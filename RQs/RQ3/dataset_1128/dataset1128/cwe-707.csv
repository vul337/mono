id,cve_id,cwe_id,language,description,commit_url,commit_msg,patch_nums,func_before,func_after,context_nums,context_data,root_cause,confidence_score,other_context_path
1,CVE-2013-0854,CWE-20,c_cpp,The mjpeg_decode_scan_progressive_ac function in libavcodec/mjpegdec.c in FFmpeg before 1.1 allows remote attackers to have an unspecified impact via crafted MJPEG data.,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=1f41cffe1e3e79620f587545bdfcbd7e6e68ed29,"\nmjpegdec: check SE.\n\nFound-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n",1,"[{""func_name"": ""mjpeg_decode_scan_progressive_ac"", ""file_path"": ""libavcodec/mjpegdec.c"", ""func_code"": ""static int mjpeg_decode_scan_progressive_ac(MJpegDecodeContext *s, int ss,\n                                            int se, int Ah, int Al)\n{\n    int mb_x, mb_y;\n    int EOBRUN = 0;\n    int c = s->comp_index[0];\n    uint8_t *data = s->picture.data[c];\n    int linesize  = s->linesize[c];\n    int last_scan = 0;\n    int16_t *quant_matrix = s->quant_matrixes[s->quant_index[c]];\n\n    if (!Al) {\n        s->coefs_finished[c] |= (1LL << (se + 1)) - (1LL << ss);\n        last_scan = !~s->coefs_finished[c];\n    }\n\n    if (s->interlaced && s->bottom_field)\n        data += linesize >> 1;\n\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        uint8_t *ptr     = data + (mb_y * linesize * 8 >> s->avctx->lowres);\n        int block_idx    = mb_y * s->block_stride[c];\n        DCTELEM (*block)[64] = &s->blocks[c][block_idx];\n        uint8_t *last_nnz    = &s->last_nnz[c][block_idx];\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++, block++, last_nnz++) {\n                int ret;\n                if (Ah)\n                    ret = decode_block_refinement(s, *block, last_nnz, s->ac_index[0],\n                                                  quant_matrix, ss, se, Al, &EOBRUN);\n                else\n                    ret = decode_block_progressive(s, *block, last_nnz, s->ac_index[0],\n                                                   quant_matrix, ss, se, Al, &EOBRUN);\n                if (ret < 0) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \""error y=%d x=%d\\n\"", mb_y, mb_x);\n                    return AVERROR_INVALIDDATA;\n                }\n\n            if (last_scan) {\n                    s->dsp.idct_put(ptr, linesize, *block);\n                    ptr += 8 >> s->avctx->lowres;\n            }\n        }\n    }\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""mjpeg_decode_scan_progressive_ac"", ""file_path"": ""libavcodec/mjpegdec.c"", ""func_code"": ""static int mjpeg_decode_scan_progressive_ac(MJpegDecodeContext *s, int ss,\n                                            int se, int Ah, int Al)\n{\n    int mb_x, mb_y;\n    int EOBRUN = 0;\n    int c = s->comp_index[0];\n    uint8_t *data = s->picture.data[c];\n    int linesize  = s->linesize[c];\n    int last_scan = 0;\n    int16_t *quant_matrix = s->quant_matrixes[s->quant_index[c]];\n\n    if (se > 63) {\n        av_log(s->avctx, AV_LOG_ERROR, \""SE %d is too large\\n\"", se);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!Al) {\n        s->coefs_finished[c] |= (1LL << (se + 1)) - (1LL << ss);\n        last_scan = !~s->coefs_finished[c];\n    }\n\n    if (s->interlaced && s->bottom_field)\n        data += linesize >> 1;\n\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        uint8_t *ptr     = data + (mb_y * linesize * 8 >> s->avctx->lowres);\n        int block_idx    = mb_y * s->block_stride[c];\n        DCTELEM (*block)[64] = &s->blocks[c][block_idx];\n        uint8_t *last_nnz    = &s->last_nnz[c][block_idx];\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++, block++, last_nnz++) {\n                int ret;\n                if (Ah)\n                    ret = decode_block_refinement(s, *block, last_nnz, s->ac_index[0],\n                                                  quant_matrix, ss, se, Al, &EOBRUN);\n                else\n                    ret = decode_block_progressive(s, *block, last_nnz, s->ac_index[0],\n                                                   quant_matrix, ss, se, Al, &EOBRUN);\n                if (ret < 0) {\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \""error y=%d x=%d\\n\"", mb_y, mb_x);\n                    return AVERROR_INVALIDDATA;\n                }\n\n            if (last_scan) {\n                    s->dsp.idct_put(ptr, linesize, *block);\n                    ptr += 8 >> s->avctx->lowres;\n            }\n        }\n    }\n    return 0;\n}""}]","{""value"": 1, ""code"": 1, ""caller"": 1}","[{""source"": ""value_info(file:mjpegdec.c, value:se)"", ""result"": {""value_trace"": [{""full_code"": ""offset = (linesize[c] * (s->v_scount[i] *\n                         (8 * s->mb_height - ((s->height / s->v_max) & 7)) - 1))"", ""line"": 982, ""func_name"": ""mjpeg_decode_scan""}, {""full_code"": ""block_offset = (((linesize[c] * (v * mb_y + y) * 8) +\n                                     (h * mb_x + x) * 8) >> s->avctx->lowres)"", ""line"": 1013, ""func_name"": ""mjpeg_decode_scan""}, {""full_code"": ""block_offset += linesize[c] >> 1"", ""line"": 1017, ""func_name"": ""mjpeg_decode_scan""}, {""full_code"": "".close          = ff_mjpeg_decode_end"", ""line"": 1857, ""func_name"": ""libavcodec/mjpegdec.c:<global>""}], ""struct_var"": ""se"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""code_info(file:mjpegdec.c, lines:1080-1110)"", ""result"": ""                }\n            }\n        }\n    }\n    return 0;\n}\n\nstatic int mjpeg_decode_scan_progressive_ac(MJpegDecodeContext *s, int ss,\n                                            int se, int Ah, int Al)\n{\n    int mb_x, mb_y;\n    int EOBRUN = 0;\n    int c = s->comp_index[0];\n    uint8_t *data = s->picture.data[c];\n    int linesize  = s->linesize[c];\n    int last_scan = 0;\n    int16_t *quant_matrix = s->quant_matrixes[s->quant_index[c]];\n\n    if (!Al) {\n        s->coefs_finished[c] |= (1LL << (se + 1)) - (1LL << ss);\n        last_scan = !~s->coefs_finished[c];\n    }\n\n    if (s->interlaced && s->bottom_field)\n        data += linesize >> 1;\n\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        uint8_t *ptr     = data + (mb_y * linesize * 8 >> s->avctx->lowres);\n        int block_idx    = mb_y * s->block_stride[c];\n        DCTELEM (*block)[64] = &s->blocks[c][block_idx];\n        uint8_t *last_nnz    = &s->last_nnz[c][block_idx];\n""}, {""source"": ""caller_info(file:mjpegdec.c, func:mjpeg_decode_scan_progressive_ac)"", ""result"": [{""call_line"": 1257, ""call_code"": ""mjpeg_decode_scan_progressive_ac(s, predictor,\n                                                        ilv, prev_shift,\n                                                        point_transform)"", ""caller_code"": ""int ff_mjpeg_decode_sos(MJpegDecodeContext *s, const uint8_t *mb_bitmask,\n                        const AVFrame *reference)\n{\n    int len, nb_components, i, h, v, predictor, point_transform;\n    int index, id, ret;\n    const int block_size = s->lossless ? 1 : 8;\n    int ilv, prev_shift;\n\n    if (!s->got_picture) {\n        av_log(s->avctx, AV_LOG_WARNING,\n                \""Can not process SOS before SOF, skipping\\n\"");\n        return -1;\n    }\n\n    av_assert0(s->picture_ptr->data[0]);\n    /* XXX: verify len field validity */\n    len = get_bits(&s->gb, 16);\n    nb_components = get_bits(&s->gb, 8);\n    if (nb_components == 0 || nb_components > MAX_COMPONENTS) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""decode_sos: nb_components (%d) unsupported\\n\"", nb_components);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (len != 6 + 2 * nb_components) {\n        av_log(s->avctx, AV_LOG_ERROR, \""decode_sos: invalid len (%d)\\n\"", len);\n        return AVERROR_INVALIDDATA;\n    }\n    for (i = 0; i < nb_components; i++) {\n        id = get_bits(&s->gb, 8) - 1;\n        av_log(s->avctx, AV_LOG_DEBUG, \""component: %d\\n\"", id);\n        /* find component index */\n        for (index = 0; index < s->nb_components; index++)\n            if (id == s->component_id[index])\n                break;\n        if (index == s->nb_components) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \""decode_sos: index(%d) out of components\\n\"", index);\n            return AVERROR_INVALIDDATA;\n        }\n        /* Metasoft MJPEG codec has Cb and Cr swapped */\n        if (s->avctx->codec_tag == MKTAG('M', 'T', 'S', 'J')\n            && nb_components == 3 && s->nb_components == 3 && i)\n            index = 3 - i;\n\n        if(nb_components == 3 && s->nb_components == 3 && s->avctx->pix_fmt == AV_PIX_FMT_GBR24P)\n            index = (i+2)%3;\n        if(nb_components == 1 && s->nb_components == 3 && s->avctx->pix_fmt == AV_PIX_FMT_GBR24P)\n            index = (index+2)%3;\n\n        s->comp_index[i] = index;\n\n        s->nb_blocks[i] = s->h_count[index] * s->v_count[index];\n        s->h_scount[i]  = s->h_count[index];\n        s->v_scount[i]  = s->v_count[index];\n\n        s->dc_index[i] = get_bits(&s->gb, 4);\n        s->ac_index[i] = get_bits(&s->gb, 4);\n\n        if (s->dc_index[i] <  0 || s->ac_index[i] < 0 ||\n            s->dc_index[i] >= 4 || s->ac_index[i] >= 4)\n            goto out_of_range;\n        if (!s->vlcs[0][s->dc_index[i]].table || !(s->progressive ? s->vlcs[2][s->ac_index[0]].table : s->vlcs[1][s->ac_index[i]].table))\n            goto out_of_range;\n    }\n\n    predictor = get_bits(&s->gb, 8);       /* JPEG Ss / lossless JPEG predictor /JPEG-LS NEAR */\n    ilv = get_bits(&s->gb, 8);             /* JPEG Se / JPEG-LS ILV */\n    if(s->avctx->codec_tag != AV_RL32(\""CJPG\"")){\n        prev_shift      = get_bits(&s->gb, 4); /* Ah */\n        point_transform = get_bits(&s->gb, 4); /* Al */\n    }else\n        prev_shift = point_transform = 0;\n\n    if (nb_components > 1) {\n        /* interleaved stream */\n        s->mb_width  = (s->width  + s->h_max * block_size - 1) / (s->h_max * block_size);\n        s->mb_height = (s->height + s->v_max * block_size - 1) / (s->v_max * block_size);\n    } else if (!s->ls) { /* skip this for JPEG-LS */\n        h = s->h_max / s->h_scount[0];\n        v = s->v_max / s->v_scount[0];\n        s->mb_width     = (s->width  + h * block_size - 1) / (h * block_size);\n        s->mb_height    = (s->height + v * block_size - 1) / (v * block_size);\n        s->nb_blocks[0] = 1;\n        s->h_scount[0]  = 1;\n        s->v_scount[0]  = 1;\n    }\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(s->avctx, AV_LOG_DEBUG, \""%s %s p:%d >>:%d ilv:%d bits:%d skip:%d %s comp:%d\\n\"",\n               s->lossless ? \""lossless\"" : \""sequential DCT\"", s->rgb ? \""RGB\"" : \""\"",\n               predictor, point_transform, ilv, s->bits, s->mjpb_skiptosod,\n               s->pegasus_rct ? \""PRCT\"" : (s->rct ? \""RCT\"" : \""\""), nb_components);\n\n\n    /* mjpeg-b can have padding bytes between sos and image data, skip them */\n    for (i = s->mjpb_skiptosod; i > 0; i--)\n        skip_bits(&s->gb, 8);\n\nnext_field:\n    for (i = 0; i < nb_components; i++)\n        s->last_dc[i] = 1024;\n\n    if (s->lossless) {\n        av_assert0(s->picture_ptr == &s->picture);\n        if (CONFIG_JPEGLS_DECODER && s->ls) {\n//            for () {\n//            reset_ls_coding_parameters(s, 0);\n\n            if ((ret = ff_jpegls_decode_picture(s, predictor,\n                                                point_transform, ilv)) < 0)\n                return ret;\n        } else {\n            if (s->rgb) {\n                if ((ret = ljpeg_decode_rgb_scan(s, nb_components, predictor, point_transform)) < 0)\n                    return ret;\n            } else {\n                if ((ret = ljpeg_decode_yuv_scan(s, predictor, point_transform)) < 0)\n                    return ret;\n            }\n        }\n    } else {\n        if (s->progressive && predictor) {\n            av_assert0(s->picture_ptr == &s->picture);\n            if ((ret = mjpeg_decode_scan_progressive_ac(s, predictor,\n                                                        ilv, prev_shift,\n                                                        point_transform)) < 0)\n                return ret;\n        } else {\n            if ((ret = mjpeg_decode_scan(s, nb_components,\n                                         prev_shift, point_transform,\n                                         mb_bitmask, reference)) < 0)\n                return ret;\n        }\n    }\n\n    if (s->interlaced &&\n        get_bits_left(&s->gb) > 32 &&\n        show_bits(&s->gb, 8) == 0xFF) {\n        GetBitContext bak = s->gb;\n        align_get_bits(&bak);\n        if (show_bits(&bak, 16) == 0xFFD1) {\n            av_log(s->avctx, AV_LOG_DEBUG, \""AVRn interlaced picture marker found\\n\"");\n            s->gb = bak;\n            skip_bits(&s->gb, 16);\n            s->bottom_field ^= 1;\n\n            goto next_field;\n        }\n    }\n\n    emms_c();\n    return 0;\n out_of_range:\n    av_log(s->avctx, AV_LOG_ERROR, \""decode_sos: ac/dc index out of range\\n\"");\n    return AVERROR_INVALIDDATA;\n}\n"", ""caller_start"": 1134, ""file_path"": ""libavcodec/mjpegdec.c""}]}]","libavcodec/mjpegdec.c: The 'se' parameter in mjpeg_decode_scan_progressive_ac (line 1095) is derived from 'ilv' in ff_mjpeg_decode_sos (line 1257), which is read from input data via get_bits(&s->gb, 8) (line 1234) without validation. Prior to the patch, 'se' (0–255) was used without ensuring it is ≤63, enabling crafted MJPEG data to trigger undefined behavior.",0.95,./videolan/other_context/CVE-2013-0854
2,CVE-2013-3672,CWE-20,c_cpp,"The mm_decode_inter function in mmvideo.c in libavcodec in FFmpeg before 1.2.1 does not validate the relationship between a horizontal coordinate and a width value, which allows remote attackers to cause a denial of service (out-of-bounds array access and application crash) via crafted American Laser Games (ALG) MM Video data.",http://git.videolan.org/?p=ffmpeg.git;a=commit;h=7fa6db2545643efb4fe2e0bb501fa50af35a6330,"\nmmvideo/mm_decode_inter: check horizontal coordinate too\n\nFixes out of array accesses\n\nFound-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 8d3c99e825317b7efda5fd12e69896b47c700303)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n",1,"[{""func_name"": ""mm_decode_inter"", ""file_path"": ""libavcodec/mmvideo.c"", ""func_code"": ""static int mm_decode_inter(MmContext * s, int half_horiz, int half_vert)\n{\n    int data_off = bytestream2_get_le16(&s->gb), y = 0;\n    GetByteContext data_ptr;\n\n    if (bytestream2_get_bytes_left(&s->gb) < data_off)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&data_ptr, s->gb.buffer + data_off, bytestream2_get_bytes_left(&s->gb) - data_off);\n    while (s->gb.buffer < data_ptr.buffer_start) {\n        int i, j;\n        int length = bytestream2_get_byte(&s->gb);\n        int x = bytestream2_get_byte(&s->gb) + ((length & 0x80) << 1);\n        length &= 0x7F;\n\n        if (length==0) {\n            y += x;\n            continue;\n        }\n\n        if (y + half_vert >= s->avctx->height)\n            return 0;\n\n        for(i=0; i<length; i++) {\n            int replace_array = bytestream2_get_byte(&s->gb);\n            for(j=0; j<8; j++) {\n                int replace = (replace_array >> (7-j)) & 1;\n                if (replace) {\n                    int color = bytestream2_get_byte(&data_ptr);\n                    s->frame.data[0][y*s->frame.linesize[0] + x] = color;\n                    if (half_horiz)\n                        s->frame.data[0][y*s->frame.linesize[0] + x + 1] = color;\n                    if (half_vert) {\n                        s->frame.data[0][(y+1)*s->frame.linesize[0] + x] = color;\n                        if (half_horiz)\n                            s->frame.data[0][(y+1)*s->frame.linesize[0] + x + 1] = color;\n                    }\n                }\n                x += 1 + half_horiz;\n            }\n        }\n\n        y += 1 + half_vert;\n    }\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""mm_decode_inter"", ""file_path"": ""libavcodec/mmvideo.c"", ""func_code"": ""static int mm_decode_inter(MmContext * s, int half_horiz, int half_vert)\n{\n    int data_off = bytestream2_get_le16(&s->gb), y = 0;\n    GetByteContext data_ptr;\n\n    if (bytestream2_get_bytes_left(&s->gb) < data_off)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&data_ptr, s->gb.buffer + data_off, bytestream2_get_bytes_left(&s->gb) - data_off);\n    while (s->gb.buffer < data_ptr.buffer_start) {\n        int i, j;\n        int length = bytestream2_get_byte(&s->gb);\n        int x = bytestream2_get_byte(&s->gb) + ((length & 0x80) << 1);\n        length &= 0x7F;\n\n        if (length==0) {\n            y += x;\n            continue;\n        }\n\n        if (y + half_vert >= s->avctx->height)\n            return 0;\n\n        for(i=0; i<length; i++) {\n            int replace_array = bytestream2_get_byte(&s->gb);\n            for(j=0; j<8; j++) {\n                int replace = (replace_array >> (7-j)) & 1;\n                if (x + half_horiz >= s->avctx->width)\n                    return AVERROR_INVALIDDATA;\n                if (replace) {\n                    int color = bytestream2_get_byte(&data_ptr);\n                    s->frame.data[0][y*s->frame.linesize[0] + x] = color;\n                    if (half_horiz)\n                        s->frame.data[0][y*s->frame.linesize[0] + x + 1] = color;\n                    if (half_vert) {\n                        s->frame.data[0][(y+1)*s->frame.linesize[0] + x] = color;\n                        if (half_horiz)\n                            s->frame.data[0][(y+1)*s->frame.linesize[0] + x + 1] = color;\n                    }\n                }\n                x += 1 + half_horiz;\n            }\n        }\n\n        y += 1 + half_vert;\n    }\n\n    return 0;\n}""}]","{""value"": 1, ""code"": 1, ""function"": 1, ""caller"": 1}","[{""source"": ""value_info(file:mmvideo.c, value:x)"", ""result"": {""value_trace"": [{""full_code"": ""x = 0"", ""line"": 88, ""func_name"": ""mm_decode_intra""}, {""full_code"": ""x+= run_length"", ""line"": 112, ""func_name"": ""mm_decode_intra""}, {""full_code"": ""x=0"", ""line"": 115, ""func_name"": ""mm_decode_intra""}, {""full_code"": ""x = bytestream2_get_byte(&s->gb) + ((length & 0x80) << 1)"", ""line"": 139, ""func_name"": ""mm_decode_inter""}, {""full_code"": ""x += 1 + half_horiz"", ""line"": 165, ""func_name"": ""mm_decode_inter""}], ""struct_var"": ""x"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""code_info(file:mmvideo.c, lines:130-170)"", ""result"": ""    GetByteContext data_ptr;\n\n    if (bytestream2_get_bytes_left(&s->gb) < data_off)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&data_ptr, s->gb.buffer + data_off, bytestream2_get_bytes_left(&s->gb) - data_off);\n    while (s->gb.buffer < data_ptr.buffer_start) {\n        int i, j;\n        int length = bytestream2_get_byte(&s->gb);\n        int x = bytestream2_get_byte(&s->gb) + ((length & 0x80) << 1);\n        length &= 0x7F;\n\n        if (length==0) {\n            y += x;\n            continue;\n        }\n\n        if (y + half_vert >= s->avctx->height)\n            return 0;\n\n        for(i=0; i<length; i++) {\n            int replace_array = bytestream2_get_byte(&s->gb);\n            for(j=0; j<8; j++) {\n                int replace = (replace_array >> (7-j)) & 1;\n                if (replace) {\n                    int color = bytestream2_get_byte(&data_ptr);\n                    s->frame.data[0][y*s->frame.linesize[0] + x] = color;\n                    if (half_horiz)\n                        s->frame.data[0][y*s->frame.linesize[0] + x + 1] = color;\n                    if (half_vert) {\n                        s->frame.data[0][(y+1)*s->frame.linesize[0] + x] = color;\n                        if (half_horiz)\n                            s->frame.data[0][(y+1)*s->frame.linesize[0] + x + 1] = color;\n                    }\n                }\n                x += 1 + half_horiz;\n            }\n        }\n\n        y += 1 + half_vert;\n    }\n""}, {""source"": ""func_info(file:mmvideo.c, func:mm_decode_inter)"", ""result"": [{""code"": ""static int mm_decode_inter(MmContext * s, int half_horiz, int half_vert)\n{\n    int data_off = bytestream2_get_le16(&s->gb), y = 0;\n    GetByteContext data_ptr;\n\n    if (bytestream2_get_bytes_left(&s->gb) < data_off)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&data_ptr, s->gb.buffer + data_off, bytestream2_get_bytes_left(&s->gb) - data_off);\n    while (s->gb.buffer < data_ptr.buffer_start) {\n        int i, j;\n        int length = bytestream2_get_byte(&s->gb);\n        int x = bytestream2_get_byte(&s->gb) + ((length & 0x80) << 1);\n        length &= 0x7F;\n\n        if (length==0) {\n            y += x;\n            continue;\n        }\n\n        if (y + half_vert >= s->avctx->height)\n            return 0;\n\n        for(i=0; i<length; i++) {\n            int replace_array = bytestream2_get_byte(&s->gb);\n            for(j=0; j<8; j++) {\n                int replace = (replace_array >> (7-j)) & 1;\n                if (replace) {\n                    int color = bytestream2_get_byte(&data_ptr);\n                    s->frame.data[0][y*s->frame.linesize[0] + x] = color;\n                    if (half_horiz)\n                        s->frame.data[0][y*s->frame.linesize[0] + x + 1] = color;\n                    if (half_vert) {\n                        s->frame.data[0][(y+1)*s->frame.linesize[0] + x] = color;\n                        if (half_horiz)\n                            s->frame.data[0][(y+1)*s->frame.linesize[0] + x + 1] = color;\n                    }\n                }\n                x += 1 + half_horiz;\n            }\n        }\n\n        y += 1 + half_vert;\n    }\n\n    return 0;\n}\n"", ""start_line"": 127, ""end_line"": 173, ""full_name"": ""mm_decode_inter"", ""file_path"": ""libavcodec/mmvideo.c""}]}, {""source"": ""caller_info(file:mmvideo.c, func:mm_decode_inter)"", ""result"": [{""call_line"": 201, ""call_code"": ""mm_decode_inter(s, 0, 0)"", ""caller_code"": ""static int mm_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    MmContext *s = avctx->priv_data;\n    int type, res;\n\n    if (buf_size < MM_PREAMBLE_SIZE)\n        return AVERROR_INVALIDDATA;\n    type = AV_RL16(&buf[0]);\n    buf += MM_PREAMBLE_SIZE;\n    buf_size -= MM_PREAMBLE_SIZE;\n    bytestream2_init(&s->gb, buf, buf_size);\n\n    if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \""reget_buffer() failed\\n\"");\n        return res;\n    }\n\n    switch(type) {\n    case MM_TYPE_PALETTE   : res = mm_decode_pal(s); return avpkt->size;\n    case MM_TYPE_INTRA     : res = mm_decode_intra(s, 0, 0); break;\n    case MM_TYPE_INTRA_HH  : res = mm_decode_intra(s, 1, 0); break;\n    case MM_TYPE_INTRA_HHV : res = mm_decode_intra(s, 1, 1); break;\n    case MM_TYPE_INTER     : res = mm_decode_inter(s, 0, 0); break;\n    case MM_TYPE_INTER_HH  : res = mm_decode_inter(s, 1, 0); break;\n    case MM_TYPE_INTER_HHV : res = mm_decode_inter(s, 1, 1); break;\n    default:\n        res = AVERROR_INVALIDDATA;\n        break;\n    }\n    if (res < 0)\n        return res;\n\n    memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);\n\n    *got_frame      = 1;\n    *(AVFrame*)data = s->frame;\n\n    return avpkt->size;\n}\n"", ""caller_start"": 175, ""file_path"": ""libavcodec/mmvideo.c""}, {""call_line"": 202, ""call_code"": ""mm_decode_inter(s, 1, 0)"", ""caller_code"": ""static int mm_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    MmContext *s = avctx->priv_data;\n    int type, res;\n\n    if (buf_size < MM_PREAMBLE_SIZE)\n        return AVERROR_INVALIDDATA;\n    type = AV_RL16(&buf[0]);\n    buf += MM_PREAMBLE_SIZE;\n    buf_size -= MM_PREAMBLE_SIZE;\n    bytestream2_init(&s->gb, buf, buf_size);\n\n    if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \""reget_buffer() failed\\n\"");\n        return res;\n    }\n\n    switch(type) {\n    case MM_TYPE_PALETTE   : res = mm_decode_pal(s); return avpkt->size;\n    case MM_TYPE_INTRA     : res = mm_decode_intra(s, 0, 0); break;\n    case MM_TYPE_INTRA_HH  : res = mm_decode_intra(s, 1, 0); break;\n    case MM_TYPE_INTRA_HHV : res = mm_decode_intra(s, 1, 1); break;\n    case MM_TYPE_INTER     : res = mm_decode_inter(s, 0, 0); break;\n    case MM_TYPE_INTER_HH  : res = mm_decode_inter(s, 1, 0); break;\n    case MM_TYPE_INTER_HHV : res = mm_decode_inter(s, 1, 1); break;\n    default:\n        res = AVERROR_INVALIDDATA;\n        break;\n    }\n    if (res < 0)\n        return res;\n\n    memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);\n\n    *got_frame      = 1;\n    *(AVFrame*)data = s->frame;\n\n    return avpkt->size;\n}\n"", ""caller_start"": 175, ""file_path"": ""libavcodec/mmvideo.c""}, {""call_line"": 203, ""call_code"": ""mm_decode_inter(s, 1, 1)"", ""caller_code"": ""static int mm_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    MmContext *s = avctx->priv_data;\n    int type, res;\n\n    if (buf_size < MM_PREAMBLE_SIZE)\n        return AVERROR_INVALIDDATA;\n    type = AV_RL16(&buf[0]);\n    buf += MM_PREAMBLE_SIZE;\n    buf_size -= MM_PREAMBLE_SIZE;\n    bytestream2_init(&s->gb, buf, buf_size);\n\n    if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \""reget_buffer() failed\\n\"");\n        return res;\n    }\n\n    switch(type) {\n    case MM_TYPE_PALETTE   : res = mm_decode_pal(s); return avpkt->size;\n    case MM_TYPE_INTRA     : res = mm_decode_intra(s, 0, 0); break;\n    case MM_TYPE_INTRA_HH  : res = mm_decode_intra(s, 1, 0); break;\n    case MM_TYPE_INTRA_HHV : res = mm_decode_intra(s, 1, 1); break;\n    case MM_TYPE_INTER     : res = mm_decode_inter(s, 0, 0); break;\n    case MM_TYPE_INTER_HH  : res = mm_decode_inter(s, 1, 0); break;\n    case MM_TYPE_INTER_HHV : res = mm_decode_inter(s, 1, 1); break;\n    default:\n        res = AVERROR_INVALIDDATA;\n        break;\n    }\n    if (res < 0)\n        return res;\n\n    memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);\n\n    *got_frame      = 1;\n    *(AVFrame*)data = s->frame;\n\n    return avpkt->size;\n}\n"", ""caller_start"": 175, ""file_path"": ""libavcodec/mmvideo.c""}]}]",libavcodec/mmvideo.c:152-154: Unvalidated 'x + half_horiz' calculation in mm_decode_inter leads to out-of-bounds access. 'x' is derived from bytestream2_get_byte (libavcodec/mmvideo.c:139) and modified via x += 1 + half_horiz (libavcodec/mmvideo.c:165). 'half_horiz' is a function parameter set by mm_decode_frame (libavcodec/mmvideo.c:201-203) based on input data type.,0.95,./videolan/other_context/CVE-2013-3672
3,CVE-2012-6696,CWE-20,c_cpp,inspircd in Debian before 2.0.7 does not properly handle unsigned integers.  NOTE: This vulnerability exists because of an incomplete fix to CVE-2012-1836.,https://github.com/inspircd/inspircd/commit/ed28c1ba666b39581adb860bf51cdde43c84cc89,Fixed out of bounds memory access from malformed DNS queries that have an invalid length label. Introduced in a6a07de0daa353bcd29056a4535a9c4784c113c8.,1,"[{""func_name"": ""DNSRequest::ResultIsReady"", ""file_path"": ""src/dns.cpp"", ""func_code"": ""DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)\n{\n\tunsigned i = 0, o;\n\tint q = 0;\n\tint curanswer;\n\tResourceRecord rr;\n \tunsigned short ptr;\n\n\t/* This is just to keep _FORTIFY_SOURCE happy */\n\trr.type = DNS_QUERY_NONE;\n\trr.rdlength = 0;\n\trr.ttl = 1;\t/* GCC is a whiney bastard -- see the XXX below. */\n\trr.rr_class = 0; /* Same for VC++ */\n\n\tif (!(header.flags1 & FLAGS_MASK_QR))\n\t\treturn std::make_pair((unsigned char*)NULL,\""Not a query result\"");\n\n\tif (header.flags1 & FLAGS_MASK_OPCODE)\n\t\treturn std::make_pair((unsigned char*)NULL,\""Unexpected value in DNS reply packet\"");\n\n\tif (header.flags2 & FLAGS_MASK_RCODE)\n\t\treturn std::make_pair((unsigned char*)NULL,\""Domain name not found\"");\n\n\tif (header.ancount < 1)\n\t\treturn std::make_pair((unsigned char*)NULL,\""No resource records returned\"");\n\n\t/* Subtract the length of the header from the length of the packet */\n\tlength -= 12;\n\n\twhile ((unsigned int)q < header.qdcount && i < length)\n\t{\n\t\tif (header.payload[i] > 63)\n\t\t{\n\t\t\ti += 6;\n\t\t\tq++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (header.payload[i] == 0)\n\t\t\t{\n\t\t\t\tq++;\n\t\t\t\ti += 5;\n\t\t\t}\n\t\t\telse i += header.payload[i] + 1;\n\t\t}\n\t}\n\tcuranswer = 0;\n\twhile ((unsigned)curanswer < header.ancount)\n\t{\n\t\tq = 0;\n\t\twhile (q == 0 && i < length)\n\t\t{\n\t\t\tif (header.payload[i] > 63)\n\t\t\t{\n\t\t\t\ti += 2;\n\t\t\t\tq = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (header.payload[i] == 0)\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tq = 1;\n\t\t\t\t}\n\t\t\t\telse i += header.payload[i] + 1; /* skip length and label */\n\t\t\t}\n\t\t}\n\t\tif (length - i < 10)\n\t\t\treturn std::make_pair((unsigned char*)NULL,\""Incorrectly sized DNS reply\"");\n\n\t\t/* XXX: We actually initialise 'rr' here including its ttl field */\n\t\tDNS::FillResourceRecord(&rr,&header.payload[i]);\n\n\t\ti += 10;\n\t\tServerInstance->Logs->Log(\""RESOLVER\"",DEBUG,\""Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d\"", rr.type, this->type, rr.rr_class, this->rr_class);\n\t\tif (rr.type != this->type)\n\t\t{\n\t\t\tcuranswer++;\n\t\t\ti += rr.rdlength;\n\t\t\tcontinue;\n\t\t}\n\t\tif (rr.rr_class != this->rr_class)\n\t\t{\n\t\t\tcuranswer++;\n\t\t\ti += rr.rdlength;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif ((unsigned int)curanswer == header.ancount)\n\t\treturn std::make_pair((unsigned char*)NULL,\""No A, AAAA or PTR type answers (\"" + ConvToStr(header.ancount) + \"" answers)\"");\n\n\tif (i + rr.rdlength > (unsigned int)length)\n\t\treturn std::make_pair((unsigned char*)NULL,\""Resource record larger than stated\"");\n\n\tif (rr.rdlength > 1023)\n\t\treturn std::make_pair((unsigned char*)NULL,\""Resource record too large\"");\n\n\tthis->ttl = rr.ttl;\n\n\tswitch (rr.type)\n\t{\n\t\t/*\n\t\t * CNAME and PTR are compressed.  We need to decompress them.\n\t\t */\n\t\tcase DNS_QUERY_CNAME:\n\t\tcase DNS_QUERY_PTR:\n\t\t\to = 0;\n\t\t\tq = 0;\n\t\t\twhile (q == 0 && i < length && o + 256 < 1023)\n\t\t\t{\n\t\t\t\t/* DN label found (byte over 63) */\n\t\t\t\tif (header.payload[i] > 63)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&ptr,&header.payload[i],2);\n\n\t\t\t\t\ti = ntohs(ptr);\n\n\t\t\t\t\t/* check that highest two bits are set. if not, we've been had */\n\t\t\t\t\tif (!(i & DN_COMP_BITMASK))\n\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, \""DN label decompression header is bogus\"");\n\n\t\t\t\t\t/* mask away the two highest bits. */\n\t\t\t\t\ti &= ~DN_COMP_BITMASK;\n\n\t\t\t\t\t/* and decrease length by 12 bytes. */\n\t\t\t\t\ti =- 12;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (header.payload[i] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tq = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tres[o] = 0;\n\t\t\t\t\t\tif (o != 0)\n\t\t\t\t\t\t\tres[o++] = '.';\n\n\t\t\t\t\t\tif (o + header.payload[i] > sizeof(DNSHeader))\n\t\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, \""DN label decompression is impossible -- malformed/hostile packet?\"");\n\n\t\t\t\t\t\tmemcpy(&res[o], &header.payload[i + 1], header.payload[i]);\n\t\t\t\t\t\to += header.payload[i];\n\t\t\t\t\t\ti += header.payload[i] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[o] = 0;\n\t\tbreak;\n\t\tcase DNS_QUERY_AAAA:\n\t\t\tif (rr.rdlength != sizeof(struct in6_addr))\n\t\t\t\treturn std::make_pair((unsigned char *) NULL, \""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?\"");\n\n\t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n\t\t\tres[rr.rdlength] = 0;\n\t\tbreak;\n\t\tcase DNS_QUERY_A:\n\t\t\tif (rr.rdlength != sizeof(struct in_addr))\n\t\t\t\treturn std::make_pair((unsigned char *) NULL, \""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?\"");\n\n\t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n\t\t\tres[rr.rdlength] = 0;\n\t\tbreak;\n\t\tdefault:\n\t\t\treturn std::make_pair((unsigned char *) NULL, \""don't know how to handle undefined type (\"" + ConvToStr(rr.type) + \"") -- rejecting\"");\n\t\tbreak;\n\t}\n\treturn std::make_pair(res,\""No error\"");\n}"", ""target"": 0}]","[{""func_name"": ""DNSRequest::ResultIsReady"", ""file_path"": ""src/dns.cpp"", ""func_code"": ""DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)\n{\n\tunsigned i = 0, o;\n\tint q = 0;\n\tint curanswer;\n\tResourceRecord rr;\n \tunsigned short ptr;\n\n\t/* This is just to keep _FORTIFY_SOURCE happy */\n\trr.type = DNS_QUERY_NONE;\n\trr.rdlength = 0;\n\trr.ttl = 1;\t/* GCC is a whiney bastard -- see the XXX below. */\n\trr.rr_class = 0; /* Same for VC++ */\n\n\tif (!(header.flags1 & FLAGS_MASK_QR))\n\t\treturn std::make_pair((unsigned char*)NULL,\""Not a query result\"");\n\n\tif (header.flags1 & FLAGS_MASK_OPCODE)\n\t\treturn std::make_pair((unsigned char*)NULL,\""Unexpected value in DNS reply packet\"");\n\n\tif (header.flags2 & FLAGS_MASK_RCODE)\n\t\treturn std::make_pair((unsigned char*)NULL,\""Domain name not found\"");\n\n\tif (header.ancount < 1)\n\t\treturn std::make_pair((unsigned char*)NULL,\""No resource records returned\"");\n\n\t/* Subtract the length of the header from the length of the packet */\n\tlength -= 12;\n\n\twhile ((unsigned int)q < header.qdcount && i < length)\n\t{\n\t\tif (header.payload[i] > 63)\n\t\t{\n\t\t\ti += 6;\n\t\t\tq++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (header.payload[i] == 0)\n\t\t\t{\n\t\t\t\tq++;\n\t\t\t\ti += 5;\n\t\t\t}\n\t\t\telse i += header.payload[i] + 1;\n\t\t}\n\t}\n\tcuranswer = 0;\n\twhile ((unsigned)curanswer < header.ancount)\n\t{\n\t\tq = 0;\n\t\twhile (q == 0 && i < length)\n\t\t{\n\t\t\tif (header.payload[i] > 63)\n\t\t\t{\n\t\t\t\ti += 2;\n\t\t\t\tq = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (header.payload[i] == 0)\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tq = 1;\n\t\t\t\t}\n\t\t\t\telse i += header.payload[i] + 1; /* skip length and label */\n\t\t\t}\n\t\t}\n\t\tif (static_cast<int>(length - i) < 10)\n\t\t\treturn std::make_pair((unsigned char*)NULL,\""Incorrectly sized DNS reply\"");\n\n\t\t/* XXX: We actually initialise 'rr' here including its ttl field */\n\t\tDNS::FillResourceRecord(&rr,&header.payload[i]);\n\n\t\ti += 10;\n\t\tServerInstance->Logs->Log(\""RESOLVER\"",DEBUG,\""Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d\"", rr.type, this->type, rr.rr_class, this->rr_class);\n\t\tif (rr.type != this->type)\n\t\t{\n\t\t\tcuranswer++;\n\t\t\ti += rr.rdlength;\n\t\t\tcontinue;\n\t\t}\n\t\tif (rr.rr_class != this->rr_class)\n\t\t{\n\t\t\tcuranswer++;\n\t\t\ti += rr.rdlength;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif ((unsigned int)curanswer == header.ancount)\n\t\treturn std::make_pair((unsigned char*)NULL,\""No A, AAAA or PTR type answers (\"" + ConvToStr(header.ancount) + \"" answers)\"");\n\n\tif (i + rr.rdlength > (unsigned int)length)\n\t\treturn std::make_pair((unsigned char*)NULL,\""Resource record larger than stated\"");\n\n\tif (rr.rdlength > 1023)\n\t\treturn std::make_pair((unsigned char*)NULL,\""Resource record too large\"");\n\n\tthis->ttl = rr.ttl;\n\n\tswitch (rr.type)\n\t{\n\t\t/*\n\t\t * CNAME and PTR are compressed.  We need to decompress them.\n\t\t */\n\t\tcase DNS_QUERY_CNAME:\n\t\tcase DNS_QUERY_PTR:\n\t\t\to = 0;\n\t\t\tq = 0;\n\t\t\twhile (q == 0 && i < length && o + 256 < 1023)\n\t\t\t{\n\t\t\t\t/* DN label found (byte over 63) */\n\t\t\t\tif (header.payload[i] > 63)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&ptr,&header.payload[i],2);\n\n\t\t\t\t\ti = ntohs(ptr);\n\n\t\t\t\t\t/* check that highest two bits are set. if not, we've been had */\n\t\t\t\t\tif (!(i & DN_COMP_BITMASK))\n\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, \""DN label decompression header is bogus\"");\n\n\t\t\t\t\t/* mask away the two highest bits. */\n\t\t\t\t\ti &= ~DN_COMP_BITMASK;\n\n\t\t\t\t\t/* and decrease length by 12 bytes. */\n\t\t\t\t\ti =- 12;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (header.payload[i] == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tq = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tres[o] = 0;\n\t\t\t\t\t\tif (o != 0)\n\t\t\t\t\t\t\tres[o++] = '.';\n\n\t\t\t\t\t\tif (o + header.payload[i] > sizeof(DNSHeader))\n\t\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, \""DN label decompression is impossible -- malformed/hostile packet?\"");\n\n\t\t\t\t\t\tmemcpy(&res[o], &header.payload[i + 1], header.payload[i]);\n\t\t\t\t\t\to += header.payload[i];\n\t\t\t\t\t\ti += header.payload[i] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[o] = 0;\n\t\tbreak;\n\t\tcase DNS_QUERY_AAAA:\n\t\t\tif (rr.rdlength != sizeof(struct in6_addr))\n\t\t\t\treturn std::make_pair((unsigned char *) NULL, \""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?\"");\n\n\t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n\t\t\tres[rr.rdlength] = 0;\n\t\tbreak;\n\t\tcase DNS_QUERY_A:\n\t\t\tif (rr.rdlength != sizeof(struct in_addr))\n\t\t\t\treturn std::make_pair((unsigned char *) NULL, \""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?\"");\n\n\t\t\tmemcpy(res,&header.payload[i],rr.rdlength);\n\t\t\tres[rr.rdlength] = 0;\n\t\tbreak;\n\t\tdefault:\n\t\t\treturn std::make_pair((unsigned char *) NULL, \""don't know how to handle undefined type (\"" + ConvToStr(rr.type) + \"") -- rejecting\"");\n\t\tbreak;\n\t}\n\treturn std::make_pair(res,\""No error\"");\n}""}]","{""value"": 4, ""function"": 1}","[{""source"": ""value_info(file:dns.cpp, value:length)"", ""result"": {""value_trace"": [{""full_code"": ""length = tempchr - tempchr2"", ""line"": 395, ""func_name"": ""DNS.MakePayload:int(char*,QueryType,shortunsigned,unsigned char*)""}, {""full_code"": ""length = strlen(tempchr2)"", ""line"": 403, ""func_name"": ""DNS.MakePayload:int(char*,QueryType,shortunsigned,unsigned char*)""}, {""full_code"": ""length = htons(rr)"", ""line"": 415, ""func_name"": ""DNS.MakePayload:int(char*,QueryType,shortunsigned,unsigned char*)""}, {""full_code"": ""length = htons(rr_class)"", ""line"": 417, ""func_name"": ""DNS.MakePayload:int(char*,QueryType,shortunsigned,unsigned char*)""}, {""full_code"": ""length = this->MakePayload(name, DNS_QUERY_A, 1, (unsigned char*)&h.payload)"", ""line"": 429, ""func_name"": ""DNS.GetIP:int(char*)""}], ""struct_var"": ""length"", ""struct_type"": ""shortunsigned"", ""struct_definition"": ""shortunsigned""}}, {""source"": ""value_info(file:dns.cpp, value:i)"", ""result"": {""value_trace"": [{""full_code"": ""i = this->cache->begin()"", ""line"": 287, ""func_name"": ""DNS.PruneCache:int()""}, {""full_code"": ""i = 0"", ""line"": 698, ""func_name"": ""DNSRequest.ResultIsReady:DNSInfo(DNSHeader&,unsigned)""}, {""full_code"": ""i += 6"", ""line"": 729, ""func_name"": ""DNSRequest.ResultIsReady:DNSInfo(DNSHeader&,unsigned)""}, {""full_code"": ""i += 5"", ""line"": 737, ""func_name"": ""DNSRequest.ResultIsReady:DNSInfo(DNSHeader&,unsigned)""}], ""struct_var"": ""i"", ""struct_type"": ""dnscache.iterator"", ""struct_definition"": null}}, {""source"": ""value_info(file:dns.cpp, value:i)"", ""result"": {""value_trace"": [{""full_code"": ""i = this->cache->begin()"", ""line"": 287, ""func_name"": ""DNS.PruneCache:int()""}, {""full_code"": ""i = 0"", ""line"": 698, ""func_name"": ""DNSRequest.ResultIsReady:DNSInfo(DNSHeader&,unsigned)""}, {""full_code"": ""i += 6"", ""line"": 729, ""func_name"": ""DNSRequest.ResultIsReady:DNSInfo(DNSHeader&,unsigned)""}, {""full_code"": ""i += 5"", ""line"": 737, ""func_name"": ""DNSRequest.ResultIsReady:DNSInfo(DNSHeader&,unsigned)""}], ""struct_var"": ""i"", ""struct_type"": ""dnscache.iterator"", ""struct_definition"": null}}, {""source"": ""value_info(file:dns.cpp, value:i)"", ""result"": {""value_trace"": [{""full_code"": ""i = this->cache->begin()"", ""line"": 287, ""func_name"": ""DNS.PruneCache:int()""}, {""full_code"": ""i = 0"", ""line"": 698, ""func_name"": ""DNSRequest.ResultIsReady:DNSInfo(DNSHeader&,unsigned)""}, {""full_code"": ""i += 6"", ""line"": 729, ""func_name"": ""DNSRequest.ResultIsReady:DNSInfo(DNSHeader&,unsigned)""}, {""full_code"": ""i += 5"", ""line"": 737, ""func_name"": ""DNSRequest.ResultIsReady:DNSInfo(DNSHeader&,unsigned)""}], ""struct_var"": ""i"", ""struct_type"": ""dnscache.iterator"", ""struct_definition"": null}}, {""source"": ""func_info(file:dns.cpp, func:ResultIsReady)"", ""result"": [{""code"": ""DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)\n{\n\tunsigned i = 0, o;\n\tint q = 0;\n\tint curanswer;\n\tResourceRecord rr;\n \tunsigned short ptr;\n\n\t/* This is just to keep _FORTIFY_SOURCE happy */\n\trr.type = DNS_QUERY_NONE;\n\trr.rdlength = 0;\n\trr.ttl = 1;\t/* GCC is a whiney bastard -- see the XXX below. */\n\trr.rr_class = 0; /* Same for VC++ */\n\n\tif (!(header.flags1 & FLAGS_MASK_QR))\n\t\treturn std::make_pair((unsigned char*)NULL,\""Not a query result\"");\n\n\tif (header.flags1 & FLAGS_MASK_OPCODE)\n\t\treturn std::make_pair((unsigned char*)NULL,\""Unexpected value in DNS reply packet\"");\n\n\tif (header.flags2 & FLAGS_MASK_RCODE)\n\t\treturn std::make_pair((unsigned char*)NULL,\""Domain name not found\"");\n\n\tif (header.ancount < 1)\n\t\treturn std::make_pair((unsigned char*)NULL,\""No resource records returned\"");\n\n\t/* Subtract the length of the header from the length of the packet */\n\tlength -= 12;\n\n\twhile ((unsigned int)q < header.qdcount && i < length)\n\t{\n\t\tif (header.payload[i] > 63)\n\t\t{\n\t\t\ti ..."", ""start_line"": 696, ""end_line"": 866, ""full_name"": ""DNSRequest.ResultIsReady:DNSInfo(DNSHeader&,unsigned)"", ""file_path"": ""src/dns.cpp""}, {""code"": ""DNSInfo ResultIsReady(DNSHeader &h, unsigned length);"", ""start_line"": 103, ""end_line"": 103, ""full_name"": ""DNSRequest.ResultIsReady:ANY(DNSHeader&,unsigned)"", ""file_path"": ""src/dns.cpp""}]}]","src/dns.cpp:761-763: The check 'length - i < 10' uses unsigned integers ('length' as 'shortunsigned' and 'i' as 'unsigned'). When 'i' exceeds 'length', the subtraction underflows, producing a large positive value. The condition evaluates as false, allowing invalid DNS replies to bypass safety checks. The patch casts to 'int' to detect negative underflow explicitly.",0.95,./github/other_context/CVE-2012-6696
4,CVE-2012-3525,CWE-20,c_cpp,"s2s/out.c in jabberd2 2.2.16 and earlier does not verify that a request was made for an XMPP Server Dialback response, which allows remote XMPP servers to spoof domains via a (1) Verify Response or (2) Authorization Response.",https://github.com/jabberd2/jabberd2/commit/aabcffae560d5fd00cd1d2ffce5d760353cf0a4d,Fixed possibility of Unsolicited Dialback Attacks,2,"[{""func_name"": ""_out_verify"", ""file_path"": ""s2s/out.c"", ""func_code"": ""static void _out_verify(conn_t out, nad_t nad) {\n    int attr, ns;\n    jid_t from, to;\n    conn_t in;\n    char *rkey;\n    int valid;\n\n    attr = nad_find_attr(nad, 0, -1, \""from\"", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \""missing or invalid from on db verify packet\"");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \""to\"", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \""missing or invalid to on db verify packet\"");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \""id\"", NULL);\n    if(attr < 0) {\n        log_debug(ZONE, \""missing id on db verify packet\"");\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n\n    /* get the incoming conn */\n    in = xhash_getx(out->s2s->in, NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr));\n    if(in == NULL) {\n        log_debug(ZONE, \""got a verify for incoming conn %.*s, but it doesn't exist, dropping the packet\"", NAD_AVAL_L(nad, attr), NAD_AVAL(nad, attr));\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n\n    attr = nad_find_attr(nad, 0, -1, \""type\"", \""valid\"");\n    if(attr >= 0) {\n        xhash_put(in->states, pstrdup(xhash_pool(in->states), rkey), (void *) conn_VALID);\n        log_write(in->s2s->log, LOG_NOTICE, \""[%d] [%s, port=%d] incoming route '%s' is now valid%s%s\"", in->fd->fd, in->ip, in->port, rkey, (in->s->flags & SX_SSL_WRAPPER) ? \"", TLS negotiated\"" : \""\"", in->s->compressed ? \"", ZLIB compression enabled\"" : \""\"");\n        valid = 1;\n    } else {\n        log_write(in->s2s->log, LOG_NOTICE, \""[%d] [%s, port=%d] incoming route '%s' is now invalid\"", in->fd->fd, in->ip, in->port, rkey);\n        valid = 0;\n    }\n\n    free(rkey);\n\n    nad_free(nad);\n\n    /* decrement outstanding verify counter */\n    --out->verify;\n\n    /* let them know what happened */\n    nad = nad_new();\n\n    ns = nad_add_namespace(nad, uri_DIALBACK, \""db\"");\n    nad_append_elem(nad, ns, \""result\"", 0);\n    nad_append_attr(nad, -1, \""to\"", from->domain);\n    nad_append_attr(nad, -1, \""from\"", to->domain);\n    nad_append_attr(nad, -1, \""type\"", valid ? \""valid\"" : \""invalid\"");\n\n    /* off it goes */\n    sx_nad_write(in->s, nad);\n\n    /* if invalid, close the stream */\n    if (!valid) {\n        /* generate stream error */\n        sx_error(in->s, stream_err_INVALID_ID, \""dialback negotiation failed\"");\n\n        /* close the incoming stream */\n        sx_close(in->s);\n    }\n\n    jid_free(from);\n    jid_free(to);\n}"", ""target"": 0}, {""func_name"": ""_out_result"", ""file_path"": ""s2s/out.c"", ""func_code"": ""static void _out_result(conn_t out, nad_t nad) {\n    int attr;\n    jid_t from, to;\n    char *rkey;\n    int rkeylen;\n\n    attr = nad_find_attr(nad, 0, -1, \""from\"", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \""missing or invalid from on db result packet\"");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \""to\"", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \""missing or invalid to on db result packet\"");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n    rkeylen = strlen(rkey);\n\n    /* key is valid */\n    if(nad_find_attr(nad, 0, -1, \""type\"", \""valid\"") >= 0) {\n        log_write(out->s2s->log, LOG_NOTICE, \""[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\"", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \"", TLS negotiated\"" : \""\"", out->s->compressed ? \"", ZLIB compression enabled\"" : \""\"");\n\n        xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    /* !!! small leak here */\n\n        log_debug(ZONE, \""%s valid, flushing queue\"", rkey);\n\n        /* flush the queue */\n        out_flush_route_queue(out->s2s, rkey, rkeylen);\n\n        free(rkey);\n\n        jid_free(from);\n        jid_free(to);\n\n        nad_free(nad);\n\n        return;\n    }\n\n    /* invalid */\n    log_write(out->s2s->log, LOG_NOTICE, \""[%d] [%s, port=%d] outgoing route '%s' is now invalid\"", out->fd->fd, out->ip, out->port, rkey);\n\n    /* close connection */\n    log_write(out->s2s->log, LOG_NOTICE, \""[%d] [%s, port=%d] closing connection\"", out->fd->fd, out->ip, out->port);\n\n    /* report stream error */\n    sx_error(out->s, stream_err_INVALID_ID, \""dialback negotiation failed\"");\n\n    /* close the stream */\n    sx_close(out->s);\n\n    /* bounce queue */\n    out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n\n    free(rkey);\n\n    jid_free(from);\n    jid_free(to);\n\n    nad_free(nad);\n}"", ""target"": 0}]","[{""func_name"": ""_out_verify"", ""file_path"": ""s2s/out.c"", ""func_code"": ""static void _out_verify(conn_t out, nad_t nad) {\n    int attr, ns;\n    jid_t from, to;\n    conn_t in;\n    char *rkey;\n    int valid;\n\n    attr = nad_find_attr(nad, 0, -1, \""from\"", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \""missing or invalid from on db verify packet\"");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \""to\"", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \""missing or invalid to on db verify packet\"");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \""id\"", NULL);\n    if(attr < 0) {\n        log_debug(ZONE, \""missing id on db verify packet\"");\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n\n    /* get the incoming conn */\n    in = xhash_getx(out->s2s->in, NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr));\n    if(in == NULL) {\n        log_debug(ZONE, \""got a verify for incoming conn %.*s, but it doesn't exist, dropping the packet\"", NAD_AVAL_L(nad, attr), NAD_AVAL(nad, attr));\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n\n    attr = nad_find_attr(nad, 0, -1, \""type\"", \""valid\"");\n    if(attr >= 0 && xhash_get(in->states, rkey) == (void*) conn_INPROGRESS) {\n        xhash_put(in->states, pstrdup(xhash_pool(in->states), rkey), (void *) conn_VALID);\n        log_write(in->s2s->log, LOG_NOTICE, \""[%d] [%s, port=%d] incoming route '%s' is now valid%s%s\"", in->fd->fd, in->ip, in->port, rkey, (in->s->flags & SX_SSL_WRAPPER) ? \"", TLS negotiated\"" : \""\"", in->s->compressed ? \"", ZLIB compression enabled\"" : \""\"");\n        valid = 1;\n    } else {\n        log_write(in->s2s->log, LOG_NOTICE, \""[%d] [%s, port=%d] incoming route '%s' is now invalid\"", in->fd->fd, in->ip, in->port, rkey);\n        valid = 0;\n    }\n\n    free(rkey);\n\n    nad_free(nad);\n\n    /* decrement outstanding verify counter */\n    --out->verify;\n\n    /* let them know what happened */\n    nad = nad_new();\n\n    ns = nad_add_namespace(nad, uri_DIALBACK, \""db\"");\n    nad_append_elem(nad, ns, \""result\"", 0);\n    nad_append_attr(nad, -1, \""to\"", from->domain);\n    nad_append_attr(nad, -1, \""from\"", to->domain);\n    nad_append_attr(nad, -1, \""type\"", valid ? \""valid\"" : \""invalid\"");\n\n    /* off it goes */\n    sx_nad_write(in->s, nad);\n\n    /* if invalid, close the stream */\n    if (!valid) {\n        /* generate stream error */\n        sx_error(in->s, stream_err_INVALID_ID, \""dialback negotiation failed\"");\n\n        /* close the incoming stream */\n        sx_close(in->s);\n    }\n\n    jid_free(from);\n    jid_free(to);\n}""}, {""func_name"": ""_out_result"", ""file_path"": ""s2s/out.c"", ""func_code"": ""static void _out_result(conn_t out, nad_t nad) {\n    int attr;\n    jid_t from, to;\n    char *rkey;\n    int rkeylen;\n\n    attr = nad_find_attr(nad, 0, -1, \""from\"", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \""missing or invalid from on db result packet\"");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \""to\"", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \""missing or invalid to on db result packet\"");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n    rkeylen = strlen(rkey);\n\n    /* key is valid */\n    if(nad_find_attr(nad, 0, -1, \""type\"", \""valid\"") >= 0 && xhash_get(out->states, rkey) == (void*) conn_INPROGRESS) {\n        log_write(out->s2s->log, LOG_NOTICE, \""[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\"", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \"", TLS negotiated\"" : \""\"", out->s->compressed ? \"", ZLIB compression enabled\"" : \""\"");\n\n        xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    /* !!! small leak here */\n\n        log_debug(ZONE, \""%s valid, flushing queue\"", rkey);\n\n        /* flush the queue */\n        out_flush_route_queue(out->s2s, rkey, rkeylen);\n\n        free(rkey);\n\n        jid_free(from);\n        jid_free(to);\n\n        nad_free(nad);\n\n        return;\n    }\n\n    /* invalid */\n    log_write(out->s2s->log, LOG_NOTICE, \""[%d] [%s, port=%d] outgoing route '%s' is now invalid\"", out->fd->fd, out->ip, out->port, rkey);\n\n    /* close connection */\n    log_write(out->s2s->log, LOG_NOTICE, \""[%d] [%s, port=%d] closing connection\"", out->fd->fd, out->ip, out->port);\n\n    /* report stream error */\n    sx_error(out->s, stream_err_INVALID_ID, \""dialback negotiation failed\"");\n\n    /* close the stream */\n    sx_close(out->s);\n\n    /* bounce queue */\n    out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n\n    free(rkey);\n\n    jid_free(from);\n    jid_free(to);\n\n    nad_free(nad);\n}""}]","{""function"": 1, ""value"": 8, ""code"": 1}","[{""source"": ""func_info(func:s2s_route_key)"", ""result"": [{""code"": ""char *s2s_route_key(pool_t p, char *local, char *remote) {\n    char *key;\n\n    if(local == NULL) local = \""\"";\n    if(remote == NULL) remote = \""\"";\n\n    if(p == NULL)\n        key = (char *) malloc(strlen(local) + strlen(remote) + 2);\n    else\n        key = (char *) pmalloc(p, strlen(local) + strlen(remote) + 2);\n\n    sprintf(key, \""%s/%s\"", local, remote);\n\n    return key;\n}"", ""start_line"": 27, ""end_line"": 41, ""full_name"": ""s2s_route_key"", ""file_path"": ""s2s/util.c""}]}, {""source"": ""value_info(file:out.c, value:conn_INPROGRESS)"", ""result"": {""value_trace"": [{""full_code"": ""conn_INPROGRESS"", ""line"": 1363, ""func_name"": null}, {""full_code"": ""conn_INPROGRESS"", ""line"": 714, ""func_name"": null}, {""full_code"": ""conn_INPROGRESS"", ""line"": 167, ""func_name"": null}], ""struct_var"": ""conn_INPROGRESS"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:out.c, value:conn_VALID)"", ""result"": {""value_trace"": [{""full_code"": ""conn_VALID"", ""line"": 1753, ""func_name"": null}, {""full_code"": ""conn_VALID"", ""line"": 1667, ""func_name"": null}, {""full_code"": ""conn_VALID"", ""line"": 671, ""func_name"": null}], ""struct_var"": ""conn_VALID"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:out.c, value:in->states)"", ""result"": {""value_trace"": [{""full_code"": ""in->states = xhash_new(101)"", ""line"": 126, ""func_name"": ""in_mio_callback""}], ""struct_var"": ""in"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:out.c, value:out->states)"", ""result"": {""value_trace"": [{""full_code"": ""out->states"", ""line"": 167, ""func_name"": ""_out_dialback""}, {""full_code"": ""out->states"", ""line"": 668, ""func_name"": ""out_packet""}, {""full_code"": ""out->states"", ""line"": 1363, ""func_name"": ""_out_mio_callback""}, {""full_code"": ""out->states"", ""line"": 1667, ""func_name"": ""_out_result""}], ""struct_var"": ""out"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:out.c, value:conn_INPROGRESS)"", ""result"": {""value_trace"": [{""full_code"": ""conn_INPROGRESS"", ""line"": 1363, ""func_name"": null}, {""full_code"": ""conn_INPROGRESS"", ""line"": 714, ""func_name"": null}, {""full_code"": ""conn_INPROGRESS"", ""line"": 167, ""func_name"": null}], ""struct_var"": ""conn_INPROGRESS"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:out.c, value:in->states)"", ""result"": {""value_trace"": [{""full_code"": ""in->states = xhash_new(101)"", ""line"": 126, ""func_name"": ""in_mio_callback""}], ""struct_var"": ""in"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:out.c, value:out->states)"", ""result"": {""value_trace"": [{""full_code"": ""out->states"", ""line"": 167, ""func_name"": ""_out_dialback""}, {""full_code"": ""out->states"", ""line"": 668, ""func_name"": ""out_packet""}, {""full_code"": ""out->states"", ""line"": 1363, ""func_name"": ""_out_mio_callback""}, {""full_code"": ""out->states"", ""line"": 1667, ""func_name"": ""_out_result""}], ""struct_var"": ""out"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:out.c, lines:0-200)"", ""result"": ""/*\n * jabberd - Jabber Open Source Server\n * Copyright (c) 2002 Jeremie Miller, Thomas Muldowney,\n *                    Ryan Eatmon, Robert Norris\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA\n */\n\n#define _GNU_SOURCE\n#include <string.h>\n\n#include \""s2s.h\""\n\n#include <idna.h>\n\n/*\n * we handle packets going from the router to the world, and stuff\n * that comes in on connections we initiated.\n *\n * action points:\n *\n *   out_packet(s2s, nad) - send this packet out\n *     - extract to domain\n *     - get dbconn for this domain using out_route\n *       - if dbconn not available bounce packet\n *       - DONE\n *     - if conn in progress (tcp)\n *       - add packet to queue for this domain\n *       - DONE\n *     - if dbconn state valid for this domain, or packet is dialback\n *       - send packet\n *       - DONE\n *     - if dbconn state invalid for this domain\n *       - bounce packet (502)\n *       - DONE\n *     - add packet to queue for this domain\n *     - if dbconn state inprogress for this domain\n *       - DONE\n *     - out_dialback(dbconn, from, to)\n *\n *   out_route(s2s, route, out, allow_bad)\n *     - if dbconn not found\n *       - check internal resolver cache for domain\n *       - if not found\n *         - ask resolver for name\n *         - DONE\n *       - if outgoing ip/port is to be reused\n *         - get dbconn for any valid ip/port\n *         - if dbconn not found\n *            - create new dbconn\n *            - initiate connect to ip/port\n *            - DONE\n *       - create new dbconn\n *       - initiate connect to ip/port\n *       - DONE\n *\n *   out_dialback(dbconn, from, to) - initiate dialback\n *     - generate dbkey: sha1(secret+remote+stream id)\n *     - send auth request: <result to='them' from='us'>dbkey</result>\n *     - set dbconn state for this domain to inprogress\n *     - DONE\n *\n *   out_resolve(s2s, query) - responses from resolver\n *     - store ip/port/ttl in resolver cache\n *     - flush domain queue -> out_packet(s2s, domain)\n *     - DONE\n *\n *   event_STREAM - ip/port open\n *     - get dbconn for this sx\n *     - for each route handled by this conn, out_dialback(dbconn, from, to)\n *     - DONE\n *\n *   event_PACKET: <result from='them' to='us' type='xxx'/> - response to our auth request\n *     - get dbconn for this sx\n *     - if type valid\n *       - set dbconn state for this domain to valid\n *       - flush dbconn queue for this domain -> out_packet(s2s, pkt)\n *       - DONE\n *     - set dbconn state for this domain to invalid\n *     - bounce dbconn queue for this domain (502)\n *     - DONE\n *\n *   event_PACKET: <verify from='them' to='us' id='123' type='xxx'/> - incoming stream authenticated\n *     - get dbconn for given id\n *     - if type is valid\n *       - set dbconn state for this domain to valid\n *     - send result: <result to='them' from='us' type='xxx'/>\n *     - DONE\n */\n\n/* forward decls */\nstatic int _out_mio_callback(mio_t m, mio_action_t a, mio_fd_t fd, void *data, void *arg);\nstatic int _out_sx_callback(sx_t s, sx_event_t e, void *data, void *arg);\nstatic void _out_result(conn_t out, nad_t nad);\nstatic void _out_verify(conn_t out, nad_t nad);\nstatic void _dns_result_aaaa(struct dns_ctx *ctx, struct dns_rr_a6 *result, void *data);\nstatic void _dns_result_a(struct dns_ctx *ctx, struct dns_rr_a4 *result, void *data);\n\n/** queue the packet */\nstatic void _out_packet_queue(s2s_t s2s, pkt_t pkt) {\n    char *rkey = s2s_route_key(NULL, pkt->from->domain, pkt->to->domain);\n    jqueue_t q = (jqueue_t) xhash_get(s2s->outq, rkey);\n\n    if(q == NULL) {\n        log_debug(ZONE, \""creating new out packet queue for '%s'\"", rkey);\n        q = jqueue_new();\n        q->key = rkey;\n        xhash_put(s2s->outq, q->key, (void *) q);\n    } else {\n        free(rkey);\n    }\n\n    log_debug(ZONE, \""queueing packet for '%s'\"", q->key);\n\n    jqueue_push(q, (void *) pkt, 0);\n}\n\nstatic void _out_dialback(conn_t out, char *rkey, int rkeylen) {\n    char *c, *dbkey, *tmp;\n    nad_t nad;\n    int elem, ns;\n    int from_len, to_len;\n    time_t now;\n\n    now = time(NULL);\n\n    c = memchr(rkey, '/', rkeylen);\n    from_len = c - rkey;\n    c++;\n    to_len = rkeylen - (c - rkey);\n\n    /* kick off the dialback */\n    tmp = strndup(c, to_len);\n    dbkey = s2s_db_key(NULL, out->s2s->local_secret, tmp, out->s->id);\n    free(tmp);\n\n    nad = nad_new();\n\n    /* request auth */\n    ns = nad_add_namespace(nad, uri_DIALBACK, \""db\"");\n    elem = nad_append_elem(nad, ns, \""result\"", 0);\n    nad_set_attr(nad, elem, -1, \""from\"", rkey, from_len);\n    nad_set_attr(nad, elem, -1, \""to\"", c, to_len);\n    nad_append_cdata(nad, dbkey, strlen(dbkey), 1);\n\n    log_debug(ZONE, \""sending auth request for %.*s (key %s)\"", rkeylen, rkey, dbkey);\n    log_write(out->s2s->log, LOG_NOTICE, \""[%d] [%s, port=%d] sending dialback auth request for route '%.*s'\"", out->fd->fd, out->ip, out->port, rkeylen, rkey);\n\n    /* off it goes */\n    sx_nad_write(out->s, nad);\n\n    free(dbkey);\n\n    /* we're in progress now */\n    xhash_put(out->states, pstrdupx(xhash_pool(out->states), rkey, rkeylen), (void *) conn_INPROGRESS);\n\n    /* record the time that we set conn_INPROGRESS state */\n    xhash_put(out->states_time, pstrdupx(xhash_pool(out->states_time), rkey, rkeylen), (void *) now);\n}\n\nvoid _out_dns_mark_bad(conn_t out) {\n    if (out->s2s->dns_bad_timeout > 0) {\n        dnsres_t bad;\n        char *ipport;\n\n        /* mark this host as bad */\n        ipport = dns_make_ipport(out->ip, out->port);\n        bad = xhash_get(out->s2s->dns_bad, ipport);\n        if (bad == NULL) {\n            bad = (dnsres_t) calloc(1, sizeof(struct dnsres_st));\n            bad->key = ipport;\n            xhash_put(out->s2s->dns_bad, ipport, bad);\n        }\n        bad->expiry = time(NULL) + out->s2s->dns_bad_timeout;\n    }\n}\n\nint dns_select(s2s_t s2s, char *ip, int *port, time_t now, dnscache_t dns, int allow_bad) {\n    /* list of results */\n    dnsres_t l_reuse[DNS_MAX_RESULTS];\n    dnsres_t l_aaaa[DNS_MAX_RESULTS];\n    dnsres_t l_a[DNS_MAX_RESULTS];\n    dnsres_t l_bad[DNS_MAX_RESULTS];\n    /* running weight sums of results */\n    int rw_reuse[DNS_MAX_RESULTS];\n    int rw_aaaa[DNS_MAX_RESULTS];\n    int rw_a[DNS_MAX_RESULTS];\n    int s_reuse = 0, s_aaaa = 0, s_a = 0, s_bad = 0; /* count */\n    int p_reuse = 0, p_aaaa = 0, p_a = 0; /* list prio */\n""}, {""source"": ""value_info(file:out.c, value:conn_INPROGRESS)"", ""result"": {""value_trace"": [{""full_code"": ""conn_INPROGRESS"", ""line"": 1363, ""func_name"": null}, {""full_code"": ""conn_INPROGRESS"", ""line"": 714, ""func_name"": null}, {""full_code"": ""conn_INPROGRESS"", ""line"": 167, ""func_name"": null}], ""struct_var"": ""conn_INPROGRESS"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}]","s2s/out.c: Missing validation of connection state before accepting dialback 'valid' responses. The `_out_verify` and `_out_result` functions did not check if a dialback request was in progress (i.e., `conn_INPROGRESS` state in `in->states`/`out->states`). The patch enforces this check. The `conn_INPROGRESS` state is set in `_out_dialback` (s2s/out.c:167) when initiating a dialback request, ensuring responses are only accepted for valid prior requests.",0.95,./github/other_context/CVE-2012-3525
5,CVE-2013-4623,CWE-20,c_cpp,"The x509parse_crt function in x509.h in PolarSSL 1.1.x before 1.1.7 and 1.2.x before 1.2.8 does not properly parse certificate messages during the SSL/TLS handshake, which allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a certificate message that contains a PEM encoded certificate.",https://github.com/Mbed-TLS/mbedtls/commit/1922a4e6aade7b1d685af19d4d9339ddb5c02859,ssl_parse_certificate() now calls x509parse_crt_der() directly,1,"[{""func_name"": ""ssl_parse_certificate"", ""file_path"": ""library/ssl_tls.c"", ""func_code"": ""int ssl_parse_certificate( ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n\n    SSL_DEBUG_MSG( 2, ( \""=> parse certificate\"" ) );\n\n    if( ssl->endpoint == SSL_IS_SERVER &&\n        ssl->authmode == SSL_VERIFY_NONE )\n    {\n        ssl->verify_result = BADCERT_SKIP_VERIFY;\n        SSL_DEBUG_MSG( 2, ( \""<= skip parse certificate\"" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \""ssl_read_record\"", ret );\n        return( ret );\n    }\n\n    ssl->state++;\n\n    /*\n     * Check if the client sent an empty certificate\n     */\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_msglen  == 2                        &&\n            ssl->in_msgtype == SSL_MSG_ALERT            &&\n            ssl->in_msg[0]  == SSL_ALERT_LEVEL_WARNING  &&\n            ssl->in_msg[1]  == SSL_ALERT_MSG_NO_CERT )\n        {\n            SSL_DEBUG_MSG( 1, ( \""SSLv3 client has no certificate\"" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_OPTIONAL )\n                return( 0 );\n            else\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n        }\n    }\n\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver != SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_hslen   == 7                    &&\n            ssl->in_msgtype == SSL_MSG_HANDSHAKE    &&\n            ssl->in_msg[0]  == SSL_HS_CERTIFICATE   &&\n            memcmp( ssl->in_msg + 4, \""\\0\\0\\0\"", 3 ) == 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \""TLSv1 client has no certificate\"" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_REQUIRED )\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n            else\n                return( 0 );\n        }\n    }\n\n    if( ssl->in_msgtype != SSL_MSG_HANDSHAKE )\n    {\n        SSL_DEBUG_MSG( 1, ( \""bad certificate message\"" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl->in_msg[0] != SSL_HS_CERTIFICATE || ssl->in_hslen < 10 )\n    {\n        SSL_DEBUG_MSG( 1, ( \""bad certificate message\"" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    /*\n     * Same message structure as in ssl_write_certificate()\n     */\n    n = ( ssl->in_msg[5] << 8 ) | ssl->in_msg[6];\n\n    if( ssl->in_msg[4] != 0 || ssl->in_hslen != 7 + n )\n    {\n        SSL_DEBUG_MSG( 1, ( \""bad certificate message\"" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    if( ( ssl->session_negotiate->peer_cert = (x509_cert *) malloc(\n                    sizeof( x509_cert ) ) ) == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \""malloc(%d bytes) failed\"",\n                       sizeof( x509_cert ) ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memset( ssl->session_negotiate->peer_cert, 0, sizeof( x509_cert ) );\n\n    i = 7;\n\n    while( i < ssl->in_hslen )\n    {\n        if( ssl->in_msg[i] != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \""bad certificate message\"" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )\n            | (unsigned int) ssl->in_msg[i + 2];\n        i += 3;\n\n        if( n < 128 || i + n > ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \""bad certificate message\"" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = x509parse_crt( ssl->session_negotiate->peer_cert, ssl->in_msg + i,\n                             n );\n        if( ret != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"" x509parse_crt\"", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    SSL_DEBUG_CRT( 3, \""peer certificate\"", ssl->session_negotiate->peer_cert );\n\n    if( ssl->authmode != SSL_VERIFY_NONE )\n    {\n        if( ssl->ca_chain == NULL )\n        {\n            SSL_DEBUG_MSG( 1, ( \""got no CA chain\"" ) );\n            return( POLARSSL_ERR_SSL_CA_CHAIN_REQUIRED );\n        }\n\n        ret = x509parse_verify( ssl->session_negotiate->peer_cert,\n                                ssl->ca_chain, ssl->ca_crl,\n                                ssl->peer_cn,  &ssl->verify_result,\n                                ssl->f_vrfy, ssl->p_vrfy );\n\n        if( ret != 0 )\n            SSL_DEBUG_RET( 1, \""x509_verify_cert\"", ret );\n\n        if( ssl->authmode != SSL_VERIFY_REQUIRED )\n            ret = 0;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \""<= parse certificate\"" ) );\n\n    return( ret );\n}"", ""target"": 0}]","[{""func_name"": ""ssl_parse_certificate"", ""file_path"": ""library/ssl_tls.c"", ""func_code"": ""int ssl_parse_certificate( ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n\n    SSL_DEBUG_MSG( 2, ( \""=> parse certificate\"" ) );\n\n    if( ssl->endpoint == SSL_IS_SERVER &&\n        ssl->authmode == SSL_VERIFY_NONE )\n    {\n        ssl->verify_result = BADCERT_SKIP_VERIFY;\n        SSL_DEBUG_MSG( 2, ( \""<= skip parse certificate\"" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \""ssl_read_record\"", ret );\n        return( ret );\n    }\n\n    ssl->state++;\n\n    /*\n     * Check if the client sent an empty certificate\n     */\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_msglen  == 2                        &&\n            ssl->in_msgtype == SSL_MSG_ALERT            &&\n            ssl->in_msg[0]  == SSL_ALERT_LEVEL_WARNING  &&\n            ssl->in_msg[1]  == SSL_ALERT_MSG_NO_CERT )\n        {\n            SSL_DEBUG_MSG( 1, ( \""SSLv3 client has no certificate\"" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_OPTIONAL )\n                return( 0 );\n            else\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n        }\n    }\n\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver != SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_hslen   == 7                    &&\n            ssl->in_msgtype == SSL_MSG_HANDSHAKE    &&\n            ssl->in_msg[0]  == SSL_HS_CERTIFICATE   &&\n            memcmp( ssl->in_msg + 4, \""\\0\\0\\0\"", 3 ) == 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \""TLSv1 client has no certificate\"" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_REQUIRED )\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n            else\n                return( 0 );\n        }\n    }\n\n    if( ssl->in_msgtype != SSL_MSG_HANDSHAKE )\n    {\n        SSL_DEBUG_MSG( 1, ( \""bad certificate message\"" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl->in_msg[0] != SSL_HS_CERTIFICATE || ssl->in_hslen < 10 )\n    {\n        SSL_DEBUG_MSG( 1, ( \""bad certificate message\"" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    /*\n     * Same message structure as in ssl_write_certificate()\n     */\n    n = ( ssl->in_msg[5] << 8 ) | ssl->in_msg[6];\n\n    if( ssl->in_msg[4] != 0 || ssl->in_hslen != 7 + n )\n    {\n        SSL_DEBUG_MSG( 1, ( \""bad certificate message\"" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    if( ( ssl->session_negotiate->peer_cert = (x509_cert *) malloc(\n                    sizeof( x509_cert ) ) ) == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \""malloc(%d bytes) failed\"",\n                       sizeof( x509_cert ) ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memset( ssl->session_negotiate->peer_cert, 0, sizeof( x509_cert ) );\n\n    i = 7;\n\n    while( i < ssl->in_hslen )\n    {\n        if( ssl->in_msg[i] != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \""bad certificate message\"" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )\n            | (unsigned int) ssl->in_msg[i + 2];\n        i += 3;\n\n        if( n < 128 || i + n > ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \""bad certificate message\"" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = x509parse_crt_der( ssl->session_negotiate->peer_cert,\n                                 ssl->in_msg + i, n );\n        if( ret != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"" x509parse_crt\"", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    SSL_DEBUG_CRT( 3, \""peer certificate\"", ssl->session_negotiate->peer_cert );\n\n    if( ssl->authmode != SSL_VERIFY_NONE )\n    {\n        if( ssl->ca_chain == NULL )\n        {\n            SSL_DEBUG_MSG( 1, ( \""got no CA chain\"" ) );\n            return( POLARSSL_ERR_SSL_CA_CHAIN_REQUIRED );\n        }\n\n        ret = x509parse_verify( ssl->session_negotiate->peer_cert,\n                                ssl->ca_chain, ssl->ca_crl,\n                                ssl->peer_cn,  &ssl->verify_result,\n                                ssl->f_vrfy, ssl->p_vrfy );\n\n        if( ret != 0 )\n            SSL_DEBUG_RET( 1, \""x509_verify_cert\"", ret );\n\n        if( ssl->authmode != SSL_VERIFY_REQUIRED )\n            ret = 0;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \""<= parse certificate\"" ) );\n\n    return( ret );\n}""}]","{""function"": 3, ""code"": 2}","[{""source"": ""func_info(func:x509parse_crt)"", ""result"": [{""code"": ""int x509parse_crt( x509_cert *chain, const unsigned char *buf, size_t buflen )\n{\n    int ret, success = 0, first_error = 0, total_failed = 0;\n    x509_cert *crt, *prev = NULL;\n    int buf_format = X50"", ""start_line"": 1396, ""end_line"": 1549, ""full_name"": ""x509parse_crt"", ""file_path"": ""library/x509parse.c""}]}, {""source"": ""func_info(func:x509parse_crt_der)"", ""result"": [{""code"": ""int x509parse_crt_der( x509_cert *crt, const unsigned char *buf, size_t buflen )\n{\n    int ret;\n    size_t len;\n    unsigned char *p, *end, *crt_end;\n\n    /*\n     * Check for valid input\n     */\n    i"", ""start_line"": 1143, ""end_line"": 1391, ""full_name"": ""x509parse_crt_der"", ""file_path"": ""library/x509parse.c""}]}, {""source"": ""code_info(file:x509parse.c, lines:1396-1549)"", ""result"": ""int x509parse_crt( x509_cert *chain, const unsigned char *buf, size_t buflen )\n{\n    int ret, success = 0, first_error = 0, total_failed = 0;\n    x509_cert *crt, *prev = NULL;\n    int buf_format = X509_FORMAT_DER;\n\n    crt = chain;\n\n    /*\n     * Check for valid input\n     */\n    if( crt == NULL || buf == NULL )\n        return( POLARSSL_ERR_X509_INVALID_INPUT );\n\n    while( crt->version != 0 && crt->next != NULL )\n    {\n        prev = crt;\n        crt = crt->next;\n    }\n\n    /*\n     * Add new certificate on the end of the chain if needed.\n     */\n    if ( crt->version != 0 && crt->next == NULL)\n    {\n        crt->next = (x509_cert *) malloc( sizeof( x509_cert ) );\n\n        if( crt->next == NULL )\n            return( POLARSSL_ERR_X509_MALLOC_FAILED );\n\n        prev = crt;\n        crt = crt->next;\n        memset( crt, 0, sizeof( x509_cert ) );\n    }\n\n    /*\n     * Determine buffer content. Buffer contains either one DER certificate or\n     * one or more PEM certificates.\n     */\n#if defined(POLARSSL_PEM_C)\n    if( strstr( (const char *) buf, \""-----BEGIN CERTIFICATE-----\"" ) != NULL )\n        buf_format = X509_FORMAT_PEM;\n#endif\n\n    if( buf_format == X509_FORMAT_DER )\n        return x509parse_crt_der( crt, buf, buflen );\n    \n#if defined(POLARSSL_PEM_C)\n    if( buf_format == X509_FORMAT_PEM )\n    {\n        pem_context pem;\n\n        while( buflen > 0 )\n        {\n            size_t use_len;\n            pem_init( &pem );\n\n            ret = pem_read_buffer( &pem,\n                           \""-----BEGIN CERTIFICATE-----\"",\n                           \""-----END CERTIFICATE-----\"",\n                           buf, NULL, 0, &use_len );\n\n            if( ret == 0 )\n            {\n                /*\n                 * Was PEM encoded\n                 */\n                buflen -= use_len;\n                buf += use_len;\n            }\n            else if( ret == POLARSSL_ERR_PEM_BAD_INPUT_DATA )\n            {\n                return( ret );\n            }\n            else if( ret != POLARSSL_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n            {\n                pem_free( &pem );\n\n                /*\n                 * PEM header and footer were found\n                 */\n                buflen -= use_len;\n                buf += use_len;\n\n                if( first_error == 0 )\n                    first_error = ret;\n\n                continue;\n            }\n            else\n                break;\n\n            ret = x509parse_crt_der( crt, pem.buf, pem.buflen );\n\n            pem_free( &pem );\n\n            if( ret != 0 )\n            {\n                /*\n                 * quit parsing on a memory error\n                 */\n                if( ret == POLARSSL_ERR_X509_MALLOC_FAILED )\n                {\n                    if( prev )\n                        prev->next = NULL;\n\n                    if( crt != chain )\n                        free( crt );\n\n                    return( ret );\n                }\n\n                if( first_error == 0 )\n                    first_error = ret;\n                \n                total_failed++;\n\n                memset( crt, 0, sizeof( x509_cert ) );\n                continue;\n            }\n\n            success = 1;\n\n            /*\n             * Add new certificate to the list\n             */\n            crt->next = (x509_cert *) malloc( sizeof( x509_cert ) );\n\n            if( crt->next == NULL )\n                return( POLARSSL_ERR_X509_MALLOC_FAILED );\n\n            prev = crt;\n            crt = crt->next;\n            memset( crt, 0, sizeof( x509_cert ) );\n        }\n    }\n#endif\n\n    if( crt->version == 0 )\n    {\n        if( prev )\n            prev->next = NULL;\n\n        if( crt != chain )\n            free( crt );\n    }\n\n    if( success )\n        return( total_failed );\n    else if( first_error )\n        return( first_error );\n    else\n        return( POLARSSL_ERR_X509_CERT_UNKNOWN_FORMAT );\n}\n\n""}, {""source"": ""code_info(file:x509parse.c, lines:1143-1391)"", ""result"": ""int x509parse_crt_der( x509_cert *crt, const unsigned char *buf, size_t buflen )\n{\n    int ret;\n    size_t len;\n    unsigned char *p, *end, *crt_end;\n\n    /*\n     * Check for valid input\n     */\n    if( crt == NULL || buf == NULL )\n        return( POLARSSL_ERR_X509_INVALID_INPUT );\n\n    p = (unsigned char *) malloc( len = buflen );\n\n    if( p == NULL )\n        return( POLARSSL_ERR_X509_MALLOC_FAILED );\n\n    memcpy( p, buf, buflen );\n\n    buflen = 0;\n\n    crt->raw.p = p;\n    crt->raw.len = len;\n    end = p + len;\n\n    /*\n     * Certificate  ::=  SEQUENCE  {\n     *      tbsCertificate       TBSCertificate,\n     *      signatureAlgorithm   AlgorithmIdentifier,\n     *      signatureValue       BIT STRING  }\n     */\n    if( ( ret = asn1_get_tag( &p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n    {\n        x509_free( crt );\n        return( POLARSSL_ERR_X509_CERT_INVALID_FORMAT );\n    }\n\n    if( len > (size_t) ( end - p ) )\n    {\n        x509_free( crt );\n        return( POLARSSL_ERR_X509_CERT_INVALID_FORMAT +\n                POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n    }\n    crt_end = p + len;\n    \n    /*\n     * TBSCertificate  ::=  SEQUENCE  {\n     */\n    crt->tbs.p = p;\n\n    if( ( ret = asn1_get_tag( &p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n    {\n        x509_free( crt );\n        return( POLARSSL_ERR_X509_CERT_INVALID_FORMAT + ret );\n    }\n\n    end = p + len;\n    crt->tbs.len = end - crt->tbs.p;\n\n    /*\n     * Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n     *\n     * CertificateSerialNumber  ::=  INTEGER\n     *\n     * signature            AlgorithmIdentifier\n     */\n    if( ( ret = x509_get_version( &p, end, &crt->version ) ) != 0 ||\n        ( ret = x509_get_serial(  &p, end, &crt->serial  ) ) != 0 ||\n        ( ret = x509_get_alg(  &p, end, &crt->sig_oid1   ) ) != 0 )\n    {\n        x509_free( crt );\n        return( ret );\n    }\n\n    crt->version++;\n\n    if( crt->version > 3 )\n    {\n        x509_free( crt );\n        return( POLARSSL_ERR_X509_CERT_UNKNOWN_VERSION );\n    }\n\n    if( ( ret = x509_get_sig_alg( &crt->sig_oid1, &crt->sig_alg ) ) != 0 )\n    {\n        x509_free( crt );\n        return( ret );\n    }\n\n    /*\n     * issuer               Name\n     */\n    crt->issuer_raw.p = p;\n\n    if( ( ret = asn1_get_tag( &p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n    {\n        x509_free( crt );\n        return( POLARSSL_ERR_X509_CERT_INVALID_FORMAT + ret );\n    }\n\n    if( ( ret = x509_get_name( &p, p + len, &crt->issuer ) ) != 0 )\n    {\n        x509_free( crt );\n        return( ret );\n    }\n\n    crt->issuer_raw.len = p - crt->issuer_raw.p;\n\n    /*\n     * Validity ::= SEQUENCE {\n     *      notBefore      Time,\n     *      notAfter       Time }\n     *\n     */\n    if( ( ret = x509_get_dates( &p, end, &crt->valid_from,\n                                         &crt->valid_to ) ) != 0 )\n    {\n        x509_free( crt );\n        return( ret );\n    }\n\n    /*\n     * subject              Name\n     */\n    crt->subject_raw.p = p;\n\n    if( ( ret = asn1_get_tag( &p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n    {\n        x509_free( crt );\n        return( POLARSSL_ERR_X509_CERT_INVALID_FORMAT + ret );\n    }\n\n    if( len && ( ret = x509_get_name( &p, p + len, &crt->subject ) ) != 0 )\n    {\n        x509_free( crt );\n        return( ret );\n    }\n\n    crt->subject_raw.len = p - crt->subject_raw.p;\n\n    /*\n     * SubjectPublicKeyInfo  ::=  SEQUENCE\n     *      algorithm            AlgorithmIdentifier,\n     *      subjectPublicKey     BIT STRING  }\n     */\n    if( ( ret = asn1_get_tag( &p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n    {\n        x509_free( crt );\n        return( POLARSSL_ERR_X509_CERT_INVALID_FORMAT + ret );\n    }\n\n    if( ( ret = x509_get_pubkey( &p, p + len, &crt->pk_oid,\n                                 &crt->rsa.N, &crt->rsa.E ) ) != 0 )\n    {\n        x509_free( crt );\n        return( ret );\n    }\n\n    if( ( ret = rsa_check_pubkey( &crt->rsa ) ) != 0 )\n    {\n        x509_free( crt );\n        return( ret );\n    }\n\n    crt->rsa.len = mpi_size( &crt->rsa.N );\n\n    /*\n     *  issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n     *                       -- If present, version shall be v2 or v3\n     *  subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n     *                       -- If present, version shall be v2 or v3\n     *  extensions      [3]  EXPLICIT Extensions OPTIONAL\n     *                       -- If present, version shall be v3\n     */\n    if( crt->version == 2 || crt->version == 3 )\n    {\n        ret = x509_get_uid( &p, end, &crt->issuer_id,  1 );\n        if( ret != 0 )\n        {\n            x509_free( crt );\n            return( ret );\n        }\n    }\n\n    if( crt->version == 2 || crt->version == 3 )\n    {\n        ret = x509_get_uid( &p, end, &crt->subject_id,  2 );\n        if( ret != 0 )\n        {\n            x509_free( crt );\n            return( ret );\n        }\n    }\n\n    if( crt->version == 3 )\n    {\n        ret = x509_get_crt_ext( &p, end, crt);\n        if( ret != 0 )\n        {\n            x509_free( crt );\n            return( ret );\n        }\n    }\n\n    if( p != end )\n    {\n        x509_free( crt );\n        return( POLARSSL_ERR_X509_CERT_INVALID_FORMAT +\n                POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n    }\n\n    end = crt_end;\n\n    /*\n     *  signatureAlgorithm   AlgorithmIdentifier,\n     *  signatureValue       BIT STRING\n     */\n    if( ( ret = x509_get_alg( &p, end, &crt->sig_oid2 ) ) != 0 )\n    {\n        x509_free( crt );\n        return( ret );\n    }\n\n    if( crt->sig_oid1.len != crt->sig_oid2.len ||\n        memcmp( crt->sig_oid1.p, crt->sig_oid2.p, crt->sig_oid1.len ) != 0 )\n    {\n        x509_free( crt );\n        return( POLARSSL_ERR_X509_CERT_SIG_MISMATCH );\n    }\n\n    if( ( ret = x509_get_sig( &p, end, &crt->sig ) ) != 0 )\n    {\n        x509_free( crt );\n        return( ret );\n    }\n\n    if( p != end )\n    {\n        x509_free( crt );\n        return( POLARSSL_ERR_X509_CERT_INVALID_FORMAT +\n                POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n    }\n\n    return( 0 );\n}\n\n""}, {""source"": ""func_info(file:pem.c, func:pem_read_buffer)"", ""result"": [{""code"": ""int pem_read_buffer( pem_context *ctx, char *header, char *footer, const unsigned char *data, const unsigned char *pwd, size_t pwdlen, size_t *use_len )\n{\n    int ret, enc;\n    size_t len;\n    unsigne"", ""start_line"": 181, ""end_line"": 341, ""full_name"": ""pem_read_buffer"", ""file_path"": ""library/pem.c""}]}]","1. `ssl_parse_certificate` (library/ssl_tls.c:2376-2378) calls `x509parse_crt` (library/x509parse.c:1396-1549) to parse certificate data. 2. `x509parse_crt` detects PEM format via `strstr` and enters a `while (buflen > 0)` loop to process PEM certificates using `pem_read_buffer`. 3. `pem_read_buffer` (library/pem.c:181-341) processes PEM data, but if the input lacks a valid PEM footer, it fails to advance the buffer (e.g., `use_len` remains unmodified), causing the loop in `x509parse_crt` to run indefinitely. 4. The patch replaces `x509parse_crt` with `x509parse_crt_der` (library/x509parse.c:1143-1391), which parses DER directly, bypassing PEM handling.",1.0,./github/other_context/CVE-2013-4623
6,CVE-2013-7294,CWE-20,c_cpp,The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,SECURITY: Properly handle IKEv2 I1 notification packet without KE payload,6,"[{""func_name"": ""ikev2_parent_outI1_continue"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\""ikev2 parent outI1: calculated ke+nonce, sending I1\""));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \""%s: Request was disconnected from state\"",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}"", ""target"": 0}, {""func_name"": ""ikev2_parent_inR1outI2_continue"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\""ikev2 parent inR1outI2: calculating g^{xy}, sending I2\""));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \""%s: Request was disconnected from state\"",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}"", ""target"": 0}, {""func_name"": ""ikev2_parent_inI1outR1_continue"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\""ikev2 parent inI1outR1: calculated ke+nonce, sending R1\""));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \""%s: Request was disconnected from state\"",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}"", ""target"": 0}, {""func_name"": ""ikev2_parent_inI2outR2_continue"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\""ikev2 parent inI2outR2: calculating g^{xy}, sending R2\""));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \""%s: Request was disconnected from state\"",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI2outR2_tail(pcrc, r);\n\tif ( e > STF_FAIL) {\n\t\t/* we do not send a notify because we are the initiator that could be responding to an error notification */\n\t\tint v2_notify_num = e - STF_FAIL;\n\t\tDBG_log(\n\t\t\t\""ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\"",\n\t\t\tenum_name(&ikev2_notify_names, v2_notify_num));\n\t} else if ( e != STF_OK) {\n\t\tDBG_log(\""ikev2_parent_inI2outR2_tail returned %s\"",\n\t\t\tenum_name(&stfstatus_name, e));\n\t}\n\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}"", ""target"": 1}, {""func_name"": ""ikev2parent_inI1outR1"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""stf_status ikev2parent_inI1outR1(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tlset_t policy = POLICY_IKEV2_ALLOW;\n\tstruct connection *c = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t    md->iface->port,\n\t\t\t\t\t\t    &md->sender,\n\t\t\t\t\t\t    md->sender_port,\n\t\t\t\t\t\t    POLICY_IKEV2_ALLOW);\n\n\t/* retrieve st->st_gi */\n\n#if 0\n\tif (c == NULL) {\n\t\t/*\n\t\t * make up a policy from the thing that was proposed, and see\n\t\t * if we can find a connection with that policy.\n\t\t */\n\n\t\tpb_stream pre_sa_pbs = sa_pd->pbs;\n\t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);\n\t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,\n\t\t\t\t\t (ip_address*)NULL, md->sender_port,\n\t\t\t\t\t policy);\n\n\t}\n#endif\n\n\tif (c == NULL) {\n\n\t\t/* See if a wildcarded connection can be found.\n\t\t * We cannot pick the right connection, so we're making a guess.\n\t\t * All Road Warrior connections are fair game:\n\t\t * we pick the first we come across (if any).\n\t\t * If we don't find any, we pick the first opportunistic\n\t\t * with the smallest subnet that includes the peer.\n\t\t * There is, of course, no necessary relationship between\n\t\t * an Initiator's address and that of its client,\n\t\t * but Food Groups kind of assumes one.\n\t\t */\n\t\t{\n\t\t\tstruct connection *d;\n\t\t\td = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t pluto_port,\n\t\t\t\t\t\t (ip_address*)NULL,\n\t\t\t\t\t\t md->sender_port, policy);\n\n\t\t\tfor (; d != NULL; d = d->hp_next) {\n\t\t\t\tif (d->kind == CK_GROUP) {\n\t\t\t\t\t/* ignore */\n\t\t\t\t} else {\n\t\t\t\t\tif (d->kind == CK_TEMPLATE &&\n\t\t\t\t\t    !(d->policy & POLICY_OPPO)) {\n\t\t\t\t\t\t/* must be Road Warrior: we have a winner */\n\t\t\t\t\t\tc = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Opportunistic or Shunt: pick tightest match */\n\t\t\t\t\tif (addrinsubnet(&md->sender,\n\t\t\t\t\t\t\t &d->spd.that.client)\n\t\t\t\t\t    &&\n\t\t\t\t\t    (c == NULL ||\n\t\t\t\t\t     !subnetinsubnet(&c->spd.that.\n\t\t\t\t\t\t\t     client,\n\t\t\t\t\t\t\t     &d->spd.that.\n\t\t\t\t\t\t\t     client)))\n\t\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS, \""initial parent SA message received on %s:%u\""\n\t\t\t       \"" but no connection has been authorized%s%s\"",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr),\n\t\t\t       ntohs(portof(&md->iface->ip_addr)),\n\t\t\t       (policy != LEMPTY) ? \"" with policy=\"" : \""\"",\n\t\t\t       (policy !=\n\t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,\n\t\t\t\t\t\t     policy) : \""\"");\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tif (c->kind != CK_TEMPLATE) {\n\t\t\tloglog(RC_LOG_SERIOUS, \""initial parent SA message received on %s:%u\""\n\t\t\t       \"" but \\\""%s\\\"" forbids connection\"",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr), pluto_port,\n\t\t\t       c->name);\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\n\t} else {\n\t\t/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */\n\t\t/* vnet=/vhost= should have set CK_TEMPLATE on connection loading */\n\t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \""local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\""));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t} else if ((c->kind == CK_TEMPLATE) &&\n\t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \""local endpoint has narrowing=yes - needs instantiation\""));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t}\n\t}\n\n\tDBG_log(\""found connection: %s\\n\"", c ? c->name : \""<none>\"");\n\n\tif (!st) {\n\t\tst = new_state();\n\t\t/* set up new state */\n\t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);\n\t\t/* initialize_new_state expects valid icookie/rcookie values, so create it now */\n\t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);\n\t\tinitialize_new_state(st, c, policy, 0, NULL_FD,\n\t\t\t\t     pcim_stranger_crypto);\n\t\tst->st_ikev2 = TRUE;\n\t\tchange_state(st, STATE_PARENT_R1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tst->st_msgid_nextuse = 0;\n\n\t\tmd->st = st;\n\t\tmd->from_state = STATE_IKEv2_BASE;\n\t}\n\n\t/* check,as a responder, are we under dos attack or not\n\t * if yes go to 6 message exchange mode. it is a config option for now.\n\t * TBD set force_busy dynamically\n\t * Paul: Can we check for STF_TOOMUCHCRYPTO ?\n\t */\n\tif (force_busy == TRUE) {\n\t\tu_char dcookie[SHA1_DIGEST_SIZE];\n\t\tchunk_t dc;\n\t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,\n\t\t\t\t   st->st_icookie);\n\t\tdc.ptr = dcookie;\n\t\tdc.len = SHA1_DIGEST_SIZE;\n\n\t\t/* check if I1 packet contian KE and a v2N payload with type COOKIE */\n\t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&\n\t\t     md->chain[ISAKMP_NEXT_v2N] &&\n\t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t\t      v2N_COOKIE)) {\n\t\t\tu_int8_t spisize;\n\t\t\tconst pb_stream *dc_pbs;\n\t\t\tchunk_t blob;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\""received a DOS cookie in I1 verify it\""));\n\t\t\t/* we received dcookie we send earlier verify it */\n\t\t\tspisize =\n\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.\n\t\t\t\tisan_spisize;\n\t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\t\tblob.ptr = dc_pbs->cur + spisize;\n\t\t\tblob.len = pbs_left(dc_pbs) - spisize;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_dump_chunk(\""dcookie received in I1 Packet\"",\n\t\t\t\t\t   blob);\n\t\t\t    DBG_dump(\""dcookie computed\"", dcookie,\n\t\t\t\t     SHA1_DIGEST_SIZE));\n\n\t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\""mismatch in DOS v2N_COOKIE,send a new one\"");\n\t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\""dcookie received match with computed one\""));\n\t\t} else {\n\t\t\t/* we are under DOS attack I1 contains no DOS COOKIE */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \""busy mode on. receieved I1 without a valid dcookie\"");\n\t\t\t    DBG_log(\""send a dcookie and forget this state\""));\n\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t} else {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\""will not send/process a dcookie\""));\n\n\t}\n\n\t/*\n\t * We have to agree to the DH group before we actually know who\n\t * we are talking to.   If we support the group, we use it.\n\t *\n\t * It is really too hard here to go through all the possible policies\n\t * that might permit this group.  If we think we are being DOS'ed\n\t * then we should demand a cookie.\n\t */\n\t{\n\t\tstruct ikev2_ke *ke;\n\t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n\n\t\tst->st_oakley.group = lookup_group(ke->isak_group);\n\t\tif (st->st_oakley.group == NULL) {\n\t\t\tchar fromname[ADDRTOT_BUF];\n\n\t\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n\t\t\tlibreswan_log(\n\t\t\t\t\""rejecting I1 from %s:%u, invalid DH group=%u\"",\n\t\t\t\tfromname, md->sender_port,\n\t\t\t\tke->isak_group);\n\t\t\treturn v2N_INVALID_KE_PAYLOAD;\n\t\t}\n\t}\n\n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\""ikev2_inI1outR1 KE\"");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \""system too busy\"");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}"", ""target"": 0}, {""func_name"": ""ikev2parent_inI2outR2"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\n\t/* struct connection *c = st->st_connection; */\n\n\t/*\n\t * the initiator sent us an encrypted payload. We need to calculate\n\t * our g^xy, and skeyseed values, and then decrypt the payload.\n\t */\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \""ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\""));\n\n\t/* verify that there is in fact an encrypted payload */\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\""R2 state should receive an encrypted payload\"");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\n\t/* now. we need to go calculate the g^xy */\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\""ikev2_inI2outR2 KE\"");\n\t\tstf_status e;\n\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \""system too busy\"");\n\t\t\tdelete_state(st);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""ikev2_parent_outI1_continue"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\""ikev2 parent outI1: calculated ke+nonce, sending I1\""));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \""%s: Request was disconnected from state\"",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n}""}, {""func_name"": ""ikev2_parent_inR1outI2_continue"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\""ikev2 parent inR1outI2: calculating g^{xy}, sending I2\""));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \""%s: Request was disconnected from state\"",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n}""}, {""func_name"": ""ikev2_parent_inI1outR1_continue"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\""ikev2 parent inI1outR1: calculated ke+nonce, sending R1\""));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \""%s: Request was disconnected from state\"",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_globals();\n}""}, {""func_name"": ""ikev2_parent_inI2outR2_continue"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\""ikev2 parent inI2outR2: calculating g^{xy}, sending R2\""));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \""%s: Request was disconnected from state\"",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI2outR2_tail(pcrc, r);\n\tif ( e > STF_FAIL) {\n\t\t/* we do not send a notify because we are the initiator that could be responding to an error notification */\n\t\tint v2_notify_num = e - STF_FAIL;\n\t\tDBG_log(\n\t\t\t\""ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\"",\n\t\t\tenum_name(&ikev2_notify_names, v2_notify_num));\n\t} else if ( e != STF_OK) {\n\t\tDBG_log(\""ikev2_parent_inI2outR2_tail returned %s\"",\n\t\t\tenum_name(&stfstatus_name, e));\n\t}\n\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n}""}, {""func_name"": ""ikev2parent_inI1outR1"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""stf_status ikev2parent_inI1outR1(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tlset_t policy = POLICY_IKEV2_ALLOW;\n\tstruct connection *c = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t    md->iface->port,\n\t\t\t\t\t\t    &md->sender,\n\t\t\t\t\t\t    md->sender_port,\n\t\t\t\t\t\t    POLICY_IKEV2_ALLOW);\n\n\t/* retrieve st->st_gi */\n\n#if 0\n\tif (c == NULL) {\n\t\t/*\n\t\t * make up a policy from the thing that was proposed, and see\n\t\t * if we can find a connection with that policy.\n\t\t */\n\n\t\tpb_stream pre_sa_pbs = sa_pd->pbs;\n\t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);\n\t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,\n\t\t\t\t\t (ip_address*)NULL, md->sender_port,\n\t\t\t\t\t policy);\n\n\t}\n#endif\n\n\tif (c == NULL) {\n\n\t\t/* See if a wildcarded connection can be found.\n\t\t * We cannot pick the right connection, so we're making a guess.\n\t\t * All Road Warrior connections are fair game:\n\t\t * we pick the first we come across (if any).\n\t\t * If we don't find any, we pick the first opportunistic\n\t\t * with the smallest subnet that includes the peer.\n\t\t * There is, of course, no necessary relationship between\n\t\t * an Initiator's address and that of its client,\n\t\t * but Food Groups kind of assumes one.\n\t\t */\n\t\t{\n\t\t\tstruct connection *d;\n\t\t\td = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t pluto_port,\n\t\t\t\t\t\t (ip_address*)NULL,\n\t\t\t\t\t\t md->sender_port, policy);\n\n\t\t\tfor (; d != NULL; d = d->hp_next) {\n\t\t\t\tif (d->kind == CK_GROUP) {\n\t\t\t\t\t/* ignore */\n\t\t\t\t} else {\n\t\t\t\t\tif (d->kind == CK_TEMPLATE &&\n\t\t\t\t\t    !(d->policy & POLICY_OPPO)) {\n\t\t\t\t\t\t/* must be Road Warrior: we have a winner */\n\t\t\t\t\t\tc = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Opportunistic or Shunt: pick tightest match */\n\t\t\t\t\tif (addrinsubnet(&md->sender,\n\t\t\t\t\t\t\t &d->spd.that.client)\n\t\t\t\t\t    &&\n\t\t\t\t\t    (c == NULL ||\n\t\t\t\t\t     !subnetinsubnet(&c->spd.that.\n\t\t\t\t\t\t\t     client,\n\t\t\t\t\t\t\t     &d->spd.that.\n\t\t\t\t\t\t\t     client)))\n\t\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS, \""initial parent SA message received on %s:%u\""\n\t\t\t       \"" but no connection has been authorized%s%s\"",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr),\n\t\t\t       ntohs(portof(&md->iface->ip_addr)),\n\t\t\t       (policy != LEMPTY) ? \"" with policy=\"" : \""\"",\n\t\t\t       (policy !=\n\t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,\n\t\t\t\t\t\t     policy) : \""\"");\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tif (c->kind != CK_TEMPLATE) {\n\t\t\tloglog(RC_LOG_SERIOUS, \""initial parent SA message received on %s:%u\""\n\t\t\t       \"" but \\\""%s\\\"" forbids connection\"",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr), pluto_port,\n\t\t\t       c->name);\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\n\t} else {\n\t\t/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */\n\t\t/* vnet=/vhost= should have set CK_TEMPLATE on connection loading */\n\t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \""local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\""));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t} else if ((c->kind == CK_TEMPLATE) &&\n\t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \""local endpoint has narrowing=yes - needs instantiation\""));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t}\n\t}\n\n\tDBG_log(\""found connection: %s\\n\"", c ? c->name : \""<none>\"");\n\n\tif (!st) {\n\t\tst = new_state();\n\t\t/* set up new state */\n\t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);\n\t\t/* initialize_new_state expects valid icookie/rcookie values, so create it now */\n\t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);\n\t\tinitialize_new_state(st, c, policy, 0, NULL_FD,\n\t\t\t\t     pcim_stranger_crypto);\n\t\tst->st_ikev2 = TRUE;\n\t\tchange_state(st, STATE_PARENT_R1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tst->st_msgid_nextuse = 0;\n\n\t\tmd->st = st;\n\t\tmd->from_state = STATE_IKEv2_BASE;\n\t}\n\n\t/* check,as a responder, are we under dos attack or not\n\t * if yes go to 6 message exchange mode. it is a config option for now.\n\t * TBD set force_busy dynamically\n\t * Paul: Can we check for STF_TOOMUCHCRYPTO ?\n\t */\n\tif (force_busy == TRUE) {\n\t\tu_char dcookie[SHA1_DIGEST_SIZE];\n\t\tchunk_t dc;\n\t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,\n\t\t\t\t   st->st_icookie);\n\t\tdc.ptr = dcookie;\n\t\tdc.len = SHA1_DIGEST_SIZE;\n\n\t\t/* check if I1 packet contian KE and a v2N payload with type COOKIE */\n\t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&\n\t\t     md->chain[ISAKMP_NEXT_v2N] &&\n\t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t\t      v2N_COOKIE)) {\n\t\t\tu_int8_t spisize;\n\t\t\tconst pb_stream *dc_pbs;\n\t\t\tchunk_t blob;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\""received a DOS cookie in I1 verify it\""));\n\t\t\t/* we received dcookie we send earlier verify it */\n\t\t\tspisize =\n\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.\n\t\t\t\tisan_spisize;\n\t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\t\tblob.ptr = dc_pbs->cur + spisize;\n\t\t\tblob.len = pbs_left(dc_pbs) - spisize;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_dump_chunk(\""dcookie received in I1 Packet\"",\n\t\t\t\t\t   blob);\n\t\t\t    DBG_dump(\""dcookie computed\"", dcookie,\n\t\t\t\t     SHA1_DIGEST_SIZE));\n\n\t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\""mismatch in DOS v2N_COOKIE,send a new one\"");\n\t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\""dcookie received match with computed one\""));\n\t\t} else {\n\t\t\t/* we are under DOS attack I1 contains no DOS COOKIE */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \""busy mode on. receieved I1 without a valid dcookie\"");\n\t\t\t    DBG_log(\""send a dcookie and forget this state\""));\n\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t} else {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\""will not send/process a dcookie\""));\n\n\t}\n\n\t/*\n\t * We have to agree to the DH group before we actually know who\n\t * we are talking to.   If we support the group, we use it.\n\t *\n\t * It is really too hard here to go through all the possible policies\n\t * that might permit this group.  If we think we are being DOS'ed\n\t * then we should demand a cookie.\n\t */\n\t{\n\t\tstruct ikev2_ke *ke;\n\t\tchar fromname[ADDRTOT_BUF];\n\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n\n\t\tif (!md->chain[ISAKMP_NEXT_v2KE]) {\n\t\t\t/* is this a notify? If so, log it */\n\t\t\tif(md->chain[ISAKMP_NEXT_v2N]) {\n\t\t\t\tlibreswan_log(\""Received Notify(%d): %s\"",\n\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,\n\t\t\t\t\tenum_name(&ikev2_notify_names,\n\t\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));\n\t\t\t}\n\t\t\tlibreswan_log(\n\t\t\t\t\""rejecting I1 from %s:%u, no KE payload present\"",\n\t\t\t\tfromname, md->sender_port);\n\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n\t\t}\n\t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n\n\t\tst->st_oakley.group = lookup_group(ke->isak_group);\n\t\tif (st->st_oakley.group == NULL) {\n\t\t\tlibreswan_log(\n\t\t\t\t\""rejecting I1 from %s:%u, invalid DH group=%u\"",\n\t\t\t\tfromname, md->sender_port,\n\t\t\t\tke->isak_group);\n\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n\t\t}\n\t}\n\n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\""ikev2_inI1outR1 KE\"");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \""system too busy\"");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}""}, {""func_name"": ""ikev2parent_inI2outR2"", ""file_path"": ""programs/pluto/ikev2_parent.c"", ""func_code"": ""stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\n\t/* struct connection *c = st->st_connection; */\n\n\t/*\n\t * the initiator sent us an encrypted payload. We need to calculate\n\t * our g^xy, and skeyseed values, and then decrypt the payload.\n\t */\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \""ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\""));\n\n\t/* verify that there is in fact an encrypted payload */\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\""R2 state should receive an encrypted payload\"");\n\t\treset_globals(); /* XXX suspicious - why was this deemed neccessary? */\n\t\treturn STF_FATAL;\n\t}\n\n\t/* now. we need to go calculate the g^xy */\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\""ikev2_inI2outR2 KE\"");\n\t\tstf_status e;\n\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \""system too busy\"");\n\t\t\tdelete_state(st);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}""}]","{""code"": 1}","[{""source"": ""code_info(file:ikev2_parent.c, lines:743-800)"", ""result"": ""\t\t\treturn v2N_INVALID_KE_PAYLOAD;\n\t\t}\n\t}\n\n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\""ikev2_inI1outR1 KE\"");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \""system too busy\"");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n\nstatic void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\""ikev2 parent inI1outR1: calculated ke+nonce, sending R1\""));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \""%s: Request was disconnected from state\"",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n""}]","programs/pluto/ikev2_parent.c:730-743: The original code did not check for the presence of the KE payload (ISAKMP_NEXT_v2KE) in IKEv2 I1 packets. When a packet lacked the KE payload, the code at programs/pluto/ikev2_parent.c:730 would dereference `md->chain[ISAKMP_NEXT_v2KE]`, leading to a null pointer dereference or invalid memory access. This triggered undefined behavior, causing Pluto to crash or restart. The patch adds a check for `ISAKMP_NEXT_v2KE` and rejects such packets with `STF_FAIL + v2N_INVALID_KE_PAYLOAD`, preventing the issue.",0.95,./github/other_context/CVE-2013-7294
7,CVE-2014-125075,CWE-89,java,A vulnerability was found in gmail-servlet and classified as critical. This issue affects the function search of the file src/Model.java. The manipulation leads to sql injection. The identifier of the patch is 5d72753c2e95bb373aa86824939397dc25f679ea. It is recommended to apply a patch to fix this issue. The identifier VDB-218021 was assigned to this vulnerability.,https://github.com/ChrisMcMStone/gmail-servlet/commit/5d72753c2e95bb373aa86824939397dc25f679ea,Added validation for contact adding and changed use of prepared statements to avoid SQL injection.,7,"[{""func_name"": ""doPost"", ""file_path"": ""src/Login.java"", ""func_code"": ""protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n\n        String username = request.getParameter(\""username\""); //Gets all the parameters\n        String password = request.getParameter(\""password\"");\n        Properties prop = System.getProperties();\n\n        try {\n\n            prop.put(\""mail.user\"", username);\n            prop.put(\""mail.password\"", password);\n            prop.put(\""mail.smtp.auth\"", \""true\"");\n            prop.put(\""mail.smtp.starttls.enable\"", \""true\"");\n            prop.put(\""mail.smtp.host\"", \""smtp.gmail.com\"");\n            prop.put(\""mail.smtp.port\"", \""587\"");\n            prop.put(\""mail.store.protocol\"", \""imaps\"");\n\n            Session session = Session.getDefaultInstance(prop);\n            Store store = session.getStore(\""imaps\"");\n            store.connect(\""imap.googlemail.com\"", username, password);\n\n            request.getSession().setAttribute(\""session\"", session);\n\n            RequestDispatcher dispatcher = request.getRequestDispatcher(\""email.html\"");\n            dispatcher.forward(request, response);\n\n        } catch (MessagingException e) {\n            RequestDispatcher dispatcher = request.getRequestDispatcher(\""Error\""); //New Request Dispatcher\n            request.setAttribute(\""error\"", e.getMessage());\n            request.setAttribute(\""previous\"", request.getServletPath());\n            dispatcher.forward(request, response);\n        }\n    }"", ""target"": 1}, {""func_name"": ""doPost"", ""file_path"": ""src/Error.java"", ""func_code"": ""protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        if (System.currentTimeMillis() > (request.getSession().getLastAccessedTime() + 300000)) {\n            request.setAttribute(\""error\"", \""Login session timed out, please click retry to log back in\"");\n            request.setAttribute(\""previous\"", \""index.html\"");\n        }\n        PrintWriter out = response.getWriter();    //Gets the PrintWriter\n        String back;\n        String previous = (String) request.getAttribute(\""previous\"");\n        if (previous.equals(\""/LoginController\"") || previous.equals(\""index.html\"")) {\n            back = \""index.html\"";\n        } else if (previous.equals(\""searchcontact\"")) {\n            back = \""contact.jsp\"";\n        } else {\n            back = \""email.html\"";\n        }\n        out.println(\n                \""<!DOCTYPE html>\"" +\n                        \""<html>\"" +\n                        \""<head lang=\\\""en\\\"">\"" +\n                        \""<meta charset=\\\""UTF-8\\\"">\"" +\n                        \""<title>Error Occured</title>\"" +\n                        \""</head>\"" +\n                        \""<body>\"" +\n                        \""<center>\"" +\n                        \""<h1>Error Occurred!</h1>\"" +\n                        \""<div>\"" +\n                        \""<br>\"" +\n                        \""Error: \"" + request.getAttribute(\""error\"") + \""<br>\"" + \""<br>\"" + \""<br>\"" +//Gets the error message\n                        \""</div>\"" +\n                        \""<div class='error-actions'>\"" +\n                        \""<a href='\"" + back + \""'>Retry</a>\"" +\n                        \""</div>\"" +\n                        \""</center>\"" +\n                        \""</body>\"" +\n                        \""</html>\""\n        );\n\n    }"", ""target"": 0}, {""func_name"": ""doGet"", ""file_path"": ""src/Error.java"", ""func_code"": ""protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        doPost(request, response);\n\n    }"", ""target"": 0}, {""func_name"": ""addContact"", ""file_path"": ""src/Model.java"", ""func_code"": ""public void addContact(String firstname, String surname, String email, String user) throws SQLException {\n        PreparedStatement newStudent = conn.prepareStatement(\""INSERT INTO \"" +\n                \""contactinfo (forename, familyname, emailaddress, contactemailaddress) VALUES ('\"" + firstname + \""', '\"" + surname + \""', '\"" + email + \""', '\"" + user + \""')\"");\n        newStudent.execute();\n    }"", ""target"": 0}, {""func_name"": ""search"", ""file_path"": ""src/Model.java"", ""func_code"": ""public String search(String forename, String surname, String contactemail) throws SQLException {\n\n        String query;\n        if (forename.isEmpty() && surname.isEmpty()) {\n            query = \""\"";\n        } else if(forename.isEmpty()) {\n            query = \""familyname LIKE '%\"" + surname + \""' and\"";\n        } else if(surname.isEmpty()) {\n            query = \""forename LIKE '%\"" + forename + \""' and \"";\n        } else {\n            query = \""forename LIKE '%\"" + forename + \""' and familyname LIKE '%\"" + surname + \""' and\"";\n        }\n\n    PreparedStatement ps = conn.prepareStatement(\""SELECT * FROM contactinfo WHERE \"" + query + \"" contactemailaddress = '\"" + contactemail + \""'\"");\n    ResultSet rs = ps.executeQuery();\n    StringBuilder result = new StringBuilder(\""<h3>Search results...</h3><table class=\\\""result-table\\\"">\"" +\n            \""<tr>\"" +\n            \""<th>Forename</th> <th>Surname</th> <th>Email</th>\"" +\n            \""</tr>\"");\n    while(rs.next())\n\n    {\n        result.append(\""<tr><td>\"");\n        result.append(rs.getString(2));\n        result.append(\""</td><td>\"" + rs.getString(3));\n        result.append(\""</td><td>\"" + rs.getString(4) + \""</td></tr>\"");\n    }\n\n    result.append(\""</table\"");\n    return result.toString();\n}"", ""target"": 0}, {""func_name"": ""doPost"", ""file_path"": ""src/SearchContact.java"", ""func_code"": ""protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //Checks whether session has timed out\n        if (System.currentTimeMillis() > (request.getSession().getLastAccessedTime() + 300000)) {\n            RequestDispatcher dispatcher = request.getRequestDispatcher(\""Error\"");    //New Request Dispatcher\n            request.setAttribute(\""error\"", \""Login session timed out, please click retry to log back in\"");\n            request.setAttribute(\""previous\"", \""index.html\"");\n            dispatcher.forward(request, response);    //Forwards to the page\n        } else {\n            HttpSession httpSession = request.getSession();\n            Session session = (Session) httpSession.getAttribute(\""session\"");\n            String user = session.getProperties().getProperty(\""mail.user\"");\n            String searchQueryForeName = request.getParameter(\""forename\"");\n            String searchQuerySurName = request.getParameter(\""surname\"");\n\n            Model m = new Model(user);\n\n            try {\n                String resultTable = m.search(searchQueryForeName, searchQuerySurName, user);\n                httpSession.setAttribute(\""results\"", resultTable);\n                httpSession.setAttribute(\""success\"", \""\"");\n                request.getRequestDispatcher(\""contact.jsp\"").forward(request, response);\n            } catch (SQLException e) {\n                RequestDispatcher dispatcher = request.getRequestDispatcher(\""Error\""); //New Request Dispatcher\n                request.setAttribute(\""error\"", e.getMessage());\n                request.setAttribute(\""previous\"", \""searchcontact\"");\n                dispatcher.forward(request, response);\n            }\n        }\n    }"", ""target"": 0}, {""func_name"": ""doPost"", ""file_path"": ""src/AddContact.java"", ""func_code"": ""protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //Checks whether session has timed out\n        if (System.currentTimeMillis() > (request.getSession().getLastAccessedTime() + 300000)) {\n            RequestDispatcher dispatcher = request.getRequestDispatcher(\""Error\"");    //New Request Dispatcher\n            request.setAttribute(\""error\"", \""Login session timed out, please click retry to log back in\"");\n            request.setAttribute(\""previous\"", \""index.html\"");\n            dispatcher.forward(request, response);    //Forwards to the page\n        } else {\n\n            HttpSession httpSession = request.getSession();     //Get Session details\n            Session session = (Session) httpSession.getAttribute(\""session\"");\n            String user = session.getProperties().getProperty(\""mail.user\"");\n\n            String forename = request.getParameter(\""firstname\"");\n            String surname = request.getParameter(\""secondname\"");\n            String email = request.getParameter(\""email\"");\n\n            Model m = new Model(user);      //Initialize model\n\n            try {\n                m.addContact(forename, surname, email, user);\n                httpSession.setAttribute(\""success\"", \""<p id=\\\""success\\\"">Contact saved successfully</p>\"");\n                request.getRequestDispatcher(\""addcontact.jsp\"").forward(request, response);\n            } catch (SQLException e) {\n\n                RequestDispatcher dispatcher = request.getRequestDispatcher(\""Error\""); //New Request Dispatcher\n                request.setAttribute(\""error\"", e.getMessage());\n                request.setAttribute(\""previous\"", \""searchcontact\"");\n                dispatcher.forward(request, response);\n            }\n        }\n    }"", ""target"": 2}]","[{""func_name"": ""doPost"", ""file_path"": ""src/Login.java"", ""func_code"": ""protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n\n        String username = request.getParameter(\""username\""); //Gets all the parameters\n        String password = request.getParameter(\""password\"");\n        Properties prop = System.getProperties();\n\n        try {\n\n            prop.put(\""mail.user\"", username);\n            prop.put(\""mail.password\"", password);\n            prop.put(\""mail.smtp.auth\"", \""true\"");\n            prop.put(\""mail.smtp.starttls.enable\"", \""true\"");\n            prop.put(\""mail.smtp.host\"", \""smtp.gmail.com\"");\n            prop.put(\""mail.smtp.port\"", \""587\"");\n            prop.put(\""mail.store.protocol\"", \""imaps\"");\n\n            Session session = Session.getDefaultInstance(prop);\n            Store store = session.getStore(\""imaps\"");\n            store.connect(\""imap.googlemail.com\"", username, password);\n\n            request.getSession().setAttribute(\""session\"", session);\n\n            RequestDispatcher dispatcher = request.getRequestDispatcher(\""email.html\"");\n            dispatcher.forward(request, response);\n\n        } catch (MessagingException e) {\n            RequestDispatcher dispatcher = request.getRequestDispatcher(\""Error\""); //New Request Dispatcher\n            request.setAttribute(\""error\"", e.getMessage());\n            request.setAttribute(\""previous\"", \""index.html\"");\n            dispatcher.forward(request, response);\n        }\n    }""}, {""func_name"": ""doPost"", ""file_path"": ""src/Error.java"", ""func_code"": ""protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        PrintWriter out = response.getWriter();    //Gets the PrintWriter\n        String back = (String) request.getAttribute(\""previous\"");\n        out.println(\n                \""<!DOCTYPE html>\"" +\n                        \""<html>\"" +\n                        \""<head lang=\\\""en\\\"">\"" +\n                        \""<meta charset=\\\""UTF-8\\\"">\"" +\n                        \""<title>Error Occured</title>\"" +\n                        \""</head>\"" +\n                        \""<body>\"" +\n                        \""<center>\"" +\n                        \""<h1>Error Occurred!</h1>\"" +\n                        \""<div>\"" +\n                        \""<br>\"" +\n                        \""Error: \"" + request.getAttribute(\""error\"") + \""<br>\"" + \""<br>\"" + \""<br>\"" +//Gets the error message\n                        \""</div>\"" +\n                        \""<div class='error-actions'>\"" +\n                        \""<a href='\"" + back + \""'>Retry</a>\"" +\n                        \""</div>\"" +\n                        \""</center>\"" +\n                        \""</body>\"" +\n                        \""</html>\""\n        );\n    }""}, {""func_name"": ""doGet"", ""file_path"": ""src/Error.java"", ""func_code"": ""protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }""}, {""func_name"": ""addContact"", ""file_path"": ""src/Model.java"", ""func_code"": ""public void addContact(String firstname, String surname, String email, String user) throws SQLException {\n\n        PreparedStatement checkDuplicate = conn.prepareStatement(\""SELECT * FROM contactinfo WHERE emailaddress = ?\"");\n        checkDuplicate.setString(1, email);\n        ResultSet rs = checkDuplicate.executeQuery();\n        if (rs.next()) {\n            throw new SQLException(\""Contact already exists\"");\n        }\n        PreparedStatement newStudent = conn.prepareStatement(\""INSERT INTO \"" +\n                \""contactinfo (forename, familyname, emailaddress, contactemailaddress) VALUES (?, ?, ?, ?)\"");\n        newStudent.setString(1, firstname);\n        newStudent.setString(2, surname);\n        newStudent.setString(3, email);\n        newStudent.setString(4, user);\n        newStudent.execute();\n\n        conn.close();\n    }""}, {""func_name"": ""search"", ""file_path"": ""src/Model.java"", ""func_code"": ""public String search(String forename, String surname, String contactemail) throws SQLException {\n\n        String query;\n        if (forename.isEmpty() && surname.isEmpty()) {\n            query = \""\"";\n        } else if (forename.isEmpty()) {\n            query = \""familyname LIKE '%\"" + surname + \""' and\"";\n        } else if (surname.isEmpty()) {\n            query = \""forename LIKE '%\"" + forename + \""' and \"";\n        } else {\n            query = \""forename LIKE '%\"" + forename + \""' and familyname LIKE '%\"" + surname + \""' and\"";\n        }\n\n        PreparedStatement ps = conn.prepareStatement(\""SELECT * FROM contactinfo WHERE ? contactemailaddress = ?\"");\n        ps.setString(1, query);\n        ps.setString(2, contactemail);\n        ResultSet rs = ps.executeQuery();\n        StringBuilder result = new StringBuilder(\""<h3>Search results...</h3><table class=\\\""result-table\\\"">\"" +\n                \""<tr>\"" +\n                \""<th>Forename</th> <th>Surname</th> <th>Email</th>\"" +\n                \""</tr>\"");\n        while (rs.next())\n        {\n            result.append(\""<tr><td>\"");\n            result.append(rs.getString(2));\n            result.append(\""</td><td>\"" + rs.getString(3));\n            result.append(\""</td><td>\"" + rs.getString(4) + \""</td></tr>\"");\n        }\n\n        result.append(\""</table\"");\n        conn.close();\n        return result.toString();\n    }""}, {""func_name"": ""doPost"", ""file_path"": ""src/SearchContact.java"", ""func_code"": ""protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //Checks whether session has timed out\n        if (System.currentTimeMillis() > (request.getSession().getLastAccessedTime() + 300000)) {\n            RequestDispatcher dispatcher = request.getRequestDispatcher(\""Error\"");    //New Request Dispatcher\n            request.setAttribute(\""error\"", \""Login session timed out, please click retry to log back in\"");\n            request.setAttribute(\""previous\"", \""index.html\"");\n            dispatcher.forward(request, response);    //Forwards to the page\n        } else {\n            HttpSession httpSession = request.getSession();\n            Session session = (Session) httpSession.getAttribute(\""session\"");\n            String user = session.getProperties().getProperty(\""mail.user\"");\n            String searchQueryForeName = request.getParameter(\""forename\"");\n            String searchQuerySurName = request.getParameter(\""surname\"");\n\n            Model m = new Model(user);\n\n            try {\n                String resultTable = m.search(searchQueryForeName, searchQuerySurName, user);\n                httpSession.setAttribute(\""results\"", resultTable);\n                httpSession.setAttribute(\""success\"", \""\"");\n                request.getRequestDispatcher(\""contact.jsp\"").forward(request, response);\n            } catch (SQLException e) {\n                RequestDispatcher dispatcher = request.getRequestDispatcher(\""Error\""); //New Request Dispatcher\n                request.setAttribute(\""error\"", e.getMessage());\n                request.setAttribute(\""previous\"", \""contact.jsp\"");\n                dispatcher.forward(request, response);\n            }\n        }\n    }""}, {""func_name"": ""doPost"", ""file_path"": ""src/AddContact.java"", ""func_code"": ""protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //Checks whether session has timed out\n        if (System.currentTimeMillis() > (request.getSession().getLastAccessedTime() + 300000)) {\n            RequestDispatcher dispatcher = request.getRequestDispatcher(\""Error\"");    //New Request Dispatcher\n            request.setAttribute(\""error\"", \""Login session timed out, please click retry to log back in\"");\n            request.setAttribute(\""previous\"", \""index.html\"");\n            dispatcher.forward(request, response);    //Forwards to the page\n        } else {\n\n            HttpSession httpSession = request.getSession();     //Get Session details\n            Session session = (Session) httpSession.getAttribute(\""session\"");\n            String user = session.getProperties().getProperty(\""mail.user\"");\n\n            String forename = request.getParameter(\""firstname\"");\n            String surname = request.getParameter(\""secondname\"");\n            String email = request.getParameter(\""email\"");\n\n            Model m = new Model(user);      //Initialize model\n\n            try {\n                m.addContact(forename, surname, email, user);\n                httpSession.setAttribute(\""success\"", \""<p id=\\\""success\\\"">Contact saved successfully</p>\"");\n                request.getRequestDispatcher(\""addcontact.jsp\"").forward(request, response);\n            } catch (SQLException e) {\n\n                RequestDispatcher dispatcher = request.getRequestDispatcher(\""Error\""); //New Request Dispatcher\n                request.setAttribute(\""error\"", e.getMessage());\n                request.setAttribute(\""previous\"", \""addcontact.jsp\"");\n                dispatcher.forward(request, response);\n            }\n        }\n    }""}]",{},[],"Root cause: src/Model.java:search previously constructed SQL queries by concatenating user input (forename/surname) into the WHERE clause. Patched code uses PreparedStatement with ? placeholders, treating inputs as data, not executable SQL. No external context is required as the fix is fully contained in the patch.",0.95,./github/other_context/CVE-2014-125075
8,CVE-2014-3487,CWE-20,c_cpp,"The cdf_read_property_info function in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, does not properly validate a stream offset, which allows remote attackers to cause a denial of service (application crash) via a crafted CDF file.",https://github.com/file/file/commit/93e063ee374b6a75729df9e7201fb511e47e259d,"Add missing check offset test (Francisco Alonso, Jan Kaluza at RedHat)",3,"[{""func_name"": ""cdf_read_property_info"", ""file_path"": ""src/cdf.c"", ""func_code"": ""int\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\""section len: %u properties %u\\n\"", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\""Ran of the end %p > %p\\n\"", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\""%\"" SIZE_T_FORMAT \""u) id=%x type=%x offs=0x%tx,0x%x\\n\"",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\""CDF_VECTOR with nelements == 0\\n\""));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\""nelements = %\"" SIZE_T_FORMAT \""u\\n\"",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\""l = %d, r = %\"" SIZE_T_FORMAT\n\t\t\t\t    \""u, s = %s\\n\"", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\""Don't know how to deal with %x\\n\"",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}"", ""target"": 0}, {""func_name"": ""cdf_read_property_info"", ""file_path"": ""ext/fileinfo/libmagic/cdf.c"", ""func_code"": ""int\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\""section len: %u properties %u\\n\"", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\""Ran of the end %p > %p\\n\"", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\""%\"" SIZE_T_FORMAT \""u) id=%x type=%x offs=0x%tx,0x%x\\n\"",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\""CDF_VECTOR with nelements == 0\\n\""));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\""nelements = %\"" SIZE_T_FORMAT \""u\\n\"",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties; \n\t\t\t    j++, i++) \n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\""l = %d, r = %\"" SIZE_T_FORMAT\n\t\t\t\t    \""u, s = %s\\n\"", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\""Don't know how to deal with %x\\n\"",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}"", ""target"": 0}, {""func_name"": ""cdf_read_property_info"", ""file_path"": ""ext/fileinfo/libmagic/cdf.c"", ""func_code"": ""int\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\""section len: %u properties %u\\n\"", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\""Ran of the end %p > %p\\n\"", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\""%\"" SIZE_T_FORMAT \""u) id=%x type=%x offs=0x%tx,0x%x\\n\"",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\""CDF_VECTOR with nelements == 0\\n\""));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\""nelements = %\"" SIZE_T_FORMAT \""u\\n\"",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties; \n\t\t\t    j++, i++) \n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\""l = %d, r = %\"" SIZE_T_FORMAT\n\t\t\t\t    \""u, s = %s\\n\"", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\""Don't know how to deal with %x\\n\"",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}"", ""target"": 0}]","[{""func_name"": ""cdf_read_property_info"", ""file_path"": ""src/cdf.c"", ""func_code"": ""int\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\""section len: %u properties %u\\n\"", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t tail = (i << 1) + 1;\n\t\tif (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),\n\t\t    __LINE__) == -1)\n\t\t\tgoto out;\n\t\tsize_t ofs = CDF_GETUINT32(p, tail);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\""Ran of the end %p > %p\\n\"", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\""%\"" SIZE_T_FORMAT \""u) id=%x type=%x offs=0x%tx,0x%x\\n\"",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\""CDF_VECTOR with nelements == 0\\n\""));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\""nelements = %\"" SIZE_T_FORMAT \""u\\n\"",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\""l = %d, r = %\"" SIZE_T_FORMAT\n\t\t\t\t    \""u, s = %s\\n\"", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\""Don't know how to deal with %x\\n\"",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}""}, {""func_name"": ""cdf_read_property_info"", ""file_path"": ""ext/fileinfo/libmagic/cdf.c"", ""func_code"": ""int\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\""section len: %u properties %u\\n\"", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t ofs, tail = (i << 1) + 1;\n\t\tif (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),\n\t\t    __LINE__) == -1)\n\t\t\tgoto out;\n\t\tofs = CDF_GETUINT32(p, tail);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\""Ran of the end %p > %p\\n\"", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\""%\"" SIZE_T_FORMAT \""u) id=%x type=%x offs=0x%tx,0x%x\\n\"",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\""CDF_VECTOR with nelements == 0\\n\""));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\""nelements = %\"" SIZE_T_FORMAT \""u\\n\"",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties; \n\t\t\t    j++, i++) \n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\""l = %d, r = %\"" SIZE_T_FORMAT\n\t\t\t\t    \""u, s = %s\\n\"", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\""Don't know how to deal with %x\\n\"",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}""}, {""func_name"": ""cdf_read_property_info"", ""file_path"": ""ext/fileinfo/libmagic/cdf.c"", ""func_code"": ""int\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\""section len: %u properties %u\\n\"", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t ofs, tail = (i << 1) + 1;\n\t\tif (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),\n\t\t    __LINE__) == -1)\n\t\t\tgoto out;\n\t\tofs = CDF_GETUINT32(p, tail);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\""Ran of the end %p > %p\\n\"", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\""%\"" SIZE_T_FORMAT \""u) id=%x type=%x offs=0x%tx,0x%x\\n\"",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\""CDF_VECTOR with nelements == 0\\n\""));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\""nelements = %\"" SIZE_T_FORMAT \""u\\n\"",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties; \n\t\t\t    j++, i++) \n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\""l = %d, r = %\"" SIZE_T_FORMAT\n\t\t\t\t    \""u, s = %s\\n\"", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\""Don't know how to deal with %x\\n\"",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}""}]","{""function"": 2}","[{""source"": ""func_info(file:cdf.c, func:cdf_check_stream_offset)"", ""result"": [{""code"": ""static int\ncdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\""%d: offset begin %p < end %p || %\"" SIZE_T_FORMAT \""u\""\n\t    \"" > %\"" SIZE_T_FORMAT \""u [%\"" SIZE_T_FORMAT \""u %\""\n\t    SIZE_T_FORMAT \""u]\\n\"", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}"", ""start_line"": 264, ""end_line"": 281, ""full_name"": ""cdf_check_stream_offset"", ""file_path"": ""src/cdf.c""}]}, {""source"": ""func_info(func:cdf_check_stream_offset)"", ""result"": [{""code"": ""static int\ncdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\""%d: offset begin %p < end %p || %\"" SIZE_T_FORMAT \""u\""\n\t    \"" > %\"" SIZE_T_FORMAT \""u [%\"" SIZE_T_FORMAT \""u %\""\n\t    SIZE_T_FORMAT \""u]\\n\"", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}"", ""start_line"": 264, ""end_line"": 281, ""full_name"": ""cdf_check_stream_offset"", ""file_path"": ""src/cdf.c""}]}]","In cdf_read_property_info (src/cdf.c:817, ext/fileinfo/libmagic/cdf.c:817), the original code calculated 'ofs' using CDF_GETUINT32(p, (i << 1) + 1) without validating if the offset was within the stream's bounds. The patch adds a call to cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t), __LINE__), which verifies that the calculated 'tail' offset does not exceed the stream's size. The function cdf_check_stream_offset (src/cdf.c:264-281) ensures the computed end offset 'e' is within the valid range [b, ss*sst->sst_len], preventing out-of-bounds memory access that could lead to a crash.",0.95,./github/other_context/CVE-2014-3487
9,CVE-2015-2752,CWE-20,c_cpp,"The XEN_DOMCTL_memory_mapping hypercall in Xen 3.2.x through 4.5.x, when using a PCI passthrough device, is not preemptible, which allows local x86 HVM domain users to cause a denial of service (host CPU consumption) via a crafted request to the device model (qemu-dm).",https://github.com/xen-project/xen/commit/b10bca0483a1fa74de99807b89b13b27064794e1,"Limit XEN_DOMCTL_memory_mapping hypercall to only process up to 64 GFNs (or less)\n\nSaid hypercall for large BARs can take quite a while. As such\nwe can require that the hypercall MUST break up the request\nin smaller values.\n\nAnother approach is to add preemption to it - whether we do the\npreemption using hypercall_create_continuation or returning\nEAGAIN to userspace (and have it re-invocate the call) - either\nway the issue we cannot easily solve is that in 'map_mmio_regions'\nif we encounter an error we MUST call 'unmap_mmio_regions' for the\nwhole BAR region.\n\nSince the preemption would re-use input fields such as nr_mfns,\nfirst_gfn, first_mfn - we would lose the original values -\nand only undo what was done in the current round (i.e. ignoring\nanything that was done prior to earlier preemptions).\n\nUnless we re-used the return value as 'EAGAIN|nr_mfns_done<<10' but\nthat puts a limit (since the return value is a long) on the amount\nof nr_mfns that can provided.\n\nThis patch sidesteps this problem by:\n - Setting an hard limit of nr_mfns having to be 64 or less.\n - Toolstack adjusts correspondingly to the nr_mfn limit.\n - If the there is an error when adding the toolstack will call the\n   remove operation to remove the whole region.\n\nThe need to break this hypercall down is for large BARs can take\nmore than the guest (initial domain usually) time-slice. This has\nthe negative result in that the guest is locked out for a long\nduration and is unable to act on any pending events.\n\nWe also augment the code to return zero if nr_mfns instead\nof trying to the hypercall.\n\nThis is XSA-125 / CVE-2015-2752.\n\nSuggested-by: Jan Beulich <jbeulich@suse.com>\nAcked-by: Jan Beulich <jbeulich@suse.com>\nSigned-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\nAcked-by: Ian Campbell <ian.campbell@citrix.com>",2,"[{""func_name"": ""do_domctl"", ""file_path"": ""xen/common/domctl.c"", ""func_code"": ""long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    long ret = 0;\n    bool_t copyback = 0;\n    struct xen_domctl curop, *op = &curop;\n    struct domain *d;\n\n    if ( copy_from_guest(op, u_domctl, 1) )\n        return -EFAULT;\n\n    if ( op->interface_version != XEN_DOMCTL_INTERFACE_VERSION )\n        return -EACCES;\n\n    switch ( op->cmd )\n    {\n    case XEN_DOMCTL_createdomain:\n    case XEN_DOMCTL_getdomaininfo:\n    case XEN_DOMCTL_test_assign_device:\n        d = NULL;\n        break;\n    default:\n        d = rcu_lock_domain_by_id(op->domain);\n        if ( d == NULL )\n            return -ESRCH;\n    }\n\n    ret = xsm_domctl(XSM_OTHER, d, op->cmd);\n    if ( ret )\n        goto domctl_out_unlock_domonly;\n\n    if ( !domctl_lock_acquire() )\n    {\n        if ( d )\n            rcu_unlock_domain(d);\n        return hypercall_create_continuation(\n            __HYPERVISOR_domctl, \""h\"", u_domctl);\n    }\n\n    switch ( op->cmd )\n    {\n\n    case XEN_DOMCTL_setvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        unsigned int vcpu = op->u.vcpucontext.vcpu;\n        struct vcpu *v;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (vcpu >= d->max_vcpus) || ((v = d->vcpu[vcpu]) == NULL) )\n            break;\n\n        if ( guest_handle_is_null(op->u.vcpucontext.ctxt) )\n        {\n            ret = vcpu_reset(v);\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \""h\"", u_domctl);\n            break;\n        }\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = alloc_vcpu_guest_context()) == NULL )\n            break;\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32on64_vcpu(v) )\n            ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n        else\n            ret = copy_from_guest(c.cmp,\n                                  guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                    void), 1);\n#else\n        ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n#endif\n        ret = ret ? -EFAULT : 0;\n\n        if ( ret == 0 )\n        {\n            domain_pause(d);\n            ret = arch_set_info_guest(v, c);\n            domain_unpause(d);\n\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \""h\"", u_domctl);\n        }\n\n        free_vcpu_guest_context(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_pausedomain:\n        ret = -EINVAL;\n        if ( d != current->domain )\n            ret = domain_pause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_unpausedomain:\n        ret = domain_unpause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_resumedomain:\n        domain_resume(d);\n        break;\n\n    case XEN_DOMCTL_createdomain:\n    {\n        domid_t        dom;\n        static domid_t rover = 0;\n        unsigned int domcr_flags;\n\n        ret = -EINVAL;\n        if ( (op->u.createdomain.flags &\n             ~(XEN_DOMCTL_CDF_hvm_guest\n               | XEN_DOMCTL_CDF_pvh_guest\n               | XEN_DOMCTL_CDF_hap\n               | XEN_DOMCTL_CDF_s3_integrity\n               | XEN_DOMCTL_CDF_oos_off)) )\n            break;\n\n        dom = op->domain;\n        if ( (dom > 0) && (dom < DOMID_FIRST_RESERVED) )\n        {\n            ret = -EINVAL;\n            if ( !is_free_domid(dom) )\n                break;\n        }\n        else\n        {\n            for ( dom = rover + 1; dom != rover; dom++ )\n            {\n                if ( dom == DOMID_FIRST_RESERVED )\n                    dom = 1;\n                if ( is_free_domid(dom) )\n                    break;\n            }\n\n            ret = -ENOMEM;\n            if ( dom == rover )\n                break;\n\n            rover = dom;\n        }\n\n        if ( (op->u.createdomain.flags & XEN_DOMCTL_CDF_hvm_guest)\n             && (op->u.createdomain.flags & XEN_DOMCTL_CDF_pvh_guest) )\n            return -EINVAL;\n\n        domcr_flags = 0;\n        if ( op->u.createdomain.flags & XEN_DOMCTL_CDF_hvm_guest )\n            domcr_flags |= DOMCRF_hvm;\n        if ( op->u.createdomain.flags & XEN_DOMCTL_CDF_pvh_guest )\n            domcr_flags |= DOMCRF_pvh;\n        if ( op->u.createdomain.flags & XEN_DOMCTL_CDF_hap )\n            domcr_flags |= DOMCRF_hap;\n        if ( op->u.createdomain.flags & XEN_DOMCTL_CDF_s3_integrity )\n            domcr_flags |= DOMCRF_s3_integrity;\n        if ( op->u.createdomain.flags & XEN_DOMCTL_CDF_oos_off )\n            domcr_flags |= DOMCRF_oos_off;\n\n        d = domain_create(dom, domcr_flags, op->u.createdomain.ssidref);\n        if ( IS_ERR(d) )\n        {\n            ret = PTR_ERR(d);\n            d = NULL;\n            break;\n        }\n\n        ret = 0;\n\n        memcpy(d->handle, op->u.createdomain.handle,\n               sizeof(xen_domain_handle_t));\n\n        op->domain = d->domain_id;\n        copyback = 1;\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_max_vcpus:\n    {\n        unsigned int i, max = op->u.max_vcpus.max, cpu;\n        cpumask_t *online;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (max > domain_max_vcpus(d)) )\n            break;\n\n        /* Until Xenoprof can dynamically grow its vcpu-s array... */\n        if ( d->xenoprof )\n        {\n            ret = -EAGAIN;\n            break;\n        }\n\n        /* Needed, for example, to ensure writable p.t. state is synced. */\n        domain_pause(d);\n\n        /*\n         * Certain operations (e.g. CPU microcode updates) modify data which is\n         * used during VCPU allocation/initialization\n         */\n        while ( !spin_trylock(&vcpu_alloc_lock) )\n        {\n            if ( hypercall_preempt_check() )\n            {\n                ret =  hypercall_create_continuation(\n                    __HYPERVISOR_domctl, \""h\"", u_domctl);\n                goto maxvcpu_out_novcpulock;\n            }\n        }\n\n        /* We cannot reduce maximum VCPUs. */\n        ret = -EINVAL;\n        if ( (max < d->max_vcpus) && (d->vcpu[max] != NULL) )\n            goto maxvcpu_out;\n\n        /*\n         * For now don't allow increasing the vcpu count from a non-zero\n         * value: This code and all readers of d->vcpu would otherwise need\n         * to be converted to use RCU, but at present there's no tools side\n         * code path that would issue such a request.\n         */\n        ret = -EBUSY;\n        if ( (d->max_vcpus > 0) && (max > d->max_vcpus) )\n            goto maxvcpu_out;\n\n        ret = -ENOMEM;\n        online = cpupool_online_cpumask(d->cpupool);\n        if ( max > d->max_vcpus )\n        {\n            struct vcpu **vcpus;\n\n            BUG_ON(d->vcpu != NULL);\n            BUG_ON(d->max_vcpus != 0);\n\n            if ( (vcpus = xzalloc_array(struct vcpu *, max)) == NULL )\n                goto maxvcpu_out;\n\n            /* Install vcpu array /then/ update max_vcpus. */\n            d->vcpu = vcpus;\n            smp_wmb();\n            d->max_vcpus = max;\n        }\n\n        for ( i = 0; i < max; i++ )\n        {\n            if ( d->vcpu[i] != NULL )\n                continue;\n\n            cpu = (i == 0) ?\n                default_vcpu0_location(online) :\n                cpumask_cycle(d->vcpu[i-1]->processor, online);\n\n            if ( alloc_vcpu(d, i, cpu) == NULL )\n                goto maxvcpu_out;\n        }\n\n        ret = 0;\n\n    maxvcpu_out:\n        spin_unlock(&vcpu_alloc_lock);\n\n    maxvcpu_out_novcpulock:\n        domain_unpause(d);\n        break;\n    }\n\n    case XEN_DOMCTL_destroydomain:\n        ret = domain_kill(d);\n        if ( ret == -ERESTART )\n            ret = hypercall_create_continuation(\n                __HYPERVISOR_domctl, \""h\"", u_domctl);\n        break;\n\n    case XEN_DOMCTL_setnodeaffinity:\n    {\n        nodemask_t new_affinity;\n\n        ret = xenctl_bitmap_to_nodemask(&new_affinity,\n                                        &op->u.nodeaffinity.nodemap);\n        if ( !ret )\n            ret = domain_set_node_affinity(d, &new_affinity);\n        break;\n    }\n\n    case XEN_DOMCTL_getnodeaffinity:\n        ret = nodemask_to_xenctl_bitmap(&op->u.nodeaffinity.nodemap,\n                                        &d->node_affinity);\n        break;\n\n    case XEN_DOMCTL_setvcpuaffinity:\n    case XEN_DOMCTL_getvcpuaffinity:\n    {\n        struct vcpu *v;\n        xen_domctl_vcpuaffinity_t *vcpuaff = &op->u.vcpuaffinity;\n\n        ret = -EINVAL;\n        if ( vcpuaff->vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[vcpuaff->vcpu]) == NULL )\n            break;\n\n        ret = -EINVAL;\n        if ( vcpuaffinity_params_invalid(vcpuaff) )\n            break;\n\n        if ( op->cmd == XEN_DOMCTL_setvcpuaffinity )\n        {\n            cpumask_var_t new_affinity, old_affinity;\n            cpumask_t *online = cpupool_online_cpumask(v->domain->cpupool);;\n\n            /*\n             * We want to be able to restore hard affinity if we are trying\n             * setting both and changing soft affinity (which happens later,\n             * when hard affinity has been succesfully chaged already) fails.\n             */\n            if ( !alloc_cpumask_var(&old_affinity) )\n            {\n                ret = -ENOMEM;\n                break;\n            }\n            cpumask_copy(old_affinity, v->cpu_hard_affinity);\n\n            if ( !alloc_cpumask_var(&new_affinity) )\n            {\n                free_cpumask_var(old_affinity);\n                ret = -ENOMEM;\n                break;\n            }\n\n            /*\n             * We both set a new affinity and report back to the caller what\n             * the scheduler will be effectively using.\n             */\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_hard,\n                                              nr_cpu_ids);\n                if ( !ret )\n                    ret = vcpu_set_hard_affinity(v, new_affinity);\n                if ( ret )\n                    goto setvcpuaffinity_out;\n\n                /*\n                 * For hard affinity, what we return is the intersection of\n                 * cpupool's online mask and the new hard affinity.\n                 */\n                cpumask_and(new_affinity, online, v->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               new_affinity);\n            }\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_soft,\n                                              nr_cpu_ids);\n                if ( !ret)\n                    ret = vcpu_set_soft_affinity(v, new_affinity);\n                if ( ret )\n                {\n                    /*\n                     * Since we're returning error, the caller expects nothing\n                     * happened, so we rollback the changes to hard affinity\n                     * (if any).\n                     */\n                    if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                        vcpu_set_hard_affinity(v, old_affinity);\n                    goto setvcpuaffinity_out;\n                }\n\n                /*\n                 * For soft affinity, we return the intersection between the\n                 * new soft affinity, the cpupool's online map and the (new)\n                 * hard affinity.\n                 */\n                cpumask_and(new_affinity, new_affinity, online);\n                cpumask_and(new_affinity, new_affinity, v->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               new_affinity);\n            }\n\n setvcpuaffinity_out:\n            free_cpumask_var(new_affinity);\n            free_cpumask_var(old_affinity);\n        }\n        else\n        {\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               v->cpu_hard_affinity);\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               v->cpu_soft_affinity);\n        }\n        break;\n    }\n\n    case XEN_DOMCTL_scheduler_op:\n        ret = sched_adjust(d, &op->u.scheduler_op);\n        copyback = 1;\n        break;\n\n    case XEN_DOMCTL_getdomaininfo:\n    {\n        domid_t dom = op->domain;\n\n        rcu_read_lock(&domlist_read_lock);\n\n        for_each_domain ( d )\n            if ( d->domain_id >= dom )\n                break;\n\n        ret = -ESRCH;\n        if ( d == NULL )\n            goto getdomaininfo_out;\n\n        ret = xsm_getdomaininfo(XSM_HOOK, d);\n        if ( ret )\n            goto getdomaininfo_out;\n\n        getdomaininfo(d, &op->u.getdomaininfo);\n\n        op->domain = op->u.getdomaininfo.domain;\n        copyback = 1;\n\n    getdomaininfo_out:\n        rcu_read_unlock(&domlist_read_lock);\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        struct vcpu         *v;\n\n        ret = -EINVAL;\n        if ( op->u.vcpucontext.vcpu >= d->max_vcpus ||\n             (v = d->vcpu[op->u.vcpucontext.vcpu]) == NULL ||\n             v == current ) /* no vcpu_pause() */\n            goto getvcpucontext_out;\n\n        ret = -ENODATA;\n        if ( !v->is_initialised )\n            goto getvcpucontext_out;\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = xmalloc(struct vcpu_guest_context)) == NULL )\n            goto getvcpucontext_out;\n\n        vcpu_pause(v);\n\n        arch_get_info_guest(v, c);\n        ret = 0;\n\n        vcpu_unpause(v);\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32on64_vcpu(v) )\n            ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n        else\n            ret = copy_to_guest(guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                  void), c.cmp, 1);\n#else\n        ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n#endif\n\n        if ( ret )\n            ret = -EFAULT;\n        copyback = 1;\n\n    getvcpucontext_out:\n        xfree(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpuinfo:\n    {\n        struct vcpu   *v;\n        struct vcpu_runstate_info runstate;\n\n        ret = -EINVAL;\n        if ( op->u.getvcpuinfo.vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[op->u.getvcpuinfo.vcpu]) == NULL )\n            break;\n\n        vcpu_runstate_get(v, &runstate);\n\n        op->u.getvcpuinfo.online   = !test_bit(_VPF_down, &v->pause_flags);\n        op->u.getvcpuinfo.blocked  = test_bit(_VPF_blocked, &v->pause_flags);\n        op->u.getvcpuinfo.running  = v->is_running;\n        op->u.getvcpuinfo.cpu_time = runstate.time[RUNSTATE_running];\n        op->u.getvcpuinfo.cpu      = v->processor;\n        ret = 0;\n        copyback = 1;\n        break;\n    }\n\n    case XEN_DOMCTL_max_mem:\n    {\n        unsigned long new_max = op->u.max_mem.max_memkb >> (PAGE_SHIFT - 10);\n\n        spin_lock(&d->page_alloc_lock);\n        /*\n         * NB. We removed a check that new_max >= current tot_pages; this means\n         * that the domain will now be allowed to \""ratchet\"" down to new_max. In\n         * the meantime, while tot > max, all new allocations are disallowed.\n         */\n        d->max_pages = new_max;\n        spin_unlock(&d->page_alloc_lock);\n        break;\n    }\n\n    case XEN_DOMCTL_setdomainhandle:\n        memcpy(d->handle, op->u.setdomainhandle.handle,\n               sizeof(xen_domain_handle_t));\n        break;\n\n    case XEN_DOMCTL_setdebugging:\n        if ( unlikely(d == current->domain) ) /* no domain_pause() */\n            ret = -EINVAL;\n        else\n        {\n            domain_pause(d);\n            d->debugger_attached = !!op->u.setdebugging.enable;\n            domain_unpause(d); /* causes guest to latch new status */\n        }\n        break;\n\n    case XEN_DOMCTL_irq_permission:\n    {\n        unsigned int pirq = op->u.irq_permission.pirq, irq;\n        int allow = op->u.irq_permission.allow_access;\n\n        if ( pirq >= current->domain->nr_pirqs )\n        {\n            ret = -EINVAL;\n            break;\n        }\n        irq = pirq_access_permitted(current->domain, pirq);\n        if ( !irq || xsm_irq_permission(XSM_HOOK, d, irq, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = irq_permit_access(d, irq);\n        else\n            ret = irq_deny_access(d, irq);\n        break;\n    }\n\n    case XEN_DOMCTL_iomem_permission:\n    {\n        unsigned long mfn = op->u.iomem_permission.first_mfn;\n        unsigned long nr_mfns = op->u.iomem_permission.nr_mfns;\n        int allow = op->u.iomem_permission.allow_access;\n\n        ret = -EINVAL;\n        if ( (mfn + nr_mfns - 1) < mfn ) /* wrap? */\n            break;\n\n        if ( !iomem_access_permitted(current->domain,\n                                     mfn, mfn + nr_mfns - 1) ||\n             xsm_iomem_permission(XSM_HOOK, d, mfn, mfn + nr_mfns - 1, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = iomem_permit_access(d, mfn, mfn + nr_mfns - 1);\n        else\n            ret = iomem_deny_access(d, mfn, mfn + nr_mfns - 1);\n        if ( !ret )\n            memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_memory_mapping:\n    {\n        unsigned long gfn = op->u.memory_mapping.first_gfn;\n        unsigned long mfn = op->u.memory_mapping.first_mfn;\n        unsigned long nr_mfns = op->u.memory_mapping.nr_mfns;\n        unsigned long mfn_end = mfn + nr_mfns - 1;\n        int add = op->u.memory_mapping.add_mapping;\n\n        ret = -EINVAL;\n        if ( mfn_end < mfn || /* wrap? */\n             ((mfn | mfn_end) >> (paddr_bits - PAGE_SHIFT)) ||\n             (gfn + nr_mfns - 1) < gfn ) /* wrap? */\n            break;\n\n        ret = -EPERM;\n        if ( !iomem_access_permitted(current->domain, mfn, mfn_end) ||\n             !iomem_access_permitted(d, mfn, mfn_end) )\n            break;\n\n        ret = xsm_iomem_mapping(XSM_HOOK, d, mfn, mfn_end, add);\n        if ( ret )\n            break;\n\n        if ( add )\n        {\n            printk(XENLOG_G_INFO\n                   \""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\\n\"",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = map_mmio_regions(d, gfn, nr_mfns, mfn);\n            if ( ret )\n                printk(XENLOG_G_WARNING\n                       \""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\\n\"",\n                       d->domain_id, gfn, mfn, nr_mfns, ret);\n        }\n        else\n        {\n            printk(XENLOG_G_INFO\n                   \""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\\n\"",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = unmap_mmio_regions(d, gfn, nr_mfns, mfn);\n            if ( ret && is_hardware_domain(current->domain) )\n                printk(XENLOG_ERR\n                       \""memory_map: error %ld removing dom%d access to [%lx,%lx]\\n\"",\n                       ret, d->domain_id, mfn, mfn_end);\n        }\n        /* Do this unconditionally to cover errors on above failure paths. */\n        memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_settimeoffset:\n        domain_set_time_offset(d, op->u.settimeoffset.time_offset_seconds);\n        break;\n\n    case XEN_DOMCTL_set_target:\n    {\n        struct domain *e;\n\n        ret = -ESRCH;\n        e = get_domain_by_id(op->u.set_target.target);\n        if ( e == NULL )\n            break;\n\n        ret = -EINVAL;\n        if ( (d == e) || (d->target != NULL) )\n        {\n            put_domain(e);\n            break;\n        }\n\n        ret = xsm_set_target(XSM_HOOK, d, e);\n        if ( ret ) {\n            put_domain(e);\n            break;\n        }\n\n        /* Hold reference on @e until we destroy @d. */\n        d->target = e;\n        break;\n    }\n\n    case XEN_DOMCTL_subscribe:\n        d->suspend_evtchn = op->u.subscribe.port;\n        break;\n\n    case XEN_DOMCTL_mem_event_op:\n        ret = mem_event_domctl(d, &op->u.mem_event_op,\n                               guest_handle_cast(u_domctl, void));\n        copyback = 1;\n        break;\n\n    case XEN_DOMCTL_disable_migrate:\n        d->disable_migrate = op->u.disable_migrate.disable;\n        break;\n\n#ifdef HAS_MEM_ACCESS\n    case XEN_DOMCTL_set_access_required:\n        if ( unlikely(current->domain == d) )\n            ret = -EPERM;\n        else\n            p2m_get_hostp2m(d)->access_required =\n                op->u.access_required.access_required;\n        break;\n#endif\n\n    case XEN_DOMCTL_set_virq_handler:\n        ret = set_global_virq_handler(d, op->u.set_virq_handler.virq);\n        break;\n\n    case XEN_DOMCTL_set_max_evtchn:\n        d->max_evtchn_port = min_t(unsigned int,\n                                   op->u.set_max_evtchn.max_port,\n                                   INT_MAX);\n        break;\n\n    case XEN_DOMCTL_setvnumainfo:\n    {\n        struct vnuma_info *vnuma;\n\n        vnuma = vnuma_init(&op->u.vnuma, d);\n        if ( IS_ERR(vnuma) )\n        {\n            ret = PTR_ERR(vnuma);\n            break;\n        }\n\n        /* overwrite vnuma topology for domain. */\n        write_lock(&d->vnuma_rwlock);\n        vnuma_destroy(d->vnuma);\n        d->vnuma = vnuma;\n        write_unlock(&d->vnuma_rwlock);\n\n        break;\n    }\n\n    default:\n        ret = arch_do_domctl(op, d, u_domctl);\n        break;\n    }\n\n    domctl_lock_release();\n\n domctl_out_unlock_domonly:\n    if ( d )\n        rcu_unlock_domain(d);\n\n    if ( copyback && __copy_to_guest(u_domctl, op, 1) )\n        ret = -EFAULT;\n\n    return ret;\n}"", ""target"": 0}, {""func_name"": ""xc_domain_memory_mapping"", ""file_path"": ""tools/libxc/xc_domain.c"", ""func_code"": ""int xc_domain_memory_mapping(\n    xc_interface *xch,\n    uint32_t domid,\n    unsigned long first_gfn,\n    unsigned long first_mfn,\n    unsigned long nr_mfns,\n    uint32_t add_mapping)\n{\n    DECLARE_DOMCTL;\n    xc_dominfo_t info;\n\n    if ( xc_domain_getinfo(xch, domid, 1, &info) != 1 ||\n         info.domid != domid )\n    {\n        PERROR(\""Could not get info for domain\"");\n        return -EINVAL;\n    }\n    if ( !xc_core_arch_auto_translated_physmap(&info) )\n        return 0;\n\n    domctl.cmd = XEN_DOMCTL_memory_mapping;\n    domctl.domain = domid;\n    domctl.u.memory_mapping.first_gfn = first_gfn;\n    domctl.u.memory_mapping.first_mfn = first_mfn;\n    domctl.u.memory_mapping.nr_mfns = nr_mfns;\n    domctl.u.memory_mapping.add_mapping = add_mapping;\n\n    return do_domctl(xch, &domctl);\n}"", ""target"": 0}]","[{""func_name"": ""do_domctl"", ""file_path"": ""xen/common/domctl.c"", ""func_code"": ""long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    long ret = 0;\n    bool_t copyback = 0;\n    struct xen_domctl curop, *op = &curop;\n    struct domain *d;\n\n    if ( copy_from_guest(op, u_domctl, 1) )\n        return -EFAULT;\n\n    if ( op->interface_version != XEN_DOMCTL_INTERFACE_VERSION )\n        return -EACCES;\n\n    switch ( op->cmd )\n    {\n    case XEN_DOMCTL_createdomain:\n    case XEN_DOMCTL_getdomaininfo:\n    case XEN_DOMCTL_test_assign_device:\n        d = NULL;\n        break;\n    default:\n        d = rcu_lock_domain_by_id(op->domain);\n        if ( d == NULL )\n            return -ESRCH;\n    }\n\n    ret = xsm_domctl(XSM_OTHER, d, op->cmd);\n    if ( ret )\n        goto domctl_out_unlock_domonly;\n\n    if ( !domctl_lock_acquire() )\n    {\n        if ( d )\n            rcu_unlock_domain(d);\n        return hypercall_create_continuation(\n            __HYPERVISOR_domctl, \""h\"", u_domctl);\n    }\n\n    switch ( op->cmd )\n    {\n\n    case XEN_DOMCTL_setvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        unsigned int vcpu = op->u.vcpucontext.vcpu;\n        struct vcpu *v;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (vcpu >= d->max_vcpus) || ((v = d->vcpu[vcpu]) == NULL) )\n            break;\n\n        if ( guest_handle_is_null(op->u.vcpucontext.ctxt) )\n        {\n            ret = vcpu_reset(v);\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \""h\"", u_domctl);\n            break;\n        }\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = alloc_vcpu_guest_context()) == NULL )\n            break;\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32on64_vcpu(v) )\n            ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n        else\n            ret = copy_from_guest(c.cmp,\n                                  guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                    void), 1);\n#else\n        ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n#endif\n        ret = ret ? -EFAULT : 0;\n\n        if ( ret == 0 )\n        {\n            domain_pause(d);\n            ret = arch_set_info_guest(v, c);\n            domain_unpause(d);\n\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \""h\"", u_domctl);\n        }\n\n        free_vcpu_guest_context(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_pausedomain:\n        ret = -EINVAL;\n        if ( d != current->domain )\n            ret = domain_pause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_unpausedomain:\n        ret = domain_unpause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_resumedomain:\n        domain_resume(d);\n        break;\n\n    case XEN_DOMCTL_createdomain:\n    {\n        domid_t        dom;\n        static domid_t rover = 0;\n        unsigned int domcr_flags;\n\n        ret = -EINVAL;\n        if ( (op->u.createdomain.flags &\n             ~(XEN_DOMCTL_CDF_hvm_guest\n               | XEN_DOMCTL_CDF_pvh_guest\n               | XEN_DOMCTL_CDF_hap\n               | XEN_DOMCTL_CDF_s3_integrity\n               | XEN_DOMCTL_CDF_oos_off)) )\n            break;\n\n        dom = op->domain;\n        if ( (dom > 0) && (dom < DOMID_FIRST_RESERVED) )\n        {\n            ret = -EINVAL;\n            if ( !is_free_domid(dom) )\n                break;\n        }\n        else\n        {\n            for ( dom = rover + 1; dom != rover; dom++ )\n            {\n                if ( dom == DOMID_FIRST_RESERVED )\n                    dom = 1;\n                if ( is_free_domid(dom) )\n                    break;\n            }\n\n            ret = -ENOMEM;\n            if ( dom == rover )\n                break;\n\n            rover = dom;\n        }\n\n        if ( (op->u.createdomain.flags & XEN_DOMCTL_CDF_hvm_guest)\n             && (op->u.createdomain.flags & XEN_DOMCTL_CDF_pvh_guest) )\n            return -EINVAL;\n\n        domcr_flags = 0;\n        if ( op->u.createdomain.flags & XEN_DOMCTL_CDF_hvm_guest )\n            domcr_flags |= DOMCRF_hvm;\n        if ( op->u.createdomain.flags & XEN_DOMCTL_CDF_pvh_guest )\n            domcr_flags |= DOMCRF_pvh;\n        if ( op->u.createdomain.flags & XEN_DOMCTL_CDF_hap )\n            domcr_flags |= DOMCRF_hap;\n        if ( op->u.createdomain.flags & XEN_DOMCTL_CDF_s3_integrity )\n            domcr_flags |= DOMCRF_s3_integrity;\n        if ( op->u.createdomain.flags & XEN_DOMCTL_CDF_oos_off )\n            domcr_flags |= DOMCRF_oos_off;\n\n        d = domain_create(dom, domcr_flags, op->u.createdomain.ssidref);\n        if ( IS_ERR(d) )\n        {\n            ret = PTR_ERR(d);\n            d = NULL;\n            break;\n        }\n\n        ret = 0;\n\n        memcpy(d->handle, op->u.createdomain.handle,\n               sizeof(xen_domain_handle_t));\n\n        op->domain = d->domain_id;\n        copyback = 1;\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_max_vcpus:\n    {\n        unsigned int i, max = op->u.max_vcpus.max, cpu;\n        cpumask_t *online;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (max > domain_max_vcpus(d)) )\n            break;\n\n        /* Until Xenoprof can dynamically grow its vcpu-s array... */\n        if ( d->xenoprof )\n        {\n            ret = -EAGAIN;\n            break;\n        }\n\n        /* Needed, for example, to ensure writable p.t. state is synced. */\n        domain_pause(d);\n\n        /*\n         * Certain operations (e.g. CPU microcode updates) modify data which is\n         * used during VCPU allocation/initialization\n         */\n        while ( !spin_trylock(&vcpu_alloc_lock) )\n        {\n            if ( hypercall_preempt_check() )\n            {\n                ret =  hypercall_create_continuation(\n                    __HYPERVISOR_domctl, \""h\"", u_domctl);\n                goto maxvcpu_out_novcpulock;\n            }\n        }\n\n        /* We cannot reduce maximum VCPUs. */\n        ret = -EINVAL;\n        if ( (max < d->max_vcpus) && (d->vcpu[max] != NULL) )\n            goto maxvcpu_out;\n\n        /*\n         * For now don't allow increasing the vcpu count from a non-zero\n         * value: This code and all readers of d->vcpu would otherwise need\n         * to be converted to use RCU, but at present there's no tools side\n         * code path that would issue such a request.\n         */\n        ret = -EBUSY;\n        if ( (d->max_vcpus > 0) && (max > d->max_vcpus) )\n            goto maxvcpu_out;\n\n        ret = -ENOMEM;\n        online = cpupool_online_cpumask(d->cpupool);\n        if ( max > d->max_vcpus )\n        {\n            struct vcpu **vcpus;\n\n            BUG_ON(d->vcpu != NULL);\n            BUG_ON(d->max_vcpus != 0);\n\n            if ( (vcpus = xzalloc_array(struct vcpu *, max)) == NULL )\n                goto maxvcpu_out;\n\n            /* Install vcpu array /then/ update max_vcpus. */\n            d->vcpu = vcpus;\n            smp_wmb();\n            d->max_vcpus = max;\n        }\n\n        for ( i = 0; i < max; i++ )\n        {\n            if ( d->vcpu[i] != NULL )\n                continue;\n\n            cpu = (i == 0) ?\n                default_vcpu0_location(online) :\n                cpumask_cycle(d->vcpu[i-1]->processor, online);\n\n            if ( alloc_vcpu(d, i, cpu) == NULL )\n                goto maxvcpu_out;\n        }\n\n        ret = 0;\n\n    maxvcpu_out:\n        spin_unlock(&vcpu_alloc_lock);\n\n    maxvcpu_out_novcpulock:\n        domain_unpause(d);\n        break;\n    }\n\n    case XEN_DOMCTL_destroydomain:\n        ret = domain_kill(d);\n        if ( ret == -ERESTART )\n            ret = hypercall_create_continuation(\n                __HYPERVISOR_domctl, \""h\"", u_domctl);\n        break;\n\n    case XEN_DOMCTL_setnodeaffinity:\n    {\n        nodemask_t new_affinity;\n\n        ret = xenctl_bitmap_to_nodemask(&new_affinity,\n                                        &op->u.nodeaffinity.nodemap);\n        if ( !ret )\n            ret = domain_set_node_affinity(d, &new_affinity);\n        break;\n    }\n\n    case XEN_DOMCTL_getnodeaffinity:\n        ret = nodemask_to_xenctl_bitmap(&op->u.nodeaffinity.nodemap,\n                                        &d->node_affinity);\n        break;\n\n    case XEN_DOMCTL_setvcpuaffinity:\n    case XEN_DOMCTL_getvcpuaffinity:\n    {\n        struct vcpu *v;\n        xen_domctl_vcpuaffinity_t *vcpuaff = &op->u.vcpuaffinity;\n\n        ret = -EINVAL;\n        if ( vcpuaff->vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[vcpuaff->vcpu]) == NULL )\n            break;\n\n        ret = -EINVAL;\n        if ( vcpuaffinity_params_invalid(vcpuaff) )\n            break;\n\n        if ( op->cmd == XEN_DOMCTL_setvcpuaffinity )\n        {\n            cpumask_var_t new_affinity, old_affinity;\n            cpumask_t *online = cpupool_online_cpumask(v->domain->cpupool);;\n\n            /*\n             * We want to be able to restore hard affinity if we are trying\n             * setting both and changing soft affinity (which happens later,\n             * when hard affinity has been succesfully chaged already) fails.\n             */\n            if ( !alloc_cpumask_var(&old_affinity) )\n            {\n                ret = -ENOMEM;\n                break;\n            }\n            cpumask_copy(old_affinity, v->cpu_hard_affinity);\n\n            if ( !alloc_cpumask_var(&new_affinity) )\n            {\n                free_cpumask_var(old_affinity);\n                ret = -ENOMEM;\n                break;\n            }\n\n            /*\n             * We both set a new affinity and report back to the caller what\n             * the scheduler will be effectively using.\n             */\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_hard,\n                                              nr_cpu_ids);\n                if ( !ret )\n                    ret = vcpu_set_hard_affinity(v, new_affinity);\n                if ( ret )\n                    goto setvcpuaffinity_out;\n\n                /*\n                 * For hard affinity, what we return is the intersection of\n                 * cpupool's online mask and the new hard affinity.\n                 */\n                cpumask_and(new_affinity, online, v->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               new_affinity);\n            }\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_soft,\n                                              nr_cpu_ids);\n                if ( !ret)\n                    ret = vcpu_set_soft_affinity(v, new_affinity);\n                if ( ret )\n                {\n                    /*\n                     * Since we're returning error, the caller expects nothing\n                     * happened, so we rollback the changes to hard affinity\n                     * (if any).\n                     */\n                    if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                        vcpu_set_hard_affinity(v, old_affinity);\n                    goto setvcpuaffinity_out;\n                }\n\n                /*\n                 * For soft affinity, we return the intersection between the\n                 * new soft affinity, the cpupool's online map and the (new)\n                 * hard affinity.\n                 */\n                cpumask_and(new_affinity, new_affinity, online);\n                cpumask_and(new_affinity, new_affinity, v->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               new_affinity);\n            }\n\n setvcpuaffinity_out:\n            free_cpumask_var(new_affinity);\n            free_cpumask_var(old_affinity);\n        }\n        else\n        {\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               v->cpu_hard_affinity);\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               v->cpu_soft_affinity);\n        }\n        break;\n    }\n\n    case XEN_DOMCTL_scheduler_op:\n        ret = sched_adjust(d, &op->u.scheduler_op);\n        copyback = 1;\n        break;\n\n    case XEN_DOMCTL_getdomaininfo:\n    {\n        domid_t dom = op->domain;\n\n        rcu_read_lock(&domlist_read_lock);\n\n        for_each_domain ( d )\n            if ( d->domain_id >= dom )\n                break;\n\n        ret = -ESRCH;\n        if ( d == NULL )\n            goto getdomaininfo_out;\n\n        ret = xsm_getdomaininfo(XSM_HOOK, d);\n        if ( ret )\n            goto getdomaininfo_out;\n\n        getdomaininfo(d, &op->u.getdomaininfo);\n\n        op->domain = op->u.getdomaininfo.domain;\n        copyback = 1;\n\n    getdomaininfo_out:\n        rcu_read_unlock(&domlist_read_lock);\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        struct vcpu         *v;\n\n        ret = -EINVAL;\n        if ( op->u.vcpucontext.vcpu >= d->max_vcpus ||\n             (v = d->vcpu[op->u.vcpucontext.vcpu]) == NULL ||\n             v == current ) /* no vcpu_pause() */\n            goto getvcpucontext_out;\n\n        ret = -ENODATA;\n        if ( !v->is_initialised )\n            goto getvcpucontext_out;\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = xmalloc(struct vcpu_guest_context)) == NULL )\n            goto getvcpucontext_out;\n\n        vcpu_pause(v);\n\n        arch_get_info_guest(v, c);\n        ret = 0;\n\n        vcpu_unpause(v);\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32on64_vcpu(v) )\n            ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n        else\n            ret = copy_to_guest(guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                  void), c.cmp, 1);\n#else\n        ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n#endif\n\n        if ( ret )\n            ret = -EFAULT;\n        copyback = 1;\n\n    getvcpucontext_out:\n        xfree(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpuinfo:\n    {\n        struct vcpu   *v;\n        struct vcpu_runstate_info runstate;\n\n        ret = -EINVAL;\n        if ( op->u.getvcpuinfo.vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[op->u.getvcpuinfo.vcpu]) == NULL )\n            break;\n\n        vcpu_runstate_get(v, &runstate);\n\n        op->u.getvcpuinfo.online   = !test_bit(_VPF_down, &v->pause_flags);\n        op->u.getvcpuinfo.blocked  = test_bit(_VPF_blocked, &v->pause_flags);\n        op->u.getvcpuinfo.running  = v->is_running;\n        op->u.getvcpuinfo.cpu_time = runstate.time[RUNSTATE_running];\n        op->u.getvcpuinfo.cpu      = v->processor;\n        ret = 0;\n        copyback = 1;\n        break;\n    }\n\n    case XEN_DOMCTL_max_mem:\n    {\n        unsigned long new_max = op->u.max_mem.max_memkb >> (PAGE_SHIFT - 10);\n\n        spin_lock(&d->page_alloc_lock);\n        /*\n         * NB. We removed a check that new_max >= current tot_pages; this means\n         * that the domain will now be allowed to \""ratchet\"" down to new_max. In\n         * the meantime, while tot > max, all new allocations are disallowed.\n         */\n        d->max_pages = new_max;\n        spin_unlock(&d->page_alloc_lock);\n        break;\n    }\n\n    case XEN_DOMCTL_setdomainhandle:\n        memcpy(d->handle, op->u.setdomainhandle.handle,\n               sizeof(xen_domain_handle_t));\n        break;\n\n    case XEN_DOMCTL_setdebugging:\n        if ( unlikely(d == current->domain) ) /* no domain_pause() */\n            ret = -EINVAL;\n        else\n        {\n            domain_pause(d);\n            d->debugger_attached = !!op->u.setdebugging.enable;\n            domain_unpause(d); /* causes guest to latch new status */\n        }\n        break;\n\n    case XEN_DOMCTL_irq_permission:\n    {\n        unsigned int pirq = op->u.irq_permission.pirq, irq;\n        int allow = op->u.irq_permission.allow_access;\n\n        if ( pirq >= current->domain->nr_pirqs )\n        {\n            ret = -EINVAL;\n            break;\n        }\n        irq = pirq_access_permitted(current->domain, pirq);\n        if ( !irq || xsm_irq_permission(XSM_HOOK, d, irq, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = irq_permit_access(d, irq);\n        else\n            ret = irq_deny_access(d, irq);\n        break;\n    }\n\n    case XEN_DOMCTL_iomem_permission:\n    {\n        unsigned long mfn = op->u.iomem_permission.first_mfn;\n        unsigned long nr_mfns = op->u.iomem_permission.nr_mfns;\n        int allow = op->u.iomem_permission.allow_access;\n\n        ret = -EINVAL;\n        if ( (mfn + nr_mfns - 1) < mfn ) /* wrap? */\n            break;\n\n        if ( !iomem_access_permitted(current->domain,\n                                     mfn, mfn + nr_mfns - 1) ||\n             xsm_iomem_permission(XSM_HOOK, d, mfn, mfn + nr_mfns - 1, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = iomem_permit_access(d, mfn, mfn + nr_mfns - 1);\n        else\n            ret = iomem_deny_access(d, mfn, mfn + nr_mfns - 1);\n        if ( !ret )\n            memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_memory_mapping:\n    {\n        unsigned long gfn = op->u.memory_mapping.first_gfn;\n        unsigned long mfn = op->u.memory_mapping.first_mfn;\n        unsigned long nr_mfns = op->u.memory_mapping.nr_mfns;\n        unsigned long mfn_end = mfn + nr_mfns - 1;\n        int add = op->u.memory_mapping.add_mapping;\n\n        ret = -EINVAL;\n        if ( mfn_end < mfn || /* wrap? */\n             ((mfn | mfn_end) >> (paddr_bits - PAGE_SHIFT)) ||\n             (gfn + nr_mfns - 1) < gfn ) /* wrap? */\n            break;\n\n        ret = -E2BIG;\n        /* Must break hypercall up as this could take a while. */\n        if ( nr_mfns > 64 )\n            break;\n\n        ret = -EPERM;\n        if ( !iomem_access_permitted(current->domain, mfn, mfn_end) ||\n             !iomem_access_permitted(d, mfn, mfn_end) )\n            break;\n\n        ret = xsm_iomem_mapping(XSM_HOOK, d, mfn, mfn_end, add);\n        if ( ret )\n            break;\n\n        if ( add )\n        {\n            printk(XENLOG_G_INFO\n                   \""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\\n\"",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = map_mmio_regions(d, gfn, nr_mfns, mfn);\n            if ( ret )\n                printk(XENLOG_G_WARNING\n                       \""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\\n\"",\n                       d->domain_id, gfn, mfn, nr_mfns, ret);\n        }\n        else\n        {\n            printk(XENLOG_G_INFO\n                   \""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\\n\"",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = unmap_mmio_regions(d, gfn, nr_mfns, mfn);\n            if ( ret && is_hardware_domain(current->domain) )\n                printk(XENLOG_ERR\n                       \""memory_map: error %ld removing dom%d access to [%lx,%lx]\\n\"",\n                       ret, d->domain_id, mfn, mfn_end);\n        }\n        /* Do this unconditionally to cover errors on above failure paths. */\n        memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_settimeoffset:\n        domain_set_time_offset(d, op->u.settimeoffset.time_offset_seconds);\n        break;\n\n    case XEN_DOMCTL_set_target:\n    {\n        struct domain *e;\n\n        ret = -ESRCH;\n        e = get_domain_by_id(op->u.set_target.target);\n        if ( e == NULL )\n            break;\n\n        ret = -EINVAL;\n        if ( (d == e) || (d->target != NULL) )\n        {\n            put_domain(e);\n            break;\n        }\n\n        ret = xsm_set_target(XSM_HOOK, d, e);\n        if ( ret ) {\n            put_domain(e);\n            break;\n        }\n\n        /* Hold reference on @e until we destroy @d. */\n        d->target = e;\n        break;\n    }\n\n    case XEN_DOMCTL_subscribe:\n        d->suspend_evtchn = op->u.subscribe.port;\n        break;\n\n    case XEN_DOMCTL_mem_event_op:\n        ret = mem_event_domctl(d, &op->u.mem_event_op,\n                               guest_handle_cast(u_domctl, void));\n        copyback = 1;\n        break;\n\n    case XEN_DOMCTL_disable_migrate:\n        d->disable_migrate = op->u.disable_migrate.disable;\n        break;\n\n#ifdef HAS_MEM_ACCESS\n    case XEN_DOMCTL_set_access_required:\n        if ( unlikely(current->domain == d) )\n            ret = -EPERM;\n        else\n            p2m_get_hostp2m(d)->access_required =\n                op->u.access_required.access_required;\n        break;\n#endif\n\n    case XEN_DOMCTL_set_virq_handler:\n        ret = set_global_virq_handler(d, op->u.set_virq_handler.virq);\n        break;\n\n    case XEN_DOMCTL_set_max_evtchn:\n        d->max_evtchn_port = min_t(unsigned int,\n                                   op->u.set_max_evtchn.max_port,\n                                   INT_MAX);\n        break;\n\n    case XEN_DOMCTL_setvnumainfo:\n    {\n        struct vnuma_info *vnuma;\n\n        vnuma = vnuma_init(&op->u.vnuma, d);\n        if ( IS_ERR(vnuma) )\n        {\n            ret = PTR_ERR(vnuma);\n            break;\n        }\n\n        /* overwrite vnuma topology for domain. */\n        write_lock(&d->vnuma_rwlock);\n        vnuma_destroy(d->vnuma);\n        d->vnuma = vnuma;\n        write_unlock(&d->vnuma_rwlock);\n\n        break;\n    }\n\n    default:\n        ret = arch_do_domctl(op, d, u_domctl);\n        break;\n    }\n\n    domctl_lock_release();\n\n domctl_out_unlock_domonly:\n    if ( d )\n        rcu_unlock_domain(d);\n\n    if ( copyback && __copy_to_guest(u_domctl, op, 1) )\n        ret = -EFAULT;\n\n    return ret;\n}""}, {""func_name"": ""xc_domain_memory_mapping"", ""file_path"": ""tools/libxc/xc_domain.c"", ""func_code"": ""int xc_domain_memory_mapping(\n    xc_interface *xch,\n    uint32_t domid,\n    unsigned long first_gfn,\n    unsigned long first_mfn,\n    unsigned long nr_mfns,\n    uint32_t add_mapping)\n{\n    DECLARE_DOMCTL;\n    xc_dominfo_t info;\n    int ret = 0, err;\n    unsigned long done = 0, nr, max_batch_sz;\n\n    if ( xc_domain_getinfo(xch, domid, 1, &info) != 1 ||\n         info.domid != domid )\n    {\n        PERROR(\""Could not get info for domain\"");\n        return -EINVAL;\n    }\n    if ( !xc_core_arch_auto_translated_physmap(&info) )\n        return 0;\n\n    if ( !nr_mfns )\n        return 0;\n\n    domctl.cmd = XEN_DOMCTL_memory_mapping;\n    domctl.domain = domid;\n    domctl.u.memory_mapping.add_mapping = add_mapping;\n    max_batch_sz = nr_mfns;\n    do\n    {\n        nr = min(nr_mfns - done, max_batch_sz);\n        domctl.u.memory_mapping.nr_mfns = nr;\n        domctl.u.memory_mapping.first_gfn = first_gfn + done;\n        domctl.u.memory_mapping.first_mfn = first_mfn + done;\n        err = do_domctl(xch, &domctl);\n        if ( err && errno == E2BIG )\n        {\n            if ( max_batch_sz <= 1 )\n                break;\n            max_batch_sz >>= 1;\n            continue;\n        }\n        /* Save the first error... */\n        if ( !ret )\n            ret = err;\n        /* .. and ignore the rest of them when removing. */\n        if ( err && add_mapping != DPCI_REMOVE_MAPPING )\n            break;\n\n        done += nr;\n    } while ( done < nr_mfns );\n\n    /*\n     * Undo what we have done unless unmapping, by unmapping the entire region.\n     * Errors here are ignored.\n     */\n    if ( ret && add_mapping != DPCI_REMOVE_MAPPING )\n        xc_domain_memory_mapping(xch, domid, first_gfn, first_mfn, nr_mfns,\n                                 DPCI_REMOVE_MAPPING);\n\n    /* We might get E2BIG so many times that we never advance. */\n    if ( !done && !ret )\n        ret = -1;\n\n    return ret;\n}""}]","{""function"": 2, ""code"": 1}","[{""source"": ""func_info(func:do_domctl)"", ""result"": [{""code"": ""static inline int do_domctl(xc_interface *xch, struct xen_domctl *domctl)\n{\n    int ret = -1;\n    DECLARE_HYPERCALL;\n    DECLARE_HYPERCALL_BOUNCE(domctl, sizeof(*domctl), XC_HYPERCALL_BUFFER_BOUNCE_BOTH);\n\n    domctl->interface_version = XEN_DOMCTL_INTERFACE_VERSION;\n\n    if ( xc_hypercall_bounce_pre(xch, domctl) )\n    {\n        PERROR(\""Could not bounce buffer for domctl hypercall\"");\n        goto out1;\n    }\n\n    hypercall.op     = __HYPERVISOR_domctl;\n    hypercall.arg[0] = HYPERCALL_BUFFER_AS_ARG(domctl);\n\n    if ( (ret = do_xen_hypercall(xch, &hypercall)) < 0 )\n    {\n        if ( errno == EACCES )\n            DPRINTF(\""domctl operation failed -- need to\""\n                    \"" rebuild the user-space tool set?\\n\"");\n    }\n\n    xc_hypercall_bounce_post(xch, domctl);\n out1:\n    return ret;\n}"", ""start_line"": 258, ""end_line"": 285, ""full_name"": ""do_domctl"", ""file_path"": ""tools/libxc/xc_private.h""}]}, {""source"": ""code_info(file:domctl.c, lines:850-870)"", ""result"": ""        if ( d == NULL )\n            goto getdomaininfo_out;\n\n        ret = xsm_getdomaininfo(XSM_HOOK, d);\n        if ( ret )\n            goto getdomaininfo_out;\n\n        getdomaininfo(d, &op->u.getdomaininfo);\n\n        op->domain = op->u.getdomaininfo.domain;\n        copyback = 1;\n\n    getdomaininfo_out:\n        rcu_read_unlock(&domlist_read_lock);\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        struct vcpu         *v;\n""}, {""source"": ""func_info(func:map_mmio_regions)"", ""result"": [{""code"": ""int map_mmio_regions(struct domain *d,\n                     unsigned long start_gfn,\n                     unsigned long nr,\n                     unsigned long mfn)\n{\n    return apply_p2m_changes(d, INSERT,\n                             pfn_to_paddr(start_gfn),\n                             pfn_to_paddr(start_gfn + nr),\n                             pfn_to_paddr(mfn),\n                             MATTR_DEV, p2m_mmio_direct);\n}"", ""start_line"": 946, ""end_line"": 956, ""full_name"": ""map_mmio_regions"", ""file_path"": ""xen/arch/arm/p2m.c""}, {""code"": ""int map_mmio_regions(struct domain *d,\n                     unsigned long start_gfn,\n                     unsigned long nr,\n                     unsigned long mfn)\n{\n    int ret = 0;\n    unsigned long i;\n\n    if ( !paging_mode_translate(d) )\n        return 0;\n\n    for ( i = 0; !ret && i < nr; i++ )\n    {\n        ret = set_mmio_p2m_entry(d, start_gfn + i, _mfn(mfn + i),\n                                 p2m_get_hostp2m(d)->default_access);\n        if ( ret )\n        {\n            unmap_mmio_regions(d, start_gfn, i, mfn);\n            break;\n        }\n    }\n\n    return ret;\n}"", ""start_line"": 1852, ""end_line"": 1875, ""full_name"": ""map_mmio_regions<duplicate>0"", ""file_path"": ""xen/arch/x86/mm/p2m.c""}]}]","xen/common/domctl.c:859-863: Enforces a hard limit of 64 MFNs via -E2BIG to prevent long hypercall execution. tools/libxc/xc_domain.c:2016-2058: Implements batch processing loop to split requests into 64-MFN chunks, retrying with E2BIG. xen/arch/x86/mm/p2m.c:1852-1875: Original map_mmio_regions processes MFNs in a loop without preemption, leading to potential denial of service for large requests.",0.95,./github/other_context/CVE-2015-2752
10,CVE-2015-4604,CWE-20,c_cpp,"The mget function in softmagic.c in file 5.x, as used in the Fileinfo component in PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8, does not properly maintain a certain pointer relationship, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted string that is mishandled by a ""Python script text executable"" rule.",https://github.com/php/php-src/commit/f938112c495b0d26572435c0be73ac0bfe642ecd,Fix bug #68819 (Fileinfo on specific file causes spurious OOM and/or segfault),1,"[{""func_name"": ""mcopy"", ""file_path"": ""ext/fileinfo/libmagic/softmagic.c"", ""func_code"": ""private int\nmcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m)\n{\n\t/*\n\t * Note: FILE_SEARCH and FILE_REGEX do not actually copy\n\t * anything, but setup pointers into the source\n\t */\n\tif (indir == 0) {\n\t\tswitch (type) {\n\t\tcase FILE_SEARCH:\n\t\t\tms->search.s = RCAST(const char *, s) + offset;\n\t\t\tms->search.s_len = nbytes - offset;\n\t\t\tms->search.offset = offset;\n\t\t\treturn 0;\n\n\t\tcase FILE_REGEX: {\n\t\t\tconst char *b;\n\t\t\tconst char *c;\n\t\t\tconst char *last;\t/* end of search region */\n\t\t\tconst char *buf;\t/* start of search region */\n\t\t\tconst char *end;\n\t\t\tsize_t lines, linecnt, bytecnt;\n\n\t\t\tlinecnt = m->str_range;\n\t\t\tbytecnt = linecnt * 80;\n\n\t\t\tif (bytecnt == 0) {\n\t\t\t\tbytecnt = 8192;\n\t\t\t}\n\t\t\tif (bytecnt > nbytes) {\n\t\t\t\tbytecnt = nbytes;\n\t\t\t}\n\t\t\tif (s == NULL) {\n\t\t\t\tms->search.s_len = 0;\n\t\t\t\tms->search.s = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuf = RCAST(const char *, s) + offset;\n\t\t\tend = last = RCAST(const char *, s) + bytecnt;\n\t\t\t/* mget() guarantees buf <= last */\n\t\t\tfor (lines = linecnt, b = buf; lines && b < end &&\n\t\t\t     ((b = CAST(const char *,\n\t\t\t\t memchr(c = b, '\\n', CAST(size_t, (end - b)))))\n\t\t\t     || (b = CAST(const char *,\n\t\t\t\t memchr(c, '\\r', CAST(size_t, (end - c))))));\n\t\t\t     lines--, b++) {\n\t\t\t\tlast = b;\n\t\t\t\tif (b[0] == '\\r' && b[1] == '\\n')\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\tif (lines)\n\t\t\t\tlast = RCAST(const char *, s) + bytecnt;\n\n\t\t\tms->search.s = buf;\n\t\t\tms->search.s_len = last - buf;\n\t\t\tms->search.offset = offset;\n\t\t\tms->search.rm_len = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16: {\n\t\t\tconst unsigned char *src = s + offset;\n\t\t\tconst unsigned char *esrc = s + nbytes;\n\t\t\tchar *dst = p->s;\n\t\t\tchar *edst = &p->s[sizeof(p->s) - 1];\n\n\t\t\tif (type == FILE_BESTRING16)\n\t\t\t\tsrc++;\n\n\t\t\t/* check that offset is within range */\n\t\t\tif (offset >= nbytes) {\n\t\t\t\tfile_magerror(ms, \""invalid offset %u in mcopy()\"",\n\t\t\t\t    offset);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (/*EMPTY*/; src < esrc; src += 2, dst++) {\n\t\t\t\tif (dst < edst)\n\t\t\t\t\t*dst = *src;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tif (*dst == '\\0') {\n\t\t\t\t\tif (type == FILE_BESTRING16 ?\n\t\t\t\t\t    *(src - 1) != '\\0' :\n\t\t\t\t\t    *(src + 1) != '\\0')\n\t\t\t\t\t\t*dst = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*edst = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_STRING:\t/* XXX - these two should not need */\n\t\tcase FILE_PSTRING:\t/* to copy anything, but do anyway. */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset >= nbytes) {\n\t\t(void)memset(p, '\\0', sizeof(*p));\n\t\treturn 0;\n\t}\n\tif (nbytes - offset < sizeof(*p))\n\t\tnbytes = nbytes - offset;\n\telse\n\t\tnbytes = sizeof(*p);\n\n\t(void)memcpy(p, s + offset, nbytes);\n\n\t/*\n\t * the usefulness of padding with zeroes eludes me, it\n\t * might even cause problems\n\t */\n\tif (nbytes < sizeof(*p))\n\t\t(void)memset(((char *)(void *)p) + nbytes, '\\0',\n\t\t    sizeof(*p) - nbytes);\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""mcopy"", ""file_path"": ""ext/fileinfo/libmagic/softmagic.c"", ""func_code"": ""private int\nmcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m)\n{\n\t/*\n\t * Note: FILE_SEARCH and FILE_REGEX do not actually copy\n\t * anything, but setup pointers into the source\n\t */\n\tif (indir == 0) {\n\t\tswitch (type) {\n\t\tcase FILE_SEARCH:\n\t\t\tms->search.s = RCAST(const char *, s) + offset;\n\t\t\tms->search.s_len = nbytes - offset;\n\t\t\tms->search.offset = offset;\n\t\t\treturn 0;\n\n\t\tcase FILE_REGEX: {\n\t\t\tconst char *b;\n\t\t\tconst char *c;\n\t\t\tconst char *last;\t/* end of search region */\n\t\t\tconst char *buf;\t/* start of search region */\n\t\t\tconst char *end;\n\t\t\tsize_t lines, linecnt, bytecnt;\n\n\t\t\tlinecnt = m->str_range;\n\t\t\tbytecnt = linecnt * 80;\n\n\t\t\tif (bytecnt == 0) {\n\t\t\t\tbytecnt = 8192;\n\t\t\t}\n\t\t\tif (bytecnt > nbytes) {\n\t\t\t\tbytecnt = nbytes;\n\t\t\t}\n\t\t\tif (offset > bytecnt) {\n\t\t\t\toffset = bytecnt;\n\t\t\t}\n\t\t\tif (s == NULL) {\n\t\t\t\tms->search.s_len = 0;\n\t\t\t\tms->search.s = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuf = RCAST(const char *, s) + offset;\n\t\t\tend = last = RCAST(const char *, s) + bytecnt;\n\t\t\t/* mget() guarantees buf <= last */\n\t\t\tfor (lines = linecnt, b = buf; lines && b < end &&\n\t\t\t     ((b = CAST(const char *,\n\t\t\t\t memchr(c = b, '\\n', CAST(size_t, (end - b)))))\n\t\t\t     || (b = CAST(const char *,\n\t\t\t\t memchr(c, '\\r', CAST(size_t, (end - c))))));\n\t\t\t     lines--, b++) {\n\t\t\t\tlast = b;\n\t\t\t\tif (b[0] == '\\r' && b[1] == '\\n')\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\tif (lines)\n\t\t\t\tlast = RCAST(const char *, s) + bytecnt;\n\n\t\t\tms->search.s = buf;\n\t\t\tms->search.s_len = last - buf;\n\t\t\tms->search.offset = offset;\n\t\t\tms->search.rm_len = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16: {\n\t\t\tconst unsigned char *src = s + offset;\n\t\t\tconst unsigned char *esrc = s + nbytes;\n\t\t\tchar *dst = p->s;\n\t\t\tchar *edst = &p->s[sizeof(p->s) - 1];\n\n\t\t\tif (type == FILE_BESTRING16)\n\t\t\t\tsrc++;\n\n\t\t\t/* check that offset is within range */\n\t\t\tif (offset >= nbytes) {\n\t\t\t\tfile_magerror(ms, \""invalid offset %u in mcopy()\"",\n\t\t\t\t    offset);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (/*EMPTY*/; src < esrc; src += 2, dst++) {\n\t\t\t\tif (dst < edst)\n\t\t\t\t\t*dst = *src;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tif (*dst == '\\0') {\n\t\t\t\t\tif (type == FILE_BESTRING16 ?\n\t\t\t\t\t    *(src - 1) != '\\0' :\n\t\t\t\t\t    *(src + 1) != '\\0')\n\t\t\t\t\t\t*dst = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*edst = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_STRING:\t/* XXX - these two should not need */\n\t\tcase FILE_PSTRING:\t/* to copy anything, but do anyway. */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset >= nbytes) {\n\t\t(void)memset(p, '\\0', sizeof(*p));\n\t\treturn 0;\n\t}\n\tif (nbytes - offset < sizeof(*p))\n\t\tnbytes = nbytes - offset;\n\telse\n\t\tnbytes = sizeof(*p);\n\n\t(void)memcpy(p, s + offset, nbytes);\n\n\t/*\n\t * the usefulness of padding with zeroes eludes me, it\n\t * might even cause problems\n\t */\n\tif (nbytes < sizeof(*p))\n\t\t(void)memset(((char *)(void *)p) + nbytes, '\\0',\n\t\t    sizeof(*p) - nbytes);\n\treturn 0;\n}""}]","{""function"": 1, ""code"": 1, ""caller"": 1, ""value"": 2}","[{""source"": ""func_info(file:softmagic.c, func:mget)"", ""result"": [{""code"": ""private int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tint rv, oneed_separator;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \""recursion nesting exceeded\"");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \""mget(type=%d, flag=%x, offset=%u, o=%zu, \""\n\t\t    \""nbytes=%zu)\\n\"", m->type, m->flag, offset, o, nbytes);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((..."", ""start_line"": 1126, ""end_line"": 1772, ""full_name"": ""mget"", ""file_path"": ""ext/fileinfo/libmagic/softmagic.c""}]}, {""source"": ""code_info(file:softmagic.c, lines:0-200)"", ""result"": ""/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * softmagic - interpret variable magic from MAGIC\n */\n\n#include \""file.h\""\n\n#ifndef\tlint\nFILE_RCSID(\""@(#)$File: softmagic.c,v 1.165 2013/03/07 02:22:24 christos Exp $\"")\n#endif\t/* lint */\n\n#include \""magic.h\""\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <time.h>\n\n#ifndef PREG_OFFSET_CAPTURE\n# define PREG_OFFSET_CAPTURE                 (1<<8)\n#endif\n\n\n\nprivate int match(struct magic_set *, struct magic *, uint32_t,\n    const unsigned char *, size_t, size_t, int, int, int, int, int *, int *,\n    int *);\nprivate int mget(struct magic_set *, const unsigned char *,\n    struct magic *, size_t, size_t, unsigned int, int, int, int, int, int *,\n    int *, int *);\nprivate int magiccheck(struct magic_set *, struct magic *);\nprivate int32_t mprint(struct magic_set *, struct magic *);\nprivate int32_t moffset(struct magic_set *, struct magic *);\nprivate void mdebug(uint32_t, const char *, size_t);\nprivate int mcopy(struct magic_set *, union VALUETYPE *, int, int,\n    const unsigned char *, uint32_t, size_t, struct magic *);\nprivate int mconvert(struct magic_set *, struct magic *, int);\nprivate int print_sep(struct magic_set *, int);\nprivate int handle_annotation(struct magic_set *, struct magic *);\nprivate void cvt_8(union VALUETYPE *, const struct magic *);\nprivate void cvt_16(union VALUETYPE *, const struct magic *);\nprivate void cvt_32(union VALUETYPE *, const struct magic *);\nprivate void cvt_64(union VALUETYPE *, const struct magic *);\n\n#define OFFSET_OOB(n, o, i)\t((n) < (o) || (i) > ((n) - (o)))\n\n/*\n * softmagic - lookup one file in parsed, in-memory copy of database\n * Passed the name and FILE * of one file to be typed.\n */\n/*ARGSUSED1*/\t\t/* nbytes passed for regularity, maybe need later */\nprotected int\nfile_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes,\n    size_t level, int mode, int text)\n{\n\tstruct mlist *ml;\n\tint rv, printed_something = 0, need_separator = 0;\n\tfor (ml = ms->mlist[0]->next; ml != ms->mlist[0]; ml = ml->next)\n\t\tif ((rv = match(ms, ml->magic, ml->nmagic, buf, nbytes, 0, mode,\n\t\t    text, 0, level, &printed_something, &need_separator,\n\t\t    NULL)) != 0)\n\t\t\treturn rv;\n\n\treturn 0;\n}\n\n/*\n * Go through the whole list, stopping if you find a match.  Process all\n * the continuations of that match before returning.\n *\n * We support multi-level continuations:\n *\n *\tAt any time when processing a successful top-level match, there is a\n *\tcurrent continuation level; it represents the level of the last\n *\tsuccessfully matched continuation.\n *\n *\tContinuations above that level are skipped as, if we see one, it\n *\tmeans that the continuation that controls them - i.e, the\n *\tlower-level continuation preceding them - failed to match.\n *\n *\tContinuations below that level are processed as, if we see one,\n *\tit means we've finished processing or skipping higher-level\n *\tcontinuations under the control of a successful or unsuccessful\n *\tlower-level continuation, and are now seeing the next lower-level\n *\tcontinuation and should process it.  The current continuation\n *\tlevel reverts to the level of the one we're seeing.\n *\n *\tContinuations at the current level are processed as, if we see\n *\tone, there's no lower-level continuation that may have failed.\n *\n *\tIf a continuation matches, we bump the current continuation level\n *\tso that higher-level continuations are processed.\n */\nprivate int\nmatch(struct magic_set *ms, struct magic *magic, uint32_t nmagic,\n    const unsigned char *s, size_t nbytes, size_t offset, int mode, int text,\n    int flip, int recursion_level, int *printed_something, int *need_separator,\n    int *returnval)\n{\n\tuint32_t magindex = 0;\n\tunsigned int cont_level = 0;\n\tint returnvalv = 0, e; /* if a match is found it is set to 1*/\n\tint firstline = 1; /* a flag to print X\\n  X\\n- X */\n\tint print = (ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0;\n\n\tif (returnval == NULL)\n\t\treturnval = &returnvalv;\n\n\tif (file_check_mem(ms, cont_level) == -1)\n\t\treturn -1;\n\n\tfor (magindex = 0; magindex < nmagic; magindex++) {\n\t\tint flush = 0;\n\t\tstruct magic *m = &magic[magindex];\n\n\t\tif (m->type != FILE_NAME)\n\t\tif ((IS_LIBMAGIC_STRING(m->type) &&\n#define FLT (STRING_BINTEST | STRING_TEXTTEST)\n\t\t     ((text && (m->str_flags & FLT) == STRING_BINTEST) ||\n\t\t      (!text && (m->str_flags & FLT) == STRING_TEXTTEST))) ||\n\t\t    (m->flag & mode) != mode) {\n\t\t\t/* Skip sub-tests */\n\t\t\twhile (magindex + 1 < nmagic &&\n                               magic[magindex + 1].cont_level != 0 &&\n\t\t\t       ++magindex)\n\t\t\t\tcontinue;\n\t\t\tcontinue; /* Skip to next top-level test*/\n\t\t}\n\n\t\tms->offset = m->offset;\n\t\tms->line = m->lineno;\n\n\t\t/* if main entry matches, print it... */\n\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode, text,\n\t\t    flip, recursion_level + 1, printed_something,\n\t\t    need_separator, returnval)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tflush = m->reln != '!';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t*returnval = 1;\n\n\t\t\tswitch (magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tflush++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (flush) {\n\t\t\t/*\n\t\t\t * main entry didn't match,\n\t\t\t * flush its continuations\n\t\t\t */\n\t\t\twhile (magindex < nmagic - 1 &&\n\t\t\t    magic[magindex + 1].cont_level != 0)\n\t\t\t\tmagindex++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t*returnval = 1;\n\t\t\treturn e;\n\t\t}\n\t\t/*\n\t\t * If we are going to print something, we'll need to print\n\t\t * a blank before we print something else.\n\t\t */\n""}, {""source"": ""caller_info(file:softmagic.c, func:mcopy)"", ""result"": [{""call_line"": 1143, ""call_code"": ""mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m)"", ""caller_code"": ""private int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tint rv, oneed_separator;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \""recursion nesting exceeded\"");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \""mget(type=%d, flag=%x, offset=%u, o=%zu, \""\n\t\t    \""nbytes=%zu)\\n\"", m->type, m->flag, offset, o, nbytes);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((..."", ""caller_start"": 1126, ""file_path"": ""ext/fileinfo/libmagic/softmagic.c""}, {""call_line"": 1640, ""call_code"": ""mcopy(ms, p, m->type, 0, s, offset, nbytes, m)"", ""caller_code"": ""private int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tint rv, oneed_separator;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \""recursion nesting exceeded\"");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \""mget(type=%d, flag=%x, offset=%u, o=%zu, \""\n\t\t    \""nbytes=%zu)\\n\"", m->type, m->flag, offset, o, nbytes);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((..."", ""caller_start"": 1126, ""file_path"": ""ext/fileinfo/libmagic/softmagic.c""}]}, {""source"": ""value_info(file:softmagic.c, value:offset)"", ""result"": {""value_trace"": [{""full_code"": ""offset = ms->offset"", ""line"": 1132, ""func_name"": ""mget""}, {""full_code"": ""offset = p->b & off"", ""line"": 1199, ""func_name"": ""mget""}, {""full_code"": ""offset = p->b | off"", ""line"": 1202, ""func_name"": ""mget""}, {""full_code"": ""offset = p->b ^ off"", ""line"": 1205, ""func_name"": ""mget""}, {""full_code"": ""offset = p->b + off"", ""line"": 1208, ""func_name"": ""mget""}], ""struct_var"": ""offset"", ""struct_type"": ""uint32_t"", ""struct_definition"": ""typedef unsigned int uint32_t;\n\ntypedef unsigned long int uint32_t;\n\ntypedef unsigned int uint32_t;\n\ntypedef unsigned long int uint32_t;\n\ntypedef unsigned int uint32_t;\n\ntypedef unsigned long int uint32_t;""}}, {""source"": ""value_info(file:softmagic.c, value:bytecnt)"", ""result"": {""value_trace"": [{""full_code"": ""bytecnt = linecnt * 80"", ""line"": 1032, ""func_name"": ""mcopy""}, {""full_code"": ""bytecnt = 8192"", ""line"": 1035, ""func_name"": ""mcopy""}, {""full_code"": ""bytecnt = nbytes"", ""line"": 1038, ""func_name"": ""mcopy""}], ""struct_var"": ""bytecnt"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}]","The root cause is an unbounded 'offset' passed to mcopy (ext/fileinfo/libmagic/softmagic.c:1143, 1640) from mget. mget computes 'offset' as ms->offset + o (softmagic.c:1132, 1143) and passes it to mcopy. Prior to the patch, mcopy (softmagic.c:1037) did not clamp 'offset' to 'bytecnt', allowing out-of-bounds access when offset > bytecnt. This led to memory corruption, triggering DoS or arbitrary code execution via crafted input.",0.95,./github/other_context/CVE-2015-4604
11,CVE-2015-8932,CWE-20,c_cpp,"The compress_bidder_init function in archive_read_support_filter_compress.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (crash) via a crafted tar file, which triggers an invalid left shift.",https://github.com/libarchive/libarchive/commit/f0b1dbbc325a2d922015eee402b72edd422cb9ea,Issue 547:  problems with compress bidder\n\nThe code previously was not very careful about verifying the\ncompression parameters.  This led to cases where it failed to\nreject invalid compressed data at the beginning.  The invalid\nleft shift was one symptom of this.\n\nThe code is now more careful:  It verifies that the compression\nparameter byte exists and verifies that the maximum code size\nis <= 16 bits.\n\nThis also includes some new tests to verify that truncated or\notherwise invalid compressed data is rejected.,2,"[{""func_name"": ""compress_bidder_init"", ""file_path"": ""libarchive/archive_read_support_filter_compress.c"", ""func_code"": ""static int\ncompress_bidder_init(struct archive_read_filter *self)\n{\n\tstruct private_data *state;\n\tstatic const size_t out_block_size = 64 * 1024;\n\tvoid *out_block;\n\tint code;\n\n\tself->code = ARCHIVE_FILTER_COMPRESS;\n\tself->name = \""compress (.Z)\"";\n\n\tstate = (struct private_data *)calloc(sizeof(*state), 1);\n\tout_block = malloc(out_block_size);\n\tif (state == NULL || out_block == NULL) {\n\t\tfree(out_block);\n\t\tfree(state);\n\t\tarchive_set_error(&self->archive->archive, ENOMEM,\n\t\t    \""Can't allocate data for %s decompression\"",\n\t\t    self->name);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tself->data = state;\n\tstate->out_block_size = out_block_size;\n\tstate->out_block = out_block;\n\tself->read = compress_filter_read;\n\tself->skip = NULL; /* not supported */\n\tself->close = compress_filter_close;\n\n\t/* XXX MOVE THE FOLLOWING OUT OF INIT() XXX */\n\n\t(void)getbits(self, 8); /* Skip first signature byte. */\n\t(void)getbits(self, 8); /* Skip second signature byte. */\n\n\tcode = getbits(self, 8);\n\tstate->maxcode_bits = code & 0x1f;\n\tstate->maxcode = (1 << state->maxcode_bits);\n\tstate->use_reset_code = code & 0x80;\n\n\t/* Initialize decompressor. */\n\tstate->free_ent = 256;\n\tstate->stackp = state->stack;\n\tif (state->use_reset_code)\n\t\tstate->free_ent++;\n\tstate->bits = 9;\n\tstate->section_end_code = (1<<state->bits) - 1;\n\tstate->oldcode = -1;\n\tfor (code = 255; code >= 0; code--) {\n\t\tstate->prefix[code] = 0;\n\t\tstate->suffix[code] = code;\n\t}\n\tnext_code(self);\n\n\treturn (ARCHIVE_OK);\n}"", ""target"": 0}, {""func_name"": ""compress_bidder_bid"", ""file_path"": ""libarchive/archive_read_support_filter_compress.c"", ""func_code"": ""static int\ncompress_bidder_bid(struct archive_read_filter_bidder *self,\n    struct archive_read_filter *filter)\n{\n\tconst unsigned char *buffer;\n\tssize_t avail;\n\tint bits_checked;\n\n\t(void)self; /* UNUSED */\n\n\tbuffer = __archive_read_filter_ahead(filter, 2, &avail);\n\n\tif (buffer == NULL)\n\t\treturn (0);\n\n\tbits_checked = 0;\n\tif (buffer[0] != 0x1F || buffer[1] != 0x9D)\n\t\treturn (0);\n\tbits_checked += 16;\n\n\t/*\n\t * TODO: Verify more.\n\t */\n\n\treturn (bits_checked);\n}"", ""target"": 0}]","[{""func_name"": ""compress_bidder_init"", ""file_path"": ""libarchive/archive_read_support_filter_compress.c"", ""func_code"": ""static int\ncompress_bidder_init(struct archive_read_filter *self)\n{\n\tstruct private_data *state;\n\tstatic const size_t out_block_size = 64 * 1024;\n\tvoid *out_block;\n\tint code;\n\n\tself->code = ARCHIVE_FILTER_COMPRESS;\n\tself->name = \""compress (.Z)\"";\n\n\tstate = (struct private_data *)calloc(sizeof(*state), 1);\n\tout_block = malloc(out_block_size);\n\tif (state == NULL || out_block == NULL) {\n\t\tfree(out_block);\n\t\tfree(state);\n\t\tarchive_set_error(&self->archive->archive, ENOMEM,\n\t\t    \""Can't allocate data for %s decompression\"",\n\t\t    self->name);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tself->data = state;\n\tstate->out_block_size = out_block_size;\n\tstate->out_block = out_block;\n\tself->read = compress_filter_read;\n\tself->skip = NULL; /* not supported */\n\tself->close = compress_filter_close;\n\n\t/* XXX MOVE THE FOLLOWING OUT OF INIT() XXX */\n\n\t(void)getbits(self, 8); /* Skip first signature byte. */\n\t(void)getbits(self, 8); /* Skip second signature byte. */\n\n\t/* Get compression parameters. */\n\tcode = getbits(self, 8);\n\tif ((code & 0x1f) > 16) {\n\t\tarchive_set_error(&self->archive->archive, -1,\n\t\t    \""Invalid compressed data\"");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tstate->maxcode_bits = code & 0x1f;\n\tstate->maxcode = (1 << state->maxcode_bits);\n\tstate->use_reset_code = code & 0x80;\n\n\t/* Initialize decompressor. */\n\tstate->free_ent = 256;\n\tstate->stackp = state->stack;\n\tif (state->use_reset_code)\n\t\tstate->free_ent++;\n\tstate->bits = 9;\n\tstate->section_end_code = (1<<state->bits) - 1;\n\tstate->oldcode = -1;\n\tfor (code = 255; code >= 0; code--) {\n\t\tstate->prefix[code] = 0;\n\t\tstate->suffix[code] = code;\n\t}\n\tnext_code(self);\n\n\treturn (ARCHIVE_OK);\n}""}, {""func_name"": ""compress_bidder_bid"", ""file_path"": ""libarchive/archive_read_support_filter_compress.c"", ""func_code"": ""static int\ncompress_bidder_bid(struct archive_read_filter_bidder *self,\n    struct archive_read_filter *filter)\n{\n\tconst unsigned char *buffer;\n\tssize_t avail;\n\tint bits_checked;\n\n\t(void)self; /* UNUSED */\n\n\t/* Shortest valid compress file is 3 bytes. */\n\tbuffer = __archive_read_filter_ahead(filter, 3, &avail);\n\n\tif (buffer == NULL)\n\t\treturn (0);\n\n\tbits_checked = 0;\n\t/* First two bytes are the magic value */\n\tif (buffer[0] != 0x1F || buffer[1] != 0x9D)\n\t\treturn (0);\n\t/* Third byte holds compression parameters. */\n\tif (buffer[2] & 0x20) /* Reserved bit, must be zero. */\n\t\treturn (0);\n\tif (buffer[2] & 0x40) /* Reserved bit, must be zero. */\n\t\treturn (0);\n\tbits_checked += 18;\n\n\treturn (bits_checked);\n}""}]",{},[],"Unvalidated `maxcode_bits` (libarchive/archive_read_support_filter_compress.c:247) derived from `code = getbits(...)` (libarchive/archive_read_support_filter_compress.c:240) could exceed 16 bits, causing undefined behavior in `(1 << state->maxcode_bits)`. The patch adds bounds checking (libarchive/archive_read_support_filter_compress.c:242-246) and ensures the parameter byte exists (libarchive/archive_read_support_filter_compress.c:186-188).",0.95,./github/other_context/CVE-2015-8932
12,CVE-2016-10712,CWE-20,c_cpp,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,11,"[{""func_name"": ""_php_stream_memory_create"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""PHPAPI php_stream *_php_stream_memory_create(int mode STREAMS_DC TSRMLS_DC)\n{\n\tphp_stream_memory_data *self;\n\tphp_stream *stream;\n\n\tself = emalloc(sizeof(*self));\n\tself->data = NULL;\n\tself->fpos = 0;\n\tself->fsize = 0;\n\tself->smax = ~0u;\n\tself->mode = mode;\n\t\n\tstream = php_stream_alloc_rel(&php_stream_memory_ops, self, 0, mode & TEMP_STREAM_READONLY ? \""rb\"" : \""w+b\"");\n\tstream->flags |= PHP_STREAM_FLAG_NO_BUFFER;\n\treturn stream;\n}"", ""target"": 0}, {""func_name"": ""php_stream_temp_cast"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_temp_cast(php_stream *stream, int castas, void **ret TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tphp_stream *file;\n\tsize_t memsize;\n\tchar *membuf;\n\toff_t pos;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\treturn FAILURE;\n\t}\n\tif (php_stream_is(ts->innerstream, PHP_STREAM_IS_STDIO)) {\n\t\treturn php_stream_cast(ts->innerstream, castas, ret, 0);\n\t}\n\n\t/* we are still using a memory based backing. If they are if we can be\n\t * a FILE*, say yes because we can perform the conversion.\n\t * If they actually want to perform the conversion, we need to switch\n\t * the memory stream to a tmpfile stream */\n\n\tif (ret == NULL && castas == PHP_STREAM_AS_STDIO) {\n\t\treturn SUCCESS;\n\t}\n\n\t/* say \""no\"" to other stream forms */\n\tif (ret == NULL) {\n\t\treturn FAILURE;\n\t}\n\n\t/* perform the conversion and then pass the request on to the innerstream */\n\tmembuf = php_stream_memory_get_buffer(ts->innerstream, &memsize);\n\tfile = php_stream_fopen_tmpfile();\n\tphp_stream_write(file, membuf, memsize);\n\tpos = php_stream_tell(ts->innerstream);\n\t\n\tphp_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE);\n\tts->innerstream = file;\n\tphp_stream_encloses(stream, ts->innerstream);\n\tphp_stream_seek(ts->innerstream, pos, SEEK_SET);\n\n\treturn php_stream_cast(ts->innerstream, castas, ret, 1);\n}"", ""target"": 0}, {""func_name"": ""php_stream_memory_set_option"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_memory_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_memory_data *ms = (php_stream_memory_data*)stream->abstract;\n\tsize_t newsize;\n\t\n\tswitch(option) {\n\t\tcase PHP_STREAM_OPTION_TRUNCATE_API:\n\t\t\tswitch (value) {\n\t\t\t\tcase PHP_STREAM_TRUNCATE_SUPPORTED:\n\t\t\t\t\treturn PHP_STREAM_OPTION_RETURN_OK;\n\n\t\t\t\tcase PHP_STREAM_TRUNCATE_SET_SIZE:\n\t\t\t\t\tif (ms->mode & TEMP_STREAM_READONLY) {\n\t\t\t\t\t\treturn PHP_STREAM_OPTION_RETURN_ERR;\n\t\t\t\t\t}\n\t\t\t\t\tnewsize = *(size_t*)ptrparam;\n\t\t\t\t\tif (newsize <= ms->fsize) {\n\t\t\t\t\t\tif (newsize < ms->fpos) {\n\t\t\t\t\t\t\tms->fpos = newsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tms->data = erealloc(ms->data, newsize);\n\t\t\t\t\t\tmemset(ms->data+ms->fsize, 0, newsize - ms->fsize);\n\t\t\t\t\t\tms->fsize = newsize;\n\t\t\t\t\t}\n\t\t\t\t\tms->fsize = newsize;\n\t\t\t\t\treturn PHP_STREAM_OPTION_RETURN_OK;\n\t\t\t}\n\t\tdefault:\n\t\t\treturn PHP_STREAM_OPTION_RETURN_NOTIMPL;\n\t}\n}"", ""target"": 0}, {""func_name"": ""_php_stream_memory_open"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""PHPAPI php_stream *_php_stream_memory_open(int mode, char *buf, size_t length STREAMS_DC TSRMLS_DC)\n{\n\tphp_stream *stream;\n\tphp_stream_memory_data *ms;\n\n\tif ((stream = php_stream_memory_create_rel(mode)) != NULL) {\n\t\tms = (php_stream_memory_data*)stream->abstract;\n\t\t\n\t\tif (mode == TEMP_STREAM_READONLY || mode == TEMP_STREAM_TAKE_BUFFER) {\n\t\t\t/* use the buffer directly */\n\t\t\tms->data = buf;\n\t\t\tms->fsize = length;\n\t\t} else {\n\t\t\tif (length) {\n\t\t\t\tassert(buf != NULL);\n\t\t\t\tphp_stream_write(stream, buf, length);\n\t\t\t}\n\t\t}\n\t}\n\treturn stream;\n}"", ""target"": 0}, {""func_name"": ""php_stream_url_wrap_rfc2397"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static php_stream * php_stream_url_wrap_rfc2397(php_stream_wrapper *wrapper, char *path, char *mode, int options, char **opened_path, php_stream_context *context STREAMS_DC TSRMLS_DC) /* {{{ */\n{\n\tphp_stream *stream;\n\tphp_stream_temp_data *ts;\n\tchar *comma, *semi, *sep, *key;\n\tsize_t mlen, dlen, plen, vlen;\n\toff_t newoffs;\n\tzval *meta = NULL;\n\tint base64 = 0, ilen;\n\n\tif (memcmp(path, \""data:\"", 5)) {\n\t\treturn NULL;\n\t}\n\n\tpath += 5;\n\tdlen = strlen(path);\n\n\tif (dlen >= 2 && path[0] == '/' && path[1] == '/') {\n\t\tdlen -= 2;\n\t\tpath += 2;\n\t}\n\n\tif ((comma = memchr(path, ',', dlen)) == NULL) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: no comma in URL\"");\n\t\treturn NULL;\n\t}\n\n\tif (comma != path) {\n\t\t/* meta info */\n\t\tmlen = comma - path;\n\t\tdlen -= mlen;\n\t\tsemi = memchr(path, ';', mlen);\n\t\tsep = memchr(path, '/', mlen);\n\t\t\n\t\tif (!semi && !sep) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: illegal media type\"");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tMAKE_STD_ZVAL(meta);\n\t\tarray_init(meta);\n\t\tif (!semi) { /* there is only a mime type */\n\t\t\tadd_assoc_stringl(meta, \""mediatype\"", path, mlen, 1);\n\t\t\tmlen = 0;\n\t\t} else if (sep && sep < semi) { /* there is a mime type */\n\t\t\tplen = semi - path;\n\t\t\tadd_assoc_stringl(meta, \""mediatype\"", path, plen, 1);\n\t\t\tmlen -= plen;\n\t\t\tpath += plen;\n\t\t} else if (semi != path || mlen != sizeof(\"";base64\"")-1 || memcmp(path, \"";base64\"", sizeof(\"";base64\"")-1)) { /* must be error since parameters are only allowed after mediatype */\n\t\t\tzval_ptr_dtor(&meta);\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: illegal media type\"");\n\t\t\treturn NULL;\n\t\t}\n\t\t/* get parameters and potentially ';base64' */\n\t\twhile(semi && (semi == path)) {\n\t\t\tpath++;\n\t\t\tmlen--;\n\t\t\tsep = memchr(path, '=', mlen);\n\t\t\tsemi = memchr(path, ';', mlen);\n\t\t\tif (!sep || (semi && semi < sep)) { /* must be ';base64' or failure */\n\t\t\t\tif (mlen != sizeof(\""base64\"")-1 || memcmp(path, \""base64\"", sizeof(\""base64\"")-1)) {\n\t\t\t\t\t/* must be error since parameters are only allowed after mediatype and we have no '=' sign */\n\t\t\t\t\tzval_ptr_dtor(&meta);\n\t\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: illegal parameter\"");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tbase64 = 1;\n\t\t\t\tmlen -= sizeof(\""base64\"") - 1;\n\t\t\t\tpath += sizeof(\""base64\"") - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* found parameter ... the heart of cs ppl lies in +1/-1 or was it +2 this time? */\n\t\t\tplen = sep - path;\n\t\t\tvlen = (semi ? semi - sep : mlen - plen) - 1 /* '=' */;\n\t\t\tkey = estrndup(path, plen);\n\t\t\tadd_assoc_stringl_ex(meta, key, plen + 1, sep + 1, vlen, 1);\n\t\t\tefree(key);\n\t\t\tplen += vlen + 1;\n\t\t\tmlen -= plen;\n\t\t\tpath += plen;\n\t\t}\n\t\tif (mlen) {\n\t\t\tzval_ptr_dtor(&meta);\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: illegal URL\"");\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tMAKE_STD_ZVAL(meta);\n\t\tarray_init(meta);\n\t}\n\tadd_assoc_bool(meta, \""base64\"", base64);\n\n\t/* skip ',' */\n\tcomma++;\n\tdlen--;\n\n\tif (base64) {\n\t\tcomma = (char*)php_base64_decode((const unsigned char *)comma, dlen, &ilen);\n\t\tif (!comma) {\n\t\t\tzval_ptr_dtor(&meta);\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: unable to decode\"");\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tcomma = estrndup(comma, dlen);\n\t\tilen = dlen = php_url_decode(comma, dlen);\n\t}\n\n\tif ((stream = php_stream_temp_create_rel(0, ~0u)) != NULL) {\n\t\t/* store data */\n\t\tphp_stream_temp_write(stream, comma, ilen TSRMLS_CC);\n\t\tphp_stream_temp_seek(stream, 0, SEEK_SET, &newoffs TSRMLS_CC);\n\t\t/* set special stream stuff (enforce exact mode) */\n\t\tvlen = strlen(mode);\n\t\tif (vlen >= sizeof(stream->mode)) {\n\t\t\tvlen = sizeof(stream->mode) - 1;\n\t\t}\n\t\tmemcpy(stream->mode, mode, vlen);\n\t\tstream->mode[vlen] = '\\0';\n\t\tstream->ops = &php_stream_rfc2397_ops;\n\t\tts = (php_stream_temp_data*)stream->abstract;\n\t\tassert(ts != NULL);\n\t\tts->mode = mode && mode[0] == 'r' && mode[1] != '+' ? TEMP_STREAM_READONLY : 0;\n\t\tts->meta = meta;\n\t}\n\tefree(comma);\n\n\treturn stream;\n}"", ""target"": 0}, {""func_name"": ""php_stream_memory_stat"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_memory_stat(php_stream *stream, php_stream_statbuf *ssb TSRMLS_DC) /* {{{ */\n{\n\ttime_t timestamp = 0;\n\tphp_stream_memory_data *ms = (php_stream_memory_data*)stream->abstract;\n\tassert(ms != NULL);\n\n\tmemset(ssb, 0, sizeof(php_stream_statbuf));\n\t/* read-only across the board */\n\t\n\tssb->sb.st_mode = ms->mode & TEMP_STREAM_READONLY ? 0444 : 0666;\n\n\tssb->sb.st_size = ms->fsize;\n\tssb->sb.st_mode |= S_IFREG; /* regular file */\n\n#ifdef NETWARE\n\tssb->sb.st_mtime.tv_sec = timestamp;\n\tssb->sb.st_atime.tv_sec = timestamp;\n\tssb->sb.st_ctime.tv_sec = timestamp;\n#else\n\tssb->sb.st_mtime = timestamp;\n\tssb->sb.st_atime = timestamp;\n\tssb->sb.st_ctime = timestamp;\n#endif\n\n\tssb->sb.st_nlink = 1;\n\tssb->sb.st_rdev = -1;\n\t/* this is only for APC, so use /dev/null device - no chance of conflict there! */\n\tssb->sb.st_dev = 0xC;\n\t/* generate unique inode number for alias/filename, so no phars will conflict */\n\tssb->sb.st_ino = 0;\n\n#ifndef PHP_WIN32\n\tssb->sb.st_blksize = -1;\n#endif\n\n#if !defined(PHP_WIN32) && !defined(__BEOS__)\n\tssb->sb.st_blocks = -1;\n#endif\n\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""php_stream_temp_seek"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tint ret;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\t*newoffs = -1;\n\t\treturn -1;\n\t}\n\tret = php_stream_seek(ts->innerstream, offset, whence);\n\t*newoffs = php_stream_tell(ts->innerstream);\n\tstream->eof = ts->innerstream->eof;\n\t\n\treturn ret;\n}"", ""target"": 0}, {""func_name"": ""php_stream_temp_set_option"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_temp_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\t\n\tswitch(option) {\n\t\tcase PHP_STREAM_OPTION_META_DATA_API:\n\t\t\tif (ts->meta) {\n\t\t\t\tzend_hash_copy(Z_ARRVAL_P((zval*)ptrparam), Z_ARRVAL_P(ts->meta), (copy_ctor_func_t) zval_add_ref, NULL, sizeof(zval*));\n\t\t\t}\n\t\t\treturn PHP_STREAM_OPTION_RETURN_OK;\n\t\tdefault:\n\t\t\tif (ts->innerstream) {\n\t\t\t\treturn php_stream_set_option(ts->innerstream, option, value, ptrparam);\n\t\t\t}\n\t\t\treturn PHP_STREAM_OPTION_RETURN_NOTIMPL;\n\t}\n}"", ""target"": 0}, {""func_name"": ""php_stream_temp_read"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static size_t php_stream_temp_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tsize_t got;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\treturn -1;\n\t}\n\t\n\tgot = php_stream_read(ts->innerstream, buf, count);\n\t\n\tstream->eof = ts->innerstream->eof;\n\t\n\treturn got;\n}"", ""target"": 1}, {""func_name"": ""php_stream_temp_close"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_temp_close(php_stream *stream, int close_handle TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tint ret;\n\n\tassert(ts != NULL);\n\n\tif (ts->innerstream) {\n\t\tret = php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE | (close_handle ? 0 : PHP_STREAM_FREE_PRESERVE_HANDLE));\n\t} else {\n\t\tret = 0;\n\t}\n\t\n\tif (ts->meta) {\n\t\tzval_ptr_dtor(&ts->meta);\n\t}\n\n\tefree(ts);\n\n\treturn ret;\n}"", ""target"": 0}, {""func_name"": ""stream_array_from_fd_set"", ""file_path"": ""ext/standard/streamsfuncs.c"", ""func_code"": ""static int stream_array_from_fd_set(zval *stream_array, fd_set *fds TSRMLS_DC)\n{\n\tzval **elem, **dest_elem;\n\tphp_stream *stream;\n\tHashTable *new_hash;\n\tint ret = 0;\n\n\tif (Z_TYPE_P(stream_array) != IS_ARRAY) {\n\t\treturn 0;\n\t}\n\tALLOC_HASHTABLE(new_hash);\n\tzend_hash_init(new_hash, zend_hash_num_elements(Z_ARRVAL_P(stream_array)), NULL, ZVAL_PTR_DTOR, 0);\n\n\tfor (zend_hash_internal_pointer_reset(Z_ARRVAL_P(stream_array));\n\t\t zend_hash_has_more_elements(Z_ARRVAL_P(stream_array)) == SUCCESS;\n\t\t zend_hash_move_forward(Z_ARRVAL_P(stream_array))) {\n\n\t\tint type;\n\t\tchar *key;\n\t\tuint key_len;\n\t\tulong num_ind;\n\t\t/* Temporary int fd is needed for the STREAM data type on windows, passing this_fd directly to php_stream_cast()\n\t\t\twould eventually bring a wrong result on x64. php_stream_cast() casts to int internally, and this will leave\n\t\t\tthe higher bits of a SOCKET variable uninitialized on systems with little endian. */\n\t\tint tmp_fd;\n\n\n\t\ttype = zend_hash_get_current_key_ex(Z_ARRVAL_P(stream_array),\n\t\t\t\t&key, &key_len, &num_ind, 0, NULL);\n\t\tif (type == HASH_KEY_NON_EXISTENT ||\n\t\t\tzend_hash_get_current_data(Z_ARRVAL_P(stream_array), (void **) &elem) == FAILURE) {\n\t\t\tcontinue; /* should not happen */\n\t\t}\n\n\t\tphp_stream_from_zval_no_verify(stream, elem);\n\t\tif (stream == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* get the fd\n\t\t * NB: Most other code will NOT use the PHP_STREAM_CAST_INTERNAL flag\n\t\t * when casting.  It is only used here so that the buffered data warning\n\t\t * is not displayed.\n\t\t */\n\t\tif (SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL, (void*)&tmp_fd, 1) && tmp_fd != -1) {\n\n\t\t\tphp_socket_t this_fd = (php_socket_t)tmp_fd;\n\n\t\t\tif (PHP_SAFE_FD_ISSET(this_fd, fds)) {\n\t\t\t\tif (type == HASH_KEY_IS_LONG) {\n\t\t\t\t\tzend_hash_index_update(new_hash, num_ind, (void *)elem, sizeof(zval *), (void **)&dest_elem);\n\t\t\t\t} else { /* HASH_KEY_IS_STRING */\n\t\t\t\t\tzend_hash_update(new_hash, key, key_len, (void *)elem, sizeof(zval *), (void **)&dest_elem);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (dest_elem) {\n\t\t\t\t\tzval_add_ref(dest_elem);\n\t\t\t\t}\n\t\t\t\tret++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* destroy old array and add new one */\n\tzend_hash_destroy(Z_ARRVAL_P(stream_array));\n\tefree(Z_ARRVAL_P(stream_array));\n\n\tzend_hash_internal_pointer_reset(new_hash);\n\tZ_ARRVAL_P(stream_array) = new_hash;\n\n\treturn ret;\n}"", ""target"": 0}]","[{""func_name"": ""_php_stream_memory_create"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""PHPAPI php_stream *_php_stream_memory_create(int mode STREAMS_DC TSRMLS_DC)\n{\n\tphp_stream_memory_data *self;\n\tphp_stream *stream;\n\n\tself = emalloc(sizeof(*self));\n\tself->data = NULL;\n\tself->fpos = 0;\n\tself->fsize = 0;\n\tself->smax = ~0u;\n\tself->mode = mode;\n\n\tstream = php_stream_alloc_rel(&php_stream_memory_ops, self, 0, mode & TEMP_STREAM_READONLY ? \""rb\"" : \""w+b\"");\n\tstream->flags |= PHP_STREAM_FLAG_NO_BUFFER;\n\treturn stream;\n}""}, {""func_name"": ""php_stream_temp_cast"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_temp_cast(php_stream *stream, int castas, void **ret TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tphp_stream *file;\n\tsize_t memsize;\n\tchar *membuf;\n\toff_t pos;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\treturn FAILURE;\n\t}\n\tif (php_stream_is(ts->innerstream, PHP_STREAM_IS_STDIO)) {\n\t\treturn php_stream_cast(ts->innerstream, castas, ret, 0);\n\t}\n\n\t/* we are still using a memory based backing. If they are if we can be\n\t * a FILE*, say yes because we can perform the conversion.\n\t * If they actually want to perform the conversion, we need to switch\n\t * the memory stream to a tmpfile stream */\n\n\tif (ret == NULL && castas == PHP_STREAM_AS_STDIO) {\n\t\treturn SUCCESS;\n\t}\n\n\t/* say \""no\"" to other stream forms */\n\tif (ret == NULL) {\n\t\treturn FAILURE;\n\t}\n\n\t/* perform the conversion and then pass the request on to the innerstream */\n\tmembuf = php_stream_memory_get_buffer(ts->innerstream, &memsize);\n\tfile = php_stream_fopen_tmpfile();\n\tphp_stream_write(file, membuf, memsize);\n\tpos = php_stream_tell(ts->innerstream);\n\n\tphp_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE);\n\tts->innerstream = file;\n\tphp_stream_encloses(stream, ts->innerstream);\n\tphp_stream_seek(ts->innerstream, pos, SEEK_SET);\n\n\treturn php_stream_cast(ts->innerstream, castas, ret, 1);\n}""}, {""func_name"": ""php_stream_memory_set_option"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_memory_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_memory_data *ms = (php_stream_memory_data*)stream->abstract;\n\tsize_t newsize;\n\n\tswitch(option) {\n\t\tcase PHP_STREAM_OPTION_TRUNCATE_API:\n\t\t\tswitch (value) {\n\t\t\t\tcase PHP_STREAM_TRUNCATE_SUPPORTED:\n\t\t\t\t\treturn PHP_STREAM_OPTION_RETURN_OK;\n\n\t\t\t\tcase PHP_STREAM_TRUNCATE_SET_SIZE:\n\t\t\t\t\tif (ms->mode & TEMP_STREAM_READONLY) {\n\t\t\t\t\t\treturn PHP_STREAM_OPTION_RETURN_ERR;\n\t\t\t\t\t}\n\t\t\t\t\tnewsize = *(size_t*)ptrparam;\n\t\t\t\t\tif (newsize <= ms->fsize) {\n\t\t\t\t\t\tif (newsize < ms->fpos) {\n\t\t\t\t\t\t\tms->fpos = newsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tms->data = erealloc(ms->data, newsize);\n\t\t\t\t\t\tmemset(ms->data+ms->fsize, 0, newsize - ms->fsize);\n\t\t\t\t\t\tms->fsize = newsize;\n\t\t\t\t\t}\n\t\t\t\t\tms->fsize = newsize;\n\t\t\t\t\treturn PHP_STREAM_OPTION_RETURN_OK;\n\t\t\t}\n\t\tdefault:\n\t\t\treturn PHP_STREAM_OPTION_RETURN_NOTIMPL;\n\t}\n}""}, {""func_name"": ""_php_stream_memory_open"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""PHPAPI php_stream *_php_stream_memory_open(int mode, char *buf, size_t length STREAMS_DC TSRMLS_DC)\n{\n\tphp_stream *stream;\n\tphp_stream_memory_data *ms;\n\n\tif ((stream = php_stream_memory_create_rel(mode)) != NULL) {\n\t\tms = (php_stream_memory_data*)stream->abstract;\n\n\t\tif (mode == TEMP_STREAM_READONLY || mode == TEMP_STREAM_TAKE_BUFFER) {\n\t\t\t/* use the buffer directly */\n\t\t\tms->data = buf;\n\t\t\tms->fsize = length;\n\t\t} else {\n\t\t\tif (length) {\n\t\t\t\tassert(buf != NULL);\n\t\t\t\tphp_stream_write(stream, buf, length);\n\t\t\t}\n\t\t}\n\t}\n\treturn stream;\n}""}, {""func_name"": ""php_stream_url_wrap_rfc2397"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static php_stream * php_stream_url_wrap_rfc2397(php_stream_wrapper *wrapper, char *path, char *mode, int options, char **opened_path, php_stream_context *context STREAMS_DC TSRMLS_DC) /* {{{ */\n{\n\tphp_stream *stream;\n\tphp_stream_temp_data *ts;\n\tchar *comma, *semi, *sep, *key;\n\tsize_t mlen, dlen, plen, vlen;\n\toff_t newoffs;\n\tzval *meta = NULL;\n\tint base64 = 0, ilen;\n\n\tif (memcmp(path, \""data:\"", 5)) {\n\t\treturn NULL;\n\t}\n\n\tpath += 5;\n\tdlen = strlen(path);\n\n\tif (dlen >= 2 && path[0] == '/' && path[1] == '/') {\n\t\tdlen -= 2;\n\t\tpath += 2;\n\t}\n\n\tif ((comma = memchr(path, ',', dlen)) == NULL) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: no comma in URL\"");\n\t\treturn NULL;\n\t}\n\n\tif (comma != path) {\n\t\t/* meta info */\n\t\tmlen = comma - path;\n\t\tdlen -= mlen;\n\t\tsemi = memchr(path, ';', mlen);\n\t\tsep = memchr(path, '/', mlen);\n\n\t\tif (!semi && !sep) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: illegal media type\"");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tMAKE_STD_ZVAL(meta);\n\t\tarray_init(meta);\n\t\tif (!semi) { /* there is only a mime type */\n\t\t\tadd_assoc_stringl(meta, \""mediatype\"", path, mlen, 1);\n\t\t\tmlen = 0;\n\t\t} else if (sep && sep < semi) { /* there is a mime type */\n\t\t\tplen = semi - path;\n\t\t\tadd_assoc_stringl(meta, \""mediatype\"", path, plen, 1);\n\t\t\tmlen -= plen;\n\t\t\tpath += plen;\n\t\t} else if (semi != path || mlen != sizeof(\"";base64\"")-1 || memcmp(path, \"";base64\"", sizeof(\"";base64\"")-1)) { /* must be error since parameters are only allowed after mediatype */\n\t\t\tzval_ptr_dtor(&meta);\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: illegal media type\"");\n\t\t\treturn NULL;\n\t\t}\n\t\t/* get parameters and potentially ';base64' */\n\t\twhile(semi && (semi == path)) {\n\t\t\tpath++;\n\t\t\tmlen--;\n\t\t\tsep = memchr(path, '=', mlen);\n\t\t\tsemi = memchr(path, ';', mlen);\n\t\t\tif (!sep || (semi && semi < sep)) { /* must be ';base64' or failure */\n\t\t\t\tif (mlen != sizeof(\""base64\"")-1 || memcmp(path, \""base64\"", sizeof(\""base64\"")-1)) {\n\t\t\t\t\t/* must be error since parameters are only allowed after mediatype and we have no '=' sign */\n\t\t\t\t\tzval_ptr_dtor(&meta);\n\t\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: illegal parameter\"");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tbase64 = 1;\n\t\t\t\tmlen -= sizeof(\""base64\"") - 1;\n\t\t\t\tpath += sizeof(\""base64\"") - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* found parameter ... the heart of cs ppl lies in +1/-1 or was it +2 this time? */\n\t\t\tplen = sep - path;\n\t\t\tvlen = (semi ? semi - sep : mlen - plen) - 1 /* '=' */;\n\t\t\tkey = estrndup(path, plen);\n\t\t\tif (plen != sizeof(\""mediatype\"")-1 || memcmp(key, \""mediatype\"", sizeof(\""mediatype\"")-1)) {\n\t\t\t\tadd_assoc_stringl_ex(meta, key, plen + 1, sep + 1, vlen, 1);\n\t\t\t}\n\t\t\tefree(key);\n\t\t\tplen += vlen + 1;\n\t\t\tmlen -= plen;\n\t\t\tpath += plen;\n\t\t}\n\t\tif (mlen) {\n\t\t\tzval_ptr_dtor(&meta);\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: illegal URL\"");\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tMAKE_STD_ZVAL(meta);\n\t\tarray_init(meta);\n\t}\n\tadd_assoc_bool(meta, \""base64\"", base64);\n\n\t/* skip ',' */\n\tcomma++;\n\tdlen--;\n\n\tif (base64) {\n\t\tcomma = (char*)php_base64_decode((const unsigned char *)comma, dlen, &ilen);\n\t\tif (!comma) {\n\t\t\tzval_ptr_dtor(&meta);\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \""rfc2397: unable to decode\"");\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tcomma = estrndup(comma, dlen);\n\t\tilen = dlen = php_url_decode(comma, dlen);\n\t}\n\n\tif ((stream = php_stream_temp_create_rel(0, ~0u)) != NULL) {\n\t\t/* store data */\n\t\tphp_stream_temp_write(stream, comma, ilen TSRMLS_CC);\n\t\tphp_stream_temp_seek(stream, 0, SEEK_SET, &newoffs TSRMLS_CC);\n\t\t/* set special stream stuff (enforce exact mode) */\n\t\tvlen = strlen(mode);\n\t\tif (vlen >= sizeof(stream->mode)) {\n\t\t\tvlen = sizeof(stream->mode) - 1;\n\t\t}\n\t\tmemcpy(stream->mode, mode, vlen);\n\t\tstream->mode[vlen] = '\\0';\n\t\tstream->ops = &php_stream_rfc2397_ops;\n\t\tts = (php_stream_temp_data*)stream->abstract;\n\t\tassert(ts != NULL);\n\t\tts->mode = mode && mode[0] == 'r' && mode[1] != '+' ? TEMP_STREAM_READONLY : 0;\n\t\tts->meta = meta;\n\t}\n\tefree(comma);\n\n\treturn stream;\n}""}, {""func_name"": ""php_stream_memory_stat"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_memory_stat(php_stream *stream, php_stream_statbuf *ssb TSRMLS_DC) /* {{{ */\n{\n\ttime_t timestamp = 0;\n\tphp_stream_memory_data *ms = (php_stream_memory_data*)stream->abstract;\n\tassert(ms != NULL);\n\n\tmemset(ssb, 0, sizeof(php_stream_statbuf));\n\t/* read-only across the board */\n\n\tssb->sb.st_mode = ms->mode & TEMP_STREAM_READONLY ? 0444 : 0666;\n\n\tssb->sb.st_size = ms->fsize;\n\tssb->sb.st_mode |= S_IFREG; /* regular file */\n\n#ifdef NETWARE\n\tssb->sb.st_mtime.tv_sec = timestamp;\n\tssb->sb.st_atime.tv_sec = timestamp;\n\tssb->sb.st_ctime.tv_sec = timestamp;\n#else\n\tssb->sb.st_mtime = timestamp;\n\tssb->sb.st_atime = timestamp;\n\tssb->sb.st_ctime = timestamp;\n#endif\n\n\tssb->sb.st_nlink = 1;\n\tssb->sb.st_rdev = -1;\n\t/* this is only for APC, so use /dev/null device - no chance of conflict there! */\n\tssb->sb.st_dev = 0xC;\n\t/* generate unique inode number for alias/filename, so no phars will conflict */\n\tssb->sb.st_ino = 0;\n\n#ifndef PHP_WIN32\n\tssb->sb.st_blksize = -1;\n#endif\n\n#if !defined(PHP_WIN32) && !defined(__BEOS__)\n\tssb->sb.st_blocks = -1;\n#endif\n\n\treturn 0;\n}""}, {""func_name"": ""php_stream_temp_seek"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tint ret;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\t*newoffs = -1;\n\t\treturn -1;\n\t}\n\tret = php_stream_seek(ts->innerstream, offset, whence);\n\t*newoffs = php_stream_tell(ts->innerstream);\n\tstream->eof = ts->innerstream->eof;\n\n\treturn ret;\n}""}, {""func_name"": ""php_stream_temp_set_option"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_temp_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\n\tswitch(option) {\n\t\tcase PHP_STREAM_OPTION_META_DATA_API:\n\t\t\tif (ts->meta) {\n\t\t\t\tzend_hash_copy(Z_ARRVAL_P((zval*)ptrparam), Z_ARRVAL_P(ts->meta), (copy_ctor_func_t) zval_add_ref, NULL, sizeof(zval*));\n\t\t\t}\n\t\t\treturn PHP_STREAM_OPTION_RETURN_OK;\n\t\tdefault:\n\t\t\tif (ts->innerstream) {\n\t\t\t\treturn php_stream_set_option(ts->innerstream, option, value, ptrparam);\n\t\t\t}\n\t\t\treturn PHP_STREAM_OPTION_RETURN_NOTIMPL;\n\t}\n}""}, {""func_name"": ""php_stream_temp_read"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static size_t php_stream_temp_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tsize_t got;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\treturn -1;\n\t}\n\n\tgot = php_stream_read(ts->innerstream, buf, count);\n\n\tstream->eof = ts->innerstream->eof;\n\n\treturn got;\n}""}, {""func_name"": ""php_stream_temp_close"", ""file_path"": ""main/streams/memory.c"", ""func_code"": ""static int php_stream_temp_close(php_stream *stream, int close_handle TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tint ret;\n\n\tassert(ts != NULL);\n\n\tif (ts->innerstream) {\n\t\tret = php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE | (close_handle ? 0 : PHP_STREAM_FREE_PRESERVE_HANDLE));\n\t} else {\n\t\tret = 0;\n\t}\n\n\tif (ts->meta) {\n\t\tzval_ptr_dtor(&ts->meta);\n\t}\n\n\tefree(ts);\n\n\treturn ret;\n}""}, {""func_name"": ""stream_array_from_fd_set"", ""file_path"": ""ext/standard/streamsfuncs.c"", ""func_code"": ""static int stream_array_from_fd_set(zval *stream_array, fd_set *fds TSRMLS_DC)\n{\n\tzval **elem, **dest_elem;\n\tphp_stream *stream;\n\tHashTable *new_hash;\n\tint ret = 0;\n\n\tif (Z_TYPE_P(stream_array) != IS_ARRAY) {\n\t\treturn 0;\n\t}\n\tALLOC_HASHTABLE(new_hash);\n\tzend_hash_init(new_hash, zend_hash_num_elements(Z_ARRVAL_P(stream_array)), NULL, ZVAL_PTR_DTOR, 0);\n\n\tfor (zend_hash_internal_pointer_reset(Z_ARRVAL_P(stream_array));\n\t\t zend_hash_has_more_elements(Z_ARRVAL_P(stream_array)) == SUCCESS;\n\t\t zend_hash_move_forward(Z_ARRVAL_P(stream_array))) {\n\n\t\tint type;\n\t\tchar *key;\n\t\tuint key_len;\n\t\tulong num_ind;\n\t\t/* Temporary int fd is needed for the STREAM data type on windows, passing this_fd directly to php_stream_cast()\n\t\t\twould eventually bring a wrong result on x64. php_stream_cast() casts to int internally, and this will leave\n\t\t\tthe higher bits of a SOCKET variable uninitialized on systems with little endian. */\n\t\tint tmp_fd;\n\n\n\t\ttype = zend_hash_get_current_key_ex(Z_ARRVAL_P(stream_array),\n\t\t\t\t&key, &key_len, &num_ind, 0, NULL);\n\t\tif (type == HASH_KEY_NON_EXISTENT ||\n\t\t\tzend_hash_get_current_data(Z_ARRVAL_P(stream_array), (void **) &elem) == FAILURE) {\n\t\t\tcontinue; /* should not happen */\n\t\t}\n\n\t\tphp_stream_from_zval_no_verify(stream, elem);\n\t\tif (stream == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* get the fd\n\t\t * NB: Most other code will NOT use the PHP_STREAM_CAST_INTERNAL flag\n\t\t * when casting.  It is only used here so that the buffered data warning\n\t\t * is not displayed.\n\t\t */\n\t\tif (SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL, (void*)&tmp_fd, 1) && tmp_fd != -1) {\n\n\t\t\tphp_socket_t this_fd = (php_socket_t)tmp_fd;\n\n\t\t\tif (PHP_SAFE_FD_ISSET(this_fd, fds)) {\n\t\t\t\tif (type == HASH_KEY_IS_LONG) {\n\t\t\t\t\tzend_hash_index_update(new_hash, num_ind, (void *)elem, sizeof(zval *), (void **)&dest_elem);\n\t\t\t\t} else { /* HASH_KEY_IS_STRING */\n\t\t\t\t\tzend_hash_update(new_hash, key, key_len, (void *)elem, sizeof(zval *), (void **)&dest_elem);\n\t\t\t\t}\n\n\t\t\t\tif (dest_elem) {\n\t\t\t\t\tzval_add_ref(dest_elem);\n\t\t\t\t}\n\t\t\t\tret++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* destroy old array and add new one */\n\tzend_hash_destroy(Z_ARRVAL_P(stream_array));\n\tefree(Z_ARRVAL_P(stream_array));\n\n\tzend_hash_internal_pointer_reset(new_hash);\n\tZ_ARRVAL_P(stream_array) = new_hash;\n\n\treturn ret;\n}""}]",{},[],"main/streams/memory.c:640-683: Code allowed arbitrary metadata key-value pairs from data URIs. The patch adds a check to only accept 'mediatype' keys, preventing attacker-controlled metadata injection.",0.95,./github/other_context/CVE-2016-10712
13,CVE-2016-2145,"CWE-119, CWE-20",c_cpp,"The am_read_post_data function in mod_auth_mellon before 0.11.1 does not check if the ap_get_client_block function returns an error, which allows remote attackers to cause a denial of service (segmentation fault and process crash) via a crafted POST data.",https://github.com/Uninett/mod_auth_mellon/commit/5f03a632c9652687c7dac1ea44f334b9983ab268,Handle ap_get_client_block() error in am_read_post_data(),1,"[{""func_name"": ""am_read_post_data"", ""file_path"": ""auth_mellon_util.c"", ""func_code"": ""int am_read_post_data(request_rec *r, char **data, apr_size_t *length)\n{\n    apr_size_t bytes_read;\n    apr_size_t bytes_left;\n    apr_size_t len;\n    long read_length;\n    int rc;\n\n    /* Prepare to receive data from the client. We request that apache\n     * dechunks data if it is chunked.\n     */\n    rc = ap_setup_client_block(r, REQUEST_CHUNKED_DECHUNK);\n    if (rc != OK) {\n        return rc;\n    }\n\n    /* This function will send a 100 Continue response if the client is\n     * waiting for that. If the client isn't going to send data, then this\n     * function will return 0.\n     */\n    if (!ap_should_client_block(r)) {\n        len = 0;\n    } else {\n        len = r->remaining;\n    }\n\n    if (length != NULL) {\n        *length = len;\n    }\n\n    *data = (char *)apr_palloc(r->pool, len + 1);\n\n    /* Make sure that the data is null-terminated.  */\n    (*data)[len] = '\\0';\n\n    bytes_read = 0;\n    bytes_left = len;\n\n    while (bytes_left > 0) {\n        /* Read data from the client. Returns 0 on EOF or error, the\n         * number of bytes otherwise.\n         */\n        read_length = ap_get_client_block(r, &(*data)[bytes_read],\n                                          bytes_left);\n        if (read_length == 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \""Failed to read POST data from client.\"");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        bytes_read += read_length;\n        bytes_left -= read_length;\n    }\n\n    return OK;\n}"", ""target"": 0}]","[{""func_name"": ""am_read_post_data"", ""file_path"": ""auth_mellon_util.c"", ""func_code"": ""int am_read_post_data(request_rec *r, char **data, apr_size_t *length)\n{\n    apr_size_t bytes_read;\n    apr_size_t bytes_left;\n    apr_size_t len;\n    long read_length;\n    int rc;\n\n    /* Prepare to receive data from the client. We request that apache\n     * dechunks data if it is chunked.\n     */\n    rc = ap_setup_client_block(r, REQUEST_CHUNKED_DECHUNK);\n    if (rc != OK) {\n        return rc;\n    }\n\n    /* This function will send a 100 Continue response if the client is\n     * waiting for that. If the client isn't going to send data, then this\n     * function will return 0.\n     */\n    if (!ap_should_client_block(r)) {\n        len = 0;\n    } else {\n        len = r->remaining;\n    }\n\n    if (length != NULL) {\n        *length = len;\n    }\n\n    *data = (char *)apr_palloc(r->pool, len + 1);\n\n    /* Make sure that the data is null-terminated.  */\n    (*data)[len] = '\\0';\n\n    bytes_read = 0;\n    bytes_left = len;\n\n    while (bytes_left > 0) {\n        /* Read data from the client. Returns 0 on EOF and -1 on\n         * error, the number of bytes otherwise.\n         */\n        read_length = ap_get_client_block(r, &(*data)[bytes_read],\n                                          bytes_left);\n        if (read_length == 0) {\n            /* got the EOF */\n            (*data)[bytes_read] = '\\0';\n\n            if (length != NULL) {\n                *length = bytes_read;\n            }\n            break;\n        }\n        else if (read_length < 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \""Failed to read POST data from client.\"");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        bytes_read += read_length;\n        bytes_left -= read_length;\n    }\n\n    return OK;\n}""}]",{},[],"Original code (auth_mellon_util.c:575-584) assumed ap_get_client_block returns 0 on EOF or error, but failed to distinguish between EOF (0) and errors (<0). Patch added explicit handling for read_length < 0 (auth_mellon_util.c:585-595).",0.95,./github/other_context/CVE-2016-2145
14,CVE-2016-4449,CWE-20,c_cpp,"XML external entity (XXE) vulnerability in the xmlStringLenDecodeEntities function in parser.c in libxml2 before 2.9.4, when not in validating mode, allows context-dependent attackers to read arbitrary files or cause a denial of service (resource consumption) via unspecified vectors.",https://github.com/GNOME/libxml2/commit/b1d34de46a11323fccffa9fadeb33be670d602f5,Fix inappropriate fetch of entities content\n\nFor https://bugzilla.gnome.org/show_bug.cgi?id=761430\n\nlibfuzzer regression testing exposed another case where the parser would\nfetch content of an external entity while not in validating mode.\nPlug that hole,1,"[{""func_name"": ""xmlStringLenDecodeEntities"", ""file_path"": ""parser.c"", ""func_code"": ""xmlChar *\nxmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n\t\t      int what, xmlChar end, xmlChar  end2, xmlChar end3) {\n    xmlChar *buffer = NULL;\n    size_t buffer_size = 0;\n    size_t nbchars = 0;\n\n    xmlChar *current = NULL;\n    xmlChar *rep = NULL;\n    const xmlChar *last;\n    xmlEntityPtr ent;\n    int c,l;\n\n    if ((ctxt == NULL) || (str == NULL) || (len < 0))\n\treturn(NULL);\n    last = str + len;\n\n    if (((ctxt->depth > 40) &&\n         ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n\t(ctxt->depth > 1024)) {\n\txmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buffer_size = XML_PARSER_BIG_BUFFER_SIZE;\n    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);\n    if (buffer == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     * we are operating on already parsed values.\n     */\n    if (str < last)\n\tc = CUR_SCHAR(str, l);\n    else\n        c = 0;\n    while ((c != 0) && (c != end) && /* non input consuming loop */\n\t   (c != end2) && (c != end3)) {\n\n\tif (c == 0) break;\n        if ((c == '&') && (str[1] == '#')) {\n\t    int val = xmlParseStringCharRef(ctxt, &str);\n\t    if (val != 0) {\n\t\tCOPY_BUF(0,buffer,nbchars,val);\n\t    }\n\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\""String decoding Entity Reference: %.30s\\n\"",\n\t\t\tstr);\n\t    ent = xmlParseStringEntityRef(ctxt, &str);\n\t    if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||\n\t        (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))\n\t        goto int_error;\n\t    xmlParserEntityCheck(ctxt, 0, ent, 0);\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked / 2;\n\t    if ((ent != NULL) &&\n\t\t(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\tif (ent->content != NULL) {\n\t\t    COPY_BUF(0,buffer,nbchars,ent->content[0]);\n\t\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t\tgrowBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t    }\n\t\t} else {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t    \""predefined entity has no content\\n\"");\n\t\t}\n\t    } else if ((ent != NULL) && (ent->content != NULL)) {\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\n\t\tif ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||\n\t\t    (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))\n\t\t    goto int_error;\n\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))\n\t\t\t\tgoto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    } else if (ent != NULL) {\n\t\tint i = xmlStrlen(ent->name);\n\t\tconst xmlChar *cur = ent->name;\n\n\t\tbuffer[nbchars++] = '&';\n\t\tif (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);\n\t\t}\n\t\tfor (;i > 0;i--)\n\t\t    buffer[nbchars++] = *cur++;\n\t\tbuffer[nbchars++] = ';';\n\t    }\n\t} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\""String decoding PE Reference: %.30s\\n\"", str);\n\t    ent = xmlParseStringPEReference(ctxt, &str);\n\t    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n\t        goto int_error;\n\t    xmlParserEntityCheck(ctxt, 0, ent, 0);\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked / 2;\n\t    if (ent != NULL) {\n                if (ent->content == NULL) {\n\t\t    xmlLoadEntityContent(ctxt, ent);\n\t\t}\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))\n\t\t\t        goto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    }\n\t} else {\n\t    COPY_BUF(l,buffer,nbchars,c);\n\t    str += l;\n\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t}\n\tif (str < last)\n\t    c = CUR_SCHAR(str, l);\n\telse\n\t    c = 0;\n    }\n    buffer[nbchars] = 0;\n    return(buffer);\n\nmem_error:\n    xmlErrMemory(ctxt, NULL);\nint_error:\n    if (rep != NULL)\n        xmlFree(rep);\n    if (buffer != NULL)\n        xmlFree(buffer);\n    return(NULL);\n}"", ""target"": 0}]","[{""func_name"": ""xmlStringLenDecodeEntities"", ""file_path"": ""parser.c"", ""func_code"": ""xmlChar *\nxmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n\t\t      int what, xmlChar end, xmlChar  end2, xmlChar end3) {\n    xmlChar *buffer = NULL;\n    size_t buffer_size = 0;\n    size_t nbchars = 0;\n\n    xmlChar *current = NULL;\n    xmlChar *rep = NULL;\n    const xmlChar *last;\n    xmlEntityPtr ent;\n    int c,l;\n\n    if ((ctxt == NULL) || (str == NULL) || (len < 0))\n\treturn(NULL);\n    last = str + len;\n\n    if (((ctxt->depth > 40) &&\n         ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n\t(ctxt->depth > 1024)) {\n\txmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buffer_size = XML_PARSER_BIG_BUFFER_SIZE;\n    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);\n    if (buffer == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     * we are operating on already parsed values.\n     */\n    if (str < last)\n\tc = CUR_SCHAR(str, l);\n    else\n        c = 0;\n    while ((c != 0) && (c != end) && /* non input consuming loop */\n\t   (c != end2) && (c != end3)) {\n\n\tif (c == 0) break;\n        if ((c == '&') && (str[1] == '#')) {\n\t    int val = xmlParseStringCharRef(ctxt, &str);\n\t    if (val != 0) {\n\t\tCOPY_BUF(0,buffer,nbchars,val);\n\t    }\n\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\""String decoding Entity Reference: %.30s\\n\"",\n\t\t\tstr);\n\t    ent = xmlParseStringEntityRef(ctxt, &str);\n\t    if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||\n\t        (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))\n\t        goto int_error;\n\t    xmlParserEntityCheck(ctxt, 0, ent, 0);\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked / 2;\n\t    if ((ent != NULL) &&\n\t\t(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\tif (ent->content != NULL) {\n\t\t    COPY_BUF(0,buffer,nbchars,ent->content[0]);\n\t\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t\tgrowBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t    }\n\t\t} else {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t    \""predefined entity has no content\\n\"");\n\t\t}\n\t    } else if ((ent != NULL) && (ent->content != NULL)) {\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\n\t\tif ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||\n\t\t    (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))\n\t\t    goto int_error;\n\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))\n\t\t\t\tgoto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    } else if (ent != NULL) {\n\t\tint i = xmlStrlen(ent->name);\n\t\tconst xmlChar *cur = ent->name;\n\n\t\tbuffer[nbchars++] = '&';\n\t\tif (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);\n\t\t}\n\t\tfor (;i > 0;i--)\n\t\t    buffer[nbchars++] = *cur++;\n\t\tbuffer[nbchars++] = ';';\n\t    }\n\t} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\""String decoding PE Reference: %.30s\\n\"", str);\n\t    ent = xmlParseStringPEReference(ctxt, &str);\n\t    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n\t        goto int_error;\n\t    xmlParserEntityCheck(ctxt, 0, ent, 0);\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked / 2;\n\t    if (ent != NULL) {\n                if (ent->content == NULL) {\n\t\t    /*\n\t\t     * Note: external parsed entities will not be loaded,\n\t\t     * it is not required for a non-validating parser to\n\t\t     * complete external PEreferences coming from the\n\t\t     * internal subset\n\t\t     */\n\t\t    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||\n\t\t\t((ctxt->options & XML_PARSE_DTDVALID) != 0) ||\n\t\t\t(ctxt->validate != 0)) {\n\t\t\txmlLoadEntityContent(ctxt, ent);\n\t\t    } else {\n\t\t\txmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,\n\t\t  \""not validating will not read content for PE entity %s\\n\"",\n\t\t                      ent->name, NULL);\n\t\t    }\n\t\t}\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))\n\t\t\t        goto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    }\n\t} else {\n\t    COPY_BUF(l,buffer,nbchars,c);\n\t    str += l;\n\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t}\n\tif (str < last)\n\t    c = CUR_SCHAR(str, l);\n\telse\n\t    c = 0;\n    }\n    buffer[nbchars] = 0;\n    return(buffer);\n\nmem_error:\n    xmlErrMemory(ctxt, NULL);\nint_error:\n    if (rep != NULL)\n        xmlFree(rep);\n    if (buffer != NULL)\n        xmlFree(buffer);\n    return(NULL);\n}""}]","{""value"": 3, ""function"": 1}","[{""source"": ""value_info(file:parser.c, value:XML_PARSE_NOENT)"", ""result"": {""value_trace"": [{""full_code"": ""XML_PARSE_NOENT\t= 1<<1"", ""line"": 1091, ""func_name"": ""xmlParserOption:<clinit>""}], ""struct_var"": ""XML_PARSE_NOENT"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:parser.c, value:XML_PARSE_DTDVALID)"", ""result"": {""value_trace"": [{""full_code"": ""XML_PARSE_DTDVALID\t= 1<<4"", ""line"": 1094, ""func_name"": ""xmlParserOption:<clinit>""}], ""struct_var"": ""XML_PARSE_DTDVALID"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:parser.c, value:ctxt->validate)"", ""result"": {""value_trace"": [{""full_code"": ""ctxt->validate = 0"", ""line"": 11054, ""func_name"": ""xmlParseExtParsedEnt""}, {""full_code"": ""ctxt->validate = ctx->validate"", ""line"": 13195, ""func_name"": ""xmlParseCtxtExternalEntity""}, {""full_code"": ""ctxt->validate = oldctxt->validate"", ""line"": 13319, ""func_name"": ""xmlParseExternalEntityPrivate""}, {""full_code"": ""ctxt->validate = 0"", ""line"": 13331, ""func_name"": ""xmlParseExternalEntityPrivate""}, {""full_code"": ""ctxt->validate = 0"", ""line"": 13642, ""func_name"": ""xmlParseBalancedChunkMemoryInternal""}], ""struct_var"": ""ctxt"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:parser.c, func:xmlLoadEntityContent)"", ""result"": [{""code"": ""static int\nxmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {\n    xmlParserInputPtr input;\n    xmlBufferPtr buf;\n    int l, c;\n    int count = 0;\n\n    if ((ctxt == NULL) || (entity == NULL) ||\n        ((entity->etype != XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t (entity->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||\n\t(entity->content != NULL)) {\n\txmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t            \""xmlLoadEntityContent parameter error\"");\n        return(-1);\n    }\n\n    if (xmlParserDebugEntities)\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\""Reading %s entity content input\\n\"", entity->name);\n\n    buf = xmlBufferCreate();\n    if (buf == NULL) {\n\txmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t            \""xmlLoadEntityContent parameter error\"");\n        return(-1);\n    }\n\n    input = xmlNewEntityInputStream(ctxt, entity);\n    if (input == NULL) {\n\txmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t            \""xmlLoadEntityContent input error\"");\n\txmlBufferFree(buf);\n        return(-1);..."", ""start_line"": 8143, ""end_line"": 8227, ""full_name"": ""xmlLoadEntityContent"", ""file_path"": ""parser.c""}]}]","parser.c:2862-2863: Unconditional call to xmlLoadEntityContent() allowed external entity content to be fetched regardless of parser mode. Patch adds conditional check (parser.c:2867-2873) requiring XML_PARSE_NOENT, XML_PARSE_DTDVALID, or ctxt->validate to be true. XML_PARSE_NOENT (parser.c:1091) and XML_PARSE_DTDVALID (parser.c:1094) are bitmask flags. ctxt->validate is initialized to 0 in functions like xmlParseExternalEntityPrivate (parser.c:13331). xmlLoadEntityContent (parser.c:8143) creates an input stream for external entities, triggering file access.",0.95,./github/other_context/CVE-2016-4449
15,CVE-2016-4809,CWE-20,c_cpp,The archive_read_format_cpio_read_header function in archive_read_support_format_cpio.c in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a CPIO archive with a large symlink.,https://github.com/libarchive/libarchive/commit/fd7e0c02e272913a0a8b6d492c7260dfca0b1408,Reject cpio symlinks that exceed 1MB,1,"[{""func_name"": ""archive_read_format_cpio_read_header"", ""file_path"": ""libarchive/archive_read_support_format_cpio.c"", ""func_code"": ""static int\narchive_read_format_cpio_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct cpio *cpio;\n\tconst void *h;\n\tstruct archive_string_conv *sconv;\n\tsize_t namelength;\n\tsize_t name_pad;\n\tint r;\n\n\tcpio = (struct cpio *)(a->format->data);\n\tsconv = cpio->opt_sconv;\n\tif (sconv == NULL) {\n\t\tif (!cpio->init_default_conversion) {\n\t\t\tcpio->sconv_default =\n\t\t\t    archive_string_default_conversion_for_read(\n\t\t\t      &(a->archive));\n\t\t\tcpio->init_default_conversion = 1;\n\t\t}\n\t\tsconv = cpio->sconv_default;\n\t}\n\t\n\tr = (cpio->read_header(a, cpio, entry, &namelength, &name_pad));\n\n\tif (r < ARCHIVE_WARN)\n\t\treturn (r);\n\n\t/* Read name from buffer. */\n\th = __archive_read_ahead(a, namelength + name_pad, NULL);\n\tif (h == NULL)\n\t    return (ARCHIVE_FATAL);\n\tif (archive_entry_copy_pathname_l(entry,\n\t    (const char *)h, namelength, sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \""Can't allocate memory for Pathname\"");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \""Pathname can't be converted from %s to current locale.\"",\n\t\t    archive_string_conversion_charset_name(sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\tcpio->entry_offset = 0;\n\n\t__archive_read_consume(a, namelength + name_pad);\n\n\t/* If this is a symlink, read the link contents. */\n\tif (archive_entry_filetype(entry) == AE_IFLNK) {\n\t\th = __archive_read_ahead(a,\n\t\t\t(size_t)cpio->entry_bytes_remaining, NULL);\n\t\tif (h == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tif (archive_entry_copy_symlink_l(entry, (const char *)h,\n\t\t    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \""Can't allocate memory for Linkname\"");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \""Linkname can't be converted from %s to \""\n\t\t\t    \""current locale.\"",\n\t\t\t    archive_string_conversion_charset_name(sconv));\n\t\t\tr = ARCHIVE_WARN;\n\t\t}\n\t\t__archive_read_consume(a, cpio->entry_bytes_remaining);\n\t\tcpio->entry_bytes_remaining = 0;\n\t}\n\n\t/* XXX TODO: If the full mode is 0160200, then this is a Solaris\n\t * ACL description for the following entry.  Read this body\n\t * and parse it as a Solaris-style ACL, then read the next\n\t * header.  XXX */\n\n\t/* Compare name to \""TRAILER!!!\"" to test for end-of-archive. */\n\tif (namelength == 11 && strcmp((const char *)h, \""TRAILER!!!\"") == 0) {\n\t\t/* TODO: Store file location of start of block. */\n\t\tarchive_clear_error(&a->archive);\n\t\treturn (ARCHIVE_EOF);\n\t}\n\n\t/* Detect and record hardlinks to previously-extracted entries. */\n\tif (record_hardlink(a, cpio, entry) != ARCHIVE_OK) {\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\treturn (r);\n}"", ""target"": 0}]","[{""func_name"": ""archive_read_format_cpio_read_header"", ""file_path"": ""libarchive/archive_read_support_format_cpio.c"", ""func_code"": ""static int\narchive_read_format_cpio_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct cpio *cpio;\n\tconst void *h;\n\tstruct archive_string_conv *sconv;\n\tsize_t namelength;\n\tsize_t name_pad;\n\tint r;\n\n\tcpio = (struct cpio *)(a->format->data);\n\tsconv = cpio->opt_sconv;\n\tif (sconv == NULL) {\n\t\tif (!cpio->init_default_conversion) {\n\t\t\tcpio->sconv_default =\n\t\t\t    archive_string_default_conversion_for_read(\n\t\t\t      &(a->archive));\n\t\t\tcpio->init_default_conversion = 1;\n\t\t}\n\t\tsconv = cpio->sconv_default;\n\t}\n\t\n\tr = (cpio->read_header(a, cpio, entry, &namelength, &name_pad));\n\n\tif (r < ARCHIVE_WARN)\n\t\treturn (r);\n\n\t/* Read name from buffer. */\n\th = __archive_read_ahead(a, namelength + name_pad, NULL);\n\tif (h == NULL)\n\t    return (ARCHIVE_FATAL);\n\tif (archive_entry_copy_pathname_l(entry,\n\t    (const char *)h, namelength, sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \""Can't allocate memory for Pathname\"");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \""Pathname can't be converted from %s to current locale.\"",\n\t\t    archive_string_conversion_charset_name(sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\tcpio->entry_offset = 0;\n\n\t__archive_read_consume(a, namelength + name_pad);\n\n\t/* If this is a symlink, read the link contents. */\n\tif (archive_entry_filetype(entry) == AE_IFLNK) {\n\t\tif (cpio->entry_bytes_remaining > 1024 * 1024) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte\"");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\th = __archive_read_ahead(a,\n\t\t\t(size_t)cpio->entry_bytes_remaining, NULL);\n\t\tif (h == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tif (archive_entry_copy_symlink_l(entry, (const char *)h,\n\t\t    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \""Can't allocate memory for Linkname\"");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \""Linkname can't be converted from %s to \""\n\t\t\t    \""current locale.\"",\n\t\t\t    archive_string_conversion_charset_name(sconv));\n\t\t\tr = ARCHIVE_WARN;\n\t\t}\n\t\t__archive_read_consume(a, cpio->entry_bytes_remaining);\n\t\tcpio->entry_bytes_remaining = 0;\n\t}\n\n\t/* XXX TODO: If the full mode is 0160200, then this is a Solaris\n\t * ACL description for the following entry.  Read this body\n\t * and parse it as a Solaris-style ACL, then read the next\n\t * header.  XXX */\n\n\t/* Compare name to \""TRAILER!!!\"" to test for end-of-archive. */\n\tif (namelength == 11 && strcmp((const char *)h, \""TRAILER!!!\"") == 0) {\n\t\t/* TODO: Store file location of start of block. */\n\t\tarchive_clear_error(&a->archive);\n\t\treturn (ARCHIVE_EOF);\n\t}\n\n\t/* Detect and record hardlinks to previously-extracted entries. */\n\tif (record_hardlink(a, cpio, entry) != ARCHIVE_OK) {\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\treturn (r);\n}""}]","{""value"": 1}","[{""source"": ""value_info(file:archive_read_support_format_cpio.c, value:cpio->entry_bytes_remaining)"", ""result"": {""value_trace"": [{""full_code"": ""cpio->entry_bytes_remaining = 0"", ""line"": 423, ""func_name"": ""archive_read_format_cpio_read_header""}, {""full_code"": ""cpio->entry_bytes_remaining -= bytes_read"", ""line"": 470, ""func_name"": ""archive_read_format_cpio_read_data""}, {""full_code"": ""cpio->entry_bytes_remaining = 0"", ""line"": 495, ""func_name"": ""archive_read_format_cpio_skip""}, {""full_code"": ""cpio->entry_bytes_remaining =\n\t    atol16(header + newc_filesize_offset, newc_filesize_size)"", ""line"": 635, ""func_name"": ""header_newc""}, {""full_code"": ""cpio->entry_bytes_remaining =\n\t    atol8(header + odc_filesize_offset, odc_filesize_size)"", ""line"": 800, ""func_name"": ""header_odc""}], ""struct_var"": ""cpio"", ""struct_type"": ""cpio*"", ""struct_definition"": ""struct cpio {\n\tint\t\t\t  magic;\n\tint\t\t\t(*read_header)(struct archive_read *, struct cpio *,\n\t\t\t\t     struct archive_entry *, size_t *, size_t *);\n\tstruct links_entry\t *links_head;\n\tint64_t\t\t\t  entry_bytes_remaining;\n\tint64_t\t\t\t  entry_bytes_unconsumed;\n\tint64_t\t\t\t  entry_offset;\n\tint64_t\t\t\t  entry_padding;\n\n\tstruct archive_string_conv *opt_sconv;\n\tstruct archive_string_conv *sconv_default;\n\tint\t\t\t  init_default_conversion;\n}\n\nstruct cpio {\n\tuint64_t\t  entry_bytes_remaining;\n\n\tint64_t\t\t  ino_next;\n\n\tstruct\t\t { int64_t old; int new;} *ino_list;\n\tsize_t\t\t  ino_list_size;\n\tsize_t\t\t  ino_list_next;\n\n\tstruct archive_string_conv *opt_sconv;\n\tstruct archive_string_conv *sconv_default;\n\tint\t\t  init_default_conversion;\n}\n\nstruct cpio {\n\tuint64_t\t  entry_bytes_remaining;\n\tint\t\t  padding;\n\n\tstruct archive_string_conv *opt_sconv;\n\tstruct archive_string_conv *sconv_default;\n\tint\t\t  init_default_conversion;\n}\n\nstruct cpio {\n\t/* Option parsing */\n\tconst char\t *argument;\n\n\t/* Options */\n\tint\t\t  add_filter; /* --uuencode */\n\tconst char\t *filename;\n\tint\t\t  mode; /* -i -o -p */\n\tint\t\t  compress; /* -j, -y, or -z */\n\tconst char\t *format; /* -H format */\n\tint\t\t  bytes_per_block; /* -b block_size */\n\tint\t\t  verbose;   /* -v */\n\tint\t\t  dot;  /* -V */\n\tint\t\t  quiet;   /* --quiet */\n\tint\t\t  extract_flags; /* Flags for extract operation */\n\tconst char\t *compress_program;\n\tint\t\t  option_append; /* -A, only relevant for -o */\n\tint\t\t  option_atime_restore; /* -a */\n\tint\t\t  option_follow_links; /* -L */\n\tint\t\t  option_link; /* -l */\n\tint\t\t  option_list; /* -t */\n\tchar\t\t  option_null; /* --null */\n\tint\t\t  option_numeric_uid_gid; /* -n */\n\tint\t\t  option_rename; /* -r */\n\tchar\t\t *destdir;\n\tsize_t\t\t  pass_destpath_alloc;\n\tchar\t\t *pass_destpath;\n\tint\t\t  uid_override;\n\tchar\t\t *uname_override;\n\tint\t\t  gid_override;\n\tchar\t\t *gname_override;\n\tint\t\t  day_first; /* true if locale prefers day/mon */\n\tconst char\t *pa...""}}]","The vulnerability arises because `cpio->entry_bytes_remaining` in `archive_read_support_format_cpio.c` (lines 635, 800) is directly populated from the CPIO archive header without bounds checking. When processing a symlink (line 402), the code reads `entry_bytes_remaining` bytes without validation, allowing attackers to specify oversized values (e.g., >1MB) in the archive header. This leads to excessive memory allocation and a crash. The patch (lines 402–407) adds a 1MB check to reject such cases.",0.95,./github/other_context/CVE-2016-4809
16,CVE-2016-9385,CWE-20,c_cpp,The x86 segment base write emulation functionality in Xen 4.4.x through 4.7.x allows local x86 PV guest OS administrators to cause a denial of service (host crash) by leveraging lack of canonical address checks.,https://github.com/xen-project/xen/commit/f3fa3abf3e61fb1f25ce721e14ac324dda67311f,"x86/PV: writes of %fs and %gs base MSRs require canonical addresses\n\nCommit c42494acb2 (""x86: fix FS/GS base handling when using the\nfsgsbase feature"") replaced the use of wrmsr_safe() on these paths\nwithout recognizing that wr{f,g}sbase() use just wrmsrl() and that the\nWR{F,G}SBASE instructions also raise #GP for non-canonical input.\n\nSimilarly arch_set_info_guest() needs to prevent non-canonical\naddresses from getting stored into state later to be loaded by context\nswitch code. For consistency also check stack pointers and LDT base.\nDR0..3, otoh, already get properly checked in set_debugreg() (albeit\nwe discard the error there).\n\nThe SHADOW_GS_BASE check isn't strictly necessary, but I think we\nbetter avoid trying the WRMSR if we know it's going to fail.\n\nThis is CVE-2016-9385 / XSA-193.\n\nReported-by: Andrew Cooper <andrew.cooper3@citrix.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>",2,"[{""func_name"": ""arch_set_info_guest"", ""file_path"": ""xen/arch/x86/domain.c"", ""func_code"": ""int arch_set_info_guest(\n    struct vcpu *v, vcpu_guest_context_u c)\n{\n    struct domain *d = v->domain;\n    unsigned long cr3_gfn;\n    struct page_info *cr3_page;\n    unsigned long flags, cr4;\n    unsigned int i;\n    int rc = 0, compat;\n\n    /* The context is a compat-mode one if the target domain is compat-mode;\n     * we expect the tools to DTRT even in compat-mode callers. */\n    compat = is_pv_32bit_domain(d) || is_pvh_32bit_domain(d);\n\n#define c(fld) (compat ? (c.cmp->fld) : (c.nat->fld))\n    flags = c(flags);\n\n    if ( is_pv_domain(d) )\n    {\n        if ( !compat )\n        {\n            if ( !is_canonical_address(c.nat->user_regs.eip) ||\n                 !is_canonical_address(c.nat->event_callback_eip) ||\n                 !is_canonical_address(c.nat->syscall_callback_eip) ||\n                 !is_canonical_address(c.nat->failsafe_callback_eip) )\n                return -EINVAL;\n\n            fixup_guest_stack_selector(d, c.nat->user_regs.ss);\n            fixup_guest_stack_selector(d, c.nat->kernel_ss);\n            fixup_guest_code_selector(d, c.nat->user_regs.cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.nat->trap_ctxt); i++ )\n            {\n                if ( !is_canonical_address(c.nat->trap_ctxt[i].address) )\n                    return -EINVAL;\n                fixup_guest_code_selector(d, c.nat->trap_ctxt[i].cs);\n            }\n\n            if ( !__addr_ok(c.nat->ldt_base) )\n                return -EINVAL;\n        }\n        else\n        {\n            fixup_guest_stack_selector(d, c.cmp->user_regs.ss);\n            fixup_guest_stack_selector(d, c.cmp->kernel_ss);\n            fixup_guest_code_selector(d, c.cmp->user_regs.cs);\n            fixup_guest_code_selector(d, c.cmp->event_callback_cs);\n            fixup_guest_code_selector(d, c.cmp->failsafe_callback_cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); i++ )\n                fixup_guest_code_selector(d, c.cmp->trap_ctxt[i].cs);\n        }\n\n        /* LDT safety checks. */\n        if ( ((c(ldt_base) & (PAGE_SIZE - 1)) != 0) ||\n             (c(ldt_ents) > 8192) )\n            return -EINVAL;\n    }\n    else if ( is_pvh_domain(d) )\n    {\n        if ( c(ctrlreg[0]) || c(ctrlreg[1]) || c(ctrlreg[2]) ||\n             c(ctrlreg[4]) || c(ctrlreg[5]) || c(ctrlreg[6]) ||\n             c(ctrlreg[7]) ||  c(ldt_base) || c(ldt_ents) ||\n             c(user_regs.cs) || c(user_regs.ss) || c(user_regs.es) ||\n             c(user_regs.ds) || c(user_regs.fs) || c(user_regs.gs) ||\n             c(kernel_ss) || c(kernel_sp) || c(gdt_ents) ||\n             (!compat && (c.nat->gs_base_kernel ||\n              c.nat->fs_base || c.nat->gs_base_user)) )\n            return -EINVAL;\n    }\n\n    v->fpu_initialised = !!(flags & VGCF_I387_VALID);\n\n    v->arch.flags &= ~TF_kernel_mode;\n    if ( (flags & VGCF_in_kernel) || has_hvm_container_domain(d)/*???*/ )\n        v->arch.flags |= TF_kernel_mode;\n\n    v->arch.vgc_flags = flags;\n\n    if ( flags & VGCF_I387_VALID )\n    {\n        memcpy(v->arch.fpu_ctxt, &c.nat->fpu_ctxt, sizeof(c.nat->fpu_ctxt));\n        if ( v->arch.xsave_area )\n            v->arch.xsave_area->xsave_hdr.xstate_bv = XSTATE_FP_SSE;\n    }\n    else if ( v->arch.xsave_area )\n    {\n        v->arch.xsave_area->xsave_hdr.xstate_bv = 0;\n        v->arch.xsave_area->fpu_sse.mxcsr = MXCSR_DEFAULT;\n    }\n    else\n    {\n        typeof(v->arch.xsave_area->fpu_sse) *fpu_sse = v->arch.fpu_ctxt;\n\n        memset(fpu_sse, 0, sizeof(*fpu_sse));\n        fpu_sse->fcw = FCW_DEFAULT;\n        fpu_sse->mxcsr = MXCSR_DEFAULT;\n    }\n    if ( v->arch.xsave_area )\n        v->arch.xsave_area->xsave_hdr.xcomp_bv = 0;\n\n    if ( !compat )\n    {\n        memcpy(&v->arch.user_regs, &c.nat->user_regs, sizeof(c.nat->user_regs));\n        if ( is_pv_domain(d) )\n            memcpy(v->arch.pv_vcpu.trap_ctxt, c.nat->trap_ctxt,\n                   sizeof(c.nat->trap_ctxt));\n    }\n    else\n    {\n        XLAT_cpu_user_regs(&v->arch.user_regs, &c.cmp->user_regs);\n        if ( is_pv_domain(d) )\n        {\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); ++i )\n                XLAT_trap_info(v->arch.pv_vcpu.trap_ctxt + i,\n                               c.cmp->trap_ctxt + i);\n        }\n    }\n\n    if ( has_hvm_container_domain(d) )\n    {\n        for ( i = 0; i < ARRAY_SIZE(v->arch.debugreg); ++i )\n            v->arch.debugreg[i] = c(debugreg[i]);\n\n        hvm_set_info_guest(v);\n\n        if ( is_hvm_domain(d) || v->is_initialised )\n            goto out;\n\n        /* NB: No need to use PV cr3 un-pickling macros */\n        cr3_gfn = c(ctrlreg[3]) >> PAGE_SHIFT;\n        cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n        v->arch.cr3 = page_to_maddr(cr3_page);\n        v->arch.hvm_vcpu.guest_cr[3] = c(ctrlreg[3]);\n        v->arch.guest_table = pagetable_from_page(cr3_page);\n\n        ASSERT(paging_mode_enabled(d));\n\n        goto pvh_skip_pv_stuff;\n    }\n\n    init_int80_direct_trap(v);\n\n    /* IOPL privileges are virtualised. */\n    v->arch.pv_vcpu.iopl = v->arch.user_regs.eflags & X86_EFLAGS_IOPL;\n    v->arch.user_regs.eflags &= ~X86_EFLAGS_IOPL;\n\n    /* Ensure real hardware interrupts are enabled. */\n    v->arch.user_regs.eflags |= X86_EFLAGS_IF;\n\n    if ( !v->is_initialised )\n    {\n        if ( !compat && !(flags & VGCF_in_kernel) && !c.nat->ctrlreg[1] )\n            return -EINVAL;\n\n        v->arch.pv_vcpu.ldt_base = c(ldt_base);\n        v->arch.pv_vcpu.ldt_ents = c(ldt_ents);\n    }\n    else\n    {\n        unsigned long pfn = pagetable_get_pfn(v->arch.guest_table);\n        bool_t fail;\n\n        if ( !compat )\n        {\n            fail = xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[3];\n            if ( pagetable_is_null(v->arch.guest_table_user) )\n                fail |= c.nat->ctrlreg[1] || !(flags & VGCF_in_kernel);\n            else\n            {\n                pfn = pagetable_get_pfn(v->arch.guest_table_user);\n                fail |= xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[1];\n            }\n        } else {\n            l4_pgentry_t *l4tab = map_domain_page(_mfn(pfn));\n\n            pfn = l4e_get_pfn(*l4tab);\n            unmap_domain_page(l4tab);\n            fail = compat_pfn_to_cr3(pfn) != c.cmp->ctrlreg[3];\n        }\n\n        for ( i = 0; i < ARRAY_SIZE(v->arch.pv_vcpu.gdt_frames); ++i )\n            fail |= v->arch.pv_vcpu.gdt_frames[i] != c(gdt_frames[i]);\n        fail |= v->arch.pv_vcpu.gdt_ents != c(gdt_ents);\n\n        fail |= v->arch.pv_vcpu.ldt_base != c(ldt_base);\n        fail |= v->arch.pv_vcpu.ldt_ents != c(ldt_ents);\n\n        if ( fail )\n           return -EOPNOTSUPP;\n    }\n\n    v->arch.pv_vcpu.kernel_ss = c(kernel_ss);\n    v->arch.pv_vcpu.kernel_sp = c(kernel_sp);\n    for ( i = 0; i < ARRAY_SIZE(v->arch.pv_vcpu.ctrlreg); ++i )\n        v->arch.pv_vcpu.ctrlreg[i] = c(ctrlreg[i]);\n\n    v->arch.pv_vcpu.event_callback_eip = c(event_callback_eip);\n    v->arch.pv_vcpu.failsafe_callback_eip = c(failsafe_callback_eip);\n    if ( !compat )\n    {\n        v->arch.pv_vcpu.syscall_callback_eip = c.nat->syscall_callback_eip;\n        v->arch.pv_vcpu.fs_base = c.nat->fs_base;\n        v->arch.pv_vcpu.gs_base_kernel = c.nat->gs_base_kernel;\n        v->arch.pv_vcpu.gs_base_user = c.nat->gs_base_user;\n    }\n    else\n    {\n        v->arch.pv_vcpu.event_callback_cs = c(event_callback_cs);\n        v->arch.pv_vcpu.failsafe_callback_cs = c(failsafe_callback_cs);\n    }\n\n    /* Only CR0.TS is modifiable by guest or admin. */\n    v->arch.pv_vcpu.ctrlreg[0] &= X86_CR0_TS;\n    v->arch.pv_vcpu.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;\n\n    cr4 = v->arch.pv_vcpu.ctrlreg[4];\n    v->arch.pv_vcpu.ctrlreg[4] = cr4 ? pv_guest_cr4_fixup(v, cr4) :\n        real_cr4_to_pv_guest_cr4(mmu_cr4_features);\n\n    memset(v->arch.debugreg, 0, sizeof(v->arch.debugreg));\n    for ( i = 0; i < 8; i++ )\n        (void)set_debugreg(v, i, c(debugreg[i]));\n\n    if ( v->is_initialised )\n        goto out;\n\n    if ( v->vcpu_id == 0 )\n    {\n        /*\n         * In the restore case we need to deal with L4 pages which got\n         * initialized with m2p_strict still clear (and which hence lack the\n         * correct initial RO_MPT_VIRT_{START,END} L4 entry).\n         */\n        if ( d != current->domain && !VM_ASSIST(d, m2p_strict) &&\n             is_pv_domain(d) && !is_pv_32bit_domain(d) &&\n             test_bit(VMASST_TYPE_m2p_strict, &c.nat->vm_assist) &&\n             atomic_read(&d->arch.pv_domain.nr_l4_pages) )\n        {\n            bool_t done = 0;\n\n            spin_lock_recursive(&d->page_alloc_lock);\n\n            for ( i = 0; ; )\n            {\n                struct page_info *page = page_list_remove_head(&d->page_list);\n\n                if ( page_lock(page) )\n                {\n                    if ( (page->u.inuse.type_info & PGT_type_mask) ==\n                         PGT_l4_page_table )\n                        done = !fill_ro_mpt(page_to_mfn(page));\n\n                    page_unlock(page);\n                }\n\n                page_list_add_tail(page, &d->page_list);\n\n                if ( done || (!(++i & 0xff) && hypercall_preempt_check()) )\n                    break;\n            }\n\n            spin_unlock_recursive(&d->page_alloc_lock);\n\n            if ( !done )\n                return -ERESTART;\n        }\n\n        d->vm_assist = c(vm_assist);\n    }\n\n    rc = put_old_guest_table(current);\n    if ( rc )\n        return rc;\n\n    if ( !compat )\n        rc = (int)set_gdt(v, c.nat->gdt_frames, c.nat->gdt_ents);\n    else\n    {\n        unsigned long gdt_frames[ARRAY_SIZE(v->arch.pv_vcpu.gdt_frames)];\n        unsigned int n = (c.cmp->gdt_ents + 511) / 512;\n\n        if ( n > ARRAY_SIZE(v->arch.pv_vcpu.gdt_frames) )\n            return -EINVAL;\n        for ( i = 0; i < n; ++i )\n            gdt_frames[i] = c.cmp->gdt_frames[i];\n        rc = (int)set_gdt(v, gdt_frames, c.cmp->gdt_ents);\n    }\n    if ( rc != 0 )\n        return rc;\n\n    set_bit(_VPF_in_reset, &v->pause_flags);\n\n    if ( !compat )\n        cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[3]);\n    else\n        cr3_gfn = compat_cr3_to_pfn(c.cmp->ctrlreg[3]);\n    cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n    if ( !cr3_page )\n        rc = -EINVAL;\n    else if ( paging_mode_refcounts(d) )\n        /* nothing */;\n    else if ( cr3_page == v->arch.old_guest_table )\n    {\n        v->arch.old_guest_table = NULL;\n        put_page(cr3_page);\n    }\n    else\n    {\n        if ( !compat )\n            rc = put_old_guest_table(v);\n        if ( !rc )\n            rc = get_page_type_preemptible(cr3_page,\n                                           !compat ? PGT_root_page_table\n                                                   : PGT_l3_page_table);\n        switch ( rc )\n        {\n        case -EINTR:\n            rc = -ERESTART;\n        case -ERESTART:\n            break;\n        case 0:\n            if ( !compat && !VM_ASSIST(d, m2p_strict) &&\n                 !paging_mode_refcounts(d) )\n                fill_ro_mpt(cr3_gfn);\n            break;\n        default:\n            if ( cr3_page == current->arch.old_guest_table )\n                cr3_page = NULL;\n            break;\n        }\n    }\n    if ( rc )\n        /* handled below */;\n    else if ( !compat )\n    {\n        v->arch.guest_table = pagetable_from_page(cr3_page);\n        if ( c.nat->ctrlreg[1] )\n        {\n            cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[1]);\n            cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n            if ( !cr3_page )\n                rc = -EINVAL;\n            else if ( !paging_mode_refcounts(d) )\n            {\n                rc = get_page_type_preemptible(cr3_page, PGT_root_page_table);\n                switch ( rc )\n                {\n                case -EINTR:\n                    rc = -ERESTART;\n                    /* Fallthrough */\n                case -ERESTART:\n                    v->arch.old_guest_table =\n                        pagetable_get_page(v->arch.guest_table);\n                    v->arch.guest_table = pagetable_null();\n                    break;\n                default:\n                    if ( cr3_page == current->arch.old_guest_table )\n                        cr3_page = NULL;\n                    break;\n                case 0:\n                    if ( VM_ASSIST(d, m2p_strict) )\n                        zap_ro_mpt(cr3_gfn);\n                    break;\n                }\n            }\n            if ( !rc )\n               v->arch.guest_table_user = pagetable_from_page(cr3_page);\n        }\n    }\n    else\n    {\n        l4_pgentry_t *l4tab;\n\n        l4tab = map_domain_page(_mfn(pagetable_get_pfn(v->arch.guest_table)));\n        *l4tab = l4e_from_pfn(page_to_mfn(cr3_page),\n            _PAGE_PRESENT|_PAGE_RW|_PAGE_USER|_PAGE_ACCESSED);\n        unmap_domain_page(l4tab);\n    }\n    if ( rc )\n    {\n        if ( cr3_page )\n            put_page(cr3_page);\n        destroy_gdt(v);\n        return rc;\n    }\n\n    clear_bit(_VPF_in_reset, &v->pause_flags);\n\n pvh_skip_pv_stuff:\n    if ( v->vcpu_id == 0 )\n        update_domain_wallclock_time(d);\n\n    /* Don't redo final setup */\n    v->is_initialised = 1;\n\n    if ( paging_mode_enabled(d) )\n        paging_update_paging_modes(v);\n\n    update_cr3(v);\n\n out:\n    if ( flags & VGCF_online )\n        clear_bit(_VPF_down, &v->pause_flags);\n    else\n        set_bit(_VPF_down, &v->pause_flags);\n    return 0;\n#undef c\n}"", ""target"": 0}, {""func_name"": ""priv_op_write_msr"", ""file_path"": ""xen/arch/x86/traps.c"", ""func_code"": ""static int priv_op_write_msr(unsigned int reg, uint64_t val,\n                             struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n\n    switch ( reg )\n    {\n        uint64_t temp;\n        int rc;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        wrfsbase(val);\n        curr->arch.pv_vcpu.fs_base = val;\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        wrgsbase(val);\n        curr->arch.pv_vcpu.gs_base_kernel = val;\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) ||\n             wrmsr_safe(MSR_SHADOW_GS_BASE, val) )\n            break;\n        curr->arch.pv_vcpu.gs_base_user = val;\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n    case MSR_K8_HWCR:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_AMD64_NB_CFG:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 > 0x17 )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( (rdmsr_safe(MSR_AMD64_NB_CFG, temp) != 0) ||\n             ((val ^ temp) & ~(1ULL << AMD64_NB_CFG_CF8_EXT_ENABLE_BIT)) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_AMD64_NB_CFG, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_FAM10H_MMIO_CONF_BASE:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 > 0x17 )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( rdmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, temp) != 0 )\n            break;\n        if ( (pci_probe & PCI_PROBE_MASK) == PCI_PROBE_MMCONF ?\n             temp != val :\n             ((temp ^ val) &\n              ~(FAM10H_MMIO_CONF_ENABLE |\n                (FAM10H_MMIO_CONF_BUSRANGE_MASK <<\n                 FAM10H_MMIO_CONF_BUSRANGE_SHIFT) |\n                ((u64)FAM10H_MMIO_CONF_BASE_MASK <<\n                 FAM10H_MMIO_CONF_BASE_SHIFT))) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_UCODE_REV:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( rdmsr_safe(reg, temp) )\n            break;\n        if ( val )\n            goto invalid;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MISC_ENABLE:\n        if ( rdmsr_safe(reg, temp) )\n            break;\n        if ( val != guest_misc_enable(temp) )\n            goto invalid;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MPERF:\n    case MSR_IA32_APERF:\n        if ( (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL) &&\n             (boot_cpu_data.x86_vendor != X86_VENDOR_AMD) )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_PERF_CTL:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_THERM_CONTROL:\n    case MSR_IA32_ENERGY_PERF_BIAS:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_AMD64_DR0_ADDRESS_MASK:\n        if ( !boot_cpu_has(X86_FEATURE_DBEXT) || (val >> 32) )\n            break;\n        curr->arch.pv_vcpu.dr_mask[0] = val;\n        if ( curr->arch.debugreg[7] & DR7_ACTIVE_MASK )\n            wrmsrl(MSR_AMD64_DR0_ADDRESS_MASK, val);\n        return X86EMUL_OKAY;\n\n    case MSR_AMD64_DR1_ADDRESS_MASK ... MSR_AMD64_DR3_ADDRESS_MASK:\n        if ( !boot_cpu_has(X86_FEATURE_DBEXT) || (val >> 32) )\n            break;\n        curr->arch.pv_vcpu.dr_mask[reg - MSR_AMD64_DR1_ADDRESS_MASK + 1] = val;\n        if ( curr->arch.debugreg[7] & DR7_ACTIVE_MASK )\n            wrmsrl(reg, val);\n        return X86EMUL_OKAY;\n\n    case MSR_INTEL_PLATFORM_INFO:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ||\n             val || rdmsr_safe(MSR_INTEL_PLATFORM_INFO, val) )\n            break;\n        return X86EMUL_OKAY;\n\n    case MSR_INTEL_MISC_FEATURES_ENABLES:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ||\n             (val & ~MSR_MISC_FEATURES_CPUID_FAULTING) ||\n             rdmsr_safe(MSR_INTEL_MISC_FEATURES_ENABLES, temp) )\n            break;\n        if ( (val & MSR_MISC_FEATURES_CPUID_FAULTING) &&\n             !this_cpu(cpuid_faulting_enabled) )\n            break;\n        curr->arch.cpuid_faulting = !!(val & MSR_MISC_FEATURES_CPUID_FAULTING);\n        return X86EMUL_OKAY;\n\n    case MSR_P6_PERFCTR(0)...MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0)...MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0...MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL...MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n    case MSR_AMD_FAM15H_EVNTSEL0...MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0...MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) )\n            {\n                if ( (vpmu_mode & XENPMU_MODE_ALL) &&\n                     !is_hardware_domain(currd) )\n                    return X86EMUL_OKAY;\n\n                if ( vpmu_do_wrmsr(reg, val, 0) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        if ( wrmsr_hypervisor_regs(reg, val) == 1 )\n            return X86EMUL_OKAY;\n\n        rc = vmce_wrmsr(reg, val);\n        if ( rc < 0 )\n            break;\n        if ( rc )\n            return X86EMUL_OKAY;\n\n        if ( (rdmsr_safe(reg, temp) != 0) || (val != temp) )\n    invalid:\n            gdprintk(XENLOG_WARNING,\n                     \""Domain attempted WRMSR %08x from 0x%016\""PRIx64\"" to 0x%016\""PRIx64\""\\n\"",\n                     reg, temp, val);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}"", ""target"": 0}]","[{""func_name"": ""arch_set_info_guest"", ""file_path"": ""xen/arch/x86/domain.c"", ""func_code"": ""int arch_set_info_guest(\n    struct vcpu *v, vcpu_guest_context_u c)\n{\n    struct domain *d = v->domain;\n    unsigned long cr3_gfn;\n    struct page_info *cr3_page;\n    unsigned long flags, cr4;\n    unsigned int i;\n    int rc = 0, compat;\n\n    /* The context is a compat-mode one if the target domain is compat-mode;\n     * we expect the tools to DTRT even in compat-mode callers. */\n    compat = is_pv_32bit_domain(d) || is_pvh_32bit_domain(d);\n\n#define c(fld) (compat ? (c.cmp->fld) : (c.nat->fld))\n    flags = c(flags);\n\n    if ( is_pv_domain(d) )\n    {\n        if ( !compat )\n        {\n            if ( !is_canonical_address(c.nat->user_regs.rip) ||\n                 !is_canonical_address(c.nat->user_regs.rsp) ||\n                 !is_canonical_address(c.nat->kernel_sp) ||\n                 (c.nat->ldt_ents && !is_canonical_address(c.nat->ldt_base)) ||\n                 !is_canonical_address(c.nat->fs_base) ||\n                 !is_canonical_address(c.nat->gs_base_kernel) ||\n                 !is_canonical_address(c.nat->gs_base_user) ||\n                 !is_canonical_address(c.nat->event_callback_eip) ||\n                 !is_canonical_address(c.nat->syscall_callback_eip) ||\n                 !is_canonical_address(c.nat->failsafe_callback_eip) )\n                return -EINVAL;\n\n            fixup_guest_stack_selector(d, c.nat->user_regs.ss);\n            fixup_guest_stack_selector(d, c.nat->kernel_ss);\n            fixup_guest_code_selector(d, c.nat->user_regs.cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.nat->trap_ctxt); i++ )\n            {\n                if ( !is_canonical_address(c.nat->trap_ctxt[i].address) )\n                    return -EINVAL;\n                fixup_guest_code_selector(d, c.nat->trap_ctxt[i].cs);\n            }\n\n            if ( !__addr_ok(c.nat->ldt_base) )\n                return -EINVAL;\n        }\n        else\n        {\n            fixup_guest_stack_selector(d, c.cmp->user_regs.ss);\n            fixup_guest_stack_selector(d, c.cmp->kernel_ss);\n            fixup_guest_code_selector(d, c.cmp->user_regs.cs);\n            fixup_guest_code_selector(d, c.cmp->event_callback_cs);\n            fixup_guest_code_selector(d, c.cmp->failsafe_callback_cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); i++ )\n                fixup_guest_code_selector(d, c.cmp->trap_ctxt[i].cs);\n        }\n\n        /* LDT safety checks. */\n        if ( ((c(ldt_base) & (PAGE_SIZE - 1)) != 0) ||\n             (c(ldt_ents) > 8192) )\n            return -EINVAL;\n    }\n    else if ( is_pvh_domain(d) )\n    {\n        if ( c(ctrlreg[0]) || c(ctrlreg[1]) || c(ctrlreg[2]) ||\n             c(ctrlreg[4]) || c(ctrlreg[5]) || c(ctrlreg[6]) ||\n             c(ctrlreg[7]) ||  c(ldt_base) || c(ldt_ents) ||\n             c(user_regs.cs) || c(user_regs.ss) || c(user_regs.es) ||\n             c(user_regs.ds) || c(user_regs.fs) || c(user_regs.gs) ||\n             c(kernel_ss) || c(kernel_sp) || c(gdt_ents) ||\n             (!compat && (c.nat->gs_base_kernel ||\n              c.nat->fs_base || c.nat->gs_base_user)) )\n            return -EINVAL;\n    }\n\n    v->fpu_initialised = !!(flags & VGCF_I387_VALID);\n\n    v->arch.flags &= ~TF_kernel_mode;\n    if ( (flags & VGCF_in_kernel) || has_hvm_container_domain(d)/*???*/ )\n        v->arch.flags |= TF_kernel_mode;\n\n    v->arch.vgc_flags = flags;\n\n    if ( flags & VGCF_I387_VALID )\n    {\n        memcpy(v->arch.fpu_ctxt, &c.nat->fpu_ctxt, sizeof(c.nat->fpu_ctxt));\n        if ( v->arch.xsave_area )\n            v->arch.xsave_area->xsave_hdr.xstate_bv = XSTATE_FP_SSE;\n    }\n    else if ( v->arch.xsave_area )\n    {\n        v->arch.xsave_area->xsave_hdr.xstate_bv = 0;\n        v->arch.xsave_area->fpu_sse.mxcsr = MXCSR_DEFAULT;\n    }\n    else\n    {\n        typeof(v->arch.xsave_area->fpu_sse) *fpu_sse = v->arch.fpu_ctxt;\n\n        memset(fpu_sse, 0, sizeof(*fpu_sse));\n        fpu_sse->fcw = FCW_DEFAULT;\n        fpu_sse->mxcsr = MXCSR_DEFAULT;\n    }\n    if ( v->arch.xsave_area )\n        v->arch.xsave_area->xsave_hdr.xcomp_bv = 0;\n\n    if ( !compat )\n    {\n        memcpy(&v->arch.user_regs, &c.nat->user_regs, sizeof(c.nat->user_regs));\n        if ( is_pv_domain(d) )\n            memcpy(v->arch.pv_vcpu.trap_ctxt, c.nat->trap_ctxt,\n                   sizeof(c.nat->trap_ctxt));\n    }\n    else\n    {\n        XLAT_cpu_user_regs(&v->arch.user_regs, &c.cmp->user_regs);\n        if ( is_pv_domain(d) )\n        {\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); ++i )\n                XLAT_trap_info(v->arch.pv_vcpu.trap_ctxt + i,\n                               c.cmp->trap_ctxt + i);\n        }\n    }\n\n    if ( has_hvm_container_domain(d) )\n    {\n        for ( i = 0; i < ARRAY_SIZE(v->arch.debugreg); ++i )\n            v->arch.debugreg[i] = c(debugreg[i]);\n\n        hvm_set_info_guest(v);\n\n        if ( is_hvm_domain(d) || v->is_initialised )\n            goto out;\n\n        /* NB: No need to use PV cr3 un-pickling macros */\n        cr3_gfn = c(ctrlreg[3]) >> PAGE_SHIFT;\n        cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n        v->arch.cr3 = page_to_maddr(cr3_page);\n        v->arch.hvm_vcpu.guest_cr[3] = c(ctrlreg[3]);\n        v->arch.guest_table = pagetable_from_page(cr3_page);\n\n        ASSERT(paging_mode_enabled(d));\n\n        goto pvh_skip_pv_stuff;\n    }\n\n    init_int80_direct_trap(v);\n\n    /* IOPL privileges are virtualised. */\n    v->arch.pv_vcpu.iopl = v->arch.user_regs.eflags & X86_EFLAGS_IOPL;\n    v->arch.user_regs.eflags &= ~X86_EFLAGS_IOPL;\n\n    /* Ensure real hardware interrupts are enabled. */\n    v->arch.user_regs.eflags |= X86_EFLAGS_IF;\n\n    if ( !v->is_initialised )\n    {\n        if ( !compat && !(flags & VGCF_in_kernel) && !c.nat->ctrlreg[1] )\n            return -EINVAL;\n\n        v->arch.pv_vcpu.ldt_base = c(ldt_base);\n        v->arch.pv_vcpu.ldt_ents = c(ldt_ents);\n    }\n    else\n    {\n        unsigned long pfn = pagetable_get_pfn(v->arch.guest_table);\n        bool_t fail;\n\n        if ( !compat )\n        {\n            fail = xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[3];\n            if ( pagetable_is_null(v->arch.guest_table_user) )\n                fail |= c.nat->ctrlreg[1] || !(flags & VGCF_in_kernel);\n            else\n            {\n                pfn = pagetable_get_pfn(v->arch.guest_table_user);\n                fail |= xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[1];\n            }\n        } else {\n            l4_pgentry_t *l4tab = map_domain_page(_mfn(pfn));\n\n            pfn = l4e_get_pfn(*l4tab);\n            unmap_domain_page(l4tab);\n            fail = compat_pfn_to_cr3(pfn) != c.cmp->ctrlreg[3];\n        }\n\n        for ( i = 0; i < ARRAY_SIZE(v->arch.pv_vcpu.gdt_frames); ++i )\n            fail |= v->arch.pv_vcpu.gdt_frames[i] != c(gdt_frames[i]);\n        fail |= v->arch.pv_vcpu.gdt_ents != c(gdt_ents);\n\n        fail |= v->arch.pv_vcpu.ldt_base != c(ldt_base);\n        fail |= v->arch.pv_vcpu.ldt_ents != c(ldt_ents);\n\n        if ( fail )\n           return -EOPNOTSUPP;\n    }\n\n    v->arch.pv_vcpu.kernel_ss = c(kernel_ss);\n    v->arch.pv_vcpu.kernel_sp = c(kernel_sp);\n    for ( i = 0; i < ARRAY_SIZE(v->arch.pv_vcpu.ctrlreg); ++i )\n        v->arch.pv_vcpu.ctrlreg[i] = c(ctrlreg[i]);\n\n    v->arch.pv_vcpu.event_callback_eip = c(event_callback_eip);\n    v->arch.pv_vcpu.failsafe_callback_eip = c(failsafe_callback_eip);\n    if ( !compat )\n    {\n        v->arch.pv_vcpu.syscall_callback_eip = c.nat->syscall_callback_eip;\n        v->arch.pv_vcpu.fs_base = c.nat->fs_base;\n        v->arch.pv_vcpu.gs_base_kernel = c.nat->gs_base_kernel;\n        v->arch.pv_vcpu.gs_base_user = c.nat->gs_base_user;\n    }\n    else\n    {\n        v->arch.pv_vcpu.event_callback_cs = c(event_callback_cs);\n        v->arch.pv_vcpu.failsafe_callback_cs = c(failsafe_callback_cs);\n    }\n\n    /* Only CR0.TS is modifiable by guest or admin. */\n    v->arch.pv_vcpu.ctrlreg[0] &= X86_CR0_TS;\n    v->arch.pv_vcpu.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;\n\n    cr4 = v->arch.pv_vcpu.ctrlreg[4];\n    v->arch.pv_vcpu.ctrlreg[4] = cr4 ? pv_guest_cr4_fixup(v, cr4) :\n        real_cr4_to_pv_guest_cr4(mmu_cr4_features);\n\n    memset(v->arch.debugreg, 0, sizeof(v->arch.debugreg));\n    for ( i = 0; i < 8; i++ )\n        (void)set_debugreg(v, i, c(debugreg[i]));\n\n    if ( v->is_initialised )\n        goto out;\n\n    if ( v->vcpu_id == 0 )\n    {\n        /*\n         * In the restore case we need to deal with L4 pages which got\n         * initialized with m2p_strict still clear (and which hence lack the\n         * correct initial RO_MPT_VIRT_{START,END} L4 entry).\n         */\n        if ( d != current->domain && !VM_ASSIST(d, m2p_strict) &&\n             is_pv_domain(d) && !is_pv_32bit_domain(d) &&\n             test_bit(VMASST_TYPE_m2p_strict, &c.nat->vm_assist) &&\n             atomic_read(&d->arch.pv_domain.nr_l4_pages) )\n        {\n            bool_t done = 0;\n\n            spin_lock_recursive(&d->page_alloc_lock);\n\n            for ( i = 0; ; )\n            {\n                struct page_info *page = page_list_remove_head(&d->page_list);\n\n                if ( page_lock(page) )\n                {\n                    if ( (page->u.inuse.type_info & PGT_type_mask) ==\n                         PGT_l4_page_table )\n                        done = !fill_ro_mpt(page_to_mfn(page));\n\n                    page_unlock(page);\n                }\n\n                page_list_add_tail(page, &d->page_list);\n\n                if ( done || (!(++i & 0xff) && hypercall_preempt_check()) )\n                    break;\n            }\n\n            spin_unlock_recursive(&d->page_alloc_lock);\n\n            if ( !done )\n                return -ERESTART;\n        }\n\n        d->vm_assist = c(vm_assist);\n    }\n\n    rc = put_old_guest_table(current);\n    if ( rc )\n        return rc;\n\n    if ( !compat )\n        rc = (int)set_gdt(v, c.nat->gdt_frames, c.nat->gdt_ents);\n    else\n    {\n        unsigned long gdt_frames[ARRAY_SIZE(v->arch.pv_vcpu.gdt_frames)];\n        unsigned int n = (c.cmp->gdt_ents + 511) / 512;\n\n        if ( n > ARRAY_SIZE(v->arch.pv_vcpu.gdt_frames) )\n            return -EINVAL;\n        for ( i = 0; i < n; ++i )\n            gdt_frames[i] = c.cmp->gdt_frames[i];\n        rc = (int)set_gdt(v, gdt_frames, c.cmp->gdt_ents);\n    }\n    if ( rc != 0 )\n        return rc;\n\n    set_bit(_VPF_in_reset, &v->pause_flags);\n\n    if ( !compat )\n        cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[3]);\n    else\n        cr3_gfn = compat_cr3_to_pfn(c.cmp->ctrlreg[3]);\n    cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n    if ( !cr3_page )\n        rc = -EINVAL;\n    else if ( paging_mode_refcounts(d) )\n        /* nothing */;\n    else if ( cr3_page == v->arch.old_guest_table )\n    {\n        v->arch.old_guest_table = NULL;\n        put_page(cr3_page);\n    }\n    else\n    {\n        if ( !compat )\n            rc = put_old_guest_table(v);\n        if ( !rc )\n            rc = get_page_type_preemptible(cr3_page,\n                                           !compat ? PGT_root_page_table\n                                                   : PGT_l3_page_table);\n        switch ( rc )\n        {\n        case -EINTR:\n            rc = -ERESTART;\n        case -ERESTART:\n            break;\n        case 0:\n            if ( !compat && !VM_ASSIST(d, m2p_strict) &&\n                 !paging_mode_refcounts(d) )\n                fill_ro_mpt(cr3_gfn);\n            break;\n        default:\n            if ( cr3_page == current->arch.old_guest_table )\n                cr3_page = NULL;\n            break;\n        }\n    }\n    if ( rc )\n        /* handled below */;\n    else if ( !compat )\n    {\n        v->arch.guest_table = pagetable_from_page(cr3_page);\n        if ( c.nat->ctrlreg[1] )\n        {\n            cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[1]);\n            cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n            if ( !cr3_page )\n                rc = -EINVAL;\n            else if ( !paging_mode_refcounts(d) )\n            {\n                rc = get_page_type_preemptible(cr3_page, PGT_root_page_table);\n                switch ( rc )\n                {\n                case -EINTR:\n                    rc = -ERESTART;\n                    /* Fallthrough */\n                case -ERESTART:\n                    v->arch.old_guest_table =\n                        pagetable_get_page(v->arch.guest_table);\n                    v->arch.guest_table = pagetable_null();\n                    break;\n                default:\n                    if ( cr3_page == current->arch.old_guest_table )\n                        cr3_page = NULL;\n                    break;\n                case 0:\n                    if ( VM_ASSIST(d, m2p_strict) )\n                        zap_ro_mpt(cr3_gfn);\n                    break;\n                }\n            }\n            if ( !rc )\n               v->arch.guest_table_user = pagetable_from_page(cr3_page);\n        }\n    }\n    else\n    {\n        l4_pgentry_t *l4tab;\n\n        l4tab = map_domain_page(_mfn(pagetable_get_pfn(v->arch.guest_table)));\n        *l4tab = l4e_from_pfn(page_to_mfn(cr3_page),\n            _PAGE_PRESENT|_PAGE_RW|_PAGE_USER|_PAGE_ACCESSED);\n        unmap_domain_page(l4tab);\n    }\n    if ( rc )\n    {\n        if ( cr3_page )\n            put_page(cr3_page);\n        destroy_gdt(v);\n        return rc;\n    }\n\n    clear_bit(_VPF_in_reset, &v->pause_flags);\n\n pvh_skip_pv_stuff:\n    if ( v->vcpu_id == 0 )\n        update_domain_wallclock_time(d);\n\n    /* Don't redo final setup */\n    v->is_initialised = 1;\n\n    if ( paging_mode_enabled(d) )\n        paging_update_paging_modes(v);\n\n    update_cr3(v);\n\n out:\n    if ( flags & VGCF_online )\n        clear_bit(_VPF_down, &v->pause_flags);\n    else\n        set_bit(_VPF_down, &v->pause_flags);\n    return 0;\n#undef c\n}""}, {""func_name"": ""priv_op_write_msr"", ""file_path"": ""xen/arch/x86/traps.c"", ""func_code"": ""static int priv_op_write_msr(unsigned int reg, uint64_t val,\n                             struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n\n    switch ( reg )\n    {\n        uint64_t temp;\n        int rc;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrfsbase(val);\n        curr->arch.pv_vcpu.fs_base = val;\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrgsbase(val);\n        curr->arch.pv_vcpu.gs_base_kernel = val;\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) ||\n             wrmsr_safe(MSR_SHADOW_GS_BASE, val) )\n            break;\n        curr->arch.pv_vcpu.gs_base_user = val;\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n    case MSR_K8_HWCR:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_AMD64_NB_CFG:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 > 0x17 )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( (rdmsr_safe(MSR_AMD64_NB_CFG, temp) != 0) ||\n             ((val ^ temp) & ~(1ULL << AMD64_NB_CFG_CF8_EXT_ENABLE_BIT)) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_AMD64_NB_CFG, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_FAM10H_MMIO_CONF_BASE:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 > 0x17 )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( rdmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, temp) != 0 )\n            break;\n        if ( (pci_probe & PCI_PROBE_MASK) == PCI_PROBE_MMCONF ?\n             temp != val :\n             ((temp ^ val) &\n              ~(FAM10H_MMIO_CONF_ENABLE |\n                (FAM10H_MMIO_CONF_BUSRANGE_MASK <<\n                 FAM10H_MMIO_CONF_BUSRANGE_SHIFT) |\n                ((u64)FAM10H_MMIO_CONF_BASE_MASK <<\n                 FAM10H_MMIO_CONF_BASE_SHIFT))) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_UCODE_REV:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( rdmsr_safe(reg, temp) )\n            break;\n        if ( val )\n            goto invalid;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MISC_ENABLE:\n        if ( rdmsr_safe(reg, temp) )\n            break;\n        if ( val != guest_misc_enable(temp) )\n            goto invalid;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MPERF:\n    case MSR_IA32_APERF:\n        if ( (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL) &&\n             (boot_cpu_data.x86_vendor != X86_VENDOR_AMD) )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_PERF_CTL:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_THERM_CONTROL:\n    case MSR_IA32_ENERGY_PERF_BIAS:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_AMD64_DR0_ADDRESS_MASK:\n        if ( !boot_cpu_has(X86_FEATURE_DBEXT) || (val >> 32) )\n            break;\n        curr->arch.pv_vcpu.dr_mask[0] = val;\n        if ( curr->arch.debugreg[7] & DR7_ACTIVE_MASK )\n            wrmsrl(MSR_AMD64_DR0_ADDRESS_MASK, val);\n        return X86EMUL_OKAY;\n\n    case MSR_AMD64_DR1_ADDRESS_MASK ... MSR_AMD64_DR3_ADDRESS_MASK:\n        if ( !boot_cpu_has(X86_FEATURE_DBEXT) || (val >> 32) )\n            break;\n        curr->arch.pv_vcpu.dr_mask[reg - MSR_AMD64_DR1_ADDRESS_MASK + 1] = val;\n        if ( curr->arch.debugreg[7] & DR7_ACTIVE_MASK )\n            wrmsrl(reg, val);\n        return X86EMUL_OKAY;\n\n    case MSR_INTEL_PLATFORM_INFO:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ||\n             val || rdmsr_safe(MSR_INTEL_PLATFORM_INFO, val) )\n            break;\n        return X86EMUL_OKAY;\n\n    case MSR_INTEL_MISC_FEATURES_ENABLES:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ||\n             (val & ~MSR_MISC_FEATURES_CPUID_FAULTING) ||\n             rdmsr_safe(MSR_INTEL_MISC_FEATURES_ENABLES, temp) )\n            break;\n        if ( (val & MSR_MISC_FEATURES_CPUID_FAULTING) &&\n             !this_cpu(cpuid_faulting_enabled) )\n            break;\n        curr->arch.cpuid_faulting = !!(val & MSR_MISC_FEATURES_CPUID_FAULTING);\n        return X86EMUL_OKAY;\n\n    case MSR_P6_PERFCTR(0)...MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0)...MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0...MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL...MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n    case MSR_AMD_FAM15H_EVNTSEL0...MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0...MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) )\n            {\n                if ( (vpmu_mode & XENPMU_MODE_ALL) &&\n                     !is_hardware_domain(currd) )\n                    return X86EMUL_OKAY;\n\n                if ( vpmu_do_wrmsr(reg, val, 0) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        if ( wrmsr_hypervisor_regs(reg, val) == 1 )\n            return X86EMUL_OKAY;\n\n        rc = vmce_wrmsr(reg, val);\n        if ( rc < 0 )\n            break;\n        if ( rc )\n            return X86EMUL_OKAY;\n\n        if ( (rdmsr_safe(reg, temp) != 0) || (val != temp) )\n    invalid:\n            gdprintk(XENLOG_WARNING,\n                     \""Domain attempted WRMSR %08x from 0x%016\""PRIx64\"" to 0x%016\""PRIx64\""\\n\"",\n                     reg, temp, val);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}""}]","{""caller"": 2, ""value"": 2}","[{""source"": ""caller_info(file:domain.c, func:arch_set_info_guest)"", ""result"": [{""call_line"": 80, ""call_code"": ""arch_set_info_guest(v, ctxt)"", ""caller_code"": ""static int do_common_cpu_on(register_t target_cpu, register_t entry_point,\n                       register_t context_id,int ver)\n{\n    struct vcpu *v;\n    struct domain *d = current->domain;\n    struct vcpu_guest_context *ctxt;\n    int rc;\n    int is_thumb = entry_point & 1;\n    register_t vcpuid;\n\n    vcpuid = vaffinity_to_vcpuid(target_cpu);\n\n    if ( vcpuid >= d->max_vcpus || (v = d->vcpu[vcpuid]) == NULL )\n        return PSCI_INVALID_PARAMETERS;\n\n    /* THUMB set is not allowed with 64-bit domain */\n    if ( is_64bit_domain(d) && is_thumb )\n        return PSCI_INVALID_PARAMETERS;\n\n    if ( (ver == PSCI_VERSION(0, 2)) &&\n            !test_bit(_VPF_down, &v->pause_flags) )\n        return PSCI_ALREADY_ON;\n\n    if ( (ctxt = alloc_vcpu_guest_context()) == NULL )\n        return PSCI_DENIED;\n\n    vgic_clear_pending_irqs(v);\n\n    memset(ctxt, 0, sizeof(*ctxt));\n    ctxt->user_regs.pc64 = (u64) entry_point;\n    ctxt->sctlr = SCTLR_GUEST_INIT;\n    ctxt->ttbr0 = 0;\n    ctxt->ttbr1 = 0;\n   ..."", ""caller_start"": 25, ""file_path"": ""xen/arch/arm/vpsci.c""}]}, {""source"": ""caller_info(file:traps.c, func:priv_op_write_msr)"", ""result"": [{""call_line"": 3221, ""call_code"": ""priv_op_write_msr(regs->_ecx, (regs->rdx << 32) | regs->_eax,\n                               NULL)"", ""caller_code"": ""static int emulate_privileged_op(struct cpu_user_regs *regs)\n{\n    struct vcpu *v = current;\n    struct domain *currd = v->domain;\n    unsigned long *reg, eip = regs->eip;\n    u8 opcode, modrm_reg = 0, modrm_rm = 0, rep_prefix = 0, lock = 0, rex = 0;\n    enum { lm_seg_none, lm_seg_fs, lm_seg_gs } lm_ovr = lm_seg_none;\n    int rc;\n    unsigned int port, i, data_sel, ar, data, bpmatch = 0;\n    unsigned int op_bytes, op_default, ad_bytes, ad_default, opsize_prefix= 0;\n#define rd_ad(reg) (ad_bytes >= sizeof(regs->reg) \\\n                    ? regs->reg \\\n                    : ad_bytes == 4 \\\n                      ? (u32)regs->reg \\\n                      : (u16)regs->reg)\n#define wr_ad(reg, val) (ad_bytes >= sizeof(regs->reg) \\\n                         ? regs->reg = (val) \\\n                         : ad_bytes == 4 \\\n                           ? (*(u32 *)&regs->reg = (val)) \\\n                           : (*(u16 *)&regs->reg = (val)))\n    unsigned long code_base, code_limit;\n    char *io_em..."", ""caller_start"": 2796, ""file_path"": ""xen/arch/x86/traps.c""}]}, {""source"": ""value_info(file:domain.c, value:c.nat)"", ""result"": {""value_trace"": [{""full_code"": ""c.nat->flags = v->arch.vgc_flags & ~(VGCF_i387_valid | VGCF_in_kernel)"", ""line"": 1460, ""func_name"": ""arch_get_info_guest<duplicate>0""}, {""full_code"": ""c.nat->flags |= VGCF_i387_valid"", ""line"": 1462, ""func_name"": ""arch_get_info_guest<duplicate>0""}], ""struct_var"": ""c"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:traps.c, value:val)"", ""result"": {""value_trace"": [{""full_code"": ""val &= ~(MSR_IA32_MISC_ENABLE_PERF_AVAIL |\n             MSR_IA32_MISC_ENABLE_MONITOR_ENABLE)"", ""line"": 2394, ""func_name"": ""guest_misc_enable""}, {""full_code"": ""val |= MSR_IA32_MISC_ENABLE_BTS_UNAVAIL |\n           MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL |\n           MSR_IA32_MISC_ENABLE_XTPR_DISABLE"", ""line"": 2396, ""func_name"": ""guest_misc_enable""}, {""full_code"": ""val = rdtsc()"", ""line"": 3234, ""func_name"": ""emulate_privileged_op""}], ""struct_var"": ""val"", ""struct_type"": ""uint64_t"", ""struct_definition"": ""typedef unsigned long long uint64_t;\n\ntypedef unsigned long long  uint64_t __attribute__((aligned (8)));\n\ntypedef unsigned long       uint64_t;\n\ntypedef unsigned long long  uint64_t __attribute__((aligned (8)));\n\ntypedef unsigned long long  uint64_t __attribute__((aligned (8)));\n\ntypedef unsigned long       uint64_t;\n\ntypedef unsigned long long  uint64_t __attribute__((aligned (8)));\n\ntypedef unsigned long long uint64_t;\n\ntypedef         __u64           uint64_t;""}}]","The vulnerability was caused by unvalidated guest inputs in two paths:\n1. In `priv_op_write_msr` (traps.c:3221), the `val` parameter (from `regs->rdx` and `regs->_eax`) was written to FS/GS base MSRs without canonical checks, leading to #GP exceptions. The patch added `!is_canonical_address(val)` checks (traps.c:2566) to prevent this.\n2. In `arch_set_info_guest` (domain.c:761), guest-provided `c.nat` fields (`fs_base`, `gs_base`) were stored without canonical checks, risking invalid values during later context switches. The patch added `!is_canonical_address(c.nat->fs_base)` checks to block this.",1.0,./github/other_context/CVE-2016-9385
17,CVE-2017-1000201,CWE-20,c_cpp,The tcmu-runner daemon in tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a local denial of service attack,https://github.com/open-iscsi/tcmu-runner/commit/e2d953050766ac538615a811c64b34358614edce,fixed local DoS when UnregisterHandler was called for a not existing handler\n\nAny user with DBUS access could cause a SEGFAULT in tcmu-runner by\nrunning something like this:\n\ndbus-send --system --print-reply --dest=org.kernel.TCMUService1 /org/kernel/TCMUService1/HandlerManager1 org.kernel.TCMUService1.HandlerManager1.UnregisterHandler string:123,1,"[{""func_name"": ""on_unregister_handler"", ""file_path"": ""main.c"", ""func_code"": ""static gboolean\non_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler->opaque;\n\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\""(bs)\"", FALSE,\n\t\t\t\t      \""unknown subtype\""));\n\t\treturn TRUE;\n\t}\n\tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n\tg_bus_unwatch_name(info->watcher_id);\n\tg_free(info);\n\tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\""(bs)\"", TRUE, \""succeeded\""));\n\treturn TRUE;\n}"", ""target"": 0}]","[{""func_name"": ""on_unregister_handler"", ""file_path"": ""main.c"", ""func_code"": ""static gboolean\non_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler ? handler->opaque : NULL;\n\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\""(bs)\"", FALSE,\n\t\t\t\t      \""unknown subtype\""));\n\t\treturn TRUE;\n\t}\n\tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n\tg_bus_unwatch_name(info->watcher_id);\n\tg_free(info);\n\tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\""(bs)\"", TRUE, \""succeeded\""));\n\treturn TRUE;\n}""}]","{""function"": 1}","[{""source"": ""func_info(file:main.c, func:find_handler_by_subtype)"", ""result"": [{""code"": ""static struct tcmur_handler *find_handler_by_subtype(gchar *subtype)\n{\n\tstruct tcmur_handler **handler;\n\n\tdarray_foreach(handler, g_runner_handlers) {\n\t\tif (strcmp((*handler)->subtype, subtype) == 0)\n\t\t\treturn *handler;\n\t}\n\treturn NULL;\n}"", ""start_line"": 65, ""end_line"": 74, ""full_name"": ""find_handler_by_subtype"", ""file_path"": ""main.c""}]}]","main.c:387: 'handler' is assigned via 'find_handler_by_subtype(subtype)' (called from 'on_unregister_handler'). If 'find_handler_by_subtype' (main.c:65-74) returns NULL (no handler found), the original code dereferences 'handler->opaque', causing a NULL pointer dereference (SEGFAULT). Patch adds a null check to prevent this.",0.95,./github/other_context/CVE-2017-1000201
18,CVE-2017-12670,"CWE-20, CWE-617",c_cpp,"In ImageMagick 7.0.6-3, missing validation was found in coders/mat.c, leading to an assertion failure in the function DestroyImage in MagickCore/image.c, which allows attackers to cause a denial of service.",https://github.com/ImageMagick/ImageMagick/commit/ab440f9ea11e0dbefb7a808cbb9441198758b0cb,https://github.com/ImageMagick/ImageMagick/issues/610,1,"[{""func_name"": ""ReadMATImage"", ""file_path"": ""coders/mat.c"", ""func_code"": ""static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\""enter\"");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  if (strncmp(MATLAB_HDR.identific,\""MATLAB\"",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""  Endian %c%c\"",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \""IM\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \""MI\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \""MATLAB\"", 6))\n    {\nMATLAB_KO:\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\""pos=%X\\n\"",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n         break;\n      default: ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""MATLAB_HDR.StructureClass %d\"",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\""UnsupportedCellTypeInTheMatrix\"");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \""MATLAB_HDR.CellType: %.20g\"",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\""quantum:format\"",\""floating-point\"");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\""quantum:format\"",\""floating-point\"");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \""IncompatibleSizeOfDouble\"");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \""UnsupportedCellTypeInTheMatrix\"");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  MAT set image pixels returns unexpected NULL on a row %u.\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \""  MAT cannot read scanrow %u from a file.\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  MAT failed to ImportQuantumPixels for a row %u\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""  MAT failed to sync image pixels for a row %u\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""return\"");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  return (image);\n}"", ""target"": 0}]","[{""func_name"": ""ReadMATImage"", ""file_path"": ""coders/mat.c"", ""func_code"": ""static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\""enter\"");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  if (strncmp(MATLAB_HDR.identific,\""MATLAB\"",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""  Endian %c%c\"",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \""IM\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \""MI\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \""MATLAB\"", 6))\n    {\nMATLAB_KO:\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\""pos=%X\\n\"",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n         break;\n      default: ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""MATLAB_HDR.StructureClass %d\"",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\""UnsupportedCellTypeInTheMatrix\"");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \""MATLAB_HDR.CellType: %.20g\"",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\""quantum:format\"",\""floating-point\"");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\""quantum:format\"",\""floating-point\"");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \""IncompatibleSizeOfDouble\"");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \""UnsupportedCellTypeInTheMatrix\"");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  MAT set image pixels returns unexpected NULL on a row %u.\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \""  MAT cannot read scanrow %u from a file.\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  MAT failed to ImportQuantumPixels for a row %u\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""  MAT failed to sync image pixels for a row %u\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""return\"");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}""}]","{""code"": 4, ""value"": 3, ""function"": 2}","[{""source"": ""code_info(file:mat.c, lines:1350-1370)"", ""result"": ""    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""return\"");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  return (image);\n}\n""}, {""source"": ""value_info(file:mat.c, value:image2)"", ""result"": {""value_trace"": [{""full_code"": ""*image2=NULL"", ""line"": 851, ""func_name"": ""ReadMATImage""}, {""full_code"": ""image2=ReadMATImageV4(image_info,image,exception)"", ""line"": 906, ""func_name"": ""ReadMATImage""}, {""full_code"": ""image2 = image"", ""line"": 961, ""func_name"": ""ReadMATImage""}, {""full_code"": ""image2=DestroyImage(image2)"", ""line"": 1103, ""func_name"": ""ReadMATImage""}, {""full_code"": ""image2 = NULL"", ""line"": 1247, ""func_name"": ""ReadMATImage""}], ""struct_var"": ""image2"", ""struct_type"": ""Image*"", ""struct_definition"": ""Magick.Image.Image:ANY(void)\n\nMagick.Image.Image:ANY(Magick.Blob&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t,std.string&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,std.string&)\n\nMagick.Image.Image:ANY(Magick.Geometry&,Magick.Color&)\n\nMagick.Image.Image:ANY(Magick.Image&)\n\nMagick.Image.Image:ANY(Magick.Image&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(size_t,size_t,std.string&,StorageType,void*)\n\nMagick.Image.Image:ANY(std.string&)\n\nMagick.Image.Image:ANY(MagickCore.Image*)\n\nclass Image\n\nclass MagickPPExport Image\n\nclass MagickPPExport Image\n  {\n  public:\n\n    // Obtain image statistics. Statistics are normalized to the range\n    // of 0.0 to 1.0 and are output to the specified ImageStatistics\n    // structure.\n    typedef struct _ImageChannelStatistics\n    {\n      /* Minimum value observed */\n      double maximum;\n      /* Maximum value observed */\n      double minimum;\n      /* Average (mean) value observed */\n      double mean;\n      /* Standard deviation, sqrt(variance) */\n      double standard_deviation;\n      /* Variance */\n      double variance;\n      /* Kurtosis */\n      double kurtosis;\n      /* Skewness */\n      double skewness;\n    } ImageChannelStatistics;\n\n    typedef struct _ImageStatistics\n    {\n      ImageChannelStatistics red;\n      ImageChannelStatistics green;\n      ImageChannelStatistics blue;\n      ImageChannelStatistics opacity;\n    } ImageStatistics;\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n  ...\n\nfriend class Image\n\nclass Image\n\nfriend class Image\n\ntypedef struct _Image Image;""}}, {""source"": ""code_info(file:mat.c, lines:800-950)"", ""result"": ""    /*\n      Allocate next image structure.\n    */\n    AcquireNextImage(image_info,image);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A T L A B i m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMATImage() reads an MAT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMATImage method is:\n%\n%      Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadMATImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\""enter\"");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  if (strncmp(MATLAB_HDR.identific,\""MATLAB\"",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""  Endian %c%c\"",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \""IM\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \""MI\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \""MATLAB\"", 6))\n    {\nMATLAB_KO:\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\""pos=%X\\n\"",TellBlob(image)); */\n\n""}, {""source"": ""value_info(file:mat.c, value:image)"", ""result"": {""value_trace"": [{""full_code"": ""image=DestroyImage(image)"", ""line"": 785, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=rotate_image"", ""line"": 786, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=DestroyImageList(image)"", ""line"": 806, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=SyncNextImageInList(image)"", ""line"": 809, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image = AcquireImage(image_info)"", ""line"": 890, ""func_name"": ""ReadMATImage""}], ""struct_var"": ""image"", ""struct_type"": ""Image*"", ""struct_definition"": ""Magick.Image.Image:ANY(void)\n\nMagick.Image.Image:ANY(Magick.Blob&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t,std.string&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,std.string&)\n\nMagick.Image.Image:ANY(Magick.Geometry&,Magick.Color&)\n\nMagick.Image.Image:ANY(Magick.Image&)\n\nMagick.Image.Image:ANY(Magick.Image&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(size_t,size_t,std.string&,StorageType,void*)\n\nMagick.Image.Image:ANY(std.string&)\n\nMagick.Image.Image:ANY(MagickCore.Image*)\n\nclass Image\n\nclass MagickPPExport Image\n\nclass MagickPPExport Image\n  {\n  public:\n\n    // Obtain image statistics. Statistics are normalized to the range\n    // of 0.0 to 1.0 and are output to the specified ImageStatistics\n    // structure.\n    typedef struct _ImageChannelStatistics\n    {\n      /* Minimum value observed */\n      double maximum;\n      /* Maximum value observed */\n      double minimum;\n      /* Average (mean) value observed */\n      double mean;\n      /* Standard deviation, sqrt(variance) */\n      double standard_deviation;\n      /* Variance */\n      double variance;\n      /* Kurtosis */\n      double kurtosis;\n      /* Skewness */\n      double skewness;\n    } ImageChannelStatistics;\n\n    typedef struct _ImageStatistics\n    {\n      ImageChannelStatistics red;\n      ImageChannelStatistics green;\n      ImageChannelStatistics blue;\n      ImageChannelStatistics opacity;\n    } ImageStatistics;\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n  ...\n\nfriend class Image\n\nclass Image\n\nfriend class Image\n\ntypedef struct _Image Image;""}}, {""source"": ""func_info(file:mat.c, func:ReadMATImageV4)"", ""result"": [{""code"": ""static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotate_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n      Object parser.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      break;\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n   ..."", ""start_line"": 592, ""end_line"": 817, ""full_name"": ""ReadMATImageV4"", ""file_path"": ""coders/mat.c""}]}, {""source"": ""code_info(file:mat.c, lines:750-850)"", ""result"": ""        exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(q,image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(unsigned char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow((double *) pixels,y,image,0,0);\n        else\n          InsertComplexFloatRow((float *) pixels,y,image,0,0);\n      }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\n    AcquireNextImage(image_info,image);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A T L A B i m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMATImage() reads an MAT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMATImage method is:\n%\n%      Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadMATImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n""}, {""source"": ""value_info(file:mat.c, value:image)"", ""result"": {""value_trace"": [{""full_code"": ""image=DestroyImage(image)"", ""line"": 785, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=rotate_image"", ""line"": 786, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=DestroyImageList(image)"", ""line"": 806, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=SyncNextImageInList(image)"", ""line"": 809, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image = AcquireImage(image_info)"", ""line"": 890, ""func_name"": ""ReadMATImage""}], ""struct_var"": ""image"", ""struct_type"": ""Image*"", ""struct_definition"": ""Magick.Image.Image:ANY(void)\n\nMagick.Image.Image:ANY(Magick.Blob&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t,std.string&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,std.string&)\n\nMagick.Image.Image:ANY(Magick.Geometry&,Magick.Color&)\n\nMagick.Image.Image:ANY(Magick.Image&)\n\nMagick.Image.Image:ANY(Magick.Image&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(size_t,size_t,std.string&,StorageType,void*)\n\nMagick.Image.Image:ANY(std.string&)\n\nMagick.Image.Image:ANY(MagickCore.Image*)\n\nclass Image\n\nclass MagickPPExport Image\n\nclass MagickPPExport Image\n  {\n  public:\n\n    // Obtain image statistics. Statistics are normalized to the range\n    // of 0.0 to 1.0 and are output to the specified ImageStatistics\n    // structure.\n    typedef struct _ImageChannelStatistics\n    {\n      /* Minimum value observed */\n      double maximum;\n      /* Maximum value observed */\n      double minimum;\n      /* Average (mean) value observed */\n      double mean;\n      /* Standard deviation, sqrt(variance) */\n      double standard_deviation;\n      /* Variance */\n      double variance;\n      /* Kurtosis */\n      double kurtosis;\n      /* Skewness */\n      double skewness;\n    } ImageChannelStatistics;\n\n    typedef struct _ImageStatistics\n    {\n      ImageChannelStatistics red;\n      ImageChannelStatistics green;\n      ImageChannelStatistics blue;\n      ImageChannelStatistics opacity;\n    } ImageStatistics;\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n  ...\n\nfriend class Image\n\nclass Image\n\nfriend class Image\n\ntypedef struct _Image Image;""}}, {""source"": ""code_info(file:mat.c, lines:700-750)"", ""result"": ""    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      return((Image *) NULL);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return((Image *) NULL);\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register PixelPacket\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(unsigned char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (PixelPacket *) NULL)\n""}, {""source"": ""func_info(file:mat.c, func:ReadMATImageV4)"", ""result"": [{""code"": ""static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotate_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n      Object parser.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      break;\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n   ..."", ""start_line"": 592, ""end_line"": 817, ""full_name"": ""ReadMATImageV4"", ""file_path"": ""coders/mat.c""}]}]","In `coders/mat.c:1364-1369`, `image2` is destroyed unconditionally before checking if `image` is NULL. If `image` becomes NULL (e.g., due to an error in `ReadMATImageV4`), `DestroyImage(image2)` may be called on an invalid or already-freed resource, triggering an assertion in `DestroyImage`. The patch moves the destruction of `image2` under an `else` block tied to `image != NULL`, ensuring it is only destroyed when `image` is valid. The root cause is the missing validation of `image` before destroying `image2`.",0.95,./github/other_context/CVE-2017-12670
19,CVE-2017-15591,CWE-20,c_cpp,An issue was discovered in Xen 4.5.x through 4.9.x allowing attackers (who control a stub domain kernel or tool stack) to cause a denial of service (host OS crash) because of a missing comparison (of range start to range end) within the DMOP map/unmap implementation.,https://github.com/xen-project/xen/commit/d59e55b018cfb79d0c4f794041aff4fe1cd0d570,"x86/ioreq server: correctly handle bogus XEN_DMOP_{,un}map_io_range_to_ioreq_server arguments\n\nMisbehaving device model can pass incorrect XEN_DMOP_map/\nunmap_io_range_to_ioreq_server arguments, namely end < start when\nspecifying address range. When this happens we hit ASSERT(s <= e) in\nrangeset_contains_range()/rangeset_overlaps_range() with debug builds.\nProduction builds will not trap right away but may misbehave later\nwhile handling such bogus ranges.\n\nThis is XSA-238.\n\nSigned-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>\nReviewed-by: Jan Beulich <jbeulich@suse.com>",2,"[{""func_name"": ""hvm_map_io_range_to_ioreq_server"", ""file_path"": ""xen/arch/x86/hvm/ioreq.c"", ""func_code"": ""int hvm_map_io_range_to_ioreq_server(struct domain *d, ioservid_t id,\n                                     uint32_t type, uint64_t start,\n                                     uint64_t end)\n{\n    struct hvm_ioreq_server *s;\n    int rc;\n\n    spin_lock_recursive(&d->arch.hvm_domain.ioreq_server.lock);\n\n    rc = -ENOENT;\n    list_for_each_entry ( s,\n                          &d->arch.hvm_domain.ioreq_server.list,\n                          list_entry )\n    {\n        if ( s == d->arch.hvm_domain.default_ioreq_server )\n            continue;\n\n        if ( s->id == id )\n        {\n            struct rangeset *r;\n\n            switch ( type )\n            {\n            case XEN_DMOP_IO_RANGE_PORT:\n            case XEN_DMOP_IO_RANGE_MEMORY:\n            case XEN_DMOP_IO_RANGE_PCI:\n                r = s->range[type];\n                break;\n\n            default:\n                r = NULL;\n                break;\n            }\n\n            rc = -EINVAL;\n            if ( !r )\n                break;\n\n            rc = -EEXIST;\n            if ( rangeset_overlaps_range(r, start, end) )\n                break;\n\n            rc = rangeset_add_range(r, start, end);\n            break;\n        }\n    }\n\n    spin_unlock_recursive(&d->arch.hvm_domain.ioreq_server.lock);\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""hvm_unmap_io_range_from_ioreq_server"", ""file_path"": ""xen/arch/x86/hvm/ioreq.c"", ""func_code"": ""int hvm_unmap_io_range_from_ioreq_server(struct domain *d, ioservid_t id,\n                                         uint32_t type, uint64_t start,\n                                         uint64_t end)\n{\n    struct hvm_ioreq_server *s;\n    int rc;\n\n    spin_lock_recursive(&d->arch.hvm_domain.ioreq_server.lock);\n\n    rc = -ENOENT;\n    list_for_each_entry ( s,\n                          &d->arch.hvm_domain.ioreq_server.list,\n                          list_entry )\n    {\n        if ( s == d->arch.hvm_domain.default_ioreq_server )\n            continue;\n\n        if ( s->id == id )\n        {\n            struct rangeset *r;\n\n            switch ( type )\n            {\n            case XEN_DMOP_IO_RANGE_PORT:\n            case XEN_DMOP_IO_RANGE_MEMORY:\n            case XEN_DMOP_IO_RANGE_PCI:\n                r = s->range[type];\n                break;\n\n            default:\n                r = NULL;\n                break;\n            }\n\n            rc = -EINVAL;\n            if ( !r )\n                break;\n\n            rc = -ENOENT;\n            if ( !rangeset_contains_range(r, start, end) )\n                break;\n\n            rc = rangeset_remove_range(r, start, end);\n            break;\n        }\n    }\n\n    spin_unlock_recursive(&d->arch.hvm_domain.ioreq_server.lock);\n\n    return rc;\n}"", ""target"": 0}]","[{""func_name"": ""hvm_map_io_range_to_ioreq_server"", ""file_path"": ""xen/arch/x86/hvm/ioreq.c"", ""func_code"": ""int hvm_map_io_range_to_ioreq_server(struct domain *d, ioservid_t id,\n                                     uint32_t type, uint64_t start,\n                                     uint64_t end)\n{\n    struct hvm_ioreq_server *s;\n    int rc;\n\n    if ( start > end )\n        return -EINVAL;\n\n    spin_lock_recursive(&d->arch.hvm_domain.ioreq_server.lock);\n\n    rc = -ENOENT;\n    list_for_each_entry ( s,\n                          &d->arch.hvm_domain.ioreq_server.list,\n                          list_entry )\n    {\n        if ( s == d->arch.hvm_domain.default_ioreq_server )\n            continue;\n\n        if ( s->id == id )\n        {\n            struct rangeset *r;\n\n            switch ( type )\n            {\n            case XEN_DMOP_IO_RANGE_PORT:\n            case XEN_DMOP_IO_RANGE_MEMORY:\n            case XEN_DMOP_IO_RANGE_PCI:\n                r = s->range[type];\n                break;\n\n            default:\n                r = NULL;\n                break;\n            }\n\n            rc = -EINVAL;\n            if ( !r )\n                break;\n\n            rc = -EEXIST;\n            if ( rangeset_overlaps_range(r, start, end) )\n                break;\n\n            rc = rangeset_add_range(r, start, end);\n            break;\n        }\n    }\n\n    spin_unlock_recursive(&d->arch.hvm_domain.ioreq_server.lock);\n\n    return rc;\n}""}, {""func_name"": ""hvm_unmap_io_range_from_ioreq_server"", ""file_path"": ""xen/arch/x86/hvm/ioreq.c"", ""func_code"": ""int hvm_unmap_io_range_from_ioreq_server(struct domain *d, ioservid_t id,\n                                         uint32_t type, uint64_t start,\n                                         uint64_t end)\n{\n    struct hvm_ioreq_server *s;\n    int rc;\n\n    if ( start > end )\n        return -EINVAL;\n\n    spin_lock_recursive(&d->arch.hvm_domain.ioreq_server.lock);\n\n    rc = -ENOENT;\n    list_for_each_entry ( s,\n                          &d->arch.hvm_domain.ioreq_server.list,\n                          list_entry )\n    {\n        if ( s == d->arch.hvm_domain.default_ioreq_server )\n            continue;\n\n        if ( s->id == id )\n        {\n            struct rangeset *r;\n\n            switch ( type )\n            {\n            case XEN_DMOP_IO_RANGE_PORT:\n            case XEN_DMOP_IO_RANGE_MEMORY:\n            case XEN_DMOP_IO_RANGE_PCI:\n                r = s->range[type];\n                break;\n\n            default:\n                r = NULL;\n                break;\n            }\n\n            rc = -EINVAL;\n            if ( !r )\n                break;\n\n            rc = -ENOENT;\n            if ( !rangeset_contains_range(r, start, end) )\n                break;\n\n            rc = rangeset_remove_range(r, start, end);\n            break;\n        }\n    }\n\n    spin_unlock_recursive(&d->arch.hvm_domain.ioreq_server.lock);\n\n    return rc;\n}""}]","{""caller"": 2, ""value"": 2}","[{""source"": ""caller_info(file:ioreq.c, func:hvm_map_io_range_to_ioreq_server)"", ""result"": [{""call_line"": 442, ""call_code"": ""hvm_map_io_range_to_ioreq_server(d, data->id, data->type,\n                                              data->start, data->end)"", ""caller_code"": ""static int dm_op(const struct dmop_args *op_args)\n{\n    struct domain *d;\n    struct xen_dm_op op;\n    bool const_op = true;\n    long rc;\n\n    rc = rcu_lock_remote_domain_by_id(op_args->domid, &d);\n    if ( rc )\n        return rc;\n\n    if ( !is_hvm_domain(d) )\n        goto out;\n\n    rc = xsm_dm_op(XSM_DM_PRIV, d);\n    if ( rc )\n        goto out;\n\n    if ( !COPY_FROM_GUEST_BUF(op, op_args, 0) )\n    {\n        rc = -EFAULT;\n        goto out;\n    }\n\n    rc = -EINVAL;\n    if ( op.pad )\n        goto out;\n\n    switch ( op.op )\n    {\n    case XEN_DMOP_create_ioreq_server:\n    {\n        struct domain *curr_d = current->domain;\n        struct xen_dm_op_create_ioreq_server *data =\n            &op.u.create_ioreq_server;\n\n        const_op = false;\n\n        rc = -EINVAL;\n        if ( data->pad[0] || data->pad[1] || data->pad[2] )\n            break;\n\n        rc = hvm_create_ioreq_server(d, curr_d->domain_id, false,\n                                     data->handle_bufioreq, &data->id);\n        bre..."", ""caller_start"": 368, ""file_path"": ""xen/arch/x86/hvm/dm.c""}]}, {""source"": ""caller_info(file:ioreq.c, func:hvm_unmap_io_range_from_ioreq_server)"", ""result"": [{""call_line"": 456, ""call_code"": ""hvm_unmap_io_range_from_ioreq_server(d, data->id, data->type,\n                                                  data->start, data->end)"", ""caller_code"": ""static int dm_op(const struct dmop_args *op_args)\n{\n    struct domain *d;\n    struct xen_dm_op op;\n    bool const_op = true;\n    long rc;\n\n    rc = rcu_lock_remote_domain_by_id(op_args->domid, &d);\n    if ( rc )\n        return rc;\n\n    if ( !is_hvm_domain(d) )\n        goto out;\n\n    rc = xsm_dm_op(XSM_DM_PRIV, d);\n    if ( rc )\n        goto out;\n\n    if ( !COPY_FROM_GUEST_BUF(op, op_args, 0) )\n    {\n        rc = -EFAULT;\n        goto out;\n    }\n\n    rc = -EINVAL;\n    if ( op.pad )\n        goto out;\n\n    switch ( op.op )\n    {\n    case XEN_DMOP_create_ioreq_server:\n    {\n        struct domain *curr_d = current->domain;\n        struct xen_dm_op_create_ioreq_server *data =\n            &op.u.create_ioreq_server;\n\n        const_op = false;\n\n        rc = -EINVAL;\n        if ( data->pad[0] || data->pad[1] || data->pad[2] )\n            break;\n\n        rc = hvm_create_ioreq_server(d, curr_d->domain_id, false,\n                                     data->handle_bufioreq, &data->id);\n        bre..."", ""caller_start"": 368, ""file_path"": ""xen/arch/x86/hvm/dm.c""}]}, {""source"": ""value_info(file:ioreq.c, value:start)"", ""result"": {""value_trace"": [{""full_code"": ""start = name"", ""line"": 59, ""func_name"": ""tap_ctl_prepare_directory""}, {""full_code"": ""start = ptr + 1"", ""line"": 77, ""func_name"": ""tap_ctl_prepare_directory""}, {""full_code"": ""start++"", ""line"": 137, ""func_name"": ""writelog_clear""}, {""full_code"": ""start = treq.sec"", ""line"": 257, ""func_name"": ""replicated_write_callback""}], ""struct_var"": ""start"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""value_info(file:ioreq.c, value:end)"", ""result"": {""value_trace"": [{""full_code"": ""end = addr + p->size - 1"", ""line"": 1231, ""func_name"": ""hvm_select_ioreq_server""}, {""full_code"": ""end = addr + (p->size * p->count) - 1"", ""line"": 1237, ""func_name"": ""hvm_select_ioreq_server""}], ""struct_var"": ""end"", ""struct_type"": ""longunsigned"", ""struct_definition"": ""longunsigned""}}]","Unvalidated 'start' and 'end' parameters in hvm_map_io_range_to_ioreq_server (xen/arch/x86/hvm/ioreq.c:820) and hvm_unmap_io_range_from_ioreq_server (xen/arch/x86/hvm/ioreq.c:872) allowed attackers to pass end < start ranges via XEN_DMOP hypercalls. These values were sourced from data->start and data->end in dm_op (xen/arch/x86/hvm/dm.c:442, 456), which copied the parameters from the guest using COPY_FROM_GUEST_BUF. The absence of start ≤ end validation led to assertion failures (debug) or undefined behavior (production).",0.95,./github/other_context/CVE-2017-15591
20,CVE-2017-5226,CWE-20,c_cpp,"When executing a program via the bubblewrap sandbox, the nonpriv session can escape to the parent session by using the TIOCSTI ioctl to push characters into the terminal's input buffer, allowing an attacker to escape the sandbox.",https://github.com/containers/bubblewrap/commit/d7fc532c42f0e9bf427923bab85433282b3e5117,"Call setsid() before executing sandboxed code (CVE-2017-5226)\n\nThis prevents the sandboxed code from getting a controlling tty,\nwhich in turn prevents it from accessing the TIOCSTI ioctl and hence\nfaking terminal input.\n\nFixes: #142\n\nCloses: #143\nApproved by: cgwalters",1,"[{""func_name"": ""main"", ""file_path"": ""bubblewrap.c"", ""func_code"": ""int\nmain (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  cleanup_free char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\""prctl(PR_SET_NO_NEW_CAPS) failed\"");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, &argv);\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n  if (opt_unshare_user_try &&\n      stat (\""/proc/self/ns/user\"", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\""/sys/module/user_namespace/parameters/enable\"", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \""/sys/module/user_namespace/parameters/enable\"");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\""Creating root mount point\\n\""));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\""Specifying --uid requires --unshare-user\"");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\""Specifying --gid requires --unshare-user\"");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\""Specifying --hostname requires --unshare-uts\"");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\""/proc\"", O_RDONLY | O_PATH);\n  if (proc_fd == -1)\n    die_with_error (\""Can't open /proc\"");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n     We first try in /run, and if that fails, try in /tmp. */\n  base_path = xasprintf (\""/run/user/%d/.bubblewrap\"", real_uid);\n  if (mkdir (base_path, 0755) && errno != EEXIST)\n    {\n      free (base_path);\n      base_path = xasprintf (\""/tmp/.bubblewrap-%d\"", real_uid);\n      if (mkdir (base_path, 0755) && errno != EEXIST)\n        die_with_error (\""Creating root mountpoint failed\"");\n    }\n\n  __debug__ ((\""creating new namespace\\n\""));\n\n  if (opt_unshare_pid)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\""eventfd()\"");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\""/proc/self/ns/cgroup\"", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\""Cannot create new cgroup namespace because the kernel does not support it\"");\n          else\n            die_with_error (\""stat on /proc/self/ns/cgroup failed\"");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\""/proc/self/ns/cgroup\"", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\""eventfd()\"");\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\""Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\"");\n          else if (errno == EPERM && !is_privileged)\n            die (\""No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\"");\n        }\n\n      die_with_error (\""Creating new namespace failed\"");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs ();\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\""{\\n    \\\""child-pid\\\"": %i\\n}\\n\"", pid);\n          size_t len = strlen (output);\n          if (write (opt_info_fd, output, len) != len)\n            die_with_error (\""Write to info_fd\"");\n          close (opt_info_fd);\n        }\n\n      monitor_child (event_fd);\n      exit (0); /* Should not be reached, but better safe... */\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net && loopback_setup () != 0)\n    die (\""Can't create loopback device\"");\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \""/\"", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\""Failed to make / slave\"");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\""\"", base_path, \""tmpfs\"", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\""Failed to mount tmpfs\"");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \""oldroot\"" and \""newroot\"". */\n  if (chdir (base_path) != 0)\n    die_with_error (\""chdir base_path\"");\n\n  /* We create a subdir \""$base_path/newroot\"" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \""$base_path/oldroot\"". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / */\n\n  if (mkdir (\""newroot\"", 0755))\n    die_with_error (\""Creating newroot failed\"");\n\n  if (mkdir (\""oldroot\"", 0755))\n    die_with_error (\""Creating oldroot failed\"");\n\n  if (pivot_root (base_path, \""oldroot\""))\n    die_with_error (\""pivot_root\"");\n\n  if (chdir (\""/\"") != 0)\n    die_with_error (\""chdir / (base path)\"");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\""Can't create privsep socket\"");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\""Can't fork unprivileged helper\"");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs ();\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\""Can't write to op_socket\"");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\""oldroot\"", \""oldroot\"", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\""Failed to make old root rprivate\"");\n\n  if (umount2 (\""oldroot\"", MNT_DETACH))\n    die_with_error (\""unmount old root\"");\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid))\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\""unshare user ns\"");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* Now make /newroot the real root */\n  if (chdir (\""/newroot\"") != 0)\n    die_with_error (\""chdir newroot\"");\n  if (chroot (\""/newroot\"") != 0)\n    die_with_error (\""chroot /newroot\"");\n  if (chdir (\""/\"") != 0)\n    die_with_error (\""chdir /\"");\n\n  /* All privileged ops are done now, so drop it */\n  drop_privs ();\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      read (opt_block_fd, b, 1);\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      cleanup_free char *seccomp_data = NULL;\n      size_t seccomp_len;\n      struct sock_fprog prog;\n\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\""Can't read seccomp data\"");\n\n      if (seccomp_len % 8 != 0)\n        die (\""Invalid seccomp data, must be multiple of 8\"");\n\n      prog.len = seccomp_len / 8;\n      prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n\n      if (prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) != 0)\n        die_with_error (\""prctl(PR_SET_SECCOMP)\"");\n    }\n\n  umask (old_umask);\n\n  new_cwd = \""/\"";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\""Can't chdir to %s\"", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\""HOME\"");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\""PWD\"", new_cwd, 1);\n  free (old_cwd);\n\n  __debug__ ((\""forking for child\\n\""));\n\n  if (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1)\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\""Can't fork for pid 1\"");\n\n      if (pid != 0)\n        {\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid);\n        }\n    }\n\n  __debug__ ((\""launch executable %s\\n\"", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  if (opt_sync_fd != -1)\n    close (opt_sync_fd);\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\""label_exec %s\"", argv[0]);\n\n  if (execvp (argv[0], argv) == -1)\n    die_with_error (\""execvp %s\"", argv[0]);\n\n  return 0;\n}"", ""target"": 0}]","[{""func_name"": ""main"", ""file_path"": ""bubblewrap.c"", ""func_code"": ""int\nmain (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  cleanup_free char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\""prctl(PR_SET_NO_NEW_CAPS) failed\"");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, &argv);\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n  if (opt_unshare_user_try &&\n      stat (\""/proc/self/ns/user\"", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\""/sys/module/user_namespace/parameters/enable\"", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \""/sys/module/user_namespace/parameters/enable\"");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\""Creating root mount point\\n\""));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\""Specifying --uid requires --unshare-user\"");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\""Specifying --gid requires --unshare-user\"");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\""Specifying --hostname requires --unshare-uts\"");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\""/proc\"", O_RDONLY | O_PATH);\n  if (proc_fd == -1)\n    die_with_error (\""Can't open /proc\"");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n     We first try in /run, and if that fails, try in /tmp. */\n  base_path = xasprintf (\""/run/user/%d/.bubblewrap\"", real_uid);\n  if (mkdir (base_path, 0755) && errno != EEXIST)\n    {\n      free (base_path);\n      base_path = xasprintf (\""/tmp/.bubblewrap-%d\"", real_uid);\n      if (mkdir (base_path, 0755) && errno != EEXIST)\n        die_with_error (\""Creating root mountpoint failed\"");\n    }\n\n  __debug__ ((\""creating new namespace\\n\""));\n\n  if (opt_unshare_pid)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\""eventfd()\"");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\""/proc/self/ns/cgroup\"", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\""Cannot create new cgroup namespace because the kernel does not support it\"");\n          else\n            die_with_error (\""stat on /proc/self/ns/cgroup failed\"");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\""/proc/self/ns/cgroup\"", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\""eventfd()\"");\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\""Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\"");\n          else if (errno == EPERM && !is_privileged)\n            die (\""No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\"");\n        }\n\n      die_with_error (\""Creating new namespace failed\"");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs ();\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\""{\\n    \\\""child-pid\\\"": %i\\n}\\n\"", pid);\n          size_t len = strlen (output);\n          if (write (opt_info_fd, output, len) != len)\n            die_with_error (\""Write to info_fd\"");\n          close (opt_info_fd);\n        }\n\n      monitor_child (event_fd);\n      exit (0); /* Should not be reached, but better safe... */\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net && loopback_setup () != 0)\n    die (\""Can't create loopback device\"");\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \""/\"", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\""Failed to make / slave\"");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\""\"", base_path, \""tmpfs\"", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\""Failed to mount tmpfs\"");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \""oldroot\"" and \""newroot\"". */\n  if (chdir (base_path) != 0)\n    die_with_error (\""chdir base_path\"");\n\n  /* We create a subdir \""$base_path/newroot\"" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \""$base_path/oldroot\"". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / */\n\n  if (mkdir (\""newroot\"", 0755))\n    die_with_error (\""Creating newroot failed\"");\n\n  if (mkdir (\""oldroot\"", 0755))\n    die_with_error (\""Creating oldroot failed\"");\n\n  if (pivot_root (base_path, \""oldroot\""))\n    die_with_error (\""pivot_root\"");\n\n  if (chdir (\""/\"") != 0)\n    die_with_error (\""chdir / (base path)\"");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\""Can't create privsep socket\"");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\""Can't fork unprivileged helper\"");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs ();\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\""Can't write to op_socket\"");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\""oldroot\"", \""oldroot\"", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\""Failed to make old root rprivate\"");\n\n  if (umount2 (\""oldroot\"", MNT_DETACH))\n    die_with_error (\""unmount old root\"");\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid))\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\""unshare user ns\"");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* Now make /newroot the real root */\n  if (chdir (\""/newroot\"") != 0)\n    die_with_error (\""chdir newroot\"");\n  if (chroot (\""/newroot\"") != 0)\n    die_with_error (\""chroot /newroot\"");\n  if (chdir (\""/\"") != 0)\n    die_with_error (\""chdir /\"");\n\n  /* All privileged ops are done now, so drop it */\n  drop_privs ();\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      read (opt_block_fd, b, 1);\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      cleanup_free char *seccomp_data = NULL;\n      size_t seccomp_len;\n      struct sock_fprog prog;\n\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\""Can't read seccomp data\"");\n\n      if (seccomp_len % 8 != 0)\n        die (\""Invalid seccomp data, must be multiple of 8\"");\n\n      prog.len = seccomp_len / 8;\n      prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n\n      if (prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) != 0)\n        die_with_error (\""prctl(PR_SET_SECCOMP)\"");\n    }\n\n  umask (old_umask);\n\n  new_cwd = \""/\"";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\""Can't chdir to %s\"", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\""HOME\"");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\""PWD\"", new_cwd, 1);\n  free (old_cwd);\n\n  __debug__ ((\""forking for child\\n\""));\n\n  if (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1)\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\""Can't fork for pid 1\"");\n\n      if (pid != 0)\n        {\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid);\n        }\n    }\n\n  __debug__ ((\""launch executable %s\\n\"", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  if (opt_sync_fd != -1)\n    close (opt_sync_fd);\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  if (setsid () == (pid_t) -1)\n    die_with_error (\""setsid\"");\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\""label_exec %s\"", argv[0]);\n\n  if (execvp (argv[0], argv) == -1)\n    die_with_error (\""execvp %s\"", argv[0]);\n\n  return 0;\n}""}]","{""function"": 2, ""code"": 2}","[{""source"": ""func_info(func:label_exec)"", ""result"": [{""code"": ""int\nlabel_exec (const char *exec_label)\n{\n#ifdef HAVE_SELINUX\n  if (is_selinux_enabled () > 0 && exec_label)\n    return setexeccon ((security_context_t) exec_label);\n#endif\n  return 0;\n}"", ""start_line"": 701, ""end_line"": 709, ""full_name"": ""label_exec"", ""file_path"": ""utils.c""}]}, {""source"": ""code_info(file:bubblewrap.c, lines:70-80)"", ""result"": ""int opt_block_fd = -1;\nint opt_info_fd = -1;\nint opt_seccomp_fd = -1;\nchar *opt_sandbox_hostname = NULL;\n\ntypedef enum {\n  SETUP_BIND_MOUNT,\n  SETUP_RO_BIND_MOUNT,\n  SETUP_DEV_BIND_MOUNT,\n  SETUP_MOUNT_PROC,\n  SETUP_MOUNT_DEV,\n  SETUP_MOUNT_TMPFS,\n""}, {""source"": ""code_info(file:bubblewrap.c, lines:2075-2090)"", ""result"": ""    die_with_error (\""label_exec %s\"", argv[0]);\n\n  if (execvp (argv[0], argv) == -1)\n    die_with_error (\""execvp %s\"", argv[0]);\n\n  return 0;\n}\n""}, {""source"": ""func_info(file:bubblewrap.c, func:unblock_sigchild)"", ""result"": [{""code"": ""static void\nunblock_sigchild (void)\n{\n  sigset_t mask;\n\n  sigemptyset (&mask);\n  sigaddset (&mask, SIGCHLD);\n\n  if (sigprocmask (SIG_UNBLOCK, &mask, NULL) == -1)\n    die_with_error (\""sigprocmask\"");\n}"", ""start_line"": 232, ""end_line"": 242, ""full_name"": ""unblock_sigchild"", ""file_path"": ""bubblewrap.c""}]}]","bubblewrap.c:2072-2075: The original code lacked `setsid()` before `label_exec()` and `execvp()`, allowing the sandboxed process to inherit the parent's session and controlling TTY. By calling `setsid()`, the process becomes a new session leader without a controlling TTY, preventing TIOCSTI-based input injection. The `label_exec()` function (utils.c:701-709) handles SELinux labels but does not affect terminal state. The subsequent `execvp()` executes the target program in a session-isolated context, blocking TTY access.",0.95,./github/other_context/CVE-2017-5226
21,CVE-2017-5592,"CWE-20, CWE-346",c_cpp,"An incorrect implementation of ""XEP-0280: Message Carbons"" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for profanity (0.4.7 - 0.5.0).",https://github.com/profanity-im/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b,Add carbons from check,1,"[{""func_name"": ""_handle_carbons"", ""file_path"": ""src/xmpp/message.c"", ""func_code"": ""static gboolean\n_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error(\""Unable to retrieve stanza name for Carbon\"");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, \""private\"") == 0) {\n        log_info(\""Carbon received with private element.\"");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, \""received\"") != 0) && (g_strcmp0(name, \""sent\"") != 0)) {\n        log_warning(\""Carbon received with unrecognised stanza name: %s\"", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning(\""Carbon received with no forwarded element\"");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\""Carbon received with no message element\"");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\""Carbon received with no message.\"");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n    Jid *my_jid = jid_create(connection_get_fulljid());\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}"", ""target"": 0}]","[{""func_name"": ""_handle_carbons"", ""file_path"": ""src/xmpp/message.c"", ""func_code"": ""static gboolean\n_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error(\""Unable to retrieve stanza name for Carbon\"");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, \""private\"") == 0) {\n        log_info(\""Carbon received with private element.\"");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, \""received\"") != 0) && (g_strcmp0(name, \""sent\"") != 0)) {\n        log_warning(\""Carbon received with unrecognised stanza name: %s\"", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning(\""Carbon received with no forwarded element\"");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\""Carbon received with no message element\"");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\""Carbon received with no message.\"");\n        return TRUE;\n    }\n\n    Jid *my_jid = jid_create(connection_get_fulljid());\n    const char *const stanza_from = xmpp_stanza_get_from(stanza);\n    Jid *msg_jid = jid_create(stanza_from);\n    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {\n        log_warning(\""Invalid carbon received, from: %s\"", stanza_from);\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}""}]","{""caller"": 2, ""code"": 2, ""value"": 2}","[{""source"": ""caller_info(file:message.c, func:_handle_carbons)"", ""result"": [{""call_line"": 764, ""call_code"": ""_handle_carbons(stanza)"", ""caller_code"": ""static void\n_handle_chat(xmpp_stanza_t *const stanza)\n{\n    // ignore if type not chat or absent\n    const char *type = xmpp_stanza_get_type(stanza);\n    if (!(g_strcmp0(type, \""chat\"") == 0 || type == NULL)) {\n        return;\n    }\n\n    // check if carbon message\n    gboolean res = _handle_carbons(stanza);\n    if (res) {\n        return;\n    }\n\n    // ignore handled namespaces\n    xmpp_stanza_t *conf = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CAPTCHA);\n    if (conf || captcha) {\n        return;\n    }\n\n    // some clients send the mucuser namespace with private messages\n    // if the namespace exists, and the stanza contains a body element, assume its a private message\n    // otherwise exit the handler\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    xmpp_stanza_t *body = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_BODY);\n    if (mucuser && body ==..."", ""caller_start"": 754, ""file_path"": ""src/xmpp/message.c""}]}, {""source"": ""code_info(file:message.c, lines:700-720)"", ""result"": ""    if (!forwarded) {\n        log_warning(\""Carbon received with no forwarded element\"");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\""Carbon received with no message element\"");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\""Carbon received with no message.\"");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n""}, {""source"": ""value_info(file:message.c, value:stanza)"", ""result"": {""value_trace"": [{""full_code"": ""stanza = stanza_create_invite(ctx, roomjid, contact, reason, password)"", ""line"": 316, ""func_name"": ""message_send_invite""}, {""full_code"": ""stanza = stanza_create_mediated_invite(ctx, roomjid, contact, reason)"", ""line"": 319, ""func_name"": ""message_send_invite""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_COMPOSING)"", ""line"": 331, ""func_name"": ""message_send_composing""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_PAUSED)"", ""line"": 341, ""func_name"": ""message_send_paused""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_INACTIVE)"", ""line"": 350, ""func_name"": ""message_send_inactive""}], ""struct_var"": ""stanza"", ""struct_type"": ""xmpp_stanza_t*"", ""struct_definition"": ""xmpp_stanza_t""}}, {""source"": ""caller_info(file:message.c, func:_handle_chat)"", ""result"": [{""call_line"": 121, ""call_code"": ""_handle_chat(stanza)"", ""caller_code"": ""static int\n_message_handler(xmpp_conn_t *const conn, xmpp_stanza_t *const stanza, void *const userdata)\n{\n    log_debug(\""Message stanza handler fired\"");\n\n    char *text;\n    size_t text_size;\n    xmpp_stanza_to_text(stanza, &text, &text_size);\n    gboolean cont = plugins_on_message_stanza_receive(text);\n    xmpp_free(connection_get_ctx(), text);\n    if (!cont) {\n        return 1;\n    }\n\n    const char *type = xmpp_stanza_get_type(stanza);\n\n    if (g_strcmp0(type, STANZA_TYPE_ERROR) == 0) {\n        _handle_error(stanza);\n    }\n\n    if (g_strcmp0(type, STANZA_TYPE_GROUPCHAT) == 0) {\n        _handle_groupchat(stanza);\n    }\n\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    if (mucuser) {\n        _handel_muc_user(stanza);\n    }\n\n    xmpp_stanza_t *conference = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    if (conference) {\n        _handle_conference(stanza);\n    }\n\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, ..."", ""caller_start"": 77, ""file_path"": ""src/xmpp/message.c""}]}, {""source"": ""value_info(file:message.c, value:stanza)"", ""result"": {""value_trace"": [{""full_code"": ""stanza = stanza_create_invite(ctx, roomjid, contact, reason, password)"", ""line"": 316, ""func_name"": ""message_send_invite""}, {""full_code"": ""stanza = stanza_create_mediated_invite(ctx, roomjid, contact, reason)"", ""line"": 319, ""func_name"": ""message_send_invite""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_COMPOSING)"", ""line"": 331, ""func_name"": ""message_send_composing""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_PAUSED)"", ""line"": 341, ""func_name"": ""message_send_paused""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_INACTIVE)"", ""line"": 350, ""func_name"": ""message_send_inactive""}], ""struct_var"": ""stanza"", ""struct_type"": ""xmpp_stanza_t*"", ""struct_definition"": ""xmpp_stanza_t""}}, {""source"": ""code_info(file:message.c, lines:100-140)"", ""result"": ""\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    if (mucuser) {\n        _handel_muc_user(stanza);\n    }\n\n    xmpp_stanza_t *conference = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    if (conference) {\n        _handle_conference(stanza);\n    }\n\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CAPTCHA);\n    if (captcha) {\n        _handle_captcha(stanza);\n    }\n\n    xmpp_stanza_t *receipts = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_RECEIPTS);\n    if (receipts) {\n        _handle_receipt_received(stanza);\n    }\n\n    _handle_chat(stanza);\n\n    return 1;\n}\n\nvoid\nmessage_handlers_init(void)\n{\n    xmpp_conn_t * const conn = connection_get_conn();\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_handler_add(conn, _message_handler, NULL, STANZA_NAME_MESSAGE, NULL, ctx);\n}\n\nchar*\nmessage_send_chat(const char *const barejid, const char *const msg, const char *const oob_url,\n    gboolean request_receipt)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *state = chat_session_get_state(barejid);\n    char *jid = chat_session_get_jid(barejid);\n""}]","The vulnerability originates in missing validation of the 'from' JID in XMPP carbons (src/xmpp/message.c:716-720). `_handle_carbons` is called by `_handle_chat` (src/xmpp/message.c:764), which is triggered by `_message_handler` (src/xmpp/message.c:121) to process incoming XMPP stanzas. `_message_handler` is registered as an XMPP stanza handler via `xmpp_handler_add` in `message_handlers_init` (src/xmpp/message.c:140), establishing the network input path for the `stanza` parameter. The attack vector is confirmed as an external attacker can send a malicious carbon stanza over XMPP, which is processed by `_message_handler` and passed to `_handle_carbons` without proper validation.",1.0,./github/other_context/CVE-2017-5592
22,CVE-2017-9144,CWE-20,c_cpp,"In ImageMagick 7.0.5-5, a crafted RLE image can trigger a crash because of incorrect EOF handling in coders/rle.c.",https://github.com/ImageMagick/ImageMagick/commit/f6240ee77847787f6d7618b669d3a2040a2d6d40,Check for EOF conditions for RLE image format,1,"[{""func_name"": ""ReadRLEImage"", ""file_path"": ""coders/rle.c"", ""func_code"": ""static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\""\\122\\314\"",2) != 0))\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=ReadBlobLSBShort(image);\n    image->page.y=ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 22)\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n          image->filename);\n        break;\n      }\n    colormap=(unsigned char *) NULL;\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n            *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(\n              ReadBlobLSBShort(image)));\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\""comment\"",comment,exception);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n          image->filename);\n        break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate RLE pixels.\n    */\n    if (image->alpha_trait != UndefinedPixelTrait)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n      number_planes+1;\n    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n         number_planes_filled))\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n      MagickMax(number_planes_filled,4)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    pixel_info_length=image->columns*image->rows*\n      MagickMax(number_planes_filled,4);\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,pixel_info_length);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n          operand++;\n          if ((offset < 0) ||\n              (offset+((size_t) operand*number_planes) > pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode & 0x40)\n            operand=ReadBlobLSBSignedShort(image);\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane;\n          operand++;\n          if ((offset < 0) ||\n              (offset+((size_t) operand*number_planes) > pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            ValidateColormapValue(image,*p & mask,&index,exception);\n            *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                ValidateColormapValue(image,(size_t) (x*map_length+\n                  (*p & mask)),&index,exception);\n                *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum(*p);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->alpha_trait == UndefinedPixelTrait)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(image,*p++,q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image,exception);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].red),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].green),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].blue),q);\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n                q+=GetPixelChannels(image);\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelInfo *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\""\\122\\314\"",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\""\\122\\314\"",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"", ""target"": 0}]","[{""func_name"": ""ReadRLEImage"", ""file_path"": ""coders/rle.c"", ""func_code"": ""static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n#define ThrowRLEException(exception,message) \\\n{ \\\n  if (colormap != (unsigned char *) NULL) \\\n    colormap=(unsigned char *) RelinquishMagickMemory(colormap); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  colormap=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\""\\122\\314\"",2) != 0))\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=(ssize_t) ReadBlobLSBShort(image);\n    image->page.y=(ssize_t) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 22)\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n\t  {\n            *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(\n              ReadBlobLSBShort(image)));\n            if (EOFBlob(image) != MagickFalse)\n              ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n\t  }\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\""comment\"",comment,exception);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate RLE pixels.\n    */\n    if (image->alpha_trait != UndefinedPixelTrait)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n      number_planes+1;\n    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n         number_planes_filled))\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n      MagickMax(number_planes_filled,4)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    pixel_info_length=image->columns*image->rows*\n      MagickMax(number_planes_filled,4);\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,pixel_info_length);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    if (opcode == EOF)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (opcode == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n\t    }\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (opcode == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n            }\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (opcode == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n            }\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n          operand++;\n          if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (opcode == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (opcode == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n            }\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n          operand++;\n          if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n      if (opcode == EOF)\n        ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            ValidateColormapValue(image,(ssize_t) (*p & mask),&index,exception);\n            *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) (x*map_length+\n                  (*p & mask)),&index,exception);\n                *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum(*p);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->alpha_trait == UndefinedPixelTrait)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(image,(Quantum) *p++,q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image,exception);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].red),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].green),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].blue),q);\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n                q+=GetPixelChannels(image);\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelInfo *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\""\\122\\314\"",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\""\\122\\314\"",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}""}]","{""code"": 2, ""function"": 2}","[{""source"": ""code_info(file:rle.c, lines:200-240)"", ""result"": ""  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\""\\122\\314\"",2) != 0))\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=ReadBlobLSBShort(image);\n    image->page.y=ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 22)\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n""}, {""source"": ""func_info(func:ReadBlobLSBSignedShort)"", ""result"": [{""code"": ""signed short ReadBlobLSBSignedShort(Image *image)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobLSBShort(image);\n  return(quantum.signed_value);\n}"", ""start_line"": 3833, ""end_line"": 3846, ""full_name"": ""ReadBlobLSBSignedShort"", ""file_path"": ""MagickCore/blob.c""}]}, {""source"": ""func_info(func:EOFBlob)"", ""result"": [{""code"": ""int EOFBlob(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""...\"");\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  switch (image->blob->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      image->blob->eof=feof(image->blob->file_info.file) != 0 ? MagickTrue :\n        MagickFalse;\n      break;\n    }\n    case ZipStream:\n    {\n      image->blob->eof=MagickFalse;\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      int\n        status;\n\n      status=0;\n      (void) BZ2_bzerror(image->blob->file_info.bzfile,&status);\n      image->blob->eof=status == BZ_UNEXPECTED_EOF ? MagickTrue : MagickFalse;\n#endif\n      break;\n    }\n    case FifoStream:\n    {\n      image->blob->eof=MagickFalse;\n  ..."", ""start_line"": 974, ""end_line"": 1022, ""full_name"": ""EOFBlob"", ""file_path"": ""MagickCore/blob.c""}]}, {""source"": ""code_info(file:blob.c, lines:100-150)"", ""result"": ""    *file;\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n  gzFile\n    gzfile;\n#endif\n\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n  BZFILE\n    *bzfile;\n#endif\n} FileInfo;\n\nstruct _BlobInfo\n{\n  size_t\n    length,\n    extent,\n    quantum;\n\n  MagickBooleanType\n    mapped,\n    eof;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    exempt,\n    synchronize,\n    status,\n    temporary;\n\n  StreamType\n    type;\n\n  FileInfo\n    file_info;\n\n  struct stat\n    properties;\n\n  StreamHandler\n    stream;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  unsigned char\n""}]","Missing EOF checks in coders/rle.c:215-225 (header parsing), coders/rle.c:254-266 (colormap parsing), and coders/rle.c:360-400 (opcode processing) allowed invalid data processing after EOF. The patch adds checks via `EOFBlob` (MagickCore/blob.c:974-1022) and `opcode == EOF` to handle unexpected EOF. `ReadBlobLSBSignedShort` (MagickCore/blob.c:3833-3846) delegates to `ReadBlobLSBShort`, which does not handle EOF internally, requiring explicit checks. A crafted RLE file could trigger reads beyond EOF, leading to invalid memory access or data corruption.",0.95,./github/other_context/CVE-2017-9144
23,CVE-2018-13302,CWE-129,c_cpp,"In FFmpeg 4.0.1, improper handling of frame types (other than EAC3_FRAME_TYPE_INDEPENDENT) that have multiple independent substreams in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to a denial of service or possibly unspecified other impact.",https://github.com/FFmpeg/FFmpeg/commit/ed22dc22216f74c75ee7901f82649e1ff725ba50,"avformat/movenc: Check that frame_types other than EAC3_FRAME_TYPE_INDEPENDENT have a supported substream id\n\nFixes: out of array access\nFixes: ffmpeg_bof_1.avi\n\nFound-by: Thuan Pham, Marcel Böhme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",1,"[{""func_name"": ""handle_eac3"", ""file_path"": ""libavformat/movenc.c"", ""func_code"": ""static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n{\n    AC3HeaderInfo *hdr = NULL;\n    struct eac3_info *info;\n    int num_blocks, ret;\n\n    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))\n        return AVERROR(ENOMEM);\n    info = track->eac3_priv;\n\n    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {\n        /* drop the packets until we see a good one */\n        if (!track->entry) {\n            av_log(mov, AV_LOG_WARNING, \""Dropping invalid packet from start of the stream\\n\"");\n            ret = 0;\n        } else\n            ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);\n    num_blocks = hdr->num_blocks;\n\n    if (!info->ec3_done) {\n        /* AC-3 substream must be the first one */\n        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {\n            ret = AVERROR(EINVAL);\n            goto end;\n        }\n\n        /* this should always be the case, given that our AC-3 parser\n         * concatenates dependent frames to their independent parent */\n        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {\n            /* substream ids must be incremental */\n            if (hdr->substreamid > info->num_ind_sub + 1) {\n                ret = AVERROR(EINVAL);\n                goto end;\n            }\n\n            if (hdr->substreamid == info->num_ind_sub + 1) {\n                //info->num_ind_sub++;\n                avpriv_request_sample(track->par, \""Multiple independent substreams\"");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            } else if (hdr->substreamid < info->num_ind_sub ||\n                       hdr->substreamid == 0 && info->substream[0].bsid) {\n                info->ec3_done = 1;\n                goto concatenate;\n            }\n        }\n\n        /* fill the info needed for the \""dec3\"" atom */\n        info->substream[hdr->substreamid].fscod = hdr->sr_code;\n        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;\n        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;\n        info->substream[hdr->substreamid].acmod = hdr->channel_mode;\n        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt->size != hdr->frame_size) {\n            int cumul_size = hdr->frame_size;\n            int parent = hdr->substreamid;\n\n            while (cumul_size != pkt->size) {\n                GetBitContext gbc;\n                int i;\n                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);\n                if (ret < 0)\n                    goto end;\n                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {\n                    ret = AVERROR(EINVAL);\n                    goto end;\n                }\n                info->substream[parent].num_dep_sub++;\n                ret /= 8;\n\n                /* header is parsed up to lfeon, but custom channel map may be needed */\n                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);\n                /* skip bsid */\n                skip_bits(&gbc, 5);\n                /* skip volume control params */\n                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {\n                    skip_bits(&gbc, 5); // skip dialog normalization\n                    if (get_bits1(&gbc)) {\n                        skip_bits(&gbc, 8); // skip compression gain word\n                    }\n                }\n                /* get the dependent stream channel map, if exists */\n                if (get_bits1(&gbc))\n                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;\n                else\n                    info->substream[parent].chan_loc |= hdr->channel_mode;\n                cumul_size += hdr->frame_size;\n            }\n        }\n    }\n\nconcatenate:\n    if (!info->num_blocks && num_blocks == 6) {\n        ret = pkt->size;\n        goto end;\n    }\n    else if (info->num_blocks + num_blocks > 6) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    if (!info->num_blocks) {\n        ret = av_packet_ref(&info->pkt, pkt);\n        if (!ret)\n            info->num_blocks = num_blocks;\n        goto end;\n    } else {\n        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)\n            goto end;\n        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);\n        info->num_blocks += num_blocks;\n        info->pkt.duration += pkt->duration;\n        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)\n            goto end;\n        if (info->num_blocks != 6)\n            goto end;\n        av_packet_unref(pkt);\n        av_packet_move_ref(pkt, &info->pkt);\n        info->num_blocks = 0;\n    }\n    ret = pkt->size;\n\nend:\n    av_free(hdr);\n\n    return ret;\n}"", ""target"": 0}]","[{""func_name"": ""handle_eac3"", ""file_path"": ""libavformat/movenc.c"", ""func_code"": ""static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n{\n    AC3HeaderInfo *hdr = NULL;\n    struct eac3_info *info;\n    int num_blocks, ret;\n\n    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))\n        return AVERROR(ENOMEM);\n    info = track->eac3_priv;\n\n    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {\n        /* drop the packets until we see a good one */\n        if (!track->entry) {\n            av_log(mov, AV_LOG_WARNING, \""Dropping invalid packet from start of the stream\\n\"");\n            ret = 0;\n        } else\n            ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);\n    num_blocks = hdr->num_blocks;\n\n    if (!info->ec3_done) {\n        /* AC-3 substream must be the first one */\n        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {\n            ret = AVERROR(EINVAL);\n            goto end;\n        }\n\n        /* this should always be the case, given that our AC-3 parser\n         * concatenates dependent frames to their independent parent */\n        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {\n            /* substream ids must be incremental */\n            if (hdr->substreamid > info->num_ind_sub + 1) {\n                ret = AVERROR(EINVAL);\n                goto end;\n            }\n\n            if (hdr->substreamid == info->num_ind_sub + 1) {\n                //info->num_ind_sub++;\n                avpriv_request_sample(track->par, \""Multiple independent substreams\"");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            } else if (hdr->substreamid < info->num_ind_sub ||\n                       hdr->substreamid == 0 && info->substream[0].bsid) {\n                info->ec3_done = 1;\n                goto concatenate;\n            }\n        } else {\n            if (hdr->substreamid != 0) {\n                avpriv_request_sample(mov->fc, \""Multiple non EAC3 independent substreams\"");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            }\n        }\n\n        /* fill the info needed for the \""dec3\"" atom */\n        info->substream[hdr->substreamid].fscod = hdr->sr_code;\n        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;\n        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;\n        info->substream[hdr->substreamid].acmod = hdr->channel_mode;\n        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt->size != hdr->frame_size) {\n            int cumul_size = hdr->frame_size;\n            int parent = hdr->substreamid;\n\n            while (cumul_size != pkt->size) {\n                GetBitContext gbc;\n                int i;\n                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);\n                if (ret < 0)\n                    goto end;\n                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {\n                    ret = AVERROR(EINVAL);\n                    goto end;\n                }\n                info->substream[parent].num_dep_sub++;\n                ret /= 8;\n\n                /* header is parsed up to lfeon, but custom channel map may be needed */\n                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);\n                /* skip bsid */\n                skip_bits(&gbc, 5);\n                /* skip volume control params */\n                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {\n                    skip_bits(&gbc, 5); // skip dialog normalization\n                    if (get_bits1(&gbc)) {\n                        skip_bits(&gbc, 8); // skip compression gain word\n                    }\n                }\n                /* get the dependent stream channel map, if exists */\n                if (get_bits1(&gbc))\n                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;\n                else\n                    info->substream[parent].chan_loc |= hdr->channel_mode;\n                cumul_size += hdr->frame_size;\n            }\n        }\n    }\n\nconcatenate:\n    if (!info->num_blocks && num_blocks == 6) {\n        ret = pkt->size;\n        goto end;\n    }\n    else if (info->num_blocks + num_blocks > 6) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    if (!info->num_blocks) {\n        ret = av_packet_ref(&info->pkt, pkt);\n        if (!ret)\n            info->num_blocks = num_blocks;\n        goto end;\n    } else {\n        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)\n            goto end;\n        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);\n        info->num_blocks += num_blocks;\n        info->pkt.duration += pkt->duration;\n        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)\n            goto end;\n        if (info->num_blocks != 6)\n            goto end;\n        av_packet_unref(pkt);\n        av_packet_move_ref(pkt, &info->pkt);\n        info->num_blocks = 0;\n    }\n    ret = pkt->size;\n\nend:\n    av_free(hdr);\n\n    return ret;\n}""}]","{""value"": 5, ""code"": 3, ""function"": 1}","[{""source"": ""value_info(file:movenc.c, value:info->substream)"", ""result"": {""value_trace"": [{""full_code"": ""info->substream"", ""line"": 548, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 549, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 552, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 553, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 554, ""func_name"": ""mov_write_eac3_tag""}], ""struct_var"": ""info"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:movenc.c, lines:430-450)"", ""result"": ""            if (hdr->substreamid == info->num_ind_sub + 1) {\n                //info->num_ind_sub++;\n                avpriv_request_sample(track->par, \""Multiple independent substreams\"");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            } else if (hdr->substreamid < info->num_ind_sub ||\n                       hdr->substreamid == 0 && info->substream[0].bsid) {\n                info->ec3_done = 1;\n                goto concatenate;\n            }\n        }\n\n        /* fill the info needed for the \""dec3\"" atom */\n        info->substream[hdr->substreamid].fscod = hdr->sr_code;\n        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;\n        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;\n        info->substream[hdr->substreamid].acmod = hdr->channel_mode;\n        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt->size != hdr->frame_size) {\n            int cumul_size = hdr->frame_size;\n""}, {""source"": ""value_info(file:movenc.c, value:info->substream)"", ""result"": {""value_trace"": [{""full_code"": ""info->substream"", ""line"": 548, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 549, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 552, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 553, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 554, ""func_name"": ""mov_write_eac3_tag""}], ""struct_var"": ""info"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:movenc.c, value:info->substream)"", ""result"": {""value_trace"": [{""full_code"": ""info->substream"", ""line"": 548, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 549, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 552, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 553, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 554, ""func_name"": ""mov_write_eac3_tag""}], ""struct_var"": ""info"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:movenc.c, lines:1-700)"", ""result"": [{""code"": ""static int utf8len(const uint8_t *b)\n{\n    int len = 0;\n    int val;\n    while (*b) {\n        GET_UTF8(val, *b++, return -1;)\n        len++;\n    }\n    return len;\n}"", ""start_line"": 118, ""end_line"": 127, ""full_name"": ""utf8len"", ""file_path"": ""libavformat/movenc.c""}, {""code"": ""static int64_t update_size(AVIOContext *pb, int64_t pos)\n{\n    int64_t curpos = avio_tell(pb);\n    avio_seek(pb, pos, SEEK_SET);\n    avio_wb32(pb, curpos - pos); /* rewrite size */\n    avio_seek(pb, curpos, SEEK_SET);\n\n    return curpos - pos;\n}"", ""start_line"": 130, ""end_line"": 138, ""full_name"": ""update_size<duplicate>2"", ""file_path"": ""libavformat/movenc.c""}, {""code"": ""static int co64_required(const MOVTrack *track)\n{\n    if (track->entry > 0 && track->cluster[track->entry - 1].pos + track->data_offset > UINT32_MAX)\n        return 1;\n    return 0;\n}"", ""start_line"": 140, ""end_line"": 145, ""full_name"": ""co64_required"", ""file_path"": ""libavformat/movenc.c""}]}, {""source"": ""value_info(file:movenc.c, value:info)"", ""result"": {""value_trace"": [{""full_code"": ""info = track->eac3_priv"", ""line"": 536, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info = &track->frag_info[track->nb_frag_info - 1]"", ""line"": 4315, ""func_name"": ""mov_add_tfra_entries""}, {""full_code"": ""*info = &track->frag_info[track->nb_frag_info - 1]"", ""line"": 4389, ""func_name"": ""mov_write_traf_tag""}], ""struct_var"": ""info"", ""struct_type"": ""eac3_info*"", ""struct_definition"": ""struct eac3_info {\n    AVPacket pkt;\n    uint8_t ec3_done;\n    uint8_t num_blocks;\n\n    /* Layout of the EC3SpecificBox */\n    /* maximum bitrate */\n    uint16_t data_rate;\n    /* number of independent substreams */\n    uint8_t  num_ind_sub;\n    struct {\n        /* sample rate code (see ff_ac3_sample_rate_tab) 2 bits */\n        uint8_t fscod;\n        /* bit stream identification 5 bits */\n        uint8_t bsid;\n        /* one bit reserved */\n        /* audio service mixing (not supported yet) 1 bit */\n        /* bit stream mode 3 bits */\n        uint8_t bsmod;\n        /* audio coding mode 3 bits */\n        uint8_t acmod;\n        /* sub woofer on 1 bit */\n        uint8_t lfeon;\n        /* 3 bits reserved */\n        /* number of dependent substreams associated with this substream 4 bits */\n        uint8_t num_dep_sub;\n        /* channel locations of the dependent substream(s), if any, 9 bits */\n        uint16_t chan_loc;\n        /* if there is no dependent substream, then one bit reser...""}}, {""source"": ""code_info(file:movenc.c, lines:1-700)"", ""result"": ""/*\n * MOV, 3GP, MP4 muxer\n * Copyright (c) 2003 Thomas Raivio\n * Copyright (c) 2004 Gildas Bazin <gbazin at videolan dot org>\n * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdint.h>\n#include <inttypes.h>\n\n#include \""movenc.h\""\n#include \""avformat.h\""\n#include \""avio_internal.h\""\n#include \""riff.h\""\n#include \""avio.h\""\n#include \""isom.h\""\n#include \""avc.h\""\n#include \""libavcodec/ac3_parser_internal.h\""\n#include \""libavcodec/dnxhddata.h\""\n#include \""libavcodec/flac.h\""\n#include \""libavcodec/get_bits.h\""\n\n#include \""libavcodec/internal.h\""\n#include \""libavcodec/put_bits.h\""\n#include \""libavcodec/vc1_common.h\""\n#include \""libavcodec/raw.h\""\n#include \""internal.h\""\n#include \""libavutil/avstring.h\""\n#include \""libavutil/intfloat.h\""\n#include \""libavutil/mathematics.h\""\n#include \""libavutil/libm.h\""\n#include \""libavutil/opt.h\""\n#include \""libavutil/dict.h\""\n#include \""libavutil/pixdesc.h\""\n#include \""libavutil/stereo3d.h\""\n#include \""libavutil/timecode.h\""\n#include \""libavutil/color_utils.h\""\n#include \""hevc.h\""\n#include \""rtpenc.h\""\n#include \""mov_chan.h\""\n#include \""vpcc.h\""\n\nstatic const AVOption options[] = {\n    { \""movflags\"", \""MOV muxer flags\"", offsetof(MOVMuxContext, flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""rtphint\"", \""Add RTP hint tracks\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_RTP_HINT}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""moov_size\"", \""maximum moov size so it can be placed at the begin\"", offsetof(MOVMuxContext, reserved_moov_size), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, 0 },\n    { \""empty_moov\"", \""Make the initial moov atom empty\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_EMPTY_MOOV}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""frag_keyframe\"", \""Fragment at video keyframes\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_KEYFRAME}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""frag_every_frame\"", \""Fragment at every frame\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_EVERY_FRAME}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""separate_moof\"", \""Write separate moof/mdat atoms for each track\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_SEPARATE_MOOF}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""frag_custom\"", \""Flush fragments on caller requests\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_CUSTOM}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""isml\"", \""Create a live smooth streaming feed (for pushing to a publishing point)\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_ISML}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""faststart\"", \""Run a second pass to put the index (moov atom) at the beginning of the file\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FASTSTART}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""omit_tfhd_offset\"", \""Omit the base data offset in tfhd atoms\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_OMIT_TFHD_OFFSET}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""disable_chpl\"", \""Disable Nero chapter atom\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DISABLE_CHPL}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""default_base_moof\"", \""Set the default-base-is-moof flag in tfhd atoms\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DEFAULT_BASE_MOOF}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""dash\"", \""Write DASH compatible fragmented MP4\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DASH}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""frag_discont\"", \""Signal that the next fragment is discontinuous from earlier ones\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_DISCONT}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""delay_moov\"", \""Delay writing the initial moov until the first fragment is cut, or until the first fragment flush\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DELAY_MOOV}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""global_sidx\"", \""Write a global sidx index at the start of the file\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_GLOBAL_SIDX}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""write_colr\"", \""Write colr atom (Experimental, may be renamed or changed, do not use from scripts)\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_WRITE_COLR}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""write_gama\"", \""Write deprecated gama atom\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_WRITE_GAMA}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""use_metadata_tags\"", \""Use mdta atom for metadata.\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_USE_MDTA}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""skip_trailer\"", \""Skip writing the mfra/tfra/mfro trailer for fragmented files\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_SKIP_TRAILER}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""negative_cts_offsets\"", \""Use negative CTS offsets (reducing the need for edit lists)\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_NEGATIVE_CTS_OFFSETS}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    FF_RTP_FLAG_OPTS(MOVMuxContext, rtp_flags),\n    { \""skip_iods\"", \""Skip writing iods atom.\"", offsetof(MOVMuxContext, iods_skip), AV_OPT_TYPE_BOOL, {.i64 = 1}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""iods_audio_profile\"", \""iods audio profile atom.\"", offsetof(MOVMuxContext, iods_audio_profile), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 255, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""iods_video_profile\"", \""iods video profile atom.\"", offsetof(MOVMuxContext, iods_video_profile), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 255, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""frag_duration\"", \""Maximum fragment duration\"", offsetof(MOVMuxContext, max_fragment_duration), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""min_frag_duration\"", \""Minimum fragment duration\"", offsetof(MOVMuxContext, min_fragment_duration), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""frag_size\"", \""Maximum fragment size\"", offsetof(MOVMuxContext, max_fragment_size), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""ism_lookahead\"", \""Number of lookahead entries for ISM files\"", offsetof(MOVMuxContext, ism_lookahead), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""video_track_timescale\"", \""set timescale of all video tracks\"", offsetof(MOVMuxContext, video_track_timescale), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""brand\"",    \""Override major brand\"", offsetof(MOVMuxContext, major_brand),   AV_OPT_TYPE_STRING, {.str = NULL}, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \""use_editlist\"", \""use edit list\"", offsetof(MOVMuxContext, use_editlist), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""fragment_index\"", \""Fragment number of the next fragment\"", offsetof(MOVMuxContext, fragments), AV_OPT_TYPE_INT, {.i64 = 1}, 1, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""mov_gamma\"", \""gamma value for gama atom\"", offsetof(MOVMuxContext, gamma), AV_OPT_TYPE_FLOAT, {.dbl = 0.0 }, 0.0, 10, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""frag_interleave\"", \""Interleave samples within fragments (max number of consecutive samples, lower is tighter interleaving, but with more overhead)\"", offsetof(MOVMuxContext, frag_interleave), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM },\n    { \""encryption_scheme\"",    \""Configures the encryption scheme, allowed values are none, cenc-aes-ctr\"", offsetof(MOVMuxContext, encryption_scheme_str),   AV_OPT_TYPE_STRING, {.str = NULL}, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \""encryption_key\"", \""The media encryption key (hex)\"", offsetof(MOVMuxContext, encryption_key), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \""encryption_kid\"", \""The media encryption key identifier (hex)\"", offsetof(MOVMuxContext, encryption_kid), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \""use_stream_ids_as_track_ids\"", \""use stream ids as track ids\"", offsetof(MOVMuxContext, use_stream_ids_as_track_ids), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""write_tmcd\"", \""force or disable writing tmcd\"", offsetof(MOVMuxContext, write_tmcd), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""write_prft\"", \""Write producer reference time box with specified time source\"", offsetof(MOVMuxContext, write_prft), AV_OPT_TYPE_INT, {.i64 = MOV_PRFT_NONE}, 0, MOV_PRFT_NB-1, AV_OPT_FLAG_ENCODING_PARAM, \""prft\""},\n    { \""wallclock\"", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = MOV_PRFT_SRC_WALLCLOCK}, 0, 0, AV_OPT_FLAG_ENCODING_PARAM, \""prft\""},\n    { \""pts\"", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = MOV_PRFT_SRC_PTS}, 0, 0, AV_OPT_FLAG_ENCODING_PARAM, \""prft\""},\n    { \""empty_hdlr_name\"", \""write zero-length name string in hdlr atoms within mdia and minf atoms\"", offsetof(MOVMuxContext, empty_hdlr_name), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { NULL },\n};\n\n#define MOV_CLASS(flavor)\\\nstatic const AVClass flavor ## _muxer_class = {\\\n    .class_name = #flavor \"" muxer\"",\\\n    .item_name  = av_default_item_name,\\\n    .option     = options,\\\n    .version    = LIBAVUTIL_VERSION_INT,\\\n};\n\nstatic int get_moov_size(AVFormatContext *s);\n\nstatic int utf8len(const uint8_t *b)\n{\n    int len = 0;\n    int val;\n    while (*b) {\n        GET_UTF8(val, *b++, return -1;)\n        len++;\n    }\n    return len;\n}\n\n//FIXME support 64 bit variant with wide placeholders\nstatic int64_t update_size(AVIOContext *pb, int64_t pos)\n{\n    int64_t curpos = avio_tell(pb);\n    avio_seek(pb, pos, SEEK_SET);\n    avio_wb32(pb, curpos - pos); /* rewrite size */\n    avio_seek(pb, curpos, SEEK_SET);\n\n    return curpos - pos;\n}\n\nstatic int co64_required(const MOVTrack *track)\n{\n    if (track->entry > 0 && track->cluster[track->entry - 1].pos + track->data_offset > UINT32_MAX)\n        return 1;\n    return 0;\n}\n\nstatic int is_cover_image(const AVStream *st)\n{\n    /* Eg. AV_DISPOSITION_ATTACHED_PIC | AV_DISPOSITION_TIMED_THUMBNAILS\n     * is encoded as sparse video track */\n    return st && st->disposition == AV_DISPOSITION_ATTACHED_PIC;\n}\n\nstatic int rtp_hinting_needed(const AVStream *st)\n{\n    /* Add hint tracks for each real audio and video stream */\n    if (is_cover_image(st))\n        return 0;\n    return st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ||\n           st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO;\n}\n\n/* Chunk offset atom */\nstatic int mov_write_stco_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int i;\n    int mode64 = co64_required(track); // use 32 bit size variant if possible\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    if (mode64)\n        ffio_wfourcc(pb, \""co64\"");\n    else\n        ffio_wfourcc(pb, \""stco\"");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, track->chunkCount); /* entry count */\n    for (i = 0; i < track->entry; i++) {\n        if (!track->cluster[i].chunkNum)\n            continue;\n        if (mode64 == 1)\n            avio_wb64(pb, track->cluster[i].pos + track->data_offset);\n        else\n            avio_wb32(pb, track->cluster[i].pos + track->data_offset);\n    }\n    return update_size(pb, pos);\n}\n\n/* Sample size atom */\nstatic int mov_write_stsz_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int equalChunks = 1;\n    int i, j, entries = 0, tst = -1, oldtst = -1;\n\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \""stsz\"");\n    avio_wb32(pb, 0); /* version & flags */\n\n    for (i = 0; i < track->entry; i++) {\n        tst = track->cluster[i].size / track->cluster[i].entries;\n        if (oldtst != -1 && tst != oldtst)\n            equalChunks = 0;\n        oldtst = tst;\n        entries += track->cluster[i].entries;\n    }\n    if (equalChunks && track->entry) {\n        int sSize = track->entry ? track->cluster[0].size / track->cluster[0].entries : 0;\n        sSize = FFMAX(1, sSize); // adpcm mono case could make sSize == 0\n        avio_wb32(pb, sSize); // sample size\n        avio_wb32(pb, entries); // sample count\n    } else {\n        avio_wb32(pb, 0); // sample size\n        avio_wb32(pb, entries); // sample count\n        for (i = 0; i < track->entry; i++) {\n            for (j = 0; j < track->cluster[i].entries; j++) {\n                avio_wb32(pb, track->cluster[i].size /\n                          track->cluster[i].entries);\n            }\n        }\n    }\n    return update_size(pb, pos);\n}\n\n/* Sample to chunk atom */\nstatic int mov_write_stsc_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int index = 0, oldval = -1, i;\n    int64_t entryPos, curpos;\n\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \""stsc\"");\n    avio_wb32(pb, 0); // version & flags\n    entryPos = avio_tell(pb);\n    avio_wb32(pb, track->chunkCount); // entry count\n    for (i = 0; i < track->entry; i++) {\n        if (oldval != track->cluster[i].samples_in_chunk && track->cluster[i].chunkNum) {\n            avio_wb32(pb, track->cluster[i].chunkNum); // first chunk\n            avio_wb32(pb, track->cluster[i].samples_in_chunk); // samples per chunk\n            avio_wb32(pb, 0x1); // sample description index\n            oldval = track->cluster[i].samples_in_chunk;\n            index++;\n        }\n    }\n    curpos = avio_tell(pb);\n    avio_seek(pb, entryPos, SEEK_SET);\n    avio_wb32(pb, index); // rewrite size\n    avio_seek(pb, curpos, SEEK_SET);\n\n    return update_size(pb, pos);\n}\n\n/* Sync sample atom */\nstatic int mov_write_stss_tag(AVIOContext *pb, MOVTrack *track, uint32_t flag)\n{\n    int64_t curpos, entryPos;\n    int i, index = 0;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); // size\n    ffio_wfourcc(pb, flag == MOV_SYNC_SAMPLE ? \""stss\"" : \""stps\"");\n    avio_wb32(pb, 0); // version & flags\n    entryPos = avio_tell(pb);\n    avio_wb32(pb, track->entry); // entry count\n    for (i = 0; i < track->entry; i++) {\n        if (track->cluster[i].flags & flag) {\n            avio_wb32(pb, i + 1);\n            index++;\n        }\n    }\n    curpos = avio_tell(pb);\n    avio_seek(pb, entryPos, SEEK_SET);\n    avio_wb32(pb, index); // rewrite size\n    avio_seek(pb, curpos, SEEK_SET);\n    return update_size(pb, pos);\n}\n\n/* Sample dependency atom */\nstatic int mov_write_sdtp_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int i;\n    uint8_t leading, dependent, reference, redundancy;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); // size\n    ffio_wfourcc(pb, \""sdtp\"");\n    avio_wb32(pb, 0); // version & flags\n    for (i = 0; i < track->entry; i++) {\n        dependent = MOV_SAMPLE_DEPENDENCY_YES;\n        leading = reference = redundancy = MOV_SAMPLE_DEPENDENCY_UNKNOWN;\n        if (track->cluster[i].flags & MOV_DISPOSABLE_SAMPLE) {\n            reference = MOV_SAMPLE_DEPENDENCY_NO;\n        }\n        if (track->cluster[i].flags & MOV_SYNC_SAMPLE) {\n            dependent = MOV_SAMPLE_DEPENDENCY_NO;\n        }\n        avio_w8(pb, (leading << 6)   | (dependent << 4) |\n                    (reference << 2) | redundancy);\n    }\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_amr_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, 0x11); /* size */\n    if (track->mode == MODE_MOV) ffio_wfourcc(pb, \""samr\"");\n    else                         ffio_wfourcc(pb, \""damr\"");\n    ffio_wfourcc(pb, \""FFMP\"");\n    avio_w8(pb, 0); /* decoder version */\n\n    avio_wb16(pb, 0x81FF); /* Mode set (all modes for AMR_NB) */\n    avio_w8(pb, 0x00); /* Mode change period (no restriction) */\n    avio_w8(pb, 0x01); /* Frames per sample */\n    return 0x11;\n}\n\nstatic int mov_write_ac3_tag(AVIOContext *pb, MOVTrack *track)\n{\n    GetBitContext gbc;\n    PutBitContext pbc;\n    uint8_t buf[3];\n    int fscod, bsid, bsmod, acmod, lfeon, frmsizecod;\n\n    if (track->vos_len < 7)\n        return -1;\n\n    avio_wb32(pb, 11);\n    ffio_wfourcc(pb, \""dac3\"");\n\n    init_get_bits(&gbc, track->vos_data + 4, (track->vos_len - 4) * 8);\n    fscod      = get_bits(&gbc, 2);\n    frmsizecod = get_bits(&gbc, 6);\n    bsid       = get_bits(&gbc, 5);\n    bsmod      = get_bits(&gbc, 3);\n    acmod      = get_bits(&gbc, 3);\n    if (acmod == 2) {\n        skip_bits(&gbc, 2); // dsurmod\n    } else {\n        if ((acmod & 1) && acmod != 1)\n            skip_bits(&gbc, 2); // cmixlev\n        if (acmod & 4)\n            skip_bits(&gbc, 2); // surmixlev\n    }\n    lfeon = get_bits1(&gbc);\n\n    init_put_bits(&pbc, buf, sizeof(buf));\n    put_bits(&pbc, 2, fscod);\n    put_bits(&pbc, 5, bsid);\n    put_bits(&pbc, 3, bsmod);\n    put_bits(&pbc, 3, acmod);\n    put_bits(&pbc, 1, lfeon);\n    put_bits(&pbc, 5, frmsizecod >> 1); // bit_rate_code\n    put_bits(&pbc, 5, 0); // reserved\n\n    flush_put_bits(&pbc);\n    avio_write(pb, buf, sizeof(buf));\n\n    return 11;\n}\n\nstruct eac3_info {\n    AVPacket pkt;\n    uint8_t ec3_done;\n    uint8_t num_blocks;\n\n    /* Layout of the EC3SpecificBox */\n    /* maximum bitrate */\n    uint16_t data_rate;\n    /* number of independent substreams */\n    uint8_t  num_ind_sub;\n    struct {\n        /* sample rate code (see ff_ac3_sample_rate_tab) 2 bits */\n        uint8_t fscod;\n        /* bit stream identification 5 bits */\n        uint8_t bsid;\n        /* one bit reserved */\n        /* audio service mixing (not supported yet) 1 bit */\n        /* bit stream mode 3 bits */\n        uint8_t bsmod;\n        /* audio coding mode 3 bits */\n        uint8_t acmod;\n        /* sub woofer on 1 bit */\n        uint8_t lfeon;\n        /* 3 bits reserved */\n        /* number of dependent substreams associated with this substream 4 bits */\n        uint8_t num_dep_sub;\n        /* channel locations of the dependent substream(s), if any, 9 bits */\n        uint16_t chan_loc;\n        /* if there is no dependent substream, then one bit reserved instead */\n    } substream[1]; /* TODO: support 8 independent substreams */\n};\n\n#if CONFIG_AC3_PARSER\nstatic int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n{\n    AC3HeaderInfo *hdr = NULL;\n    struct eac3_info *info;\n    int num_blocks, ret;\n\n    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))\n        return AVERROR(ENOMEM);\n    info = track->eac3_priv;\n\n    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {\n        /* drop the packets until we see a good one */\n        if (!track->entry) {\n            av_log(mov, AV_LOG_WARNING, \""Dropping invalid packet from start of the stream\\n\"");\n            ret = 0;\n        } else\n            ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);\n    num_blocks = hdr->num_blocks;\n\n    if (!info->ec3_done) {\n        /* AC-3 substream must be the first one */\n        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {\n            ret = AVERROR(EINVAL);\n            goto end;\n        }\n\n        /* this should always be the case, given that our AC-3 parser\n         * concatenates dependent frames to their independent parent */\n        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {\n            /* substream ids must be incremental */\n            if (hdr->substreamid > info->num_ind_sub + 1) {\n                ret = AVERROR(EINVAL);\n                goto end;\n            }\n\n            if (hdr->substreamid == info->num_ind_sub + 1) {\n                //info->num_ind_sub++;\n                avpriv_request_sample(track->par, \""Multiple independent substreams\"");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            } else if (hdr->substreamid < info->num_ind_sub ||\n                       hdr->substreamid == 0 && info->substream[0].bsid) {\n                info->ec3_done = 1;\n                goto concatenate;\n            }\n        }\n\n        /* fill the info needed for the \""dec3\"" atom */\n        info->substream[hdr->substreamid].fscod = hdr->sr_code;\n        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;\n        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;\n        info->substream[hdr->substreamid].acmod = hdr->channel_mode;\n        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt->size != hdr->frame_size) {\n            int cumul_size = hdr->frame_size;\n            int parent = hdr->substreamid;\n\n            while (cumul_size != pkt->size) {\n                GetBitContext gbc;\n                int i;\n                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);\n                if (ret < 0)\n                    goto end;\n                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {\n                    ret = AVERROR(EINVAL);\n                    goto end;\n                }\n                info->substream[parent].num_dep_sub++;\n                ret /= 8;\n\n                /* header is parsed up to lfeon, but custom channel map may be needed */\n                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);\n                /* skip bsid */\n                skip_bits(&gbc, 5);\n                /* skip volume control params */\n                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {\n                    skip_bits(&gbc, 5); // skip dialog normalization\n                    if (get_bits1(&gbc)) {\n                        skip_bits(&gbc, 8); // skip compression gain word\n                    }\n                }\n                /* get the dependent stream channel map, if exists */\n                if (get_bits1(&gbc))\n                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;\n                else\n                    info->substream[parent].chan_loc |= hdr->channel_mode;\n                cumul_size += hdr->frame_size;\n            }\n        }\n    }\n\nconcatenate:\n    if (!info->num_blocks && num_blocks == 6) {\n        ret = pkt->size;\n        goto end;\n    }\n    else if (info->num_blocks + num_blocks > 6) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    if (!info->num_blocks) {\n        ret = av_packet_ref(&info->pkt, pkt);\n        if (!ret)\n            info->num_blocks = num_blocks;\n        goto end;\n    } else {\n        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)\n            goto end;\n        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);\n        info->num_blocks += num_blocks;\n        info->pkt.duration += pkt->duration;\n        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)\n            goto end;\n        if (info->num_blocks != 6)\n            goto end;\n        av_packet_unref(pkt);\n        av_packet_move_ref(pkt, &info->pkt);\n        info->num_blocks = 0;\n    }\n    ret = pkt->size;\n\nend:\n    av_free(hdr);\n\n    return ret;\n}\n#endif\n\nstatic int mov_write_eac3_tag(AVIOContext *pb, MOVTrack *track)\n{\n    PutBitContext pbc;\n    uint8_t *buf;\n    struct eac3_info *info;\n    int size, i;\n\n    if (!track->eac3_priv)\n        return AVERROR(EINVAL);\n\n    info = track->eac3_priv;\n    size = 2 + 4 * (info->num_ind_sub + 1);\n    buf = av_malloc(size);\n    if (!buf) {\n        size = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    init_put_bits(&pbc, buf, size);\n    put_bits(&pbc, 13, info->data_rate);\n    put_bits(&pbc,  3, info->num_ind_sub);\n    for (i = 0; i <= info->num_ind_sub; i++) {\n        put_bits(&pbc, 2, info->substream[i].fscod);\n        put_bits(&pbc, 5, info->substream[i].bsid);\n        put_bits(&pbc, 1, 0); /* reserved */\n        put_bits(&pbc, 1, 0); /* asvc */\n        put_bits(&pbc, 3, info->substream[i].bsmod);\n        put_bits(&pbc, 3, info->substream[i].acmod);\n        put_bits(&pbc, 1, info->substream[i].lfeon);\n        put_bits(&pbc, 5, 0); /* reserved */\n        put_bits(&pbc, 4, info->substream[i].num_dep_sub);\n        if (!info->substream[i].num_dep_sub) {\n            put_bits(&pbc, 1, 0); /* reserved */\n            size--;\n        } else {\n            put_bits(&pbc, 9, info->substream[i].chan_loc);\n        }\n    }\n    flush_put_bits(&pbc);\n\n    avio_wb32(pb, size + 8);\n    ffio_wfourcc(pb, \""dec3\"");\n    avio_write(pb, buf, size);\n\n    av_free(buf);\n\nend:\n    av_packet_unref(&info->pkt);\n    av_freep(&track->eac3_priv);\n\n    return size;\n}\n\n/**\n * This function writes extradata \""as is\"".\n * Extradata must be formatted like a valid atom (with size and tag).\n */\nstatic int mov_write_extradata_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_write(pb, track->par->extradata, track->par->extradata_size);\n    return track->par->extradata_size;\n}\n\nstatic int mov_write_enda_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 10);\n    ffio_wfourcc(pb, \""enda\"");\n    avio_wb16(pb, 1); /* little endian */\n    return 10;\n}\n\nstatic int mov_write_enda_tag_be(AVIOContext *pb)\n{\n  avio_wb32(pb, 10);\n  ffio_wfourcc(pb, \""enda\"");\n  avio_wb16(pb, 0); /* big endian */\n  return 10;\n}\n\nstatic void put_descr(AVIOContext *pb, int tag, unsigned int size)\n{\n    int i = 3;\n    avio_w8(pb, tag);\n    for (; i > 0; i--)\n        avio_w8(pb, (size >> (7 * i)) | 0x80);\n    avio_w8(pb, size & 0x7F);\n}\n\nstatic unsigned compute_avg_bitrate(MOVTrack *track)\n{\n    uint64_t size = 0;\n    int i;\n    if (!track->track_duration)\n        return 0;\n    for (i = 0; i < track->entry; i++)\n        size += track->cluster[i].size;\n    return size * 8 * track->timescale / track->track_duration;\n}\n\nstatic int mov_write_esds_tag(AVIOContext *pb, MOVTrack *track) // Basic\n{\n    AVCPBProperties *props;\n    int64_t pos = avio_tell(pb);\n    int decoder_specific_info_len = track->vos_len ? 5 + track->vos_len : 0;\n    unsigned avg_bitrate;\n\n    avio_wb32(pb, 0); // size\n    ffio_wfourcc(pb, \""esds\"");\n    avio_wb32(pb, 0); // Version\n\n    // ES descriptor\n    put_descr(pb, 0x03, 3 + 5+13 + decoder_specific_info_len + 5+1);\n    avio_wb16(pb, track->track_id);\n    avio_w8(pb, 0x00); // flags (= no flags)\n\n    // DecoderConfig descriptor\n    put_descr(pb, 0x04, 13 + decoder_specific_info_len);\n\n    // Object type indication\n    if ((track->par->codec_id == AV_CODEC_ID_MP2 ||\n         track->par->codec_id == AV_CODEC_ID_MP3) &&\n        track->par->sample_rate > 24000)\n        avio_w8(pb, 0x6B); // 11172-3\n    else\n        avio_w8(pb, ff_codec_get_tag(ff_mp4_obj_type, track->par->codec_id));\n\n    // the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)\n    // plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)\n    if (track->par->codec_id == AV_CODEC_ID_DVD_SUBTITLE)\n        avio_w8(pb, (0x38 << 2) | 1); // flags (= NeroSubpicStream)\n    else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        avio_w8(pb, 0x15); // flags (= Audiostream)\n    else\n        avio_w8(pb, 0x11); // flags (= Visualstream)\n\n    props = (AVCPBProperties*)av_stream_get_side_data(track->st, AV_PKT_DATA_CPB_PROPERTIES,\n                                                      NULL);\n\n    avio_wb24(pb, props ? props->buffer_size / 8 : 0); // Buffersize DB\n\n    avg_bitrate = compute_avg_bitrate(track);\n    avio_wb32(pb, props ? FFMAX3(props->max_bitrate, props->avg_bitrate, avg_bitrate) : FFMAX(track->par->bit_rate, avg_bitrate)); // maxbitrate (FIXME should be max rate in any 1 sec window)\n    avio_wb32(pb, avg_bitrate);\n\n    if (track->vos_len) {\n        // DecoderSpecific info descriptor\n        put_descr(pb, 0x05, track->vos_len);\n        avio_write(pb, track->vos_data, track->vos_len);\n    }\n\n    // SL descriptor\n    put_descr(pb, 0x06, 1);\n    avio_w8(pb, 0x02);\n    return update_size(pb, pos);\n}\n\nstatic int mov_pcm_le_gt16(enum AVCodecID codec_id)\n{\n    return codec_id == AV_CODEC_ID_PCM_S24LE ||\n           codec_id == AV_CODEC_ID_PCM_S32LE ||\n           codec_id == AV_CODEC_ID_PCM_F32LE ||\n           codec_id == AV_CODEC_ID_PCM_F64LE;\n}\n\nstatic int mov_pcm_be_gt16(enum AVCodecID codec_id)\n{\n    return codec_id == AV_CODEC_ID_PCM_S24BE ||\n           codec_id == AV_CODEC_ID_PCM_S32BE ||\n           codec_id == AV_CODEC_ID_PCM_F32BE ||\n           codec_id == AV_CODEC_ID_PCM_F64BE;\n}\n\nstatic int mov_write_ms_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int ret;\n    int64_t pos = avio_tell(pb);\n""}, {""source"": ""value_info(file:movenc.c, value:info->substream)"", ""result"": {""value_trace"": [{""full_code"": ""info->substream"", ""line"": 548, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 549, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 552, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 553, ""func_name"": ""mov_write_eac3_tag""}, {""full_code"": ""info->substream"", ""line"": 554, ""func_name"": ""mov_write_eac3_tag""}], ""struct_var"": ""info"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:movenc.c, lines:1-700)"", ""result"": ""/*\n * MOV, 3GP, MP4 muxer\n * Copyright (c) 2003 Thomas Raivio\n * Copyright (c) 2004 Gildas Bazin <gbazin at videolan dot org>\n * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdint.h>\n#include <inttypes.h>\n\n#include \""movenc.h\""\n#include \""avformat.h\""\n#include \""avio_internal.h\""\n#include \""riff.h\""\n#include \""avio.h\""\n#include \""isom.h\""\n#include \""avc.h\""\n#include \""libavcodec/ac3_parser_internal.h\""\n#include \""libavcodec/dnxhddata.h\""\n#include \""libavcodec/flac.h\""\n#include \""libavcodec/get_bits.h\""\n\n#include \""libavcodec/internal.h\""\n#include \""libavcodec/put_bits.h\""\n#include \""libavcodec/vc1_common.h\""\n#include \""libavcodec/raw.h\""\n#include \""internal.h\""\n#include \""libavutil/avstring.h\""\n#include \""libavutil/intfloat.h\""\n#include \""libavutil/mathematics.h\""\n#include \""libavutil/libm.h\""\n#include \""libavutil/opt.h\""\n#include \""libavutil/dict.h\""\n#include \""libavutil/pixdesc.h\""\n#include \""libavutil/stereo3d.h\""\n#include \""libavutil/timecode.h\""\n#include \""libavutil/color_utils.h\""\n#include \""hevc.h\""\n#include \""rtpenc.h\""\n#include \""mov_chan.h\""\n#include \""vpcc.h\""\n\nstatic const AVOption options[] = {\n    { \""movflags\"", \""MOV muxer flags\"", offsetof(MOVMuxContext, flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""rtphint\"", \""Add RTP hint tracks\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_RTP_HINT}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""moov_size\"", \""maximum moov size so it can be placed at the begin\"", offsetof(MOVMuxContext, reserved_moov_size), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, 0 },\n    { \""empty_moov\"", \""Make the initial moov atom empty\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_EMPTY_MOOV}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""frag_keyframe\"", \""Fragment at video keyframes\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_KEYFRAME}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""frag_every_frame\"", \""Fragment at every frame\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_EVERY_FRAME}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""separate_moof\"", \""Write separate moof/mdat atoms for each track\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_SEPARATE_MOOF}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""frag_custom\"", \""Flush fragments on caller requests\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_CUSTOM}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""isml\"", \""Create a live smooth streaming feed (for pushing to a publishing point)\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_ISML}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""faststart\"", \""Run a second pass to put the index (moov atom) at the beginning of the file\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FASTSTART}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""omit_tfhd_offset\"", \""Omit the base data offset in tfhd atoms\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_OMIT_TFHD_OFFSET}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""disable_chpl\"", \""Disable Nero chapter atom\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DISABLE_CHPL}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""default_base_moof\"", \""Set the default-base-is-moof flag in tfhd atoms\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DEFAULT_BASE_MOOF}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""dash\"", \""Write DASH compatible fragmented MP4\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DASH}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""frag_discont\"", \""Signal that the next fragment is discontinuous from earlier ones\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_DISCONT}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""delay_moov\"", \""Delay writing the initial moov until the first fragment is cut, or until the first fragment flush\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DELAY_MOOV}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""global_sidx\"", \""Write a global sidx index at the start of the file\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_GLOBAL_SIDX}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""write_colr\"", \""Write colr atom (Experimental, may be renamed or changed, do not use from scripts)\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_WRITE_COLR}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""write_gama\"", \""Write deprecated gama atom\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_WRITE_GAMA}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""use_metadata_tags\"", \""Use mdta atom for metadata.\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_USE_MDTA}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""skip_trailer\"", \""Skip writing the mfra/tfra/mfro trailer for fragmented files\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_SKIP_TRAILER}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    { \""negative_cts_offsets\"", \""Use negative CTS offsets (reducing the need for edit lists)\"", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_NEGATIVE_CTS_OFFSETS}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \""movflags\"" },\n    FF_RTP_FLAG_OPTS(MOVMuxContext, rtp_flags),\n    { \""skip_iods\"", \""Skip writing iods atom.\"", offsetof(MOVMuxContext, iods_skip), AV_OPT_TYPE_BOOL, {.i64 = 1}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""iods_audio_profile\"", \""iods audio profile atom.\"", offsetof(MOVMuxContext, iods_audio_profile), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 255, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""iods_video_profile\"", \""iods video profile atom.\"", offsetof(MOVMuxContext, iods_video_profile), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 255, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""frag_duration\"", \""Maximum fragment duration\"", offsetof(MOVMuxContext, max_fragment_duration), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""min_frag_duration\"", \""Minimum fragment duration\"", offsetof(MOVMuxContext, min_fragment_duration), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""frag_size\"", \""Maximum fragment size\"", offsetof(MOVMuxContext, max_fragment_size), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""ism_lookahead\"", \""Number of lookahead entries for ISM files\"", offsetof(MOVMuxContext, ism_lookahead), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""video_track_timescale\"", \""set timescale of all video tracks\"", offsetof(MOVMuxContext, video_track_timescale), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""brand\"",    \""Override major brand\"", offsetof(MOVMuxContext, major_brand),   AV_OPT_TYPE_STRING, {.str = NULL}, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \""use_editlist\"", \""use edit list\"", offsetof(MOVMuxContext, use_editlist), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""fragment_index\"", \""Fragment number of the next fragment\"", offsetof(MOVMuxContext, fragments), AV_OPT_TYPE_INT, {.i64 = 1}, 1, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""mov_gamma\"", \""gamma value for gama atom\"", offsetof(MOVMuxContext, gamma), AV_OPT_TYPE_FLOAT, {.dbl = 0.0 }, 0.0, 10, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""frag_interleave\"", \""Interleave samples within fragments (max number of consecutive samples, lower is tighter interleaving, but with more overhead)\"", offsetof(MOVMuxContext, frag_interleave), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM },\n    { \""encryption_scheme\"",    \""Configures the encryption scheme, allowed values are none, cenc-aes-ctr\"", offsetof(MOVMuxContext, encryption_scheme_str),   AV_OPT_TYPE_STRING, {.str = NULL}, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \""encryption_key\"", \""The media encryption key (hex)\"", offsetof(MOVMuxContext, encryption_key), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \""encryption_kid\"", \""The media encryption key identifier (hex)\"", offsetof(MOVMuxContext, encryption_kid), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \""use_stream_ids_as_track_ids\"", \""use stream ids as track ids\"", offsetof(MOVMuxContext, use_stream_ids_as_track_ids), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""write_tmcd\"", \""force or disable writing tmcd\"", offsetof(MOVMuxContext, write_tmcd), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \""write_prft\"", \""Write producer reference time box with specified time source\"", offsetof(MOVMuxContext, write_prft), AV_OPT_TYPE_INT, {.i64 = MOV_PRFT_NONE}, 0, MOV_PRFT_NB-1, AV_OPT_FLAG_ENCODING_PARAM, \""prft\""},\n    { \""wallclock\"", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = MOV_PRFT_SRC_WALLCLOCK}, 0, 0, AV_OPT_FLAG_ENCODING_PARAM, \""prft\""},\n    { \""pts\"", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = MOV_PRFT_SRC_PTS}, 0, 0, AV_OPT_FLAG_ENCODING_PARAM, \""prft\""},\n    { \""empty_hdlr_name\"", \""write zero-length name string in hdlr atoms within mdia and minf atoms\"", offsetof(MOVMuxContext, empty_hdlr_name), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { NULL },\n};\n\n#define MOV_CLASS(flavor)\\\nstatic const AVClass flavor ## _muxer_class = {\\\n    .class_name = #flavor \"" muxer\"",\\\n    .item_name  = av_default_item_name,\\\n    .option     = options,\\\n    .version    = LIBAVUTIL_VERSION_INT,\\\n};\n\nstatic int get_moov_size(AVFormatContext *s);\n\nstatic int utf8len(const uint8_t *b)\n{\n    int len = 0;\n    int val;\n    while (*b) {\n        GET_UTF8(val, *b++, return -1;)\n        len++;\n    }\n    return len;\n}\n\n//FIXME support 64 bit variant with wide placeholders\nstatic int64_t update_size(AVIOContext *pb, int64_t pos)\n{\n    int64_t curpos = avio_tell(pb);\n    avio_seek(pb, pos, SEEK_SET);\n    avio_wb32(pb, curpos - pos); /* rewrite size */\n    avio_seek(pb, curpos, SEEK_SET);\n\n    return curpos - pos;\n}\n\nstatic int co64_required(const MOVTrack *track)\n{\n    if (track->entry > 0 && track->cluster[track->entry - 1].pos + track->data_offset > UINT32_MAX)\n        return 1;\n    return 0;\n}\n\nstatic int is_cover_image(const AVStream *st)\n{\n    /* Eg. AV_DISPOSITION_ATTACHED_PIC | AV_DISPOSITION_TIMED_THUMBNAILS\n     * is encoded as sparse video track */\n    return st && st->disposition == AV_DISPOSITION_ATTACHED_PIC;\n}\n\nstatic int rtp_hinting_needed(const AVStream *st)\n{\n    /* Add hint tracks for each real audio and video stream */\n    if (is_cover_image(st))\n        return 0;\n    return st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ||\n           st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO;\n}\n\n/* Chunk offset atom */\nstatic int mov_write_stco_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int i;\n    int mode64 = co64_required(track); // use 32 bit size variant if possible\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    if (mode64)\n        ffio_wfourcc(pb, \""co64\"");\n    else\n        ffio_wfourcc(pb, \""stco\"");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, track->chunkCount); /* entry count */\n    for (i = 0; i < track->entry; i++) {\n        if (!track->cluster[i].chunkNum)\n            continue;\n        if (mode64 == 1)\n            avio_wb64(pb, track->cluster[i].pos + track->data_offset);\n        else\n            avio_wb32(pb, track->cluster[i].pos + track->data_offset);\n    }\n    return update_size(pb, pos);\n}\n\n/* Sample size atom */\nstatic int mov_write_stsz_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int equalChunks = 1;\n    int i, j, entries = 0, tst = -1, oldtst = -1;\n\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \""stsz\"");\n    avio_wb32(pb, 0); /* version & flags */\n\n    for (i = 0; i < track->entry; i++) {\n        tst = track->cluster[i].size / track->cluster[i].entries;\n        if (oldtst != -1 && tst != oldtst)\n            equalChunks = 0;\n        oldtst = tst;\n        entries += track->cluster[i].entries;\n    }\n    if (equalChunks && track->entry) {\n        int sSize = track->entry ? track->cluster[0].size / track->cluster[0].entries : 0;\n        sSize = FFMAX(1, sSize); // adpcm mono case could make sSize == 0\n        avio_wb32(pb, sSize); // sample size\n        avio_wb32(pb, entries); // sample count\n    } else {\n        avio_wb32(pb, 0); // sample size\n        avio_wb32(pb, entries); // sample count\n        for (i = 0; i < track->entry; i++) {\n            for (j = 0; j < track->cluster[i].entries; j++) {\n                avio_wb32(pb, track->cluster[i].size /\n                          track->cluster[i].entries);\n            }\n        }\n    }\n    return update_size(pb, pos);\n}\n\n/* Sample to chunk atom */\nstatic int mov_write_stsc_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int index = 0, oldval = -1, i;\n    int64_t entryPos, curpos;\n\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \""stsc\"");\n    avio_wb32(pb, 0); // version & flags\n    entryPos = avio_tell(pb);\n    avio_wb32(pb, track->chunkCount); // entry count\n    for (i = 0; i < track->entry; i++) {\n        if (oldval != track->cluster[i].samples_in_chunk && track->cluster[i].chunkNum) {\n            avio_wb32(pb, track->cluster[i].chunkNum); // first chunk\n            avio_wb32(pb, track->cluster[i].samples_in_chunk); // samples per chunk\n            avio_wb32(pb, 0x1); // sample description index\n            oldval = track->cluster[i].samples_in_chunk;\n            index++;\n        }\n    }\n    curpos = avio_tell(pb);\n    avio_seek(pb, entryPos, SEEK_SET);\n    avio_wb32(pb, index); // rewrite size\n    avio_seek(pb, curpos, SEEK_SET);\n\n    return update_size(pb, pos);\n}\n\n/* Sync sample atom */\nstatic int mov_write_stss_tag(AVIOContext *pb, MOVTrack *track, uint32_t flag)\n{\n    int64_t curpos, entryPos;\n    int i, index = 0;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); // size\n    ffio_wfourcc(pb, flag == MOV_SYNC_SAMPLE ? \""stss\"" : \""stps\"");\n    avio_wb32(pb, 0); // version & flags\n    entryPos = avio_tell(pb);\n    avio_wb32(pb, track->entry); // entry count\n    for (i = 0; i < track->entry; i++) {\n        if (track->cluster[i].flags & flag) {\n            avio_wb32(pb, i + 1);\n            index++;\n        }\n    }\n    curpos = avio_tell(pb);\n    avio_seek(pb, entryPos, SEEK_SET);\n    avio_wb32(pb, index); // rewrite size\n    avio_seek(pb, curpos, SEEK_SET);\n    return update_size(pb, pos);\n}\n\n/* Sample dependency atom */\nstatic int mov_write_sdtp_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int i;\n    uint8_t leading, dependent, reference, redundancy;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); // size\n    ffio_wfourcc(pb, \""sdtp\"");\n    avio_wb32(pb, 0); // version & flags\n    for (i = 0; i < track->entry; i++) {\n        dependent = MOV_SAMPLE_DEPENDENCY_YES;\n        leading = reference = redundancy = MOV_SAMPLE_DEPENDENCY_UNKNOWN;\n        if (track->cluster[i].flags & MOV_DISPOSABLE_SAMPLE) {\n            reference = MOV_SAMPLE_DEPENDENCY_NO;\n        }\n        if (track->cluster[i].flags & MOV_SYNC_SAMPLE) {\n            dependent = MOV_SAMPLE_DEPENDENCY_NO;\n        }\n        avio_w8(pb, (leading << 6)   | (dependent << 4) |\n                    (reference << 2) | redundancy);\n    }\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_amr_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, 0x11); /* size */\n    if (track->mode == MODE_MOV) ffio_wfourcc(pb, \""samr\"");\n    else                         ffio_wfourcc(pb, \""damr\"");\n    ffio_wfourcc(pb, \""FFMP\"");\n    avio_w8(pb, 0); /* decoder version */\n\n    avio_wb16(pb, 0x81FF); /* Mode set (all modes for AMR_NB) */\n    avio_w8(pb, 0x00); /* Mode change period (no restriction) */\n    avio_w8(pb, 0x01); /* Frames per sample */\n    return 0x11;\n}\n\nstatic int mov_write_ac3_tag(AVIOContext *pb, MOVTrack *track)\n{\n    GetBitContext gbc;\n    PutBitContext pbc;\n    uint8_t buf[3];\n    int fscod, bsid, bsmod, acmod, lfeon, frmsizecod;\n\n    if (track->vos_len < 7)\n        return -1;\n\n    avio_wb32(pb, 11);\n    ffio_wfourcc(pb, \""dac3\"");\n\n    init_get_bits(&gbc, track->vos_data + 4, (track->vos_len - 4) * 8);\n    fscod      = get_bits(&gbc, 2);\n    frmsizecod = get_bits(&gbc, 6);\n    bsid       = get_bits(&gbc, 5);\n    bsmod      = get_bits(&gbc, 3);\n    acmod      = get_bits(&gbc, 3);\n    if (acmod == 2) {\n        skip_bits(&gbc, 2); // dsurmod\n    } else {\n        if ((acmod & 1) && acmod != 1)\n            skip_bits(&gbc, 2); // cmixlev\n        if (acmod & 4)\n            skip_bits(&gbc, 2); // surmixlev\n    }\n    lfeon = get_bits1(&gbc);\n\n    init_put_bits(&pbc, buf, sizeof(buf));\n    put_bits(&pbc, 2, fscod);\n    put_bits(&pbc, 5, bsid);\n    put_bits(&pbc, 3, bsmod);\n    put_bits(&pbc, 3, acmod);\n    put_bits(&pbc, 1, lfeon);\n    put_bits(&pbc, 5, frmsizecod >> 1); // bit_rate_code\n    put_bits(&pbc, 5, 0); // reserved\n\n    flush_put_bits(&pbc);\n    avio_write(pb, buf, sizeof(buf));\n\n    return 11;\n}\n\nstruct eac3_info {\n    AVPacket pkt;\n    uint8_t ec3_done;\n    uint8_t num_blocks;\n\n    /* Layout of the EC3SpecificBox */\n    /* maximum bitrate */\n    uint16_t data_rate;\n    /* number of independent substreams */\n    uint8_t  num_ind_sub;\n    struct {\n        /* sample rate code (see ff_ac3_sample_rate_tab) 2 bits */\n        uint8_t fscod;\n        /* bit stream identification 5 bits */\n        uint8_t bsid;\n        /* one bit reserved */\n        /* audio service mixing (not supported yet) 1 bit */\n        /* bit stream mode 3 bits */\n        uint8_t bsmod;\n        /* audio coding mode 3 bits */\n        uint8_t acmod;\n        /* sub woofer on 1 bit */\n        uint8_t lfeon;\n        /* 3 bits reserved */\n        /* number of dependent substreams associated with this substream 4 bits */\n        uint8_t num_dep_sub;\n        /* channel locations of the dependent substream(s), if any, 9 bits */\n        uint16_t chan_loc;\n        /* if there is no dependent substream, then one bit reserved instead */\n    } substream[1]; /* TODO: support 8 independent substreams */\n};\n\n#if CONFIG_AC3_PARSER\nstatic int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n{\n    AC3HeaderInfo *hdr = NULL;\n    struct eac3_info *info;\n    int num_blocks, ret;\n\n    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))\n        return AVERROR(ENOMEM);\n    info = track->eac3_priv;\n\n    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {\n        /* drop the packets until we see a good one */\n        if (!track->entry) {\n            av_log(mov, AV_LOG_WARNING, \""Dropping invalid packet from start of the stream\\n\"");\n            ret = 0;\n        } else\n            ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);\n    num_blocks = hdr->num_blocks;\n\n    if (!info->ec3_done) {\n        /* AC-3 substream must be the first one */\n        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {\n            ret = AVERROR(EINVAL);\n            goto end;\n        }\n\n        /* this should always be the case, given that our AC-3 parser\n         * concatenates dependent frames to their independent parent */\n        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {\n            /* substream ids must be incremental */\n            if (hdr->substreamid > info->num_ind_sub + 1) {\n                ret = AVERROR(EINVAL);\n                goto end;\n            }\n\n            if (hdr->substreamid == info->num_ind_sub + 1) {\n                //info->num_ind_sub++;\n                avpriv_request_sample(track->par, \""Multiple independent substreams\"");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            } else if (hdr->substreamid < info->num_ind_sub ||\n                       hdr->substreamid == 0 && info->substream[0].bsid) {\n                info->ec3_done = 1;\n                goto concatenate;\n            }\n        }\n\n        /* fill the info needed for the \""dec3\"" atom */\n        info->substream[hdr->substreamid].fscod = hdr->sr_code;\n        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;\n        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;\n        info->substream[hdr->substreamid].acmod = hdr->channel_mode;\n        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt->size != hdr->frame_size) {\n            int cumul_size = hdr->frame_size;\n            int parent = hdr->substreamid;\n\n            while (cumul_size != pkt->size) {\n                GetBitContext gbc;\n                int i;\n                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);\n                if (ret < 0)\n                    goto end;\n                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {\n                    ret = AVERROR(EINVAL);\n                    goto end;\n                }\n                info->substream[parent].num_dep_sub++;\n                ret /= 8;\n\n                /* header is parsed up to lfeon, but custom channel map may be needed */\n                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);\n                /* skip bsid */\n                skip_bits(&gbc, 5);\n                /* skip volume control params */\n                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {\n                    skip_bits(&gbc, 5); // skip dialog normalization\n                    if (get_bits1(&gbc)) {\n                        skip_bits(&gbc, 8); // skip compression gain word\n                    }\n                }\n                /* get the dependent stream channel map, if exists */\n                if (get_bits1(&gbc))\n                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;\n                else\n                    info->substream[parent].chan_loc |= hdr->channel_mode;\n                cumul_size += hdr->frame_size;\n            }\n        }\n    }\n\nconcatenate:\n    if (!info->num_blocks && num_blocks == 6) {\n        ret = pkt->size;\n        goto end;\n    }\n    else if (info->num_blocks + num_blocks > 6) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    if (!info->num_blocks) {\n        ret = av_packet_ref(&info->pkt, pkt);\n        if (!ret)\n            info->num_blocks = num_blocks;\n        goto end;\n    } else {\n        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)\n            goto end;\n        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);\n        info->num_blocks += num_blocks;\n        info->pkt.duration += pkt->duration;\n        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)\n            goto end;\n        if (info->num_blocks != 6)\n            goto end;\n        av_packet_unref(pkt);\n        av_packet_move_ref(pkt, &info->pkt);\n        info->num_blocks = 0;\n    }\n    ret = pkt->size;\n\nend:\n    av_free(hdr);\n\n    return ret;\n}\n#endif\n\nstatic int mov_write_eac3_tag(AVIOContext *pb, MOVTrack *track)\n{\n    PutBitContext pbc;\n    uint8_t *buf;\n    struct eac3_info *info;\n    int size, i;\n\n    if (!track->eac3_priv)\n        return AVERROR(EINVAL);\n\n    info = track->eac3_priv;\n    size = 2 + 4 * (info->num_ind_sub + 1);\n    buf = av_malloc(size);\n    if (!buf) {\n        size = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    init_put_bits(&pbc, buf, size);\n    put_bits(&pbc, 13, info->data_rate);\n    put_bits(&pbc,  3, info->num_ind_sub);\n    for (i = 0; i <= info->num_ind_sub; i++) {\n        put_bits(&pbc, 2, info->substream[i].fscod);\n        put_bits(&pbc, 5, info->substream[i].bsid);\n        put_bits(&pbc, 1, 0); /* reserved */\n        put_bits(&pbc, 1, 0); /* asvc */\n        put_bits(&pbc, 3, info->substream[i].bsmod);\n        put_bits(&pbc, 3, info->substream[i].acmod);\n        put_bits(&pbc, 1, info->substream[i].lfeon);\n        put_bits(&pbc, 5, 0); /* reserved */\n        put_bits(&pbc, 4, info->substream[i].num_dep_sub);\n        if (!info->substream[i].num_dep_sub) {\n            put_bits(&pbc, 1, 0); /* reserved */\n            size--;\n        } else {\n            put_bits(&pbc, 9, info->substream[i].chan_loc);\n        }\n    }\n    flush_put_bits(&pbc);\n\n    avio_wb32(pb, size + 8);\n    ffio_wfourcc(pb, \""dec3\"");\n    avio_write(pb, buf, size);\n\n    av_free(buf);\n\nend:\n    av_packet_unref(&info->pkt);\n    av_freep(&track->eac3_priv);\n\n    return size;\n}\n\n/**\n * This function writes extradata \""as is\"".\n * Extradata must be formatted like a valid atom (with size and tag).\n */\nstatic int mov_write_extradata_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_write(pb, track->par->extradata, track->par->extradata_size);\n    return track->par->extradata_size;\n}\n\nstatic int mov_write_enda_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 10);\n    ffio_wfourcc(pb, \""enda\"");\n    avio_wb16(pb, 1); /* little endian */\n    return 10;\n}\n\nstatic int mov_write_enda_tag_be(AVIOContext *pb)\n{\n  avio_wb32(pb, 10);\n  ffio_wfourcc(pb, \""enda\"");\n  avio_wb16(pb, 0); /* big endian */\n  return 10;\n}\n\nstatic void put_descr(AVIOContext *pb, int tag, unsigned int size)\n{\n    int i = 3;\n    avio_w8(pb, tag);\n    for (; i > 0; i--)\n        avio_w8(pb, (size >> (7 * i)) | 0x80);\n    avio_w8(pb, size & 0x7F);\n}\n\nstatic unsigned compute_avg_bitrate(MOVTrack *track)\n{\n    uint64_t size = 0;\n    int i;\n    if (!track->track_duration)\n        return 0;\n    for (i = 0; i < track->entry; i++)\n        size += track->cluster[i].size;\n    return size * 8 * track->timescale / track->track_duration;\n}\n\nstatic int mov_write_esds_tag(AVIOContext *pb, MOVTrack *track) // Basic\n{\n    AVCPBProperties *props;\n    int64_t pos = avio_tell(pb);\n    int decoder_specific_info_len = track->vos_len ? 5 + track->vos_len : 0;\n    unsigned avg_bitrate;\n\n    avio_wb32(pb, 0); // size\n    ffio_wfourcc(pb, \""esds\"");\n    avio_wb32(pb, 0); // Version\n\n    // ES descriptor\n    put_descr(pb, 0x03, 3 + 5+13 + decoder_specific_info_len + 5+1);\n    avio_wb16(pb, track->track_id);\n    avio_w8(pb, 0x00); // flags (= no flags)\n\n    // DecoderConfig descriptor\n    put_descr(pb, 0x04, 13 + decoder_specific_info_len);\n\n    // Object type indication\n    if ((track->par->codec_id == AV_CODEC_ID_MP2 ||\n         track->par->codec_id == AV_CODEC_ID_MP3) &&\n        track->par->sample_rate > 24000)\n        avio_w8(pb, 0x6B); // 11172-3\n    else\n        avio_w8(pb, ff_codec_get_tag(ff_mp4_obj_type, track->par->codec_id));\n\n    // the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)\n    // plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)\n    if (track->par->codec_id == AV_CODEC_ID_DVD_SUBTITLE)\n        avio_w8(pb, (0x38 << 2) | 1); // flags (= NeroSubpicStream)\n    else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        avio_w8(pb, 0x15); // flags (= Audiostream)\n    else\n        avio_w8(pb, 0x11); // flags (= Visualstream)\n\n    props = (AVCPBProperties*)av_stream_get_side_data(track->st, AV_PKT_DATA_CPB_PROPERTIES,\n                                                      NULL);\n\n    avio_wb24(pb, props ? props->buffer_size / 8 : 0); // Buffersize DB\n\n    avg_bitrate = compute_avg_bitrate(track);\n    avio_wb32(pb, props ? FFMAX3(props->max_bitrate, props->avg_bitrate, avg_bitrate) : FFMAX(track->par->bit_rate, avg_bitrate)); // maxbitrate (FIXME should be max rate in any 1 sec window)\n    avio_wb32(pb, avg_bitrate);\n\n    if (track->vos_len) {\n        // DecoderSpecific info descriptor\n        put_descr(pb, 0x05, track->vos_len);\n        avio_write(pb, track->vos_data, track->vos_len);\n    }\n\n    // SL descriptor\n    put_descr(pb, 0x06, 1);\n    avio_w8(pb, 0x02);\n    return update_size(pb, pos);\n}\n\nstatic int mov_pcm_le_gt16(enum AVCodecID codec_id)\n{\n    return codec_id == AV_CODEC_ID_PCM_S24LE ||\n           codec_id == AV_CODEC_ID_PCM_S32LE ||\n           codec_id == AV_CODEC_ID_PCM_F32LE ||\n           codec_id == AV_CODEC_ID_PCM_F64LE;\n}\n\nstatic int mov_pcm_be_gt16(enum AVCodecID codec_id)\n{\n    return codec_id == AV_CODEC_ID_PCM_S24BE ||\n           codec_id == AV_CODEC_ID_PCM_S32BE ||\n           codec_id == AV_CODEC_ID_PCM_F32BE ||\n           codec_id == AV_CODEC_ID_PCM_F64BE;\n}\n\nstatic int mov_write_ms_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int ret;\n    int64_t pos = avio_tell(pb);\n""}]","libavformat/movenc.c:430-450: Unchecked access to 'info->substream[hdr->substreamid]' in 'handle_eac3' for non-EAC3_FRAME_TYPE_INDEPENDENT frames. The 'eac3_info' struct (libavformat/movenc.c: defined in struct eac3_info) declares 'substream[1]' as a fixed-size array, but 'hdr->substreamid' is used without bounds checking. When 'hdr->substreamid' > 0 (allowed for non-independent frames prior to the patch), this causes out-of-bounds access. The patch (libavformat/movenc.c:437-443) adds a check to reject such cases, confirming the prior flaw.",0.95,./github/other_context/CVE-2018-13302
24,CVE-2018-14357,CWE-78,c_cpp,"An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.",https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725,quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>,5,"[{""func_name"": ""imap_auth_login"", ""file_path"": ""imap/auth_login.c"", ""func_code"": ""enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\""LOGIN disabled on this server.\""));\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  mutt_message(_(\""Logging in...\""));\n\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n\n  /* don't print the password unless we're at the ungodly debugging level\n   * of 5 or higher */\n\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \""Sending LOGIN command for %s...\\n\"", idata->conn->account.user);\n\n  snprintf(buf, sizeof(buf), \""LOGIN %s %s\"", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n\n  if (!rc)\n  {\n    mutt_clear_error(); /* clear \""Logging in...\"".  fixes #3524 */\n    return IMAP_AUTH_SUCCESS;\n  }\n\n  mutt_error(_(\""Login failed.\""));\n  return IMAP_AUTH_FAILURE;\n}"", ""target"": 0}, {""func_name"": ""compile_search"", ""file_path"": ""imap/imap.c"", ""func_code"": ""static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)\n{\n  if (do_search(pat, 0) == 0)\n    return 0;\n\n  if (pat->not)\n    mutt_buffer_addstr(buf, \""NOT \"");\n\n  if (pat->child)\n  {\n    int clauses;\n\n    clauses = do_search(pat->child, 1);\n    if (clauses > 0)\n    {\n      const struct Pattern *clause = pat->child;\n\n      mutt_buffer_addch(buf, '(');\n\n      while (clauses)\n      {\n        if (do_search(clause, 0))\n        {\n          if (pat->op == MUTT_OR && clauses > 1)\n            mutt_buffer_addstr(buf, \""OR \"");\n          clauses--;\n\n          if (compile_search(ctx, clause, buf) < 0)\n            return -1;\n\n          if (clauses)\n            mutt_buffer_addch(buf, ' ');\n        }\n        clause = clause->next;\n      }\n\n      mutt_buffer_addch(buf, ')');\n    }\n  }\n  else\n  {\n    char term[STRING];\n    char *delim = NULL;\n\n    switch (pat->op)\n    {\n      case MUTT_HEADER:\n        mutt_buffer_addstr(buf, \""HEADER \"");\n\n        /* extract header name */\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\""Header search without header name: %s\""), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \""BODY \"");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \""TEXT \"");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\""Server-side custom search not supported: %s\""), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \""X-GM-RAW \"");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}"", ""target"": 0}, {""func_name"": ""cmd_parse_lsub"", ""file_path"": ""imap/command.c"", ""func_code"": ""static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(idata, s);\n    return;\n  }\n\n  if (!ImapCheckSubscribed)\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \""Subscribing to %s\\n\"", list.name);\n\n  mutt_str_strfcpy(buf, \""mailboxes \\\""\"", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \"" */\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \""\\\""\"");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \""Error adding subscribed mailbox: %s\\n\"", errstr);\n  FREE(&token.data);\n}"", ""target"": 0}, {""func_name"": ""imap_quote_string"", ""file_path"": ""imap/util.c"", ""func_code"": ""void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \""\\\""\\\\\"";\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\""';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\""';\n  *pt = '\\0';\n}"", ""target"": 0}, {""func_name"": ""imap_munge_mbox_name"", ""file_path"": ""imap/util.c"", ""func_code"": ""void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf);\n\n  FREE(&buf);\n}"", ""target"": 0}]","[{""func_name"": ""imap_auth_login"", ""file_path"": ""imap/auth_login.c"", ""func_code"": ""enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\""LOGIN disabled on this server.\""));\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  mutt_message(_(\""Logging in...\""));\n\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);\n\n  /* don't print the password unless we're at the ungodly debugging level\n   * of 5 or higher */\n\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \""Sending LOGIN command for %s...\\n\"", idata->conn->account.user);\n\n  snprintf(buf, sizeof(buf), \""LOGIN %s %s\"", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n\n  if (!rc)\n  {\n    mutt_clear_error(); /* clear \""Logging in...\"".  fixes #3524 */\n    return IMAP_AUTH_SUCCESS;\n  }\n\n  mutt_error(_(\""Login failed.\""));\n  return IMAP_AUTH_FAILURE;\n}""}, {""func_name"": ""compile_search"", ""file_path"": ""imap/imap.c"", ""func_code"": ""static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)\n{\n  if (do_search(pat, 0) == 0)\n    return 0;\n\n  if (pat->not)\n    mutt_buffer_addstr(buf, \""NOT \"");\n\n  if (pat->child)\n  {\n    int clauses;\n\n    clauses = do_search(pat->child, 1);\n    if (clauses > 0)\n    {\n      const struct Pattern *clause = pat->child;\n\n      mutt_buffer_addch(buf, '(');\n\n      while (clauses)\n      {\n        if (do_search(clause, 0))\n        {\n          if (pat->op == MUTT_OR && clauses > 1)\n            mutt_buffer_addstr(buf, \""OR \"");\n          clauses--;\n\n          if (compile_search(ctx, clause, buf) < 0)\n            return -1;\n\n          if (clauses)\n            mutt_buffer_addch(buf, ' ');\n        }\n        clause = clause->next;\n      }\n\n      mutt_buffer_addch(buf, ')');\n    }\n  }\n  else\n  {\n    char term[STRING];\n    char *delim = NULL;\n\n    switch (pat->op)\n    {\n      case MUTT_HEADER:\n        mutt_buffer_addstr(buf, \""HEADER \"");\n\n        /* extract header name */\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\""Header search without header name: %s\""), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \""BODY \"");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \""TEXT \"");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\""Server-side custom search not supported: %s\""), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \""X-GM-RAW \"");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}""}, {""func_name"": ""cmd_parse_lsub"", ""file_path"": ""imap/command.c"", ""func_code"": ""static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(idata, s);\n    return;\n  }\n\n  if (!ImapCheckSubscribed)\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \""Subscribing to %s\\n\"", list.name);\n\n  mutt_str_strfcpy(buf, \""mailboxes \\\""\"", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \"" */\n  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \""\\\""\"");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \""Error adding subscribed mailbox: %s\\n\"", errstr);\n  FREE(&token.data);\n}""}, {""func_name"": ""imap_quote_string"", ""file_path"": ""imap/util.c"", ""func_code"": ""void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \""`\\\""\\\\\"";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\""';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\""';\n  *pt = '\\0';\n}""}, {""func_name"": ""imap_munge_mbox_name"", ""file_path"": ""imap/util.c"", ""func_code"": ""void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf, false);\n\n  FREE(&buf);\n}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(file:util.c, func:imap_quote_string)"", ""result"": [{""code"": ""void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \""\\\""\\\\\"";\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\""';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\""';\n  *pt = '\\0';\n}"", ""start_line"": 801, ""end_line"": 829, ""full_name"": ""imap_quote_string"", ""file_path"": ""imap/util.c""}]}, {""source"": ""code_info(file:util.c, lines:802-805)"", ""result"": ""{\n  static const char quote[] = \""\\\""\\\\\"";\n  char *pt = dest;\n  const char *s = src;\n\n""}]","imap/util.c:802-805 (pre-patch): The `imap_quote_string` function used `static const char quote[] = ""\\\"";`, escaping only backslashes and double quotes. Backticks were not escaped, allowing them to be injected into IMAP commands. The patch adds a `quote_backtick` flag to conditionally escape backticks. Vulnerable contexts (e.g., `compile_search`, `imap_auth_login`) passed `false`, leaving backticks unescaped in user-controlled data like search terms or credentials. This enabled remote IMAP servers to execute arbitrary commands via backtick injection in mailbox names or other inputs.",0.95,./github/other_context/CVE-2018-14357
25,CVE-2018-14361,CWE-20,c_cpp,An issue was discovered in NeoMutt before 2018-07-16. nntp.c proceeds even if memory allocation fails for messages data.,https://github.com/neomutt/neomutt/commit/9e927affe3a021175f354af5fa01d22657c20585,Add alloc fail check in nntp_fetch_headers,1,"[{""func_name"": ""nntp_fetch_headers"", ""file_path"": ""nntp.c"", ""func_code"": ""static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\n                              anum_t last, int restore)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct FetchCtx fc;\n  struct Header *hdr = NULL;\n  char buf[HUGE_STRING];\n  int rc = 0;\n  int oldmsgcount = ctx->msgcount;\n  anum_t current;\n  anum_t first_over = first;\n#ifdef USE_HCACHE\n  void *hdata = NULL;\n#endif\n\n  /* if empty group or nothing to do */\n  if (!last || first > last)\n    return 0;\n\n  /* init fetch context */\n  fc.ctx = ctx;\n  fc.first = first;\n  fc.last = last;\n  fc.restore = restore;\n  fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n#ifdef USE_HCACHE\n  fc.hc = hc;\n#endif\n\n  /* fetch list of articles */\n  if (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n  {\n    if (!ctx->quiet)\n      mutt_message(_(\""Fetching list of articles...\""));\n    if (nntp_data->nserv->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \""LISTGROUP %s %u-%u\\r\\n\"", nntp_data->group, first, last);\n    else\n      snprintf(buf, sizeof(buf), \""LISTGROUP %s\\r\\n\"", nntp_data->group);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\""LISTGROUP: %s\"", buf);\n    }\n    if (rc == 0)\n    {\n      for (current = first; current <= last && rc == 0; current++)\n      {\n        if (fc.messages[current - first])\n          continue;\n\n        snprintf(buf, sizeof(buf), \""%u\"", current);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \""#1 mutt_bcache_del %s\\n\"", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n\n#ifdef USE_HCACHE\n        if (fc.hc)\n        {\n          mutt_debug(2, \""mutt_hcache_delete %s\\n\"", buf);\n          mutt_hcache_delete(fc.hc, buf, strlen(buf));\n        }\n#endif\n      }\n    }\n  }\n  else\n  {\n    for (current = first; current <= last; current++)\n      fc.messages[current - first] = 1;\n  }\n\n  /* fetching header from cache or server, or fallback to fetch overview */\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&fc.progress, _(\""Fetching message headers...\""),\n                       MUTT_PROGRESS_MSG, ReadInc, last - first + 1);\n  }\n  for (current = first; current <= last && rc == 0; current++)\n  {\n    if (!ctx->quiet)\n      mutt_progress_update(&fc.progress, current - first + 1, -1);\n\n#ifdef USE_HCACHE\n    snprintf(buf, sizeof(buf), \""%u\"", current);\n#endif\n\n    /* delete header from cache that does not exist on server */\n    if (!fc.messages[current - first])\n      continue;\n\n    /* allocate memory for headers */\n    if (ctx->msgcount >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n#ifdef USE_HCACHE\n    /* try to fetch header from cache */\n    hdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf));\n    if (hdata)\n    {\n      mutt_debug(2, \""mutt_hcache_fetch %s\\n\"", buf);\n      ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n      mutt_hcache_free(fc.hc, &hdata);\n      hdr->data = 0;\n\n      /* skip header marked as deleted in cache */\n      if (hdr->deleted && !restore)\n      {\n        mutt_header_free(&hdr);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \""#2 mutt_bcache_del %s\\n\"", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        continue;\n      }\n\n      hdr->read = false;\n      hdr->old = false;\n    }\n    else\n#endif\n\n        /* don't try to fetch header from removed newsgroup */\n        if (nntp_data->deleted)\n      continue;\n\n    /* fallback to fetch overview */\n    else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)\n    {\n      if (NntpListgroup && nntp_data->nserv->hasLISTGROUP)\n        break;\n      else\n        continue;\n    }\n\n    /* fetch header from server */\n    else\n    {\n      FILE *fp = mutt_file_mkstemp();\n      if (!fp)\n      {\n        mutt_perror(\""mutt_file_mkstemp() failed!\"");\n        rc = -1;\n        break;\n      }\n\n      snprintf(buf, sizeof(buf), \""HEAD %u\\r\\n\"", current);\n      rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n      if (rc)\n      {\n        mutt_file_fclose(&fp);\n        if (rc < 0)\n          break;\n\n        /* invalid response */\n        if (mutt_str_strncmp(\""423\"", buf, 3) != 0)\n        {\n          mutt_error(\""HEAD: %s\"", buf);\n          break;\n        }\n\n        /* no such article */\n        if (nntp_data->bcache)\n        {\n          snprintf(buf, sizeof(buf), \""%u\"", current);\n          mutt_debug(2, \""#3 mutt_bcache_del %s\\n\"", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        rc = 0;\n        continue;\n      }\n\n      /* parse header */\n      hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n      hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n      hdr->received = hdr->date_sent;\n      mutt_file_fclose(&fp);\n    }\n\n    /* save header in context */\n    hdr->index = ctx->msgcount++;\n    hdr->read = false;\n    hdr->old = false;\n    hdr->deleted = false;\n    hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n    NHDR(hdr)->article_num = current;\n    if (restore)\n      hdr->changed = true;\n    else\n    {\n      nntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num);\n      if (!hdr->read)\n        nntp_parse_xref(ctx, hdr);\n    }\n    if (current > nntp_data->last_loaded)\n      nntp_data->last_loaded = current;\n    first_over = current + 1;\n  }\n\n  if (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP)\n    current = first_over;\n\n  /* fetch overview information */\n  if (current <= last && rc == 0 && !nntp_data->deleted)\n  {\n    char *cmd = nntp_data->nserv->hasOVER ? \""OVER\"" : \""XOVER\"";\n    snprintf(buf, sizeof(buf), \""%s %u-%u\\r\\n\"", cmd, current, last);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\""%s: %s\"", cmd, buf);\n    }\n  }\n\n  if (ctx->msgcount > oldmsgcount)\n    mx_update_context(ctx, ctx->msgcount - oldmsgcount);\n\n  FREE(&fc.messages);\n  if (rc != 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}"", ""target"": 0}]","[{""func_name"": ""nntp_fetch_headers"", ""file_path"": ""nntp.c"", ""func_code"": ""static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\n                              anum_t last, int restore)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct FetchCtx fc;\n  struct Header *hdr = NULL;\n  char buf[HUGE_STRING];\n  int rc = 0;\n  int oldmsgcount = ctx->msgcount;\n  anum_t current;\n  anum_t first_over = first;\n#ifdef USE_HCACHE\n  void *hdata = NULL;\n#endif\n\n  /* if empty group or nothing to do */\n  if (!last || first > last)\n    return 0;\n\n  /* init fetch context */\n  fc.ctx = ctx;\n  fc.first = first;\n  fc.last = last;\n  fc.restore = restore;\n  fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n  if (fc.messages == NULL)\n\t  return -1;\n#ifdef USE_HCACHE\n  fc.hc = hc;\n#endif\n\n  /* fetch list of articles */\n  if (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n  {\n    if (!ctx->quiet)\n      mutt_message(_(\""Fetching list of articles...\""));\n    if (nntp_data->nserv->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \""LISTGROUP %s %u-%u\\r\\n\"", nntp_data->group, first, last);\n    else\n      snprintf(buf, sizeof(buf), \""LISTGROUP %s\\r\\n\"", nntp_data->group);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\""LISTGROUP: %s\"", buf);\n    }\n    if (rc == 0)\n    {\n      for (current = first; current <= last && rc == 0; current++)\n      {\n        if (fc.messages[current - first])\n          continue;\n\n        snprintf(buf, sizeof(buf), \""%u\"", current);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \""#1 mutt_bcache_del %s\\n\"", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n\n#ifdef USE_HCACHE\n        if (fc.hc)\n        {\n          mutt_debug(2, \""mutt_hcache_delete %s\\n\"", buf);\n          mutt_hcache_delete(fc.hc, buf, strlen(buf));\n        }\n#endif\n      }\n    }\n  }\n  else\n  {\n    for (current = first; current <= last; current++)\n      fc.messages[current - first] = 1;\n  }\n\n  /* fetching header from cache or server, or fallback to fetch overview */\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&fc.progress, _(\""Fetching message headers...\""),\n                       MUTT_PROGRESS_MSG, ReadInc, last - first + 1);\n  }\n  for (current = first; current <= last && rc == 0; current++)\n  {\n    if (!ctx->quiet)\n      mutt_progress_update(&fc.progress, current - first + 1, -1);\n\n#ifdef USE_HCACHE\n    snprintf(buf, sizeof(buf), \""%u\"", current);\n#endif\n\n    /* delete header from cache that does not exist on server */\n    if (!fc.messages[current - first])\n      continue;\n\n    /* allocate memory for headers */\n    if (ctx->msgcount >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n#ifdef USE_HCACHE\n    /* try to fetch header from cache */\n    hdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf));\n    if (hdata)\n    {\n      mutt_debug(2, \""mutt_hcache_fetch %s\\n\"", buf);\n      ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n      mutt_hcache_free(fc.hc, &hdata);\n      hdr->data = 0;\n\n      /* skip header marked as deleted in cache */\n      if (hdr->deleted && !restore)\n      {\n        mutt_header_free(&hdr);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \""#2 mutt_bcache_del %s\\n\"", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        continue;\n      }\n\n      hdr->read = false;\n      hdr->old = false;\n    }\n    else\n#endif\n\n        /* don't try to fetch header from removed newsgroup */\n        if (nntp_data->deleted)\n      continue;\n\n    /* fallback to fetch overview */\n    else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)\n    {\n      if (NntpListgroup && nntp_data->nserv->hasLISTGROUP)\n        break;\n      else\n        continue;\n    }\n\n    /* fetch header from server */\n    else\n    {\n      FILE *fp = mutt_file_mkstemp();\n      if (!fp)\n      {\n        mutt_perror(\""mutt_file_mkstemp() failed!\"");\n        rc = -1;\n        break;\n      }\n\n      snprintf(buf, sizeof(buf), \""HEAD %u\\r\\n\"", current);\n      rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n      if (rc)\n      {\n        mutt_file_fclose(&fp);\n        if (rc < 0)\n          break;\n\n        /* invalid response */\n        if (mutt_str_strncmp(\""423\"", buf, 3) != 0)\n        {\n          mutt_error(\""HEAD: %s\"", buf);\n          break;\n        }\n\n        /* no such article */\n        if (nntp_data->bcache)\n        {\n          snprintf(buf, sizeof(buf), \""%u\"", current);\n          mutt_debug(2, \""#3 mutt_bcache_del %s\\n\"", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        rc = 0;\n        continue;\n      }\n\n      /* parse header */\n      hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n      hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n      hdr->received = hdr->date_sent;\n      mutt_file_fclose(&fp);\n    }\n\n    /* save header in context */\n    hdr->index = ctx->msgcount++;\n    hdr->read = false;\n    hdr->old = false;\n    hdr->deleted = false;\n    hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n    NHDR(hdr)->article_num = current;\n    if (restore)\n      hdr->changed = true;\n    else\n    {\n      nntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num);\n      if (!hdr->read)\n        nntp_parse_xref(ctx, hdr);\n    }\n    if (current > nntp_data->last_loaded)\n      nntp_data->last_loaded = current;\n    first_over = current + 1;\n  }\n\n  if (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP)\n    current = first_over;\n\n  /* fetch overview information */\n  if (current <= last && rc == 0 && !nntp_data->deleted)\n  {\n    char *cmd = nntp_data->nserv->hasOVER ? \""OVER\"" : \""XOVER\"";\n    snprintf(buf, sizeof(buf), \""%s %u-%u\\r\\n\"", cmd, current, last);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\""%s: %s\"", cmd, buf);\n    }\n  }\n\n  if (ctx->msgcount > oldmsgcount)\n    mx_update_context(ctx, ctx->msgcount - oldmsgcount);\n\n  FREE(&fc.messages);\n  if (rc != 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(func:mutt_mem_calloc)"", ""result"": [{""code"": ""void *mutt_mem_calloc(size_t nmemb, size_t size)\n{\n  void *p = NULL;\n\n  if (!nmemb || !size)\n    return NULL;\n\n  if (nmemb > (SIZE_MAX / size))\n  {\n    mutt_error(_(\""Integer overflow -- can't allocate memory!\""));\n    mutt_exit(1);\n  }\n\n  p = calloc(nmemb, size);\n  if (!p)\n  {\n    mutt_error(_(\""Out of memory!\""));\n    mutt_exit(1);\n  }\n  return p;\n}"", ""start_line"": 52, ""end_line"": 72, ""full_name"": ""mutt_mem_calloc"", ""file_path"": ""mutt/memory.c""}]}, {""source"": ""code_info(file:nntp.c, lines:1290-1300)"", ""result"": ""  fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n#ifdef USE_HCACHE\n  fc.hc = hc;\n#endif\n\n  /* fetch list of articles */\n  if (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n  {\n    if (!ctx->quiet)\n      mutt_message(_(\""Fetching list of articles...\""));\n    if (nntp_data->nserv->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \""LISTGROUP %s %u-%u\\r\\n\"", nntp_data->group, first, last);\n""}]","nntp.c:1289: 'fc.messages' is allocated via mutt_mem_calloc without a NULL check. mutt/memory.c:52-72: mutt_mem_calloc calls calloc and exits on failure. Prior to the patch, if mutt_mem_calloc had returned NULL (e.g., in a version without mutt_exit(1)), the code would proceed, leading to undefined behavior. The patch adds a NULL check at nntp.c:1290-1291 to handle this scenario.",0.95,./github/other_context/CVE-2018-14361
26,CVE-2019-10664,CWE-89,c_cpp,Domoticz before 4.10578 allows SQL Injection via the idx parameter in CWebServer::GetFloorplanImage in WebServer.cpp.,https://github.com/domoticz/domoticz/commit/ee70db46f81afa582c96b887b73bcd2a86feda00,Fixed possible SQL Injection Vulnerability (Thanks to Fabio Carretto!),1,"[{""func_name"": ""CWebServer::GetFloorplanImage"", ""file_path"": ""main/WebServer.cpp"", ""func_code"": ""void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \""idx\"");\n\t\t\tif (idx == \""\"") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\""SELECT Image FROM Floorplans WHERE ID=%s\"", idx.c_str());\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \""floorplan\"";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \"".png\"";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \"".jpg\"";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \"".bmp\"";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \"".gif\"";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}"", ""target"": 0}]","[{""func_name"": ""CWebServer::GetFloorplanImage"", ""file_path"": ""main/WebServer.cpp"", ""func_code"": ""void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \""idx\"");\n\t\t\tif (idx == \""\"") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\""SELECT Image FROM Floorplans WHERE ID=%d\"", atol(idx.c_str()));\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \""floorplan\"";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \"".png\"";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \"".jpg\"";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \"".bmp\"";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \"".gif\"";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}""}]","{""function"": 1, ""value"": 1}","[{""source"": ""func_info(file:WebServer.cpp, func:GetFloorplanImage)"", ""result"": [{""code"": ""void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \""idx\"");\n\t\t\tif (idx == \""\"") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\""SELECT Image FROM Floorplans WHERE ID=%s\"", idx.c_str());\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \""floorplan\"";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \"".png\"";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \"".jpg\"";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \"".bmp\"";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \"".gif\"";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}"", ""start_line"": 10768, ""end_line"": 10792, ""full_name"": ""http.server.CWebServer.GetFloorplanImage:void(http.server.WebEmSession&,http.server.request&,http.server.reply&)"", ""file_path"": ""main/WebServer.cpp""}]}, {""source"": ""value_info(file:WebServer.cpp, value:idx)"", ""result"": {""value_trace"": [{""full_code"": ""idx = request::findValue(&req, \""idx\"")"", ""line"": 1459, ""func_name"": ""http.server.CWebServer.Cmd_UpdateHardware:void(http.server.WebEmSession&,http.server.request&,Json.Value&)""}, {""full_code"": ""idx = request::findValue(&req, \""idx\"")"", ""line"": 1834, ""func_name"": ""http.server.CWebServer.Cmd_GetDeviceValueOptions:void(http.server.WebEmSession&,http.server.request&,Json.Value&)""}, {""full_code"": ""idx = request::findValue(&req, \""idx\"")"", ""line"": 1865, ""func_name"": ""http.server.CWebServer.Cmd_GetDeviceValueOptionWording:void(http.server.WebEmSession&,http.server.request&,Json.Value&)""}, {""full_code"": ""idx = request::findValue(&req, \""idx\"")"", ""line"": 1913, ""func_name"": ""http.server.CWebServer.Cmd_DeleteUserVariable:void(http.server.WebEmSession&,http.server.request&,Json.Value&)""}, {""full_code"": ""idx = request::findValue(&req, \""idx\"")"", ""line"": 1930, ""func_name"": ""http.server.CWebServer.Cmd_UpdateUserVariable:void(http.server.WebEmSession&,http.server.request&,Json.Value&)""}], ""struct_var"": ""idx"", ""struct_type"": ""std.string"", ""struct_definition"": null}}]","main/WebServer.cpp:10773 used %s format for SQL query with idx (from request::findValue(&req, ""idx"")) as a string. Patch changed to %d and applied atol(), enforcing numeric input. This prevents SQLi by ensuring 'idx' is treated as an integer, not executable SQL.",0.95,./github/other_context/CVE-2019-10664
27,CVE-2019-13640,CWE-78,c_cpp,"In qBittorrent before 4.1.7, the function Application::runExternalProgram() located in app/application.cpp allows command injection via shell metacharacters in the torrent name parameter or current tracker parameter, as demonstrated by remote command execution via a crafted name within an RSS feed.",https://github.com/qbittorrent/qBittorrent/commit/a610c8567e55516231d199b551e0e7e2dca70cbf,"Prevent command injection via ""Run external program"" function\n\nCloses #10925.",1,"[{""func_name"": ""Application::runExternalProgram"", ""file_path"": ""src/app/application.cpp"", ""func_code"": ""void Application::runExternalProgram(const BitTorrent::TorrentHandle *torrent) const\n{\n    QString program = Preferences::instance()->getAutoRunProgram().trimmed();\n    program.replace(\""%N\"", torrent->name());\n    program.replace(\""%L\"", torrent->category());\n\n    QStringList tags = torrent->tags().toList();\n    std::sort(tags.begin(), tags.end(), Utils::String::naturalLessThan<Qt::CaseInsensitive>);\n    program.replace(\""%G\"", tags.join(','));\n\n#if defined(Q_OS_WIN)\n    const auto chopPathSep = [](const QString &str) -> QString\n    {\n        if (str.endsWith('\\\\'))\n            return str.mid(0, (str.length() -1));\n        return str;\n    };\n    program.replace(\""%F\"", chopPathSep(Utils::Fs::toNativePath(torrent->contentPath())));\n    program.replace(\""%R\"", chopPathSep(Utils::Fs::toNativePath(torrent->rootPath())));\n    program.replace(\""%D\"", chopPathSep(Utils::Fs::toNativePath(torrent->savePath())));\n#else\n    program.replace(\""%F\"", Utils::Fs::toNativePath(torrent->contentPath()));\n    program.replace(\""%R\"", Utils::Fs::toNativePath(torrent->rootPath()));\n    program.replace(\""%D\"", Utils::Fs::toNativePath(torrent->savePath()));\n#endif\n    program.replace(\""%C\"", QString::number(torrent->filesCount()));\n    program.replace(\""%Z\"", QString::number(torrent->totalSize()));\n    program.replace(\""%T\"", torrent->currentTracker());\n    program.replace(\""%I\"", torrent->hash());\n\n    Logger *logger = Logger::instance();\n    logger->addMessage(tr(\""Torrent: %1, running external program, command: %2\"").arg(torrent->name(), program));\n\n#if defined(Q_OS_WIN)\n    std::unique_ptr<wchar_t[]> programWchar(new wchar_t[program.length() + 1] {});\n    program.toWCharArray(programWchar.get());\n\n    // Need to split arguments manually because QProcess::startDetached(QString)\n    // will strip off empty parameters.\n    // E.g. `python.exe \""1\"" \""\"" \""3\""` will become `python.exe \""1\"" \""3\""`\n    int argCount = 0;\n    LPWSTR *args = ::CommandLineToArgvW(programWchar.get(), &argCount);\n\n    QStringList argList;\n    for (int i = 1; i < argCount; ++i)\n        argList += QString::fromWCharArray(args[i]);\n\n    QProcess::startDetached(QString::fromWCharArray(args[0]), argList);\n\n    ::LocalFree(args);\n#else\n    QProcess::startDetached(QLatin1String(\""/bin/sh\""), {QLatin1String(\""-c\""), program});\n#endif\n}"", ""target"": 0}]","[{""func_name"": ""Application::runExternalProgram"", ""file_path"": ""src/app/application.cpp"", ""func_code"": ""void Application::runExternalProgram(const BitTorrent::TorrentHandle *torrent) const\n{\n    QString program = Preferences::instance()->getAutoRunProgram().trimmed();\n    program.replace(\""%N\"", torrent->name());\n    program.replace(\""%L\"", torrent->category());\n\n    QStringList tags = torrent->tags().toList();\n    std::sort(tags.begin(), tags.end(), Utils::String::naturalLessThan<Qt::CaseInsensitive>);\n    program.replace(\""%G\"", tags.join(','));\n\n#if defined(Q_OS_WIN)\n    const auto chopPathSep = [](const QString &str) -> QString\n    {\n        if (str.endsWith('\\\\'))\n            return str.mid(0, (str.length() -1));\n        return str;\n    };\n    program.replace(\""%F\"", chopPathSep(Utils::Fs::toNativePath(torrent->contentPath())));\n    program.replace(\""%R\"", chopPathSep(Utils::Fs::toNativePath(torrent->rootPath())));\n    program.replace(\""%D\"", chopPathSep(Utils::Fs::toNativePath(torrent->savePath())));\n#else\n    program.replace(\""%F\"", Utils::Fs::toNativePath(torrent->contentPath()));\n    program.replace(\""%R\"", Utils::Fs::toNativePath(torrent->rootPath()));\n    program.replace(\""%D\"", Utils::Fs::toNativePath(torrent->savePath()));\n#endif\n    program.replace(\""%C\"", QString::number(torrent->filesCount()));\n    program.replace(\""%Z\"", QString::number(torrent->totalSize()));\n    program.replace(\""%T\"", torrent->currentTracker());\n    program.replace(\""%I\"", torrent->hash());\n\n    Logger *logger = Logger::instance();\n    logger->addMessage(tr(\""Torrent: %1, running external program, command: %2\"").arg(torrent->name(), program));\n\n#if defined(Q_OS_WIN)\n    std::unique_ptr<wchar_t[]> programWchar(new wchar_t[program.length() + 1] {});\n    program.toWCharArray(programWchar.get());\n\n    // Need to split arguments manually because QProcess::startDetached(QString)\n    // will strip off empty parameters.\n    // E.g. `python.exe \""1\"" \""\"" \""3\""` will become `python.exe \""1\"" \""3\""`\n    int argCount = 0;\n    LPWSTR *args = ::CommandLineToArgvW(programWchar.get(), &argCount);\n\n    QStringList argList;\n    for (int i = 1; i < argCount; ++i)\n        argList += QString::fromWCharArray(args[i]);\n\n    QProcess::startDetached(QString::fromWCharArray(args[0]), argList);\n\n    ::LocalFree(args);\n#else\n    // Cannot give users shell environment by default, as doing so could\n    // enable command injection via torrent name and other arguments\n    // (especially when some automated download mechanism has been setup).\n    // See: https://github.com/qbittorrent/qBittorrent/issues/10925\n    QProcess::startDetached(program);\n#endif\n}""}]","{""value"": 2, ""function"": 3, ""code"": 2, ""caller"": 1}","[{""source"": ""value_info(file:application.cpp, value:program)"", ""result"": {""value_trace"": [{""full_code"": ""program = Preferences::instance()->getAutoRunProgram().trimmed()"", ""line"": 289, ""func_name"": ""Application.runExternalProgram:void(BitTorrent.TorrentHandle*)<const>""}], ""struct_var"": ""program"", ""struct_type"": ""QString"", ""struct_definition"": ""class QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString""}}, {""source"": ""value_info(file:application.cpp, value:program)"", ""result"": {""value_trace"": [{""full_code"": ""program = Preferences::instance()->getAutoRunProgram().trimmed()"", ""line"": 289, ""func_name"": ""Application.runExternalProgram:void(BitTorrent.TorrentHandle*)<const>""}], ""struct_var"": ""program"", ""struct_type"": ""QString"", ""struct_definition"": ""class QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString\n\nclass QString""}}, {""source"": ""func_info(func:getAutoRunProgram)"", ""result"": [{""code"": ""QString Preferences::getAutoRunProgram() const\n{\n    return value(\""AutoRun/program\"").toString();\n}"", ""start_line"": 793, ""end_line"": 796, ""full_name"": ""Preferences.getAutoRunProgram:QString()<const>"", ""file_path"": ""src/base/preferences.cpp""}]}, {""source"": ""code_info(file:application.cpp, lines:289-335)"", ""result"": ""    QString program = Preferences::instance()->getAutoRunProgram().trimmed();\n    program.replace(\""%N\"", torrent->name());\n    program.replace(\""%L\"", torrent->category());\n\n    QStringList tags = torrent->tags().toList();\n    std::sort(tags.begin(), tags.end(), Utils::String::naturalLessThan<Qt::CaseInsensitive>);\n    program.replace(\""%G\"", tags.join(','));\n\n#if defined(Q_OS_WIN)\n    const auto chopPathSep = [](const QString &str) -> QString\n    {\n        if (str.endsWith('\\\\'))\n            return str.mid(0, (str.length() -1));\n        return str;\n    };\n    program.replace(\""%F\"", chopPathSep(Utils::Fs::toNativePath(torrent->contentPath())));\n    program.replace(\""%R\"", chopPathSep(Utils::Fs::toNativePath(torrent->rootPath())));\n    program.replace(\""%D\"", chopPathSep(Utils::Fs::toNativePath(torrent->savePath())));\n#else\n    program.replace(\""%F\"", Utils::Fs::toNativePath(torrent->contentPath()));\n    program.replace(\""%R\"", Utils::Fs::toNativePath(torrent->rootPath()));\n    program.replace(\""%D\"", Utils::Fs::toNativePath(torrent->savePath()));\n#endif\n    program.replace(\""%C\"", QString::number(torrent->filesCount()));\n    program.replace(\""%Z\"", QString::number(torrent->totalSize()));\n    program.replace(\""%T\"", torrent->currentTracker());\n    program.replace(\""%I\"", torrent->hash());\n\n    Logger *logger = Logger::instance();\n    logger->addMessage(tr(\""Torrent: %1, running external program, command: %2\"").arg(torrent->name(), program));\n\n#if defined(Q_OS_WIN)\n    std::unique_ptr<wchar_t[]> programWchar(new wchar_t[program.length() + 1] {});\n    program.toWCharArray(programWchar.get());\n\n    // Need to split arguments manually because QProcess::startDetached(QString)\n    // will strip off empty parameters.\n    // E.g. `python.exe \""1\"" \""\"" \""3\""` will become `python.exe \""1\"" \""3\""`\n    int argCount = 0;\n    LPWSTR *args = ::CommandLineToArgvW(programWchar.get(), &argCount);\n\n    QStringList argList;\n    for (int i = 1; i < argCount; ++i)\n        argList += QString::fromWCharArray(args[i]);\n\n    QProcess::startDetached(QString::fromWCharArray(args[0]), argList);\n\n    ::LocalFree(args);\n""}, {""source"": ""caller_info(file:application.cpp, func:startDetached)"", ""result"": [{""call_line"": 338, ""call_code"": ""QProcess::startDetached(QLatin1String(\""/bin/sh\""), {QLatin1String(\""-c\""), program})"", ""caller_code"": ""void Application::runExternalProgram(const BitTorrent::TorrentHandle *torrent) const\n{\n    QString program = Preferences::instance()->getAutoRunProgram().trimmed();\n    program.replace(\""%N\"", torrent->name());\n    program.replace(\""%L\"", torrent->category());\n\n    QStringList tags = torrent->tags().toList();\n    std::sort(tags.begin(), tags.end(), Utils::String::naturalLessThan<Qt::CaseInsensitive>);\n    program.replace(\""%G\"", tags.join(','));\n\n#if defined(Q_OS_WIN)\n    const auto chopPathSep = [](const QString &str) -> QString\n    {\n        if (str.endsWith('\\\\'))\n            return str.mid(0, (str.length() -1));\n        return str;\n    };\n    program.replace(\""%F\"", chopPathSep(Utils::Fs::toNativePath(torrent->contentPath())));\n    program.replace(\""%R\"", chopPathSep(Utils::Fs::toNativePath(torrent->rootPath())));\n    program.replace(\""%D\"", chopPathSep(Utils::Fs::toNativePath(torrent->savePath())));\n#else\n    program.replace(\""%F\"", Utils::Fs::toNativePath(torrent->contentPath()));\n    progr..."", ""caller_start"": 287, ""file_path"": ""src/app/application.cpp""}]}, {""source"": ""func_info(func:name)"", ""result"": [{""code"": ""QString MagnetUri::name() const\n{\n    return m_name;\n}"", ""start_line"": 97, ""end_line"": 100, ""full_name"": ""BitTorrent.MagnetUri.name:QString()<const>"", ""file_path"": ""src/base/bittorrent/magneturi.cpp""}, {""code"": ""QString TorrentHandle::name() const\n{\n    QString name = m_name;\n    if (name.isEmpty())\n        name = QString::fromStdString(m_nativeStatus.name);\n\n    if (name.isEmpty() && hasMetadata())\n        name = QString::fromStdString(m_torrentInfo.nativeInfo()->orig_files().name());\n\n    if (name.isEmpty())\n        name = m_hash;\n\n    return name;\n}"", ""start_line"": 247, ""end_line"": 260, ""full_name"": ""BitTorrent.TorrentHandle.name:QString()<const>"", ""file_path"": ""src/base/bittorrent/torrenthandle.cpp""}, {""code"": ""QString TorrentInfo::name() const\n{\n    if (!isValid()) return {};\n    return QString::fromStdString(m_nativeInfo->name());\n}"", ""start_line"": 160, ""end_line"": 164, ""full_name"": ""BitTorrent.TorrentInfo.name:QString()<const>"", ""file_path"": ""src/base/bittorrent/torrentinfo.cpp""}]}, {""source"": ""func_info(func:currentTracker)"", ""result"": [{""code"": ""QString TorrentHandle::currentTracker() const\n{\n    return QString::fromStdString(m_nativeStatus.current_tracker);\n}"", ""start_line"": 313, ""end_line"": 316, ""full_name"": ""BitTorrent.TorrentHandle.currentTracker:QString()<const>"", ""file_path"": ""src/base/bittorrent/torrenthandle.cpp""}]}, {""source"": ""code_info(file:torrent.cpp, lines:0-200)"", ""result"": ""error code""}]","src/app/application.cpp:289-335: 'program' string constructed with unsanitized user inputs via placeholder substitution (e.g., %N replaced by torrent->name(), %T by torrent->currentTracker()). torrent->name() (src/base/bittorrent/torrenthandle.cpp:247-260) and torrent->currentTracker() (src/base/bittorrent/torrenthandle.cpp:313-316) return values directly from user-controlled torrent metadata without sanitization. src/app/application.cpp:338: Original code executed 'program' via /bin/sh, allowing shell metacharacters in inputs to trigger command injection.",0.95,./github/other_context/CVE-2019-13640
28,CVE-2019-15569,CWE-89,java,"HM Courts & Tribunals ccd-data-store-api before 2019-06-10 allows SQL injection, related to SearchQueryFactoryOperation.java and SortDirection.java.",https://github.com/hmcts/ccd-data-store-api/commit/c942d5ce847ab1b4acce8753320096e596b42c72,refactored to prevent sql injection introducing an enum,3,"[{""func_name"": ""fromOptionalString"", ""file_path"": ""src/main/java/uk/gov/hmcts/ccd/data/casedetails/search/SortDirection.java"", ""func_code"": ""public static SortDirection fromOptionalString(Optional<String> direction) {\n    \tif (\""DESC\"".equalsIgnoreCase(direction.orElse(null)))\n    \t    return DESC;\n        return ASC;\n    }"", ""target"": 1}, {""func_name"": ""build"", ""file_path"": ""src/main/java/uk/gov/hmcts/ccd/data/casedetails/search/SearchQueryFactoryOperation.java"", ""func_code"": ""public Query build(MetaData metadata, Map<String, String> params, boolean isCountQuery) {\n        final List<Criterion> criteria = criterionFactory.build(metadata, params);\n        \n        String queryToFormat = isCountQuery ? MAIN_COUNT_QUERY : MAIN_QUERY;\n        String whereClausePart = secure(toClauses(criteria), metadata);\n        String sortDirectionPart = metadata.getSortDirection().orElse(SORT_ASCENDING).toUpperCase();\n        \n        String queryString = String.format(queryToFormat, whereClausePart, sortDirectionPart);\n\n        Query query;\n        if (isCountQuery) {\n            query = entityManager.createNativeQuery(queryString);\n        } else {\n            query = entityManager.createNativeQuery(queryString, CaseDetailsEntity.class);\n        }\n        addParameters(query, criteria);\n        return query;\n    }"", ""target"": 0}, {""func_name"": ""build"", ""file_path"": ""src/main/java/uk/gov/hmcts/ccd/data/casedetails/search/SearchQueryFactoryOperation.java"", ""func_code"": ""public Query build(MetaData metadata, Map<String, String> params, boolean isCountQuery) {\n        final List<Criterion> criteria = criterionFactory.build(metadata, params);\n        String queryString = String.format(isCountQuery ? MAIN_COUNT_QUERY : MAIN_QUERY,\n                                           secure(toClauses(criteria), metadata),\n                                           metadata.getSortDirection().orElse(SORT_ASCENDING).toUpperCase()\n        );\n        Query query;\n        if (isCountQuery) {\n            query = entityManager.createNativeQuery(queryString);\n        } else {\n            query = entityManager.createNativeQuery(queryString, CaseDetailsEntity.class);\n        }\n        addParameters(query, criteria);\n        return query;\n    }"", ""target"": 1}]","[{""func_name"": ""fromOptionalString"", ""file_path"": ""src/main/java/uk/gov/hmcts/ccd/data/casedetails/search/SortDirection.java"", ""func_code"": ""public static SortDirection fromOptionalString(Optional<String> direction) {\n        if (\""DESC\"".equalsIgnoreCase(direction.orElse(null))) {\n            return DESC;\n        }\n        return ASC;\n    }""}, {""func_name"": ""build"", ""file_path"": ""src/main/java/uk/gov/hmcts/ccd/data/casedetails/search/SearchQueryFactoryOperation.java"", ""func_code"": ""public Query build(MetaData metadata, Map<String, String> params, boolean isCountQuery) {\n        final List<Criterion> criteria = criterionFactory.build(metadata, params);\n        \n        String queryToFormat = isCountQuery ? MAIN_COUNT_QUERY : MAIN_QUERY;\n        String whereClausePart = secure(toClauses(criteria), metadata);\n\n        SortDirection direction = SortDirection.fromOptionalString(metadata.getSortDirection());\n\n        String queryString = String.format(queryToFormat, whereClausePart, direction.name());\n\n        Query query;\n        if (isCountQuery) {\n            query = entityManager.createNativeQuery(queryString);\n        } else {\n            query = entityManager.createNativeQuery(queryString, CaseDetailsEntity.class);\n        }\n        addParameters(query, criteria);\n        return query;\n    }""}, {""func_name"": ""build"", ""file_path"": ""src/main/java/uk/gov/hmcts/ccd/data/casedetails/search/SearchQueryFactoryOperation.java"", ""func_code"": ""public Query build(MetaData metadata, Map<String, String> params, boolean isCountQuery) {\n        final List<Criterion> criteria = criterionFactory.build(metadata, params);\n        \n        String queryToFormat = isCountQuery ? MAIN_COUNT_QUERY : MAIN_QUERY;\n        String whereClausePart = secure(toClauses(criteria), metadata);\n        String sortDirectionPart = metadata.getSortDirection().orElse(SORT_ASCENDING).toUpperCase();\n        \n        String queryString = String.format(queryToFormat, whereClausePart, sortDirectionPart);\n\n        Query query;\n        if (isCountQuery) {\n            query = entityManager.createNativeQuery(queryString);\n        } else {\n            query = entityManager.createNativeQuery(queryString, CaseDetailsEntity.class);\n        }\n        addParameters(query, criteria);\n        return query;\n    }""}]","{""function"": 1}","[{""source"": ""func_info(file:SortDirection.java, func:fromOptionalString)"", ""result"": [{""code"": ""    public static SortDirection fromOptionalString(Optional<String> direction) {\n    \tif (\""DESC\"".equalsIgnoreCase(direction.orElse(null)))\n    \t    return DESC;\n        return ASC;\n    }\n"", ""start_line"": 8, ""end_line"": 12, ""full_name"": ""uk.gov.hmcts.ccd.data.casedetails.search.SortDirection.fromOptionalString:uk.gov.hmcts.ccd.data.casedetails.search.SortDirection(java.util.Optional)"", ""file_path"": ""src/main/java/uk/gov/hmcts/ccd/data/casedetails/search/SortDirection.java""}]}]","Original code directly used metadata.getSortDirection() (user input) in SQL queries via String.format() (SearchQueryFactoryOperation.java:42-43). Patch replaces this with SortDirection.fromOptionalString(), which validates input to only 'ASC' or 'DESC' (SortDirection.java:8-12). Enum's name() ensures safe SQL literals.",0.95,./github/other_context/CVE-2019-15569
29,CVE-2019-17347,CWE-20,c_cpp,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because a guest can manipulate its virtualised %cr4 in a way that is incompatible with Linux (and possibly other guest kernels).,https://github.com/xen-project/xen/commit/eccc170053e46b4ab1d9e7485c09e210be15bbd7,"x86/pv: Don't have %cr4.fsgsbase active behind a guest kernels back\n\nCurrently, a 64bit PV guest can appear to set and clear FSGSBASE in %cr4, but\nthe bit remains set in hardware.  Therefore, the {RD,WR}{FS,GS}BASE are usable\neven when the guest kernel believes that they are disabled.\n\nThe FSGSBASE feature isn't currently supported in Linux, and its context\nswitch path has some optimisations which rely on userspace being unable to use\nthe WR{FS,GS}BASE instructions.  Xen's current behaviour undermines this\nexpectation.\n\nIn 64bit PV guest context, always load the guest kernels setting of FSGSBASE\ninto %cr4.  This requires adjusting how Xen uses the {RD,WR}{FS,GS}BASE\ninstructions.\n\n * Delete the cpu_has_fsgsbase helper.  It is no longer safe, as users need to\n   check %cr4 directly.\n * The raw __rd{fs,gs}base() helpers are only safe to use when %cr4.fsgsbase\n   is set.  Comment this property.\n * The {rd,wr}{fs,gs}{base,shadow}() and read_msr() helpers are updated to use\n   the current %cr4 value to determine which mechanism to use.\n * toggle_guest_mode() and save_segments() are update to avoid reading\n   fs/gsbase if the values in hardware cannot be stale WRT struct vcpu.  A\n   consequence of this is that the write_cr() path needs to cache the current\n   bases, as subsequent context switches will skip saving the values.\n * write_cr4() is updated to ensure that the shadow %cr4.fsgsbase value is\n   observed in a safe way WRT the hardware setting, if an interrupt happens to\n   hit in the middle.\n * load_segments() is updated to use the VMLOAD optimisation if FSGSBASE is\n   unavailable, even if only gs_shadow needs updating.  As a minor perf\n   improvement, check cpu_has_svm first to short circuit a context-dependent\n   conditional on Intel hardware.\n * pv_make_cr4() is updated for 64bit PV guests to use the guest kernels\n   choice of FSGSBASE.\n\nThis is part of XSA-293.\n\nReported-by: Andy Lutomirski <luto@kernel.org>\nSigned-off-by: Andrew Cooper <andrew.cooper3@citrix.com>\nReviewed-by: Jan Beulich <jbeulich@suse.com>",20,"[{""func_name"": ""svm_cpu_up_prepare"", ""file_path"": ""xen/arch/x86/hvm/svm/svm.c"", ""func_code"": ""static int svm_cpu_up_prepare(unsigned int cpu)\n{\n    paddr_t *this_hsa = &per_cpu(hsa, cpu);\n    paddr_t *this_vmcb = &per_cpu(host_vmcb, cpu);\n    nodeid_t node = cpu_to_node(cpu);\n    unsigned int memflags = 0;\n    struct page_info *pg;\n\n    if ( node != NUMA_NO_NODE )\n        memflags = MEMF_node(node);\n\n    if ( !*this_hsa )\n    {\n        pg = alloc_domheap_page(NULL, memflags);\n        if ( !pg )\n            goto err;\n\n        clear_domain_page(page_to_mfn(pg));\n        *this_hsa = page_to_maddr(pg);\n    }\n\n    if ( !*this_vmcb )\n    {\n        pg = alloc_domheap_page(NULL, memflags);\n        if ( !pg )\n            goto err;\n\n#ifdef CONFIG_PV\n        if ( !cpu_has_fsgsbase )\n            per_cpu(host_vmcb_va, cpu) = __map_domain_page_global(pg);\n#endif\n\n        clear_domain_page(page_to_mfn(pg));\n        *this_vmcb = page_to_maddr(pg);\n    }\n\n    return 0;\n\n err:\n    svm_cpu_dead(cpu);\n    return -ENOMEM;\n}"", ""target"": 0}, {""func_name"": ""write_cr"", ""file_path"": ""xen/arch/x86/pv/emul-priv-op.c"", ""func_code"": ""static int write_cr(unsigned int reg, unsigned long val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n\n    switch ( reg )\n    {\n    case 0: /* Write CR0 */\n        if ( (val ^ read_cr0()) & ~X86_CR0_TS )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \""Attempt to change unmodifiable CR0 flags\\n\"");\n            break;\n        }\n        do_fpu_taskswitch(!!(val & X86_CR0_TS));\n        return X86EMUL_OKAY;\n\n    case 2: /* Write CR2 */\n        curr->arch.pv.ctrlreg[2] = val;\n        arch_set_cr2(curr, val);\n        return X86EMUL_OKAY;\n\n    case 3: /* Write CR3 */\n    {\n        struct domain *currd = curr->domain;\n        unsigned long gfn;\n        struct page_info *page;\n        int rc;\n\n        gfn = !is_pv_32bit_domain(currd)\n              ? xen_cr3_to_pfn(val) : compat_cr3_to_pfn(val);\n        page = get_page_from_gfn(currd, gfn, NULL, P2M_ALLOC);\n        if ( !page )\n            break;\n        rc = new_guest_cr3(page_to_mfn(page));\n        put_page(page);\n\n        switch ( rc )\n        {\n        case 0:\n            return X86EMUL_OKAY;\n        case -ERESTART: /* retry after preemption */\n            return X86EMUL_RETRY;\n        }\n        break;\n    }\n\n    case 4: /* Write CR4 */\n        curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);\n        write_cr4(pv_make_cr4(curr));\n        ctxt_switch_levelling(curr);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}"", ""target"": 0}, {""func_name"": ""read_msr"", ""file_path"": ""xen/arch/x86/pv/emul-priv-op.c"", ""func_code"": ""static int read_msr(unsigned int reg, uint64_t *val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    const struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n    int ret;\n\n    if ( (ret = guest_rdmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )\n    {\n        if ( ret == X86EMUL_EXCEPTION )\n            x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);\n\n        return ret;\n    }\n\n    switch ( reg )\n    {\n        int rc;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = cpu_has_fsgsbase ? __rdfsbase() : curr->arch.pv.fs_base;\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = cpu_has_fsgsbase ? __rdgsbase()\n                                : curr->arch.pv.gs_base_kernel;\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = curr->arch.pv.gs_base_user;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_TSC:\n        *val = currd->arch.vtsc ? pv_soft_rdtsc(curr, ctxt->regs) : rdtsc();\n        return X86EMUL_OKAY;\n\n    case MSR_EFER:\n        /* Hide unknown bits, and unconditionally hide SVME from guests. */\n        *val = read_efer() & EFER_KNOWN_MASK & ~EFER_SVME;\n        /*\n         * Hide the 64-bit features from 32-bit guests.  SCE has\n         * vendor-dependent behaviour.\n         */\n        if ( is_pv_32bit_domain(currd) )\n            *val &= ~(EFER_LME | EFER_LMA |\n                      (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL\n                       ? EFER_SCE : 0));\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD )\n            break;\n        if ( unlikely(is_cpufreq_controller(currd)) )\n            goto normal;\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_UCODE_REV:\n        BUILD_BUG_ON(MSR_IA32_UCODE_REV != MSR_AMD_PATCHLEVEL);\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            if ( wrmsr_safe(MSR_IA32_UCODE_REV, 0) )\n                break;\n            /* As documented in the SDM: Do a CPUID 1 here */\n            cpuid_eax(1);\n        }\n        goto normal;\n\n    case MSR_IA32_MISC_ENABLE:\n        rdmsrl(reg, *val);\n        *val = guest_misc_enable(*val);\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_PERF_CAPABILITIES:\n        /* No extra capabilities are supported. */\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n            /* fall through */\n    case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) )\n            {\n                if ( vpmu_do_rdmsr(reg, val) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        rc = vmce_rdmsr(reg, val);\n        if ( rc < 0 )\n            break;\n        if ( rc )\n            return X86EMUL_OKAY;\n        /* fall through */\n    normal:\n        /* Everyone can read the MSR space. */\n        /* gdprintk(XENLOG_WARNING, \""Domain attempted RDMSR %08x\\n\"", reg); */\n        if ( rdmsr_safe(reg, *val) )\n            break;\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}"", ""target"": 0}, {""func_name"": ""load_segments"", ""file_path"": ""xen/arch/x86/domain.c"", ""func_code"": ""static void load_segments(struct vcpu *n)\n{\n    struct cpu_user_regs *uregs = &n->arch.user_regs;\n    int all_segs_okay = 1;\n    unsigned int dirty_segment_mask, cpu = smp_processor_id();\n    bool fs_gs_done = false;\n\n    /* Load and clear the dirty segment mask. */\n    dirty_segment_mask = per_cpu(dirty_segment_mask, cpu);\n    per_cpu(dirty_segment_mask, cpu) = 0;\n\n#ifdef CONFIG_HVM\n    if ( !is_pv_32bit_vcpu(n) && !cpu_has_fsgsbase && cpu_has_svm &&\n         !((uregs->fs | uregs->gs) & ~3) &&\n         /*\n          * The remaining part is just for optimization: If only shadow GS\n          * needs loading, there's nothing to be gained here.\n          */\n         (n->arch.pv.fs_base | n->arch.pv.gs_base_user | n->arch.pv.ldt_ents) )\n    {\n        unsigned long gsb = n->arch.flags & TF_kernel_mode\n            ? n->arch.pv.gs_base_kernel : n->arch.pv.gs_base_user;\n        unsigned long gss = n->arch.flags & TF_kernel_mode\n            ? n->arch.pv.gs_base_user : n->arch.pv.gs_base_kernel;\n\n        fs_gs_done = svm_load_segs(n->arch.pv.ldt_ents, LDT_VIRT_START(n),\n                                   uregs->fs, n->arch.pv.fs_base,\n                                   uregs->gs, gsb, gss);\n    }\n#endif\n    if ( !fs_gs_done )\n        load_LDT(n);\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_DS) | uregs->ds) )\n    {\n        preload_segment(ds, uregs->ds);\n        all_segs_okay &= loadsegment(ds, uregs->ds);\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_ES) | uregs->es) )\n    {\n        preload_segment(es, uregs->es);\n        all_segs_okay &= loadsegment(es, uregs->es);\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_FS) | uregs->fs) && !fs_gs_done )\n    {\n        all_segs_okay &= loadsegment(fs, uregs->fs);\n        /* non-nul selector updates fs_base */\n        if ( uregs->fs & ~3 )\n            dirty_segment_mask &= ~DIRTY_FS_BASE;\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_GS) | uregs->gs) && !fs_gs_done )\n    {\n        all_segs_okay &= loadsegment(gs, uregs->gs);\n        /* non-nul selector updates gs_base_user */\n        if ( uregs->gs & ~3 )\n            dirty_segment_mask &= ~DIRTY_GS_BASE;\n    }\n\n    if ( !fs_gs_done && !is_pv_32bit_vcpu(n) )\n    {\n        /* This can only be non-zero if selector is NULL. */\n        if ( n->arch.pv.fs_base | (dirty_segment_mask & DIRTY_FS_BASE) )\n            wrfsbase(n->arch.pv.fs_base);\n\n        /*\n         * Most kernels have non-zero GS base, so don't bother testing.\n         * (For old AMD hardware this is also a serialising instruction,\n         * avoiding erratum #88.)\n         */\n        wrgsshadow(n->arch.pv.gs_base_kernel);\n\n        /* This can only be non-zero if selector is NULL. */\n        if ( n->arch.pv.gs_base_user |\n             (dirty_segment_mask & DIRTY_GS_BASE) )\n            wrgsbase(n->arch.pv.gs_base_user);\n\n        /* If in kernel mode then switch the GS bases around. */\n        if ( (n->arch.flags & TF_kernel_mode) )\n            asm volatile ( \""swapgs\"" );\n    }\n\n    if ( unlikely(!all_segs_okay) )\n    {\n        struct pv_vcpu *pv = &n->arch.pv;\n        struct cpu_user_regs *regs = guest_cpu_user_regs();\n        unsigned long *rsp =\n            (unsigned long *)(((n->arch.flags & TF_kernel_mode)\n                               ? regs->rsp : pv->kernel_sp) & ~0xf);\n        unsigned long cs_and_mask, rflags;\n\n        /* Fold upcall mask and architectural IOPL into RFLAGS.IF. */\n        rflags  = regs->rflags & ~(X86_EFLAGS_IF|X86_EFLAGS_IOPL);\n        rflags |= !vcpu_info(n, evtchn_upcall_mask) << 9;\n        if ( VM_ASSIST(n->domain, architectural_iopl) )\n            rflags |= n->arch.pv.iopl;\n\n        if ( is_pv_32bit_vcpu(n) )\n        {\n            unsigned int *esp = ring_1(regs) ?\n                                (unsigned int *)regs->rsp :\n                                (unsigned int *)pv->kernel_sp;\n            int ret = 0;\n\n            /* CS longword also contains full evtchn_upcall_mask. */\n            cs_and_mask = (unsigned short)regs->cs |\n                ((unsigned int)vcpu_info(n, evtchn_upcall_mask) << 16);\n\n            if ( !ring_1(regs) )\n            {\n                ret  = put_user(regs->ss,       esp-1);\n                ret |= put_user(regs->esp,      esp-2);\n                esp -= 2;\n            }\n\n            if ( ret |\n                 put_user(rflags,              esp-1) |\n                 put_user(cs_and_mask,         esp-2) |\n                 put_user(regs->eip,           esp-3) |\n                 put_user(uregs->gs,           esp-4) |\n                 put_user(uregs->fs,           esp-5) |\n                 put_user(uregs->es,           esp-6) |\n                 put_user(uregs->ds,           esp-7) )\n            {\n                gprintk(XENLOG_ERR,\n                        \""error while creating compat failsafe callback frame\\n\"");\n                domain_crash(n->domain);\n            }\n\n            if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )\n                vcpu_info(n, evtchn_upcall_mask) = 1;\n\n            regs->entry_vector |= TRAP_syscall;\n            regs->eflags       &= ~(X86_EFLAGS_VM|X86_EFLAGS_RF|X86_EFLAGS_NT|\n                                    X86_EFLAGS_IOPL|X86_EFLAGS_TF);\n            regs->ss            = FLAT_COMPAT_KERNEL_SS;\n            regs->esp           = (unsigned long)(esp-7);\n            regs->cs            = FLAT_COMPAT_KERNEL_CS;\n            regs->eip           = pv->failsafe_callback_eip;\n            return;\n        }\n\n        if ( !(n->arch.flags & TF_kernel_mode) )\n            toggle_guest_mode(n);\n        else\n            regs->cs &= ~3;\n\n        /* CS longword also contains full evtchn_upcall_mask. */\n        cs_and_mask = (unsigned long)regs->cs |\n            ((unsigned long)vcpu_info(n, evtchn_upcall_mask) << 32);\n\n        if ( put_user(regs->ss,            rsp- 1) |\n             put_user(regs->rsp,           rsp- 2) |\n             put_user(rflags,              rsp- 3) |\n             put_user(cs_and_mask,         rsp- 4) |\n             put_user(regs->rip,           rsp- 5) |\n             put_user(uregs->gs,           rsp- 6) |\n             put_user(uregs->fs,           rsp- 7) |\n             put_user(uregs->es,           rsp- 8) |\n             put_user(uregs->ds,           rsp- 9) |\n             put_user(regs->r11,           rsp-10) |\n             put_user(regs->rcx,           rsp-11) )\n        {\n            gprintk(XENLOG_ERR,\n                    \""error while creating failsafe callback frame\\n\"");\n            domain_crash(n->domain);\n        }\n\n        if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )\n            vcpu_info(n, evtchn_upcall_mask) = 1;\n\n        regs->entry_vector |= TRAP_syscall;\n        regs->rflags       &= ~(X86_EFLAGS_AC|X86_EFLAGS_VM|X86_EFLAGS_RF|\n                                X86_EFLAGS_NT|X86_EFLAGS_IOPL|X86_EFLAGS_TF);\n        regs->ss            = FLAT_KERNEL_SS;\n        regs->rsp           = (unsigned long)(rsp-11);\n        regs->cs            = FLAT_KERNEL_CS;\n        regs->rip           = pv->failsafe_callback_eip;\n    }\n}"", ""target"": 0}, {""func_name"": ""__context_switch"", ""file_path"": ""xen/arch/x86/domain.c"", ""func_code"": ""static void __context_switch(void)\n{\n    struct cpu_user_regs *stack_regs = guest_cpu_user_regs();\n    unsigned int          cpu = smp_processor_id();\n    struct vcpu          *p = per_cpu(curr_vcpu, cpu);\n    struct vcpu          *n = current;\n    struct domain        *pd = p->domain, *nd = n->domain;\n    seg_desc_t           *gdt;\n    struct desc_ptr       gdt_desc;\n\n    ASSERT(p != n);\n    ASSERT(!vcpu_cpu_dirty(n));\n\n    if ( !is_idle_domain(pd) )\n    {\n        memcpy(&p->arch.user_regs, stack_regs, CTXT_SWITCH_STACK_BYTES);\n        vcpu_save_fpu(p);\n        pd->arch.ctxt_switch->from(p);\n    }\n\n    /*\n     * Mark this CPU in next domain's dirty cpumasks before calling\n     * ctxt_switch_to(). This avoids a race on things like EPT flushing,\n     * which is synchronised on that function.\n     */\n    if ( pd != nd )\n        cpumask_set_cpu(cpu, nd->dirty_cpumask);\n    write_atomic(&n->dirty_cpu, cpu);\n\n    if ( !is_idle_domain(nd) )\n    {\n        memcpy(stack_regs, &n->arch.user_regs, CTXT_SWITCH_STACK_BYTES);\n        if ( cpu_has_xsave )\n        {\n            u64 xcr0 = n->arch.xcr0 ?: XSTATE_FP_SSE;\n\n            if ( xcr0 != get_xcr0() && !set_xcr0(xcr0) )\n                BUG();\n\n            if ( cpu_has_xsaves && is_hvm_vcpu(n) )\n                set_msr_xss(n->arch.hvm.msr_xss);\n        }\n        vcpu_restore_fpu_nonlazy(n, false);\n        nd->arch.ctxt_switch->to(n);\n    }\n\n    psr_ctxt_switch_to(nd);\n\n    gdt = !is_pv_32bit_domain(nd) ? per_cpu(gdt_table, cpu) :\n                                    per_cpu(compat_gdt_table, cpu);\n    if ( need_full_gdt(nd) )\n    {\n        unsigned long mfn = virt_to_mfn(gdt);\n        l1_pgentry_t *pl1e = pv_gdt_ptes(n);\n        unsigned int i;\n\n        for ( i = 0; i < NR_RESERVED_GDT_PAGES; i++ )\n            l1e_write(pl1e + FIRST_RESERVED_GDT_PAGE + i,\n                      l1e_from_pfn(mfn + i, __PAGE_HYPERVISOR_RW));\n    }\n\n    if ( need_full_gdt(pd) &&\n         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(nd)) )\n    {\n        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;\n        gdt_desc.base  = (unsigned long)(gdt - FIRST_RESERVED_GDT_ENTRY);\n\n        lgdt(&gdt_desc);\n    }\n\n    write_ptbase(n);\n\n#if defined(CONFIG_PV) && defined(CONFIG_HVM)\n    /* Prefetch the VMCB if we expect to use it later in the context switch */\n    if ( is_pv_domain(nd) && !is_pv_32bit_domain(nd) && !is_idle_domain(nd) &&\n         !cpu_has_fsgsbase && cpu_has_svm )\n        svm_load_segs(0, 0, 0, 0, 0, 0, 0);\n#endif\n\n    if ( need_full_gdt(nd) &&\n         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(pd)) )\n    {\n        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;\n        gdt_desc.base = GDT_VIRT_START(n);\n\n        lgdt(&gdt_desc);\n    }\n\n    if ( pd != nd )\n        cpumask_clear_cpu(cpu, pd->dirty_cpumask);\n    write_atomic(&p->dirty_cpu, VCPU_CPU_CLEAN);\n\n    per_cpu(curr_vcpu, cpu) = n;\n}"", ""target"": 0}, {""func_name"": ""save_segments"", ""file_path"": ""xen/arch/x86/domain.c"", ""func_code"": ""static void save_segments(struct vcpu *v)\n{\n    struct cpu_user_regs *regs = &v->arch.user_regs;\n    unsigned int dirty_segment_mask = 0;\n\n    regs->ds = read_sreg(ds);\n    regs->es = read_sreg(es);\n    regs->fs = read_sreg(fs);\n    regs->gs = read_sreg(gs);\n\n    if ( cpu_has_fsgsbase && !is_pv_32bit_vcpu(v) )\n    {\n        v->arch.pv.fs_base = __rdfsbase();\n        if ( v->arch.flags & TF_kernel_mode )\n            v->arch.pv.gs_base_kernel = __rdgsbase();\n        else\n            v->arch.pv.gs_base_user = __rdgsbase();\n    }\n\n    if ( regs->ds )\n        dirty_segment_mask |= DIRTY_DS;\n\n    if ( regs->es )\n        dirty_segment_mask |= DIRTY_ES;\n\n    if ( regs->fs || is_pv_32bit_vcpu(v) )\n    {\n        dirty_segment_mask |= DIRTY_FS;\n        /* non-nul selector kills fs_base */\n        if ( regs->fs & ~3 )\n            v->arch.pv.fs_base = 0;\n    }\n    if ( v->arch.pv.fs_base )\n        dirty_segment_mask |= DIRTY_FS_BASE;\n\n    if ( regs->gs || is_pv_32bit_vcpu(v) )\n    {\n        dirty_segment_mask |= DIRTY_GS;\n        /* non-nul selector kills gs_base_user */\n        if ( regs->gs & ~3 )\n            v->arch.pv.gs_base_user = 0;\n    }\n    if ( v->arch.flags & TF_kernel_mode ? v->arch.pv.gs_base_kernel\n                                        : v->arch.pv.gs_base_user )\n        dirty_segment_mask |= DIRTY_GS_BASE;\n\n    this_cpu(dirty_segment_mask) = dirty_segment_mask;\n}"", ""target"": 0}, {""func_name"": ""write_cr4"", ""file_path"": ""xen/include/asm-x86/processor.h"", ""func_code"": ""static inline void write_cr4(unsigned long val)\n{\n    /* No global pages in case of PCIDs enabled! */\n    ASSERT(!(val & X86_CR4_PGE) || !(val & X86_CR4_PCIDE));\n\n    get_cpu_info()->cr4 = val;\n    asm volatile ( \""mov %0,%%cr4\"" : : \""r\"" (val) );\n}"", ""target"": 0}, {""func_name"": ""load_segments"", ""file_path"": ""xen/arch/x86/pv/domain.c"", ""func_code"": ""static void load_segments(struct vcpu *n)\n{\n    struct cpu_user_regs *uregs = &n->arch.user_regs;\n    int all_segs_okay = 1;\n    unsigned int dirty_segment_mask, cpu = smp_processor_id();\n    bool fs_gs_done = false;\n\n    /* Load and clear the dirty segment mask. */\n    dirty_segment_mask = per_cpu(dirty_segment_mask, cpu);\n    per_cpu(dirty_segment_mask, cpu) = 0;\n\n#ifdef CONFIG_HVM\n    if ( !is_pv_32bit_vcpu(n) && !cpu_has_fsgsbase && cpu_has_svm &&\n         !((uregs->fs | uregs->gs) & ~3) &&\n         /*\n          * The remaining part is just for optimization: If only shadow GS\n          * needs loading, there's nothing to be gained here.\n          */\n         (n->arch.pv.fs_base | n->arch.pv.gs_base_user | n->arch.pv.ldt_ents) )\n    {\n        unsigned long gsb = n->arch.flags & TF_kernel_mode\n            ? n->arch.pv.gs_base_kernel : n->arch.pv.gs_base_user;\n        unsigned long gss = n->arch.flags & TF_kernel_mode\n            ? n->arch.pv.gs_base_user : n->arch.pv.gs_base_kernel;\n\n        fs_gs_done = svm_load_segs(n->arch.pv.ldt_ents, LDT_VIRT_START(n),\n                                   uregs->fs, n->arch.pv.fs_base,\n                                   uregs->gs, gsb, gss);\n    }\n#endif\n    if ( !fs_gs_done )\n        load_LDT(n);\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_DS) | uregs->ds) )\n    {\n        preload_segment(ds, uregs->ds);\n        all_segs_okay &= loadsegment(ds, uregs->ds);\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_ES) | uregs->es) )\n    {\n        preload_segment(es, uregs->es);\n        all_segs_okay &= loadsegment(es, uregs->es);\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_FS) | uregs->fs) && !fs_gs_done )\n    {\n        all_segs_okay &= loadsegment(fs, uregs->fs);\n        /* non-nul selector updates fs_base */\n        if ( uregs->fs & ~3 )\n            dirty_segment_mask &= ~DIRTY_FS_BASE;\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_GS) | uregs->gs) && !fs_gs_done )\n    {\n        all_segs_okay &= loadsegment(gs, uregs->gs);\n        /* non-nul selector updates gs_base_user */\n        if ( uregs->gs & ~3 )\n            dirty_segment_mask &= ~DIRTY_GS_BASE;\n    }\n\n    if ( !fs_gs_done && !is_pv_32bit_vcpu(n) )\n    {\n        /* This can only be non-zero if selector is NULL. */\n        if ( n->arch.pv.fs_base | (dirty_segment_mask & DIRTY_FS_BASE) )\n            wrfsbase(n->arch.pv.fs_base);\n\n        /*\n         * Most kernels have non-zero GS base, so don't bother testing.\n         * (For old AMD hardware this is also a serialising instruction,\n         * avoiding erratum #88.)\n         */\n        wrgsshadow(n->arch.pv.gs_base_kernel);\n\n        /* This can only be non-zero if selector is NULL. */\n        if ( n->arch.pv.gs_base_user |\n             (dirty_segment_mask & DIRTY_GS_BASE) )\n            wrgsbase(n->arch.pv.gs_base_user);\n\n        /* If in kernel mode then switch the GS bases around. */\n        if ( (n->arch.flags & TF_kernel_mode) )\n            asm volatile ( \""swapgs\"" );\n    }\n\n    if ( unlikely(!all_segs_okay) )\n    {\n        struct pv_vcpu *pv = &n->arch.pv;\n        struct cpu_user_regs *regs = guest_cpu_user_regs();\n        unsigned long *rsp =\n            (unsigned long *)(((n->arch.flags & TF_kernel_mode)\n                               ? regs->rsp : pv->kernel_sp) & ~0xf);\n        unsigned long cs_and_mask, rflags;\n\n        /* Fold upcall mask and architectural IOPL into RFLAGS.IF. */\n        rflags  = regs->rflags & ~(X86_EFLAGS_IF|X86_EFLAGS_IOPL);\n        rflags |= !vcpu_info(n, evtchn_upcall_mask) << 9;\n        if ( VM_ASSIST(n->domain, architectural_iopl) )\n            rflags |= n->arch.pv.iopl;\n\n        if ( is_pv_32bit_vcpu(n) )\n        {\n            unsigned int *esp = ring_1(regs) ?\n                                (unsigned int *)regs->rsp :\n                                (unsigned int *)pv->kernel_sp;\n            int ret = 0;\n\n            /* CS longword also contains full evtchn_upcall_mask. */\n            cs_and_mask = (unsigned short)regs->cs |\n                ((unsigned int)vcpu_info(n, evtchn_upcall_mask) << 16);\n\n            if ( !ring_1(regs) )\n            {\n                ret  = put_user(regs->ss,       esp-1);\n                ret |= put_user(regs->esp,      esp-2);\n                esp -= 2;\n            }\n\n            if ( ret |\n                 put_user(rflags,              esp-1) |\n                 put_user(cs_and_mask,         esp-2) |\n                 put_user(regs->eip,           esp-3) |\n                 put_user(uregs->gs,           esp-4) |\n                 put_user(uregs->fs,           esp-5) |\n                 put_user(uregs->es,           esp-6) |\n                 put_user(uregs->ds,           esp-7) )\n            {\n                gprintk(XENLOG_ERR,\n                        \""error while creating compat failsafe callback frame\\n\"");\n                domain_crash(n->domain);\n            }\n\n            if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )\n                vcpu_info(n, evtchn_upcall_mask) = 1;\n\n            regs->entry_vector |= TRAP_syscall;\n            regs->eflags       &= ~(X86_EFLAGS_VM|X86_EFLAGS_RF|X86_EFLAGS_NT|\n                                    X86_EFLAGS_IOPL|X86_EFLAGS_TF);\n            regs->ss            = FLAT_COMPAT_KERNEL_SS;\n            regs->esp           = (unsigned long)(esp-7);\n            regs->cs            = FLAT_COMPAT_KERNEL_CS;\n            regs->eip           = pv->failsafe_callback_eip;\n            return;\n        }\n\n        if ( !(n->arch.flags & TF_kernel_mode) )\n            toggle_guest_mode(n);\n        else\n            regs->cs &= ~3;\n\n        /* CS longword also contains full evtchn_upcall_mask. */\n        cs_and_mask = (unsigned long)regs->cs |\n            ((unsigned long)vcpu_info(n, evtchn_upcall_mask) << 32);\n\n        if ( put_user(regs->ss,            rsp- 1) |\n             put_user(regs->rsp,           rsp- 2) |\n             put_user(rflags,              rsp- 3) |\n             put_user(cs_and_mask,         rsp- 4) |\n             put_user(regs->rip,           rsp- 5) |\n             put_user(uregs->gs,           rsp- 6) |\n             put_user(uregs->fs,           rsp- 7) |\n             put_user(uregs->es,           rsp- 8) |\n             put_user(uregs->ds,           rsp- 9) |\n             put_user(regs->r11,           rsp-10) |\n             put_user(regs->rcx,           rsp-11) )\n        {\n            gprintk(XENLOG_ERR,\n                    \""error while creating failsafe callback frame\\n\"");\n            domain_crash(n->domain);\n        }\n\n        if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )\n            vcpu_info(n, evtchn_upcall_mask) = 1;\n\n        regs->entry_vector |= TRAP_syscall;\n        regs->rflags       &= ~(X86_EFLAGS_AC|X86_EFLAGS_VM|X86_EFLAGS_RF|\n                                X86_EFLAGS_NT|X86_EFLAGS_IOPL|X86_EFLAGS_TF);\n        regs->ss            = FLAT_KERNEL_SS;\n        regs->rsp           = (unsigned long)(rsp-11);\n        regs->cs            = FLAT_KERNEL_CS;\n        regs->rip           = pv->failsafe_callback_eip;\n    }\n}"", ""target"": 0}, {""func_name"": ""__context_switch"", ""file_path"": ""xen/arch/x86/pv/domain.c"", ""func_code"": ""static void __context_switch(void)\n{\n    struct cpu_user_regs *stack_regs = guest_cpu_user_regs();\n    unsigned int          cpu = smp_processor_id();\n    struct vcpu          *p = per_cpu(curr_vcpu, cpu);\n    struct vcpu          *n = current;\n    struct domain        *pd = p->domain, *nd = n->domain;\n    seg_desc_t           *gdt;\n    struct desc_ptr       gdt_desc;\n\n    ASSERT(p != n);\n    ASSERT(!vcpu_cpu_dirty(n));\n\n    if ( !is_idle_domain(pd) )\n    {\n        memcpy(&p->arch.user_regs, stack_regs, CTXT_SWITCH_STACK_BYTES);\n        vcpu_save_fpu(p);\n        pd->arch.ctxt_switch->from(p);\n    }\n\n    /*\n     * Mark this CPU in next domain's dirty cpumasks before calling\n     * ctxt_switch_to(). This avoids a race on things like EPT flushing,\n     * which is synchronised on that function.\n     */\n    if ( pd != nd )\n        cpumask_set_cpu(cpu, nd->dirty_cpumask);\n    write_atomic(&n->dirty_cpu, cpu);\n\n    if ( !is_idle_domain(nd) )\n    {\n        memcpy(stack_regs, &n->arch.user_regs, CTXT_SWITCH_STACK_BYTES);\n        if ( cpu_has_xsave )\n        {\n            u64 xcr0 = n->arch.xcr0 ?: XSTATE_FP_SSE;\n\n            if ( xcr0 != get_xcr0() && !set_xcr0(xcr0) )\n                BUG();\n\n            if ( cpu_has_xsaves && is_hvm_vcpu(n) )\n                set_msr_xss(n->arch.hvm.msr_xss);\n        }\n        vcpu_restore_fpu_nonlazy(n, false);\n        nd->arch.ctxt_switch->to(n);\n    }\n\n    psr_ctxt_switch_to(nd);\n\n    gdt = !is_pv_32bit_domain(nd) ? per_cpu(gdt_table, cpu) :\n                                    per_cpu(compat_gdt_table, cpu);\n    if ( need_full_gdt(nd) )\n    {\n        unsigned long mfn = virt_to_mfn(gdt);\n        l1_pgentry_t *pl1e = pv_gdt_ptes(n);\n        unsigned int i;\n\n        for ( i = 0; i < NR_RESERVED_GDT_PAGES; i++ )\n            l1e_write(pl1e + FIRST_RESERVED_GDT_PAGE + i,\n                      l1e_from_pfn(mfn + i, __PAGE_HYPERVISOR_RW));\n    }\n\n    if ( need_full_gdt(pd) &&\n         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(nd)) )\n    {\n        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;\n        gdt_desc.base  = (unsigned long)(gdt - FIRST_RESERVED_GDT_ENTRY);\n\n        lgdt(&gdt_desc);\n    }\n\n    write_ptbase(n);\n\n#if defined(CONFIG_PV) && defined(CONFIG_HVM)\n    /* Prefetch the VMCB if we expect to use it later in the context switch */\n    if ( is_pv_domain(nd) && !is_pv_32bit_domain(nd) && !is_idle_domain(nd) &&\n         !cpu_has_fsgsbase && cpu_has_svm )\n        svm_load_segs(0, 0, 0, 0, 0, 0, 0);\n#endif\n\n    if ( need_full_gdt(nd) &&\n         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(pd)) )\n    {\n        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;\n        gdt_desc.base = GDT_VIRT_START(n);\n\n        lgdt(&gdt_desc);\n    }\n\n    if ( pd != nd )\n        cpumask_clear_cpu(cpu, pd->dirty_cpumask);\n    write_atomic(&p->dirty_cpu, VCPU_CPU_CLEAN);\n\n    per_cpu(curr_vcpu, cpu) = n;\n}"", ""target"": 0}, {""func_name"": ""save_segments"", ""file_path"": ""xen/arch/x86/pv/domain.c"", ""func_code"": ""static void save_segments(struct vcpu *v)\n{\n    struct cpu_user_regs *regs = &v->arch.user_regs;\n    unsigned int dirty_segment_mask = 0;\n\n    regs->ds = read_sreg(ds);\n    regs->es = read_sreg(es);\n    regs->fs = read_sreg(fs);\n    regs->gs = read_sreg(gs);\n\n    if ( cpu_has_fsgsbase && !is_pv_32bit_vcpu(v) )\n    {\n        v->arch.pv.fs_base = __rdfsbase();\n        if ( v->arch.flags & TF_kernel_mode )\n            v->arch.pv.gs_base_kernel = __rdgsbase();\n        else\n            v->arch.pv.gs_base_user = __rdgsbase();\n    }\n\n    if ( regs->ds )\n        dirty_segment_mask |= DIRTY_DS;\n\n    if ( regs->es )\n        dirty_segment_mask |= DIRTY_ES;\n\n    if ( regs->fs || is_pv_32bit_vcpu(v) )\n    {\n        dirty_segment_mask |= DIRTY_FS;\n        /* non-nul selector kills fs_base */\n        if ( regs->fs & ~3 )\n            v->arch.pv.fs_base = 0;\n    }\n    if ( v->arch.pv.fs_base )\n        dirty_segment_mask |= DIRTY_FS_BASE;\n\n    if ( regs->gs || is_pv_32bit_vcpu(v) )\n    {\n        dirty_segment_mask |= DIRTY_GS;\n        /* non-nul selector kills gs_base_user */\n        if ( regs->gs & ~3 )\n            v->arch.pv.gs_base_user = 0;\n    }\n    if ( v->arch.flags & TF_kernel_mode ? v->arch.pv.gs_base_kernel\n                                        : v->arch.pv.gs_base_user )\n        dirty_segment_mask |= DIRTY_GS_BASE;\n\n    this_cpu(dirty_segment_mask) = dirty_segment_mask;\n}"", ""target"": 0}, {""func_name"": ""wrfsbase"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline void wrfsbase(unsigned long base)\n{\n    if ( cpu_has_fsgsbase )\n#ifdef HAVE_AS_FSGSBASE\n        asm volatile ( \""wrfsbase %0\"" :: \""r\"" (base) );\n#else\n        asm volatile ( \"".byte 0xf3, 0x48, 0x0f, 0xae, 0xd0\"" :: \""a\"" (base) );\n#endif\n    else\n        wrmsrl(MSR_FS_BASE, base);\n}"", ""target"": 0}, {""func_name"": ""rdfsbase"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline unsigned long rdfsbase(void)\n{\n    unsigned long base;\n\n    if ( cpu_has_fsgsbase )\n        return __rdfsbase();\n\n    rdmsrl(MSR_FS_BASE, base);\n\n    return base;\n}"", ""target"": 0}, {""func_name"": ""rdgsbase"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline unsigned long rdgsbase(void)\n{\n    unsigned long base;\n\n    if ( cpu_has_fsgsbase )\n        return __rdgsbase();\n\n    rdmsrl(MSR_GS_BASE, base);\n\n    return base;\n}"", ""target"": 0}, {""func_name"": ""wrgsshadow"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline void wrgsshadow(unsigned long base)\n{\n    if ( cpu_has_fsgsbase )\n    {\n        asm volatile ( \""swapgs\\n\\t\""\n#ifdef HAVE_AS_FSGSBASE\n                       \""wrgsbase %0\\n\\t\""\n                       \""swapgs\""\n                       :: \""r\"" (base) );\n#else\n                       \"".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8\\n\\t\""\n                       \""swapgs\""\n                       :: \""a\"" (base) );\n#endif\n    }\n    else\n        wrmsrl(MSR_SHADOW_GS_BASE, base);\n}"", ""target"": 0}, {""func_name"": ""rdgsshadow"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline unsigned long rdgsshadow(void)\n{\n    unsigned long base;\n\n    if ( cpu_has_fsgsbase )\n    {\n        asm volatile ( \""swapgs\"" );\n        base = __rdgsbase();\n        asm volatile ( \""swapgs\"" );\n    }\n    else\n        rdmsrl(MSR_SHADOW_GS_BASE, base);\n\n    return base;\n}"", ""target"": 0}, {""func_name"": ""wrgsbase"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline void wrgsbase(unsigned long base)\n{\n    if ( cpu_has_fsgsbase )\n#ifdef HAVE_AS_FSGSBASE\n        asm volatile ( \""wrgsbase %0\"" :: \""r\"" (base) );\n#else\n        asm volatile ( \"".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8\"" :: \""a\"" (base) );\n#endif\n    else\n        wrmsrl(MSR_GS_BASE, base);\n}"", ""target"": 0}, {""func_name"": ""write_ptbase"", ""file_path"": ""xen/arch/x86/mm.c"", ""func_code"": ""void write_ptbase(struct vcpu *v)\n{\n    struct cpu_info *cpu_info = get_cpu_info();\n    unsigned long new_cr4;\n\n    new_cr4 = (is_pv_vcpu(v) && !is_idle_vcpu(v))\n              ? pv_guest_cr4_to_real_cr4(v)\n              : ((read_cr4() & ~(X86_CR4_PCIDE | X86_CR4_TSD)) | X86_CR4_PGE);\n\n    if ( is_pv_vcpu(v) && v->domain->arch.pv.xpti )\n    {\n        cpu_info->root_pgt_changed = true;\n        cpu_info->pv_cr3 = __pa(this_cpu(root_pgt));\n        if ( new_cr4 & X86_CR4_PCIDE )\n            cpu_info->pv_cr3 |= get_pcid_bits(v, true);\n        switch_cr3_cr4(v->arch.cr3, new_cr4);\n    }\n    else\n    {\n        /* Make sure to clear use_pv_cr3 and xen_cr3 before pv_cr3. */\n        cpu_info->use_pv_cr3 = false;\n        cpu_info->xen_cr3 = 0;\n        /* switch_cr3_cr4() serializes. */\n        switch_cr3_cr4(v->arch.cr3, new_cr4);\n        cpu_info->pv_cr3 = 0;\n    }\n\n    ASSERT(is_pv_vcpu(v) || read_cr4() == mmu_cr4_features);\n}"", ""target"": 0}, {""func_name"": ""write_cr"", ""file_path"": ""xen/arch/x86/pv/emul-priv-op.c"", ""func_code"": ""static int write_cr(unsigned int reg, unsigned long val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n\n    switch ( reg )\n    {\n    case 0: /* Write CR0 */\n        if ( (val ^ read_cr0()) & ~X86_CR0_TS )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \""Attempt to change unmodifiable CR0 flags\\n\"");\n            break;\n        }\n        do_fpu_taskswitch(!!(val & X86_CR0_TS));\n        return X86EMUL_OKAY;\n\n    case 2: /* Write CR2 */\n        curr->arch.pv.ctrlreg[2] = val;\n        arch_set_cr2(curr, val);\n        return X86EMUL_OKAY;\n\n    case 3: /* Write CR3 */\n    {\n        struct domain *currd = curr->domain;\n        unsigned long gfn;\n        struct page_info *page;\n        int rc;\n\n        gfn = !is_pv_32bit_domain(currd)\n              ? xen_cr3_to_pfn(val) : compat_cr3_to_pfn(val);\n        page = get_page_from_gfn(currd, gfn, NULL, P2M_ALLOC);\n        if ( !page )\n            break;\n        rc = new_guest_cr3(page_to_mfn(page));\n        put_page(page);\n\n        switch ( rc )\n        {\n        case 0:\n            return X86EMUL_OKAY;\n        case -ERESTART: /* retry after preemption */\n            return X86EMUL_RETRY;\n        }\n        break;\n    }\n\n    case 4: /* Write CR4 */\n        curr->arch.pv.ctrlreg[4] = pv_guest_cr4_fixup(curr, val);\n        write_cr4(pv_guest_cr4_to_real_cr4(curr));\n        ctxt_switch_levelling(curr);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}"", ""target"": 0}, {""func_name"": ""arch_set_info_guest"", ""file_path"": ""xen/arch/x86/domain.c"", ""func_code"": ""int arch_set_info_guest(\n    struct vcpu *v, vcpu_guest_context_u c)\n{\n    struct domain *d = v->domain;\n    unsigned int i;\n    unsigned long flags;\n    bool compat;\n#ifdef CONFIG_PV\n    unsigned long cr3_gfn;\n    struct page_info *cr3_page;\n    unsigned long cr4;\n    int rc = 0;\n#endif\n\n    /* The context is a compat-mode one if the target domain is compat-mode;\n     * we expect the tools to DTRT even in compat-mode callers. */\n    compat = is_pv_32bit_domain(d);\n\n#define c(fld) (compat ? (c.cmp->fld) : (c.nat->fld))\n    flags = c(flags);\n\n    if ( is_pv_domain(d) )\n    {\n        if ( !compat )\n        {\n            if ( !is_canonical_address(c.nat->user_regs.rip) ||\n                 !is_canonical_address(c.nat->user_regs.rsp) ||\n                 !is_canonical_address(c.nat->kernel_sp) ||\n                 (c.nat->ldt_ents && !is_canonical_address(c.nat->ldt_base)) ||\n                 !is_canonical_address(c.nat->fs_base) ||\n                 !is_canonical_address(c.nat->gs_base_kernel) ||\n                 !is_canonical_address(c.nat->gs_base_user) ||\n                 !is_canonical_address(c.nat->event_callback_eip) ||\n                 !is_canonical_address(c.nat->syscall_callback_eip) ||\n                 !is_canonical_address(c.nat->failsafe_callback_eip) )\n                return -EINVAL;\n\n            fixup_guest_stack_selector(d, c.nat->user_regs.ss);\n            fixup_guest_stack_selector(d, c.nat->kernel_ss);\n            fixup_guest_code_selector(d, c.nat->user_regs.cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.nat->trap_ctxt); i++ )\n            {\n                if ( !is_canonical_address(c.nat->trap_ctxt[i].address) )\n                    return -EINVAL;\n                fixup_guest_code_selector(d, c.nat->trap_ctxt[i].cs);\n            }\n\n            if ( !__addr_ok(c.nat->ldt_base) )\n                return -EINVAL;\n        }\n        else\n        {\n            fixup_guest_stack_selector(d, c.cmp->user_regs.ss);\n            fixup_guest_stack_selector(d, c.cmp->kernel_ss);\n            fixup_guest_code_selector(d, c.cmp->user_regs.cs);\n            fixup_guest_code_selector(d, c.cmp->event_callback_cs);\n            fixup_guest_code_selector(d, c.cmp->failsafe_callback_cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); i++ )\n                fixup_guest_code_selector(d, c.cmp->trap_ctxt[i].cs);\n        }\n\n        /* LDT safety checks. */\n        if ( ((c(ldt_base) & (PAGE_SIZE - 1)) != 0) ||\n             (c(ldt_ents) > 8192) )\n            return -EINVAL;\n    }\n\n    v->arch.flags &= ~TF_kernel_mode;\n    if ( (flags & VGCF_in_kernel) || is_hvm_domain(d)/*???*/ )\n        v->arch.flags |= TF_kernel_mode;\n\n    v->arch.vgc_flags = flags;\n\n    vcpu_setup_fpu(v, v->arch.xsave_area,\n                   flags & VGCF_I387_VALID ? &c.nat->fpu_ctxt : NULL,\n                   FCW_DEFAULT);\n\n    if ( !compat )\n    {\n        memcpy(&v->arch.user_regs, &c.nat->user_regs, sizeof(c.nat->user_regs));\n        if ( is_pv_domain(d) )\n            memcpy(v->arch.pv.trap_ctxt, c.nat->trap_ctxt,\n                   sizeof(c.nat->trap_ctxt));\n    }\n    else\n    {\n        XLAT_cpu_user_regs(&v->arch.user_regs, &c.cmp->user_regs);\n        if ( is_pv_domain(d) )\n        {\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); ++i )\n                XLAT_trap_info(v->arch.pv.trap_ctxt + i,\n                               c.cmp->trap_ctxt + i);\n        }\n    }\n\n    if ( is_hvm_domain(d) )\n    {\n        for ( i = 0; i < ARRAY_SIZE(v->arch.dr); ++i )\n            v->arch.dr[i] = c(debugreg[i]);\n        v->arch.dr6 = c(debugreg[6]);\n        v->arch.dr7 = c(debugreg[7]);\n\n        hvm_set_info_guest(v);\n        goto out;\n    }\n\n#ifdef CONFIG_PV\n    /* IOPL privileges are virtualised. */\n    v->arch.pv.iopl = v->arch.user_regs.eflags & X86_EFLAGS_IOPL;\n    v->arch.user_regs.eflags &= ~X86_EFLAGS_IOPL;\n\n    /* Ensure real hardware interrupts are enabled. */\n    v->arch.user_regs.eflags |= X86_EFLAGS_IF;\n\n    if ( !v->is_initialised )\n    {\n        if ( !compat && !(flags & VGCF_in_kernel) && !c.nat->ctrlreg[1] )\n            return -EINVAL;\n\n        v->arch.pv.ldt_base = c(ldt_base);\n        v->arch.pv.ldt_ents = c(ldt_ents);\n    }\n    else\n    {\n        unsigned long pfn = pagetable_get_pfn(v->arch.guest_table);\n        bool fail;\n\n        if ( !compat )\n        {\n            fail = xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[3];\n            if ( pagetable_is_null(v->arch.guest_table_user) )\n                fail |= c.nat->ctrlreg[1] || !(flags & VGCF_in_kernel);\n            else\n            {\n                pfn = pagetable_get_pfn(v->arch.guest_table_user);\n                fail |= xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[1];\n            }\n        } else {\n            l4_pgentry_t *l4tab = map_domain_page(_mfn(pfn));\n\n            pfn = l4e_get_pfn(*l4tab);\n            unmap_domain_page(l4tab);\n            fail = compat_pfn_to_cr3(pfn) != c.cmp->ctrlreg[3];\n        }\n\n        for ( i = 0; i < ARRAY_SIZE(v->arch.pv.gdt_frames); ++i )\n            fail |= v->arch.pv.gdt_frames[i] != c(gdt_frames[i]);\n        fail |= v->arch.pv.gdt_ents != c(gdt_ents);\n\n        fail |= v->arch.pv.ldt_base != c(ldt_base);\n        fail |= v->arch.pv.ldt_ents != c(ldt_ents);\n\n        if ( fail )\n           return -EOPNOTSUPP;\n    }\n\n    v->arch.pv.kernel_ss = c(kernel_ss);\n    v->arch.pv.kernel_sp = c(kernel_sp);\n    for ( i = 0; i < ARRAY_SIZE(v->arch.pv.ctrlreg); ++i )\n        v->arch.pv.ctrlreg[i] = c(ctrlreg[i]);\n\n    v->arch.pv.event_callback_eip = c(event_callback_eip);\n    v->arch.pv.failsafe_callback_eip = c(failsafe_callback_eip);\n    if ( !compat )\n    {\n        v->arch.pv.syscall_callback_eip = c.nat->syscall_callback_eip;\n        /* non-nul selector kills fs_base */\n        v->arch.pv.fs_base =\n            !(v->arch.user_regs.fs & ~3) ? c.nat->fs_base : 0;\n        v->arch.pv.gs_base_kernel = c.nat->gs_base_kernel;\n        /* non-nul selector kills gs_base_user */\n        v->arch.pv.gs_base_user =\n            !(v->arch.user_regs.gs & ~3) ? c.nat->gs_base_user : 0;\n    }\n    else\n    {\n        v->arch.pv.event_callback_cs = c(event_callback_cs);\n        v->arch.pv.failsafe_callback_cs = c(failsafe_callback_cs);\n    }\n\n    /* Only CR0.TS is modifiable by guest or admin. */\n    v->arch.pv.ctrlreg[0] &= X86_CR0_TS;\n    v->arch.pv.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;\n\n    cr4 = v->arch.pv.ctrlreg[4];\n    v->arch.pv.ctrlreg[4] = cr4 ? pv_guest_cr4_fixup(v, cr4) :\n        real_cr4_to_pv_guest_cr4(mmu_cr4_features);\n\n    memset(v->arch.dr, 0, sizeof(v->arch.dr));\n    v->arch.dr6 = X86_DR6_DEFAULT;\n    v->arch.dr7 = X86_DR7_DEFAULT;\n    v->arch.pv.dr7_emul = 0;\n\n    for ( i = 0; i < ARRAY_SIZE(v->arch.dr); i++ )\n        set_debugreg(v, i, c(debugreg[i]));\n    set_debugreg(v, 6, c(debugreg[6]));\n    set_debugreg(v, 7, c(debugreg[7]));\n\n    if ( v->is_initialised )\n        goto out;\n\n    if ( v->vcpu_id == 0 )\n    {\n        /*\n         * In the restore case we need to deal with L4 pages which got\n         * initialized with m2p_strict still clear (and which hence lack the\n         * correct initial RO_MPT_VIRT_{START,END} L4 entry).\n         */\n        if ( d != current->domain && !VM_ASSIST(d, m2p_strict) &&\n             is_pv_domain(d) && !is_pv_32bit_domain(d) &&\n             test_bit(VMASST_TYPE_m2p_strict, &c.nat->vm_assist) &&\n             atomic_read(&d->arch.pv.nr_l4_pages) )\n        {\n            bool done = false;\n\n            spin_lock_recursive(&d->page_alloc_lock);\n\n            for ( i = 0; ; )\n            {\n                struct page_info *page = page_list_remove_head(&d->page_list);\n\n                if ( page_lock(page) )\n                {\n                    if ( (page->u.inuse.type_info & PGT_type_mask) ==\n                         PGT_l4_page_table )\n                        done = !fill_ro_mpt(page_to_mfn(page));\n\n                    page_unlock(page);\n                }\n\n                page_list_add_tail(page, &d->page_list);\n\n                if ( done || (!(++i & 0xff) && hypercall_preempt_check()) )\n                    break;\n            }\n\n            spin_unlock_recursive(&d->page_alloc_lock);\n\n            if ( !done )\n                return -ERESTART;\n        }\n\n        d->vm_assist = c(vm_assist);\n    }\n\n    rc = put_old_guest_table(current);\n    if ( rc )\n        return rc;\n\n    if ( !compat )\n        rc = (int)pv_set_gdt(v, c.nat->gdt_frames, c.nat->gdt_ents);\n    else\n    {\n        unsigned long gdt_frames[ARRAY_SIZE(v->arch.pv.gdt_frames)];\n        unsigned int nr_frames = DIV_ROUND_UP(c.cmp->gdt_ents, 512);\n\n        if ( nr_frames > ARRAY_SIZE(v->arch.pv.gdt_frames) )\n            return -EINVAL;\n\n        for ( i = 0; i < nr_frames; ++i )\n            gdt_frames[i] = c.cmp->gdt_frames[i];\n\n        rc = (int)pv_set_gdt(v, gdt_frames, c.cmp->gdt_ents);\n    }\n    if ( rc != 0 )\n        return rc;\n\n    set_bit(_VPF_in_reset, &v->pause_flags);\n\n    if ( !compat )\n        cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[3]);\n    else\n        cr3_gfn = compat_cr3_to_pfn(c.cmp->ctrlreg[3]);\n    cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n    if ( !cr3_page )\n        rc = -EINVAL;\n    else if ( paging_mode_refcounts(d) )\n        /* nothing */;\n    else if ( cr3_page == v->arch.old_guest_table )\n    {\n        v->arch.old_guest_table = NULL;\n        put_page(cr3_page);\n    }\n    else\n    {\n        if ( !compat )\n            rc = put_old_guest_table(v);\n        if ( !rc )\n            rc = get_page_type_preemptible(cr3_page,\n                                           !compat ? PGT_root_page_table\n                                                   : PGT_l3_page_table);\n        switch ( rc )\n        {\n        case -EINTR:\n            rc = -ERESTART;\n        case -ERESTART:\n            break;\n        case 0:\n            if ( !compat && !VM_ASSIST(d, m2p_strict) &&\n                 !paging_mode_refcounts(d) )\n                fill_ro_mpt(_mfn(cr3_gfn));\n            break;\n        default:\n            if ( cr3_page == current->arch.old_guest_table )\n                cr3_page = NULL;\n            break;\n        }\n    }\n    if ( rc )\n        /* handled below */;\n    else if ( !compat )\n    {\n        v->arch.guest_table = pagetable_from_page(cr3_page);\n        if ( c.nat->ctrlreg[1] )\n        {\n            cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[1]);\n            cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n            if ( !cr3_page )\n                rc = -EINVAL;\n            else if ( !paging_mode_refcounts(d) )\n            {\n                rc = get_page_type_preemptible(cr3_page, PGT_root_page_table);\n                switch ( rc )\n                {\n                case -EINTR:\n                    rc = -ERESTART;\n                    /* Fallthrough */\n                case -ERESTART:\n                    v->arch.old_guest_ptpg = NULL;\n                    v->arch.old_guest_table =\n                        pagetable_get_page(v->arch.guest_table);\n                    v->arch.guest_table = pagetable_null();\n                    break;\n                default:\n                    if ( cr3_page == current->arch.old_guest_table )\n                        cr3_page = NULL;\n                    break;\n                case 0:\n                    if ( VM_ASSIST(d, m2p_strict) )\n                        zap_ro_mpt(_mfn(cr3_gfn));\n                    break;\n                }\n            }\n            if ( !rc )\n               v->arch.guest_table_user = pagetable_from_page(cr3_page);\n        }\n    }\n    else\n    {\n        l4_pgentry_t *l4tab;\n\n        l4tab = map_domain_page(pagetable_get_mfn(v->arch.guest_table));\n        *l4tab = l4e_from_mfn(page_to_mfn(cr3_page),\n            _PAGE_PRESENT|_PAGE_RW|_PAGE_USER|_PAGE_ACCESSED);\n        unmap_domain_page(l4tab);\n    }\n    if ( rc )\n    {\n        if ( cr3_page )\n            put_page(cr3_page);\n        pv_destroy_gdt(v);\n        return rc;\n    }\n\n    clear_bit(_VPF_in_reset, &v->pause_flags);\n\n    if ( v->vcpu_id == 0 )\n        update_domain_wallclock_time(d);\n\n    /* Don't redo final setup */\n    v->is_initialised = 1;\n\n    if ( paging_mode_enabled(d) )\n        paging_update_paging_modes(v);\n\n    update_cr3(v);\n#endif /* CONFIG_PV */\n\n out:\n    if ( flags & VGCF_online )\n        clear_bit(_VPF_down, &v->pause_flags);\n    else\n        set_bit(_VPF_down, &v->pause_flags);\n    return 0;\n#undef c\n}"", ""target"": 0}, {""func_name"": ""arch_set_info_guest"", ""file_path"": ""xen/arch/x86/pv/domain.c"", ""func_code"": ""int arch_set_info_guest(\n    struct vcpu *v, vcpu_guest_context_u c)\n{\n    struct domain *d = v->domain;\n    unsigned int i;\n    unsigned long flags;\n    bool compat;\n#ifdef CONFIG_PV\n    unsigned long cr3_gfn;\n    struct page_info *cr3_page;\n    unsigned long cr4;\n    int rc = 0;\n#endif\n\n    /* The context is a compat-mode one if the target domain is compat-mode;\n     * we expect the tools to DTRT even in compat-mode callers. */\n    compat = is_pv_32bit_domain(d);\n\n#define c(fld) (compat ? (c.cmp->fld) : (c.nat->fld))\n    flags = c(flags);\n\n    if ( is_pv_domain(d) )\n    {\n        if ( !compat )\n        {\n            if ( !is_canonical_address(c.nat->user_regs.rip) ||\n                 !is_canonical_address(c.nat->user_regs.rsp) ||\n                 !is_canonical_address(c.nat->kernel_sp) ||\n                 (c.nat->ldt_ents && !is_canonical_address(c.nat->ldt_base)) ||\n                 !is_canonical_address(c.nat->fs_base) ||\n                 !is_canonical_address(c.nat->gs_base_kernel) ||\n                 !is_canonical_address(c.nat->gs_base_user) ||\n                 !is_canonical_address(c.nat->event_callback_eip) ||\n                 !is_canonical_address(c.nat->syscall_callback_eip) ||\n                 !is_canonical_address(c.nat->failsafe_callback_eip) )\n                return -EINVAL;\n\n            fixup_guest_stack_selector(d, c.nat->user_regs.ss);\n            fixup_guest_stack_selector(d, c.nat->kernel_ss);\n            fixup_guest_code_selector(d, c.nat->user_regs.cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.nat->trap_ctxt); i++ )\n            {\n                if ( !is_canonical_address(c.nat->trap_ctxt[i].address) )\n                    return -EINVAL;\n                fixup_guest_code_selector(d, c.nat->trap_ctxt[i].cs);\n            }\n\n            if ( !__addr_ok(c.nat->ldt_base) )\n                return -EINVAL;\n        }\n        else\n        {\n            fixup_guest_stack_selector(d, c.cmp->user_regs.ss);\n            fixup_guest_stack_selector(d, c.cmp->kernel_ss);\n            fixup_guest_code_selector(d, c.cmp->user_regs.cs);\n            fixup_guest_code_selector(d, c.cmp->event_callback_cs);\n            fixup_guest_code_selector(d, c.cmp->failsafe_callback_cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); i++ )\n                fixup_guest_code_selector(d, c.cmp->trap_ctxt[i].cs);\n        }\n\n        /* LDT safety checks. */\n        if ( ((c(ldt_base) & (PAGE_SIZE - 1)) != 0) ||\n             (c(ldt_ents) > 8192) )\n            return -EINVAL;\n    }\n\n    v->arch.flags &= ~TF_kernel_mode;\n    if ( (flags & VGCF_in_kernel) || is_hvm_domain(d)/*???*/ )\n        v->arch.flags |= TF_kernel_mode;\n\n    v->arch.vgc_flags = flags;\n\n    vcpu_setup_fpu(v, v->arch.xsave_area,\n                   flags & VGCF_I387_VALID ? &c.nat->fpu_ctxt : NULL,\n                   FCW_DEFAULT);\n\n    if ( !compat )\n    {\n        memcpy(&v->arch.user_regs, &c.nat->user_regs, sizeof(c.nat->user_regs));\n        if ( is_pv_domain(d) )\n            memcpy(v->arch.pv.trap_ctxt, c.nat->trap_ctxt,\n                   sizeof(c.nat->trap_ctxt));\n    }\n    else\n    {\n        XLAT_cpu_user_regs(&v->arch.user_regs, &c.cmp->user_regs);\n        if ( is_pv_domain(d) )\n        {\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); ++i )\n                XLAT_trap_info(v->arch.pv.trap_ctxt + i,\n                               c.cmp->trap_ctxt + i);\n        }\n    }\n\n    if ( is_hvm_domain(d) )\n    {\n        for ( i = 0; i < ARRAY_SIZE(v->arch.dr); ++i )\n            v->arch.dr[i] = c(debugreg[i]);\n        v->arch.dr6 = c(debugreg[6]);\n        v->arch.dr7 = c(debugreg[7]);\n\n        hvm_set_info_guest(v);\n        goto out;\n    }\n\n#ifdef CONFIG_PV\n    /* IOPL privileges are virtualised. */\n    v->arch.pv.iopl = v->arch.user_regs.eflags & X86_EFLAGS_IOPL;\n    v->arch.user_regs.eflags &= ~X86_EFLAGS_IOPL;\n\n    /* Ensure real hardware interrupts are enabled. */\n    v->arch.user_regs.eflags |= X86_EFLAGS_IF;\n\n    if ( !v->is_initialised )\n    {\n        if ( !compat && !(flags & VGCF_in_kernel) && !c.nat->ctrlreg[1] )\n            return -EINVAL;\n\n        v->arch.pv.ldt_base = c(ldt_base);\n        v->arch.pv.ldt_ents = c(ldt_ents);\n    }\n    else\n    {\n        unsigned long pfn = pagetable_get_pfn(v->arch.guest_table);\n        bool fail;\n\n        if ( !compat )\n        {\n            fail = xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[3];\n            if ( pagetable_is_null(v->arch.guest_table_user) )\n                fail |= c.nat->ctrlreg[1] || !(flags & VGCF_in_kernel);\n            else\n            {\n                pfn = pagetable_get_pfn(v->arch.guest_table_user);\n                fail |= xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[1];\n            }\n        } else {\n            l4_pgentry_t *l4tab = map_domain_page(_mfn(pfn));\n\n            pfn = l4e_get_pfn(*l4tab);\n            unmap_domain_page(l4tab);\n            fail = compat_pfn_to_cr3(pfn) != c.cmp->ctrlreg[3];\n        }\n\n        for ( i = 0; i < ARRAY_SIZE(v->arch.pv.gdt_frames); ++i )\n            fail |= v->arch.pv.gdt_frames[i] != c(gdt_frames[i]);\n        fail |= v->arch.pv.gdt_ents != c(gdt_ents);\n\n        fail |= v->arch.pv.ldt_base != c(ldt_base);\n        fail |= v->arch.pv.ldt_ents != c(ldt_ents);\n\n        if ( fail )\n           return -EOPNOTSUPP;\n    }\n\n    v->arch.pv.kernel_ss = c(kernel_ss);\n    v->arch.pv.kernel_sp = c(kernel_sp);\n    for ( i = 0; i < ARRAY_SIZE(v->arch.pv.ctrlreg); ++i )\n        v->arch.pv.ctrlreg[i] = c(ctrlreg[i]);\n\n    v->arch.pv.event_callback_eip = c(event_callback_eip);\n    v->arch.pv.failsafe_callback_eip = c(failsafe_callback_eip);\n    if ( !compat )\n    {\n        v->arch.pv.syscall_callback_eip = c.nat->syscall_callback_eip;\n        /* non-nul selector kills fs_base */\n        v->arch.pv.fs_base =\n            !(v->arch.user_regs.fs & ~3) ? c.nat->fs_base : 0;\n        v->arch.pv.gs_base_kernel = c.nat->gs_base_kernel;\n        /* non-nul selector kills gs_base_user */\n        v->arch.pv.gs_base_user =\n            !(v->arch.user_regs.gs & ~3) ? c.nat->gs_base_user : 0;\n    }\n    else\n    {\n        v->arch.pv.event_callback_cs = c(event_callback_cs);\n        v->arch.pv.failsafe_callback_cs = c(failsafe_callback_cs);\n    }\n\n    /* Only CR0.TS is modifiable by guest or admin. */\n    v->arch.pv.ctrlreg[0] &= X86_CR0_TS;\n    v->arch.pv.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;\n\n    cr4 = v->arch.pv.ctrlreg[4];\n    v->arch.pv.ctrlreg[4] = cr4 ? pv_guest_cr4_fixup(v, cr4) :\n        real_cr4_to_pv_guest_cr4(mmu_cr4_features);\n\n    memset(v->arch.dr, 0, sizeof(v->arch.dr));\n    v->arch.dr6 = X86_DR6_DEFAULT;\n    v->arch.dr7 = X86_DR7_DEFAULT;\n    v->arch.pv.dr7_emul = 0;\n\n    for ( i = 0; i < ARRAY_SIZE(v->arch.dr); i++ )\n        set_debugreg(v, i, c(debugreg[i]));\n    set_debugreg(v, 6, c(debugreg[6]));\n    set_debugreg(v, 7, c(debugreg[7]));\n\n    if ( v->is_initialised )\n        goto out;\n\n    if ( v->vcpu_id == 0 )\n    {\n        /*\n         * In the restore case we need to deal with L4 pages which got\n         * initialized with m2p_strict still clear (and which hence lack the\n         * correct initial RO_MPT_VIRT_{START,END} L4 entry).\n         */\n        if ( d != current->domain && !VM_ASSIST(d, m2p_strict) &&\n             is_pv_domain(d) && !is_pv_32bit_domain(d) &&\n             test_bit(VMASST_TYPE_m2p_strict, &c.nat->vm_assist) &&\n             atomic_read(&d->arch.pv.nr_l4_pages) )\n        {\n            bool done = false;\n\n            spin_lock_recursive(&d->page_alloc_lock);\n\n            for ( i = 0; ; )\n            {\n                struct page_info *page = page_list_remove_head(&d->page_list);\n\n                if ( page_lock(page) )\n                {\n                    if ( (page->u.inuse.type_info & PGT_type_mask) ==\n                         PGT_l4_page_table )\n                        done = !fill_ro_mpt(page_to_mfn(page));\n\n                    page_unlock(page);\n                }\n\n                page_list_add_tail(page, &d->page_list);\n\n                if ( done || (!(++i & 0xff) && hypercall_preempt_check()) )\n                    break;\n            }\n\n            spin_unlock_recursive(&d->page_alloc_lock);\n\n            if ( !done )\n                return -ERESTART;\n        }\n\n        d->vm_assist = c(vm_assist);\n    }\n\n    rc = put_old_guest_table(current);\n    if ( rc )\n        return rc;\n\n    if ( !compat )\n        rc = (int)pv_set_gdt(v, c.nat->gdt_frames, c.nat->gdt_ents);\n    else\n    {\n        unsigned long gdt_frames[ARRAY_SIZE(v->arch.pv.gdt_frames)];\n        unsigned int nr_frames = DIV_ROUND_UP(c.cmp->gdt_ents, 512);\n\n        if ( nr_frames > ARRAY_SIZE(v->arch.pv.gdt_frames) )\n            return -EINVAL;\n\n        for ( i = 0; i < nr_frames; ++i )\n            gdt_frames[i] = c.cmp->gdt_frames[i];\n\n        rc = (int)pv_set_gdt(v, gdt_frames, c.cmp->gdt_ents);\n    }\n    if ( rc != 0 )\n        return rc;\n\n    set_bit(_VPF_in_reset, &v->pause_flags);\n\n    if ( !compat )\n        cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[3]);\n    else\n        cr3_gfn = compat_cr3_to_pfn(c.cmp->ctrlreg[3]);\n    cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n    if ( !cr3_page )\n        rc = -EINVAL;\n    else if ( paging_mode_refcounts(d) )\n        /* nothing */;\n    else if ( cr3_page == v->arch.old_guest_table )\n    {\n        v->arch.old_guest_table = NULL;\n        put_page(cr3_page);\n    }\n    else\n    {\n        if ( !compat )\n            rc = put_old_guest_table(v);\n        if ( !rc )\n            rc = get_page_type_preemptible(cr3_page,\n                                           !compat ? PGT_root_page_table\n                                                   : PGT_l3_page_table);\n        switch ( rc )\n        {\n        case -EINTR:\n            rc = -ERESTART;\n        case -ERESTART:\n            break;\n        case 0:\n            if ( !compat && !VM_ASSIST(d, m2p_strict) &&\n                 !paging_mode_refcounts(d) )\n                fill_ro_mpt(_mfn(cr3_gfn));\n            break;\n        default:\n            if ( cr3_page == current->arch.old_guest_table )\n                cr3_page = NULL;\n            break;\n        }\n    }\n    if ( rc )\n        /* handled below */;\n    else if ( !compat )\n    {\n        v->arch.guest_table = pagetable_from_page(cr3_page);\n        if ( c.nat->ctrlreg[1] )\n        {\n            cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[1]);\n            cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n            if ( !cr3_page )\n                rc = -EINVAL;\n            else if ( !paging_mode_refcounts(d) )\n            {\n                rc = get_page_type_preemptible(cr3_page, PGT_root_page_table);\n                switch ( rc )\n                {\n                case -EINTR:\n                    rc = -ERESTART;\n                    /* Fallthrough */\n                case -ERESTART:\n                    v->arch.old_guest_ptpg = NULL;\n                    v->arch.old_guest_table =\n                        pagetable_get_page(v->arch.guest_table);\n                    v->arch.guest_table = pagetable_null();\n                    break;\n                default:\n                    if ( cr3_page == current->arch.old_guest_table )\n                        cr3_page = NULL;\n                    break;\n                case 0:\n                    if ( VM_ASSIST(d, m2p_strict) )\n                        zap_ro_mpt(_mfn(cr3_gfn));\n                    break;\n                }\n            }\n            if ( !rc )\n               v->arch.guest_table_user = pagetable_from_page(cr3_page);\n        }\n    }\n    else\n    {\n        l4_pgentry_t *l4tab;\n\n        l4tab = map_domain_page(pagetable_get_mfn(v->arch.guest_table));\n        *l4tab = l4e_from_mfn(page_to_mfn(cr3_page),\n            _PAGE_PRESENT|_PAGE_RW|_PAGE_USER|_PAGE_ACCESSED);\n        unmap_domain_page(l4tab);\n    }\n    if ( rc )\n    {\n        if ( cr3_page )\n            put_page(cr3_page);\n        pv_destroy_gdt(v);\n        return rc;\n    }\n\n    clear_bit(_VPF_in_reset, &v->pause_flags);\n\n    if ( v->vcpu_id == 0 )\n        update_domain_wallclock_time(d);\n\n    /* Don't redo final setup */\n    v->is_initialised = 1;\n\n    if ( paging_mode_enabled(d) )\n        paging_update_paging_modes(v);\n\n    update_cr3(v);\n#endif /* CONFIG_PV */\n\n out:\n    if ( flags & VGCF_online )\n        clear_bit(_VPF_down, &v->pause_flags);\n    else\n        set_bit(_VPF_down, &v->pause_flags);\n    return 0;\n#undef c\n}"", ""target"": 0}]","[{""func_name"": ""svm_cpu_up_prepare"", ""file_path"": ""xen/arch/x86/hvm/svm/svm.c"", ""func_code"": ""static int svm_cpu_up_prepare(unsigned int cpu)\n{\n    paddr_t *this_hsa = &per_cpu(hsa, cpu);\n    paddr_t *this_vmcb = &per_cpu(host_vmcb, cpu);\n    nodeid_t node = cpu_to_node(cpu);\n    unsigned int memflags = 0;\n    struct page_info *pg;\n\n    if ( node != NUMA_NO_NODE )\n        memflags = MEMF_node(node);\n\n    if ( !*this_hsa )\n    {\n        pg = alloc_domheap_page(NULL, memflags);\n        if ( !pg )\n            goto err;\n\n        clear_domain_page(page_to_mfn(pg));\n        *this_hsa = page_to_maddr(pg);\n    }\n\n    if ( !*this_vmcb )\n    {\n        pg = alloc_domheap_page(NULL, memflags);\n        if ( !pg )\n            goto err;\n\n#ifdef CONFIG_PV\n        per_cpu(host_vmcb_va, cpu) = __map_domain_page_global(pg);\n#endif\n\n        clear_domain_page(page_to_mfn(pg));\n        *this_vmcb = page_to_maddr(pg);\n    }\n\n    return 0;\n\n err:\n    svm_cpu_dead(cpu);\n    return -ENOMEM;\n}""}, {""func_name"": ""write_cr"", ""file_path"": ""xen/arch/x86/pv/emul-priv-op.c"", ""func_code"": ""static int write_cr(unsigned int reg, unsigned long val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n\n    switch ( reg )\n    {\n    case 0: /* Write CR0 */\n        if ( (val ^ read_cr0()) & ~X86_CR0_TS )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \""Attempt to change unmodifiable CR0 flags\\n\"");\n            break;\n        }\n        do_fpu_taskswitch(!!(val & X86_CR0_TS));\n        return X86EMUL_OKAY;\n\n    case 2: /* Write CR2 */\n        curr->arch.pv.ctrlreg[2] = val;\n        arch_set_cr2(curr, val);\n        return X86EMUL_OKAY;\n\n    case 3: /* Write CR3 */\n    {\n        struct domain *currd = curr->domain;\n        unsigned long gfn;\n        struct page_info *page;\n        int rc;\n\n        gfn = !is_pv_32bit_domain(currd)\n              ? xen_cr3_to_pfn(val) : compat_cr3_to_pfn(val);\n        page = get_page_from_gfn(currd, gfn, NULL, P2M_ALLOC);\n        if ( !page )\n            break;\n        rc = new_guest_cr3(page_to_mfn(page));\n        put_page(page);\n\n        switch ( rc )\n        {\n        case 0:\n            return X86EMUL_OKAY;\n        case -ERESTART: /* retry after preemption */\n            return X86EMUL_RETRY;\n        }\n        break;\n    }\n\n    case 4: /* Write CR4 */\n        /*\n         * If this write will disable FSGSBASE, refresh Xen's idea of the\n         * guest bases now that they can no longer change.\n         */\n        if ( (curr->arch.pv.ctrlreg[4] & X86_CR4_FSGSBASE) &&\n             !(val & X86_CR4_FSGSBASE) )\n        {\n            curr->arch.pv.fs_base = __rdfsbase();\n            curr->arch.pv.gs_base_kernel = __rdgsbase();\n        }\n\n        curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);\n        write_cr4(pv_make_cr4(curr));\n        ctxt_switch_levelling(curr);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}""}, {""func_name"": ""read_msr"", ""file_path"": ""xen/arch/x86/pv/emul-priv-op.c"", ""func_code"": ""static int read_msr(unsigned int reg, uint64_t *val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    const struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n    int ret;\n\n    if ( (ret = guest_rdmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )\n    {\n        if ( ret == X86EMUL_EXCEPTION )\n            x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);\n\n        return ret;\n    }\n\n    switch ( reg )\n    {\n        int rc;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = (read_cr4() & X86_CR4_FSGSBASE) ? __rdfsbase()\n                                               : curr->arch.pv.fs_base;\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = (read_cr4() & X86_CR4_FSGSBASE) ? __rdgsbase()\n                                               : curr->arch.pv.gs_base_kernel;\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = curr->arch.pv.gs_base_user;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_TSC:\n        *val = currd->arch.vtsc ? pv_soft_rdtsc(curr, ctxt->regs) : rdtsc();\n        return X86EMUL_OKAY;\n\n    case MSR_EFER:\n        /* Hide unknown bits, and unconditionally hide SVME from guests. */\n        *val = read_efer() & EFER_KNOWN_MASK & ~EFER_SVME;\n        /*\n         * Hide the 64-bit features from 32-bit guests.  SCE has\n         * vendor-dependent behaviour.\n         */\n        if ( is_pv_32bit_domain(currd) )\n            *val &= ~(EFER_LME | EFER_LMA |\n                      (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL\n                       ? EFER_SCE : 0));\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD )\n            break;\n        if ( unlikely(is_cpufreq_controller(currd)) )\n            goto normal;\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_UCODE_REV:\n        BUILD_BUG_ON(MSR_IA32_UCODE_REV != MSR_AMD_PATCHLEVEL);\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            if ( wrmsr_safe(MSR_IA32_UCODE_REV, 0) )\n                break;\n            /* As documented in the SDM: Do a CPUID 1 here */\n            cpuid_eax(1);\n        }\n        goto normal;\n\n    case MSR_IA32_MISC_ENABLE:\n        rdmsrl(reg, *val);\n        *val = guest_misc_enable(*val);\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_PERF_CAPABILITIES:\n        /* No extra capabilities are supported. */\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n            /* fall through */\n    case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) )\n            {\n                if ( vpmu_do_rdmsr(reg, val) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        rc = vmce_rdmsr(reg, val);\n        if ( rc < 0 )\n            break;\n        if ( rc )\n            return X86EMUL_OKAY;\n        /* fall through */\n    normal:\n        /* Everyone can read the MSR space. */\n        /* gdprintk(XENLOG_WARNING, \""Domain attempted RDMSR %08x\\n\"", reg); */\n        if ( rdmsr_safe(reg, *val) )\n            break;\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}""}, {""func_name"": ""load_segments"", ""file_path"": ""xen/arch/x86/domain.c"", ""func_code"": ""static void load_segments(struct vcpu *n)\n{\n    struct cpu_user_regs *uregs = &n->arch.user_regs;\n    int all_segs_okay = 1;\n    unsigned int dirty_segment_mask, cpu = smp_processor_id();\n    bool fs_gs_done = false;\n\n    /* Load and clear the dirty segment mask. */\n    dirty_segment_mask = per_cpu(dirty_segment_mask, cpu);\n    per_cpu(dirty_segment_mask, cpu) = 0;\n\n#ifdef CONFIG_HVM\n    if ( cpu_has_svm && !is_pv_32bit_vcpu(n) &&\n         !(read_cr4() & X86_CR4_FSGSBASE) && !((uregs->fs | uregs->gs) & ~3) )\n    {\n        unsigned long gsb = n->arch.flags & TF_kernel_mode\n            ? n->arch.pv.gs_base_kernel : n->arch.pv.gs_base_user;\n        unsigned long gss = n->arch.flags & TF_kernel_mode\n            ? n->arch.pv.gs_base_user : n->arch.pv.gs_base_kernel;\n\n        fs_gs_done = svm_load_segs(n->arch.pv.ldt_ents, LDT_VIRT_START(n),\n                                   uregs->fs, n->arch.pv.fs_base,\n                                   uregs->gs, gsb, gss);\n    }\n#endif\n    if ( !fs_gs_done )\n        load_LDT(n);\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_DS) | uregs->ds) )\n    {\n        preload_segment(ds, uregs->ds);\n        all_segs_okay &= loadsegment(ds, uregs->ds);\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_ES) | uregs->es) )\n    {\n        preload_segment(es, uregs->es);\n        all_segs_okay &= loadsegment(es, uregs->es);\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_FS) | uregs->fs) && !fs_gs_done )\n    {\n        all_segs_okay &= loadsegment(fs, uregs->fs);\n        /* non-nul selector updates fs_base */\n        if ( uregs->fs & ~3 )\n            dirty_segment_mask &= ~DIRTY_FS_BASE;\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_GS) | uregs->gs) && !fs_gs_done )\n    {\n        all_segs_okay &= loadsegment(gs, uregs->gs);\n        /* non-nul selector updates gs_base_user */\n        if ( uregs->gs & ~3 )\n            dirty_segment_mask &= ~DIRTY_GS_BASE;\n    }\n\n    if ( !fs_gs_done && !is_pv_32bit_vcpu(n) )\n    {\n        /* This can only be non-zero if selector is NULL. */\n        if ( n->arch.pv.fs_base | (dirty_segment_mask & DIRTY_FS_BASE) )\n            wrfsbase(n->arch.pv.fs_base);\n\n        /*\n         * Most kernels have non-zero GS base, so don't bother testing.\n         * (For old AMD hardware this is also a serialising instruction,\n         * avoiding erratum #88.)\n         */\n        wrgsshadow(n->arch.pv.gs_base_kernel);\n\n        /* This can only be non-zero if selector is NULL. */\n        if ( n->arch.pv.gs_base_user |\n             (dirty_segment_mask & DIRTY_GS_BASE) )\n            wrgsbase(n->arch.pv.gs_base_user);\n\n        /* If in kernel mode then switch the GS bases around. */\n        if ( (n->arch.flags & TF_kernel_mode) )\n            asm volatile ( \""swapgs\"" );\n    }\n\n    if ( unlikely(!all_segs_okay) )\n    {\n        struct pv_vcpu *pv = &n->arch.pv;\n        struct cpu_user_regs *regs = guest_cpu_user_regs();\n        unsigned long *rsp =\n            (unsigned long *)(((n->arch.flags & TF_kernel_mode)\n                               ? regs->rsp : pv->kernel_sp) & ~0xf);\n        unsigned long cs_and_mask, rflags;\n\n        /* Fold upcall mask and architectural IOPL into RFLAGS.IF. */\n        rflags  = regs->rflags & ~(X86_EFLAGS_IF|X86_EFLAGS_IOPL);\n        rflags |= !vcpu_info(n, evtchn_upcall_mask) << 9;\n        if ( VM_ASSIST(n->domain, architectural_iopl) )\n            rflags |= n->arch.pv.iopl;\n\n        if ( is_pv_32bit_vcpu(n) )\n        {\n            unsigned int *esp = ring_1(regs) ?\n                                (unsigned int *)regs->rsp :\n                                (unsigned int *)pv->kernel_sp;\n            int ret = 0;\n\n            /* CS longword also contains full evtchn_upcall_mask. */\n            cs_and_mask = (unsigned short)regs->cs |\n                ((unsigned int)vcpu_info(n, evtchn_upcall_mask) << 16);\n\n            if ( !ring_1(regs) )\n            {\n                ret  = put_user(regs->ss,       esp-1);\n                ret |= put_user(regs->esp,      esp-2);\n                esp -= 2;\n            }\n\n            if ( ret |\n                 put_user(rflags,              esp-1) |\n                 put_user(cs_and_mask,         esp-2) |\n                 put_user(regs->eip,           esp-3) |\n                 put_user(uregs->gs,           esp-4) |\n                 put_user(uregs->fs,           esp-5) |\n                 put_user(uregs->es,           esp-6) |\n                 put_user(uregs->ds,           esp-7) )\n            {\n                gprintk(XENLOG_ERR,\n                        \""error while creating compat failsafe callback frame\\n\"");\n                domain_crash(n->domain);\n            }\n\n            if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )\n                vcpu_info(n, evtchn_upcall_mask) = 1;\n\n            regs->entry_vector |= TRAP_syscall;\n            regs->eflags       &= ~(X86_EFLAGS_VM|X86_EFLAGS_RF|X86_EFLAGS_NT|\n                                    X86_EFLAGS_IOPL|X86_EFLAGS_TF);\n            regs->ss            = FLAT_COMPAT_KERNEL_SS;\n            regs->esp           = (unsigned long)(esp-7);\n            regs->cs            = FLAT_COMPAT_KERNEL_CS;\n            regs->eip           = pv->failsafe_callback_eip;\n            return;\n        }\n\n        if ( !(n->arch.flags & TF_kernel_mode) )\n            toggle_guest_mode(n);\n        else\n            regs->cs &= ~3;\n\n        /* CS longword also contains full evtchn_upcall_mask. */\n        cs_and_mask = (unsigned long)regs->cs |\n            ((unsigned long)vcpu_info(n, evtchn_upcall_mask) << 32);\n\n        if ( put_user(regs->ss,            rsp- 1) |\n             put_user(regs->rsp,           rsp- 2) |\n             put_user(rflags,              rsp- 3) |\n             put_user(cs_and_mask,         rsp- 4) |\n             put_user(regs->rip,           rsp- 5) |\n             put_user(uregs->gs,           rsp- 6) |\n             put_user(uregs->fs,           rsp- 7) |\n             put_user(uregs->es,           rsp- 8) |\n             put_user(uregs->ds,           rsp- 9) |\n             put_user(regs->r11,           rsp-10) |\n             put_user(regs->rcx,           rsp-11) )\n        {\n            gprintk(XENLOG_ERR,\n                    \""error while creating failsafe callback frame\\n\"");\n            domain_crash(n->domain);\n        }\n\n        if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )\n            vcpu_info(n, evtchn_upcall_mask) = 1;\n\n        regs->entry_vector |= TRAP_syscall;\n        regs->rflags       &= ~(X86_EFLAGS_AC|X86_EFLAGS_VM|X86_EFLAGS_RF|\n                                X86_EFLAGS_NT|X86_EFLAGS_IOPL|X86_EFLAGS_TF);\n        regs->ss            = FLAT_KERNEL_SS;\n        regs->rsp           = (unsigned long)(rsp-11);\n        regs->cs            = FLAT_KERNEL_CS;\n        regs->rip           = pv->failsafe_callback_eip;\n    }\n}""}, {""func_name"": ""__context_switch"", ""file_path"": ""xen/arch/x86/domain.c"", ""func_code"": ""static void __context_switch(void)\n{\n    struct cpu_user_regs *stack_regs = guest_cpu_user_regs();\n    unsigned int          cpu = smp_processor_id();\n    struct vcpu          *p = per_cpu(curr_vcpu, cpu);\n    struct vcpu          *n = current;\n    struct domain        *pd = p->domain, *nd = n->domain;\n    seg_desc_t           *gdt;\n    struct desc_ptr       gdt_desc;\n\n    ASSERT(p != n);\n    ASSERT(!vcpu_cpu_dirty(n));\n\n    if ( !is_idle_domain(pd) )\n    {\n        memcpy(&p->arch.user_regs, stack_regs, CTXT_SWITCH_STACK_BYTES);\n        vcpu_save_fpu(p);\n        pd->arch.ctxt_switch->from(p);\n    }\n\n    /*\n     * Mark this CPU in next domain's dirty cpumasks before calling\n     * ctxt_switch_to(). This avoids a race on things like EPT flushing,\n     * which is synchronised on that function.\n     */\n    if ( pd != nd )\n        cpumask_set_cpu(cpu, nd->dirty_cpumask);\n    write_atomic(&n->dirty_cpu, cpu);\n\n    if ( !is_idle_domain(nd) )\n    {\n        memcpy(stack_regs, &n->arch.user_regs, CTXT_SWITCH_STACK_BYTES);\n        if ( cpu_has_xsave )\n        {\n            u64 xcr0 = n->arch.xcr0 ?: XSTATE_FP_SSE;\n\n            if ( xcr0 != get_xcr0() && !set_xcr0(xcr0) )\n                BUG();\n\n            if ( cpu_has_xsaves && is_hvm_vcpu(n) )\n                set_msr_xss(n->arch.hvm.msr_xss);\n        }\n        vcpu_restore_fpu_nonlazy(n, false);\n        nd->arch.ctxt_switch->to(n);\n    }\n\n    psr_ctxt_switch_to(nd);\n\n    gdt = !is_pv_32bit_domain(nd) ? per_cpu(gdt_table, cpu) :\n                                    per_cpu(compat_gdt_table, cpu);\n    if ( need_full_gdt(nd) )\n    {\n        unsigned long mfn = virt_to_mfn(gdt);\n        l1_pgentry_t *pl1e = pv_gdt_ptes(n);\n        unsigned int i;\n\n        for ( i = 0; i < NR_RESERVED_GDT_PAGES; i++ )\n            l1e_write(pl1e + FIRST_RESERVED_GDT_PAGE + i,\n                      l1e_from_pfn(mfn + i, __PAGE_HYPERVISOR_RW));\n    }\n\n    if ( need_full_gdt(pd) &&\n         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(nd)) )\n    {\n        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;\n        gdt_desc.base  = (unsigned long)(gdt - FIRST_RESERVED_GDT_ENTRY);\n\n        lgdt(&gdt_desc);\n    }\n\n    write_ptbase(n);\n\n#if defined(CONFIG_PV) && defined(CONFIG_HVM)\n    /* Prefetch the VMCB if we expect to use it later in the context switch */\n    if ( cpu_has_svm && is_pv_domain(nd) && !is_pv_32bit_domain(nd) &&\n         !is_idle_domain(nd) && !(read_cr4() & X86_CR4_FSGSBASE) )\n        svm_load_segs(0, 0, 0, 0, 0, 0, 0);\n#endif\n\n    if ( need_full_gdt(nd) &&\n         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(pd)) )\n    {\n        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;\n        gdt_desc.base = GDT_VIRT_START(n);\n\n        lgdt(&gdt_desc);\n    }\n\n    if ( pd != nd )\n        cpumask_clear_cpu(cpu, pd->dirty_cpumask);\n    write_atomic(&p->dirty_cpu, VCPU_CPU_CLEAN);\n\n    per_cpu(curr_vcpu, cpu) = n;\n}""}, {""func_name"": ""save_segments"", ""file_path"": ""xen/arch/x86/domain.c"", ""func_code"": ""static void save_segments(struct vcpu *v)\n{\n    struct cpu_user_regs *regs = &v->arch.user_regs;\n    unsigned int dirty_segment_mask = 0;\n\n    regs->ds = read_sreg(ds);\n    regs->es = read_sreg(es);\n    regs->fs = read_sreg(fs);\n    regs->gs = read_sreg(gs);\n\n    /* %fs/%gs bases can only be stale if WR{FS,GS}BASE are usable. */\n    if ( (read_cr4() & X86_CR4_FSGSBASE) && !is_pv_32bit_vcpu(v) )\n    {\n        v->arch.pv.fs_base = __rdfsbase();\n        if ( v->arch.flags & TF_kernel_mode )\n            v->arch.pv.gs_base_kernel = __rdgsbase();\n        else\n            v->arch.pv.gs_base_user = __rdgsbase();\n    }\n\n    if ( regs->ds )\n        dirty_segment_mask |= DIRTY_DS;\n\n    if ( regs->es )\n        dirty_segment_mask |= DIRTY_ES;\n\n    if ( regs->fs || is_pv_32bit_vcpu(v) )\n    {\n        dirty_segment_mask |= DIRTY_FS;\n        /* non-nul selector kills fs_base */\n        if ( regs->fs & ~3 )\n            v->arch.pv.fs_base = 0;\n    }\n    if ( v->arch.pv.fs_base )\n        dirty_segment_mask |= DIRTY_FS_BASE;\n\n    if ( regs->gs || is_pv_32bit_vcpu(v) )\n    {\n        dirty_segment_mask |= DIRTY_GS;\n        /* non-nul selector kills gs_base_user */\n        if ( regs->gs & ~3 )\n            v->arch.pv.gs_base_user = 0;\n    }\n    if ( v->arch.flags & TF_kernel_mode ? v->arch.pv.gs_base_kernel\n                                        : v->arch.pv.gs_base_user )\n        dirty_segment_mask |= DIRTY_GS_BASE;\n\n    this_cpu(dirty_segment_mask) = dirty_segment_mask;\n}""}, {""func_name"": ""write_cr4"", ""file_path"": ""xen/include/asm-x86/processor.h"", ""func_code"": ""static inline void write_cr4(unsigned long val)\n{\n    struct cpu_info *info = get_cpu_info();\n\n    /* No global pages in case of PCIDs enabled! */\n    ASSERT(!(val & X86_CR4_PGE) || !(val & X86_CR4_PCIDE));\n\n    /*\n     * On hardware supporting FSGSBASE, the value in %cr4 is the kernel's\n     * choice for 64bit PV guests, which impacts whether Xen can use the\n     * instructions.\n     *\n     * The {rd,wr}{fs,gs}base() helpers use info->cr4 to work out whether it\n     * is safe to execute the {RD,WR}{FS,GS}BASE instruction, falling back to\n     * the MSR path if not.  Some users require interrupt safety.\n     *\n     * If FSGSBASE is currently or about to become clear, reflect this in\n     * info->cr4 before updating %cr4, so an interrupt which hits in the\n     * middle won't observe FSGSBASE set in info->cr4 but clear in %cr4.\n     */\n    info->cr4 = val & (info->cr4 | ~X86_CR4_FSGSBASE);\n\n    asm volatile ( \""mov %[val], %%cr4\""\n                   : \""+m\"" (info->cr4) /* Force ordering without a barrier. */\n                   : [val] \""r\"" (val) );\n\n    info->cr4 = val;\n}""}, {""func_name"": ""load_segments"", ""file_path"": ""xen/arch/x86/pv/domain.c"", ""func_code"": ""static void load_segments(struct vcpu *n)\n{\n    struct cpu_user_regs *uregs = &n->arch.user_regs;\n    int all_segs_okay = 1;\n    unsigned int dirty_segment_mask, cpu = smp_processor_id();\n    bool fs_gs_done = false;\n\n    /* Load and clear the dirty segment mask. */\n    dirty_segment_mask = per_cpu(dirty_segment_mask, cpu);\n    per_cpu(dirty_segment_mask, cpu) = 0;\n\n#ifdef CONFIG_HVM\n    if ( cpu_has_svm && !is_pv_32bit_vcpu(n) &&\n         !(read_cr4() & X86_CR4_FSGSBASE) && !((uregs->fs | uregs->gs) & ~3) )\n    {\n        unsigned long gsb = n->arch.flags & TF_kernel_mode\n            ? n->arch.pv.gs_base_kernel : n->arch.pv.gs_base_user;\n        unsigned long gss = n->arch.flags & TF_kernel_mode\n            ? n->arch.pv.gs_base_user : n->arch.pv.gs_base_kernel;\n\n        fs_gs_done = svm_load_segs(n->arch.pv.ldt_ents, LDT_VIRT_START(n),\n                                   uregs->fs, n->arch.pv.fs_base,\n                                   uregs->gs, gsb, gss);\n    }\n#endif\n    if ( !fs_gs_done )\n        load_LDT(n);\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_DS) | uregs->ds) )\n    {\n        preload_segment(ds, uregs->ds);\n        all_segs_okay &= loadsegment(ds, uregs->ds);\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_ES) | uregs->es) )\n    {\n        preload_segment(es, uregs->es);\n        all_segs_okay &= loadsegment(es, uregs->es);\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_FS) | uregs->fs) && !fs_gs_done )\n    {\n        all_segs_okay &= loadsegment(fs, uregs->fs);\n        /* non-nul selector updates fs_base */\n        if ( uregs->fs & ~3 )\n            dirty_segment_mask &= ~DIRTY_FS_BASE;\n    }\n\n    /* Either selector != 0 ==> reload. */\n    if ( unlikely((dirty_segment_mask & DIRTY_GS) | uregs->gs) && !fs_gs_done )\n    {\n        all_segs_okay &= loadsegment(gs, uregs->gs);\n        /* non-nul selector updates gs_base_user */\n        if ( uregs->gs & ~3 )\n            dirty_segment_mask &= ~DIRTY_GS_BASE;\n    }\n\n    if ( !fs_gs_done && !is_pv_32bit_vcpu(n) )\n    {\n        /* This can only be non-zero if selector is NULL. */\n        if ( n->arch.pv.fs_base | (dirty_segment_mask & DIRTY_FS_BASE) )\n            wrfsbase(n->arch.pv.fs_base);\n\n        /*\n         * Most kernels have non-zero GS base, so don't bother testing.\n         * (For old AMD hardware this is also a serialising instruction,\n         * avoiding erratum #88.)\n         */\n        wrgsshadow(n->arch.pv.gs_base_kernel);\n\n        /* This can only be non-zero if selector is NULL. */\n        if ( n->arch.pv.gs_base_user |\n             (dirty_segment_mask & DIRTY_GS_BASE) )\n            wrgsbase(n->arch.pv.gs_base_user);\n\n        /* If in kernel mode then switch the GS bases around. */\n        if ( (n->arch.flags & TF_kernel_mode) )\n            asm volatile ( \""swapgs\"" );\n    }\n\n    if ( unlikely(!all_segs_okay) )\n    {\n        struct pv_vcpu *pv = &n->arch.pv;\n        struct cpu_user_regs *regs = guest_cpu_user_regs();\n        unsigned long *rsp =\n            (unsigned long *)(((n->arch.flags & TF_kernel_mode)\n                               ? regs->rsp : pv->kernel_sp) & ~0xf);\n        unsigned long cs_and_mask, rflags;\n\n        /* Fold upcall mask and architectural IOPL into RFLAGS.IF. */\n        rflags  = regs->rflags & ~(X86_EFLAGS_IF|X86_EFLAGS_IOPL);\n        rflags |= !vcpu_info(n, evtchn_upcall_mask) << 9;\n        if ( VM_ASSIST(n->domain, architectural_iopl) )\n            rflags |= n->arch.pv.iopl;\n\n        if ( is_pv_32bit_vcpu(n) )\n        {\n            unsigned int *esp = ring_1(regs) ?\n                                (unsigned int *)regs->rsp :\n                                (unsigned int *)pv->kernel_sp;\n            int ret = 0;\n\n            /* CS longword also contains full evtchn_upcall_mask. */\n            cs_and_mask = (unsigned short)regs->cs |\n                ((unsigned int)vcpu_info(n, evtchn_upcall_mask) << 16);\n\n            if ( !ring_1(regs) )\n            {\n                ret  = put_user(regs->ss,       esp-1);\n                ret |= put_user(regs->esp,      esp-2);\n                esp -= 2;\n            }\n\n            if ( ret |\n                 put_user(rflags,              esp-1) |\n                 put_user(cs_and_mask,         esp-2) |\n                 put_user(regs->eip,           esp-3) |\n                 put_user(uregs->gs,           esp-4) |\n                 put_user(uregs->fs,           esp-5) |\n                 put_user(uregs->es,           esp-6) |\n                 put_user(uregs->ds,           esp-7) )\n            {\n                gprintk(XENLOG_ERR,\n                        \""error while creating compat failsafe callback frame\\n\"");\n                domain_crash(n->domain);\n            }\n\n            if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )\n                vcpu_info(n, evtchn_upcall_mask) = 1;\n\n            regs->entry_vector |= TRAP_syscall;\n            regs->eflags       &= ~(X86_EFLAGS_VM|X86_EFLAGS_RF|X86_EFLAGS_NT|\n                                    X86_EFLAGS_IOPL|X86_EFLAGS_TF);\n            regs->ss            = FLAT_COMPAT_KERNEL_SS;\n            regs->esp           = (unsigned long)(esp-7);\n            regs->cs            = FLAT_COMPAT_KERNEL_CS;\n            regs->eip           = pv->failsafe_callback_eip;\n            return;\n        }\n\n        if ( !(n->arch.flags & TF_kernel_mode) )\n            toggle_guest_mode(n);\n        else\n            regs->cs &= ~3;\n\n        /* CS longword also contains full evtchn_upcall_mask. */\n        cs_and_mask = (unsigned long)regs->cs |\n            ((unsigned long)vcpu_info(n, evtchn_upcall_mask) << 32);\n\n        if ( put_user(regs->ss,            rsp- 1) |\n             put_user(regs->rsp,           rsp- 2) |\n             put_user(rflags,              rsp- 3) |\n             put_user(cs_and_mask,         rsp- 4) |\n             put_user(regs->rip,           rsp- 5) |\n             put_user(uregs->gs,           rsp- 6) |\n             put_user(uregs->fs,           rsp- 7) |\n             put_user(uregs->es,           rsp- 8) |\n             put_user(uregs->ds,           rsp- 9) |\n             put_user(regs->r11,           rsp-10) |\n             put_user(regs->rcx,           rsp-11) )\n        {\n            gprintk(XENLOG_ERR,\n                    \""error while creating failsafe callback frame\\n\"");\n            domain_crash(n->domain);\n        }\n\n        if ( n->arch.vgc_flags & VGCF_failsafe_disables_events )\n            vcpu_info(n, evtchn_upcall_mask) = 1;\n\n        regs->entry_vector |= TRAP_syscall;\n        regs->rflags       &= ~(X86_EFLAGS_AC|X86_EFLAGS_VM|X86_EFLAGS_RF|\n                                X86_EFLAGS_NT|X86_EFLAGS_IOPL|X86_EFLAGS_TF);\n        regs->ss            = FLAT_KERNEL_SS;\n        regs->rsp           = (unsigned long)(rsp-11);\n        regs->cs            = FLAT_KERNEL_CS;\n        regs->rip           = pv->failsafe_callback_eip;\n    }\n}""}, {""func_name"": ""__context_switch"", ""file_path"": ""xen/arch/x86/pv/domain.c"", ""func_code"": ""static void __context_switch(void)\n{\n    struct cpu_user_regs *stack_regs = guest_cpu_user_regs();\n    unsigned int          cpu = smp_processor_id();\n    struct vcpu          *p = per_cpu(curr_vcpu, cpu);\n    struct vcpu          *n = current;\n    struct domain        *pd = p->domain, *nd = n->domain;\n    seg_desc_t           *gdt;\n    struct desc_ptr       gdt_desc;\n\n    ASSERT(p != n);\n    ASSERT(!vcpu_cpu_dirty(n));\n\n    if ( !is_idle_domain(pd) )\n    {\n        memcpy(&p->arch.user_regs, stack_regs, CTXT_SWITCH_STACK_BYTES);\n        vcpu_save_fpu(p);\n        pd->arch.ctxt_switch->from(p);\n    }\n\n    /*\n     * Mark this CPU in next domain's dirty cpumasks before calling\n     * ctxt_switch_to(). This avoids a race on things like EPT flushing,\n     * which is synchronised on that function.\n     */\n    if ( pd != nd )\n        cpumask_set_cpu(cpu, nd->dirty_cpumask);\n    write_atomic(&n->dirty_cpu, cpu);\n\n    if ( !is_idle_domain(nd) )\n    {\n        memcpy(stack_regs, &n->arch.user_regs, CTXT_SWITCH_STACK_BYTES);\n        if ( cpu_has_xsave )\n        {\n            u64 xcr0 = n->arch.xcr0 ?: XSTATE_FP_SSE;\n\n            if ( xcr0 != get_xcr0() && !set_xcr0(xcr0) )\n                BUG();\n\n            if ( cpu_has_xsaves && is_hvm_vcpu(n) )\n                set_msr_xss(n->arch.hvm.msr_xss);\n        }\n        vcpu_restore_fpu_nonlazy(n, false);\n        nd->arch.ctxt_switch->to(n);\n    }\n\n    psr_ctxt_switch_to(nd);\n\n    gdt = !is_pv_32bit_domain(nd) ? per_cpu(gdt_table, cpu) :\n                                    per_cpu(compat_gdt_table, cpu);\n    if ( need_full_gdt(nd) )\n    {\n        unsigned long mfn = virt_to_mfn(gdt);\n        l1_pgentry_t *pl1e = pv_gdt_ptes(n);\n        unsigned int i;\n\n        for ( i = 0; i < NR_RESERVED_GDT_PAGES; i++ )\n            l1e_write(pl1e + FIRST_RESERVED_GDT_PAGE + i,\n                      l1e_from_pfn(mfn + i, __PAGE_HYPERVISOR_RW));\n    }\n\n    if ( need_full_gdt(pd) &&\n         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(nd)) )\n    {\n        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;\n        gdt_desc.base  = (unsigned long)(gdt - FIRST_RESERVED_GDT_ENTRY);\n\n        lgdt(&gdt_desc);\n    }\n\n    write_ptbase(n);\n\n#if defined(CONFIG_PV) && defined(CONFIG_HVM)\n    /* Prefetch the VMCB if we expect to use it later in the context switch */\n    if ( cpu_has_svm && is_pv_domain(nd) && !is_pv_32bit_domain(nd) &&\n         !is_idle_domain(nd) && !(read_cr4() & X86_CR4_FSGSBASE) )\n        svm_load_segs(0, 0, 0, 0, 0, 0, 0);\n#endif\n\n    if ( need_full_gdt(nd) &&\n         ((p->vcpu_id != n->vcpu_id) || !need_full_gdt(pd)) )\n    {\n        gdt_desc.limit = LAST_RESERVED_GDT_BYTE;\n        gdt_desc.base = GDT_VIRT_START(n);\n\n        lgdt(&gdt_desc);\n    }\n\n    if ( pd != nd )\n        cpumask_clear_cpu(cpu, pd->dirty_cpumask);\n    write_atomic(&p->dirty_cpu, VCPU_CPU_CLEAN);\n\n    per_cpu(curr_vcpu, cpu) = n;\n}""}, {""func_name"": ""save_segments"", ""file_path"": ""xen/arch/x86/pv/domain.c"", ""func_code"": ""static void save_segments(struct vcpu *v)\n{\n    struct cpu_user_regs *regs = &v->arch.user_regs;\n    unsigned int dirty_segment_mask = 0;\n\n    regs->ds = read_sreg(ds);\n    regs->es = read_sreg(es);\n    regs->fs = read_sreg(fs);\n    regs->gs = read_sreg(gs);\n\n    /* %fs/%gs bases can only be stale if WR{FS,GS}BASE are usable. */\n    if ( (read_cr4() & X86_CR4_FSGSBASE) && !is_pv_32bit_vcpu(v) )\n    {\n        v->arch.pv.fs_base = __rdfsbase();\n        if ( v->arch.flags & TF_kernel_mode )\n            v->arch.pv.gs_base_kernel = __rdgsbase();\n        else\n            v->arch.pv.gs_base_user = __rdgsbase();\n    }\n\n    if ( regs->ds )\n        dirty_segment_mask |= DIRTY_DS;\n\n    if ( regs->es )\n        dirty_segment_mask |= DIRTY_ES;\n\n    if ( regs->fs || is_pv_32bit_vcpu(v) )\n    {\n        dirty_segment_mask |= DIRTY_FS;\n        /* non-nul selector kills fs_base */\n        if ( regs->fs & ~3 )\n            v->arch.pv.fs_base = 0;\n    }\n    if ( v->arch.pv.fs_base )\n        dirty_segment_mask |= DIRTY_FS_BASE;\n\n    if ( regs->gs || is_pv_32bit_vcpu(v) )\n    {\n        dirty_segment_mask |= DIRTY_GS;\n        /* non-nul selector kills gs_base_user */\n        if ( regs->gs & ~3 )\n            v->arch.pv.gs_base_user = 0;\n    }\n    if ( v->arch.flags & TF_kernel_mode ? v->arch.pv.gs_base_kernel\n                                        : v->arch.pv.gs_base_user )\n        dirty_segment_mask |= DIRTY_GS_BASE;\n\n    this_cpu(dirty_segment_mask) = dirty_segment_mask;\n}""}, {""func_name"": ""wrfsbase"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline void wrfsbase(unsigned long base)\n{\n    if ( read_cr4() & X86_CR4_FSGSBASE )\n#ifdef HAVE_AS_FSGSBASE\n        asm volatile ( \""wrfsbase %0\"" :: \""r\"" (base) );\n#else\n        asm volatile ( \"".byte 0xf3, 0x48, 0x0f, 0xae, 0xd0\"" :: \""a\"" (base) );\n#endif\n    else\n        wrmsrl(MSR_FS_BASE, base);\n}""}, {""func_name"": ""rdfsbase"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline unsigned long rdfsbase(void)\n{\n    unsigned long base;\n\n    if ( read_cr4() & X86_CR4_FSGSBASE )\n        return __rdfsbase();\n\n    rdmsrl(MSR_FS_BASE, base);\n\n    return base;\n}""}, {""func_name"": ""rdgsbase"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline unsigned long rdgsbase(void)\n{\n    unsigned long base;\n\n    if ( read_cr4() & X86_CR4_FSGSBASE )\n        return __rdgsbase();\n\n    rdmsrl(MSR_GS_BASE, base);\n\n    return base;\n}""}, {""func_name"": ""wrgsshadow"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline void wrgsshadow(unsigned long base)\n{\n    if ( read_cr4() & X86_CR4_FSGSBASE )\n    {\n        asm volatile ( \""swapgs\\n\\t\""\n#ifdef HAVE_AS_FSGSBASE\n                       \""wrgsbase %0\\n\\t\""\n                       \""swapgs\""\n                       :: \""r\"" (base) );\n#else\n                       \"".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8\\n\\t\""\n                       \""swapgs\""\n                       :: \""a\"" (base) );\n#endif\n    }\n    else\n        wrmsrl(MSR_SHADOW_GS_BASE, base);\n}""}, {""func_name"": ""rdgsshadow"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline unsigned long rdgsshadow(void)\n{\n    unsigned long base;\n\n    if ( read_cr4() & X86_CR4_FSGSBASE )\n    {\n        asm volatile ( \""swapgs\"" );\n        base = __rdgsbase();\n        asm volatile ( \""swapgs\"" );\n    }\n    else\n        rdmsrl(MSR_SHADOW_GS_BASE, base);\n\n    return base;\n}""}, {""func_name"": ""wrgsbase"", ""file_path"": ""xen/include/asm-x86/msr.h"", ""func_code"": ""static inline void wrgsbase(unsigned long base)\n{\n    if ( read_cr4() & X86_CR4_FSGSBASE )\n#ifdef HAVE_AS_FSGSBASE\n        asm volatile ( \""wrgsbase %0\"" :: \""r\"" (base) );\n#else\n        asm volatile ( \"".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8\"" :: \""a\"" (base) );\n#endif\n    else\n        wrmsrl(MSR_GS_BASE, base);\n}""}, {""func_name"": ""write_ptbase"", ""file_path"": ""xen/arch/x86/mm.c"", ""func_code"": ""void write_ptbase(struct vcpu *v)\n{\n    struct cpu_info *cpu_info = get_cpu_info();\n    unsigned long new_cr4;\n\n    new_cr4 = (is_pv_vcpu(v) && !is_idle_vcpu(v))\n              ? pv_make_cr4(v) : mmu_cr4_features;\n\n    if ( is_pv_vcpu(v) && v->domain->arch.pv.xpti )\n    {\n        cpu_info->root_pgt_changed = true;\n        cpu_info->pv_cr3 = __pa(this_cpu(root_pgt));\n        if ( new_cr4 & X86_CR4_PCIDE )\n            cpu_info->pv_cr3 |= get_pcid_bits(v, true);\n        switch_cr3_cr4(v->arch.cr3, new_cr4);\n    }\n    else\n    {\n        /* Make sure to clear use_pv_cr3 and xen_cr3 before pv_cr3. */\n        cpu_info->use_pv_cr3 = false;\n        cpu_info->xen_cr3 = 0;\n        /* switch_cr3_cr4() serializes. */\n        switch_cr3_cr4(v->arch.cr3, new_cr4);\n        cpu_info->pv_cr3 = 0;\n    }\n}""}, {""func_name"": ""write_cr"", ""file_path"": ""xen/arch/x86/pv/emul-priv-op.c"", ""func_code"": ""static int write_cr(unsigned int reg, unsigned long val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n\n    switch ( reg )\n    {\n    case 0: /* Write CR0 */\n        if ( (val ^ read_cr0()) & ~X86_CR0_TS )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \""Attempt to change unmodifiable CR0 flags\\n\"");\n            break;\n        }\n        do_fpu_taskswitch(!!(val & X86_CR0_TS));\n        return X86EMUL_OKAY;\n\n    case 2: /* Write CR2 */\n        curr->arch.pv.ctrlreg[2] = val;\n        arch_set_cr2(curr, val);\n        return X86EMUL_OKAY;\n\n    case 3: /* Write CR3 */\n    {\n        struct domain *currd = curr->domain;\n        unsigned long gfn;\n        struct page_info *page;\n        int rc;\n\n        gfn = !is_pv_32bit_domain(currd)\n              ? xen_cr3_to_pfn(val) : compat_cr3_to_pfn(val);\n        page = get_page_from_gfn(currd, gfn, NULL, P2M_ALLOC);\n        if ( !page )\n            break;\n        rc = new_guest_cr3(page_to_mfn(page));\n        put_page(page);\n\n        switch ( rc )\n        {\n        case 0:\n            return X86EMUL_OKAY;\n        case -ERESTART: /* retry after preemption */\n            return X86EMUL_RETRY;\n        }\n        break;\n    }\n\n    case 4: /* Write CR4 */\n        curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val);\n        write_cr4(pv_make_cr4(curr));\n        ctxt_switch_levelling(curr);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}""}, {""func_name"": ""arch_set_info_guest"", ""file_path"": ""xen/arch/x86/domain.c"", ""func_code"": ""int arch_set_info_guest(\n    struct vcpu *v, vcpu_guest_context_u c)\n{\n    struct domain *d = v->domain;\n    unsigned int i;\n    unsigned long flags;\n    bool compat;\n#ifdef CONFIG_PV\n    unsigned long cr3_gfn;\n    struct page_info *cr3_page;\n    int rc = 0;\n#endif\n\n    /* The context is a compat-mode one if the target domain is compat-mode;\n     * we expect the tools to DTRT even in compat-mode callers. */\n    compat = is_pv_32bit_domain(d);\n\n#define c(fld) (compat ? (c.cmp->fld) : (c.nat->fld))\n    flags = c(flags);\n\n    if ( is_pv_domain(d) )\n    {\n        if ( !compat )\n        {\n            if ( !is_canonical_address(c.nat->user_regs.rip) ||\n                 !is_canonical_address(c.nat->user_regs.rsp) ||\n                 !is_canonical_address(c.nat->kernel_sp) ||\n                 (c.nat->ldt_ents && !is_canonical_address(c.nat->ldt_base)) ||\n                 !is_canonical_address(c.nat->fs_base) ||\n                 !is_canonical_address(c.nat->gs_base_kernel) ||\n                 !is_canonical_address(c.nat->gs_base_user) ||\n                 !is_canonical_address(c.nat->event_callback_eip) ||\n                 !is_canonical_address(c.nat->syscall_callback_eip) ||\n                 !is_canonical_address(c.nat->failsafe_callback_eip) )\n                return -EINVAL;\n\n            fixup_guest_stack_selector(d, c.nat->user_regs.ss);\n            fixup_guest_stack_selector(d, c.nat->kernel_ss);\n            fixup_guest_code_selector(d, c.nat->user_regs.cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.nat->trap_ctxt); i++ )\n            {\n                if ( !is_canonical_address(c.nat->trap_ctxt[i].address) )\n                    return -EINVAL;\n                fixup_guest_code_selector(d, c.nat->trap_ctxt[i].cs);\n            }\n\n            if ( !__addr_ok(c.nat->ldt_base) )\n                return -EINVAL;\n        }\n        else\n        {\n            fixup_guest_stack_selector(d, c.cmp->user_regs.ss);\n            fixup_guest_stack_selector(d, c.cmp->kernel_ss);\n            fixup_guest_code_selector(d, c.cmp->user_regs.cs);\n            fixup_guest_code_selector(d, c.cmp->event_callback_cs);\n            fixup_guest_code_selector(d, c.cmp->failsafe_callback_cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); i++ )\n                fixup_guest_code_selector(d, c.cmp->trap_ctxt[i].cs);\n        }\n\n        /* LDT safety checks. */\n        if ( ((c(ldt_base) & (PAGE_SIZE - 1)) != 0) ||\n             (c(ldt_ents) > 8192) )\n            return -EINVAL;\n    }\n\n    v->arch.flags &= ~TF_kernel_mode;\n    if ( (flags & VGCF_in_kernel) || is_hvm_domain(d)/*???*/ )\n        v->arch.flags |= TF_kernel_mode;\n\n    v->arch.vgc_flags = flags;\n\n    vcpu_setup_fpu(v, v->arch.xsave_area,\n                   flags & VGCF_I387_VALID ? &c.nat->fpu_ctxt : NULL,\n                   FCW_DEFAULT);\n\n    if ( !compat )\n    {\n        memcpy(&v->arch.user_regs, &c.nat->user_regs, sizeof(c.nat->user_regs));\n        if ( is_pv_domain(d) )\n            memcpy(v->arch.pv.trap_ctxt, c.nat->trap_ctxt,\n                   sizeof(c.nat->trap_ctxt));\n    }\n    else\n    {\n        XLAT_cpu_user_regs(&v->arch.user_regs, &c.cmp->user_regs);\n        if ( is_pv_domain(d) )\n        {\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); ++i )\n                XLAT_trap_info(v->arch.pv.trap_ctxt + i,\n                               c.cmp->trap_ctxt + i);\n        }\n    }\n\n    if ( is_hvm_domain(d) )\n    {\n        for ( i = 0; i < ARRAY_SIZE(v->arch.dr); ++i )\n            v->arch.dr[i] = c(debugreg[i]);\n        v->arch.dr6 = c(debugreg[6]);\n        v->arch.dr7 = c(debugreg[7]);\n\n        hvm_set_info_guest(v);\n        goto out;\n    }\n\n#ifdef CONFIG_PV\n    /* IOPL privileges are virtualised. */\n    v->arch.pv.iopl = v->arch.user_regs.eflags & X86_EFLAGS_IOPL;\n    v->arch.user_regs.eflags &= ~X86_EFLAGS_IOPL;\n\n    /* Ensure real hardware interrupts are enabled. */\n    v->arch.user_regs.eflags |= X86_EFLAGS_IF;\n\n    if ( !v->is_initialised )\n    {\n        if ( !compat && !(flags & VGCF_in_kernel) && !c.nat->ctrlreg[1] )\n            return -EINVAL;\n\n        v->arch.pv.ldt_base = c(ldt_base);\n        v->arch.pv.ldt_ents = c(ldt_ents);\n    }\n    else\n    {\n        unsigned long pfn = pagetable_get_pfn(v->arch.guest_table);\n        bool fail;\n\n        if ( !compat )\n        {\n            fail = xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[3];\n            if ( pagetable_is_null(v->arch.guest_table_user) )\n                fail |= c.nat->ctrlreg[1] || !(flags & VGCF_in_kernel);\n            else\n            {\n                pfn = pagetable_get_pfn(v->arch.guest_table_user);\n                fail |= xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[1];\n            }\n        } else {\n            l4_pgentry_t *l4tab = map_domain_page(_mfn(pfn));\n\n            pfn = l4e_get_pfn(*l4tab);\n            unmap_domain_page(l4tab);\n            fail = compat_pfn_to_cr3(pfn) != c.cmp->ctrlreg[3];\n        }\n\n        for ( i = 0; i < ARRAY_SIZE(v->arch.pv.gdt_frames); ++i )\n            fail |= v->arch.pv.gdt_frames[i] != c(gdt_frames[i]);\n        fail |= v->arch.pv.gdt_ents != c(gdt_ents);\n\n        fail |= v->arch.pv.ldt_base != c(ldt_base);\n        fail |= v->arch.pv.ldt_ents != c(ldt_ents);\n\n        if ( fail )\n           return -EOPNOTSUPP;\n    }\n\n    v->arch.pv.kernel_ss = c(kernel_ss);\n    v->arch.pv.kernel_sp = c(kernel_sp);\n    for ( i = 0; i < ARRAY_SIZE(v->arch.pv.ctrlreg); ++i )\n        v->arch.pv.ctrlreg[i] = c(ctrlreg[i]);\n\n    v->arch.pv.event_callback_eip = c(event_callback_eip);\n    v->arch.pv.failsafe_callback_eip = c(failsafe_callback_eip);\n    if ( !compat )\n    {\n        v->arch.pv.syscall_callback_eip = c.nat->syscall_callback_eip;\n        /* non-nul selector kills fs_base */\n        v->arch.pv.fs_base =\n            !(v->arch.user_regs.fs & ~3) ? c.nat->fs_base : 0;\n        v->arch.pv.gs_base_kernel = c.nat->gs_base_kernel;\n        /* non-nul selector kills gs_base_user */\n        v->arch.pv.gs_base_user =\n            !(v->arch.user_regs.gs & ~3) ? c.nat->gs_base_user : 0;\n    }\n    else\n    {\n        v->arch.pv.event_callback_cs = c(event_callback_cs);\n        v->arch.pv.failsafe_callback_cs = c(failsafe_callback_cs);\n    }\n\n    /* Only CR0.TS is modifiable by guest or admin. */\n    v->arch.pv.ctrlreg[0] &= X86_CR0_TS;\n    v->arch.pv.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;\n\n    v->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(v, v->arch.pv.ctrlreg[4]);\n\n    memset(v->arch.dr, 0, sizeof(v->arch.dr));\n    v->arch.dr6 = X86_DR6_DEFAULT;\n    v->arch.dr7 = X86_DR7_DEFAULT;\n    v->arch.pv.dr7_emul = 0;\n\n    for ( i = 0; i < ARRAY_SIZE(v->arch.dr); i++ )\n        set_debugreg(v, i, c(debugreg[i]));\n    set_debugreg(v, 6, c(debugreg[6]));\n    set_debugreg(v, 7, c(debugreg[7]));\n\n    if ( v->is_initialised )\n        goto out;\n\n    if ( v->vcpu_id == 0 )\n    {\n        /*\n         * In the restore case we need to deal with L4 pages which got\n         * initialized with m2p_strict still clear (and which hence lack the\n         * correct initial RO_MPT_VIRT_{START,END} L4 entry).\n         */\n        if ( d != current->domain && !VM_ASSIST(d, m2p_strict) &&\n             is_pv_domain(d) && !is_pv_32bit_domain(d) &&\n             test_bit(VMASST_TYPE_m2p_strict, &c.nat->vm_assist) &&\n             atomic_read(&d->arch.pv.nr_l4_pages) )\n        {\n            bool done = false;\n\n            spin_lock_recursive(&d->page_alloc_lock);\n\n            for ( i = 0; ; )\n            {\n                struct page_info *page = page_list_remove_head(&d->page_list);\n\n                if ( page_lock(page) )\n                {\n                    if ( (page->u.inuse.type_info & PGT_type_mask) ==\n                         PGT_l4_page_table )\n                        done = !fill_ro_mpt(page_to_mfn(page));\n\n                    page_unlock(page);\n                }\n\n                page_list_add_tail(page, &d->page_list);\n\n                if ( done || (!(++i & 0xff) && hypercall_preempt_check()) )\n                    break;\n            }\n\n            spin_unlock_recursive(&d->page_alloc_lock);\n\n            if ( !done )\n                return -ERESTART;\n        }\n\n        d->vm_assist = c(vm_assist);\n    }\n\n    rc = put_old_guest_table(current);\n    if ( rc )\n        return rc;\n\n    if ( !compat )\n        rc = (int)pv_set_gdt(v, c.nat->gdt_frames, c.nat->gdt_ents);\n    else\n    {\n        unsigned long gdt_frames[ARRAY_SIZE(v->arch.pv.gdt_frames)];\n        unsigned int nr_frames = DIV_ROUND_UP(c.cmp->gdt_ents, 512);\n\n        if ( nr_frames > ARRAY_SIZE(v->arch.pv.gdt_frames) )\n            return -EINVAL;\n\n        for ( i = 0; i < nr_frames; ++i )\n            gdt_frames[i] = c.cmp->gdt_frames[i];\n\n        rc = (int)pv_set_gdt(v, gdt_frames, c.cmp->gdt_ents);\n    }\n    if ( rc != 0 )\n        return rc;\n\n    set_bit(_VPF_in_reset, &v->pause_flags);\n\n    if ( !compat )\n        cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[3]);\n    else\n        cr3_gfn = compat_cr3_to_pfn(c.cmp->ctrlreg[3]);\n    cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n    if ( !cr3_page )\n        rc = -EINVAL;\n    else if ( paging_mode_refcounts(d) )\n        /* nothing */;\n    else if ( cr3_page == v->arch.old_guest_table )\n    {\n        v->arch.old_guest_table = NULL;\n        put_page(cr3_page);\n    }\n    else\n    {\n        if ( !compat )\n            rc = put_old_guest_table(v);\n        if ( !rc )\n            rc = get_page_type_preemptible(cr3_page,\n                                           !compat ? PGT_root_page_table\n                                                   : PGT_l3_page_table);\n        switch ( rc )\n        {\n        case -EINTR:\n            rc = -ERESTART;\n        case -ERESTART:\n            break;\n        case 0:\n            if ( !compat && !VM_ASSIST(d, m2p_strict) &&\n                 !paging_mode_refcounts(d) )\n                fill_ro_mpt(_mfn(cr3_gfn));\n            break;\n        default:\n            if ( cr3_page == current->arch.old_guest_table )\n                cr3_page = NULL;\n            break;\n        }\n    }\n    if ( rc )\n        /* handled below */;\n    else if ( !compat )\n    {\n        v->arch.guest_table = pagetable_from_page(cr3_page);\n        if ( c.nat->ctrlreg[1] )\n        {\n            cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[1]);\n            cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n            if ( !cr3_page )\n                rc = -EINVAL;\n            else if ( !paging_mode_refcounts(d) )\n            {\n                rc = get_page_type_preemptible(cr3_page, PGT_root_page_table);\n                switch ( rc )\n                {\n                case -EINTR:\n                    rc = -ERESTART;\n                    /* Fallthrough */\n                case -ERESTART:\n                    v->arch.old_guest_ptpg = NULL;\n                    v->arch.old_guest_table =\n                        pagetable_get_page(v->arch.guest_table);\n                    v->arch.guest_table = pagetable_null();\n                    break;\n                default:\n                    if ( cr3_page == current->arch.old_guest_table )\n                        cr3_page = NULL;\n                    break;\n                case 0:\n                    if ( VM_ASSIST(d, m2p_strict) )\n                        zap_ro_mpt(_mfn(cr3_gfn));\n                    break;\n                }\n            }\n            if ( !rc )\n               v->arch.guest_table_user = pagetable_from_page(cr3_page);\n        }\n    }\n    else\n    {\n        l4_pgentry_t *l4tab;\n\n        l4tab = map_domain_page(pagetable_get_mfn(v->arch.guest_table));\n        *l4tab = l4e_from_mfn(page_to_mfn(cr3_page),\n            _PAGE_PRESENT|_PAGE_RW|_PAGE_USER|_PAGE_ACCESSED);\n        unmap_domain_page(l4tab);\n    }\n    if ( rc )\n    {\n        if ( cr3_page )\n            put_page(cr3_page);\n        pv_destroy_gdt(v);\n        return rc;\n    }\n\n    clear_bit(_VPF_in_reset, &v->pause_flags);\n\n    if ( v->vcpu_id == 0 )\n        update_domain_wallclock_time(d);\n\n    /* Don't redo final setup */\n    v->is_initialised = 1;\n\n    if ( paging_mode_enabled(d) )\n        paging_update_paging_modes(v);\n\n    update_cr3(v);\n#endif /* CONFIG_PV */\n\n out:\n    if ( flags & VGCF_online )\n        clear_bit(_VPF_down, &v->pause_flags);\n    else\n        set_bit(_VPF_down, &v->pause_flags);\n    return 0;\n#undef c\n}""}, {""func_name"": ""arch_set_info_guest"", ""file_path"": ""xen/arch/x86/pv/domain.c"", ""func_code"": ""int arch_set_info_guest(\n    struct vcpu *v, vcpu_guest_context_u c)\n{\n    struct domain *d = v->domain;\n    unsigned int i;\n    unsigned long flags;\n    bool compat;\n#ifdef CONFIG_PV\n    unsigned long cr3_gfn;\n    struct page_info *cr3_page;\n    int rc = 0;\n#endif\n\n    /* The context is a compat-mode one if the target domain is compat-mode;\n     * we expect the tools to DTRT even in compat-mode callers. */\n    compat = is_pv_32bit_domain(d);\n\n#define c(fld) (compat ? (c.cmp->fld) : (c.nat->fld))\n    flags = c(flags);\n\n    if ( is_pv_domain(d) )\n    {\n        if ( !compat )\n        {\n            if ( !is_canonical_address(c.nat->user_regs.rip) ||\n                 !is_canonical_address(c.nat->user_regs.rsp) ||\n                 !is_canonical_address(c.nat->kernel_sp) ||\n                 (c.nat->ldt_ents && !is_canonical_address(c.nat->ldt_base)) ||\n                 !is_canonical_address(c.nat->fs_base) ||\n                 !is_canonical_address(c.nat->gs_base_kernel) ||\n                 !is_canonical_address(c.nat->gs_base_user) ||\n                 !is_canonical_address(c.nat->event_callback_eip) ||\n                 !is_canonical_address(c.nat->syscall_callback_eip) ||\n                 !is_canonical_address(c.nat->failsafe_callback_eip) )\n                return -EINVAL;\n\n            fixup_guest_stack_selector(d, c.nat->user_regs.ss);\n            fixup_guest_stack_selector(d, c.nat->kernel_ss);\n            fixup_guest_code_selector(d, c.nat->user_regs.cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.nat->trap_ctxt); i++ )\n            {\n                if ( !is_canonical_address(c.nat->trap_ctxt[i].address) )\n                    return -EINVAL;\n                fixup_guest_code_selector(d, c.nat->trap_ctxt[i].cs);\n            }\n\n            if ( !__addr_ok(c.nat->ldt_base) )\n                return -EINVAL;\n        }\n        else\n        {\n            fixup_guest_stack_selector(d, c.cmp->user_regs.ss);\n            fixup_guest_stack_selector(d, c.cmp->kernel_ss);\n            fixup_guest_code_selector(d, c.cmp->user_regs.cs);\n            fixup_guest_code_selector(d, c.cmp->event_callback_cs);\n            fixup_guest_code_selector(d, c.cmp->failsafe_callback_cs);\n\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); i++ )\n                fixup_guest_code_selector(d, c.cmp->trap_ctxt[i].cs);\n        }\n\n        /* LDT safety checks. */\n        if ( ((c(ldt_base) & (PAGE_SIZE - 1)) != 0) ||\n             (c(ldt_ents) > 8192) )\n            return -EINVAL;\n    }\n\n    v->arch.flags &= ~TF_kernel_mode;\n    if ( (flags & VGCF_in_kernel) || is_hvm_domain(d)/*???*/ )\n        v->arch.flags |= TF_kernel_mode;\n\n    v->arch.vgc_flags = flags;\n\n    vcpu_setup_fpu(v, v->arch.xsave_area,\n                   flags & VGCF_I387_VALID ? &c.nat->fpu_ctxt : NULL,\n                   FCW_DEFAULT);\n\n    if ( !compat )\n    {\n        memcpy(&v->arch.user_regs, &c.nat->user_regs, sizeof(c.nat->user_regs));\n        if ( is_pv_domain(d) )\n            memcpy(v->arch.pv.trap_ctxt, c.nat->trap_ctxt,\n                   sizeof(c.nat->trap_ctxt));\n    }\n    else\n    {\n        XLAT_cpu_user_regs(&v->arch.user_regs, &c.cmp->user_regs);\n        if ( is_pv_domain(d) )\n        {\n            for ( i = 0; i < ARRAY_SIZE(c.cmp->trap_ctxt); ++i )\n                XLAT_trap_info(v->arch.pv.trap_ctxt + i,\n                               c.cmp->trap_ctxt + i);\n        }\n    }\n\n    if ( is_hvm_domain(d) )\n    {\n        for ( i = 0; i < ARRAY_SIZE(v->arch.dr); ++i )\n            v->arch.dr[i] = c(debugreg[i]);\n        v->arch.dr6 = c(debugreg[6]);\n        v->arch.dr7 = c(debugreg[7]);\n\n        hvm_set_info_guest(v);\n        goto out;\n    }\n\n#ifdef CONFIG_PV\n    /* IOPL privileges are virtualised. */\n    v->arch.pv.iopl = v->arch.user_regs.eflags & X86_EFLAGS_IOPL;\n    v->arch.user_regs.eflags &= ~X86_EFLAGS_IOPL;\n\n    /* Ensure real hardware interrupts are enabled. */\n    v->arch.user_regs.eflags |= X86_EFLAGS_IF;\n\n    if ( !v->is_initialised )\n    {\n        if ( !compat && !(flags & VGCF_in_kernel) && !c.nat->ctrlreg[1] )\n            return -EINVAL;\n\n        v->arch.pv.ldt_base = c(ldt_base);\n        v->arch.pv.ldt_ents = c(ldt_ents);\n    }\n    else\n    {\n        unsigned long pfn = pagetable_get_pfn(v->arch.guest_table);\n        bool fail;\n\n        if ( !compat )\n        {\n            fail = xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[3];\n            if ( pagetable_is_null(v->arch.guest_table_user) )\n                fail |= c.nat->ctrlreg[1] || !(flags & VGCF_in_kernel);\n            else\n            {\n                pfn = pagetable_get_pfn(v->arch.guest_table_user);\n                fail |= xen_pfn_to_cr3(pfn) != c.nat->ctrlreg[1];\n            }\n        } else {\n            l4_pgentry_t *l4tab = map_domain_page(_mfn(pfn));\n\n            pfn = l4e_get_pfn(*l4tab);\n            unmap_domain_page(l4tab);\n            fail = compat_pfn_to_cr3(pfn) != c.cmp->ctrlreg[3];\n        }\n\n        for ( i = 0; i < ARRAY_SIZE(v->arch.pv.gdt_frames); ++i )\n            fail |= v->arch.pv.gdt_frames[i] != c(gdt_frames[i]);\n        fail |= v->arch.pv.gdt_ents != c(gdt_ents);\n\n        fail |= v->arch.pv.ldt_base != c(ldt_base);\n        fail |= v->arch.pv.ldt_ents != c(ldt_ents);\n\n        if ( fail )\n           return -EOPNOTSUPP;\n    }\n\n    v->arch.pv.kernel_ss = c(kernel_ss);\n    v->arch.pv.kernel_sp = c(kernel_sp);\n    for ( i = 0; i < ARRAY_SIZE(v->arch.pv.ctrlreg); ++i )\n        v->arch.pv.ctrlreg[i] = c(ctrlreg[i]);\n\n    v->arch.pv.event_callback_eip = c(event_callback_eip);\n    v->arch.pv.failsafe_callback_eip = c(failsafe_callback_eip);\n    if ( !compat )\n    {\n        v->arch.pv.syscall_callback_eip = c.nat->syscall_callback_eip;\n        /* non-nul selector kills fs_base */\n        v->arch.pv.fs_base =\n            !(v->arch.user_regs.fs & ~3) ? c.nat->fs_base : 0;\n        v->arch.pv.gs_base_kernel = c.nat->gs_base_kernel;\n        /* non-nul selector kills gs_base_user */\n        v->arch.pv.gs_base_user =\n            !(v->arch.user_regs.gs & ~3) ? c.nat->gs_base_user : 0;\n    }\n    else\n    {\n        v->arch.pv.event_callback_cs = c(event_callback_cs);\n        v->arch.pv.failsafe_callback_cs = c(failsafe_callback_cs);\n    }\n\n    /* Only CR0.TS is modifiable by guest or admin. */\n    v->arch.pv.ctrlreg[0] &= X86_CR0_TS;\n    v->arch.pv.ctrlreg[0] |= read_cr0() & ~X86_CR0_TS;\n\n    v->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(v, v->arch.pv.ctrlreg[4]);\n\n    memset(v->arch.dr, 0, sizeof(v->arch.dr));\n    v->arch.dr6 = X86_DR6_DEFAULT;\n    v->arch.dr7 = X86_DR7_DEFAULT;\n    v->arch.pv.dr7_emul = 0;\n\n    for ( i = 0; i < ARRAY_SIZE(v->arch.dr); i++ )\n        set_debugreg(v, i, c(debugreg[i]));\n    set_debugreg(v, 6, c(debugreg[6]));\n    set_debugreg(v, 7, c(debugreg[7]));\n\n    if ( v->is_initialised )\n        goto out;\n\n    if ( v->vcpu_id == 0 )\n    {\n        /*\n         * In the restore case we need to deal with L4 pages which got\n         * initialized with m2p_strict still clear (and which hence lack the\n         * correct initial RO_MPT_VIRT_{START,END} L4 entry).\n         */\n        if ( d != current->domain && !VM_ASSIST(d, m2p_strict) &&\n             is_pv_domain(d) && !is_pv_32bit_domain(d) &&\n             test_bit(VMASST_TYPE_m2p_strict, &c.nat->vm_assist) &&\n             atomic_read(&d->arch.pv.nr_l4_pages) )\n        {\n            bool done = false;\n\n            spin_lock_recursive(&d->page_alloc_lock);\n\n            for ( i = 0; ; )\n            {\n                struct page_info *page = page_list_remove_head(&d->page_list);\n\n                if ( page_lock(page) )\n                {\n                    if ( (page->u.inuse.type_info & PGT_type_mask) ==\n                         PGT_l4_page_table )\n                        done = !fill_ro_mpt(page_to_mfn(page));\n\n                    page_unlock(page);\n                }\n\n                page_list_add_tail(page, &d->page_list);\n\n                if ( done || (!(++i & 0xff) && hypercall_preempt_check()) )\n                    break;\n            }\n\n            spin_unlock_recursive(&d->page_alloc_lock);\n\n            if ( !done )\n                return -ERESTART;\n        }\n\n        d->vm_assist = c(vm_assist);\n    }\n\n    rc = put_old_guest_table(current);\n    if ( rc )\n        return rc;\n\n    if ( !compat )\n        rc = (int)pv_set_gdt(v, c.nat->gdt_frames, c.nat->gdt_ents);\n    else\n    {\n        unsigned long gdt_frames[ARRAY_SIZE(v->arch.pv.gdt_frames)];\n        unsigned int nr_frames = DIV_ROUND_UP(c.cmp->gdt_ents, 512);\n\n        if ( nr_frames > ARRAY_SIZE(v->arch.pv.gdt_frames) )\n            return -EINVAL;\n\n        for ( i = 0; i < nr_frames; ++i )\n            gdt_frames[i] = c.cmp->gdt_frames[i];\n\n        rc = (int)pv_set_gdt(v, gdt_frames, c.cmp->gdt_ents);\n    }\n    if ( rc != 0 )\n        return rc;\n\n    set_bit(_VPF_in_reset, &v->pause_flags);\n\n    if ( !compat )\n        cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[3]);\n    else\n        cr3_gfn = compat_cr3_to_pfn(c.cmp->ctrlreg[3]);\n    cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n    if ( !cr3_page )\n        rc = -EINVAL;\n    else if ( paging_mode_refcounts(d) )\n        /* nothing */;\n    else if ( cr3_page == v->arch.old_guest_table )\n    {\n        v->arch.old_guest_table = NULL;\n        put_page(cr3_page);\n    }\n    else\n    {\n        if ( !compat )\n            rc = put_old_guest_table(v);\n        if ( !rc )\n            rc = get_page_type_preemptible(cr3_page,\n                                           !compat ? PGT_root_page_table\n                                                   : PGT_l3_page_table);\n        switch ( rc )\n        {\n        case -EINTR:\n            rc = -ERESTART;\n        case -ERESTART:\n            break;\n        case 0:\n            if ( !compat && !VM_ASSIST(d, m2p_strict) &&\n                 !paging_mode_refcounts(d) )\n                fill_ro_mpt(_mfn(cr3_gfn));\n            break;\n        default:\n            if ( cr3_page == current->arch.old_guest_table )\n                cr3_page = NULL;\n            break;\n        }\n    }\n    if ( rc )\n        /* handled below */;\n    else if ( !compat )\n    {\n        v->arch.guest_table = pagetable_from_page(cr3_page);\n        if ( c.nat->ctrlreg[1] )\n        {\n            cr3_gfn = xen_cr3_to_pfn(c.nat->ctrlreg[1]);\n            cr3_page = get_page_from_gfn(d, cr3_gfn, NULL, P2M_ALLOC);\n\n            if ( !cr3_page )\n                rc = -EINVAL;\n            else if ( !paging_mode_refcounts(d) )\n            {\n                rc = get_page_type_preemptible(cr3_page, PGT_root_page_table);\n                switch ( rc )\n                {\n                case -EINTR:\n                    rc = -ERESTART;\n                    /* Fallthrough */\n                case -ERESTART:\n                    v->arch.old_guest_ptpg = NULL;\n                    v->arch.old_guest_table =\n                        pagetable_get_page(v->arch.guest_table);\n                    v->arch.guest_table = pagetable_null();\n                    break;\n                default:\n                    if ( cr3_page == current->arch.old_guest_table )\n                        cr3_page = NULL;\n                    break;\n                case 0:\n                    if ( VM_ASSIST(d, m2p_strict) )\n                        zap_ro_mpt(_mfn(cr3_gfn));\n                    break;\n                }\n            }\n            if ( !rc )\n               v->arch.guest_table_user = pagetable_from_page(cr3_page);\n        }\n    }\n    else\n    {\n        l4_pgentry_t *l4tab;\n\n        l4tab = map_domain_page(pagetable_get_mfn(v->arch.guest_table));\n        *l4tab = l4e_from_mfn(page_to_mfn(cr3_page),\n            _PAGE_PRESENT|_PAGE_RW|_PAGE_USER|_PAGE_ACCESSED);\n        unmap_domain_page(l4tab);\n    }\n    if ( rc )\n    {\n        if ( cr3_page )\n            put_page(cr3_page);\n        pv_destroy_gdt(v);\n        return rc;\n    }\n\n    clear_bit(_VPF_in_reset, &v->pause_flags);\n\n    if ( v->vcpu_id == 0 )\n        update_domain_wallclock_time(d);\n\n    /* Don't redo final setup */\n    v->is_initialised = 1;\n\n    if ( paging_mode_enabled(d) )\n        paging_update_paging_modes(v);\n\n    update_cr3(v);\n#endif /* CONFIG_PV */\n\n out:\n    if ( flags & VGCF_online )\n        clear_bit(_VPF_down, &v->pause_flags);\n    else\n        set_bit(_VPF_down, &v->pause_flags);\n    return 0;\n#undef c\n}""}]","{""function"": 2, ""value"": 1}","[{""source"": ""func_info(func:pv_make_cr4)"", ""result"": [{""code"": ""unsigned long pv_make_cr4(const struct vcpu *v)\n{\n    const struct domain *d = v->domain;\n    unsigned long cr4 = mmu_cr4_features &\n        ~(X86_CR4_PCIDE | X86_CR4_PGE | X86_CR4_TSD);\n\n    /*\n     * PCIDE or PGE depends on the PCID/XPTI settings, but must not both be\n     * set, as it impacts the safety of TLB flushing.\n     */\n    if ( d->arch.pv.pcid )\n        cr4 |= X86_CR4_PCIDE;\n    else if ( !d->arch.pv.xpti )\n        cr4 |= X86_CR4_PGE;\n\n    /*\n     * TSD is needed if either the guest has elected to use it, or Xen is\n     * virtualising the TSC value the guest sees.\n     */\n    if ( d->arch.vtsc || (v->arch.pv.ctrlreg[4] & X86_CR4_TSD) )\n        cr4 |= X86_CR4_TSD;\n\n    return cr4;\n}"", ""start_line"": 121, ""end_line"": 144, ""full_name"": ""pv_make_cr4"", ""file_path"": ""xen/arch/x86/pv/domain.c""}, {""code"": ""static inline unsigned long pv_make_cr4(const struct vcpu *v) { return ~0ul; }"", ""start_line"": 92, ""end_line"": 92, ""full_name"": ""pv_make_cr4<duplicate>0"", ""file_path"": ""xen/include/asm-x86/pv/domain.h""}]}, {""source"": ""value_info(file:cpufeature.h, value:cpu_has_fsgsbase)"", ""result"": {""value_trace"": [{""full_code"": ""cpu_has_fsgsbase"", ""line"": 1490, ""func_name"": null}, {""full_code"": ""cpu_has_fsgsbase"", ""line"": 374, ""func_name"": null}, {""full_code"": ""cpu_has_fsgsbase"", ""line"": 831, ""func_name"": null}, {""full_code"": ""cpu_has_fsgsbase"", ""line"": 219, ""func_name"": null}, {""full_code"": ""cpu_has_fsgsbase"", ""line"": 207, ""func_name"": null}], ""struct_var"": ""cpu_has_fsgsbase"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""func_info(func:pv_fixup_guest_cr4)"", ""result"": [{""code"": ""unsigned long pv_fixup_guest_cr4(const struct vcpu *v, unsigned long cr4)\n{\n    const struct cpuid_policy *p = v->domain->arch.cpuid;\n\n    /* Discard attempts to set guest controllable bits outside of the policy. */\n    cr4 &= ~((p->basic.tsc     ? 0 : X86_CR4_TSD)      |\n             (p->basic.de      ? 0 : X86_CR4_DE)       |\n             (p->feat.fsgsbase ? 0 : X86_CR4_FSGSBASE) |\n             (p->basic.xsave   ? 0 : X86_CR4_OSXSAVE));\n\n    /* Masks expected to be disjoint sets. */\n    BUILD_BUG_ON(PV_CR4_GUEST_MASK & PV_CR4_GUEST_VISIBLE_MASK);\n\n    /*\n     * A guest sees the policy subset of its own choice of guest controllable\n     * bits, and a subset of Xen's choice of certain hardware settings.\n     */\n    return ((cr4 & PV_CR4_GUEST_MASK) |\n            (mmu_cr4_features & PV_CR4_GUEST_VISIBLE_MASK));\n}"", ""start_line"": 100, ""end_line"": 119, ""full_name"": ""pv_fixup_guest_cr4"", ""file_path"": ""xen/arch/x86/pv/domain.c""}]}]","1. Guest modifies CR4.FSGSBASE in a 64-bit PV context, but Xen does not enforce the hardware CR4 state (xen/arch/x86/pv/emul-priv-op.c:781-789).\n2. Xen's write_cr4() now captures fs/gs base values when FSGSBASE is disabled, ensuring shadow CR4 matches hardware (xen/include/asm-x86/processor.h:306-328).\n3. {rd,wr}fs/gsbase() now check read_cr4() instead of cpu_has_fsgsbase (xen/include/asm-x86/msr.h:155-157, 167-169).\n4. pv_make_cr4() constructs CR4 with correct FSGSBASE state based on guest policy (xen/arch/x86/pv/domain.c:121-144).\n5. pv_fixup_guest_cr4() ensures guest CR4 does not set disallowed bits (xen/arch/x86/pv/domain.c:100-119).",1.0,./github/other_context/CVE-2019-17347
30,CVE-2019-1010251,CWE-20,c_cpp,"Open Information Security Foundation Suricata prior to version 4.1.2 is affected by: Denial of Service - DNS detection bypass. The impact is: An attacker can evade a signature detection with a specialy formed network packet. The component is: app-layer-detect-proto.c, decode.c, decode-teredo.c and decode-ipv6.c (https://github.com/OISF/suricata/pull/3590/commits/11f3659f64a4e42e90cb3c09fcef66894205aefe, https://github.com/OISF/suricata/pull/3590/commits/8357ef3f8ffc7d99ef6571350724160de356158b). The attack vector is: An attacker can trigger the vulnerability by sending a specifically crafted network request. The fixed version is: 4.1.2.",https://github.com/OISF/suricata/commit/11f3659f64a4e42e90cb3c09fcef66894205aefe,teredo: be stricter on what to consider valid teredo\n\nInvalid Teredo can lead to valid DNS traffic (or other UDP traffic)\nbeing misdetected as Teredo. This leads to false negatives in the\nUDP payload inspection.\n\nMake the teredo code only consider a packet teredo if the encapsulated\ndata was decoded without any 'invalid' events being set.\n\nBug #2736.,5,"[{""func_name"": ""DecodeIPV6ExtHdrs"", ""file_path"": ""src/decode-ipv6.c"", ""func_code"": ""static void\nDecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    SCEnter();\n\n    uint8_t *orig_pkt = pkt;\n    uint8_t nh = 0; /* careful, 0 is actually a real type */\n    uint16_t hdrextlen = 0;\n    uint16_t plen;\n    char dstopts = 0;\n    char exthdr_fh_done = 0;\n    int hh = 0;\n    int rh = 0;\n    int eh = 0;\n    int ah = 0;\n\n    nh = IPV6_GET_NH(p);\n    plen = len;\n\n    while(1)\n    {\n        /* No upper layer, but we do have data. Suspicious. */\n        if (nh == IPPROTO_NONE && plen > 0) {\n            ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);\n            SCReturn;\n        }\n\n        if (plen < 2) { /* minimal needed in a hdr */\n            SCReturn;\n        }\n\n        switch(nh)\n        {\n            case IPPROTO_TCP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeTCP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_UDP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeUDP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ICMPV6:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeICMPV6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_SCTP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeSCTP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ROUTING:\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n\n                SCLogDebug(\""hdrextlen %\""PRIu8, hdrextlen);\n\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                if (rh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_RH);\n                    /* skip past this extension so we can continue parsing the rest\n                     * of the packet */\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                rh = 1;\n                IPV6_EXTHDR_SET_RH(p);\n\n                uint8_t ip6rh_type = *(pkt + 2);\n                if (ip6rh_type == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_RH_TYPE_0);\n                }\n                p->ip6eh.rh_type = ip6rh_type;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n\n            case IPPROTO_HOPOPTS:\n            case IPPROTO_DSTOPTS:\n            {\n                IPV6OptHAO hao_s, *hao = &hao_s;\n                IPV6OptRA ra_s, *ra = &ra_s;\n                IPV6OptJumbo jumbo_s, *jumbo = &jumbo_s;\n                uint16_t optslen = 0;\n\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen =  (*(pkt+1) + 1) << 3;\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                uint8_t *ptr = pkt + 2; /* +2 to go past nxthdr and len */\n\n                /* point the pointers to right structures\n                 * in Packet. */\n                if (nh == IPPROTO_HOPOPTS) {\n                    if (hh) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_HH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n\n                    hh = 1;\n\n                    optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                }\n                else if (nh == IPPROTO_DSTOPTS)\n                {\n                    if (dstopts == 0) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 1;\n                    } else if (dstopts == 1) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 2;\n                    } else {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_DH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n                }\n\n                if (optslen > plen) {\n                    /* since the packet is long enough (we checked\n                     * plen against hdrlen, the optlen must be malformed. */\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                    /* skip past this extension so we can continue parsing the rest\n                     * of the packet */\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n/** \\todo move into own function to loaded on demand */\n                uint16_t padn_cnt = 0;\n                uint16_t other_cnt = 0;\n                uint16_t offset = 0;\n                while(offset < optslen)\n                {\n                    if (*ptr == IPV6OPT_PAD1)\n                    {\n                        padn_cnt++;\n                        offset++;\n                        ptr++;\n                        continue;\n                    }\n\n                    if (offset + 1 >= optslen) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                        break;\n                    }\n\n                    /* length field for each opt */\n                    uint8_t ip6_optlen = *(ptr + 1);\n\n                    /* see if the optlen from the packet fits the total optslen */\n                    if ((offset + 1 + ip6_optlen) > optslen) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                        break;\n                    }\n\n                    if (*ptr == IPV6OPT_PADN) /* PadN */\n                    {\n                        //printf(\""PadN option\\n\"");\n                        padn_cnt++;\n\n                        /* a zero padN len would be weird */\n                        if (ip6_optlen == 0)\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_ZERO_LEN_PADN);\n                    }\n                    else if (*ptr == IPV6OPT_RA) /* RA */\n                    {\n                        ra->ip6ra_type = *(ptr);\n                        ra->ip6ra_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(ra->ip6ra_value)) {\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&ra->ip6ra_value, (ptr + 2), sizeof(ra->ip6ra_value));\n                        ra->ip6ra_value = SCNtohs(ra->ip6ra_value);\n                        //printf(\""RA option: type %\"" PRIu32 \"" len %\"" PRIu32 \"" value %\"" PRIu32 \""\\n\"",\n                        //    ra->ip6ra_type, ra->ip6ra_len, ra->ip6ra_value);\n                        other_cnt++;\n                    }\n                    else if (*ptr == IPV6OPT_JUMBO) /* Jumbo */\n                    {\n                        jumbo->ip6j_type = *(ptr);\n                        jumbo->ip6j_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(jumbo->ip6j_payload_len)) {\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&jumbo->ip6j_payload_len, (ptr+2), sizeof(jumbo->ip6j_payload_len));\n                        jumbo->ip6j_payload_len = SCNtohl(jumbo->ip6j_payload_len);\n                        //printf(\""Jumbo option: type %\"" PRIu32 \"" len %\"" PRIu32 \"" payload len %\"" PRIu32 \""\\n\"",\n                        //    jumbo->ip6j_type, jumbo->ip6j_len, jumbo->ip6j_payload_len);\n                    }\n                    else if (*ptr == IPV6OPT_HAO) /* HAO */\n                    {\n                        hao->ip6hao_type = *(ptr);\n                        hao->ip6hao_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(hao->ip6hao_hoa)) {\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&hao->ip6hao_hoa, (ptr+2), sizeof(hao->ip6hao_hoa));\n                        //printf(\""HAO option: type %\"" PRIu32 \"" len %\"" PRIu32 \"" \"",\n                        //    hao->ip6hao_type, hao->ip6hao_len);\n                        //char addr_buf[46];\n                        //PrintInet(AF_INET6, (char *)&(hao->ip6hao_hoa),\n                        //    addr_buf,sizeof(addr_buf));\n                        //printf(\""home addr %s\\n\"", addr_buf);\n                        other_cnt++;\n                    } else {\n                        if (nh == IPPROTO_HOPOPTS)\n                            ENGINE_SET_EVENT(p, IPV6_HOPOPTS_UNKNOWN_OPT);\n                        else\n                            ENGINE_SET_EVENT(p, IPV6_DSTOPTS_UNKNOWN_OPT);\n\n                        other_cnt++;\n                    }\n                    uint16_t optlen = (*(ptr + 1) + 2);\n                    ptr += optlen; /* +2 for opt type and opt len fields */\n                    offset += optlen;\n                }\n                /* flag packets that have only padding */\n                if (padn_cnt > 0 && other_cnt == 0) {\n                    if (nh == IPPROTO_HOPOPTS)\n                        ENGINE_SET_EVENT(p, IPV6_HOPOPTS_ONLY_PADDING);\n                    else\n                        ENGINE_SET_EVENT(p, IPV6_DSTOPTS_ONLY_PADDING);\n                }\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n\n            case IPPROTO_FRAGMENT:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* store the offset of this extension into the packet\n                 * past the ipv6 header. We use it in defrag for creating\n                 * a defragmented packet without the frag header */\n                if (exthdr_fh_done == 0) {\n                    p->ip6eh.fh_offset = pkt - orig_pkt;\n                    exthdr_fh_done = 1;\n                }\n\n                uint16_t prev_hdrextlen = hdrextlen;\n                hdrextlen = sizeof(IPV6FragHdr);\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                /* for the frag header, the length field is reserved */\n                if (*(pkt + 1) != 0) {\n                    ENGINE_SET_EVENT(p, IPV6_FH_NON_ZERO_RES_FIELD);\n                    /* non fatal, lets try to continue */\n                }\n\n                if (IPV6_EXTHDR_ISSET_FH(p)) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_FH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* set the header flag first */\n                IPV6_EXTHDR_SET_FH(p);\n\n                /* parse the header and setup the vars */\n                DecodeIPV6FragHeader(p, pkt, hdrextlen, plen, prev_hdrextlen);\n\n                /* if FH has offset 0 and no more fragments are coming, we\n                 * parse this packet further right away, no defrag will be\n                 * needed. It is a useless FH then though, so we do set an\n                 * decoder event. */\n                if (p->ip6eh.fh_more_frags_set == 0 && p->ip6eh.fh_offset == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_USELESS_FH);\n\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* the rest is parsed upon reassembly */\n                p->flags |= PKT_IS_FRAGMENT;\n                SCReturn;\n            }\n            case IPPROTO_ESP:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen = sizeof(IPV6EspHdr);\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                if (eh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_EH);\n                    SCReturn;\n                }\n\n                eh = 1;\n\n                nh = IPPROTO_NONE;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_AH:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* we need the header as a minimum */\n                hdrextlen = sizeof(IPV6AuthHdr);\n                /* the payload len field is the number of extra 4 byte fields,\n                 * IPV6AuthHdr already contains the first */\n                if (*(pkt+1) > 0)\n                    hdrextlen += ((*(pkt+1) - 1) * 4);\n\n                SCLogDebug(\""hdrextlen %\""PRIu8, hdrextlen);\n\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                IPV6AuthHdr *ahhdr = (IPV6AuthHdr *)pkt;\n                if (ahhdr->ip6ah_reserved != 0x0000) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_AH_RES_NOT_NULL);\n                }\n\n                if (ah) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_AH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                ah = 1;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_IPIP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeIPv4inIPv6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n            /* none, last header */\n            case IPPROTO_NONE:\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n            case IPPROTO_ICMP:\n                ENGINE_SET_EVENT(p,IPV6_WITH_ICMPV4);\n                SCReturn;\n            /* no parsing yet, just skip it */\n            case IPPROTO_MH:\n            case IPPROTO_HIP:\n            case IPPROTO_SHIM6:\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            default:\n                ENGINE_SET_EVENT(p, IPV6_UNKNOWN_NEXT_HEADER);\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n        }\n    }\n\n    SCReturn;\n}"", ""target"": 0}, {""func_name"": ""DecodeTeredo"", ""file_path"": ""src/decode-teredo.c"", ""func_code"": ""int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n\n    uint8_t *start = pkt;\n\n    /* Is this packet to short to contain an IPv6 packet ? */\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n\n    /* Teredo encapsulate IPv6 in UDP and can add some custom message\n     * part before the IPv6 packet. In our case, we just want to get\n     * over an ORIGIN indication. So we just make one offset if needed. */\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            /* origin indication: compatible with tunnel */\n            case 0x0:\n                /* offset is coherent with len and presence of an IPv6 header */\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            /* authentication: negotiation not real tunnel */\n            case 0x1:\n                return TM_ECODE_FAILED;\n            /* this case is not possible in Teredo: not that protocol */\n            default:\n                return TM_ECODE_FAILED;\n        }\n    }\n\n    /* There is no specific field that we can check to prove that the packet\n     * is a Teredo packet. We've zapped here all the possible Teredo header\n     * and we should have an IPv6 packet at the start pointer.\n     * We then can only do two checks before sending the encapsulated packets\n     * to decoding:\n     *  - The packet has a protocol version which is IPv6.\n     *  - The IPv6 length of the packet matches what remains in buffer.\n     */\n    if (IP_GET_RAW_VER(start) == 6) {\n        IPV6Hdr *thdr = (IPV6Hdr *)start;\n        if (len ==  IPV6_HEADER_LEN +\n                IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n            if (pq != NULL) {\n                int blen = len - (start - pkt);\n                /* spawn off tunnel packet */\n                Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n                                                  DECODE_TUNNEL_IPV6, pq);\n                if (tp != NULL) {\n                    PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                    /* add the tp to the packet queue. */\n                    PacketEnqueue(pq,tp);\n                    StatsIncr(tv, dtv->counter_teredo);\n                    return TM_ECODE_OK;\n                }\n            }\n        }\n        return TM_ECODE_FAILED;\n    }\n\n    return TM_ECODE_FAILED;\n}"", ""target"": 1}, {""func_name"": ""PacketTunnelPktSetup"", ""file_path"": ""src/decode.c"", ""func_code"": ""Packet *PacketTunnelPktSetup(ThreadVars *tv, DecodeThreadVars *dtv, Packet *parent,\n                             uint8_t *pkt, uint32_t len, enum DecodeTunnelProto proto,\n                             PacketQueue *pq)\n{\n    int ret;\n\n    SCEnter();\n\n    /* get us a packet */\n    Packet *p = PacketGetFromQueueOrAlloc();\n    if (unlikely(p == NULL)) {\n        SCReturnPtr(NULL, \""Packet\"");\n    }\n\n    /* copy packet and set lenght, proto */\n    PacketCopyData(p, pkt, len);\n    p->recursion_level = parent->recursion_level + 1;\n    p->ts.tv_sec = parent->ts.tv_sec;\n    p->ts.tv_usec = parent->ts.tv_usec;\n    p->datalink = DLT_RAW;\n    p->tenant_id = parent->tenant_id;\n\n    /* set the root ptr to the lowest layer */\n    if (parent->root != NULL)\n        p->root = parent->root;\n    else\n        p->root = parent;\n\n    /* tell new packet it's part of a tunnel */\n    SET_TUNNEL_PKT(p);\n\n    ret = DecodeTunnel(tv, dtv, p, GET_PKT_DATA(p),\n                       GET_PKT_LEN(p), pq, proto);\n\n    if (unlikely(ret != TM_ECODE_OK)) {\n        /* Not a tunnel packet, just a pseudo packet */\n        p->root = NULL;\n        UNSET_TUNNEL_PKT(p);\n        TmqhOutputPacketpool(tv, p);\n        SCReturnPtr(NULL, \""Packet\"");\n    }\n\n\n    /* tell parent packet it's part of a tunnel */\n    SET_TUNNEL_PKT(parent);\n\n    /* increment tunnel packet refcnt in the root packet */\n    TUNNEL_INCR_PKT_TPR(p);\n\n    /* disable payload (not packet) inspection on the parent, as the payload\n     * is the packet we will now run through the system separately. We do\n     * check it against the ip/port/other header checks though */\n    DecodeSetNoPayloadInspectionFlag(parent);\n    SCReturnPtr(p, \""Packet\"");\n}"", ""target"": 1}, {""func_name"": ""DecodeTunnel"", ""file_path"": ""src/decode.c"", ""func_code"": ""int DecodeTunnel(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p,\n        uint8_t *pkt, uint32_t len, PacketQueue *pq, enum DecodeTunnelProto proto)\n{\n    switch (proto) {\n        case DECODE_TUNNEL_PPP:\n            return DecodePPP(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_IPV4:\n            return DecodeIPV4(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_IPV6:\n            return DecodeIPV6(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_VLAN:\n            return DecodeVLAN(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_ETHERNET:\n            return DecodeEthernet(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_ERSPAN:\n            return DecodeERSPAN(tv, dtv, p, pkt, len, pq);\n        default:\n            SCLogInfo(\""FIXME: DecodeTunnel: protocol %\"" PRIu32 \"" not supported.\"", proto);\n            break;\n    }\n    return TM_ECODE_OK;\n}"", ""target"": 0}, {""func_name"": ""AppLayerProtoDetectGetProto"", ""file_path"": ""src/app-layer-detect-proto.c"", ""func_code"": ""AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,\n                                     Flow *f,\n                                     uint8_t *buf, uint32_t buflen,\n                                     uint8_t ipproto, uint8_t direction)\n{\n    SCEnter();\n    SCLogDebug(\""buflen %u for %s direction\"", buflen,\n            (direction & STREAM_TOSERVER) ? \""toserver\"" : \""toclient\"");\n\n    AppProto alproto = ALPROTO_UNKNOWN;\n\n    if (!FLOW_IS_PM_DONE(f, direction)) {\n        AppProto pm_results[ALPROTO_MAX];\n        uint16_t pm_matches = AppLayerProtoDetectPMGetProto(tctx, f,\n                                                   buf, buflen,\n                                                   direction,\n                                                   ipproto,\n                                                   pm_results);\n        if (pm_matches > 0) {\n            alproto = pm_results[0];\n            goto end;\n        }\n    }\n\n    if (!FLOW_IS_PP_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPPGetProto(f, buf, buflen,\n                                                ipproto, direction);\n        if (alproto != ALPROTO_UNKNOWN)\n            goto end;\n    }\n\n    /* Look if flow can be found in expectation list */\n    if (!FLOW_IS_PE_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPEGetProto(f, ipproto, direction);\n    }\n\n end:\n    SCReturnUInt(alproto);\n}"", ""target"": 1}]","[{""func_name"": ""DecodeIPV6ExtHdrs"", ""file_path"": ""src/decode-ipv6.c"", ""func_code"": ""static void\nDecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    SCEnter();\n\n    uint8_t *orig_pkt = pkt;\n    uint8_t nh = IPV6_GET_NH(p); /* careful, 0 is actually a real type */\n    uint16_t hdrextlen = 0;\n    uint16_t plen = len;\n    char dstopts = 0;\n    char exthdr_fh_done = 0;\n    int hh = 0;\n    int rh = 0;\n    int eh = 0;\n    int ah = 0;\n\n    while(1)\n    {\n        if (nh == IPPROTO_NONE) {\n            if (plen > 0) {\n                /* No upper layer, but we do have data. Suspicious. */\n                ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);\n            }\n            SCReturn;\n        }\n\n        if (plen < 2) { /* minimal needed in a hdr */\n            ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n            SCReturn;\n        }\n\n        switch(nh)\n        {\n            case IPPROTO_TCP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeTCP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_UDP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeUDP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ICMPV6:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeICMPV6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_SCTP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeSCTP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ROUTING:\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n\n                SCLogDebug(\""hdrextlen %\""PRIu8, hdrextlen);\n\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                if (rh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_RH);\n                    /* skip past this extension so we can continue parsing the rest\n                     * of the packet */\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                rh = 1;\n                IPV6_EXTHDR_SET_RH(p);\n\n                uint8_t ip6rh_type = *(pkt + 2);\n                if (ip6rh_type == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_RH_TYPE_0);\n                }\n                p->ip6eh.rh_type = ip6rh_type;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n\n            case IPPROTO_HOPOPTS:\n            case IPPROTO_DSTOPTS:\n            {\n                IPV6OptHAO hao_s, *hao = &hao_s;\n                IPV6OptRA ra_s, *ra = &ra_s;\n                IPV6OptJumbo jumbo_s, *jumbo = &jumbo_s;\n                uint16_t optslen = 0;\n\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen =  (*(pkt+1) + 1) << 3;\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                uint8_t *ptr = pkt + 2; /* +2 to go past nxthdr and len */\n\n                /* point the pointers to right structures\n                 * in Packet. */\n                if (nh == IPPROTO_HOPOPTS) {\n                    if (hh) {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_HH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n\n                    hh = 1;\n\n                    optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                }\n                else if (nh == IPPROTO_DSTOPTS)\n                {\n                    if (dstopts == 0) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 1;\n                    } else if (dstopts == 1) {\n                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;\n                        dstopts = 2;\n                    } else {\n                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_DH);\n                        /* skip past this extension so we can continue parsing the rest\n                         * of the packet */\n                        nh = *pkt;\n                        pkt += hdrextlen;\n                        plen -= hdrextlen;\n                        break;\n                    }\n                }\n\n                if (optslen > plen) {\n                    /* since the packet is long enough (we checked\n                     * plen against hdrlen, the optlen must be malformed. */\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                    /* skip past this extension so we can continue parsing the rest\n                     * of the packet */\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n/** \\todo move into own function to loaded on demand */\n                uint16_t padn_cnt = 0;\n                uint16_t other_cnt = 0;\n                uint16_t offset = 0;\n                while(offset < optslen)\n                {\n                    if (*ptr == IPV6OPT_PAD1)\n                    {\n                        padn_cnt++;\n                        offset++;\n                        ptr++;\n                        continue;\n                    }\n\n                    if (offset + 1 >= optslen) {\n                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                        break;\n                    }\n\n                    /* length field for each opt */\n                    uint8_t ip6_optlen = *(ptr + 1);\n\n                    /* see if the optlen from the packet fits the total optslen */\n                    if ((offset + 1 + ip6_optlen) > optslen) {\n                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                        break;\n                    }\n\n                    if (*ptr == IPV6OPT_PADN) /* PadN */\n                    {\n                        //printf(\""PadN option\\n\"");\n                        padn_cnt++;\n\n                        /* a zero padN len would be weird */\n                        if (ip6_optlen == 0)\n                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_ZERO_LEN_PADN);\n                    }\n                    else if (*ptr == IPV6OPT_RA) /* RA */\n                    {\n                        ra->ip6ra_type = *(ptr);\n                        ra->ip6ra_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(ra->ip6ra_value)) {\n                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&ra->ip6ra_value, (ptr + 2), sizeof(ra->ip6ra_value));\n                        ra->ip6ra_value = SCNtohs(ra->ip6ra_value);\n                        //printf(\""RA option: type %\"" PRIu32 \"" len %\"" PRIu32 \"" value %\"" PRIu32 \""\\n\"",\n                        //    ra->ip6ra_type, ra->ip6ra_len, ra->ip6ra_value);\n                        other_cnt++;\n                    }\n                    else if (*ptr == IPV6OPT_JUMBO) /* Jumbo */\n                    {\n                        jumbo->ip6j_type = *(ptr);\n                        jumbo->ip6j_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(jumbo->ip6j_payload_len)) {\n                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&jumbo->ip6j_payload_len, (ptr+2), sizeof(jumbo->ip6j_payload_len));\n                        jumbo->ip6j_payload_len = SCNtohl(jumbo->ip6j_payload_len);\n                        //printf(\""Jumbo option: type %\"" PRIu32 \"" len %\"" PRIu32 \"" payload len %\"" PRIu32 \""\\n\"",\n                        //    jumbo->ip6j_type, jumbo->ip6j_len, jumbo->ip6j_payload_len);\n                    }\n                    else if (*ptr == IPV6OPT_HAO) /* HAO */\n                    {\n                        hao->ip6hao_type = *(ptr);\n                        hao->ip6hao_len  = ip6_optlen;\n\n                        if (ip6_optlen < sizeof(hao->ip6hao_hoa)) {\n                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                            break;\n                        }\n\n                        memcpy(&hao->ip6hao_hoa, (ptr+2), sizeof(hao->ip6hao_hoa));\n                        //printf(\""HAO option: type %\"" PRIu32 \"" len %\"" PRIu32 \"" \"",\n                        //    hao->ip6hao_type, hao->ip6hao_len);\n                        //char addr_buf[46];\n                        //PrintInet(AF_INET6, (char *)&(hao->ip6hao_hoa),\n                        //    addr_buf,sizeof(addr_buf));\n                        //printf(\""home addr %s\\n\"", addr_buf);\n                        other_cnt++;\n                    } else {\n                        if (nh == IPPROTO_HOPOPTS)\n                            ENGINE_SET_EVENT(p, IPV6_HOPOPTS_UNKNOWN_OPT);\n                        else\n                            ENGINE_SET_EVENT(p, IPV6_DSTOPTS_UNKNOWN_OPT);\n\n                        other_cnt++;\n                    }\n                    uint16_t optlen = (*(ptr + 1) + 2);\n                    ptr += optlen; /* +2 for opt type and opt len fields */\n                    offset += optlen;\n                }\n                /* flag packets that have only padding */\n                if (padn_cnt > 0 && other_cnt == 0) {\n                    if (nh == IPPROTO_HOPOPTS)\n                        ENGINE_SET_EVENT(p, IPV6_HOPOPTS_ONLY_PADDING);\n                    else\n                        ENGINE_SET_EVENT(p, IPV6_DSTOPTS_ONLY_PADDING);\n                }\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n\n            case IPPROTO_FRAGMENT:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* store the offset of this extension into the packet\n                 * past the ipv6 header. We use it in defrag for creating\n                 * a defragmented packet without the frag header */\n                if (exthdr_fh_done == 0) {\n                    p->ip6eh.fh_offset = pkt - orig_pkt;\n                    exthdr_fh_done = 1;\n                }\n\n                uint16_t prev_hdrextlen = hdrextlen;\n                hdrextlen = sizeof(IPV6FragHdr);\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                /* for the frag header, the length field is reserved */\n                if (*(pkt + 1) != 0) {\n                    ENGINE_SET_EVENT(p, IPV6_FH_NON_ZERO_RES_FIELD);\n                    /* non fatal, lets try to continue */\n                }\n\n                if (IPV6_EXTHDR_ISSET_FH(p)) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_FH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* set the header flag first */\n                IPV6_EXTHDR_SET_FH(p);\n\n                /* parse the header and setup the vars */\n                DecodeIPV6FragHeader(p, pkt, hdrextlen, plen, prev_hdrextlen);\n\n                /* if FH has offset 0 and no more fragments are coming, we\n                 * parse this packet further right away, no defrag will be\n                 * needed. It is a useless FH then though, so we do set an\n                 * decoder event. */\n                if (p->ip6eh.fh_more_frags_set == 0 && p->ip6eh.fh_offset == 0) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_USELESS_FH);\n\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                /* the rest is parsed upon reassembly */\n                p->flags |= PKT_IS_FRAGMENT;\n                SCReturn;\n            }\n            case IPPROTO_ESP:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                hdrextlen = sizeof(IPV6EspHdr);\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                if (eh) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_EH);\n                    SCReturn;\n                }\n\n                eh = 1;\n\n                nh = IPPROTO_NONE;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_AH:\n            {\n                IPV6_SET_L4PROTO(p,nh);\n                /* we need the header as a minimum */\n                hdrextlen = sizeof(IPV6AuthHdr);\n                /* the payload len field is the number of extra 4 byte fields,\n                 * IPV6AuthHdr already contains the first */\n                if (*(pkt+1) > 0)\n                    hdrextlen += ((*(pkt+1) - 1) * 4);\n\n                SCLogDebug(\""hdrextlen %\""PRIu8, hdrextlen);\n\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                IPV6AuthHdr *ahhdr = (IPV6AuthHdr *)pkt;\n                if (ahhdr->ip6ah_reserved != 0x0000) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_AH_RES_NOT_NULL);\n                }\n\n                if (ah) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_AH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                ah = 1;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_IPIP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeIPv4inIPv6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n            /* none, last header */\n            case IPPROTO_NONE:\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n            case IPPROTO_ICMP:\n                ENGINE_SET_EVENT(p,IPV6_WITH_ICMPV4);\n                SCReturn;\n            /* no parsing yet, just skip it */\n            case IPPROTO_MH:\n            case IPPROTO_HIP:\n            case IPPROTO_SHIM6:\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n                if (hdrextlen > plen) {\n                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            default:\n                ENGINE_SET_EVENT(p, IPV6_UNKNOWN_NEXT_HEADER);\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n        }\n    }\n\n    SCReturn;\n}""}, {""func_name"": ""DecodeTeredo"", ""file_path"": ""src/decode-teredo.c"", ""func_code"": ""int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n\n    uint8_t *start = pkt;\n\n    /* Is this packet to short to contain an IPv6 packet ? */\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n\n    /* Teredo encapsulate IPv6 in UDP and can add some custom message\n     * part before the IPv6 packet. In our case, we just want to get\n     * over an ORIGIN indication. So we just make one offset if needed. */\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            /* origin indication: compatible with tunnel */\n            case 0x0:\n                /* offset is coherent with len and presence of an IPv6 header */\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            /* authentication: negotiation not real tunnel */\n            case 0x1:\n                return TM_ECODE_FAILED;\n            /* this case is not possible in Teredo: not that protocol */\n            default:\n                return TM_ECODE_FAILED;\n        }\n    }\n\n    /* There is no specific field that we can check to prove that the packet\n     * is a Teredo packet. We've zapped here all the possible Teredo header\n     * and we should have an IPv6 packet at the start pointer.\n     * We then can only do a few checks before sending the encapsulated packets\n     * to decoding:\n     *  - The packet has a protocol version which is IPv6.\n     *  - The IPv6 length of the packet matches what remains in buffer.\n     *  - HLIM is 0. This would technically be valid, but still weird.\n     *  - NH 0 (HOP) and not enough data.\n     *\n     *  If all these conditions are met, the tunnel decoder will be called.\n     *  If the packet gets an invalid event set, it will still be rejected.\n     */\n    if (IP_GET_RAW_VER(start) == 6) {\n        IPV6Hdr *thdr = (IPV6Hdr *)start;\n\n        /* ignore hoplimit 0 packets, most likely an artifact of bad detection */\n        if (IPV6_GET_RAW_HLIM(thdr) == 0)\n            return TM_ECODE_FAILED;\n\n        /* if nh is 0 (HOP) with little data we have a bogus packet */\n        if (IPV6_GET_RAW_NH(thdr) == 0 && IPV6_GET_RAW_PLEN(thdr) < 8)\n            return TM_ECODE_FAILED;\n\n        if (len ==  IPV6_HEADER_LEN +\n                IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n            if (pq != NULL) {\n                int blen = len - (start - pkt);\n                /* spawn off tunnel packet */\n                Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n                                                  DECODE_TUNNEL_IPV6_TEREDO, pq);\n                if (tp != NULL) {\n                    PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                    /* add the tp to the packet queue. */\n                    PacketEnqueue(pq,tp);\n                    StatsIncr(tv, dtv->counter_teredo);\n                    return TM_ECODE_OK;\n                }\n            }\n        }\n        return TM_ECODE_FAILED;\n    }\n\n    return TM_ECODE_FAILED;\n}""}, {""func_name"": ""PacketTunnelPktSetup"", ""file_path"": ""src/decode.c"", ""func_code"": ""Packet *PacketTunnelPktSetup(ThreadVars *tv, DecodeThreadVars *dtv, Packet *parent,\n                             uint8_t *pkt, uint32_t len, enum DecodeTunnelProto proto,\n                             PacketQueue *pq)\n{\n    int ret;\n\n    SCEnter();\n\n    /* get us a packet */\n    Packet *p = PacketGetFromQueueOrAlloc();\n    if (unlikely(p == NULL)) {\n        SCReturnPtr(NULL, \""Packet\"");\n    }\n\n    /* copy packet and set lenght, proto */\n    PacketCopyData(p, pkt, len);\n    p->recursion_level = parent->recursion_level + 1;\n    p->ts.tv_sec = parent->ts.tv_sec;\n    p->ts.tv_usec = parent->ts.tv_usec;\n    p->datalink = DLT_RAW;\n    p->tenant_id = parent->tenant_id;\n\n    /* set the root ptr to the lowest layer */\n    if (parent->root != NULL)\n        p->root = parent->root;\n    else\n        p->root = parent;\n\n    /* tell new packet it's part of a tunnel */\n    SET_TUNNEL_PKT(p);\n\n    ret = DecodeTunnel(tv, dtv, p, GET_PKT_DATA(p),\n                       GET_PKT_LEN(p), pq, proto);\n\n    if (unlikely(ret != TM_ECODE_OK) ||\n            (proto == DECODE_TUNNEL_IPV6_TEREDO && (p->flags & PKT_IS_INVALID)))\n    {\n        /* Not a (valid) tunnel packet */\n        SCLogDebug(\""tunnel packet is invalid\"");\n\n        p->root = NULL;\n        UNSET_TUNNEL_PKT(p);\n        TmqhOutputPacketpool(tv, p);\n        SCReturnPtr(NULL, \""Packet\"");\n    }\n\n\n    /* tell parent packet it's part of a tunnel */\n    SET_TUNNEL_PKT(parent);\n\n    /* increment tunnel packet refcnt in the root packet */\n    TUNNEL_INCR_PKT_TPR(p);\n\n    /* disable payload (not packet) inspection on the parent, as the payload\n     * is the packet we will now run through the system separately. We do\n     * check it against the ip/port/other header checks though */\n    DecodeSetNoPayloadInspectionFlag(parent);\n    SCReturnPtr(p, \""Packet\"");\n}""}, {""func_name"": ""DecodeTunnel"", ""file_path"": ""src/decode.c"", ""func_code"": ""int DecodeTunnel(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p,\n        uint8_t *pkt, uint32_t len, PacketQueue *pq, enum DecodeTunnelProto proto)\n{\n    switch (proto) {\n        case DECODE_TUNNEL_PPP:\n            return DecodePPP(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_IPV4:\n            return DecodeIPV4(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_IPV6:\n        case DECODE_TUNNEL_IPV6_TEREDO:\n            return DecodeIPV6(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_VLAN:\n            return DecodeVLAN(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_ETHERNET:\n            return DecodeEthernet(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_ERSPAN:\n            return DecodeERSPAN(tv, dtv, p, pkt, len, pq);\n        default:\n            SCLogDebug(\""FIXME: DecodeTunnel: protocol %\"" PRIu32 \"" not supported.\"", proto);\n            break;\n    }\n    return TM_ECODE_OK;\n}""}, {""func_name"": ""AppLayerProtoDetectGetProto"", ""file_path"": ""src/app-layer-detect-proto.c"", ""func_code"": ""AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,\n                                     Flow *f,\n                                     uint8_t *buf, uint32_t buflen,\n                                     uint8_t ipproto, uint8_t direction)\n{\n    SCEnter();\n    SCLogDebug(\""buflen %u for %s direction\"", buflen,\n            (direction & STREAM_TOSERVER) ? \""toserver\"" : \""toclient\"");\n\n    AppProto alproto = ALPROTO_UNKNOWN;\n    AppProto pm_alproto = ALPROTO_UNKNOWN;\n\n    if (!FLOW_IS_PM_DONE(f, direction)) {\n        AppProto pm_results[ALPROTO_MAX];\n        uint16_t pm_matches = AppLayerProtoDetectPMGetProto(tctx, f,\n                                                   buf, buflen,\n                                                   direction,\n                                                   ipproto,\n                                                   pm_results);\n        if (pm_matches > 0) {\n            alproto = pm_results[0];\n\n            /* HACK: if detected protocol is dcerpc/udp, we run PP as well\n             * to avoid misdetecting DNS as DCERPC. */\n            if (!(ipproto == IPPROTO_UDP && alproto == ALPROTO_DCERPC))\n                goto end;\n\n            pm_alproto = alproto;\n\n            /* fall through */\n        }\n    }\n\n    if (!FLOW_IS_PP_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPPGetProto(f, buf, buflen,\n                                                ipproto, direction);\n        if (alproto != ALPROTO_UNKNOWN)\n            goto end;\n    }\n\n    /* Look if flow can be found in expectation list */\n    if (!FLOW_IS_PE_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPEGetProto(f, ipproto, direction);\n    }\n\n end:\n    if (alproto == ALPROTO_UNKNOWN)\n        alproto = pm_alproto;\n\n    SCReturnUInt(alproto);\n}""}]","{""code"": 8, ""function"": 7}","[{""source"": ""code_info(file:decode-teredo.c, lines:1-100)"", ""result"": ""/* Copyright (C) 2012 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */\n\n/**\n * \\ingroup decode\n *\n * @{\n */\n\n\n/**\n * \\file\n *\n * \\author Eric Leblond <eric@regit.org>\n *\n * Decode Teredo Tunneling protocol.\n *\n * This implementation is based upon RFC 4380: http://www.ietf.org/rfc/rfc4380.txt\n */\n\n#include \""suricata-common.h\""\n#include \""decode.h\""\n#include \""decode-ipv6.h\""\n#include \""decode-teredo.h\""\n#include \""util-debug.h\""\n#include \""conf.h\""\n\n#define TEREDO_ORIG_INDICATION_LENGTH    8\n\nstatic bool g_teredo_enabled = true;\n\nvoid DecodeTeredoConfig(void)\n{\n    int enabled = 0;\n    if (ConfGetBool(\""decoder.teredo.enabled\"", &enabled) == 1) {\n        if (enabled) {\n            g_teredo_enabled = true;\n        } else {\n            g_teredo_enabled = false;\n        }\n    }\n}\n\n/**\n * \\brief Function to decode Teredo packets\n *\n * \\retval TM_ECODE_FAILED if packet is not a Teredo packet, TM_ECODE_OK if it is\n */\nint DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n\n    uint8_t *start = pkt;\n\n    /* Is this packet to short to contain an IPv6 packet ? */\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n\n    /* Teredo encapsulate IPv6 in UDP and can add some custom message\n     * part before the IPv6 packet. In our case, we just want to get\n     * over an ORIGIN indication. So we just make one offset if needed. */\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            /* origin indication: compatible with tunnel */\n            case 0x0:\n                /* offset is coherent with len and presence of an IPv6 header */\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            /* authentication: negotiation not real tunnel */\n            case 0x1:\n                return TM_ECODE_FAILED;\n            /* this case is not possible in Teredo: not that protocol */\n            default:\n                return TM_ECODE_FAILED;\n        }\n    }\n\n    /* There is no specific field that we can check to prove that the packet\n     * is a Teredo packet. We've zapped here all the possible Teredo header\n     * and we should have an IPv6 packet at the start pointer.\n     * We then can only do two checks before sending the encapsulated packets\n     * to decoding:\n     *  - The packet has a protocol version which is IPv6.\n""}, {""source"": ""func_info(file:decode-teredo.c, func:DecodeTeredo)"", ""result"": [{""code"": ""int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n\n    uint8_t *start = pkt;\n\n    /* Is this packet to short to contain an IPv6 packet ? */\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n\n    /* Teredo encapsulate IPv6 in UDP and can add some custom message\n     * part before the IPv6 packet. In our case, we just want to get\n     * over an ORIGIN indication. So we just make one offset if needed. */\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            /* origin indication: compatible with tunnel */\n            case 0x0:\n                /* offset is coherent with len and presence of an IPv6 header */\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            /*..."", ""start_line"": 63, ""end_line"": 126, ""full_name"": ""DecodeTeredo"", ""file_path"": ""src/decode-teredo.c""}]}, {""source"": ""code_info(file:decode-teredo.c, lines:100-200)"", ""result"": ""     * to decoding:\n     *  - The packet has a protocol version which is IPv6.\n     *  - The IPv6 length of the packet matches what remains in buffer.\n     */\n    if (IP_GET_RAW_VER(start) == 6) {\n        IPV6Hdr *thdr = (IPV6Hdr *)start;\n        if (len ==  IPV6_HEADER_LEN +\n                IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n            if (pq != NULL) {\n                int blen = len - (start - pkt);\n                /* spawn off tunnel packet */\n                Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n                                                  DECODE_TUNNEL_IPV6, pq);\n                if (tp != NULL) {\n                    PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                    /* add the tp to the packet queue. */\n                    PacketEnqueue(pq,tp);\n                    StatsIncr(tv, dtv->counter_teredo);\n                    return TM_ECODE_OK;\n                }\n            }\n        }\n        return TM_ECODE_FAILED;\n    }\n\n    return TM_ECODE_FAILED;\n}\n\n/**\n * @}\n */\n""}, {""source"": ""func_info(func:PacketTunnelPktSetup)"", ""result"": [{""code"": ""Packet *PacketTunnelPktSetup(ThreadVars *tv, DecodeThreadVars *dtv, Packet *parent,\n                             uint8_t *pkt, uint32_t len, enum DecodeTunnelProto proto,\n                             PacketQueue *pq)\n{\n    int ret;\n\n    SCEnter();\n\n    /* get us a packet */\n    Packet *p = PacketGetFromQueueOrAlloc();\n    if (unlikely(p == NULL)) {\n        SCReturnPtr(NULL, \""Packet\"");\n    }\n\n    /* copy packet and set lenght, proto */\n    PacketCopyData(p, pkt, len);\n    p->recursion_level = parent->recursion_level + 1;\n    p->ts.tv_sec = parent->ts.tv_sec;\n    p->ts.tv_usec = parent->ts.tv_usec;\n    p->datalink = DLT_RAW;\n    p->tenant_id = parent->tenant_id;\n\n    /* set the root ptr to the lowest layer */\n    if (parent->root != NULL)\n        p->root = parent->root;\n    else\n        p->root = parent;\n\n    /* tell new packet it's part of a tunnel */\n    SET_TUNNEL_PKT(p);\n\n    ret = DecodeTunnel(tv, dtv, p, GET_PKT_DATA(p),\n                       GET_PKT_LEN(p), pq, proto);\n\n    if..."", ""start_line"": 272, ""end_line"": 326, ""full_name"": ""PacketTunnelPktSetup"", ""file_path"": ""src/decode.c""}]}, {""source"": ""code_info(file:decode-teredo.c, lines:127-200)"", ""result"": ""\n/**\n * @}\n */\n""}, {""source"": ""func_info(file:decode-teredo.c, func:DecodeTeredo)"", ""result"": [{""code"": ""int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n\n    uint8_t *start = pkt;\n\n    /* Is this packet to short to contain an IPv6 packet ? */\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n\n    /* Teredo encapsulate IPv6 in UDP and can add some custom message\n     * part before the IPv6 packet. In our case, we just want to get\n     * over an ORIGIN indication. So we just make one offset if needed. */\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            /* origin indication: compatible with tunnel */\n            case 0x0:\n                /* offset is coherent with len and presence of an IPv6 header */\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            /*..."", ""start_line"": 63, ""end_line"": 126, ""full_name"": ""DecodeTeredo"", ""file_path"": ""src/decode-teredo.c""}]}, {""source"": ""code_info(file:decode-teredo.c, lines:127-200)"", ""result"": ""\n/**\n * @}\n */\n""}, {""source"": ""func_info(file:decode.c, func:PacketTunnelPktSetup)"", ""result"": [{""code"": ""Packet *PacketTunnelPktSetup(ThreadVars *tv, DecodeThreadVars *dtv, Packet *parent,\n                             uint8_t *pkt, uint32_t len, enum DecodeTunnelProto proto,\n                             PacketQueue *pq)\n{\n    int ret;\n\n    SCEnter();\n\n    /* get us a packet */\n    Packet *p = PacketGetFromQueueOrAlloc();\n    if (unlikely(p == NULL)) {\n        SCReturnPtr(NULL, \""Packet\"");\n    }\n\n    /* copy packet and set lenght, proto */\n    PacketCopyData(p, pkt, len);\n    p->recursion_level = parent->recursion_level + 1;\n    p->ts.tv_sec = parent->ts.tv_sec;\n    p->ts.tv_usec = parent->ts.tv_usec;\n    p->datalink = DLT_RAW;\n    p->tenant_id = parent->tenant_id;\n\n    /* set the root ptr to the lowest layer */\n    if (parent->root != NULL)\n        p->root = parent->root;\n    else\n        p->root = parent;\n\n    /* tell new packet it's part of a tunnel */\n    SET_TUNNEL_PKT(p);\n\n    ret = DecodeTunnel(tv, dtv, p, GET_PKT_DATA(p),\n                       GET_PKT_LEN(p), pq, proto);\n\n    if..."", ""start_line"": 272, ""end_line"": 326, ""full_name"": ""PacketTunnelPktSetup"", ""file_path"": ""src/decode.c""}]}, {""source"": ""code_info(file:decode-ipv6.c, lines:100-200)"", ""result"": ""    }\n    return TM_ECODE_OK;\n}\n\n#ifndef UNITTESTS // ugly, but we need this in defrag tests\nstatic inline\n#endif\nvoid DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                          uint16_t hdrextlen, uint16_t plen,\n                          uint16_t prev_hdrextlen)\n{\n    uint16_t frag_offset = (*(pkt + 2) << 8 | *(pkt + 3)) & 0xFFF8;\n    int frag_morefrags   = (*(pkt + 2) << 8 | *(pkt + 3)) & 0x0001;\n\n    p->ip6eh.fh_offset = frag_offset;\n    p->ip6eh.fh_more_frags_set = frag_morefrags ? TRUE : FALSE;\n    p->ip6eh.fh_nh = *pkt;\n\n    uint32_t fh_id;\n    memcpy(&fh_id, pkt+4, 4);\n    p->ip6eh.fh_id = SCNtohl(fh_id);\n\n    SCLogDebug(\""IPV6 FH: offset %u, mf %s, nh %u, id %u/%x\"",\n            p->ip6eh.fh_offset,\n            p->ip6eh.fh_more_frags_set ? \""true\"" : \""false\"",\n            p->ip6eh.fh_nh,\n            p->ip6eh.fh_id, p->ip6eh.fh_id);\n\n    // store header offset, data offset\n    uint16_t frag_hdr_offset = (uint16_t)(pkt - GET_PKT_DATA(p));\n    uint16_t data_offset = (uint16_t)(frag_hdr_offset + hdrextlen);\n    uint16_t data_len = plen - hdrextlen;\n\n    p->ip6eh.fh_header_offset = frag_hdr_offset;\n    p->ip6eh.fh_data_offset = data_offset;\n    p->ip6eh.fh_data_len = data_len;\n\n    /* if we have a prev hdr, store the type and offset of it */\n    if (prev_hdrextlen) {\n        p->ip6eh.fh_prev_hdr_offset = frag_hdr_offset - prev_hdrextlen;\n    }\n\n    SCLogDebug(\""IPV6 FH: frag_hdr_offset %u, data_offset %u, data_len %u\"",\n            p->ip6eh.fh_header_offset, p->ip6eh.fh_data_offset,\n            p->ip6eh.fh_data_len);\n}\n\nstatic void\nDecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    SCEnter();\n\n    uint8_t *orig_pkt = pkt;\n    uint8_t nh = 0; /* careful, 0 is actually a real type */\n    uint16_t hdrextlen = 0;\n    uint16_t plen;\n    char dstopts = 0;\n    char exthdr_fh_done = 0;\n    int hh = 0;\n    int rh = 0;\n    int eh = 0;\n    int ah = 0;\n\n    nh = IPV6_GET_NH(p);\n    plen = len;\n\n    while(1)\n    {\n        /* No upper layer, but we do have data. Suspicious. */\n        if (nh == IPPROTO_NONE && plen > 0) {\n            ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);\n            SCReturn;\n        }\n\n        if (plen < 2) { /* minimal needed in a hdr */\n            SCReturn;\n        }\n\n        switch(nh)\n        {\n            case IPPROTO_TCP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeTCP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_UDP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeUDP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ICMPV6:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeICMPV6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_SCTP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeSCTP(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n\n            case IPPROTO_ROUTING:\n                IPV6_SET_L4PROTO(p,nh);\n""}, {""source"": ""func_info(file:decode.c, func:DecodeTunnel)"", ""result"": [{""code"": ""int DecodeTunnel(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p,\n        uint8_t *pkt, uint32_t len, PacketQueue *pq, enum DecodeTunnelProto proto)\n{\n    switch (proto) {\n        case DECODE_TUNNEL_PPP:\n            return DecodePPP(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_IPV4:\n            return DecodeIPV4(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_IPV6:\n            return DecodeIPV6(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_VLAN:\n            return DecodeVLAN(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_ETHERNET:\n            return DecodeEthernet(tv, dtv, p, pkt, len, pq);\n        case DECODE_TUNNEL_ERSPAN:\n            return DecodeERSPAN(tv, dtv, p, pkt, len, pq);\n        default:\n            SCLogInfo(\""FIXME: DecodeTunnel: protocol %\"" PRIu32 \"" not supported.\"", proto);\n            break;\n    }\n    return TM_ECODE_OK;\n}"", ""start_line"": 73, ""end_line"": 94, ""full_name"": ""DecodeTunnel"", ""file_path"": ""src/decode.c""}]}, {""source"": ""code_info(file:decode-ipv6.c, lines:500-600)"", ""result"": ""                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n\n                IPV6AuthHdr *ahhdr = (IPV6AuthHdr *)pkt;\n                if (ahhdr->ip6ah_reserved != 0x0000) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_AH_RES_NOT_NULL);\n                }\n\n                if (ah) {\n                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_AH);\n                    nh = *pkt;\n                    pkt += hdrextlen;\n                    plen -= hdrextlen;\n                    break;\n                }\n\n                ah = 1;\n\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            }\n            case IPPROTO_IPIP:\n                IPV6_SET_L4PROTO(p,nh);\n                DecodeIPv4inIPv6(tv, dtv, p, pkt, plen, pq);\n                SCReturn;\n            /* none, last header */\n            case IPPROTO_NONE:\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n            case IPPROTO_ICMP:\n                ENGINE_SET_EVENT(p,IPV6_WITH_ICMPV4);\n                SCReturn;\n            /* no parsing yet, just skip it */\n            case IPPROTO_MH:\n            case IPPROTO_HIP:\n            case IPPROTO_SHIM6:\n                hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n                if (hdrextlen > plen) {\n                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n                    SCReturn;\n                }\n                nh = *pkt;\n                pkt += hdrextlen;\n                plen -= hdrextlen;\n                break;\n            default:\n                ENGINE_SET_EVENT(p, IPV6_UNKNOWN_NEXT_HEADER);\n                IPV6_SET_L4PROTO(p,nh);\n                SCReturn;\n        }\n    }\n\n    SCReturn;\n}\n\nstatic int DecodeIPV6Packet (ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len)\n{\n    if (unlikely(len < IPV6_HEADER_LEN)) {\n        return -1;\n    }\n\n    if (unlikely(IP_GET_RAW_VER(pkt) != 6)) {\n        SCLogDebug(\""wrong ip version %\"" PRIu8 \""\"",IP_GET_RAW_VER(pkt));\n        ENGINE_SET_INVALID_EVENT(p, IPV6_WRONG_IP_VER);\n        return -1;\n    }\n\n    p->ip6h = (IPV6Hdr *)pkt;\n\n    if (unlikely(len < (IPV6_HEADER_LEN + IPV6_GET_PLEN(p))))\n    {\n        ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_PKT);\n        return -1;\n    }\n\n    SET_IPV6_SRC_ADDR(p,&p->src);\n    SET_IPV6_DST_ADDR(p,&p->dst);\n\n    return 0;\n}\n\nint DecodeIPV6(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    int ret;\n\n    StatsIncr(tv, dtv->counter_ipv6);\n\n    /* do the actual decoding */\n    ret = DecodeIPV6Packet (tv, dtv, p, pkt, len);\n    if (unlikely(ret < 0)) {\n        p->ip6h = NULL;\n        return TM_ECODE_FAILED;\n    }\n\n#ifdef DEBUG\n    if (SCLogDebugEnabled()) { /* only convert the addresses if debug is really enabled */\n        /* debug print */\n        char s[46], d[46];\n        PrintInet(AF_INET6, (const void *)GET_IPV6_SRC_ADDR(p), s, sizeof(s));\n""}, {""source"": ""code_info(file:decode-teredo.c, lines:127-150)"", ""result"": ""\n/**\n * @}\n */\n""}, {""source"": ""func_info(file:decode-ipv6.c, func:DecodeIPV6)"", ""result"": [{""code"": ""int DecodeIPV6(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    int ret;\n\n    StatsIncr(tv, dtv->counter_ipv6);\n\n    /* do the actual decoding */\n    ret = DecodeIPV6Packet (tv, dtv, p, pkt, len);\n    if (unlikely(ret < 0)) {\n        p->ip6h = NULL;\n        return TM_ECODE_FAILED;\n    }\n\n#ifdef DEBUG\n    if (SCLogDebugEnabled()) { /* only convert the addresses if debug is really enabled */\n        /* debug print */\n        char s[46], d[46];\n        PrintInet(AF_INET6, (const void *)GET_IPV6_SRC_ADDR(p), s, sizeof(s));\n        PrintInet(AF_INET6, (const void *)GET_IPV6_DST_ADDR(p), d, sizeof(d));\n        SCLogDebug(\""IPV6 %s->%s - CLASS: %\"" PRIu32 \"" FLOW: %\"" PRIu32 \"" NH: %\"" PRIu32 \"" PLEN: %\"" PRIu32 \"" HLIM: %\"" PRIu32 \""\"", s,d,\n                IPV6_GET_CLASS(p), IPV6_GET_FLOW(p), IPV6_GET_NH(p), IPV6_GET_PLEN(p),\n                IPV6_GET_HLIM(p));\n    }\n#endif /* DEBUG */\n\n    /* now process the Ext headers and/or the L4 Layer */\n    s..."", ""start_line"": 584, ""end_line"": 665, ""full_name"": ""DecodeIPV6"", ""file_path"": ""src/decode-ipv6.c""}]}, {""source"": ""func_info(file:decode-teredo.c, func:DecodeTeredo)"", ""result"": [{""code"": ""int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n\n    uint8_t *start = pkt;\n\n    /* Is this packet to short to contain an IPv6 packet ? */\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n\n    /* Teredo encapsulate IPv6 in UDP and can add some custom message\n     * part before the IPv6 packet. In our case, we just want to get\n     * over an ORIGIN indication. So we just make one offset if needed. */\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            /* origin indication: compatible with tunnel */\n            case 0x0:\n                /* offset is coherent with len and presence of an IPv6 header */\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            /*..."", ""start_line"": 63, ""end_line"": 126, ""full_name"": ""DecodeTeredo"", ""file_path"": ""src/decode-teredo.c""}]}, {""source"": ""code_info(file:decode-teredo.c, lines:127-150)"", ""result"": ""\n/**\n * @}\n */\n""}]","decode-ipv6.c:151-539: Malformed IPv6 headers were marked with non-fatal ENGINE_SET_EVENT, allowing invalid packets to be processed as Teredo. The patch replaces these with ENGINE_SET_INVALID_EVENT, ensuring malformed packets are rejected. decode.c:80-89 routes Teredo packets through IPv6 decoder. decode-teredo.c:63-126 checks IPv6 header validity and relies on DecodeIPV6's return value (src/decode-ipv6.c:584-665) to determine if the packet is valid. If DecodeIPV6 returns TM_ECODE_FAILED (due to invalid events), Teredo detection is skipped. This blocks invalid packets from being misclassified as Teredo.",0.95,./github/other_context/CVE-2019-1010251
31,CVE-2019-18424,CWE-78,c_cpp,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12,"passthrough: quarantine PCI devices\n\nWhen a PCI device is assigned to an untrusted domain, it is possible for\nthat domain to program the device to DMA to an arbitrary address. The\nIOMMU is used to protect the host from malicious DMA by making sure that\nthe device addresses can only target memory assigned to the guest. However,\nwhen the guest domain is torn down the device is assigned back to dom0,\nthus allowing any in-flight DMA to potentially target critical host data.\n\nThis patch introduces a 'quarantine' for PCI devices using dom_io. When\nthe toolstack makes a device assignable (by binding it to pciback), it\nwill now also assign it to DOMID_IO and the device will only be assigned\nback to dom0 when the device is made unassignable again. Whilst device is\nassignable it will only ever transfer between dom_io and guest domains.\ndom_io is actually only used as a sentinel domain for quarantining purposes;\nit is not configured with any IOMMU mappings. Assignment to dom_io simply\nmeans that the device's initiator (requestor) identifier is not present in\nthe IOMMU's device table and thus any DMA transactions issued will be\nterminated with a fault condition.\n\nIn addition, a fix to assignment handling is made for VT-d.  Failure\nduring the assignment step should not lead to a device still being\nassociated with its prior owner. Hand the device to DomIO temporarily,\nuntil the assignment step has completed successfully.  Remove the PI\nhooks from the source domain then earlier as well.\n\nFailure of the recovery reassign_device_ownership() may not go silent:\nThere e.g. may still be left over RMRR mappings in the domain assignment\nto which has failed, and hence we can't allow that domain to continue\nexecuting.\n\nNOTE: This patch also includes one printk() cleanup; the\n      ""XEN_DOMCTL_assign_device: "" tag is dropped in iommu_do_pci_domctl(),\n      since similar printk()-s elsewhere also don't log such a tag.\n\nThis is XSA-302.\n\nSigned-off-by: Paul Durrant <paul.durrant@citrix.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nSigned-off-by: Ian Jackson <ian.jackson@eu.citrix.com>",16,"[{""func_name"": ""iommu_setup"", ""file_path"": ""xen/drivers/passthrough/iommu.c"", ""func_code"": ""int __init iommu_setup(void)\n{\n    int rc = -ENODEV;\n    bool_t force_intremap = force_iommu && iommu_intremap;\n\n    if ( iommu_hwdom_strict )\n        iommu_hwdom_passthrough = false;\n\n    if ( iommu_enable )\n    {\n        rc = iommu_hardware_setup();\n        iommu_enabled = (rc == 0);\n    }\n    if ( !iommu_enabled )\n        iommu_intremap = 0;\n\n    if ( (force_iommu && !iommu_enabled) ||\n         (force_intremap && !iommu_intremap) )\n        panic(\""Couldn't enable %s and iommu=required/force\\n\"",\n              !iommu_enabled ? \""IOMMU\"" : \""Interrupt Remapping\"");\n\n    if ( !iommu_intremap )\n        iommu_intpost = 0;\n\n    printk(\""I/O virtualisation %sabled\\n\"", iommu_enabled ? \""en\"" : \""dis\"");\n    if ( !iommu_enabled )\n    {\n        iommu_snoop = 0;\n        iommu_hwdom_passthrough = false;\n        iommu_hwdom_strict = false;\n    }\n    else\n    {\n        printk(\"" - Dom0 mode: %s\\n\"",\n               iommu_hwdom_passthrough ? \""Passthrough\"" :\n               iommu_hwdom_strict ? \""Strict\"" : \""Relaxed\"");\n        printk(\""Interrupt remapping %sabled\\n\"", iommu_intremap ? \""en\"" : \""dis\"");\n        tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);\n    }\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""iommu_domain_init"", ""file_path"": ""xen/drivers/passthrough/iommu.c"", ""func_code"": ""int iommu_domain_init(struct domain *d, unsigned int opts)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n#ifdef CONFIG_NUMA\n    hd->node = NUMA_NO_NODE;\n#endif\n\n    ret = arch_iommu_domain_init(d);\n    if ( ret )\n        return ret;\n\n    hd->platform_ops = iommu_get_ops();\n    ret = hd->platform_ops->init(d);\n    if ( ret )\n        return ret;\n\n    if ( is_hardware_domain(d) )\n        check_hwdom_reqs(d); /* may modify iommu_hwdom_strict */\n\n    /*\n     * Use shared page tables for HAP and IOMMU if the global option\n     * is enabled (from which we can infer the h/w is capable) and\n     * the domain options do not disallow it. HAP must, of course, also\n     * be enabled.\n     */\n    hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&\n        !(opts & XEN_DOMCTL_IOMMU_no_sharept);\n\n    /*\n     * NB: 'relaxed' h/w domains don't need the IOMMU mappings to be kept\n     *     in-sync with their assigned pages because all host RAM will be\n     *     mapped during hwdom_init().\n     */\n    if ( !is_hardware_domain(d) || iommu_hwdom_strict )\n        hd->need_sync = !iommu_use_hap_pt(d);\n\n    ASSERT(!(hd->need_sync && hd->hap_pt_share));\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""setup_system_domains"", ""file_path"": ""xen/common/domain.c"", ""func_code"": ""void __init setup_system_domains(void)\n{\n    /*\n     * Initialise our DOMID_XEN domain.\n     * Any Xen-heap pages that we will allow to be mapped will have\n     * their domain field set to dom_xen.\n     * Hidden PCI devices will also be associated with this domain\n     * (but be [partly] controlled by Dom0 nevertheless).\n     */\n    dom_xen = domain_create(DOMID_XEN, NULL, false);\n    if ( IS_ERR(dom_xen) )\n        panic(\""Failed to create d[XEN]: %ld\\n\"", PTR_ERR(dom_xen));\n\n    /*\n     * Initialise our DOMID_IO domain.\n     * This domain owns I/O pages that are within the range of the page_info\n     * array. Mappings occur at the priv of the caller.\n     */\n    dom_io = domain_create(DOMID_IO, NULL, false);\n    if ( IS_ERR(dom_io) )\n        panic(\""Failed to create d[IO]: %ld\\n\"", PTR_ERR(dom_io));\n\n#ifdef CONFIG_MEM_SHARING\n    /*\n     * Initialise our COW domain.\n     * This domain owns sharable pages.\n     */\n    dom_cow = domain_create(DOMID_COW, NULL, false);\n    if ( IS_ERR(dom_cow) )\n        panic(\""Failed to create d[COW]: %ld\\n\"", PTR_ERR(dom_cow));\n#endif\n}"", ""target"": 0}, {""func_name"": ""amd_iommu_setup_domain_device"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static void amd_iommu_setup_domain_device(\n    struct domain *domain, struct amd_iommu *iommu,\n    uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id, valid = 1;\n    u8 bus = pdev->bus;\n    const struct domain_iommu *hd = dom_iommu(domain);\n\n    BUG_ON( !hd->arch.root_table || !hd->arch.paging_mode ||\n            !iommu->dev_table.buffer );\n\n    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )\n        valid = 0;\n\n    /* get device-table entry */\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n\n    if ( !dte->v || !dte->tv )\n    {\n        /* bind DTE to domain page-tables */\n        amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.root_table), domain->domain_id,\n            hd->arch.paging_mode, valid);\n\n        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )\n            dte->i = ats_enabled;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\""Setup I/O page table: device id = %#x, type = %#x, \""\n                        \""root table = %#\""PRIx64\"", \""\n                        \""domain = %d, paging mode = %d\\n\"",\n                        req_id, pdev->type,\n                        page_to_maddr(hd->arch.root_table),\n                        domain->domain_id, hd->arch.paging_mode);\n    }\n\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )\n    {\n        if ( devfn == pdev->devfn )\n            enable_ats_device(pdev, &iommu->ats_devices);\n\n        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);\n    }\n}"", ""target"": 0}, {""func_name"": ""amd_iommu_disable_domain_device"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static void amd_iommu_disable_domain_device(const struct domain *domain,\n                                            struct amd_iommu *iommu,\n                                            uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id;\n    u8 bus = pdev->bus;\n\n    BUG_ON ( iommu->dev_table.buffer == NULL );\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n    if ( dte->tv || dte->v )\n    {\n        /* See the comment in amd_iommu_setup_device_table(). */\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_ABORTED;\n        smp_wmb();\n        dte->iv = true;\n        dte->tv = false;\n        dte->gv = false;\n        dte->i = false;\n        dte->ex = false;\n        dte->sa = false;\n        dte->se = false;\n        dte->sd = false;\n        dte->sys_mgt = IOMMU_DEV_TABLE_SYS_MGT_DMA_ABORTED;\n        dte->ioctl = IOMMU_DEV_TABLE_IO_CONTROL_ABORTED;\n        smp_wmb();\n        dte->v = true;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\""Disable: device id = %#x, \""\n                        \""domain = %d, paging mode = %d\\n\"",\n                        req_id,  domain->domain_id,\n                        dom_iommu(domain)->arch.paging_mode);\n    }\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( devfn == pdev->devfn &&\n         pci_ats_device(iommu->seg, bus, devfn) &&\n         pci_ats_enabled(iommu->seg, bus, devfn) )\n        disable_ats_device(pdev);\n}"", ""target"": 0}, {""func_name"": ""amd_iommu_assign_device"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static int amd_iommu_assign_device(struct domain *d, u8 devfn,\n                                   struct pci_dev *pdev,\n                                   u32 flag)\n{\n    struct ivrs_mappings *ivrs_mappings = get_ivrs_mappings(pdev->seg);\n    int bdf = PCI_BDF2(pdev->bus, devfn);\n    int req_id = get_dma_requestor_id(pdev->seg, bdf);\n\n    if ( ivrs_mappings[req_id].unity_map_enable )\n    {\n        amd_iommu_reserve_domain_unity_map(\n            d,\n            ivrs_mappings[req_id].addr_range_start,\n            ivrs_mappings[req_id].addr_range_length,\n            ivrs_mappings[req_id].write_permission,\n            ivrs_mappings[req_id].read_permission);\n    }\n\n    return reassign_device(hardware_domain, d, devfn, pdev);\n}"", ""target"": 0}, {""func_name"": ""libxl__device_pci_assignable_remove"", ""file_path"": ""tools/libxl/libxl_pci.c"", ""func_code"": ""static int libxl__device_pci_assignable_remove(libxl__gc *gc,\n                                               libxl_device_pci *pcidev,\n                                               int rebind)\n{\n    int rc;\n    char *driver_path;\n\n    /* Unbind from pciback */\n    if ( (rc=pciback_dev_is_assigned(gc, pcidev)) < 0 ) {\n        return ERROR_FAIL;\n    } else if ( rc ) {\n        pciback_dev_unassign(gc, pcidev);\n    } else {\n        LOG(WARN, \""Not bound to pciback\"");\n    }\n\n    /* Rebind if necessary */\n    driver_path = pci_assignable_driver_path_read(gc, pcidev);\n\n    if ( driver_path ) {\n        if ( rebind ) {\n            LOG(INFO, \""Rebinding to driver at %s\"", driver_path);\n\n            if ( sysfs_write_bdf(gc,\n                                 GCSPRINTF(\""%s/bind\"", driver_path),\n                                 pcidev) < 0 ) {\n                LOGE(ERROR, \""Couldn't bind device to %s\"", driver_path);\n                return -1;\n            }\n\n            pci_assignable_driver_path_remove(gc, pcidev);\n        }\n    } else {\n        if ( rebind ) {\n            LOG(WARN,\n                \""Couldn't find path for original driver; not rebinding\"");\n        }\n    }\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""libxl__device_pci_assignable_add"", ""file_path"": ""tools/libxl/libxl_pci.c"", ""func_code"": ""static int libxl__device_pci_assignable_add(libxl__gc *gc,\n                                            libxl_device_pci *pcidev,\n                                            int rebind)\n{\n    unsigned dom, bus, dev, func;\n    char *spath, *driver_path = NULL;\n    int rc;\n    struct stat st;\n\n    /* Local copy for convenience */\n    dom = pcidev->domain;\n    bus = pcidev->bus;\n    dev = pcidev->dev;\n    func = pcidev->func;\n\n    /* See if the device exists */\n    spath = GCSPRINTF(SYSFS_PCI_DEV\""/\""PCI_BDF, dom, bus, dev, func);\n    if ( lstat(spath, &st) ) {\n        LOGE(ERROR, \""Couldn't lstat %s\"", spath);\n        return ERROR_FAIL;\n    }"", ""target"": 0}, {""func_name"": ""iommu_do_dt_domctl"", ""file_path"": ""xen/drivers/passthrough/device_tree.c"", ""func_code"": ""int iommu_do_dt_domctl(struct xen_domctl *domctl, struct domain *d,\n                       XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    int ret;\n    struct dt_device_node *dev;\n\n    switch ( domctl->cmd )\n    {\n    case XEN_DOMCTL_assign_device:\n        ASSERT(d);\n        /* fall through */\n    case XEN_DOMCTL_test_assign_device:\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )\n            break;\n\n        ret = -EINVAL;\n        if ( (d && d->is_dying) || domctl->u.assign_device.flags )\n            break;\n\n        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,\n                                    domctl->u.assign_device.u.dt.size,\n                                    &dev);\n        if ( ret )\n            break;\n\n        ret = xsm_assign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));\n        if ( ret )\n            break;\n\n        if ( domctl->cmd == XEN_DOMCTL_test_assign_device )\n        {\n            if ( iommu_dt_device_is_assigned(dev) )\n            {\n                printk(XENLOG_G_ERR \""%s already assigned.\\n\"",\n                       dt_node_full_name(dev));\n                ret = -EINVAL;\n            }\n            break;\n        }\n\n        ret = iommu_add_dt_device(dev);\n        /*\n         * Ignore \""-EEXIST\"" error code as it would mean that the device is\n         * already added to the IOMMU (positive result). Such happens after\n         * re-creating guest domain.\n         */\n        if ( ret < 0 && ret != -EEXIST )\n        {\n            printk(XENLOG_G_ERR \""Failed to add %s to the IOMMU\\n\"",\n                   dt_node_full_name(dev));\n            break;\n        }\n\n        ret = iommu_assign_dt_device(d, dev);\n\n        if ( ret )\n            printk(XENLOG_G_ERR \""XEN_DOMCTL_assign_dt_device: assign \\\""%s\\\""\""\n                   \"" to dom%u failed (%d)\\n\"",\n                   dt_node_full_name(dev), d->domain_id, ret);\n        break;\n\n    case XEN_DOMCTL_deassign_device:\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )\n            break;\n\n        ret = -EINVAL;\n        if ( domctl->u.assign_device.flags )\n            break;\n\n        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,\n                                    domctl->u.assign_device.u.dt.size,\n                                    &dev);\n        if ( ret )\n            break;\n\n        ret = xsm_deassign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));\n\n        ret = iommu_deassign_dt_device(d, dev);\n\n        if ( ret )\n            printk(XENLOG_G_ERR \""XEN_DOMCTL_assign_dt_device: assign \\\""%s\\\""\""\n                   \"" to dom%u failed (%d)\\n\"",\n                   dt_node_full_name(dev), d->domain_id, ret);\n        break;\n\n    default:\n        ret = -ENOSYS;\n        break;\n    }\n\n    return ret;\n}"", ""target"": 0}, {""func_name"": ""do_domctl"", ""file_path"": ""xen/common/domctl.c"", ""func_code"": ""long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    long ret = 0;\n    bool_t copyback = 0;\n    struct xen_domctl curop, *op = &curop;\n    struct domain *d;\n\n    if ( copy_from_guest(op, u_domctl, 1) )\n        return -EFAULT;\n\n    if ( op->interface_version != XEN_DOMCTL_INTERFACE_VERSION )\n        return -EACCES;\n\n    switch ( op->cmd )\n    {\n    case XEN_DOMCTL_test_assign_device:\n    case XEN_DOMCTL_vm_event_op:\n        if ( op->domain == DOMID_INVALID )\n        {\n    case XEN_DOMCTL_createdomain:\n    case XEN_DOMCTL_gdbsx_guestmemio:\n            d = NULL;\n            break;\n        }\n        /* fall through */\n    default:\n        d = rcu_lock_domain_by_id(op->domain);\n        if ( !d && op->cmd != XEN_DOMCTL_getdomaininfo )\n            return -ESRCH;\n    }\n\n    ret = xsm_domctl(XSM_OTHER, d, op->cmd);\n    if ( ret )\n        goto domctl_out_unlock_domonly;\n\n    if ( !domctl_lock_acquire() )\n    {\n        if ( d )\n            rcu_unlock_domain(d);\n        return hypercall_create_continuation(\n            __HYPERVISOR_domctl, \""h\"", u_domctl);\n    }\n\n    switch ( op->cmd )\n    {\n\n    case XEN_DOMCTL_setvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        unsigned int vcpu = op->u.vcpucontext.vcpu;\n        struct vcpu *v;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (vcpu >= d->max_vcpus) || ((v = d->vcpu[vcpu]) == NULL) )\n            break;\n\n        if ( guest_handle_is_null(op->u.vcpucontext.ctxt) )\n        {\n            ret = vcpu_reset(v);\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \""h\"", u_domctl);\n            break;\n        }\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = alloc_vcpu_guest_context()) == NULL )\n            break;\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32bit_domain(d) )\n            ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n        else\n            ret = copy_from_guest(c.cmp,\n                                  guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                    void), 1);\n#else\n        ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n#endif\n        ret = ret ? -EFAULT : 0;\n\n        if ( ret == 0 )\n        {\n            domain_pause(d);\n            ret = arch_set_info_guest(v, c);\n            domain_unpause(d);\n\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \""h\"", u_domctl);\n        }\n\n        free_vcpu_guest_context(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_pausedomain:\n        ret = -EINVAL;\n        if ( d != current->domain )\n            ret = domain_pause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_unpausedomain:\n        ret = domain_unpause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_resumedomain:\n        if ( d == current->domain ) /* no domain_pause() */\n            ret = -EINVAL;\n        else\n            domain_resume(d);\n        break;\n\n    case XEN_DOMCTL_createdomain:\n    {\n        domid_t        dom;\n        static domid_t rover = 0;\n\n        dom = op->domain;\n        if ( (dom > 0) && (dom < DOMID_FIRST_RESERVED) )\n        {\n            ret = -EINVAL;\n            if ( !is_free_domid(dom) )\n                break;\n        }\n        else\n        {\n            for ( dom = rover + 1; dom != rover; dom++ )\n            {\n                if ( dom == DOMID_FIRST_RESERVED )\n                    dom = 1;\n                if ( is_free_domid(dom) )\n                    break;\n            }\n\n            ret = -ENOMEM;\n            if ( dom == rover )\n                break;\n\n            rover = dom;\n        }\n\n        d = domain_create(dom, &op->u.createdomain, false);\n        if ( IS_ERR(d) )\n        {\n            ret = PTR_ERR(d);\n            d = NULL;\n            break;\n        }\n\n        ret = 0;\n        op->domain = d->domain_id;\n        copyback = 1;\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_max_vcpus:\n    {\n        unsigned int i, max = op->u.max_vcpus.max;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (max != d->max_vcpus) )   /* max_vcpus set up in createdomain */\n            break;\n\n        /* Needed, for example, to ensure writable p.t. state is synced. */\n        domain_pause(d);\n\n        ret = -ENOMEM;\n\n        for ( i = 0; i < max; i++ )\n        {\n            if ( d->vcpu[i] != NULL )\n                continue;\n\n            if ( vcpu_create(d, i) == NULL )\n                goto maxvcpu_out;\n        }\n\n        domain_update_node_affinity(d);\n        ret = 0;\n\n    maxvcpu_out:\n        domain_unpause(d);\n        break;\n    }\n\n    case XEN_DOMCTL_soft_reset:\n        if ( d == current->domain ) /* no domain_pause() */\n        {\n            ret = -EINVAL;\n            break;\n        }\n        ret = domain_soft_reset(d);\n        break;\n\n    case XEN_DOMCTL_destroydomain:\n        domctl_lock_release();\n        domain_lock(d);\n        ret = domain_kill(d);\n        domain_unlock(d);\n        if ( ret == -ERESTART )\n            ret = hypercall_create_continuation(\n                __HYPERVISOR_domctl, \""h\"", u_domctl);\n        goto domctl_out_unlock_domonly;\n\n    case XEN_DOMCTL_setnodeaffinity:\n    {\n        nodemask_t new_affinity;\n\n        ret = xenctl_bitmap_to_nodemask(&new_affinity,\n                                        &op->u.nodeaffinity.nodemap);\n        if ( !ret )\n            ret = domain_set_node_affinity(d, &new_affinity);\n        break;\n    }\n\n    case XEN_DOMCTL_getnodeaffinity:\n        ret = nodemask_to_xenctl_bitmap(&op->u.nodeaffinity.nodemap,\n                                        &d->node_affinity);\n        break;\n\n    case XEN_DOMCTL_setvcpuaffinity:\n    case XEN_DOMCTL_getvcpuaffinity:\n    {\n        struct vcpu *v;\n        const struct sched_unit *unit;\n        struct xen_domctl_vcpuaffinity *vcpuaff = &op->u.vcpuaffinity;\n\n        ret = -EINVAL;\n        if ( vcpuaff->vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[vcpuaff->vcpu]) == NULL )\n            break;\n\n        unit = v->sched_unit;\n        ret = -EINVAL;\n        if ( vcpuaffinity_params_invalid(vcpuaff) )\n            break;\n\n        if ( op->cmd == XEN_DOMCTL_setvcpuaffinity )\n        {\n            cpumask_var_t new_affinity, old_affinity;\n            cpumask_t *online = cpupool_domain_master_cpumask(v->domain);\n\n            /*\n             * We want to be able to restore hard affinity if we are trying\n             * setting both and changing soft affinity (which happens later,\n             * when hard affinity has been succesfully chaged already) fails.\n             */\n            if ( !alloc_cpumask_var(&old_affinity) )\n            {\n                ret = -ENOMEM;\n                break;\n            }\n            cpumask_copy(old_affinity, unit->cpu_hard_affinity);\n\n            if ( !alloc_cpumask_var(&new_affinity) )\n            {\n                free_cpumask_var(old_affinity);\n                ret = -ENOMEM;\n                break;\n            }\n\n            /* Undo a stuck SCHED_pin_override? */\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_FORCE )\n                vcpu_temporary_affinity(v, NR_CPUS, VCPU_AFFINITY_OVERRIDE);\n\n            ret = 0;\n\n            /*\n             * We both set a new affinity and report back to the caller what\n             * the scheduler will be effectively using.\n             */\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_hard,\n                                              nr_cpu_ids);\n                if ( !ret )\n                    ret = vcpu_set_hard_affinity(v, new_affinity);\n                if ( ret )\n                    goto setvcpuaffinity_out;\n\n                /*\n                 * For hard affinity, what we return is the intersection of\n                 * cpupool's online mask and the new hard affinity.\n                 */\n                cpumask_and(new_affinity, online, unit->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               new_affinity);\n            }\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_soft,\n                                              nr_cpu_ids);\n                if ( !ret)\n                    ret = vcpu_set_soft_affinity(v, new_affinity);\n                if ( ret )\n                {\n                    /*\n                     * Since we're returning error, the caller expects nothing\n                     * happened, so we rollback the changes to hard affinity\n                     * (if any).\n                     */\n                    if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                        vcpu_set_hard_affinity(v, old_affinity);\n                    goto setvcpuaffinity_out;\n                }\n\n                /*\n                 * For soft affinity, we return the intersection between the\n                 * new soft affinity, the cpupool's online map and the (new)\n                 * hard affinity.\n                 */\n                cpumask_and(new_affinity, new_affinity, online);\n                cpumask_and(new_affinity, new_affinity,\n                            unit->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               new_affinity);\n            }\n\n setvcpuaffinity_out:\n            free_cpumask_var(new_affinity);\n            free_cpumask_var(old_affinity);\n        }\n        else\n        {\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               unit->cpu_hard_affinity);\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               unit->cpu_soft_affinity);\n        }\n        break;\n    }\n\n    case XEN_DOMCTL_scheduler_op:\n        ret = sched_adjust(d, &op->u.scheduler_op);\n        copyback = 1;\n        break;\n\n    case XEN_DOMCTL_getdomaininfo:\n    {\n        domid_t dom = DOMID_INVALID;\n\n        if ( !d )\n        {\n            ret = -EINVAL;\n            if ( op->domain >= DOMID_FIRST_RESERVED )\n                break;\n\n            rcu_read_lock(&domlist_read_lock);\n\n            dom = op->domain;\n            for_each_domain ( d )\n                if ( d->domain_id >= dom )\n                    break;\n        }\n\n        ret = -ESRCH;\n        if ( d == NULL )\n            goto getdomaininfo_out;\n\n        ret = xsm_getdomaininfo(XSM_HOOK, d);\n        if ( ret )\n            goto getdomaininfo_out;\n\n        getdomaininfo(d, &op->u.getdomaininfo);\n\n        op->domain = op->u.getdomaininfo.domain;\n        copyback = 1;\n\n    getdomaininfo_out:\n        /* When d was non-NULL upon entry, no cleanup is needed. */\n        if ( dom == DOMID_INVALID )\n            break;\n\n        rcu_read_unlock(&domlist_read_lock);\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        struct vcpu         *v;\n\n        ret = -EINVAL;\n        if ( op->u.vcpucontext.vcpu >= d->max_vcpus ||\n             (v = d->vcpu[op->u.vcpucontext.vcpu]) == NULL ||\n             v == current ) /* no vcpu_pause() */\n            goto getvcpucontext_out;\n\n        ret = -ENODATA;\n        if ( !v->is_initialised )\n            goto getvcpucontext_out;\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = xzalloc(struct vcpu_guest_context)) == NULL )\n            goto getvcpucontext_out;\n\n        vcpu_pause(v);\n\n        arch_get_info_guest(v, c);\n        ret = 0;\n\n        vcpu_unpause(v);\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32bit_domain(d) )\n            ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n        else\n            ret = copy_to_guest(guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                  void), c.cmp, 1);\n#else\n        ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n#endif\n\n        if ( ret )\n            ret = -EFAULT;\n        copyback = 1;\n\n    getvcpucontext_out:\n        xfree(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpuinfo:\n    {\n        struct vcpu   *v;\n        struct vcpu_runstate_info runstate;\n\n        ret = -EINVAL;\n        if ( op->u.getvcpuinfo.vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[op->u.getvcpuinfo.vcpu]) == NULL )\n            break;\n\n        vcpu_runstate_get(v, &runstate);\n\n        op->u.getvcpuinfo.online   = !(v->pause_flags & VPF_down);\n        op->u.getvcpuinfo.blocked  = !!(v->pause_flags & VPF_blocked);\n        op->u.getvcpuinfo.running  = v->is_running;\n        op->u.getvcpuinfo.cpu_time = runstate.time[RUNSTATE_running];\n        op->u.getvcpuinfo.cpu      = v->processor;\n        ret = 0;\n        copyback = 1;\n        break;\n    }\n\n    case XEN_DOMCTL_max_mem:\n    {\n        uint64_t new_max = op->u.max_mem.max_memkb >> (PAGE_SHIFT - 10);\n\n        spin_lock(&d->page_alloc_lock);\n        /*\n         * NB. We removed a check that new_max >= current tot_pages; this means\n         * that the domain will now be allowed to \""ratchet\"" down to new_max. In\n         * the meantime, while tot > max, all new allocations are disallowed.\n         */\n        d->max_pages = min(new_max, (uint64_t)(typeof(d->max_pages))-1);\n        spin_unlock(&d->page_alloc_lock);\n        break;\n    }\n\n    case XEN_DOMCTL_setdomainhandle:\n        memcpy(d->handle, op->u.setdomainhandle.handle,\n               sizeof(xen_domain_handle_t));\n        break;\n\n    case XEN_DOMCTL_setdebugging:\n        if ( unlikely(d == current->domain) ) /* no domain_pause() */\n            ret = -EINVAL;\n        else\n        {\n            domain_pause(d);\n            d->debugger_attached = !!op->u.setdebugging.enable;\n            domain_unpause(d); /* causes guest to latch new status */\n        }\n        break;\n\n    case XEN_DOMCTL_irq_permission:\n    {\n        unsigned int pirq = op->u.irq_permission.pirq, irq;\n        int allow = op->u.irq_permission.allow_access;\n\n        if ( pirq >= current->domain->nr_pirqs )\n        {\n            ret = -EINVAL;\n            break;\n        }\n        irq = pirq_access_permitted(current->domain, pirq);\n        if ( !irq || xsm_irq_permission(XSM_HOOK, d, irq, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = irq_permit_access(d, irq);\n        else\n            ret = irq_deny_access(d, irq);\n        break;\n    }\n\n    case XEN_DOMCTL_iomem_permission:\n    {\n        unsigned long mfn = op->u.iomem_permission.first_mfn;\n        unsigned long nr_mfns = op->u.iomem_permission.nr_mfns;\n        int allow = op->u.iomem_permission.allow_access;\n\n        ret = -EINVAL;\n        if ( (mfn + nr_mfns - 1) < mfn ) /* wrap? */\n            break;\n\n        if ( !iomem_access_permitted(current->domain,\n                                     mfn, mfn + nr_mfns - 1) ||\n             xsm_iomem_permission(XSM_HOOK, d, mfn, mfn + nr_mfns - 1, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = iomem_permit_access(d, mfn, mfn + nr_mfns - 1);\n        else\n            ret = iomem_deny_access(d, mfn, mfn + nr_mfns - 1);\n        if ( !ret )\n            memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_memory_mapping:\n    {\n        unsigned long gfn = op->u.memory_mapping.first_gfn;\n        unsigned long mfn = op->u.memory_mapping.first_mfn;\n        unsigned long nr_mfns = op->u.memory_mapping.nr_mfns;\n        unsigned long mfn_end = mfn + nr_mfns - 1;\n        int add = op->u.memory_mapping.add_mapping;\n\n        ret = -EINVAL;\n        if ( mfn_end < mfn || /* wrap? */\n             ((mfn | mfn_end) >> (paddr_bits - PAGE_SHIFT)) ||\n             (gfn + nr_mfns - 1) < gfn ) /* wrap? */\n            break;\n\n#ifndef CONFIG_X86 /* XXX ARM!? */\n        ret = -E2BIG;\n        /* Must break hypercall up as this could take a while. */\n        if ( nr_mfns > 64 )\n            break;\n#endif\n\n        ret = -EPERM;\n        if ( !iomem_access_permitted(current->domain, mfn, mfn_end) ||\n             !iomem_access_permitted(d, mfn, mfn_end) )\n            break;\n\n        ret = xsm_iomem_mapping(XSM_HOOK, d, mfn, mfn_end, add);\n        if ( ret )\n            break;\n\n        if ( add )\n        {\n            printk(XENLOG_G_DEBUG\n                   \""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\\n\"",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = map_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));\n            if ( ret < 0 )\n                printk(XENLOG_G_WARNING\n                       \""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\\n\"",\n                       d->domain_id, gfn, mfn, nr_mfns, ret);\n        }\n        else\n        {\n            printk(XENLOG_G_DEBUG\n                   \""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\\n\"",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = unmap_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));\n            if ( ret < 0 && is_hardware_domain(current->domain) )\n                printk(XENLOG_ERR\n                       \""memory_map: error %ld removing dom%d access to [%lx,%lx]\\n\"",\n                       ret, d->domain_id, mfn, mfn_end);\n        }\n        /* Do this unconditionally to cover errors on above failure paths. */\n        memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_settimeoffset:\n        domain_set_time_offset(d, op->u.settimeoffset.time_offset_seconds);\n        break;\n\n    case XEN_DOMCTL_set_target:\n    {\n        struct domain *e;\n\n        ret = -ESRCH;\n        e = get_domain_by_id(op->u.set_target.target);\n        if ( e == NULL )\n            break;\n\n        ret = -EINVAL;\n        if ( (d == e) || (d->target != NULL) )\n        {\n            put_domain(e);\n            break;\n        }\n\n        ret = -EOPNOTSUPP;\n        if ( is_hvm_domain(e) )\n            ret = xsm_set_target(XSM_HOOK, d, e);\n        if ( ret )\n        {\n            put_domain(e);\n            break;\n        }\n\n        /* Hold reference on @e until we destroy @d. */\n        d->target = e;\n        break;\n    }\n\n    case XEN_DOMCTL_subscribe:\n        d->suspend_evtchn = op->u.subscribe.port;\n        break;\n\n    case XEN_DOMCTL_vm_event_op:\n        ret = vm_event_domctl(d, &op->u.vm_event_op);\n        if ( ret == 0 )\n            copyback = true;\n        break;\n\n#ifdef CONFIG_MEM_ACCESS\n    case XEN_DOMCTL_set_access_required:\n        if ( unlikely(current->domain == d) ) /* no domain_pause() */\n            ret = -EPERM;\n        else\n        {\n            domain_pause(d);\n            arch_p2m_set_access_required(d,\n                op->u.access_required.access_required);\n            domain_unpause(d);\n        }\n        break;\n#endif\n\n    case XEN_DOMCTL_set_virq_handler:\n        ret = set_global_virq_handler(d, op->u.set_virq_handler.virq);\n        break;\n\n    case XEN_DOMCTL_setvnumainfo:\n    {\n        struct vnuma_info *vnuma;\n\n        vnuma = vnuma_init(&op->u.vnuma, d);\n        if ( IS_ERR(vnuma) )\n        {\n            ret = PTR_ERR(vnuma);\n            break;\n        }\n\n        /* overwrite vnuma topology for domain. */\n        write_lock(&d->vnuma_rwlock);\n        vnuma_destroy(d->vnuma);\n        d->vnuma = vnuma;\n        write_unlock(&d->vnuma_rwlock);\n\n        break;\n    }\n\n    case XEN_DOMCTL_monitor_op:\n        ret = monitor_domctl(d, &op->u.monitor_op);\n        if ( !ret )\n            copyback = 1;\n        break;\n\n    default:\n        ret = arch_do_domctl(op, d, u_domctl);\n        break;\n    }\n\n    domctl_lock_release();\n\n domctl_out_unlock_domonly:\n    if ( d )\n        rcu_unlock_domain(d);\n\n    if ( copyback && __copy_to_guest(u_domctl, op, 1) )\n        ret = -EFAULT;\n\n    return ret;\n}"", ""target"": 0}, {""func_name"": ""deassign_device"", ""file_path"": ""xen/drivers/passthrough/pci.c"", ""func_code"": ""static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus,\n                           uint8_t devfn)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return -EINVAL;\n\n    ASSERT(pcidevs_locked());\n    pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);\n    if ( !pdev )\n        return -ENODEV;\n\n    while ( pdev->phantom_stride )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,\n                                                pci_to_dev(pdev));\n        if ( !ret )\n            continue;\n\n        printk(XENLOG_G_ERR \""%pd: deassign %04x:%02x:%02x.%u failed (%d)\\n\"",\n               d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret);\n        return ret;\n    }\n\n    devfn = pdev->devfn;\n    ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,\n                                            pci_to_dev(pdev));\n    if ( ret )\n    {\n        dprintk(XENLOG_G_ERR,\n                \""%pd: deassign device (%04x:%02x:%02x.%u) failed\\n\"",\n                d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n        return ret;\n    }\n\n    pdev->fault.count = 0;\n\n    return ret;\n}"", ""target"": 0}, {""func_name"": ""assign_device"", ""file_path"": ""xen/drivers/passthrough/pci.c"", ""func_code"": ""static int assign_device(struct domain *d, u16 seg, u8 bus, u8 devfn, u32 flag)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    int rc = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n    /* Prevent device assign if mem paging or mem sharing have been \n     * enabled for this domain */\n    if ( unlikely((is_hvm_domain(d) &&\n                   d->arch.hvm.mem_sharing_enabled) ||\n                  vm_event_check_ring(d->vm_event_paging) ||\n                  p2m_get_hostp2m(d)->global_logdirty) )\n        return -EXDEV;\n\n    if ( !pcidevs_trylock() )\n        return -ERESTART;\n\n    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);\n    if ( !pdev )\n    {\n        rc = pci_get_pdev(seg, bus, devfn) ? -EBUSY : -ENODEV;\n        goto done;\n    }\n\n    if ( pdev->msix )\n    {\n        rc = pci_reset_msix_state(pdev);\n        if ( rc )\n            goto done;\n        msixtbl_init(d);\n    }\n\n    pdev->fault.count = 0;\n\n    if ( (rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag)) )\n        goto done;\n\n    for ( ; pdev->phantom_stride; rc = 0 )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag);\n        if ( rc )\n            printk(XENLOG_G_WARNING \""d%d: assign %04x:%02x:%02x.%u failed (%d)\\n\"",\n                   d->domain_id, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   rc);\n    }\n\n done:\n    pcidevs_unlock();\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""device_assigned"", ""file_path"": ""xen/drivers/passthrough/pci.c"", ""func_code"": ""static int device_assigned(u16 seg, u8 bus, u8 devfn)\n{\n    struct pci_dev *pdev;\n\n    pcidevs_lock();\n    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);\n    pcidevs_unlock();\n\n    return pdev ? 0 : -EBUSY;\n}"", ""target"": 0}, {""func_name"": ""iommu_do_pci_domctl"", ""file_path"": ""xen/drivers/passthrough/pci.c"", ""func_code"": ""int iommu_do_pci_domctl(\n    struct xen_domctl *domctl, struct domain *d,\n    XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    u16 seg;\n    u8 bus, devfn;\n    int ret = 0;\n    uint32_t machine_sbdf;\n\n    switch ( domctl->cmd )\n    {\n        unsigned int flags;\n\n    case XEN_DOMCTL_get_device_group:\n    {\n        u32 max_sdevs;\n        XEN_GUEST_HANDLE_64(uint32) sdevs;\n\n        ret = xsm_get_device_group(XSM_HOOK, domctl->u.get_device_group.machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = domctl->u.get_device_group.machine_sbdf >> 16;\n        bus = PCI_BUS(domctl->u.get_device_group.machine_sbdf);\n        devfn = PCI_DEVFN2(domctl->u.get_device_group.machine_sbdf);\n        max_sdevs = domctl->u.get_device_group.max_sdevs;\n        sdevs = domctl->u.get_device_group.sdev_array;\n\n        ret = iommu_get_device_group(d, seg, bus, devfn, sdevs, max_sdevs);\n        if ( ret < 0 )\n        {\n            dprintk(XENLOG_ERR, \""iommu_get_device_group() failed!\\n\"");\n            ret = -EFAULT;\n            domctl->u.get_device_group.num_sdevs = 0;\n        }\n        else\n        {\n            domctl->u.get_device_group.num_sdevs = ret;\n            ret = 0;\n        }\n        if ( __copy_field_to_guest(u_domctl, domctl, u.get_device_group) )\n            ret = -EFAULT;\n    }\n    break;\n\n    case XEN_DOMCTL_assign_device:\n        ASSERT(d);\n        /* fall through */\n    case XEN_DOMCTL_test_assign_device:\n        /* Don't support self-assignment of devices. */\n        if ( d == current->domain )\n        {\n            ret = -EINVAL;\n            break;\n        }\n\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )\n            break;\n\n        ret = -EINVAL;\n        flags = domctl->u.assign_device.flags;\n        if ( domctl->cmd == XEN_DOMCTL_assign_device\n             ? d->is_dying || (flags & ~XEN_DOMCTL_DEV_RDM_RELAXED)\n             : flags )\n            break;\n\n        machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;\n\n        ret = xsm_assign_device(XSM_HOOK, d, machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = machine_sbdf >> 16;\n        bus = PCI_BUS(machine_sbdf);\n        devfn = PCI_DEVFN2(machine_sbdf);\n\n        ret = device_assigned(seg, bus, devfn);\n        if ( domctl->cmd == XEN_DOMCTL_test_assign_device )\n        {\n            if ( ret )\n            {\n                printk(XENLOG_G_INFO\n                       \""%04x:%02x:%02x.%u already assigned, or non-existent\\n\"",\n                       seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n                ret = -EINVAL;\n            }\n            break;\n        }\n        if ( !ret )\n            ret = assign_device(d, seg, bus, devfn, flags);\n        if ( ret == -ERESTART )\n            ret = hypercall_create_continuation(__HYPERVISOR_domctl,\n                                                \""h\"", u_domctl);\n        else if ( ret )\n            printk(XENLOG_G_ERR \""XEN_DOMCTL_assign_device: \""\n                   \""assign %04x:%02x:%02x.%u to dom%d failed (%d)\\n\"",\n                   seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   d->domain_id, ret);\n\n        break;\n\n    case XEN_DOMCTL_deassign_device:\n        /* Don't support self-deassignment of devices. */\n        if ( d == current->domain )\n        {\n            ret = -EINVAL;\n            break;\n        }\n\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )\n            break;\n\n        ret = -EINVAL;\n        if ( domctl->u.assign_device.flags )\n            break;\n\n        machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;\n\n        ret = xsm_deassign_device(XSM_HOOK, d, machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = machine_sbdf >> 16;\n        bus = PCI_BUS(machine_sbdf);\n        devfn = PCI_DEVFN2(machine_sbdf);\n\n        pcidevs_lock();\n        ret = deassign_device(d, seg, bus, devfn);\n        pcidevs_unlock();\n        if ( ret )\n            printk(XENLOG_G_ERR\n                   \""deassign %04x:%02x:%02x.%u from dom%d failed (%d)\\n\"",\n                   seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   d->domain_id, ret);\n\n        break;\n\n    default:\n        ret = -ENOSYS;\n        break;\n    }\n\n    return ret;\n}"", ""target"": 0}, {""func_name"": ""iommu_setup"", ""file_path"": ""xen/drivers/passthrough/vtd/iommu.c"", ""func_code"": ""int __init iommu_setup(void)\n{\n    int rc = -ENODEV;\n    bool_t force_intremap = force_iommu && iommu_intremap;\n\n    if ( iommu_hwdom_strict )\n        iommu_hwdom_passthrough = false;\n\n    if ( iommu_enable )\n    {\n        rc = iommu_hardware_setup();\n        iommu_enabled = (rc == 0);\n    }\n    if ( !iommu_enabled )\n        iommu_intremap = 0;\n\n    if ( (force_iommu && !iommu_enabled) ||\n         (force_intremap && !iommu_intremap) )\n        panic(\""Couldn't enable %s and iommu=required/force\\n\"",\n              !iommu_enabled ? \""IOMMU\"" : \""Interrupt Remapping\"");\n\n    if ( !iommu_intremap )\n        iommu_intpost = 0;\n\n    printk(\""I/O virtualisation %sabled\\n\"", iommu_enabled ? \""en\"" : \""dis\"");\n    if ( !iommu_enabled )\n    {\n        iommu_snoop = 0;\n        iommu_hwdom_passthrough = false;\n        iommu_hwdom_strict = false;\n    }\n    else\n    {\n        printk(\"" - Dom0 mode: %s\\n\"",\n               iommu_hwdom_passthrough ? \""Passthrough\"" :\n               iommu_hwdom_strict ? \""Strict\"" : \""Relaxed\"");\n        printk(\""Interrupt remapping %sabled\\n\"", iommu_intremap ? \""en\"" : \""dis\"");\n        tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);\n    }\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""iommu_domain_init"", ""file_path"": ""xen/drivers/passthrough/vtd/iommu.c"", ""func_code"": ""int iommu_domain_init(struct domain *d, unsigned int opts)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n#ifdef CONFIG_NUMA\n    hd->node = NUMA_NO_NODE;\n#endif\n\n    ret = arch_iommu_domain_init(d);\n    if ( ret )\n        return ret;\n\n    hd->platform_ops = iommu_get_ops();\n    ret = hd->platform_ops->init(d);\n    if ( ret )\n        return ret;\n\n    if ( is_hardware_domain(d) )\n        check_hwdom_reqs(d); /* may modify iommu_hwdom_strict */\n\n    /*\n     * Use shared page tables for HAP and IOMMU if the global option\n     * is enabled (from which we can infer the h/w is capable) and\n     * the domain options do not disallow it. HAP must, of course, also\n     * be enabled.\n     */\n    hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&\n        !(opts & XEN_DOMCTL_IOMMU_no_sharept);\n\n    /*\n     * NB: 'relaxed' h/w domains don't need the IOMMU mappings to be kept\n     *     in-sync with their assigned pages because all host RAM will be\n     *     mapped during hwdom_init().\n     */\n    if ( !is_hardware_domain(d) || iommu_hwdom_strict )\n        hd->need_sync = !iommu_use_hap_pt(d);\n\n    ASSERT(!(hd->need_sync && hd->hap_pt_share));\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""iommu_setup"", ""file_path"": ""xen/drivers/passthrough/iommu.c"", ""func_code"": ""int __init iommu_setup(void)\n{\n    int rc = -ENODEV;\n    bool_t force_intremap = force_iommu && iommu_intremap;\n\n    if ( iommu_hwdom_strict )\n        iommu_hwdom_passthrough = false;\n\n    if ( iommu_enable )\n    {\n        rc = iommu_hardware_setup();\n        iommu_enabled = (rc == 0);\n    }\n    if ( !iommu_enabled )\n        iommu_intremap = 0;\n\n    if ( (force_iommu && !iommu_enabled) ||\n         (force_intremap && !iommu_intremap) )\n        panic(\""Couldn't enable %s and iommu=required/force\\n\"",\n              !iommu_enabled ? \""IOMMU\"" : \""Interrupt Remapping\"");\n\n    if ( !iommu_intremap )\n        iommu_intpost = 0;\n\n    printk(\""I/O virtualisation %sabled\\n\"", iommu_enabled ? \""en\"" : \""dis\"");\n    if ( !iommu_enabled )\n    {\n        iommu_snoop = 0;\n        iommu_hwdom_passthrough = false;\n        iommu_hwdom_strict = false;\n    }\n    else\n    {\n        dom_io->options |= XEN_DOMCTL_CDF_iommu;\n        if ( iommu_domain_init(dom_io, 0) )\n            panic(\""Could not set up quarantine\\n\"");\n\n        printk(\"" - Dom0 mode: %s\\n\"",\n               iommu_hwdom_passthrough ? \""Passthrough\"" :\n               iommu_hwdom_strict ? \""Strict\"" : \""Relaxed\"");\n        printk(\""Interrupt remapping %sabled\\n\"", iommu_intremap ? \""en\"" : \""dis\"");\n        tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);\n    }\n\n    return rc;\n}""}, {""func_name"": ""iommu_domain_init"", ""file_path"": ""xen/drivers/passthrough/iommu.c"", ""func_code"": ""int iommu_domain_init(struct domain *d, unsigned int opts)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n#ifdef CONFIG_NUMA\n    hd->node = NUMA_NO_NODE;\n#endif\n\n    ret = arch_iommu_domain_init(d);\n    if ( ret )\n        return ret;\n\n    hd->platform_ops = iommu_get_ops();\n    ret = hd->platform_ops->init(d);\n    if ( ret || is_system_domain(d) )\n        return ret;\n\n    if ( is_hardware_domain(d) )\n        check_hwdom_reqs(d); /* may modify iommu_hwdom_strict */\n\n    /*\n     * Use shared page tables for HAP and IOMMU if the global option\n     * is enabled (from which we can infer the h/w is capable) and\n     * the domain options do not disallow it. HAP must, of course, also\n     * be enabled.\n     */\n    hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&\n        !(opts & XEN_DOMCTL_IOMMU_no_sharept);\n\n    /*\n     * NB: 'relaxed' h/w domains don't need the IOMMU mappings to be kept\n     *     in-sync with their assigned pages because all host RAM will be\n     *     mapped during hwdom_init().\n     */\n    if ( !is_hardware_domain(d) || iommu_hwdom_strict )\n        hd->need_sync = !iommu_use_hap_pt(d);\n\n    ASSERT(!(hd->need_sync && hd->hap_pt_share));\n\n    return 0;\n}""}, {""func_name"": ""setup_system_domains"", ""file_path"": ""xen/common/domain.c"", ""func_code"": ""void __init setup_system_domains(void)\n{\n    /*\n     * Initialise our DOMID_XEN domain.\n     * Any Xen-heap pages that we will allow to be mapped will have\n     * their domain field set to dom_xen.\n     * Hidden PCI devices will also be associated with this domain\n     * (but be [partly] controlled by Dom0 nevertheless).\n     */\n    dom_xen = domain_create(DOMID_XEN, NULL, false);\n    if ( IS_ERR(dom_xen) )\n        panic(\""Failed to create d[XEN]: %ld\\n\"", PTR_ERR(dom_xen));\n\n    /*\n     * Initialise our DOMID_IO domain.\n     * This domain owns I/O pages that are within the range of the page_info\n     * array. Mappings occur at the priv of the caller.\n     * Quarantined PCI devices will be associated with this domain.\n     */\n    dom_io = domain_create(DOMID_IO, NULL, false);\n    if ( IS_ERR(dom_io) )\n        panic(\""Failed to create d[IO]: %ld\\n\"", PTR_ERR(dom_io));\n\n#ifdef CONFIG_MEM_SHARING\n    /*\n     * Initialise our COW domain.\n     * This domain owns sharable pages.\n     */\n    dom_cow = domain_create(DOMID_COW, NULL, false);\n    if ( IS_ERR(dom_cow) )\n        panic(\""Failed to create d[COW]: %ld\\n\"", PTR_ERR(dom_cow));\n#endif\n}""}, {""func_name"": ""amd_iommu_setup_domain_device"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static void amd_iommu_setup_domain_device(\n    struct domain *domain, struct amd_iommu *iommu,\n    uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id, valid = 1;\n    u8 bus = pdev->bus;\n    const struct domain_iommu *hd = dom_iommu(domain);\n\n    /* dom_io is used as a sentinel for quarantined devices */\n    if ( domain == dom_io )\n        return;\n\n    BUG_ON( !hd->arch.root_table || !hd->arch.paging_mode ||\n            !iommu->dev_table.buffer );\n\n    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )\n        valid = 0;\n\n    /* get device-table entry */\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n\n    if ( !dte->v || !dte->tv )\n    {\n        /* bind DTE to domain page-tables */\n        amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.root_table), domain->domain_id,\n            hd->arch.paging_mode, valid);\n\n        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )\n            dte->i = ats_enabled;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\""Setup I/O page table: device id = %#x, type = %#x, \""\n                        \""root table = %#\""PRIx64\"", \""\n                        \""domain = %d, paging mode = %d\\n\"",\n                        req_id, pdev->type,\n                        page_to_maddr(hd->arch.root_table),\n                        domain->domain_id, hd->arch.paging_mode);\n    }\n\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )\n    {\n        if ( devfn == pdev->devfn )\n            enable_ats_device(pdev, &iommu->ats_devices);\n\n        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);\n    }\n}""}, {""func_name"": ""amd_iommu_disable_domain_device"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static void amd_iommu_disable_domain_device(const struct domain *domain,\n                                            struct amd_iommu *iommu,\n                                            uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id;\n    u8 bus = pdev->bus;\n\n    /* dom_io is used as a sentinel for quarantined devices */\n    if ( domain == dom_io )\n        return;\n\n    BUG_ON ( iommu->dev_table.buffer == NULL );\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n    if ( dte->tv || dte->v )\n    {\n        /* See the comment in amd_iommu_setup_device_table(). */\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_ABORTED;\n        smp_wmb();\n        dte->iv = true;\n        dte->tv = false;\n        dte->gv = false;\n        dte->i = false;\n        dte->ex = false;\n        dte->sa = false;\n        dte->se = false;\n        dte->sd = false;\n        dte->sys_mgt = IOMMU_DEV_TABLE_SYS_MGT_DMA_ABORTED;\n        dte->ioctl = IOMMU_DEV_TABLE_IO_CONTROL_ABORTED;\n        smp_wmb();\n        dte->v = true;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\""Disable: device id = %#x, \""\n                        \""domain = %d, paging mode = %d\\n\"",\n                        req_id,  domain->domain_id,\n                        dom_iommu(domain)->arch.paging_mode);\n    }\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( devfn == pdev->devfn &&\n         pci_ats_device(iommu->seg, bus, devfn) &&\n         pci_ats_enabled(iommu->seg, bus, devfn) )\n        disable_ats_device(pdev);\n}""}, {""func_name"": ""amd_iommu_assign_device"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static int amd_iommu_assign_device(struct domain *d, u8 devfn,\n                                   struct pci_dev *pdev,\n                                   u32 flag)\n{\n    struct ivrs_mappings *ivrs_mappings = get_ivrs_mappings(pdev->seg);\n    int bdf = PCI_BDF2(pdev->bus, devfn);\n    int req_id = get_dma_requestor_id(pdev->seg, bdf);\n\n    if ( ivrs_mappings[req_id].unity_map_enable )\n    {\n        amd_iommu_reserve_domain_unity_map(\n            d,\n            ivrs_mappings[req_id].addr_range_start,\n            ivrs_mappings[req_id].addr_range_length,\n            ivrs_mappings[req_id].write_permission,\n            ivrs_mappings[req_id].read_permission);\n    }\n\n    return reassign_device(pdev->domain, d, devfn, pdev);\n}""}, {""func_name"": ""libxl__device_pci_assignable_remove"", ""file_path"": ""tools/libxl/libxl_pci.c"", ""func_code"": ""static int libxl__device_pci_assignable_remove(libxl__gc *gc,\n                                               libxl_device_pci *pcidev,\n                                               int rebind)\n{\n    libxl_ctx *ctx = libxl__gc_owner(gc);\n    int rc;\n    char *driver_path;\n\n    /* De-quarantine */\n    rc = xc_deassign_device(ctx->xch, DOMID_IO, pcidev_encode_bdf(pcidev));\n    if ( rc < 0 ) {\n        LOG(ERROR, \""failed to de-quarantine \""PCI_BDF, pcidev->domain, pcidev->bus,\n            pcidev->dev, pcidev->func);\n        return ERROR_FAIL;\n    }\n\n    /* Unbind from pciback */\n    if ( (rc=pciback_dev_is_assigned(gc, pcidev)) < 0 ) {\n        return ERROR_FAIL;\n    } else if ( rc ) {\n        pciback_dev_unassign(gc, pcidev);\n    } else {\n        LOG(WARN, \""Not bound to pciback\"");\n    }\n\n    /* Rebind if necessary */\n    driver_path = pci_assignable_driver_path_read(gc, pcidev);\n\n    if ( driver_path ) {\n        if ( rebind ) {\n            LOG(INFO, \""Rebinding to driver at %s\"", driver_path);\n\n            if ( sysfs_write_bdf(gc,\n                                 GCSPRINTF(\""%s/bind\"", driver_path),\n                                 pcidev) < 0 ) {\n                LOGE(ERROR, \""Couldn't bind device to %s\"", driver_path);\n                return -1;\n            }\n\n            pci_assignable_driver_path_remove(gc, pcidev);\n        }\n    } else {\n        if ( rebind ) {\n            LOG(WARN,\n                \""Couldn't find path for original driver; not rebinding\"");\n        }\n    }\n\n    return 0;\n}""}, {""func_name"": ""libxl__device_pci_assignable_add"", ""file_path"": ""tools/libxl/libxl_pci.c"", ""func_code"": ""static int libxl__device_pci_assignable_add(libxl__gc *gc,\n                                            libxl_device_pci *pcidev,\n                                            int rebind)\n{\n    libxl_ctx *ctx = libxl__gc_owner(gc);\n    unsigned dom, bus, dev, func;\n    char *spath, *driver_path = NULL;\n    int rc;\n    struct stat st;\n\n    /* Local copy for convenience */\n    dom = pcidev->domain;\n    bus = pcidev->bus;\n    dev = pcidev->dev;\n    func = pcidev->func;\n\n    /* See if the device exists */\n    spath = GCSPRINTF(SYSFS_PCI_DEV\""/\""PCI_BDF, dom, bus, dev, func);\n    if ( lstat(spath, &st) ) {\n        LOGE(ERROR, \""Couldn't lstat %s\"", spath);\n        return ERROR_FAIL;\n    }""}, {""func_name"": ""iommu_do_dt_domctl"", ""file_path"": ""xen/drivers/passthrough/device_tree.c"", ""func_code"": ""int iommu_do_dt_domctl(struct xen_domctl *domctl, struct domain *d,\n                       XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    int ret;\n    struct dt_device_node *dev;\n\n    switch ( domctl->cmd )\n    {\n    case XEN_DOMCTL_assign_device:\n        ASSERT(d);\n        /* fall through */\n    case XEN_DOMCTL_test_assign_device:\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )\n            break;\n\n        ret = -EINVAL;\n        if ( (d && d->is_dying) || domctl->u.assign_device.flags )\n            break;\n\n        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,\n                                    domctl->u.assign_device.u.dt.size,\n                                    &dev);\n        if ( ret )\n            break;\n\n        ret = xsm_assign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));\n        if ( ret )\n            break;\n\n        if ( domctl->cmd == XEN_DOMCTL_test_assign_device )\n        {\n            if ( iommu_dt_device_is_assigned(dev) )\n            {\n                printk(XENLOG_G_ERR \""%s already assigned.\\n\"",\n                       dt_node_full_name(dev));\n                ret = -EINVAL;\n            }\n            break;\n        }\n\n        if ( d == dom_io )\n            return -EINVAL;\n\n        ret = iommu_add_dt_device(dev);\n        /*\n         * Ignore \""-EEXIST\"" error code as it would mean that the device is\n         * already added to the IOMMU (positive result). Such happens after\n         * re-creating guest domain.\n         */\n        if ( ret < 0 && ret != -EEXIST )\n        {\n            printk(XENLOG_G_ERR \""Failed to add %s to the IOMMU\\n\"",\n                   dt_node_full_name(dev));\n            break;\n        }\n\n        ret = iommu_assign_dt_device(d, dev);\n\n        if ( ret )\n            printk(XENLOG_G_ERR \""XEN_DOMCTL_assign_dt_device: assign \\\""%s\\\""\""\n                   \"" to dom%u failed (%d)\\n\"",\n                   dt_node_full_name(dev), d->domain_id, ret);\n        break;\n\n    case XEN_DOMCTL_deassign_device:\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )\n            break;\n\n        ret = -EINVAL;\n        if ( domctl->u.assign_device.flags )\n            break;\n\n        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,\n                                    domctl->u.assign_device.u.dt.size,\n                                    &dev);\n        if ( ret )\n            break;\n\n        ret = xsm_deassign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));\n\n        if ( d == dom_io )\n            return -EINVAL;\n\n        ret = iommu_deassign_dt_device(d, dev);\n\n        if ( ret )\n            printk(XENLOG_G_ERR \""XEN_DOMCTL_assign_dt_device: assign \\\""%s\\\""\""\n                   \"" to dom%u failed (%d)\\n\"",\n                   dt_node_full_name(dev), d->domain_id, ret);\n        break;\n\n    default:\n        ret = -ENOSYS;\n        break;\n    }\n\n    return ret;\n}""}, {""func_name"": ""do_domctl"", ""file_path"": ""xen/common/domctl.c"", ""func_code"": ""long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    long ret = 0;\n    bool_t copyback = 0;\n    struct xen_domctl curop, *op = &curop;\n    struct domain *d;\n\n    if ( copy_from_guest(op, u_domctl, 1) )\n        return -EFAULT;\n\n    if ( op->interface_version != XEN_DOMCTL_INTERFACE_VERSION )\n        return -EACCES;\n\n    switch ( op->cmd )\n    {\n    case XEN_DOMCTL_assign_device:\n    case XEN_DOMCTL_deassign_device:\n        if ( op->domain == DOMID_IO )\n        {\n            d = dom_io;\n            break;\n        }\n        else if ( op->domain == DOMID_INVALID )\n            return -ESRCH;\n        /* fall through */\n    case XEN_DOMCTL_test_assign_device:\n    case XEN_DOMCTL_vm_event_op:\n        if ( op->domain == DOMID_INVALID )\n        {\n    case XEN_DOMCTL_createdomain:\n    case XEN_DOMCTL_gdbsx_guestmemio:\n            d = NULL;\n            break;\n        }\n        /* fall through */\n    default:\n        d = rcu_lock_domain_by_id(op->domain);\n        if ( !d && op->cmd != XEN_DOMCTL_getdomaininfo )\n            return -ESRCH;\n    }\n\n    ret = xsm_domctl(XSM_OTHER, d, op->cmd);\n    if ( ret )\n        goto domctl_out_unlock_domonly;\n\n    if ( !domctl_lock_acquire() )\n    {\n        if ( d && d != dom_io )\n            rcu_unlock_domain(d);\n        return hypercall_create_continuation(\n            __HYPERVISOR_domctl, \""h\"", u_domctl);\n    }\n\n    switch ( op->cmd )\n    {\n\n    case XEN_DOMCTL_setvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        unsigned int vcpu = op->u.vcpucontext.vcpu;\n        struct vcpu *v;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (vcpu >= d->max_vcpus) || ((v = d->vcpu[vcpu]) == NULL) )\n            break;\n\n        if ( guest_handle_is_null(op->u.vcpucontext.ctxt) )\n        {\n            ret = vcpu_reset(v);\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \""h\"", u_domctl);\n            break;\n        }\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = alloc_vcpu_guest_context()) == NULL )\n            break;\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32bit_domain(d) )\n            ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n        else\n            ret = copy_from_guest(c.cmp,\n                                  guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                    void), 1);\n#else\n        ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n#endif\n        ret = ret ? -EFAULT : 0;\n\n        if ( ret == 0 )\n        {\n            domain_pause(d);\n            ret = arch_set_info_guest(v, c);\n            domain_unpause(d);\n\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \""h\"", u_domctl);\n        }\n\n        free_vcpu_guest_context(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_pausedomain:\n        ret = -EINVAL;\n        if ( d != current->domain )\n            ret = domain_pause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_unpausedomain:\n        ret = domain_unpause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_resumedomain:\n        if ( d == current->domain ) /* no domain_pause() */\n            ret = -EINVAL;\n        else\n            domain_resume(d);\n        break;\n\n    case XEN_DOMCTL_createdomain:\n    {\n        domid_t        dom;\n        static domid_t rover = 0;\n\n        dom = op->domain;\n        if ( (dom > 0) && (dom < DOMID_FIRST_RESERVED) )\n        {\n            ret = -EINVAL;\n            if ( !is_free_domid(dom) )\n                break;\n        }\n        else\n        {\n            for ( dom = rover + 1; dom != rover; dom++ )\n            {\n                if ( dom == DOMID_FIRST_RESERVED )\n                    dom = 1;\n                if ( is_free_domid(dom) )\n                    break;\n            }\n\n            ret = -ENOMEM;\n            if ( dom == rover )\n                break;\n\n            rover = dom;\n        }\n\n        d = domain_create(dom, &op->u.createdomain, false);\n        if ( IS_ERR(d) )\n        {\n            ret = PTR_ERR(d);\n            d = NULL;\n            break;\n        }\n\n        ret = 0;\n        op->domain = d->domain_id;\n        copyback = 1;\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_max_vcpus:\n    {\n        unsigned int i, max = op->u.max_vcpus.max;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (max != d->max_vcpus) )   /* max_vcpus set up in createdomain */\n            break;\n\n        /* Needed, for example, to ensure writable p.t. state is synced. */\n        domain_pause(d);\n\n        ret = -ENOMEM;\n\n        for ( i = 0; i < max; i++ )\n        {\n            if ( d->vcpu[i] != NULL )\n                continue;\n\n            if ( vcpu_create(d, i) == NULL )\n                goto maxvcpu_out;\n        }\n\n        domain_update_node_affinity(d);\n        ret = 0;\n\n    maxvcpu_out:\n        domain_unpause(d);\n        break;\n    }\n\n    case XEN_DOMCTL_soft_reset:\n        if ( d == current->domain ) /* no domain_pause() */\n        {\n            ret = -EINVAL;\n            break;\n        }\n        ret = domain_soft_reset(d);\n        break;\n\n    case XEN_DOMCTL_destroydomain:\n        domctl_lock_release();\n        domain_lock(d);\n        ret = domain_kill(d);\n        domain_unlock(d);\n        if ( ret == -ERESTART )\n            ret = hypercall_create_continuation(\n                __HYPERVISOR_domctl, \""h\"", u_domctl);\n        goto domctl_out_unlock_domonly;\n\n    case XEN_DOMCTL_setnodeaffinity:\n    {\n        nodemask_t new_affinity;\n\n        ret = xenctl_bitmap_to_nodemask(&new_affinity,\n                                        &op->u.nodeaffinity.nodemap);\n        if ( !ret )\n            ret = domain_set_node_affinity(d, &new_affinity);\n        break;\n    }\n\n    case XEN_DOMCTL_getnodeaffinity:\n        ret = nodemask_to_xenctl_bitmap(&op->u.nodeaffinity.nodemap,\n                                        &d->node_affinity);\n        break;\n\n    case XEN_DOMCTL_setvcpuaffinity:\n    case XEN_DOMCTL_getvcpuaffinity:\n    {\n        struct vcpu *v;\n        const struct sched_unit *unit;\n        struct xen_domctl_vcpuaffinity *vcpuaff = &op->u.vcpuaffinity;\n\n        ret = -EINVAL;\n        if ( vcpuaff->vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[vcpuaff->vcpu]) == NULL )\n            break;\n\n        unit = v->sched_unit;\n        ret = -EINVAL;\n        if ( vcpuaffinity_params_invalid(vcpuaff) )\n            break;\n\n        if ( op->cmd == XEN_DOMCTL_setvcpuaffinity )\n        {\n            cpumask_var_t new_affinity, old_affinity;\n            cpumask_t *online = cpupool_domain_master_cpumask(v->domain);\n\n            /*\n             * We want to be able to restore hard affinity if we are trying\n             * setting both and changing soft affinity (which happens later,\n             * when hard affinity has been succesfully chaged already) fails.\n             */\n            if ( !alloc_cpumask_var(&old_affinity) )\n            {\n                ret = -ENOMEM;\n                break;\n            }\n            cpumask_copy(old_affinity, unit->cpu_hard_affinity);\n\n            if ( !alloc_cpumask_var(&new_affinity) )\n            {\n                free_cpumask_var(old_affinity);\n                ret = -ENOMEM;\n                break;\n            }\n\n            /* Undo a stuck SCHED_pin_override? */\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_FORCE )\n                vcpu_temporary_affinity(v, NR_CPUS, VCPU_AFFINITY_OVERRIDE);\n\n            ret = 0;\n\n            /*\n             * We both set a new affinity and report back to the caller what\n             * the scheduler will be effectively using.\n             */\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_hard,\n                                              nr_cpu_ids);\n                if ( !ret )\n                    ret = vcpu_set_hard_affinity(v, new_affinity);\n                if ( ret )\n                    goto setvcpuaffinity_out;\n\n                /*\n                 * For hard affinity, what we return is the intersection of\n                 * cpupool's online mask and the new hard affinity.\n                 */\n                cpumask_and(new_affinity, online, unit->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               new_affinity);\n            }\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_soft,\n                                              nr_cpu_ids);\n                if ( !ret)\n                    ret = vcpu_set_soft_affinity(v, new_affinity);\n                if ( ret )\n                {\n                    /*\n                     * Since we're returning error, the caller expects nothing\n                     * happened, so we rollback the changes to hard affinity\n                     * (if any).\n                     */\n                    if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                        vcpu_set_hard_affinity(v, old_affinity);\n                    goto setvcpuaffinity_out;\n                }\n\n                /*\n                 * For soft affinity, we return the intersection between the\n                 * new soft affinity, the cpupool's online map and the (new)\n                 * hard affinity.\n                 */\n                cpumask_and(new_affinity, new_affinity, online);\n                cpumask_and(new_affinity, new_affinity,\n                            unit->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               new_affinity);\n            }\n\n setvcpuaffinity_out:\n            free_cpumask_var(new_affinity);\n            free_cpumask_var(old_affinity);\n        }\n        else\n        {\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               unit->cpu_hard_affinity);\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               unit->cpu_soft_affinity);\n        }\n        break;\n    }\n\n    case XEN_DOMCTL_scheduler_op:\n        ret = sched_adjust(d, &op->u.scheduler_op);\n        copyback = 1;\n        break;\n\n    case XEN_DOMCTL_getdomaininfo:\n    {\n        domid_t dom = DOMID_INVALID;\n\n        if ( !d )\n        {\n            ret = -EINVAL;\n            if ( op->domain >= DOMID_FIRST_RESERVED )\n                break;\n\n            rcu_read_lock(&domlist_read_lock);\n\n            dom = op->domain;\n            for_each_domain ( d )\n                if ( d->domain_id >= dom )\n                    break;\n        }\n\n        ret = -ESRCH;\n        if ( d == NULL )\n            goto getdomaininfo_out;\n\n        ret = xsm_getdomaininfo(XSM_HOOK, d);\n        if ( ret )\n            goto getdomaininfo_out;\n\n        getdomaininfo(d, &op->u.getdomaininfo);\n\n        op->domain = op->u.getdomaininfo.domain;\n        copyback = 1;\n\n    getdomaininfo_out:\n        /* When d was non-NULL upon entry, no cleanup is needed. */\n        if ( dom == DOMID_INVALID )\n            break;\n\n        rcu_read_unlock(&domlist_read_lock);\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        struct vcpu         *v;\n\n        ret = -EINVAL;\n        if ( op->u.vcpucontext.vcpu >= d->max_vcpus ||\n             (v = d->vcpu[op->u.vcpucontext.vcpu]) == NULL ||\n             v == current ) /* no vcpu_pause() */\n            goto getvcpucontext_out;\n\n        ret = -ENODATA;\n        if ( !v->is_initialised )\n            goto getvcpucontext_out;\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = xzalloc(struct vcpu_guest_context)) == NULL )\n            goto getvcpucontext_out;\n\n        vcpu_pause(v);\n\n        arch_get_info_guest(v, c);\n        ret = 0;\n\n        vcpu_unpause(v);\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32bit_domain(d) )\n            ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n        else\n            ret = copy_to_guest(guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                  void), c.cmp, 1);\n#else\n        ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n#endif\n\n        if ( ret )\n            ret = -EFAULT;\n        copyback = 1;\n\n    getvcpucontext_out:\n        xfree(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpuinfo:\n    {\n        struct vcpu   *v;\n        struct vcpu_runstate_info runstate;\n\n        ret = -EINVAL;\n        if ( op->u.getvcpuinfo.vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[op->u.getvcpuinfo.vcpu]) == NULL )\n            break;\n\n        vcpu_runstate_get(v, &runstate);\n\n        op->u.getvcpuinfo.online   = !(v->pause_flags & VPF_down);\n        op->u.getvcpuinfo.blocked  = !!(v->pause_flags & VPF_blocked);\n        op->u.getvcpuinfo.running  = v->is_running;\n        op->u.getvcpuinfo.cpu_time = runstate.time[RUNSTATE_running];\n        op->u.getvcpuinfo.cpu      = v->processor;\n        ret = 0;\n        copyback = 1;\n        break;\n    }\n\n    case XEN_DOMCTL_max_mem:\n    {\n        uint64_t new_max = op->u.max_mem.max_memkb >> (PAGE_SHIFT - 10);\n\n        spin_lock(&d->page_alloc_lock);\n        /*\n         * NB. We removed a check that new_max >= current tot_pages; this means\n         * that the domain will now be allowed to \""ratchet\"" down to new_max. In\n         * the meantime, while tot > max, all new allocations are disallowed.\n         */\n        d->max_pages = min(new_max, (uint64_t)(typeof(d->max_pages))-1);\n        spin_unlock(&d->page_alloc_lock);\n        break;\n    }\n\n    case XEN_DOMCTL_setdomainhandle:\n        memcpy(d->handle, op->u.setdomainhandle.handle,\n               sizeof(xen_domain_handle_t));\n        break;\n\n    case XEN_DOMCTL_setdebugging:\n        if ( unlikely(d == current->domain) ) /* no domain_pause() */\n            ret = -EINVAL;\n        else\n        {\n            domain_pause(d);\n            d->debugger_attached = !!op->u.setdebugging.enable;\n            domain_unpause(d); /* causes guest to latch new status */\n        }\n        break;\n\n    case XEN_DOMCTL_irq_permission:\n    {\n        unsigned int pirq = op->u.irq_permission.pirq, irq;\n        int allow = op->u.irq_permission.allow_access;\n\n        if ( pirq >= current->domain->nr_pirqs )\n        {\n            ret = -EINVAL;\n            break;\n        }\n        irq = pirq_access_permitted(current->domain, pirq);\n        if ( !irq || xsm_irq_permission(XSM_HOOK, d, irq, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = irq_permit_access(d, irq);\n        else\n            ret = irq_deny_access(d, irq);\n        break;\n    }\n\n    case XEN_DOMCTL_iomem_permission:\n    {\n        unsigned long mfn = op->u.iomem_permission.first_mfn;\n        unsigned long nr_mfns = op->u.iomem_permission.nr_mfns;\n        int allow = op->u.iomem_permission.allow_access;\n\n        ret = -EINVAL;\n        if ( (mfn + nr_mfns - 1) < mfn ) /* wrap? */\n            break;\n\n        if ( !iomem_access_permitted(current->domain,\n                                     mfn, mfn + nr_mfns - 1) ||\n             xsm_iomem_permission(XSM_HOOK, d, mfn, mfn + nr_mfns - 1, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = iomem_permit_access(d, mfn, mfn + nr_mfns - 1);\n        else\n            ret = iomem_deny_access(d, mfn, mfn + nr_mfns - 1);\n        if ( !ret )\n            memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_memory_mapping:\n    {\n        unsigned long gfn = op->u.memory_mapping.first_gfn;\n        unsigned long mfn = op->u.memory_mapping.first_mfn;\n        unsigned long nr_mfns = op->u.memory_mapping.nr_mfns;\n        unsigned long mfn_end = mfn + nr_mfns - 1;\n        int add = op->u.memory_mapping.add_mapping;\n\n        ret = -EINVAL;\n        if ( mfn_end < mfn || /* wrap? */\n             ((mfn | mfn_end) >> (paddr_bits - PAGE_SHIFT)) ||\n             (gfn + nr_mfns - 1) < gfn ) /* wrap? */\n            break;\n\n#ifndef CONFIG_X86 /* XXX ARM!? */\n        ret = -E2BIG;\n        /* Must break hypercall up as this could take a while. */\n        if ( nr_mfns > 64 )\n            break;\n#endif\n\n        ret = -EPERM;\n        if ( !iomem_access_permitted(current->domain, mfn, mfn_end) ||\n             !iomem_access_permitted(d, mfn, mfn_end) )\n            break;\n\n        ret = xsm_iomem_mapping(XSM_HOOK, d, mfn, mfn_end, add);\n        if ( ret )\n            break;\n\n        if ( add )\n        {\n            printk(XENLOG_G_DEBUG\n                   \""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\\n\"",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = map_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));\n            if ( ret < 0 )\n                printk(XENLOG_G_WARNING\n                       \""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\\n\"",\n                       d->domain_id, gfn, mfn, nr_mfns, ret);\n        }\n        else\n        {\n            printk(XENLOG_G_DEBUG\n                   \""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\\n\"",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = unmap_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));\n            if ( ret < 0 && is_hardware_domain(current->domain) )\n                printk(XENLOG_ERR\n                       \""memory_map: error %ld removing dom%d access to [%lx,%lx]\\n\"",\n                       ret, d->domain_id, mfn, mfn_end);\n        }\n        /* Do this unconditionally to cover errors on above failure paths. */\n        memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_settimeoffset:\n        domain_set_time_offset(d, op->u.settimeoffset.time_offset_seconds);\n        break;\n\n    case XEN_DOMCTL_set_target:\n    {\n        struct domain *e;\n\n        ret = -ESRCH;\n        e = get_domain_by_id(op->u.set_target.target);\n        if ( e == NULL )\n            break;\n\n        ret = -EINVAL;\n        if ( (d == e) || (d->target != NULL) )\n        {\n            put_domain(e);\n            break;\n        }\n\n        ret = -EOPNOTSUPP;\n        if ( is_hvm_domain(e) )\n            ret = xsm_set_target(XSM_HOOK, d, e);\n        if ( ret )\n        {\n            put_domain(e);\n            break;\n        }\n\n        /* Hold reference on @e until we destroy @d. */\n        d->target = e;\n        break;\n    }\n\n    case XEN_DOMCTL_subscribe:\n        d->suspend_evtchn = op->u.subscribe.port;\n        break;\n\n    case XEN_DOMCTL_vm_event_op:\n        ret = vm_event_domctl(d, &op->u.vm_event_op);\n        if ( ret == 0 )\n            copyback = true;\n        break;\n\n#ifdef CONFIG_MEM_ACCESS\n    case XEN_DOMCTL_set_access_required:\n        if ( unlikely(current->domain == d) ) /* no domain_pause() */\n            ret = -EPERM;\n        else\n        {\n            domain_pause(d);\n            arch_p2m_set_access_required(d,\n                op->u.access_required.access_required);\n            domain_unpause(d);\n        }\n        break;\n#endif\n\n    case XEN_DOMCTL_set_virq_handler:\n        ret = set_global_virq_handler(d, op->u.set_virq_handler.virq);\n        break;\n\n    case XEN_DOMCTL_setvnumainfo:\n    {\n        struct vnuma_info *vnuma;\n\n        vnuma = vnuma_init(&op->u.vnuma, d);\n        if ( IS_ERR(vnuma) )\n        {\n            ret = PTR_ERR(vnuma);\n            break;\n        }\n\n        /* overwrite vnuma topology for domain. */\n        write_lock(&d->vnuma_rwlock);\n        vnuma_destroy(d->vnuma);\n        d->vnuma = vnuma;\n        write_unlock(&d->vnuma_rwlock);\n\n        break;\n    }\n\n    case XEN_DOMCTL_monitor_op:\n        ret = monitor_domctl(d, &op->u.monitor_op);\n        if ( !ret )\n            copyback = 1;\n        break;\n\n    default:\n        ret = arch_do_domctl(op, d, u_domctl);\n        break;\n    }\n\n    domctl_lock_release();\n\n domctl_out_unlock_domonly:\n    if ( d && d != dom_io )\n        rcu_unlock_domain(d);\n\n    if ( copyback && __copy_to_guest(u_domctl, op, 1) )\n        ret = -EFAULT;\n\n    return ret;\n}""}, {""func_name"": ""deassign_device"", ""file_path"": ""xen/drivers/passthrough/pci.c"", ""func_code"": ""static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus,\n                           uint8_t devfn)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    struct domain *target;\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return -EINVAL;\n\n    ASSERT(pcidevs_locked());\n    pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);\n    if ( !pdev )\n        return -ENODEV;\n\n    /* De-assignment from dom_io should de-quarantine the device */\n    target = (pdev->quarantine && pdev->domain != dom_io) ?\n        dom_io : hardware_domain;\n\n    while ( pdev->phantom_stride )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                                pci_to_dev(pdev));\n        if ( !ret )\n            continue;\n\n        printk(XENLOG_G_ERR \""%pd: deassign %04x:%02x:%02x.%u failed (%d)\\n\"",\n               d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret);\n        return ret;\n    }\n\n    devfn = pdev->devfn;\n    ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                            pci_to_dev(pdev));\n    if ( ret )\n    {\n        dprintk(XENLOG_G_ERR,\n                \""%pd: deassign device (%04x:%02x:%02x.%u) failed\\n\"",\n                d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n        return ret;\n    }\n\n    if ( pdev->domain == hardware_domain  )\n        pdev->quarantine = false;\n\n    pdev->fault.count = 0;\n\n    return ret;\n}""}, {""func_name"": ""assign_device"", ""file_path"": ""xen/drivers/passthrough/pci.c"", ""func_code"": ""static int assign_device(struct domain *d, u16 seg, u8 bus, u8 devfn, u32 flag)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    int rc = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n    /* Prevent device assign if mem paging or mem sharing have been \n     * enabled for this domain */\n    if ( d != dom_io &&\n         unlikely((is_hvm_domain(d) &&\n                   d->arch.hvm.mem_sharing_enabled) ||\n                  vm_event_check_ring(d->vm_event_paging) ||\n                  p2m_get_hostp2m(d)->global_logdirty) )\n        return -EXDEV;\n\n    if ( !pcidevs_trylock() )\n        return -ERESTART;\n\n    pdev = pci_get_pdev(seg, bus, devfn);\n\n    rc = -ENODEV;\n    if ( !pdev )\n        goto done;\n\n    rc = 0;\n    if ( d == pdev->domain )\n        goto done;\n\n    rc = -EBUSY;\n    if ( pdev->domain != hardware_domain &&\n         pdev->domain != dom_io )\n        goto done;\n\n    if ( pdev->msix )\n    {\n        rc = pci_reset_msix_state(pdev);\n        if ( rc )\n            goto done;\n        msixtbl_init(d);\n    }\n\n    pdev->fault.count = 0;\n\n    if ( (rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag)) )\n        goto done;\n\n    for ( ; pdev->phantom_stride; rc = 0 )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag);\n        if ( rc )\n            printk(XENLOG_G_WARNING \""d%d: assign %04x:%02x:%02x.%u failed (%d)\\n\"",\n                   d->domain_id, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   rc);\n    }\n\n done:\n    /* The device is assigned to dom_io so mark it as quarantined */\n    if ( !rc && d == dom_io )\n        pdev->quarantine = true;\n\n    pcidevs_unlock();\n\n    return rc;\n}""}, {""func_name"": ""device_assigned"", ""file_path"": ""xen/drivers/passthrough/pci.c"", ""func_code"": ""static int device_assigned(u16 seg, u8 bus, u8 devfn)\n{\n    struct pci_dev *pdev;\n    int rc = 0;\n\n    pcidevs_lock();\n\n    pdev = pci_get_pdev(seg, bus, devfn);\n\n    if ( !pdev )\n        rc = -ENODEV;\n    /*\n     * If the device exists and it is not owned by either the hardware\n     * domain or dom_io then it must be assigned to a guest, or be\n     * hidden (owned by dom_xen).\n     */\n    else if ( pdev->domain != hardware_domain &&\n              pdev->domain != dom_io )\n        rc = -EBUSY;\n\n    pcidevs_unlock();\n\n    return rc;\n}""}, {""func_name"": ""iommu_do_pci_domctl"", ""file_path"": ""xen/drivers/passthrough/pci.c"", ""func_code"": ""int iommu_do_pci_domctl(\n    struct xen_domctl *domctl, struct domain *d,\n    XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    u16 seg;\n    u8 bus, devfn;\n    int ret = 0;\n    uint32_t machine_sbdf;\n\n    switch ( domctl->cmd )\n    {\n        unsigned int flags;\n\n    case XEN_DOMCTL_get_device_group:\n    {\n        u32 max_sdevs;\n        XEN_GUEST_HANDLE_64(uint32) sdevs;\n\n        ret = xsm_get_device_group(XSM_HOOK, domctl->u.get_device_group.machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = domctl->u.get_device_group.machine_sbdf >> 16;\n        bus = PCI_BUS(domctl->u.get_device_group.machine_sbdf);\n        devfn = PCI_DEVFN2(domctl->u.get_device_group.machine_sbdf);\n        max_sdevs = domctl->u.get_device_group.max_sdevs;\n        sdevs = domctl->u.get_device_group.sdev_array;\n\n        ret = iommu_get_device_group(d, seg, bus, devfn, sdevs, max_sdevs);\n        if ( ret < 0 )\n        {\n            dprintk(XENLOG_ERR, \""iommu_get_device_group() failed!\\n\"");\n            ret = -EFAULT;\n            domctl->u.get_device_group.num_sdevs = 0;\n        }\n        else\n        {\n            domctl->u.get_device_group.num_sdevs = ret;\n            ret = 0;\n        }\n        if ( __copy_field_to_guest(u_domctl, domctl, u.get_device_group) )\n            ret = -EFAULT;\n    }\n    break;\n\n    case XEN_DOMCTL_assign_device:\n        ASSERT(d);\n        /* fall through */\n    case XEN_DOMCTL_test_assign_device:\n        /* Don't support self-assignment of devices. */\n        if ( d == current->domain )\n        {\n            ret = -EINVAL;\n            break;\n        }\n\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )\n            break;\n\n        ret = -EINVAL;\n        flags = domctl->u.assign_device.flags;\n        if ( domctl->cmd == XEN_DOMCTL_assign_device\n             ? d->is_dying || (flags & ~XEN_DOMCTL_DEV_RDM_RELAXED)\n             : flags )\n            break;\n\n        machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;\n\n        ret = xsm_assign_device(XSM_HOOK, d, machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = machine_sbdf >> 16;\n        bus = PCI_BUS(machine_sbdf);\n        devfn = PCI_DEVFN2(machine_sbdf);\n\n        ret = device_assigned(seg, bus, devfn);\n        if ( domctl->cmd == XEN_DOMCTL_test_assign_device )\n        {\n            if ( ret )\n            {\n                printk(XENLOG_G_INFO\n                       \""%04x:%02x:%02x.%u already assigned, or non-existent\\n\"",\n                       seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n                ret = -EINVAL;\n            }\n            break;\n        }\n        if ( !ret )\n            ret = assign_device(d, seg, bus, devfn, flags);\n        if ( ret == -ERESTART )\n            ret = hypercall_create_continuation(__HYPERVISOR_domctl,\n                                                \""h\"", u_domctl);\n        else if ( ret )\n            printk(XENLOG_G_ERR\n                   \""assign %04x:%02x:%02x.%u to dom%d failed (%d)\\n\"",\n                   seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   d->domain_id, ret);\n\n        break;\n\n    case XEN_DOMCTL_deassign_device:\n        /* Don't support self-deassignment of devices. */\n        if ( d == current->domain )\n        {\n            ret = -EINVAL;\n            break;\n        }\n\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )\n            break;\n\n        ret = -EINVAL;\n        if ( domctl->u.assign_device.flags )\n            break;\n\n        machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;\n\n        ret = xsm_deassign_device(XSM_HOOK, d, machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = machine_sbdf >> 16;\n        bus = PCI_BUS(machine_sbdf);\n        devfn = PCI_DEVFN2(machine_sbdf);\n\n        pcidevs_lock();\n        ret = deassign_device(d, seg, bus, devfn);\n        pcidevs_unlock();\n        if ( ret )\n            printk(XENLOG_G_ERR\n                   \""deassign %04x:%02x:%02x.%u from dom%d failed (%d)\\n\"",\n                   seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   d->domain_id, ret);\n\n        break;\n\n    default:\n        ret = -ENOSYS;\n        break;\n    }\n\n    return ret;\n}""}, {""func_name"": ""iommu_setup"", ""file_path"": ""xen/drivers/passthrough/vtd/iommu.c"", ""func_code"": ""int __init iommu_setup(void)\n{\n    int rc = -ENODEV;\n    bool_t force_intremap = force_iommu && iommu_intremap;\n\n    if ( iommu_hwdom_strict )\n        iommu_hwdom_passthrough = false;\n\n    if ( iommu_enable )\n    {\n        rc = iommu_hardware_setup();\n        iommu_enabled = (rc == 0);\n    }\n    if ( !iommu_enabled )\n        iommu_intremap = 0;\n\n    if ( (force_iommu && !iommu_enabled) ||\n         (force_intremap && !iommu_intremap) )\n        panic(\""Couldn't enable %s and iommu=required/force\\n\"",\n              !iommu_enabled ? \""IOMMU\"" : \""Interrupt Remapping\"");\n\n    if ( !iommu_intremap )\n        iommu_intpost = 0;\n\n    printk(\""I/O virtualisation %sabled\\n\"", iommu_enabled ? \""en\"" : \""dis\"");\n    if ( !iommu_enabled )\n    {\n        iommu_snoop = 0;\n        iommu_hwdom_passthrough = false;\n        iommu_hwdom_strict = false;\n    }\n    else\n    {\n        dom_io->options |= XEN_DOMCTL_CDF_iommu;\n        if ( iommu_domain_init(dom_io, 0) )\n            panic(\""Could not set up quarantine\\n\"");\n\n        printk(\"" - Dom0 mode: %s\\n\"",\n               iommu_hwdom_passthrough ? \""Passthrough\"" :\n               iommu_hwdom_strict ? \""Strict\"" : \""Relaxed\"");\n        printk(\""Interrupt remapping %sabled\\n\"", iommu_intremap ? \""en\"" : \""dis\"");\n        tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);\n    }\n\n    return rc;\n}""}, {""func_name"": ""iommu_domain_init"", ""file_path"": ""xen/drivers/passthrough/vtd/iommu.c"", ""func_code"": ""int iommu_domain_init(struct domain *d, unsigned int opts)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n#ifdef CONFIG_NUMA\n    hd->node = NUMA_NO_NODE;\n#endif\n\n    ret = arch_iommu_domain_init(d);\n    if ( ret )\n        return ret;\n\n    hd->platform_ops = iommu_get_ops();\n    ret = hd->platform_ops->init(d);\n    if ( ret || is_system_domain(d) )\n        return ret;\n\n    if ( is_hardware_domain(d) )\n        check_hwdom_reqs(d); /* may modify iommu_hwdom_strict */\n\n    /*\n     * Use shared page tables for HAP and IOMMU if the global option\n     * is enabled (from which we can infer the h/w is capable) and\n     * the domain options do not disallow it. HAP must, of course, also\n     * be enabled.\n     */\n    hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&\n        !(opts & XEN_DOMCTL_IOMMU_no_sharept);\n\n    /*\n     * NB: 'relaxed' h/w domains don't need the IOMMU mappings to be kept\n     *     in-sync with their assigned pages because all host RAM will be\n     *     mapped during hwdom_init().\n     */\n    if ( !is_hardware_domain(d) || iommu_hwdom_strict )\n        hd->need_sync = !iommu_use_hap_pt(d);\n\n    ASSERT(!(hd->need_sync && hd->hap_pt_share));\n\n    return 0;\n}""}]","{""caller"": 1, ""code"": 1}","[{""source"": ""caller_info(file:pci.c, func:deassign_device)"", ""result"": [{""call_line"": 971, ""call_code"": ""deassign_device(d, pdev->seg, bus, devfn)"", ""caller_code"": ""int pci_release_devices(struct domain *d)\n{\n    struct pci_dev *pdev;\n    u8 bus, devfn;\n    int ret;\n\n    pcidevs_lock();\n    ret = pci_clean_dpci_irqs(d);\n    if ( ret )\n    {\n        pcidevs_unlock();\n        return ret;\n    }\n    while ( (pdev = pci_get_pdev_by_domain(d, -1, -1, -1)) )\n    {\n        bus = pdev->bus;\n        devfn = pdev->devfn;\n        if ( deassign_device(d, pdev->seg, bus, devfn) )\n            printk(\""domain %d: deassign device (%04x:%02x:%02x.%u) failed!\\n\"",\n                   d->domain_id, pdev->seg, bus,\n                   PCI_SLOT(devfn), PCI_FUNC(devfn));\n    }\n    pcidevs_unlock();\n\n    return 0;\n}"", ""caller_start"": 954, ""file_path"": ""xen/drivers/passthrough/pci.c""}]}, {""source"": ""code_info(file:domain.c, lines:500-600)"", ""result"": "" fail:\n    ASSERT(err < 0);      /* Sanity check paths leading here. */\n    err = err ?: -EILSEQ; /* Release build safety. */\n\n    d->is_dying = DOMDYING_dead;\n    if ( hardware_domain == d )\n        hardware_domain = old_hwdom;\n    atomic_set(&d->refcnt, DOMAIN_DESTROYED);\n\n    sched_destroy_domain(d);\n\n    if ( d->max_vcpus )\n    {\n        d->max_vcpus = 0;\n        XFREE(d->vcpu);\n    }\n    if ( init_status & INIT_arch )\n        arch_domain_destroy(d);\n    if ( init_status & INIT_gnttab )\n        grant_table_destroy(d);\n    if ( init_status & INIT_evtchn )\n    {\n        evtchn_destroy(d);\n        evtchn_destroy_final(d);\n        radix_tree_destroy(&d->pirq_tree, free_pirq_struct);\n    }\n    if ( init_status & INIT_watchdog )\n        watchdog_domain_destroy(d);\n\n    _domain_destroy(d);\n\n    return ERR_PTR(err);\n}\n\nvoid __init setup_system_domains(void)\n{\n    /*\n     * Initialise our DOMID_XEN domain.\n     * Any Xen-heap pages that we will allow to be mapped will have\n     * their domain field set to dom_xen.\n     * Hidden PCI devices will also be associated with this domain\n     * (but be [partly] controlled by Dom0 nevertheless).\n     */\n    dom_xen = domain_create(DOMID_XEN, NULL, false);\n    if ( IS_ERR(dom_xen) )\n        panic(\""Failed to create d[XEN]: %ld\\n\"", PTR_ERR(dom_xen));\n\n    /*\n     * Initialise our DOMID_IO domain.\n     * This domain owns I/O pages that are within the range of the page_info\n     * array. Mappings occur at the priv of the caller.\n     */\n    dom_io = domain_create(DOMID_IO, NULL, false);\n    if ( IS_ERR(dom_io) )\n        panic(\""Failed to create d[IO]: %ld\\n\"", PTR_ERR(dom_io));\n\n#ifdef CONFIG_MEM_SHARING\n    /*\n     * Initialise our COW domain.\n     * This domain owns sharable pages.\n     */\n    dom_cow = domain_create(DOMID_COW, NULL, false);\n    if ( IS_ERR(dom_cow) )\n        panic(\""Failed to create d[COW]: %ld\\n\"", PTR_ERR(dom_cow));\n#endif\n}\n\nvoid domain_update_node_affinity(struct domain *d)\n{\n    cpumask_var_t dom_cpumask, dom_cpumask_soft;\n    cpumask_t *dom_affinity;\n    const cpumask_t *online;\n    struct sched_unit *unit;\n    unsigned int cpu;\n\n    /* Do we have vcpus already? If not, no need to update node-affinity. */\n    if ( !d->vcpu || !d->vcpu[0] )\n        return;\n\n    if ( !zalloc_cpumask_var(&dom_cpumask) )\n        return;\n    if ( !zalloc_cpumask_var(&dom_cpumask_soft) )\n    {\n        free_cpumask_var(dom_cpumask);\n        return;\n    }\n\n    online = cpupool_domain_master_cpumask(d);\n\n    spin_lock(&d->node_affinity_lock);\n\n    /*\n     * If d->auto_node_affinity is true, let's compute the domain's\n     * node-affinity and update d->node_affinity accordingly. if false,\n     * just leave d->auto_node_affinity alone.\n     */\n    if ( d->auto_node_affinity )\n    {\n        /*\n         * We want the narrowest possible set of pcpus (to get the narowest\n         * possible set of nodes). What we need is the cpumask of where the\n         * domain can run (the union of the hard affinity of all its vcpus),\n""}]","xen/drivers/passthrough/pci.c:911-952: deassign_device reassigns devices to dom_io during deassignment. xen/drivers/passthrough/iommu.c:182-187: iommu_domain_init blocks IOMMU mappings for dom_io. xen/drivers/passthrough/pci.c:971: pci_release_devices calls deassign_device during domain teardown. xen/common/domain.c:500-600: Domain destruction triggers arch_domain_destroy, which includes PCI cleanup.",0.95,./github/other_context/CVE-2019-18424
32,CVE-2013-4537,CWE-94,c_cpp,The ssi_sd_transfer function in hw/sd/ssi-sd.c in QEMU before 1.7.2 allows remote attackers to execute arbitrary code via a crafted arglen value in a savevm image.,https://github.com/qemu/qemu/commit/a9c380db3b8c6af19546a68145c8d1438a09c92b,ssi-sd: fix buffer overrun on invalid state load\n\nCVE-2013-4537\n\ns->arglen is taken from wire and used as idx\nin ssi_sd_transfer().\n\nValidate it before access.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Juan Quintela <quintela@redhat.com>,1,"[{""func_name"": ""ssi_sd_load"", ""file_path"": ""hw/sd/ssi-sd.c"", ""func_code"": ""static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n        return -EINVAL;\n\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n    for (i = 0; i < 5; i++)\n        s->response[i] = qemu_get_be32(f);\n    s->arglen = qemu_get_be32(f);\n    s->response_pos = qemu_get_be32(f);\n    s->stopping = qemu_get_be32(f);\n\n    ss->cs = qemu_get_be32(f);\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""ssi_sd_load"", ""file_path"": ""hw/sd/ssi-sd.c"", ""func_code"": ""static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n        return -EINVAL;\n\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n    for (i = 0; i < 5; i++)\n        s->response[i] = qemu_get_be32(f);\n    s->arglen = qemu_get_be32(f);\n    if (s->mode == SSI_SD_CMDARG &&\n        (s->arglen < 0 || s->arglen >= ARRAY_SIZE(s->cmdarg))) {\n        return -EINVAL;\n    }\n    s->response_pos = qemu_get_be32(f);\n    s->stopping = qemu_get_be32(f);\n    if (s->mode == SSI_SD_RESPONSE &&\n        (s->response_pos < 0 || s->response_pos >= ARRAY_SIZE(s->response) ||\n        (!s->stopping && s->arglen > ARRAY_SIZE(s->response)))) {\n        return -EINVAL;\n    }\n\n    ss->cs = qemu_get_be32(f);\n\n    return 0;\n}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(file:ssi-sd.c, func:ssi_sd_transfer)"", ""result"": [{""code"": ""static uint32_t ssi_sd_transfer(SSISlave *dev, uint32_t val)\n{\n    ssi_sd_state *s = FROM_SSI_SLAVE(ssi_sd_state, dev);\n\n    /* Special case: allow CMD12 (STOP TRANSMISSION) while reading data.  */\n    if (s->mode == SSI_SD_DATA_READ && val == 0x4d) {\n        s->mode = SSI_SD_CMD;\n        /* There must be at least one byte delay before the card responds.  */\n        s->stopping = 1;\n    }\n\n    switch (s->mode) {\n    case SSI_SD_CMD:\n        if (val == 0xff) {\n            DPRINTF(\""NULL command\\n\"");\n            return 0xff;\n        }\n        s->cmd = val & 0x3f;\n        s->mode = SSI_SD_CMDARG;\n        s->arglen = 0;\n        return 0xff;\n    case SSI_SD_CMDARG:\n        if (s->arglen == 4) {\n            SDRequest request;\n            uint8_t longresp[16];\n            /* FIXME: Check CRC.  */\n            request.cmd = s->cmd;\n            request.arg = (s->cmdarg[0] << 24) | (s->cmdarg[1] << 16)\n                           | (s->cmdarg[2] << 8) | s->cmdarg[3];\n            DPRINTF(\""CMD%d a..."", ""start_line"": 67, ""end_line"": 196, ""full_name"": ""ssi_sd_transfer"", ""file_path"": ""hw/sd/ssi-sd.c""}]}, {""source"": ""code_info(file:ssi-sd.c, lines:120-150)"", ""result"": ""                cardstatus = (longresp[0] << 24) | (longresp[1] << 16)\n                             | (longresp[2] << 8) | longresp[3];\n                status = 0;\n                if (((cardstatus >> 9) & 0xf) < 4)\n                    status |= SSI_SDR_IDLE;\n                if (cardstatus & ERASE_RESET)\n                    status |= SSI_SDR_ERASE_RESET;\n                if (cardstatus & ILLEGAL_COMMAND)\n                    status |= SSI_SDR_ILLEGAL_COMMAND;\n                if (cardstatus & COM_CRC_ERROR)\n                    status |= SSI_SDR_COM_CRC_ERROR;\n                if (cardstatus & ERASE_SEQ_ERROR)\n                    status |= SSI_SDR_ERASE_SEQ_ERROR;\n                if (cardstatus & ADDRESS_ERROR)\n                    status |= SSI_SDR_ADDRESS_ERROR;\n                if (cardstatus & CARD_IS_LOCKED)\n                    status |= SSI_SDR_LOCKED;\n                if (cardstatus & (LOCK_UNLOCK_FAILED | WP_ERASE_SKIP))\n                    status |= SSI_SDR_WP_ERASE;\n                if (cardstatus & SD_ERROR)\n                    status |= SSI_SDR_ERROR;\n                if (cardstatus & CC_ERROR)\n                    status |= SSI_SDR_CC_ERROR;\n                if (cardstatus & CARD_ECC_FAILED)\n                    status |= SSI_SDR_ECC_FAILED;\n                if (cardstatus & WP_VIOLATION)\n                    status |= SSI_SDR_WP_VIOLATION;\n                if (cardstatus & ERASE_PARAM)\n                    status |= SSI_SDR_ERASE_PARAM;\n                if (cardstatus & (OUT_OF_RANGE | CID_CSD_OVERWRITE))\n                    status |= SSI_SDR_OUT_OF_RANGE;\n                /* ??? Don't know what Parameter Error really means, so\n""}]","1. In hw/sd/ssi-sd.c:231-238 (original code), s->arglen is loaded from untrusted savevm input without validation in ssi_sd_load().\n2. In hw/sd/ssi-sd.c:105 (ssi_sd_transfer()), s->arglen is used as an index into s->cmdarg[4] (e.g., s->cmdarg[s->arglen++] = val & 0xff). If s->arglen >=4, this causes a buffer overflow.\n3. The patch adds bounds checks in ssi_sd_load() to ensure s->arglen is within ARRAY_SIZE(s->cmdarg) (4 elements), preventing overflow.",0.95,./github/other_context/CVE-2013-4537
33,CVE-2014-5120,CWE-20,c_cpp,"gd_ctx.c in the GD component in PHP 5.4.x before 5.4.32 and 5.5.x before 5.5.16 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to overwrite arbitrary files via crafted input to an application that calls the (1) imagegd, (2) imagegd2, (3) imagegif, (4) imagejpeg, (5) imagepng, (6) imagewbmp, or (7) imagewebp function.",https://github.com/php/php-src/commit/1daa4c0090b7cd8178dcaa96287234c69ac6ca18,Fix bug #67730 - Null byte injection possible with imagexxx functions,1,"[{""func_name"": ""_php_image_output_ctx"", ""file_path"": ""ext/gd/gd_ctx.c"", ""func_code"": ""static void _php_image_output_ctx(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, void (*func_p)())\n{\n\tzval *imgind;\n\tchar *file = NULL;\n\tint file_len = 0;\n\tlong quality, basefilter;\n\tgdImagePtr im;\n\tint argc = ZEND_NUM_ARGS();\n\tint q = -1, i;\n\tint f = -1;\n\tgdIOCtx *ctx = NULL;\n\tzval *to_zval = NULL;\n\tphp_stream *stream;\n\n\t/* The third (quality) parameter for Wbmp stands for the threshold when called from image2wbmp().\n\t * The third (quality) parameter for Wbmp and Xbm stands for the foreground color index when called\n\t * from imagey<type>().\n\t */\n\tif (image_type == PHP_GDIMG_TYPE_XBM) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""rp!|ll\"", &imgind, &file, &file_len, &quality, &basefilter) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* PHP_GDIMG_TYPE_GIF\n\t\t * PHP_GDIMG_TYPE_PNG \n\t\t * PHP_GDIMG_TYPE_JPG \n\t\t * PHP_GDIMG_TYPE_WBM \n\t\t * PHP_GDIMG_TYPE_WEBP \n\t\t * */\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""r|z/!ll\"", &imgind, &to_zval, &quality, &basefilter) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &imgind, -1, \""Image\"", phpi_get_le_gd());\n\n\tif (argc >= 3) {\n\t\tq = quality; /* or colorindex for foreground of BW images (defaults to black) */\n\t\tif (argc == 4) {\n\t\t\tf = basefilter;\n\t\t}\n\t}\n\n\tif (argc > 1 && to_zval != NULL) {\n\t\tif (Z_TYPE_P(to_zval) == IS_RESOURCE) {\n\t\t\tphp_stream_from_zval_no_verify(stream, &to_zval);\n\t\t\tif (stream == NULL) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else if (Z_TYPE_P(to_zval) == IS_STRING) {\n\t\t\tstream = php_stream_open_wrapper(Z_STRVAL_P(to_zval), \""wb\"", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);\n\t\t\tif (stream == NULL) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid 2nd parameter, it must a filename or a stream\"");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tctx = emalloc(sizeof(gdIOCtx));\n\t\tctx->putC = _php_image_output_putc;\n\t\tctx->putBuf = _php_image_output_putbuf;\n\t\tctx->gd_free = _php_image_output_ctxfree;\n\n#if APACHE && defined(CHARSET_EBCDIC)\n\t\t/* XXX this is unlikely to work any more thies@thieso.net */\n\t\t/* This is a binary file already: avoid EBCDIC->ASCII conversion */\n\t\tap_bsetflag(php3_rqst->connection->client, B_EBCDIC2ASCII, 0);\n#endif\n\t}\n\n\tif (!ctx)\t{\n\t\tctx = emalloc(sizeof(gdIOCtx));\n\t\tctx->putC = _php_image_stream_putc;\n\t\tctx->putBuf = _php_image_stream_putbuf;\n\t\tctx->gd_free = _php_image_stream_ctxfree;\n\t\tctx->data = (void *)stream;\n\t}\n\n\tswitch(image_type) {\n\t\tcase PHP_GDIMG_CONVERT_WBM:\n\t\t\tif(q<0||q>255) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid threshold value '%d'. It must be between 0 and 255\"", q);\n\t\t\t}\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t(*func_p)(im, ctx, q);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_WEBP:\n\t\t\tif (q == -1) {\n\t\t\t\tq = 80;\n\t\t\t}\n\t\t\t(*func_p)(im, ctx, q);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\t(*func_p)(im, ctx, q, f);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_XBM:\n\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\tif (argc < 3) {\n\t\t\t\tfor(i=0; i < gdImageColorsTotal(im); i++) {\n\t\t\t\t\tif(!gdImageRed(im, i) && !gdImageGreen(im, i) && !gdImageBlue(im, i)) break;\n\t\t\t\t}\n\t\t\t\tq = i;\n\t\t\t}\n\t\t\tif (image_type == PHP_GDIMG_TYPE_XBM) {\n\t\t\t\t(*func_p)(im, file, q, ctx);\n\t\t\t} else {\n\t\t\t\t(*func_p)(im, q, ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(*func_p)(im, ctx);\n\t\t\tbreak;\n\t}\n\n\tctx->gd_free(ctx);\n\n\tRETURN_TRUE;\n}"", ""target"": 0}]","[{""func_name"": ""_php_image_output_ctx"", ""file_path"": ""ext/gd/gd_ctx.c"", ""func_code"": ""static void _php_image_output_ctx(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, void (*func_p)())\n{\n\tzval *imgind;\n\tchar *file = NULL;\n\tint file_len = 0;\n\tlong quality, basefilter;\n\tgdImagePtr im;\n\tint argc = ZEND_NUM_ARGS();\n\tint q = -1, i;\n\tint f = -1;\n\tgdIOCtx *ctx = NULL;\n\tzval *to_zval = NULL;\n\tphp_stream *stream;\n\n\t/* The third (quality) parameter for Wbmp stands for the threshold when called from image2wbmp().\n\t * The third (quality) parameter for Wbmp and Xbm stands for the foreground color index when called\n\t * from imagey<type>().\n\t */\n\tif (image_type == PHP_GDIMG_TYPE_XBM) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""rp!|ll\"", &imgind, &file, &file_len, &quality, &basefilter) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* PHP_GDIMG_TYPE_GIF\n\t\t * PHP_GDIMG_TYPE_PNG \n\t\t * PHP_GDIMG_TYPE_JPG \n\t\t * PHP_GDIMG_TYPE_WBM \n\t\t * PHP_GDIMG_TYPE_WEBP \n\t\t * */\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""r|z/!ll\"", &imgind, &to_zval, &quality, &basefilter) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &imgind, -1, \""Image\"", phpi_get_le_gd());\n\n\tif (argc >= 3) {\n\t\tq = quality; /* or colorindex for foreground of BW images (defaults to black) */\n\t\tif (argc == 4) {\n\t\t\tf = basefilter;\n\t\t}\n\t}\n\n\tif (argc > 1 && to_zval != NULL) {\n\t\tif (Z_TYPE_P(to_zval) == IS_RESOURCE) {\n\t\t\tphp_stream_from_zval_no_verify(stream, &to_zval);\n\t\t\tif (stream == NULL) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else if (Z_TYPE_P(to_zval) == IS_STRING) {\n\t\t\tif (CHECK_ZVAL_NULL_PATH(to_zval)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid 2nd parameter, filename must not contain null bytes\"");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tstream = php_stream_open_wrapper(Z_STRVAL_P(to_zval), \""wb\"", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);\n\t\t\tif (stream == NULL) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid 2nd parameter, it must a filename or a stream\"");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tctx = emalloc(sizeof(gdIOCtx));\n\t\tctx->putC = _php_image_output_putc;\n\t\tctx->putBuf = _php_image_output_putbuf;\n\t\tctx->gd_free = _php_image_output_ctxfree;\n\n#if APACHE && defined(CHARSET_EBCDIC)\n\t\t/* XXX this is unlikely to work any more thies@thieso.net */\n\t\t/* This is a binary file already: avoid EBCDIC->ASCII conversion */\n\t\tap_bsetflag(php3_rqst->connection->client, B_EBCDIC2ASCII, 0);\n#endif\n\t}\n\n\tif (!ctx)\t{\n\t\tctx = emalloc(sizeof(gdIOCtx));\n\t\tctx->putC = _php_image_stream_putc;\n\t\tctx->putBuf = _php_image_stream_putbuf;\n\t\tctx->gd_free = _php_image_stream_ctxfree;\n\t\tctx->data = (void *)stream;\n\t}\n\n\tswitch(image_type) {\n\t\tcase PHP_GDIMG_CONVERT_WBM:\n\t\t\tif(q<0||q>255) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid threshold value '%d'. It must be between 0 and 255\"", q);\n\t\t\t}\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t(*func_p)(im, ctx, q);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_WEBP:\n\t\t\tif (q == -1) {\n\t\t\t\tq = 80;\n\t\t\t}\n\t\t\t(*func_p)(im, ctx, q);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\t(*func_p)(im, ctx, q, f);\n\t\t\tbreak;\n\t\tcase PHP_GDIMG_TYPE_XBM:\n\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\tif (argc < 3) {\n\t\t\t\tfor(i=0; i < gdImageColorsTotal(im); i++) {\n\t\t\t\t\tif(!gdImageRed(im, i) && !gdImageGreen(im, i) && !gdImageBlue(im, i)) break;\n\t\t\t\t}\n\t\t\t\tq = i;\n\t\t\t}\n\t\t\tif (image_type == PHP_GDIMG_TYPE_XBM) {\n\t\t\t\t(*func_p)(im, file, q, ctx);\n\t\t\t} else {\n\t\t\t\t(*func_p)(im, q, ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(*func_p)(im, ctx);\n\t\t\tbreak;\n\t}\n\n\tctx->gd_free(ctx);\n\n\tRETURN_TRUE;\n}""}]","{""caller"": 1}","[{""source"": ""caller_info(file:gd_ctx.c, func:_php_image_output_ctx)"", ""result"": [{""call_line"": 2702, ""call_code"": ""_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, \""XBM\"", gdImageXbmCtx)"", ""caller_code"": ""PHP_FUNCTION(imagexbm)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, \""XBM\"", gdImageXbmCtx);\n}"", ""caller_start"": 2700, ""file_path"": ""ext/gd/gd.c""}, {""call_line"": 2710, ""call_code"": ""_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, \""GIF\"", gdImageGifCtx)"", ""caller_code"": ""PHP_FUNCTION(imagegif)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, \""GIF\"", gdImageGifCtx);\n}"", ""caller_start"": 2708, ""file_path"": ""ext/gd/gd.c""}, {""call_line"": 2750, ""call_code"": ""_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, \""WBMP\"", gdImageWBMPCtx)"", ""caller_code"": ""PHP_FUNCTION(imagewbmp)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, \""WBMP\"", gdImageWBMPCtx);\n}"", ""caller_start"": 2748, ""file_path"": ""ext/gd/gd.c""}]}]","ext/gd/gd_ctx.c:128: Stream creation via Z_STRVAL_P(to_zval) without null byte validation. The 'to_zval' is populated by user input through functions like PHP_FUNCTION(imagegif) (ext/gd/gd.c:2710), which pass the second parameter (filename) to _php_image_output_ctx. Prior to the patch, no validation occurred, allowing %00 sequences in filenames.",0.95,./github/other_context/CVE-2014-5120
34,CVE-2013-6430,CWE-79,java,"The JavaScriptUtils.javaScriptEscape method in web/util/JavaScriptUtils.java in Spring MVC in Spring Framework before 3.2.2 does not properly escape certain characters, which allows remote attackers to conduct cross-site scripting (XSS) attacks via a (1) line separator or (2) paragraph separator Unicode character or (3) left or (4) right angle bracket.",https://github.com/spring-projects/spring-framework/commit/7a7df6637478607bef0277bf52a4e0a03e20a248,"Update JavaScriptUtils\n\nAdd escaping for <, >, and PS/LS line terminators\n\nIssue: SPR-9983",1,"[{""func_name"": ""javaScriptEscape"", ""file_path"": ""org.springframework.web/src/main/java/org/springframework/web/util/JavaScriptUtils.java"", ""func_code"": ""public static String javaScriptEscape(String input) {\n\t\tif (input == null) {\n\t\t\treturn input;\n\t\t}\n\n\t\tStringBuilder filtered = new StringBuilder(input.length());\n\t\tchar prevChar = '\\u0000';\n\t\tchar c;\n\t\tfor (int i = 0; i < input.length(); i++) {\n\t\t\tc = input.charAt(i);\n\t\t\tif (c == '\""') {\n\t\t\t\tfiltered.append(\""\\\\\\\""\"");\n\t\t\t}\n\t\t\telse if (c == '\\'') {\n\t\t\t\tfiltered.append(\""\\\\'\"");\n\t\t\t}\n\t\t\telse if (c == '\\\\') {\n\t\t\t\tfiltered.append(\""\\\\\\\\\"");\n\t\t\t}\n\t\t\telse if (c == '/') {\n\t\t\t\tfiltered.append(\""\\\\/\"");\n\t\t\t}\n\t\t\telse if (c == '\\t') {\n\t\t\t\tfiltered.append(\""\\\\t\"");\n\t\t\t}\n\t\t\telse if (c == '\\n') {\n\t\t\t\tif (prevChar != '\\r') {\n\t\t\t\t\tfiltered.append(\""\\\\n\"");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (c == '\\r') {\n\t\t\t\tfiltered.append(\""\\\\n\"");\n\t\t\t}\n\t\t\telse if (c == '\\f') {\n\t\t\t\tfiltered.append(\""\\\\f\"");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfiltered.append(c);\n\t\t\t}\n\t\t\tprevChar = c;\n\n\t\t}\n\t\treturn filtered.toString();\n\t}"", ""target"": 0}]","[{""func_name"": ""javaScriptEscape"", ""file_path"": ""org.springframework.web/src/main/java/org/springframework/web/util/JavaScriptUtils.java"", ""func_code"": ""public static String javaScriptEscape(String input) {\n\t\tif (input == null) {\n\t\t\treturn input;\n\t\t}\n\n\t\tStringBuilder filtered = new StringBuilder(input.length());\n\t\tchar prevChar = '\\u0000';\n\t\tchar c;\n\t\tfor (int i = 0; i < input.length(); i++) {\n\t\t\tc = input.charAt(i);\n\t\t\tif (c == '\""') {\n\t\t\t\tfiltered.append(\""\\\\\\\""\"");\n\t\t\t}\n\t\t\telse if (c == '\\'') {\n\t\t\t\tfiltered.append(\""\\\\'\"");\n\t\t\t}\n\t\t\telse if (c == '\\\\') {\n\t\t\t\tfiltered.append(\""\\\\\\\\\"");\n\t\t\t}\n\t\t\telse if (c == '/') {\n\t\t\t\tfiltered.append(\""\\\\/\"");\n\t\t\t}\n\t\t\telse if (c == '\\t') {\n\t\t\t\tfiltered.append(\""\\\\t\"");\n\t\t\t}\n\t\t\telse if (c == '\\n') {\n\t\t\t\tif (prevChar != '\\r') {\n\t\t\t\t\tfiltered.append(\""\\\\n\"");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (c == '\\r') {\n\t\t\t\tfiltered.append(\""\\\\n\"");\n\t\t\t}\n\t\t\telse if (c == '\\f') {\n\t\t\t\tfiltered.append(\""\\\\f\"");\n\t\t\t}\n\t\t\telse if (c == '\\b') {\n\t\t\t\tfiltered.append(\""\\\\b\"");\n\t\t\t}\n\t\t\t// No '\\v' in Java, use octal value for VT ascii char\n\t\t\telse if (c == '\\013') {\n\t\t\t\tfiltered.append(\""\\\\v\"");\n\t\t\t}\n\t\t\telse if (c == '<') {\n\t\t\t\tfiltered.append(\""\\\\u003C\"");\n\t\t\t}\n\t\t\telse if (c == '>') {\n\t\t\t\tfiltered.append(\""\\\\u003E\"");\n\t\t\t}\n\t\t\t// Unicode for PS (line terminator in ECMA-262)\n\t\t\telse if (c == '\\u2028') {\n\t\t\t\tfiltered.append(\""\\\\u2028\"");\n\t\t\t}\n\t\t\t// Unicode for LS (line terminator in ECMA-262)\n\t\t\telse if (c == '\\u2029') {\n\t\t\t\tfiltered.append(\""\\\\u2029\"");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfiltered.append(c);\n\t\t\t}\n\t\t\tprevChar = c;\n\n\t\t}\n\t\treturn filtered.toString();\n\t}""}]","{""caller"": 1, ""value"": 4, ""function"": 4}","[{""source"": ""caller_info(func:javaScriptEscape)"", ""result"": [{""call_line"": 83, ""call_code"": ""JavaScriptUtils.javaScriptEscape(content)"", ""caller_code"": ""\t@Override\n\tpublic int doAfterBody() throws JspException {\n\t\ttry {\n\t\t\tString content = readBodyContent();\n\t\t\t// HTML and/or JavaScript escape, if demanded\n\t\t\tcontent = isHtmlEscape() ? HtmlUtils.htmlEscape(content) : content;\n\t\t\tcontent = this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(content) : content;\n\t\t\twriteBodyContent(content);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new JspException(\""Could not write escaped body\"", ex);\n\t\t}\n\t\treturn (SKIP_BODY);\n\t}\n"", ""caller_start"": 77, ""file_path"": ""org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/tags/EscapeBodyTag.java""}, {""call_line"": 128, ""call_code"": ""JavaScriptUtils.javaScriptEscape(result)"", ""caller_code"": ""\t@Override\n\tpublic int doEndTag() throws JspException {\n\t\tEvaluationContext evaluationContext =\n\t\t\t\t(EvaluationContext) this.pageContext.getAttribute(EVALUATION_CONTEXT_PAGE_ATTRIBUTE);\n\t\tif (evaluationContext == null) {\n\t\t\tevaluationContext = createEvaluationContext(this.pageContext);\n\t\t\tthis.pageContext.setAttribute(EVALUATION_CONTEXT_PAGE_ATTRIBUTE, evaluationContext);\n\t\t}\n\t\tif (this.var != null) {\n\t\t\tObject result = this.expression.getValue(evaluationContext);\n\t\t\tthis.pageContext.setAttribute(this.var, result, this.scope);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tString result = this.expression.getValue(evaluationContext, String.class);\n\t\t\t\tresult = ObjectUtils.getDisplayString(result);\n\t\t\t\tresult = (isHtmlEscape() ? HtmlUtils.htmlEscape(result) : result);\n\t\t\t\tresult = (this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(result) : result);\n\t\t\t\tthis.pageContext.getOut().print(result);\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tthrow new JspException(ex);\n\t\t\t}\n\t\t}\n\t\treturn EVAL_PAGE;\n\t}\n"", ""caller_start"": 111, ""file_path"": ""org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/tags/EvalTag.java""}, {""call_line"": 169, ""call_code"": ""JavaScriptUtils.javaScriptEscape(msg)"", ""caller_code"": ""\t@Override\n\tprotected final int doStartTagInternal() throws JspException, IOException {\n\t\ttry {\n\t\t\t// Resolve the unescaped message.\n\t\t\tString msg = resolveMessage();\n\n\t\t\t// HTML and/or JavaScript escape, if demanded.\n\t\t\tmsg = isHtmlEscape() ? HtmlUtils.htmlEscape(msg) : msg;\n\t\t\tmsg = this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(msg) : msg;\n\n\t\t\t// Expose as variable, if demanded, else write to the page.\n\t\t\tString resolvedVar = ExpressionEvaluationUtils.evaluateString(\""var\"", this.var, pageContext);\n\t\t\tif (resolvedVar != null) {\n\t\t\t\tString resolvedScope = ExpressionEvaluationUtils.evaluateString(\""scope\"", this.scope, pageContext);\n\t\t\t\tpageContext.setAttribute(resolvedVar, msg, TagUtils.getScope(resolvedScope));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twriteMessage(msg);\n\t\t\t}\n\n\t\t\treturn EVAL_BODY_INCLUDE;\n\t\t}\n\t\tcatch (NoSuchMessageException ex) {\n\t\t\tthrow new JspTagException(getNoSuchMessageExceptionDescription(ex));\n\t\t}\n\t}\n"", ""caller_start"": 161, ""file_path"": ""org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/tags/MessageTag.java""}, {""call_line"": 231, ""call_code"": ""JavaScriptUtils.javaScriptEscape(urlStr)"", ""caller_code"": ""\tprivate String createUrl() throws JspException {\n\t\tHttpServletRequest request = (HttpServletRequest) pageContext.getRequest();\n\t\tHttpServletResponse response = (HttpServletResponse) pageContext.getResponse();\n\t\tStringBuilder url = new StringBuilder();\n\t\tif (this.type == UrlType.CONTEXT_RELATIVE) {\n\t\t\t// add application context to url\n\t\t\tif (this.context == null) {\n\t\t\t\turl.append(request.getContextPath());\n\t\t\t}\n\t\t\telse {\n\t\t\t\turl.append(this.context);\n\t\t\t}\n\t\t}\n\t\tif (this.type != UrlType.RELATIVE && this.type != UrlType.ABSOLUTE && !this.value.startsWith(\""/\"")) {\n\t\t\turl.append(\""/\"");\n\t\t}\n\t\turl.append(replaceUriTemplateParams(this.value, this.params, this.templateParams));\n\t\turl.append(createQueryString(this.params, this.templateParams, (url.indexOf(\""?\"") == -1)));\n\n\t\tString urlStr = url.toString();\n\t\tif (this.type != UrlType.ABSOLUTE) {\n\t\t\t// Add the session identifier if needed\n\t\t\t// (Do not embed the session identifier in a remote link!)\n\t\t\turlStr = response.encodeURL(urlStr);\n\t\t}\n\n\t\t// HTML and/or JavaScript escape, if demanded.\n\t\turlStr = isHtmlEscape() ? HtmlUtils.htmlEscape(urlStr) : urlStr;\n\t\turlStr = this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(urlStr) : urlStr;\n\t\t\n\t\treturn urlStr;\n\t}\n"", ""caller_start"": 203, ""file_path"": ""org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/tags/UrlTag.java""}]}, {""source"": ""value_info(file:EscapeBodyTag.java, value:content)"", ""result"": {""value_trace"": [{""full_code"": ""String content = readBodyContent()"", ""line"": 80, ""func_name"": ""org.springframework.web.servlet.tags.EscapeBodyTag.doAfterBody:int()""}, {""full_code"": ""content = isHtmlEscape() ? HtmlUtils.htmlEscape(content) : content"", ""line"": 82, ""func_name"": ""org.springframework.web.servlet.tags.EscapeBodyTag.doAfterBody:int()""}, {""full_code"": ""content = this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(content) : content"", ""line"": 83, ""func_name"": ""org.springframework.web.servlet.tags.EscapeBodyTag.doAfterBody:int()""}], ""struct_var"": ""content"", ""struct_type"": ""java.lang.String"", ""struct_definition"": null}}, {""source"": ""value_info(file:EvalTag.java, value:result)"", ""result"": {""value_trace"": [{""full_code"": ""Object result = this.expression.getValue(evaluationContext)"", ""line"": 120, ""func_name"": ""org.springframework.web.servlet.tags.EvalTag.doEndTag:int()""}, {""full_code"": ""String result = this.expression.getValue(evaluationContext, String.class)"", ""line"": 125, ""func_name"": ""org.springframework.web.servlet.tags.EvalTag.doEndTag:int()""}, {""full_code"": ""result = ObjectUtils.getDisplayString(result)"", ""line"": 126, ""func_name"": ""org.springframework.web.servlet.tags.EvalTag.doEndTag:int()""}, {""full_code"": ""result = (isHtmlEscape() ? HtmlUtils.htmlEscape(result) : result)"", ""line"": 127, ""func_name"": ""org.springframework.web.servlet.tags.EvalTag.doEndTag:int()""}, {""full_code"": ""result = (this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(result) : result)"", ""line"": 128, ""func_name"": ""org.springframework.web.servlet.tags.EvalTag.doEndTag:int()""}], ""struct_var"": ""result"", ""struct_type"": ""java.lang.Object"", ""struct_definition"": null}}, {""source"": ""value_info(file:MessageTag.java, value:msg)"", ""result"": {""value_trace"": [{""full_code"": ""String msg = resolveMessage()"", ""line"": 165, ""func_name"": ""org.springframework.web.servlet.tags.MessageTag.doStartTagInternal:int()""}, {""full_code"": ""msg = isHtmlEscape() ? HtmlUtils.htmlEscape(msg) : msg"", ""line"": 168, ""func_name"": ""org.springframework.web.servlet.tags.MessageTag.doStartTagInternal:int()""}, {""full_code"": ""msg = this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(msg) : msg"", ""line"": 169, ""func_name"": ""org.springframework.web.servlet.tags.MessageTag.doStartTagInternal:int()""}], ""struct_var"": ""msg"", ""struct_type"": ""java.lang.String"", ""struct_definition"": null}}, {""source"": ""value_info(file:UrlTag.java, value:urlStr)"", ""result"": {""value_trace"": [{""full_code"": ""String urlStr = url.toString()"", ""line"": 222, ""func_name"": ""org.springframework.web.servlet.tags.UrlTag.createUrl:java.lang.String()""}, {""full_code"": ""urlStr = response.encodeURL(urlStr)"", ""line"": 226, ""func_name"": ""org.springframework.web.servlet.tags.UrlTag.createUrl:java.lang.String()""}, {""full_code"": ""urlStr = isHtmlEscape() ? HtmlUtils.htmlEscape(urlStr) : urlStr"", ""line"": 230, ""func_name"": ""org.springframework.web.servlet.tags.UrlTag.createUrl:java.lang.String()""}, {""full_code"": ""urlStr = this.javaScriptEscape ? JavaScriptUtils.javaScriptEscape(urlStr) : urlStr"", ""line"": 231, ""func_name"": ""org.springframework.web.servlet.tags.UrlTag.createUrl:java.lang.String()""}], ""struct_var"": ""urlStr"", ""struct_type"": ""java.lang.String"", ""struct_definition"": null}}, {""source"": ""func_info(file:EscapeBodyTag.java, func:readBodyContent)"", ""result"": [{""code"": ""\tprotected String readBodyContent() throws IOException {\n\t\treturn this.bodyContent.getString();\n\t}\n"", ""start_line"": 97, ""end_line"": 99, ""full_name"": ""org.springframework.web.servlet.tags.EscapeBodyTag.readBodyContent:java.lang.String()"", ""file_path"": ""org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/tags/EscapeBodyTag.java""}]}, {""source"": ""func_info(file:UrlTag.java, func:replaceUriTemplateParams)"", ""result"": [{""code"": ""\tprotected String replaceUriTemplateParams(String uri, List<Param> params, Set<String> usedParams)\n\t\t\tthrows JspException {\n\n\t\tString encoding = pageContext.getResponse().getCharacterEncoding();\n\t\tfor (Param param : params) {\n\t\t\tString template = URL_TEMPLATE_DELIMITER_PREFIX + param.getName() + URL_TEMPLATE_DELIMITER_SUFFIX;\n\t\t\tif (uri.contains(template)) {\n\t\t\t\tusedParams.add(param.getName());\n\t\t\t\ttry {\n\t\t\t\t\turi = uri.replace(template, UriUtils.encodePath(param.getValue(), encoding));\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t\t\tthrow new JspException(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn uri;\n\t}\n"", ""start_line"": 284, ""end_line"": 301, ""full_name"": ""org.springframework.web.servlet.tags.UrlTag.replaceUriTemplateParams:java.lang.String(java.lang.String,java.util.List,java.util.Set)"", ""file_path"": ""org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/tags/UrlTag.java""}]}, {""source"": ""func_info(file:MessageTag.java, func:resolveMessage)"", ""result"": [{""code"": ""\tprotected String resolveMessage() throws JspException, NoSuchMessageException {\n\t\tMessageSource messageSource = getMessageSource();\n\t\tif (messageSource == null) {\n\t\t\tthrow new JspTagException(\""No corresponding MessageSource found\"");\n\t\t}\n\n\t\t// Evaluate the specified MessageSourceResolvable, if any.\n\t\tMessageSourceResolvable resolvedMessage = null;\n\t\tif (this.message instanceof MessageSourceResolvable) {\n\t\t\tresolvedMessage = (MessageSourceResolvable) this.message;\n\t\t}\n\t\telse if (this.message != null) {\n\t\t\tString expr = this.message.toString();\n\t\t\tresolvedMessage = (MessageSourceResolvable)\n\t\t\t\t\tExpressionEvaluationUtils.evaluate(\""message\"", expr, MessageSourceResolvable.class, pageContext);\n\t\t}\n\n\t\tif (resolvedMessage != null) {\n\t\t\t// We have a given MessageSourceResolvable.\n\t\t\treturn messageSource.getMessage(resolvedMessage, getRequestContext().getLocale());\n\t\t}\n\n\t\tString resolvedCode = ExpressionEvaluationUtils.evaluateString(\""code\"", this.code, pageContext);\n\t\tString resolvedText = ExpressionEvaluationUtils.evaluateString(\""text\"", this.text, pageContext);\n\n\t\tif (resolvedCode != null || resolvedText != null) {\n\t\t\t// We have a code or default text that we need to resolve.\n\t\t\tObject[] argumentsArray = resolveArguments(this.arguments);\n\t\t\tif (resolvedText != null) {\n\t\t\t\t// We have a fallback text to consider.\n\t\t\t\treturn messageSource.getMessage(\n\t\t\t\t\t\tresolvedCode, argumentsArray, resolvedText, getRequestContext().getLocale());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We have no fallback text to consider.\n\t\t\t\treturn messageSource.getMessage(\n\t\t\t\t\t\tresolvedCode, argumentsArray, getRequestContext().getLocale());\n\t\t\t}\n\t\t}\n\n\t\t// All we have is a specified literal text.\n\t\treturn resolvedText;\n\t}\n"", ""start_line"": 192, ""end_line"": 234, ""full_name"": ""org.springframework.web.servlet.tags.MessageTag.resolveMessage:java.lang.String()"", ""file_path"": ""org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/tags/MessageTag.java""}]}, {""source"": ""func_info(func:getValue)"", ""result"": [{""code"": ""\tpublic Object getValue() {\n\t\treturn this.value;\n\t}\n"", ""start_line"": 60, ""end_line"": 62, ""full_name"": ""org.springframework.beans.BeanMetadataAttribute.getValue:java.lang.Object()"", ""file_path"": ""org.springframework.beans/src/main/java/org/springframework/beans/BeanMetadataAttribute.java""}, {""code"": ""\tpublic Object getValue() {\n\t\treturn (this.propertyChangeEvent != null ? this.propertyChangeEvent.getNewValue() : null);\n\t}\n"", ""start_line"": 75, ""end_line"": 77, ""full_name"": ""org.springframework.beans.PropertyAccessException.getValue:java.lang.Object()"", ""file_path"": ""org.springframework.beans/src/main/java/org/springframework/beans/PropertyAccessException.java""}, {""code"": ""\tpublic Object getValue() {\n\t\treturn this.value;\n\t}\n"", ""start_line"": 126, ""end_line"": 128, ""full_name"": ""org.springframework.beans.PropertyValue.getValue:java.lang.Object()"", ""file_path"": ""org.springframework.beans/src/main/java/org/springframework/beans/PropertyValue.java""}]}]","JavaScriptUtils.javaScriptEscape (org.springframework.web.util.JavaScriptUtils.java:74-95) failed to escape <, >, \\u2028, and \\u2029, enabling XSS. The method is invoked in:\n1. EscapeBodyTag.java:83: 'content' from readBodyContent() (EscapeBodyTag.java:97-99) → JSP body content (user-controlled)\n2. EvalTag.java:128: 'result' from expression.getValue() (EvalTag.java:120) → EL expressions (user-controlled)\n3. MessageTag.java:169: 'msg' from resolveMessage() (MessageTag.java:192-234) → message parameters (user-controlled)\n4. UrlTag.java:231: 'urlStr' from replaceUriTemplateParams() (UrlTag.java:284-301) → URL template parameters (user-controlled). Unescaped characters in these inputs lead to XSS when injected into JavaScript contexts.",0.95,./github/other_context/CVE-2013-6430
35,CVE-2017-13061,CWE-20,c_cpp,"In ImageMagick 7.0.6-5, a length-validation vulnerability was found in the function ReadPSDLayersInternal in coders/psd.c, which allows attackers to cause a denial of service (ReadPSDImage memory exhaustion) via a crafted file.",https://github.com/ImageMagick/ImageMagick/commit/d5e05878caac35b0c8e852791ccfcc77a1390958,https://github.com/ImageMagick/ImageMagick/issues/645,1,"[{""func_name"": ""ReadPSDLayersInternal"", ""file_path"": ""coders/psd.c"", ""func_code"": ""static MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\""8BIM\"",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\""Lr16\"",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  negative layer count corrected for\"");\n          image->alpha_trait=BlendPixelTrait;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""  image contains %.20g layers\"",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\""InvalidNumberOfLayers\"",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  allocation of LayerInfo failed\"");\n          ThrowBinaryException(ResourceLimitError,\""MemoryAllocationFailed\"",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""  reading layer #%.20g\"",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\""MaximumChannelsExceeded\"",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\"",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""    channel[%.20g]: type=%.20g, size=%.20g\"",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\""8BIM\"",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""  layer type was %.4s instead of 8BIM\"", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\""ImproperImageHeader\"",\n              image->filename);\n          }\n        count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\"",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \""true\"" : \""false\"",layer_info[i].flags,\n            layer_info[i].visible ? \""true\"" : \""false\"");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""    layer contains additional info\"");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\"",\n                    (double) layer_info[i].mask.page.x,(double)\n                    layer_info[i].mask.page.y,(double)\n                    layer_info[i].mask.page.width,(double)\n                    layer_info[i].mask.page.height,(double) ((MagickOffsetType)\n                    length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \""UnexpectedEndOfFile\"",image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \""      layer blending ranges: length=%.20g\"",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) length; j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \""        source(%x), dest(%x)\"",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""      layer name: %s\"",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \""UnexpectedEndOfFile\"",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""      layer data is empty\"");\n            if (layer_info[i].info != (StringInfo *) NULL)\n              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""  allocation of image for layer %.20g failed\"",(double) i);\n            ThrowBinaryException(ResourceLimitError,\""MemoryAllocationFailed\"",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\""psd:additional-info\"",\n              layer_info[i].info,exception);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \""UnexpectedEndOfFile\"",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""  reading data for layer %.20g\"",(double) i);\n\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}"", ""target"": 0}]","[{""func_name"": ""ReadPSDLayersInternal"", ""file_path"": ""coders/psd.c"", ""func_code"": ""static MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\""8BIM\"",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\""Lr16\"",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  negative layer count corrected for\"");\n          image->alpha_trait=BlendPixelTrait;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""  image contains %.20g layers\"",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\""InvalidNumberOfLayers\"",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  allocation of LayerInfo failed\"");\n          ThrowBinaryException(ResourceLimitError,\""MemoryAllocationFailed\"",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""  reading layer #%.20g\"",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\""MaximumChannelsExceeded\"",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\"",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""    channel[%.20g]: type=%.20g, size=%.20g\"",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\""8BIM\"",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""  layer type was %.4s instead of 8BIM\"", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\""ImproperImageHeader\"",\n              image->filename);\n          }\n        count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\"",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \""true\"" : \""false\"",layer_info[i].flags,\n            layer_info[i].visible ? \""true\"" : \""false\"");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""    layer contains additional info\"");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\"",\n                    (double) layer_info[i].mask.page.x,(double)\n                    layer_info[i].mask.page.y,(double)\n                    layer_info[i].mask.page.width,(double)\n                    layer_info[i].mask.page.height,(double) ((MagickOffsetType)\n                    length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \""UnexpectedEndOfFile\"",image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \""      layer blending ranges: length=%.20g\"",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) length; j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \""        source(%x), dest(%x)\"",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""      layer name: %s\"",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \""UnexpectedEndOfFile\"",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                if (length > GetBlobSize(image))\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \""InsufficientImageDataInFile\"",image->filename);\n                  }\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""      layer data is empty\"");\n            if (layer_info[i].info != (StringInfo *) NULL)\n              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""  allocation of image for layer %.20g failed\"",(double) i);\n            ThrowBinaryException(ResourceLimitError,\""MemoryAllocationFailed\"",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\""psd:additional-info\"",\n              layer_info[i].info,exception);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \""UnexpectedEndOfFile\"",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \""  reading data for layer %.20g\"",(double) i);\n\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}""}]","{""value"": 9, ""code"": 1, ""function"": 2, ""caller"": 2}","[{""source"": ""value_info(file:psd.c, value:length)"", ""result"": {""value_trace"": [{""full_code"": ""length=(size_t) (*compact_pixels++)"", ""line"": 555, ""func_name"": ""DecodePSDPixels""}, {""full_code"": ""length=256-length+1"", ""line"": 560, ""func_name"": ""DecodePSDPixels""}, {""full_code"": ""length++"", ""line"": 606, ""func_name"": ""DecodePSDPixels""}, {""full_code"": ""length=0"", ""line"": 1128, ""func_name"": ""ReadPSDChannelRLE""}, {""full_code"": ""length=(size_t) sizes[y]"", ""line"": 1131, ""func_name"": ""ReadPSDChannelRLE""}], ""struct_var"": ""length"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}, {""source"": ""value_info(file:psd.c, value:compact_pixels)"", ""result"": {""value_trace"": [{""full_code"": ""compact_pixels++"", ""line"": 555, ""func_name"": ""DecodePSDPixels""}, {""full_code"": ""compact_pixels++"", ""line"": 562, ""func_name"": ""DecodePSDPixels""}], ""struct_var"": ""compact_pixels"", ""struct_type"": ""unsigned char*"", ""struct_definition"": ""unsigned char""}}, {""source"": ""value_info(file:psd.c, value:sizes)"", ""result"": {""value_trace"": [{""full_code"": ""sizes=(MagickOffsetType *) AcquireQuantumMemory(size,sizeof(*sizes))"", ""line"": 1086, ""func_name"": ""ReadPSDRLESizes""}, {""full_code"": ""sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows)"", ""line"": 1350, ""func_name"": ""ReadPSDChannel""}, {""full_code"": ""sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes)"", ""line"": 1356, ""func_name"": ""ReadPSDChannel""}, {""full_code"": ""sizes=(MagickOffsetType *) NULL"", ""line"": 1900, ""func_name"": ""ReadPSDMergedImage""}, {""full_code"": ""sizes=ReadPSDRLESizes(image,psd_info,image->rows*psd_info->channels)"", ""line"": 1903, ""func_name"": ""ReadPSDMergedImage""}], ""struct_var"": ""sizes"", ""struct_type"": ""MagickOffsetType*"", ""struct_definition"": ""typedef long long MagickOffsetType;\n\ntypedef ssize_t MagickOffsetType;\n\ntypedef __int64 MagickOffsetType;""}}, {""source"": ""value_info(file:psd.c, value:compact_pixels)"", ""result"": {""value_trace"": [{""full_code"": ""compact_pixels++"", ""line"": 555, ""func_name"": ""DecodePSDPixels""}, {""full_code"": ""compact_pixels++"", ""line"": 562, ""func_name"": ""DecodePSDPixels""}], ""struct_var"": ""compact_pixels"", ""struct_type"": ""unsigned char*"", ""struct_definition"": ""unsigned char""}}, {""source"": ""value_info(file:psd.c, value:sizes)"", ""result"": {""value_trace"": [{""full_code"": ""sizes=(MagickOffsetType *) AcquireQuantumMemory(size,sizeof(*sizes))"", ""line"": 1086, ""func_name"": ""ReadPSDRLESizes""}, {""full_code"": ""sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows)"", ""line"": 1350, ""func_name"": ""ReadPSDChannel""}, {""full_code"": ""sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes)"", ""line"": 1356, ""func_name"": ""ReadPSDChannel""}, {""full_code"": ""sizes=(MagickOffsetType *) NULL"", ""line"": 1900, ""func_name"": ""ReadPSDMergedImage""}, {""full_code"": ""sizes=ReadPSDRLESizes(image,psd_info,image->rows*psd_info->channels)"", ""line"": 1903, ""func_name"": ""ReadPSDMergedImage""}], ""struct_var"": ""sizes"", ""struct_type"": ""MagickOffsetType*"", ""struct_definition"": ""typedef long long MagickOffsetType;\n\ntypedef ssize_t MagickOffsetType;\n\ntypedef __int64 MagickOffsetType;""}}, {""source"": ""value_info(file:psd.c, value:compact_pixels)"", ""result"": {""value_trace"": [{""full_code"": ""compact_pixels++"", ""line"": 555, ""func_name"": ""DecodePSDPixels""}, {""full_code"": ""compact_pixels++"", ""line"": 562, ""func_name"": ""DecodePSDPixels""}], ""struct_var"": ""compact_pixels"", ""struct_type"": ""unsigned char*"", ""struct_definition"": ""unsigned char""}}, {""source"": ""code_info(file:psd.c, lines:1086-1100)"", ""result"": ""  sizes=(MagickOffsetType *) AcquireQuantumMemory(size,sizeof(*sizes));\n  if(sizes != (MagickOffsetType *) NULL)\n    {\n      for (y=0; y < (ssize_t) size; y++)\n      {\n        if (psd_info->version == 1)\n          sizes[y]=(MagickOffsetType) ReadBlobShort(image);\n        else\n          sizes[y]=(MagickOffsetType) ReadBlobLong(image);\n      }\n    }\n  return sizes;\n}\n\nstatic MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception)\n""}, {""source"": ""value_info(file:psd.c, value:compact_pixels)"", ""result"": {""value_trace"": [{""full_code"": ""compact_pixels++"", ""line"": 555, ""func_name"": ""DecodePSDPixels""}, {""full_code"": ""compact_pixels++"", ""line"": 562, ""func_name"": ""DecodePSDPixels""}], ""struct_var"": ""compact_pixels"", ""struct_type"": ""unsigned char*"", ""struct_definition"": ""unsigned char""}}, {""source"": ""func_info(file:psd.c, func:DecodePSDPixels)"", ""result"": [{""code"": ""static ssize_t DecodePSDPixels(const size_t number_compact_pixels,\n  const unsigned char *compact_pixels,const ssize_t depth,\n  const size_t number_pixels,unsigned char *pixels)\n{\n#define CheckNumberCompactPixels \\\n  if (packets == 0) \\\n    return(i); \\\n  packets--\n\n#define CheckNumberPixels(count) \\\n  if (((ssize_t) i + count) > (ssize_t) number_pixels) \\\n    return(i); \\\n  i+=count\n\n  int\n    pixel;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    length;\n\n  ssize_t\n    packets;\n\n  packets=(ssize_t) number_compact_pixels;\n  for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); )\n  {\n    packets--;\n    length=(size_t) (*compact_pixels++);\n    if (length == 128)\n      continue;\n    if (length > 128)\n      {\n        length=256-length+1;\n        CheckNumberCompactPixels;\n        pixel=(*compact_pixels++);\n        for (j=0; j < (ssize_t) length; j++)\n        {\n          switch (depth)\n          {\n            case 1:\n            {\n              CheckNumberPixels(8);\n              *pi..."", ""start_line"": 524, ""end_line"": 652, ""full_name"": ""DecodePSDPixels"", ""file_path"": ""coders/psd.c""}]}, {""source"": ""caller_info(file:psd.c, func:DecodePSDPixels)"", ""result"": [{""call_line"": 1158, ""call_code"": ""DecodePSDPixels((size_t) sizes[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels)"", ""caller_code"": ""static MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    length,\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \""      layer data is RLE compressed\"");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\""MemoryAllocationFailed\"",\n      image->filename);\n\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < sizes[y])\n      length=(size_t) sizes[y];\n\n  if (length > row_size + 256) // arbitrary number\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\""InvalidLeng..."", ""caller_start"": 1100, ""file_path"": ""coders/psd.c""}]}, {""source"": ""value_info(value:compact_pixels)"", ""result"": {""value_trace"": [{""full_code"": ""compact_pixels++"", ""line"": 555, ""func_name"": ""DecodePSDPixels""}, {""full_code"": ""compact_pixels++"", ""line"": 562, ""func_name"": ""DecodePSDPixels""}], ""struct_var"": ""compact_pixels"", ""struct_type"": ""unsigned char*"", ""struct_definition"": ""unsigned char""}}, {""source"": ""func_info(func:ReadBlob)"", ""result"": [{""code"": ""ssize_t ReadBlob(Image *image,const size_t length,void *data)\n{\n  int\n    c;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  if (length == 0)\n    return(0);\n  assert(data != (void *) NULL);\n  count=0;\n  q=(unsigned char *) data;\n  switch (image->blob->type)\n  {\n    case UndefinedStream:\n      break;\n    case StandardStream:\n    case FileStream:\n    case PipeStream:\n    {\n      switch (length)\n      {\n        default:\n        {\n          count=(ssize_t) fread(q,1,length,image->blob->file_info.file);\n          break;\n        }\n        case 4:\n        {\n          c=getc(image->blob->file_info.file);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 3:\n        {\n          c=getc(image->blob->file_info.file);\n          if (c == EOF)\n ..."", ""start_line"": 3234, ""end_line"": 3391, ""full_name"": ""ReadBlob"", ""file_path"": ""MagickCore/blob.c""}]}, {""source"": ""value_info(file:psd.c, value:compact_pixels)"", ""result"": {""value_trace"": [{""full_code"": ""compact_pixels++"", ""line"": 555, ""func_name"": ""DecodePSDPixels""}, {""full_code"": ""compact_pixels++"", ""line"": 562, ""func_name"": ""DecodePSDPixels""}], ""struct_var"": ""compact_pixels"", ""struct_type"": ""unsigned char*"", ""struct_definition"": ""unsigned char""}}, {""source"": ""caller_info(file:psd.c, func:ReadBlob)"", ""result"": [{""call_line"": 1064, ""call_code"": ""ReadBlob(image,row_size,pixels)"", ""caller_code"": ""static MagickBooleanType ReadPSDChannelRaw(Image *image,const size_t channels,\n  const ssize_t type,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    count,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \""      layer data is RAW\"");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\""MemoryAllocationFailed\"",\n      image->filename);\n\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n\n    count=ReadBlob(image,row_size,pixels);\n    if (count != row_size)\n      break;\n\n    status=ReadPSDChannelPixels(image,channels,y,type,pixels,exception);\n    if (status == MagickFalse)\n      break;\n  }\n\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}"", ""caller_start"": 1033, ""file_path"": ""coders/psd.c""}, {""call_line"": 1154, ""call_code"": ""ReadBlob(image,(size_t) sizes[y],compact_pixels)"", ""caller_code"": ""static MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  size_t\n    length,\n    row_size;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \""      layer data is RLE compressed\"");\n\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\""MemoryAllocationFailed\"",\n      image->filename);\n\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < sizes[y])\n      length=(size_t) sizes[y];\n\n  if (length > row_size + 256) // arbitrary number\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\""InvalidLeng..."", ""caller_start"": 1100, ""file_path"": ""coders/psd.c""}, {""call_line"": 1514, ""call_code"": ""ReadBlob(image,4,(unsigned char *) type)"", ""caller_code"": ""static MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\""8BIM\"",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\""Lr16\"",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue)..."", ""caller_start"": 1483, ""file_path"": ""coders/psd.c""}, {""call_line"": 1521, ""call_code"": ""ReadBlob(image,4,(unsigned char *) type)"", ""caller_code"": ""static MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\""8BIM\"",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\""Lr16\"",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue)..."", ""caller_start"": 1483, ""file_path"": ""coders/psd.c""}]}]","coders/psd.c:1742-1748: 'length' is used in AcquireStringInfo and ReadBlob without validation. 'length' is derived from:\n1. 'sizes[y]' (ReadPSDChannelRLE:1131) → populated via ReadBlobShort/ReadBlobLong (ReadPSDRLESizes:1089-1093) from untrusted image blob data (psd.c:1089-1093).\n2. '*compact_pixels++' (DecodePSDPixels:555) → 'compact_pixels' is initialized via ReadBlob(image, (size_t) sizes[y], compact_pixels) in ReadPSDChannelRLE (psd.c:1154), where 'sizes[y]' originates from untrusted input. Both sources enable attackers to craft malicious 'length' values, causing memory exhaustion via unchecked allocations.",0.95,./github/other_context/CVE-2017-13061
36,CVE-2017-6504,CWE-20,c_cpp,"WebUI in qBittorrent before 3.3.11 did not set the X-Frame-Options header, which could potentially lead to clickjacking.",https://github.com/qbittorrent/qBittorrent/commit/f5ad04766f4abaa78374ff03704316f8ce04627d,[WebUI] Avoid clickjacking attacks,1,"[{""func_name"": ""AbstractWebApplication::processRequest"", ""file_path"": ""src/webui/abstractwebapplication.cpp"", ""func_code"": ""Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    clear(); // clear response\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n\n    if (isBanned()) {\n        status(403, \""Forbidden\"");\n        print(QObject::tr(\""Your IP address has been banned after too many failed authentication attempts.\""), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n\n    return response();\n}"", ""target"": 0}]","[{""func_name"": ""AbstractWebApplication::processRequest"", ""file_path"": ""src/webui/abstractwebapplication.cpp"", ""func_code"": ""Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    // clear response\n    clear();\n\n    // avoid clickjacking attacks\n    header(Http::HEADER_X_FRAME_OPTIONS, \""SAMEORIGIN\"");\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n\n    if (isBanned()) {\n        status(403, \""Forbidden\"");\n        print(QObject::tr(\""Your IP address has been banned after too many failed authentication attempts.\""), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n\n    return response();\n}""}]","{""code"": 1, ""caller"": 1, ""function"": 4, ""query"": 2}","[{""source"": ""code_info(file:abstractwebapplication.cpp, lines:100-130)"", ""result"": ""Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    clear(); // clear response\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n\n    if (isBanned()) {\n        status(403, \""Forbidden\"");\n        print(QObject::tr(\""Your IP address has been banned after too many failed authentication attempts.\""), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n\n    return response();\n}\n\nvoid AbstractWebApplication::UnbanTimerEvent()\n{\n    UnbanTimer* ubantimer = static_cast<UnbanTimer*>(sender());\n    qDebug(\""Ban period has expired for %s\"", qPrintable(ubantimer->peerIp().toString()));\n    clientFailedAttempts_.remove(ubantimer->peerIp());\n    ubantimer->deleteLater();\n}\n\nvoid AbstractWebApplication::removeInactiveSessions()\n""}, {""source"": ""caller_info(file:abstractwebapplication.cpp, func:processRequest)"", ""result"": [{""call_line"": 117, ""call_code"": ""processRequest()"", ""caller_code"": ""Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    clear(); // clear response\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n\n    if (isBanned()) {\n        status(403, \""Forbidden\"");\n        print(QObject::tr(\""Your IP address has been banned after too many failed authentication attempts.\""), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n\n    return response();\n}"", ""caller_start"": 100, ""file_path"": ""src/webui/abstractwebapplication.cpp""}, {""call_line"": 73, ""call_code"": ""m_requestHandler->processRequest(request, env)"", ""caller_code"": ""void Connection::read()\n{\n    m_receivedData.append(m_socket->readAll());\n\n    Request request;\n    RequestParser::ErrorCode err = RequestParser::parse(m_receivedData, request);\n    switch (err) {\n    case RequestParser::IncompleteRequest:\n        // Partial request waiting for the rest\n        break;\n    case RequestParser::BadRequest:\n        sendResponse(Response(400, \""Bad Request\""));\n        break;\n    case RequestParser::NoError:\n        Environment env;\n        env.clientAddress = m_socket->peerAddress();\n        Response response = m_requestHandler->processRequest(request, env);\n        if (acceptsGzipEncoding(request.headers[\""accept-encoding\""]))\n            response.headers[HEADER_CONTENT_ENCODING] = \""gzip\"";\n        sendResponse(response);\n        break;\n    }\n}"", ""caller_start"": 57, ""file_path"": ""src/base/http/connection.cpp""}]}, {""source"": ""func_info(file:abstractwebapplication.cpp, func:processRequest)"", ""result"": [{""code"": ""Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    clear(); // clear res"", ""start_line"": 100, ""end_line"": 121, ""full_name"": ""AbstractWebApplication.processRequest:Http.Response(Http.Request&,Http.Environment&)"", ""file_path"": ""src/webui/abstractwebapplication.cpp""}]}, {""source"": ""func_info(file:abstractwebapplication.cpp, func:processRequest)"", ""result"": [{""code"": ""Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    clear(); // clear res"", ""start_line"": 100, ""end_line"": 121, ""full_name"": ""AbstractWebApplication.processRequest:Http.Response(Http.Request&,Http.Environment&)"", ""file_path"": ""src/webui/abstractwebapplication.cpp""}]}, {""source"": ""func_info(file:abstractwebapplication.cpp, func:processRequest)"", ""result"": [{""code"": ""Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    clear(); // clear res"", ""start_line"": 100, ""end_line"": 121, ""full_name"": ""AbstractWebApplication.processRequest:Http.Response(Http.Request&,Http.Environment&)"", ""file_path"": ""src/webui/abstractwebapplication.cpp""}]}, {""source"": ""func_info(file:abstractwebapplication.cpp, func:processRequest)"", ""result"": [{""code"": ""Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    clear(); // clear res"", ""start_line"": 100, ""end_line"": 121, ""full_name"": ""AbstractWebApplication.processRequest:Http.Response(Http.Request&,Http.Environment&)"", ""file_path"": ""src/webui/abstractwebapplication.cpp""}]}, {""source"": ""query_info(query:cpg.method.name(\""processRequest\"").file.name(\""src/w...)"", ""result"": [{""name"": ""src/webui/abstractwebapplication.cpp"", ""code"": ""<empty>"", ""content"": ""<empty>""}, {""name"": ""src/webui/webapplication.cpp"", ""code"": ""<empty>"", ""content"": ""<empty>""}]}, {""source"": ""query_info(query:cpg.method.name(\""processRequest\"").file.name(\""src/w...)"", ""result"": [{""name"": ""src/webui/abstractwebapplication.cpp"", ""code"": ""<empty>"", ""content"": ""<empty>""}, {""name"": ""src/webui/webapplication.cpp"", ""code"": ""<empty>"", ""content"": ""<empty>""}]}]","The vulnerability originated from the absence of the X-Frame-Options header in HTTP responses generated by `AbstractWebApplication::processRequest` (src/webui/abstractwebapplication.cpp:115). The patch added `header(Http::HEADER_X_FRAME_OPTIONS, ""SAMEORIGIN"")` to set this header. No derived classes of `AbstractWebApplication` override `processRequest()`, as evidenced by the absence of inheritance declarations in `.h` files and `processRequest` overrides in `.cpp` files. The base class implementation is the sole execution path, and the patch fully addresses the vulnerability.",1.0,./github/other_context/CVE-2017-6504
37,CVE-2018-1000125,CWE-20,java,inversoft prime-jwt version prior to version 1.3.0 or prior to commit 0d94dcef0133d699f21d217e922564adbb83a227 contains an input validation vulnerability in JWTDecoder.decode that can result in a JWT that is decoded and thus implicitly validated even if it lacks a valid signature. This attack appear to be exploitable via an attacker crafting a token with a valid header and body and then requests it to be validated. This vulnerability appears to have been fixed in 1.3.0 and later or after commit 0d94dcef0133d699f21d217e922564adbb83a227.,https://github.com/FusionAuth/fusionauth-jwt/commit/0d94dcef0133d699f21d217e922564adbb83a227,"Fixes Issue #2, bug exists that allows a JWT to be decoded even when no signature is provided.",3,"[{""func_name"": ""decode"", ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java"", ""func_code"": ""public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // Be particular about decoding an unsecured JWT. If the JWT is signed or any verifiers were provided don't do it.\n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.isEmpty()) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }"", ""target"": 0}, {""func_name"": ""decode"", ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java"", ""func_code"": ""public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // Be particular about decoding an unsecured JWT. If the JWT is signed or any verifiers were provided don't do it.\n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.length == 0) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }"", ""target"": 0}, {""func_name"": ""decode"", ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java"", ""func_code"": ""private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\"".\"");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\""No Verifier has been provided for verify a signature signed using [\"" + header.algorithm.getName() + \""]\"");\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }"", ""target"": 0}]","[{""func_name"": ""decode"", ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java"", ""func_code"": ""public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.isEmpty()) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }""}, {""func_name"": ""decode"", ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java"", ""func_code"": ""public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.length == 0) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }""}, {""func_name"": ""decode"", ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java"", ""func_code"": ""private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\"".\"");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\""No Verifier has been provided for verify a signature signed using [\"" + header.algorithm.getName() + \""]\"");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }""}]","{""value"": 1, ""function"": 1, ""caller"": 1}","[{""source"": ""value_info(file:Header.java, value:algorithm)"", ""result"": {""value_trace"": [{""full_code"": ""header.algorithm = signer.getAlgorithm()"", ""line"": 75, ""func_name"": ""org.primeframework.jwt.JWTEncoder.encode:java.lang.String(org.primeframework.jwt.domain.JWT,org.primeframework.jwt.Signer,java.util.function.Consumer)""}, {""full_code"": ""this.algorithm = algorithm"", ""line"": 63, ""func_name"": ""org.primeframework.jwt.domain.Algorithm.<init>:void(java.lang.String)""}, {""full_code"": ""this.algorithm = algorithm"", ""line"": 46, ""func_name"": ""org.primeframework.jwt.domain.Header.<init>:void(org.primeframework.jwt.domain.Algorithm)""}, {""full_code"": ""this.algorithm = algorithm"", ""line"": 41, ""func_name"": ""org.primeframework.jwt.hmac.HMACSigner.<init>:void(org.primeframework.jwt.domain.Algorithm,java.lang.String)""}, {""full_code"": ""this.algorithm = algorithm"", ""line"": 45, ""func_name"": ""org.primeframework.jwt.rsa.RSASigner.<init>:void(org.primeframework.jwt.domain.Algorithm,java.lang.String)""}], ""struct_var"": ""algorithm"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:JWTDecoder.java, func:decode)"", ""result"": [{""code"": ""  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // Be particular about decoding an unsecured JWT. If the JWT is signed or any verifiers were provided don't do it.\n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.length == 0) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n"", ""start_line"": 60, ""end_line"": 82, ""full_name"": ""org.primeframework.jwt.JWTDecoder.decode:org.primeframework.jwt.domain.JWT(java.lang.String,org.primeframework.jwt.Verifier[])"", ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java""}, {""code"": ""  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\""kid\""));\n  }\n"", ""start_line"": 95, ""end_line"": 97, ""full_name"": ""org.primeframework.jwt.JWTDecoder.decode:org.primeframework.jwt.domain.JWT(java.lang.String,java.util.Map)"", ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java""}, {""code"": ""  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // Be particular about decoding an unsecured JWT. If the JWT is signed or any verifiers were provided don't do it.\n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.isEmpty()) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n"", ""start_line"": 112, ""end_line"": 133, ""full_name"": ""org.primeframework.jwt.JWTDecoder.decode:org.primeframework.jwt.domain.JWT(java.lang.String,java.util.Map,java.util.function.Function)"", ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java""}]}, {""source"": ""caller_info(file:JWTDecoder.java, func:decode)"", ""result"": [{""call_line"": 81, ""call_code"": ""this.decode(encodedJWT, header, parts, verifier)"", ""caller_code"": ""  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // Be particular about decoding an unsecured JWT. If the JWT is signed or any verifiers were provided don't do it.\n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.length == 0) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n"", ""caller_start"": 60, ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java""}, {""call_line"": 96, ""call_code"": ""this.decode(encodedJWT, verifiers, <lambda>)"", ""caller_code"": ""  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\""kid\""));\n  }\n"", ""caller_start"": 95, ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java""}, {""call_line"": 132, ""call_code"": ""this.decode(encodedJWT, header, parts, verifier)"", ""caller_code"": ""  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // Be particular about decoding an unsecured JWT. If the JWT is signed or any verifiers were provided don't do it.\n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.isEmpty()) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n"", ""caller_start"": 112, ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java""}, {""call_line"": 137, ""call_code"": ""Base64.getUrlDecoder().decode(bytes)"", ""caller_code"": ""  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\""The encoded JWT is not properly Base64 encoded.\"", e);\n    }\n  }\n"", ""caller_start"": 135, ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java""}]}]","In JWTDecoder.java, the original code allowed decoding a JWT with no signature (parts.length == 2) if header.algorithm == Algorithm.none and verifiers were empty (verifiers.length == 0 or verifiers.isEmpty()). Attackers could craft tokens with non-'none' algorithms but no signature, which would be decoded as valid if no verifiers were provided. The patch adds checks to enforce that if parts.length == 2 and verifiers are empty, the algorithm must be 'none'; otherwise, it throws InvalidJWTSignatureException. This logic is implemented in JWTDecoder.java:64-73 (array overload) and JWTDecoder.java:66-73 (map overload).",0.95,./github/other_context/CVE-2018-1000125
38,CVE-2018-14354,CWE-78,c_cpp,"An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with a manual subscription or unsubscription.",https://github.com/neomutt/neomutt/commit/95e80bf9ff10f68cb6443f760b85df4117cb15eb,Quote path in imap_subscribe,1,"[{""func_name"": ""imap_subscribe"", ""file_path"": ""imap/imap.c"", ""func_code"": ""int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\""Bad mailbox name\""));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \""INBOX\"", sizeof(buf));\n\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \""%smailboxes \\\""%s\\\""\"", subscribe ? \""\"" : \""un\"", path);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \""Error adding subscribed mailbox: %s\\n\"", errstr);\n    FREE(&token.data);\n  }\n\n  if (subscribe)\n    mutt_message(_(\""Subscribing to %s...\""), buf);\n  else\n    mutt_message(_(\""Unsubscribing from %s...\""), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n\n  snprintf(buf, sizeof(buf), \""%sSUBSCRIBE %s\"", subscribe ? \""\"" : \""UN\"", mbox);\n\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\""Subscribed to %s\""), mx.mbox);\n  else\n    mutt_message(_(\""Unsubscribed from %s\""), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}"", ""target"": 0}]","[{""func_name"": ""imap_subscribe"", ""file_path"": ""imap/imap.c"", ""func_code"": ""int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n  size_t len = 0;\n\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\""Bad mailbox name\""));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \""INBOX\"", sizeof(buf));\n\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n\tlen = snprintf(mbox, sizeof(mbox), \""%smailboxes \"", subscribe ? \""\"" : \""un\"");\n\timap_quote_string(mbox + len, sizeof(mbox) - len, path, true);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \""Error adding subscribed mailbox: %s\\n\"", errstr);\n    FREE(&token.data);\n  }\n\n  if (subscribe)\n    mutt_message(_(\""Subscribing to %s...\""), buf);\n  else\n    mutt_message(_(\""Unsubscribing from %s...\""), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n\n  snprintf(buf, sizeof(buf), \""%sSUBSCRIBE %s\"", subscribe ? \""\"" : \""UN\"", mbox);\n\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\""Subscribed to %s\""), mx.mbox);\n  else\n    mutt_message(_(\""Unsubscribed from %s\""), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}""}]","{""function"": 1}","[{""source"": ""func_info(func:imap_quote_string)"", ""result"": [{""code"": ""void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \""`\\\""\\\\\"";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\""';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\""';\n  *pt = '\\0';\n}"", ""start_line"": 801, ""end_line"": 832, ""full_name"": ""imap_quote_string"", ""file_path"": ""imap/util.c""}]}]","imap/imap.c:1731: Direct interpolation of 'path' into a command string via snprintf without escaping special characters like backticks. imap/util.c:801-832: imap_quote_string in the patch properly escapes backticks and quotes when quote_backtick=true, preventing injection.",0.95,./github/other_context/CVE-2018-14354
39,CVE-2018-14679,"CWE-193, CWE-20",c_cpp,"An issue was discovered in mspack/chmd.c in libmspack before 0.7alpha. There is an off-by-one error in the CHM PMGI/PMGL chunk number validity checks, which could lead to denial of service (uninitialized data dereference and application crash).",https://github.com/kyz/libmspack/commit/72e70a921f0f07fee748aec2274b30784e1d312a,Fix off-by-one bounds check on CHM PMGI/PMGL chunk numbers and\nreject empty filenames. Thanks to Hanno Böck for reporting,2,"[{""func_name"": ""read_chunk"", ""file_path"": ""libmspack/mspack/chmd.c"", ""func_code"": ""static unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *buf;\n\n    /* check arguments - most are already checked by chmd_fast_find */\n    if (chunk_num > chm->num_chunks) return NULL;\n    \n    /* ensure chunk cache is available */\n    if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    /* try to answer out of chunk cache */\n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    /* need to read chunk - allocate memory for it */\n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    /* seek to block and read it */\n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* check the signature. Is is PMGL or PMGI? */\n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* all OK. Store chunk in cache and return it */\n    return chm->chunk_cache[chunk_num] = buf;\n}"", ""target"": 0}, {""func_name"": ""chmd_read_headers"", ""file_path"": ""libmspack/mspack/chmd.c"", ""func_code"": ""static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\""incorrect GUIDs\""))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \""WARNING; CHM version > 3\"");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\""content section begins after file has ended\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\""chunk size not large enough\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\""no chunks\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\""more than 100,000 chunks\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\""chunks larger than entire file\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \""WARNING; chunk size is not a power of two\"");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \""WARNING; first PMGL chunk is not zero\"");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\""first pmgl chunk is after last pmgl chunk\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root > chm->num_chunks) {\n    D((\""index_root outside valid range\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \""WARNING; PMGL quickref area is too small\"");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \""WARNING; PMGL quickref area is too large\"");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      name = p; p += name_len;\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \""/\"" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \""invalid section number '%u'.\"", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\""chunk ended before all entries could be read\""))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}"", ""target"": 0}]","[{""func_name"": ""read_chunk"", ""file_path"": ""libmspack/mspack/chmd.c"", ""func_code"": ""static unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *buf;\n\n    /* check arguments - most are already checked by chmd_fast_find */\n    if (chunk_num >= chm->num_chunks) return NULL;\n    \n    /* ensure chunk cache is available */\n    if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    /* try to answer out of chunk cache */\n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    /* need to read chunk - allocate memory for it */\n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    /* seek to block and read it */\n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* check the signature. Is is PMGL or PMGI? */\n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* all OK. Store chunk in cache and return it */\n    return chm->chunk_cache[chunk_num] = buf;\n}""}, {""func_name"": ""chmd_read_headers"", ""file_path"": ""libmspack/mspack/chmd.c"", ""func_code"": ""static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\""incorrect GUIDs\""))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \""WARNING; CHM version > 3\"");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\""content section begins after file has ended\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\""chunk size not large enough\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\""no chunks\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\""more than 100,000 chunks\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\""chunks larger than entire file\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \""WARNING; chunk size is not a power of two\"");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \""WARNING; first PMGL chunk is not zero\"");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\""first pmgl chunk is after last pmgl chunk\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\""index_root outside valid range\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \""WARNING; PMGL quickref area is too small\"");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \""WARNING; PMGL quickref area is too large\"");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      /* consider blank filenames to be an error */\n      if (name_len == 0) goto chunk_end;\n      name = p; p += name_len;\n\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \""/\"" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \""invalid section number '%u'.\"", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\""chunk ended before all entries could be read\""))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}""}]","{""caller"": 1, ""value"": 1}","[{""source"": ""caller_info(file:chmd.c, func:read_chunk)"", ""result"": [{""call_line"": 556, ""call_code"": ""read_chunk(self, chm, fh, n)"", ""caller_code"": ""static int chmd_fast_find(struct mschm_decompressor *base,\n\t\t\t  struct mschmd_header *chm, const char *filename,\n\t\t\t  struct mschmd_file *f_ptr, int f_size)\n{\n    struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n    struct mspack_system *sys;\n    struct mspack_file *fh;\n    const unsigned char *chunk, *p, *end;\n    int err = MSPACK_ERR_OK, result = -1;\n    unsigned int n, sec;\n\n    if (!self || !chm || !f_ptr || (f_size != sizeof(struct mschmd_file))) {\n\treturn MSPACK_ERR_ARGS;\n    }\n    sys = self->system;\n\n    /* clear the results structure */\n    memset(f_ptr, 0, f_size);\n\n    if (!(fh = sys->open(sys, chm->filename, MSPACK_SYS_OPEN_READ))) {\n\treturn MSPACK_ERR_OPEN;\n    }\n\n    /* go through PMGI chunk hierarchy to reach PMGL chunk */\n    if (chm->index_root < chm->num_chunks) {\n\tn = chm->index_root;\n\tfor (;;) {\n\t    if (!(chunk = read_chunk(self, chm, fh, n))) {\n\t\tsys->close(fh);\n\t\treturn self->error;\n\t    }\n\n\t    /* search PMGI/PMGL chunk. exit early if..."", ""caller_start"": 529, ""file_path"": ""libmspack/mspack/chmd.c""}, {""call_line"": 575, ""call_code"": ""read_chunk(self, chm, fh, n)"", ""caller_code"": ""static int chmd_fast_find(struct mschm_decompressor *base,\n\t\t\t  struct mschmd_header *chm, const char *filename,\n\t\t\t  struct mschmd_file *f_ptr, int f_size)\n{\n    struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n    struct mspack_system *sys;\n    struct mspack_file *fh;\n    const unsigned char *chunk, *p, *end;\n    int err = MSPACK_ERR_OK, result = -1;\n    unsigned int n, sec;\n\n    if (!self || !chm || !f_ptr || (f_size != sizeof(struct mschmd_file))) {\n\treturn MSPACK_ERR_ARGS;\n    }\n    sys = self->system;\n\n    /* clear the results structure */\n    memset(f_ptr, 0, f_size);\n\n    if (!(fh = sys->open(sys, chm->filename, MSPACK_SYS_OPEN_READ))) {\n\treturn MSPACK_ERR_OPEN;\n    }\n\n    /* go through PMGI chunk hierarchy to reach PMGL chunk */\n    if (chm->index_root < chm->num_chunks) {\n\tn = chm->index_root;\n\tfor (;;) {\n\t    if (!(chunk = read_chunk(self, chm, fh, n))) {\n\t\tsys->close(fh);\n\t\treturn self->error;\n\t    }\n\n\t    /* search PMGI/PMGL chunk. exit early if..."", ""caller_start"": 529, ""file_path"": ""libmspack/mspack/chmd.c""}]}, {""source"": ""value_info(file:chmd.c, value:chm->num_chunks)"", ""result"": {""value_trace"": [{""full_code"": ""chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks])"", ""line"": 350, ""func_name"": ""chmd_read_headers""}], ""struct_var"": ""chm"", ""struct_type"": ""mschmd_header*"", ""struct_definition"": ""static struct mschmd_header\n\nstatic struct mschmd_header\n\nstatic struct mschmd_header\n\nstruct mschmd_header\n\nstruct mschmd_header {\n  /** The version of the CHM file format used in this file. */\n  unsigned int version;\n\n  /**\n   * The \""timestamp\"" of the CHM helpfile. \n   *\n   * It is the lower 32 bits of a 64-bit value representing the number of\n   * centiseconds since 1601-01-01 00:00:00 UTC, plus 42. It is not useful\n   * as a timestamp, but it is useful as a semi-unique ID.\n   */\n  unsigned int timestamp;\n      \n  /**\n   * The default Language and Country ID (LCID) of the user who ran the\n   * HTMLHelp Compiler. This is not the language of the CHM file itself.\n   */\n  unsigned int language;\n\n  /**\n   * The filename of the CHM helpfile. This is given by the library user\n   * and may be in any format.\n   */\n  const char *filename;\n\n  /** The length of the CHM helpfile, in bytes. */\n  off_t length;\n\n  /** A list of all non-system files in the CHM helpfile. */\n  struct mschmd_file *files;\n\n  /**\n   * A list of all system files in the CHM helpfile.\n   *\n   * System files are files which begi...\n\nstruct mschmd_header\n\nstruct mschmd_header\n\nstruct mschmd_header\n\nstruct mschmd_header\n\nstruct mschmd_header {\n  /** The version of the CHM file format used in this file. */\n  unsigned int version;\n\n  /**\n   * The \""timestamp\"" of the CHM helpfile. \n   *\n   * It is the lower 32 bits of a 64-bit value representing the number of\n   * centiseconds since 1601-01-01 00:00:00 UTC, plus 42. It is not useful\n   * as a timestamp, but it is useful as a semi-unique ID.\n   */\n  unsigned int timestamp;\n      \n  /**\n   * The default Language and Country ID (LCID) of the user who ran the\n   * HTMLHelp Compiler. This is not the language of the CHM file itself.\n   */\n  unsigned int language;\n\n  /**\n   * The filename of the CHM helpfile. This is given by the library user\n   * and may be in any format.\n   */\n  const char *filename;\n\n  /** The length of the CHM helpfile, in bytes. */\n  off_t length;\n\n  /** A list of all non-system files in the CHM helpfile. */\n  struct mschmd_file *files;\n\n  /**\n   * A list of all system files in the CHM helpfile.\n   *\n   * System files are files which begi...\n\nstruct mschmd_header\n\nstruct mschmd_header""}}]","libmspack/mspack/chmd.c:623 (original off-by-one check allowed chunk_num == num_chunks) → libmspack/mspack/chmd.c:350 (chm->num_chunks initialized from CHM file header data) → libmspack/mspack/chmd.c:556/575 (read_chunk called with chunk_num derived from chm->index_root or other CHM file-parsed values). Untrusted input in CHM files bypasses bounds checks, leading to invalid chunk reads and uninitialized data dereference.",0.95,./github/other_context/CVE-2018-14679
40,CVE-2018-25084,CWE-79,java,"A vulnerability, which was classified as problematic, has been found in Ping Identity Self-Service Account Manager 1.1.2. Affected by this issue is some unknown functionality of the file src/main/java/com/unboundid/webapp/ssam/SSAMController.java. The manipulation leads to cross site scripting. The attack may be launched remotely. Upgrading to version 1.1.3 is able to address this issue. The patch is identified as f64b10d63bb19ca2228b0c2d561a1a6e5a3bf251. It is recommended to upgrade the affected component. VDB-225362 is the identifier assigned to this vulnerability.",https://github.com/pingidentity/ssam/commit/f64b10d63bb19ca2228b0c2d561a1a6e5a3bf251,Added html escaping to help with XSS. Added frame busting to help with XFS. Added a method override filter so that only GETs and POSTs are accepted. Disabled autocomplete for password fields. Added ability for customer to set their HPKP headers.,2,"[{""func_name"": ""populateRegistrationModel"", ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java"", ""func_code"": ""private void populateRegistrationModel(Map<String, String> parameters,\n          Model model)\n  {\n    for(Map.Entry<String, String> parameter : parameters.entrySet())\n    {\n      // handle all parameters except the password\n      String name = parameter.getKey();\n      if(!name.equals(\""userPassword\"") && !name.equals(\""_csrf\""))\n      {\n        String value = parameter.getValue().trim();\n        if(!value.isEmpty())\n        {\n          model.addAttribute(name, value);\n        }\n      }\n    }\n  }"", ""target"": 0}, {""func_name"": ""populateUserModel"", ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java"", ""func_code"": ""private void populateUserModel(String username, Entry entry, Model model)\n  {\n    model.addAttribute(\""username\"", username);\n    for(Attribute attribute : entry.getAttributes())\n    {\n      model.addAttribute(attribute.getName(), attribute.getValue());\n    }\n    model.addAttribute(\""entry\"", entry);\n  }"", ""target"": 0}]","[{""func_name"": ""populateRegistrationModel"", ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java"", ""func_code"": ""private void populateRegistrationModel(Map<String, String> parameters,\n          Model model)\n  {\n    for(Map.Entry<String, String> parameter : parameters.entrySet())\n    {\n      // handle all parameters except the password\n      String name = parameter.getKey();\n      if(!name.equals(\""userPassword\"") && !name.equals(\""_csrf\""))\n      {\n        String value = parameter.getValue().trim();\n        if(!value.isEmpty())\n        {\n          model.addAttribute(name, HtmlUtils.htmlEscape(value));\n        }\n      }\n    }\n  }""}, {""func_name"": ""populateUserModel"", ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java"", ""func_code"": ""private void populateUserModel(String username, Entry entry, Model model)\n  {\n    model.addAttribute(\""username\"", username);\n    for(Attribute attribute : entry.getAttributes())\n    {\n      model.addAttribute(attribute.getName(), HtmlUtils.htmlEscape(attribute.getValue()));\n    }\n    model.addAttribute(\""entry\"", entry);\n  }""}]","{""caller"": 2, ""value"": 2}","[{""source"": ""caller_info(file:SSAMController.java, func:populateRegistrationModel)"", ""result"": [{""call_line"": 531, ""call_code"": ""populateRegistrationModel(parameters, model)"", ""caller_code"": ""  @RequestMapping(value = \""/register\"", method = RequestMethod.POST,\n          consumes = APPLICATION_FORM_URLENCODED_VALUE)\n  public String createUser(@RequestParam Map<String, String> parameters,\n          HttpServletRequest request, HttpSession session, Model model)\n  {\n    try\n    {\n      //verify reCAPTCHA\n      verifyRecaptcha(parameters);\n\n      // construct a list of attributes for the user based on the form\n      // parameters\n      List<Attribute> attributes = new ArrayList<>();\n      for(String objectClass : settings.getObjectClasses())\n      {\n        attributes.add(new Attribute(\""objectClass\"", objectClass.trim()));\n      }\n      attributes.add(new Attribute(\""ds-pwp-account-disabled\"", \""true\""));\n      String namingAttributeName = settings.getNamingAttribute();\n      String namingAttributeValue = null;\n      for(Map.Entry<String, String> e : parameters.entrySet())\n      {\n        // only handle attributes that are defined in the schema\n        String name = e.getKey();\n        if(schema.getAttributeType(name) != null)\n        {\n          String value = e.getValue().trim();\n          if(!value.isEmpty())\n          {\n            attributes.add(new Attribute(name, value));\n          }\n          // take note of the naming attribute value for constructing the DN\n          if(name.equals(namingAttributeName))\n          {\n            namingAttributeValue = value;\n          }\n        }\n      }\n\n      // make sure that the naming attribute was found\n      if(namingAttributeValue == null)\n      {\n        model.addAttribute(\""error\"", \""A naming attribute was not provided for '\"" \n            + namingAttributeName + \""'\"");\n        model.addAttribute(\""passwordRequirements\"",\n                getPasswordRequirements(null));\n        populateRegistrationModel(parameters, model);\n        return \""register\"";\n      }\n      \n      // create and add the user entry\n      DN dn = new DN(new RDN(namingAttributeName, namingAttributeValue), baseDN);\n      Entry entry = new Entry(dn, attributes);\n      LDAPResult result = pool.add(entry);\n      ResultCode resultCode = result.getResultCode();\n      if(resultCode != ResultCode.SUCCESS)\n      {\n        model.addAttribute(\""error\"", resultCode + \"" - \"" \n            + result.getDiagnosticMessage());\n        model.addAttribute(\""passwordRequirements\"",\n                getPasswordRequirements(null));\n        populateRegistrationModel(parameters, model);\n        return \""register\"";\n      }\n      \n      // send a single use token with a registration code\n      DeliverRegistrationCodeResult codeResult = deliverRegistrationCode(\n              entry.getDN());\n      \n      // put the DN in the session\n      session.setAttribute(\""userDN\"", dn.toString());\n      // put the code result in the session and model\n      session.setAttribute(\""result\"", codeResult);\n      model.addAttribute(\""result\"", codeResult);\n      \n      return \""registration-verify\"";\n    }\n    catch(LDAPException e)\n    {\n      log.error(\""Encountered error creating user\"", e);\n      model.addAttribute(\""error\"", e.getMessage());\n      model.addAttribute(\""passwordRequirements\"", getPasswordRequirements(null));\n      populateRegistrationModel(parameters, model);\n      return \""register\"";\n    }\n    catch(WebApplicationException e)\n    {\n      log.error(e.getMessage(), e);\n      // add an accessible error to the model\n      model.addAttribute(\""error\"", e.getMessage());\n      model.addAttribute(\""passwordRequirements\"", getPasswordRequirements(null));\n      populateRegistrationModel(parameters, model);\n      return \""register\"";\n    }\n  }\n"", ""caller_start"": 485, ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java""}, {""call_line"": 546, ""call_code"": ""populateRegistrationModel(parameters, model)"", ""caller_code"": ""  @RequestMapping(value = \""/register\"", method = RequestMethod.POST,\n          consumes = APPLICATION_FORM_URLENCODED_VALUE)\n  public String createUser(@RequestParam Map<String, String> parameters,\n          HttpServletRequest request, HttpSession session, Model model)\n  {\n    try\n    {\n      //verify reCAPTCHA\n      verifyRecaptcha(parameters);\n\n      // construct a list of attributes for the user based on the form\n      // parameters\n      List<Attribute> attributes = new ArrayList<>();\n      for(String objectClass : settings.getObjectClasses())\n      {\n        attributes.add(new Attribute(\""objectClass\"", objectClass.trim()));\n      }\n      attributes.add(new Attribute(\""ds-pwp-account-disabled\"", \""true\""));\n      String namingAttributeName = settings.getNamingAttribute();\n      String namingAttributeValue = null;\n      for(Map.Entry<String, String> e : parameters.entrySet())\n      {\n        // only handle attributes that are defined in the schema\n        String name = e.getKey();\n        if(schema.getAttributeType(name) != null)\n        {\n          String value = e.getValue().trim();\n          if(!value.isEmpty())\n          {\n            attributes.add(new Attribute(name, value));\n          }\n          // take note of the naming attribute value for constructing the DN\n          if(name.equals(namingAttributeName))\n          {\n            namingAttributeValue = value;\n          }\n        }\n      }\n\n      // make sure that the naming attribute was found\n      if(namingAttributeValue == null)\n      {\n        model.addAttribute(\""error\"", \""A naming attribute was not provided for '\"" \n            + namingAttributeName + \""'\"");\n        model.addAttribute(\""passwordRequirements\"",\n                getPasswordRequirements(null));\n        populateRegistrationModel(parameters, model);\n        return \""register\"";\n      }\n      \n      // create and add the user entry\n      DN dn = new DN(new RDN(namingAttributeName, namingAttributeValue), baseDN);\n      Entry entry = new Entry(dn, attributes);\n      LDAPResult result = pool.add(entry);\n      ResultCode resultCode = result.getResultCode();\n      if(resultCode != ResultCode.SUCCESS)\n      {\n        model.addAttribute(\""error\"", resultCode + \"" - \"" \n            + result.getDiagnosticMessage());\n        model.addAttribute(\""passwordRequirements\"",\n                getPasswordRequirements(null));\n        populateRegistrationModel(parameters, model);\n        return \""register\"";\n      }\n      \n      // send a single use token with a registration code\n      DeliverRegistrationCodeResult codeResult = deliverRegistrationCode(\n              entry.getDN());\n      \n      // put the DN in the session\n      session.setAttribute(\""userDN\"", dn.toString());\n      // put the code result in the session and model\n      session.setAttribute(\""result\"", codeResult);\n      model.addAttribute(\""result\"", codeResult);\n      \n      return \""registration-verify\"";\n    }\n    catch(LDAPException e)\n    {\n      log.error(\""Encountered error creating user\"", e);\n      model.addAttribute(\""error\"", e.getMessage());\n      model.addAttribute(\""passwordRequirements\"", getPasswordRequirements(null));\n      populateRegistrationModel(parameters, model);\n      return \""register\"";\n    }\n    catch(WebApplicationException e)\n    {\n      log.error(e.getMessage(), e);\n      // add an accessible error to the model\n      model.addAttribute(\""error\"", e.getMessage());\n      model.addAttribute(\""passwordRequirements\"", getPasswordRequirements(null));\n      populateRegistrationModel(parameters, model);\n      return \""register\"";\n    }\n  }\n"", ""caller_start"": 485, ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java""}, {""call_line"": 567, ""call_code"": ""populateRegistrationModel(parameters, model)"", ""caller_code"": ""  @RequestMapping(value = \""/register\"", method = RequestMethod.POST,\n          consumes = APPLICATION_FORM_URLENCODED_VALUE)\n  public String createUser(@RequestParam Map<String, String> parameters,\n          HttpServletRequest request, HttpSession session, Model model)\n  {\n    try\n    {\n      //verify reCAPTCHA\n      verifyRecaptcha(parameters);\n\n      // construct a list of attributes for the user based on the form\n      // parameters\n      List<Attribute> attributes = new ArrayList<>();\n      for(String objectClass : settings.getObjectClasses())\n      {\n        attributes.add(new Attribute(\""objectClass\"", objectClass.trim()));\n      }\n      attributes.add(new Attribute(\""ds-pwp-account-disabled\"", \""true\""));\n      String namingAttributeName = settings.getNamingAttribute();\n      String namingAttributeValue = null;\n      for(Map.Entry<String, String> e : parameters.entrySet())\n      {\n        // only handle attributes that are defined in the schema\n        String name = e.getKey();\n        if(schema.getAttributeType(name) != null)\n        {\n          String value = e.getValue().trim();\n          if(!value.isEmpty())\n          {\n            attributes.add(new Attribute(name, value));\n          }\n          // take note of the naming attribute value for constructing the DN\n          if(name.equals(namingAttributeName))\n          {\n            namingAttributeValue = value;\n          }\n        }\n      }\n\n      // make sure that the naming attribute was found\n      if(namingAttributeValue == null)\n      {\n        model.addAttribute(\""error\"", \""A naming attribute was not provided for '\"" \n            + namingAttributeName + \""'\"");\n        model.addAttribute(\""passwordRequirements\"",\n                getPasswordRequirements(null));\n        populateRegistrationModel(parameters, model);\n        return \""register\"";\n      }\n      \n      // create and add the user entry\n      DN dn = new DN(new RDN(namingAttributeName, namingAttributeValue), baseDN);\n      Entry entry = new Entry(dn, attributes);\n      LDAPResult result = pool.add(entry);\n      ResultCode resultCode = result.getResultCode();\n      if(resultCode != ResultCode.SUCCESS)\n      {\n        model.addAttribute(\""error\"", resultCode + \"" - \"" \n            + result.getDiagnosticMessage());\n        model.addAttribute(\""passwordRequirements\"",\n                getPasswordRequirements(null));\n        populateRegistrationModel(parameters, model);\n        return \""register\"";\n      }\n      \n      // send a single use token with a registration code\n      DeliverRegistrationCodeResult codeResult = deliverRegistrationCode(\n              entry.getDN());\n      \n      // put the DN in the session\n      session.setAttribute(\""userDN\"", dn.toString());\n      // put the code result in the session and model\n      session.setAttribute(\""result\"", codeResult);\n      model.addAttribute(\""result\"", codeResult);\n      \n      return \""registration-verify\"";\n    }\n    catch(LDAPException e)\n    {\n      log.error(\""Encountered error creating user\"", e);\n      model.addAttribute(\""error\"", e.getMessage());\n      model.addAttribute(\""passwordRequirements\"", getPasswordRequirements(null));\n      populateRegistrationModel(parameters, model);\n      return \""register\"";\n    }\n    catch(WebApplicationException e)\n    {\n      log.error(e.getMessage(), e);\n      // add an accessible error to the model\n      model.addAttribute(\""error\"", e.getMessage());\n      model.addAttribute(\""passwordRequirements\"", getPasswordRequirements(null));\n      populateRegistrationModel(parameters, model);\n      return \""register\"";\n    }\n  }\n"", ""caller_start"": 485, ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java""}, {""call_line"": 576, ""call_code"": ""populateRegistrationModel(parameters, model)"", ""caller_code"": ""  @RequestMapping(value = \""/register\"", method = RequestMethod.POST,\n          consumes = APPLICATION_FORM_URLENCODED_VALUE)\n  public String createUser(@RequestParam Map<String, String> parameters,\n          HttpServletRequest request, HttpSession session, Model model)\n  {\n    try\n    {\n      //verify reCAPTCHA\n      verifyRecaptcha(parameters);\n\n      // construct a list of attributes for the user based on the form\n      // parameters\n      List<Attribute> attributes = new ArrayList<>();\n      for(String objectClass : settings.getObjectClasses())\n      {\n        attributes.add(new Attribute(\""objectClass\"", objectClass.trim()));\n      }\n      attributes.add(new Attribute(\""ds-pwp-account-disabled\"", \""true\""));\n      String namingAttributeName = settings.getNamingAttribute();\n      String namingAttributeValue = null;\n      for(Map.Entry<String, String> e : parameters.entrySet())\n      {\n        // only handle attributes that are defined in the schema\n        String name = e.getKey();\n        if(schema.getAttributeType(name) != null)\n        {\n          String value = e.getValue().trim();\n          if(!value.isEmpty())\n          {\n            attributes.add(new Attribute(name, value));\n          }\n          // take note of the naming attribute value for constructing the DN\n          if(name.equals(namingAttributeName))\n          {\n            namingAttributeValue = value;\n          }\n        }\n      }\n\n      // make sure that the naming attribute was found\n      if(namingAttributeValue == null)\n      {\n        model.addAttribute(\""error\"", \""A naming attribute was not provided for '\"" \n            + namingAttributeName + \""'\"");\n        model.addAttribute(\""passwordRequirements\"",\n                getPasswordRequirements(null));\n        populateRegistrationModel(parameters, model);\n        return \""register\"";\n      }\n      \n      // create and add the user entry\n      DN dn = new DN(new RDN(namingAttributeName, namingAttributeValue), baseDN);\n      Entry entry = new Entry(dn, attributes);\n      LDAPResult result = pool.add(entry);\n      ResultCode resultCode = result.getResultCode();\n      if(resultCode != ResultCode.SUCCESS)\n      {\n        model.addAttribute(\""error\"", resultCode + \"" - \"" \n            + result.getDiagnosticMessage());\n        model.addAttribute(\""passwordRequirements\"",\n                getPasswordRequirements(null));\n        populateRegistrationModel(parameters, model);\n        return \""register\"";\n      }\n      \n      // send a single use token with a registration code\n      DeliverRegistrationCodeResult codeResult = deliverRegistrationCode(\n              entry.getDN());\n      \n      // put the DN in the session\n      session.setAttribute(\""userDN\"", dn.toString());\n      // put the code result in the session and model\n      session.setAttribute(\""result\"", codeResult);\n      model.addAttribute(\""result\"", codeResult);\n      \n      return \""registration-verify\"";\n    }\n    catch(LDAPException e)\n    {\n      log.error(\""Encountered error creating user\"", e);\n      model.addAttribute(\""error\"", e.getMessage());\n      model.addAttribute(\""passwordRequirements\"", getPasswordRequirements(null));\n      populateRegistrationModel(parameters, model);\n      return \""register\"";\n    }\n    catch(WebApplicationException e)\n    {\n      log.error(e.getMessage(), e);\n      // add an accessible error to the model\n      model.addAttribute(\""error\"", e.getMessage());\n      model.addAttribute(\""passwordRequirements\"", getPasswordRequirements(null));\n      populateRegistrationModel(parameters, model);\n      return \""register\"";\n    }\n  }\n"", ""caller_start"": 485, ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java""}]}, {""source"": ""caller_info(file:SSAMController.java, func:populateUserModel)"", ""result"": [{""call_line"": 206, ""call_code"": ""populateUserModel(username, entry, model)"", ""caller_code"": ""  @RequestMapping({ \""/\"", \""/user\"" })\n  public String getUser(Model model)\n  {\n    // search for the user and put the user entry and attributes into the model\n    String username = SecurityContextHolder.getContext().getAuthentication()\n            .getName();\n    try\n    {\n      Entry entry = getUserEntry();\n      populateUserModel(username, entry, model);\n      // insert password requirements to use in the user view\n      model.addAttribute(\""passwordRequirements\"",\n              getPasswordRequirements(entry.getDN()));\n      return \""user\"";\n    }\n    catch(LDAPException e)\n    {\n      // if we can't get the entry, just display the error page\n      model.addAttribute(\""error\"", e.getMessage());\n      return \""error\"";\n    }\n  }\n"", ""caller_start"": 197, ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java""}, {""call_line"": 276, ""call_code"": ""populateUserModel(username, targetEntry, model)"", ""caller_code"": ""  @RequestMapping(value = \""/user\"", method = RequestMethod.POST,\n          consumes = APPLICATION_FORM_URLENCODED_VALUE)\n  public String updateUser(@RequestParam Map<String, String> parameters,\n          Model model)\n  {\n    String username = SecurityContextHolder.getContext().getAuthentication()\n            .getName();\n    Entry targetEntry = null;\n    try\n    {\n      // get the currently authenticated user's entry and make a copy of it with\n      // the provided changes\n      Entry sourceEntry = getUserEntry();\n      model.addAttribute(\""passwordRequirements\"",\n              getPasswordRequirements(sourceEntry.getDN()));\n      targetEntry = sourceEntry.duplicate();\n      for(Map.Entry<String, String> e : parameters.entrySet())\n      {\n        // only handle attributes defined in the schema\n        String attribute = e.getKey();\n        if(schema.getAttributeType(attribute) != null)\n        {\n          // either remove the value from the entry or update it\n          String value = e.getValue().trim();\n          if(\""\"".equals(value))\n          {\n            targetEntry.removeAttribute(attribute);\n          }\n          else\n          {\n            targetEntry.setAttribute(attribute, value);\n          }\n        }\n      }\n\n      // get the modifications required to update the entry and apply them\n      List<Modification> mods = Entry.diff(sourceEntry, targetEntry, true);\n      if(!mods.isEmpty())\n      {\n        ModifyRequest request = new ModifyRequest(sourceEntry.getDN(), mods);\n        request.addControl(getIntermediateClientRequestControl());\n        pool.modify(sourceEntry.getDN(), mods);\n      }\n      populateUserModel(username, targetEntry, model);\n      model.addAttribute(\""success\"", \""User changes were successfully saved.\"");\n    }\n    catch(LDAPException e)\n    {\n      // if we couldn't even get the entry, something bad happened, so return\n      // the error view\n      model.addAttribute(\""error\"", e.getMessage());\n      if(targetEntry == null)\n      {\n        model.addAttribute(\""username\"", username);\n        return \""error\"";\n      }\n\n      // there was some sort of error encountered, probably when trying to\n      // modify the entry, so populate the model with everything needed to\n      // render the \""user\"" view\n      Map<String, String> modelParameters = new HashMap<>(parameters);\n      modelParameters.remove(\""_csrf\"");\n      model.addAllAttributes(modelParameters);\n      populateUserModel(username, targetEntry, model);\n    }\n    return \""user\"";\n  }\n"", ""caller_start"": 233, ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java""}, {""call_line"": 296, ""call_code"": ""populateUserModel(username, targetEntry, model)"", ""caller_code"": ""  @RequestMapping(value = \""/user\"", method = RequestMethod.POST,\n          consumes = APPLICATION_FORM_URLENCODED_VALUE)\n  public String updateUser(@RequestParam Map<String, String> parameters,\n          Model model)\n  {\n    String username = SecurityContextHolder.getContext().getAuthentication()\n            .getName();\n    Entry targetEntry = null;\n    try\n    {\n      // get the currently authenticated user's entry and make a copy of it with\n      // the provided changes\n      Entry sourceEntry = getUserEntry();\n      model.addAttribute(\""passwordRequirements\"",\n              getPasswordRequirements(sourceEntry.getDN()));\n      targetEntry = sourceEntry.duplicate();\n      for(Map.Entry<String, String> e : parameters.entrySet())\n      {\n        // only handle attributes defined in the schema\n        String attribute = e.getKey();\n        if(schema.getAttributeType(attribute) != null)\n        {\n          // either remove the value from the entry or update it\n          String value = e.getValue().trim();\n          if(\""\"".equals(value))\n          {\n            targetEntry.removeAttribute(attribute);\n          }\n          else\n          {\n            targetEntry.setAttribute(attribute, value);\n          }\n        }\n      }\n\n      // get the modifications required to update the entry and apply them\n      List<Modification> mods = Entry.diff(sourceEntry, targetEntry, true);\n      if(!mods.isEmpty())\n      {\n        ModifyRequest request = new ModifyRequest(sourceEntry.getDN(), mods);\n        request.addControl(getIntermediateClientRequestControl());\n        pool.modify(sourceEntry.getDN(), mods);\n      }\n      populateUserModel(username, targetEntry, model);\n      model.addAttribute(\""success\"", \""User changes were successfully saved.\"");\n    }\n    catch(LDAPException e)\n    {\n      // if we couldn't even get the entry, something bad happened, so return\n      // the error view\n      model.addAttribute(\""error\"", e.getMessage());\n      if(targetEntry == null)\n      {\n        model.addAttribute(\""username\"", username);\n        return \""error\"";\n      }\n\n      // there was some sort of error encountered, probably when trying to\n      // modify the entry, so populate the model with everything needed to\n      // render the \""user\"" view\n      Map<String, String> modelParameters = new HashMap<>(parameters);\n      modelParameters.remove(\""_csrf\"");\n      model.addAllAttributes(modelParameters);\n      populateUserModel(username, targetEntry, model);\n    }\n    return \""user\"";\n  }\n"", ""caller_start"": 233, ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java""}, {""call_line"": 426, ""call_code"": ""populateUserModel(authentication.getName(), getUserEntry(), model)"", ""caller_code"": ""  @RequestMapping(value = \""/deleteUser\"", method = RequestMethod.POST,\n      consumes = APPLICATION_FORM_URLENCODED_VALUE)\n  public String deleteUser(HttpSession session, Model model)\n  {\n    Authentication authentication = SecurityContextHolder.getContext()\n            .getAuthentication();\n    try \n    {\n      // The current code will fail if there are child entries under the current\n      // user. In order to successfully delete those accounts, a subtree delete\n      // request control may be used to handle the situation.\n      // At the moment, there is no need for a subtree delete request control.\n\n      // request deletion of currently authenticated user\n      Object userDetails = authentication.getPrincipal();\n      \n      if(userDetails instanceof LDAPUser \n          && !StringUtils.isEmpty(((LDAPUser) userDetails).getDN()))\n      {\n        pool.delete(((LDAPUser) userDetails).getDN());  \n      }\n      else \n      {\n        pool.delete(getUserEntry().getDN());\n      }\n      // deletion successful if this is reached\n      if(!pingActive())\n      {\n        // invalidate the session to mimic LDAP logout\n        session.invalidate();\n      }\n      return \""deletion-success\"";\n    }\n    catch (LDAPException e)\n    {\n      log.error(e.getDiagnosticMessage(), HttpStatus.INTERNAL_SERVER_ERROR);\n      model.addAttribute(\""error\"", \""There was an error deleting the account.\"");\n      try\n      {\n        populateUserModel(authentication.getName(), getUserEntry(), model);\n      }\n      catch(LDAPException le)\n      {\n        log.error(\""Could not populate user model\"", e);\n      }\n      return \""user\"";\n    }\n  }\n"", ""caller_start"": 387, ""file_path"": ""src/main/java/com/unboundid/webapp/ssam/SSAMController.java""}]}, {""source"": ""value_info(file:SSAMController.java, value:parameter)"", ""result"": {""value_trace"": [{""full_code"": ""<empty>"", ""line"": 983, ""func_name"": ""com.unboundid.webapp.ssam.SSAMController.populateRegistrationModel:void(java.util.Map,org.springframework.ui.Model)""}], ""struct_var"": ""parameter"", ""struct_type"": ""java.util.Map$Entry"", ""struct_definition"": null}}, {""source"": ""value_info(file:SSAMController.java, value:attribute)"", ""result"": {""value_trace"": [{""full_code"": ""String attribute = e.getKey()"", ""line"": 252, ""func_name"": ""com.unboundid.webapp.ssam.SSAMController.updateUser:java.lang.String(java.util.Map,org.springframework.ui.Model)""}, {""full_code"": ""<empty>"", ""line"": 972, ""func_name"": ""com.unboundid.webapp.ssam.SSAMController.populateUserModel:void(java.lang.String,com.unboundid.ldap.sdk.Entry,org.springframework.ui.Model)""}], ""struct_var"": ""attribute"", ""struct_type"": ""java.lang.String"", ""struct_definition"": null}}]","Unescaped user input in model.addAttribute() (SSAMController.java:990, 972) allowed XSS. Data flow chain:\n1. User input arrives via @RequestParam Map parameters in /register (SSAMController.java:485-576) and /user (SSAMController.java:233-296) endpoints\n2. Parameters are processed directly from HTTP form data (createUser(), updateUser())\n3. Values from parameters.entrySet() and attribute.getValue() (LDAP Entry attributes derived from prior user inputs) are added to Spring Model without escaping\n4. These model attributes are rendered in HTML views without additional sanitization",0.95,./github/other_context/CVE-2018-25084
41,CVE-2019-10182,"CWE-345, CWE-94, CWE-22",java,It was found that icedtea-web though 1.7.2 and 1.8.2 did not properly sanitize paths from <jar/> elements in JNLP files. An attacker could trick a victim into running a specially crafted application and use this flaw to upload arbitrary files to arbitrary locations in the context of the user.,https://github.com/AdoptOpenJDK/IcedTea-Web/commit/2ab070cdac087bd208f64fa8138bb709f8d7680c,Fixed bug when relative path (..) could leak up (even out of cache) - CVE-2019-10182\n\n* netx/net/sourceforge/jnlp/cache/CacheUtil.java: if path or query contains .. is saved to cache via its hash\n* netx/net/sourceforge/jnlp/util/FileUtils.java: added warning about different behavior on win/linux\n* tests/netx/unit/net/sourceforge/jnlp/cache/CacheUtilTest.java: added tests for hashing\n* tests/netx/unit/net/sourceforge/jnlp/runtime/JNLPClassLoaderTest.java:  added test for .. in path. Added test that verifies encoded .. (%2E%2E) do not leak from cahce\n* tests/netx/unit/net/sourceforge/jnlp/runtime/up.jnlp: example jnlp with .. full url\n* tests/netx/unit/net/sourceforge/jnlp/runtime/up.jnlp: example jnlp with encoded ..,5,"[{""func_name"": ""createParentDir"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/util/FileUtils.java"", ""func_code"": ""public static void createParentDir(File f, String eMsg) throws IOException {\n        File parent = f.getParentFile();\n        if (!parent.isDirectory() && !parent.mkdirs()) {\n            throw new IOException(\""Cant create directory \"" + (eMsg == null ? parent : eMsg));\n        }\n    }"", ""target"": 0}, {""func_name"": ""urlToPath"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java"", ""func_code"": ""public static File urlToPath(URL location, String subdir) {\n        if (subdir == null) {\n            throw new NullPointerException();\n        }\n\n        StringBuilder path = new StringBuilder();\n\n        path.append(subdir);\n        path.append(File.separatorChar);\n\n        path.append(location.getProtocol());\n        path.append(File.separatorChar);\n        path.append(location.getHost());\n        path.append(File.separatorChar);\n        /**\n         * This is a bit of imprecise. The usage of default port would be\n         * better, but it would cause terrible backward incompatibility.\n         */\n        if (location.getPort() > 0) {\n            path.append(location.getPort());\n            path.append(File.separatorChar);\n        }\n        path.append(location.getPath().replace('/', File.separatorChar));\n        if (location.getQuery() != null && !location.getQuery().trim().isEmpty()) {\n            path.append(\"".\"").append(location.getQuery());\n        }\n\n        File candidate = new File(FileUtils.sanitizePath(path.toString()));\n        if (candidate.getName().length() > 255) {\n            /**\n             * When filename is longer then 255 chars, then then various\n             * filesystems have issues to save it. By saving the file by its\n             * sum, we are trying to prevent collision of two files differs in\n             * suffixes (general suffix of name, not only 'filetype suffix')\n             * only. It is also preventing bug when truncate (files with 1000\n             * chars hash in query) cuts to much.\n             */\n            try {\n                MessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n                byte[] sum = md.digest(candidate.getName().getBytes(UTF_8));\n                //convert the byte to hex format method 2\n                StringBuilder hexString = new StringBuilder();\n                for (int i = 0; i < sum.length; i++) {\n                    hexString.append(Integer.toHexString(0xFF & sum[i]));\n                }\n                String extension = \""\"";\n                int i = candidate.getName().lastIndexOf('.');\n                if (i > 0) {\n                    extension = candidate.getName().substring(i);//contains dot\n                }\n                if (extension.length() < 10 && extension.length() > 1) {\n                    hexString.append(extension);\n                }\n                candidate = new File(candidate.getParentFile(), hexString.toString());\n            } catch (NoSuchAlgorithmException ex) {\n                // should not occur, cite from javadoc:\n                // every java implementation should support\n                // MD5 SHA-1 SHA-256\n                throw new RuntimeException(ex);\n            }\n        }\n        return candidate;\n    }"", ""target"": 0}, {""func_name"": ""isMetaInfFile"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/tools/JarCertVerifier.java"", ""func_code"": ""static boolean isMetaInfFile(String name) {\n        String ucName = name.toUpperCase();\n        return ucName.startsWith(META_INF);\n    }"", ""target"": 0}, {""func_name"": ""activateJars"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/runtime/JNLPClassLoader.java"", ""func_code"": ""protected void activateJars(final List<JARDesc> jars) {\n        PrivilegedAction<Void> activate = new PrivilegedAction<Void>() {\n\n            @SuppressWarnings(\""deprecation\"")\n            @Override\n            public Void run() {\n                // transfer the Jars\n                waitForJars(jars);\n\n                for (JARDesc jar : jars) {\n                    available.remove(jar);\n\n                    // add jar\n                    File localFile = tracker.getCacheFile(jar.getLocation());\n                    try {\n                        URL location = jar.getLocation(); // non-cacheable, use source location\n                        if (localFile != null) {\n                            // TODO: Should be toURI().toURL()\n                            location = localFile.toURL(); // cached file\n                            // This is really not the best way.. but we need some way for\n                            // PluginAppletViewer::getCachedImageRef() to check if the image\n                            // is available locally, and it cannot use getResources() because\n                            // that prefetches the resource, which confuses MediaTracker.waitForAll()\n                            // which does a wait(), waiting for notification (presumably\n                            // thrown after a resource is fetched). This bug manifests itself\n                            // particularly when using The FileManager applet from Webmin.\n                            try (JarFile jarFile = new JarFile(localFile)) {\n                                for (JarEntry je : Collections.list(jarFile.entries())) {\n\n                                    // another jar in my jar? it is more likely than you think\n                                    if (je.getName().endsWith(\"".jar\"")) {\n                                        // We need to extract that jar so that it can be loaded\n                                        // (inline loading with \""jar:..!/...\"" path will not work\n                                        // with standard classloader methods)\n\n                                        String extractedJarLocation = localFile + \"".nested/\"" + je.getName();\n                                        File parentDir = new File(extractedJarLocation).getParentFile();\n                                        if (!parentDir.isDirectory() && !parentDir.mkdirs()) {\n                                            throw new RuntimeException(\""Unable to extract nested jar.\"");\n                                        }\n                                        FileOutputStream extractedJar = new FileOutputStream(extractedJarLocation);\n                                        InputStream is = jarFile.getInputStream(je);\n\n                                        byte[] bytes = new byte[1024];\n                                        int read = is.read(bytes);\n                                        int fileSize = read;\n                                        while (read > 0) {\n                                            extractedJar.write(bytes, 0, read);\n                                            read = is.read(bytes);\n                                            fileSize += read;\n                                        }\n\n                                        is.close();\n                                        extractedJar.close();\n\n                                        // 0 byte file? skip\n                                        if (fileSize <= 0) {\n                                            continue;\n                                        }\n\n                                        tracker.addResource(new File(extractedJarLocation).toURL(), null, null, null);\n\n                                        URL codebase = file.getCodeBase();\n                                        if (codebase == null) {\n                                            //FIXME: codebase should be the codebase of the Main Jar not\n                                            //the location. Although, it still works in the current state.\n                                            codebase = file.getResources().getMainJAR().getLocation();\n                                        }\n\n                                        final SecurityDesc jarSecurity = securityDelegate.getJarPermissions(codebase);\n\n                                        try {\n                                            URL fileURL = new URL(\""file://\"" + extractedJarLocation);\n                                            // there is no remote URL for this, so lets fake one\n                                            URL fakeRemote = new URL(jar.getLocation().toString() + \""!\"" + je.getName());\n                                            CachedJarFileCallback.getInstance().addMapping(fakeRemote, fileURL);\n                                            addURL(fakeRemote);\n\n                                            jarLocationSecurityMap.put(fakeRemote, jarSecurity);\n\n                                        } catch (MalformedURLException mfue) {\n                                            LOG.error(\""Unable to add extracted nested jar to classpath\"", mfue);\n                                        }\n                                    }\n\n                                    jarEntries.add(je.getName());\n                                }\n                            }\n                        }\n\n                        addURL(jar.getLocation());\n\n                        // there is currently no mechanism to cache files per\n                        // instance.. so only index cached files\n                        if (localFile != null) {\n                            CachedJarFileCallback.getInstance().addMapping(jar.getLocation(), localFile.toURI().toURL());\n\n                            try (JarFile jarFile = new JarFile(localFile.getAbsolutePath())) {\n                                Manifest mf = jarFile.getManifest();\n\n                                // Only check classpath if this is the plugin and there is no jnlp_href usage.\n                                // Note that this is different from proprietary plugin behaviour.\n                                // If jnlp_href is used, the app should be treated similarly to when\n                                // it is run from javaws as a webstart.\n                                if (file instanceof PluginBridge && !((PluginBridge) file).useJNLPHref()) {\n                                    classpaths.addAll(ManifestAttributesReader.getClassPaths(mf, jar.getLocation()));\n                                }\n\n                                JarIndexAccess index = JarIndexAccess.getJarIndex(jarFile);\n                                if (index != null) {\n                                    jarIndexes.add(index);\n                                }\n                            }\n                        } else {\n                            CachedJarFileCallback.getInstance().addMapping(jar.getLocation(), jar.getLocation());\n                        }\n\n                        LOG.debug(\""Activate jar: {}\"", location);\n                    } catch (Exception ex) {\n                        LOG.error(IcedTeaWebConstants.DEFAULT_ERROR_MESSAGE, ex);\n                    }\n\n                    // some programs place a native library in any jar\n                    nativeLibraryStorage.addSearchJar(jar.getLocation());\n                }\n\n                return null;\n            }\n        };\n\n        AccessController.doPrivileged(activate, acc);\n    }"", ""target"": 0}, {""func_name"": ""hex"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java"", ""func_code"": ""private static String hex(String origName, String candidate) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n        byte[] sum = md.digest(candidate.getBytes(UTF_8));\n        //convert the byte to hex format method 2\n        StringBuilder hexString = new StringBuilder();\n        for (int i = 0; i < sum.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & sum[i]));\n        }\n        String extension = \""\"";\n        int i = origName.lastIndexOf('.');\n        if (i > 0) {\n            extension = origName.substring(i);//contains dot\n        }\n        if (extension.length() < 10 && extension.length() > 1) {\n            hexString.append(extension);\n        }\n        return hexString.toString();\n    }"", ""target"": 0}]","[{""func_name"": ""createParentDir"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/util/FileUtils.java"", ""func_code"": ""public static void createParentDir(File f, String eMsg) throws IOException {\n        File parent = f.getParentFile();\n        // warning, linux and windows behave differently. Below snippet will pass on win(security hole), fail on linux\n        // warning  mkdir is canonicaling, but exists/isDirectory is not. So  where mkdirs return true, and really creates dir, isDirectory can still return false\n        // can be seen on this example\n        // mkdirs /a/b/../c\n        // where b do not exists will lead creation of /a/c\n        // but exists on /a/b/../c is false on linux  even afterwards\n        // without hexing of .. paths,\n        if (!parent.isDirectory() && !parent.mkdirs()) {\n            throw new IOException(\""Cant create directory \"" + (eMsg == null ? parent : eMsg));\n        }\n    }""}, {""func_name"": ""urlToPath"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java"", ""func_code"": ""public static File urlToPath(URL location, String subdir) {\n        if (subdir == null) {\n            throw new NullPointerException();\n        }\n\n        StringBuilder path = new StringBuilder();\n\n        path.append(subdir);\n        path.append(File.separatorChar);\n\n        path.append(location.getProtocol());\n        path.append(File.separatorChar);\n        path.append(location.getHost());\n        path.append(File.separatorChar);\n        /**\n         * This is a bit of imprecise. The usage of default port would be\n         * better, but it would cause terrible backward incompatibility.\n         */\n        if (location.getPort() > 0) {\n            path.append(location.getPort());\n            path.append(File.separatorChar);\n        }\n        String locationPath = location.getPath().replace('/', File.separatorChar);\n        String query = \""\"";\n        if (location.getQuery() != null) {\n            query = location.getQuery();\n        }\n        if (locationPath.contains(\""..\"") || query.contains(\""..\"")){\n            try {\n                /**\n                 * if path contains .. then it can harm lcoal system\n                 * So without mercy, hash it\n                 */\n                String hexed = hex(new File(locationPath).getName(), locationPath);\n                return new File(path.toString(), hexed.toString());\n            } catch (NoSuchAlgorithmException ex) {\n                // should not occur, cite from javadoc:\n                // every java implementation should support\n                // MD5 SHA-1 SHA-256\n                throw new RuntimeException(ex);\n            }\n        } else {\n            path.append(locationPath);\n            if (location.getQuery() != null && !location.getQuery().trim().isEmpty()) {\n                path.append(\"".\"").append(location.getQuery());\n            }\n\n            File candidate = new File(FileUtils.sanitizePath(path.toString()));\n            try {\n                if (candidate.getName().length() > 255) {\n                    /**\n                     * When filename is longer then 255 chars, then then various\n                     * filesystems have issues to save it. By saving the file by its\n                     * sum, we are trying to prevent collision of two files differs in\n                     * suffixes (general suffix of name, not only 'filetype suffix')\n                     * only. It is also preventing bug when truncate (files with 1000\n                     * chars hash in query) cuts to much.\n                     */\n                    String hexed = hex(candidate.getName(), candidate.getName());\n                    candidate = new File(candidate.getParentFile(), hexed.toString());\n                }\n            } catch (NoSuchAlgorithmException ex) {\n                // should not occur, cite from javadoc:\n                // every java implementation should support\n                // MD5 SHA-1 SHA-256\n                throw new RuntimeException(ex);\n            }\n            return candidate;\n        }\n    }""}, {""func_name"": ""isMetaInfFile"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/tools/JarCertVerifier.java"", ""func_code"": ""static boolean isMetaInfFile(String name) {\n        if (name.endsWith(\""class\"")) {\n            return false;\n        }\n        return name.startsWith(META_INF) && (\n                name.endsWith(\"".MF\"") ||\n                name.endsWith(\"".SF\"") ||\n                name.endsWith(\"".DSA\"") ||\n                name.endsWith(\"".RSA\"") ||\n                SIG.matcher(name).matches()\n        );\n    }""}, {""func_name"": ""activateJars"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/runtime/JNLPClassLoader.java"", ""func_code"": ""protected void activateJars(final List<JARDesc> jars) {\n        PrivilegedAction<Void> activate = new PrivilegedAction<Void>() {\n\n            @SuppressWarnings(\""deprecation\"")\n            @Override\n            public Void run() {\n                // transfer the Jars\n                waitForJars(jars);\n\n                for (JARDesc jar : jars) {\n                    available.remove(jar);\n\n                    // add jar\n                    File localFile = tracker.getCacheFile(jar.getLocation());\n                    try {\n                        URL location = jar.getLocation(); // non-cacheable, use source location\n                        if (localFile != null) {\n                            // TODO: Should be toURI().toURL()\n                            location = localFile.toURL(); // cached file\n                            // This is really not the best way.. but we need some way for\n                            // PluginAppletViewer::getCachedImageRef() to check if the image\n                            // is available locally, and it cannot use getResources() because\n                            // that prefetches the resource, which confuses MediaTracker.waitForAll()\n                            // which does a wait(), waiting for notification (presumably\n                            // thrown after a resource is fetched). This bug manifests itself\n                            // particularly when using The FileManager applet from Webmin.\n                            try (JarFile jarFile = new JarFile(localFile)) {\n                                for (JarEntry je : Collections.list(jarFile.entries())) {\n\n                                    // another jar in my jar? it is more likely than you think\n                                    if (je.getName().endsWith(\"".jar\"")) {\n                                        // We need to extract that jar so that it can be loaded\n                                        // (inline loading with \""jar:..!/...\"" path will not work\n                                        // with standard classloader methods)\n\n                                        String name = je.getName();\n                                        if (name.contains(\""..\"")){\n                                            name=CacheUtil.hex(name, name);\n                                        }\n                                        String extractedJarLocation = localFile + \"".nested/\"" + name;\n                                        File parentDir = new File(extractedJarLocation).getParentFile();\n                                        if (!parentDir.isDirectory() && !parentDir.mkdirs()) {\n                                            throw new RuntimeException(\""Unable to extract nested jar.\"");\n                                        }\n                                        FileOutputStream extractedJar = new FileOutputStream(extractedJarLocation);\n                                        InputStream is = jarFile.getInputStream(je);\n\n                                        byte[] bytes = new byte[1024];\n                                        int read = is.read(bytes);\n                                        int fileSize = read;\n                                        while (read > 0) {\n                                            extractedJar.write(bytes, 0, read);\n                                            read = is.read(bytes);\n                                            fileSize += read;\n                                        }\n\n                                        is.close();\n                                        extractedJar.close();\n\n                                        // 0 byte file? skip\n                                        if (fileSize <= 0) {\n                                            continue;\n                                        }\n\n                                        tracker.addResource(new File(extractedJarLocation).toURL(), null, null, null);\n\n                                        URL codebase = file.getCodeBase();\n                                        if (codebase == null) {\n                                            //FIXME: codebase should be the codebase of the Main Jar not\n                                            //the location. Although, it still works in the current state.\n                                            codebase = file.getResources().getMainJAR().getLocation();\n                                        }\n\n                                        final SecurityDesc jarSecurity = securityDelegate.getJarPermissions(codebase);\n\n                                        try {\n                                            URL fileURL = new URL(\""file://\"" + extractedJarLocation);\n                                            // there is no remote URL for this, so lets fake one\n                                            URL fakeRemote = new URL(jar.getLocation().toString() + \""!\"" + je.getName());\n                                            CachedJarFileCallback.getInstance().addMapping(fakeRemote, fileURL);\n                                            addURL(fakeRemote);\n\n                                            jarLocationSecurityMap.put(fakeRemote, jarSecurity);\n\n                                        } catch (MalformedURLException mfue) {\n                                            LOG.error(\""Unable to add extracted nested jar to classpath\"", mfue);\n                                        }\n                                    }\n\n                                    jarEntries.add(je.getName());\n                                }\n                            }\n                        }\n\n                        addURL(jar.getLocation());\n\n                        // there is currently no mechanism to cache files per\n                        // instance.. so only index cached files\n                        if (localFile != null) {\n                            CachedJarFileCallback.getInstance().addMapping(jar.getLocation(), localFile.toURI().toURL());\n\n                            try (JarFile jarFile = new JarFile(localFile.getAbsolutePath())) {\n                                Manifest mf = jarFile.getManifest();\n\n                                // Only check classpath if this is the plugin and there is no jnlp_href usage.\n                                // Note that this is different from proprietary plugin behaviour.\n                                // If jnlp_href is used, the app should be treated similarly to when\n                                // it is run from javaws as a webstart.\n                                if (file instanceof PluginBridge && !((PluginBridge) file).useJNLPHref()) {\n                                    classpaths.addAll(ManifestAttributesReader.getClassPaths(mf, jar.getLocation()));\n                                }\n\n                                JarIndexAccess index = JarIndexAccess.getJarIndex(jarFile);\n                                if (index != null) {\n                                    jarIndexes.add(index);\n                                }\n                            }\n                        } else {\n                            CachedJarFileCallback.getInstance().addMapping(jar.getLocation(), jar.getLocation());\n                        }\n\n                        LOG.debug(\""Activate jar: {}\"", location);\n                    } catch (Exception ex) {\n                        LOG.error(IcedTeaWebConstants.DEFAULT_ERROR_MESSAGE, ex);\n                    }\n\n                    // some programs place a native library in any jar\n                    nativeLibraryStorage.addSearchJar(jar.getLocation());\n                }\n\n                return null;\n            }\n        };\n\n        AccessController.doPrivileged(activate, acc);\n    }""}, {""func_name"": ""hex"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java"", ""func_code"": ""public static String hex(String origName, String candidate) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n        byte[] sum = md.digest(candidate.getBytes(UTF_8));\n        //convert the byte to hex format method 2\n        StringBuilder hexString = new StringBuilder();\n        for (int i = 0; i < sum.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & sum[i]));\n        }\n        String extension = \""\"";\n        int i = origName.lastIndexOf('.');\n        if (i > 0) {\n            extension = origName.substring(i);//contains dot\n        }\n        if (extension.length() < 10 && extension.length() > 1) {\n            hexString.append(extension);\n        }\n        return hexString.toString();\n    }""}]","{""caller"": 1, ""function"": 1}","[{""source"": ""caller_info(file:CacheUtil.java, func:urlToPath)"", ""result"": [{""call_line"": 511, ""call_code"": ""urlToPath(source, \""\"")"", ""caller_code"": ""    public static File getCacheFile(final URL source, final VersionString version) {\n        if (!isCacheable(source))\n            throw new IllegalArgumentException(source + \"" is not a cacheable resource\"");\n\n        File cacheFile = null;\n        final CacheLRUWrapper lruHandler = CacheLRUWrapper.getInstance();\n        synchronized (lruHandler) {\n            try {\n                lruHandler.lock();\n\n                // We need to reload the cacheOrder file each time\n                // since another plugin/javaws instance may have updated it.\n                lruHandler.load();\n                cacheFile = getCacheFileIfExist(urlToPath(source, \""\""));\n                if (cacheFile == null) { // We did not find a copy of it.\n                    cacheFile = makeNewCacheFile(source, version);\n                } else\n                    lruHandler.store();\n            } finally {\n                lruHandler.unlock();\n            }\n        }\n        return cacheFile;\n    }\n"", ""caller_start"": 498, ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java""}, {""call_line"": 602, ""call_code"": ""urlToPath(source, path)"", ""caller_code"": ""    public static File makeNewCacheFile(final URL source, final VersionString version) {\n        final CacheLRUWrapper lruHandler = CacheLRUWrapper.getInstance();\n        synchronized (lruHandler) {\n            File cacheFile = null;\n            try {\n                lruHandler.lock();\n                lruHandler.load();\n                for (long i = 0; i < Long.MAX_VALUE; i++) {\n                    String path = lruHandler.getCacheDir().getFullPath() + File.separator + i;\n                    File cDir = new File(path);\n                    if (!cDir.exists()) {\n                        // We can use this directory.\n                        try {\n                            cacheFile = urlToPath(source, path);\n                            FileUtils.createParentDir(cacheFile);\n                            File pf = new File(cacheFile.getPath() + CacheDirectory.INFO_SUFFIX);\n                            FileUtils.createRestrictedFile(pf, true); // Create the info file for marking later.\n                            lruHandler.addEntry(lruHandler.generateKey(cacheFile.getPath()), cacheFile.getPath());\n                        } catch (IOException ioe) {\n                            LOG.error(IcedTeaWebConstants.DEFAULT_ERROR_MESSAGE, ioe);\n                        }\n\n                        break;\n                    }\n                }\n\n                lruHandler.store();\n            } finally {\n                lruHandler.unlock();\n            }\n            return cacheFile;\n        }\n    }\n"", ""caller_start"": 589, ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java""}, {""call_line"": 96, ""call_code"": ""CacheUtil.urlToPath(location, pcache)"", ""caller_code"": ""    private File toCacheFile(URL location) {\n        String pcache = PathsAndFiles.PCACHE_DIR.getFullPath();\n        return CacheUtil.urlToPath(location, pcache);\n    }\n"", ""caller_start"": 94, ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/services/XPersistenceService.java""}]}, {""source"": ""func_info(func:sanitizePath)"", ""result"": [{""code"": ""    public static String sanitizePath(String path) {\n        return sanitizePath(path, SANITIZED_CHAR);\n    }\n"", ""start_line"": 105, ""end_line"": 107, ""full_name"": ""net.sourceforge.jnlp.util.FileUtils.sanitizePath:java.lang.String(java.lang.String)"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/util/FileUtils.java""}, {""code"": ""    public static String sanitizePath(String path, char substitute) {\n        //on windows, we can receive both c:/path/ and c:\\path\\\n        path = path.replace(\""\\\\\"", \""/\"");\n        if (OsUtil.isWindows() && path.matches(\""^[a-zA-Z]\\\\:.*\"")) {\n            path = path.replaceFirst(\"":\"", WIN_DRIVE_LETTER_COLON_WILDCHAR);\n        }\n        for (int i = 0; i < INVALID_PATH.size(); i++) {\n            if (-1 != path.indexOf(INVALID_PATH.get(i))) {\n                path = path.replace(INVALID_PATH.get(i), substitute);\n            }\n        }\n        if (OsUtil.isWindows()) {\n            path = path.replaceFirst(WIN_DRIVE_LETTER_COLON_WILDCHAR, \"":\"");\n        }\n        return path;\n    }\n"", ""start_line"": 109, ""end_line"": 124, ""full_name"": ""net.sourceforge.jnlp.util.FileUtils.sanitizePath:java.lang.String(java.lang.String,char)"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/util/FileUtils.java""}]}]","Paths containing '..' in JNLP <jar/> elements were not sanitized before being used to generate cache file paths. The `urlToPath` function (core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java:699-743) failed to block traversal sequences, allowing attackers to craft URLs like `http://example.com/../../malicious.jar`. The `sanitizePath` function (core/src/main/java/net/sourceforge/jnlp/util/FileUtils.java:109-124) replaced invalid characters but did not address '..' traversal. When `getCacheFile` (core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java:498-511) called `urlToPath`, traversal paths were resolved to filesystem locations, enabling arbitrary file writes. The patch adds '..' checks and hashing to prevent this.",0.95,./github/other_context/CVE-2019-10182
42,CVE-2019-15784,CWE-129,c_cpp,Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.,https://github.com/Haivision/srt/commit/47e589072c44350b0305c05066c224d1cbda992d,[core] Fixed sender list to reallocate on insert\nif required,9,"[{""func_name"": ""CSndUList::insert_"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::insert_(int64_t ts, const CUDT* u)\n{\n   CSNode* n = u->m_pSNode;\n\n   // do not insert repeated node\n   if (n->m_iHeapLoc >= 0)\n      return;\n\n   m_iLastEntry ++;\n   m_pHeap[m_iLastEntry] = n;\n   n->m_llTimeStamp_tk = ts;\n\n   int q = m_iLastEntry;\n   int p = q;\n   while (p != 0)\n   {\n      p = (q - 1) >> 1;\n      if (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[q]->m_llTimeStamp_tk)\n      {\n         CSNode* t = m_pHeap[p];\n         m_pHeap[p] = m_pHeap[q];\n         m_pHeap[q] = t;\n         t->m_iHeapLoc = q;\n         q = p;\n      }\n      else\n         break;\n   }\n\n   n->m_iHeapLoc = q;\n\n   // an earlier event has been inserted, wake up sending worker\n   if (n->m_iHeapLoc == 0)\n      m_pTimer->interrupt();\n\n   // first entry, activate the sending queue\n   if (0 == m_iLastEntry)\n   {\n       pthread_mutex_lock(m_pWindowLock);\n       pthread_cond_signal(m_pWindowCond);\n       pthread_mutex_unlock(m_pWindowLock);\n   }\n}"", ""target"": 0}, {""func_name"": ""CSndUList::update"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::update(const CUDT* u, EReschedule reschedule)\n{\n   CGuard listguard(m_ListLock);\n\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      if (!reschedule) // EReschedule to bool conversion, predicted.\n         return;\n\n      if (n->m_iHeapLoc == 0)\n      {\n         n->m_llTimeStamp_tk = 1;\n         m_pTimer->interrupt();\n         return;\n      }\n\n      remove_(u);\n   }\n\n   insert_(1, u);\n}"", ""target"": 0}, {""func_name"": ""CSndUList::pop"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""int CSndUList::pop(sockaddr*& addr, CPacket& pkt)\n{\n   CGuard listguard(m_ListLock);\n\n   if (-1 == m_iLastEntry)\n      return -1;\n\n   // no pop until the next schedulled time\n   uint64_t ts;\n   CTimer::rdtsc(ts);\n   if (ts < m_pHeap[0]->m_llTimeStamp_tk)\n      return -1;\n\n   CUDT* u = m_pHeap[0]->m_pUDT;\n   remove_(u);\n\n#define UST(field) ( (u->m_b##field) ? \""+\"" : \""-\"" ) << #field << \"" \""\n\n   HLOGC(mglog.Debug, log << \""SND:pop: requesting packet from @\"" << u->socketID()\n           << \"" STATUS: \""\n           << UST(Listening)\n           << UST(Connecting)\n           << UST(Connected)\n           << UST(Closing)\n           << UST(Shutdown)\n           << UST(Broken)\n           << UST(PeerHealth)\n           << UST(Opened)\n        );\n#undef UST\n\n   if (!u->m_bConnected || u->m_bBroken)\n      return -1;\n\n   // pack a packet from the socket\n   if (u->packData(pkt, ts) <= 0)\n      return -1;\n\n   addr = u->m_pPeerAddr;\n\n   // insert a new entry, ts is the next processing time\n   if (ts > 0)\n      insert_(ts, u);\n\n   return 1;\n}"", ""target"": 0}, {""func_name"": ""CSndUList::CSndUList"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""CSndUList::CSndUList():\n    m_pHeap(NULL),\n    m_iArrayLength(4096),\n    m_iLastEntry(-1),\n    m_ListLock(),\n    m_pWindowLock(NULL),\n    m_pWindowCond(NULL),\n    m_pTimer(NULL)\n{\n    m_pHeap = new CSNode*[m_iArrayLength];\n    pthread_mutex_init(&m_ListLock, NULL);\n}"", ""target"": 0}, {""func_name"": ""CSndUList::realloc_"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::realloc_()\n{\n   CSNode** temp = NULL;\n\n   try\n   {\n       temp = new CSNode * [m_iArrayLength * 2];\n   }\n   catch (...)\n   {\n       return;\n   }\n\n   memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);\n   m_iArrayLength *= 2;\n   delete[] m_pHeap;\n   m_pHeap = temp;\n}"", ""target"": 0}, {""func_name"": ""CSndUList::insert_"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::insert_(int64_t ts, const CUDT* u)\n{\n    // increase the heap array size if necessary\n    if (m_iLastEntry == m_iArrayLength - 1)\n        realloc_();\n\n    insert_norealloc(ts, u);\n}"", ""target"": 1}, {""func_name"": ""CSndUList::remove_"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::remove_(const CUDT* u)\n{\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      // remove the node from heap\n      m_pHeap[n->m_iHeapLoc] = m_pHeap[m_iLastEntry];\n      m_iLastEntry --;\n      m_pHeap[n->m_iHeapLoc]->m_iHeapLoc = n->m_iHeapLoc;\n\n      int q = n->m_iHeapLoc;\n      int p = q * 2 + 1;\n      while (p <= m_iLastEntry)\n      {\n         if ((p + 1 <= m_iLastEntry) && (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[p + 1]->m_llTimeStamp_tk))\n            p ++;\n\n         if (m_pHeap[q]->m_llTimeStamp_tk > m_pHeap[p]->m_llTimeStamp_tk)\n         {\n            CSNode* t = m_pHeap[p];\n            m_pHeap[p] = m_pHeap[q];\n            m_pHeap[p]->m_iHeapLoc = p;\n            m_pHeap[q] = t;\n            m_pHeap[q]->m_iHeapLoc = q;\n\n            q = p;\n            p = q * 2 + 1;\n         }\n         else\n            break;\n      }\n\n      n->m_iHeapLoc = -1;\n   }\n\n   // the only event has been deleted, wake up immediately\n   if (0 == m_iLastEntry)\n      m_pTimer->interrupt();\n}"", ""target"": 1}, {""func_name"": ""CSndUList::update"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::update(const CUDT* u, EReschedule reschedule)\n{\n   CGuard listguard(m_ListLock);\n\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      if (!reschedule) // EReschedule to bool conversion, predicted.\n         return;\n\n      if (n->m_iHeapLoc == 0)\n      {\n         n->m_llTimeStamp_tk = 1;\n         m_pTimer->interrupt();\n         return;\n      }\n\n      remove_(u);\n      insert_norealloc(1, u);\n      return;\n   }\n\n   insert_(1, u);\n}"", ""target"": 0}, {""func_name"": ""CSndUList::pop"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""int CSndUList::pop(sockaddr*& addr, CPacket& pkt)\n{\n   CGuard listguard(m_ListLock);\n\n   if (-1 == m_iLastEntry)\n      return -1;\n\n   // no pop until the next schedulled time\n   uint64_t ts;\n   CTimer::rdtsc(ts);\n   if (ts < m_pHeap[0]->m_llTimeStamp_tk)\n      return -1;\n\n   CUDT* u = m_pHeap[0]->m_pUDT;\n   remove_(u);\n\n#define UST(field) ( (u->m_b##field) ? \""+\"" : \""-\"" ) << #field << \"" \""\n\n   HLOGC(mglog.Debug, log << \""SND:pop: requesting packet from @\"" << u->socketID()\n           << \"" STATUS: \""\n           << UST(Listening)\n           << UST(Connecting)\n           << UST(Connected)\n           << UST(Closing)\n           << UST(Shutdown)\n           << UST(Broken)\n           << UST(PeerHealth)\n           << UST(Opened)\n        );\n#undef UST\n\n   if (!u->m_bConnected || u->m_bBroken)\n      return -1;\n\n   // pack a packet from the socket\n   if (u->packData(pkt, ts) <= 0)\n      return -1;\n\n   addr = u->m_pPeerAddr;\n\n   // insert a new entry, ts is the next processing time\n   if (ts > 0)\n      insert_norealloc(ts, u);\n\n   return 1;\n}"", ""target"": 1}]","[{""func_name"": ""CSndUList::insert_"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::insert_(int64_t ts, const CUDT* u)\n{\n    // increase the heap array size if necessary\n    if (m_iLastEntry == m_iArrayLength - 1)\n        realloc_();\n\n    insert_norealloc(ts, u);\n}""}, {""func_name"": ""CSndUList::update"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::update(const CUDT* u, EReschedule reschedule)\n{\n   CGuard listguard(m_ListLock);\n\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      if (!reschedule) // EReschedule to bool conversion, predicted.\n         return;\n\n      if (n->m_iHeapLoc == 0)\n      {\n         n->m_llTimeStamp_tk = 1;\n         m_pTimer->interrupt();\n         return;\n      }\n\n      remove_(u);\n      insert_norealloc(1, u);\n      return;\n   }\n\n   insert_(1, u);\n}""}, {""func_name"": ""CSndUList::pop"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""int CSndUList::pop(sockaddr*& addr, CPacket& pkt)\n{\n   CGuard listguard(m_ListLock);\n\n   if (-1 == m_iLastEntry)\n      return -1;\n\n   // no pop until the next schedulled time\n   uint64_t ts;\n   CTimer::rdtsc(ts);\n   if (ts < m_pHeap[0]->m_llTimeStamp_tk)\n      return -1;\n\n   CUDT* u = m_pHeap[0]->m_pUDT;\n   remove_(u);\n\n#define UST(field) ( (u->m_b##field) ? \""+\"" : \""-\"" ) << #field << \"" \""\n\n   HLOGC(mglog.Debug, log << \""SND:pop: requesting packet from @\"" << u->socketID()\n           << \"" STATUS: \""\n           << UST(Listening)\n           << UST(Connecting)\n           << UST(Connected)\n           << UST(Closing)\n           << UST(Shutdown)\n           << UST(Broken)\n           << UST(PeerHealth)\n           << UST(Opened)\n        );\n#undef UST\n\n   if (!u->m_bConnected || u->m_bBroken)\n      return -1;\n\n   // pack a packet from the socket\n   if (u->packData(pkt, ts) <= 0)\n      return -1;\n\n   addr = u->m_pPeerAddr;\n\n   // insert a new entry, ts is the next processing time\n   if (ts > 0)\n      insert_norealloc(ts, u);\n\n   return 1;\n}""}, {""func_name"": ""CSndUList::CSndUList"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""CSndUList::CSndUList():\n    m_pHeap(NULL),\n    m_iArrayLength(512),\n    m_iLastEntry(-1),\n    m_ListLock(),\n    m_pWindowLock(NULL),\n    m_pWindowCond(NULL),\n    m_pTimer(NULL)\n{\n    m_pHeap = new CSNode*[m_iArrayLength];\n    pthread_mutex_init(&m_ListLock, NULL);\n}""}, {""func_name"": ""CSndUList::realloc_"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::realloc_()\n{\n   CSNode** temp = NULL;\n\n   try\n   {\n       temp = new CSNode *[2 * m_iArrayLength];\n   }\n   catch (...)\n   {\n       throw CUDTException(MJ_SYSTEMRES, MN_MEMORY, 0);\n   }\n\n   memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);\n   m_iArrayLength *= 2;\n   delete[] m_pHeap;\n   m_pHeap = temp;\n}""}, {""func_name"": ""CSndUList::insert_"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::insert_(int64_t ts, const CUDT* u)\n{\n    // increase the heap array size if necessary\n    if (m_iLastEntry == m_iArrayLength - 1)\n        realloc_();\n\n    insert_norealloc_(ts, u);\n}""}, {""func_name"": ""CSndUList::remove_"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::remove_(const CUDT* u)\n{\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      // remove the node from heap\n      m_pHeap[n->m_iHeapLoc] = m_pHeap[m_iLastEntry];\n      m_iLastEntry --;\n      m_pHeap[n->m_iHeapLoc]->m_iHeapLoc = n->m_iHeapLoc;\n\n      int q = n->m_iHeapLoc;\n      int p = q * 2 + 1;\n      while (p <= m_iLastEntry)\n      {\n         if ((p + 1 <= m_iLastEntry) && (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[p + 1]->m_llTimeStamp_tk))\n            p ++;\n\n         if (m_pHeap[q]->m_llTimeStamp_tk > m_pHeap[p]->m_llTimeStamp_tk)\n         {\n            swap(m_pHeap[p], m_pHeap[q]);\n            m_pHeap[p]->m_iHeapLoc = p;\n            m_pHeap[q]->m_iHeapLoc = q;\n\n            q = p;\n            p = q * 2 + 1;\n         }\n         else\n            break;\n      }\n\n      n->m_iHeapLoc = -1;\n   }\n\n   // the only event has been deleted, wake up immediately\n   if (0 == m_iLastEntry)\n      m_pTimer->interrupt();\n}""}, {""func_name"": ""CSndUList::update"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""void CSndUList::update(const CUDT* u, EReschedule reschedule)\n{\n   CGuard listguard(m_ListLock);\n\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      if (!reschedule) // EReschedule to bool conversion, predicted.\n         return;\n\n      if (n->m_iHeapLoc == 0)\n      {\n         n->m_llTimeStamp_tk = 1;\n         m_pTimer->interrupt();\n         return;\n      }\n\n      remove_(u);\n      insert_norealloc_(1, u);\n      return;\n   }\n\n   insert_(1, u);\n}""}, {""func_name"": ""CSndUList::pop"", ""file_path"": ""srtcore/queue.cpp"", ""func_code"": ""int CSndUList::pop(sockaddr*& addr, CPacket& pkt)\n{\n   CGuard listguard(m_ListLock);\n\n   if (-1 == m_iLastEntry)\n      return -1;\n\n   // no pop until the next schedulled time\n   uint64_t ts;\n   CTimer::rdtsc(ts);\n   if (ts < m_pHeap[0]->m_llTimeStamp_tk)\n      return -1;\n\n   CUDT* u = m_pHeap[0]->m_pUDT;\n   remove_(u);\n\n#define UST(field) ( (u->m_b##field) ? \""+\"" : \""-\"" ) << #field << \"" \""\n\n   HLOGC(mglog.Debug, log << \""SND:pop: requesting packet from @\"" << u->socketID()\n           << \"" STATUS: \""\n           << UST(Listening)\n           << UST(Connecting)\n           << UST(Connected)\n           << UST(Closing)\n           << UST(Shutdown)\n           << UST(Broken)\n           << UST(PeerHealth)\n           << UST(Opened)\n        );\n#undef UST\n\n   if (!u->m_bConnected || u->m_bBroken)\n      return -1;\n\n   // pack a packet from the socket\n   if (u->packData(pkt, ts) <= 0)\n      return -1;\n\n   addr = u->m_pPeerAddr;\n\n   // insert a new entry, ts is the next processing time\n   if (ts > 0)\n      insert_norealloc_(ts, u);\n\n   return 1;\n}""}]","{""code"": 2, ""value"": 1}","[{""source"": ""code_info(file:queue.cpp, lines:10-20)"", ""result"": ""\n/*****************************************************************************\nCopyright (c) 2001 - 2011, The Board of Trustees of the University of Illinois.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n""}, {""source"": ""value_info(file:queue.cpp, value:m_iArrayLength)"", ""result"": {""value_trace"": [{""full_code"": ""m_iArrayLength *= 2"", ""line"": 295, ""func_name"": ""CSndUList.insert:void(int64_t,CUDT*)""}], ""struct_var"": ""m_iArrayLength"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:queue.cpp, lines:290-305)"", ""result"": ""      {\n         return;\n      }\n\n      memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);\n      m_iArrayLength *= 2;\n      delete [] m_pHeap;\n      m_pHeap = temp;\n   }\n\n   insert_(ts, u);\n}\n\nvoid CSndUList::update(const CUDT* u, EReschedule reschedule)\n{\n   CGuard listguard(m_ListLock);\n\n""}]",srtcore/queue.cpp:392-394 (insert_ lacked realloc_ check before insertion) → srtcore/queue.cpp:4-7 (realloc_ now throws on failure instead of returning) → srtcore/queue.cpp:290-305 (realloc_ doubles m_iArrayLength via m_iArrayLength *= 2).,0.95,./github/other_context/CVE-2019-15784
43,CVE-2019-20363,CWE-79,java,An XSS issue was discovered in Ignite Realtime Openfire 4.4.4 via alias to Manage Store Contents.,https://github.com/igniterealtime/Openfire/commit/b6f758241f3fdd57b48c527a695512f33e26eb74,Fix issues identified by CSW,1,"[{""func_name"": ""doGet"", ""file_path"": ""xmppserver/src/main/java/org/jivesoftware/admin/servlet/SystemCacheDetailsServlet.java"", ""func_code"": ""@Override\n    protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n\n        final String cacheName = ParamUtils.getStringParameter(request, \""cacheName\"", \""\"").trim();\n        final Optional<Cache<?, ?>> optionalCache = Arrays.stream(CacheFactory.getAllCaches())\n            .filter(cache -> cacheName.equals(cache.getName()))\n            .findAny()\n            .map(cache -> (Cache<?, ?>) cache);\n\n        if (!optionalCache.isPresent()) {\n            request.setAttribute(\""warningMessage\"", LocaleUtils.getLocalizedString(\""system.cache-details.cache_not_found\"", Collections.singletonList(cacheName)));\n        }\n\n        final boolean secretKey = optionalCache.map(Cache::isKeySecret).orElse(Boolean.FALSE);\n        final boolean secretValue = optionalCache.map(Cache::isValueSecret).orElse(Boolean.FALSE);\n\n        final List<Map.Entry<String, String>> cacheEntries = optionalCache.map(Cache::entrySet)\n            .map(Collection::stream)\n            .orElseGet(Stream::empty)\n            .map(entry -> new AbstractMap.SimpleEntry<>(secretKey ? \""************\"" : entry.getKey().toString(), secretValue ? \""************\"" : entry.getValue().toString()))\n            .sorted(Comparator.comparing(Map.Entry::getKey))\n            .collect(Collectors.toList());\n\n        // Find what we're searching for\n        final Search search = new Search(request);\n        Predicate<Map.Entry<String, String>> predicate = entry -> true;\n        if (!search.key.isEmpty() && !secretKey) {\n            predicate = predicate.and(entry -> StringUtils.containsIgnoringCase(entry.getKey(), search.key));\n        }\n        if (!search.value.isEmpty() && !secretValue) {\n            predicate = predicate.and(entry -> StringUtils.containsIgnoringCase(entry.getValue(), search.value));\n        }\n\n        final ListPager<Map.Entry<String, String>> listPager = new ListPager<>(request, response, cacheEntries, predicate, SEARCH_FIELDS);\n\n        final String csrf = StringUtils.randomString(16);\n        CookieUtils.setCookie(request, response, \""csrf\"", csrf, -1);\n        addSessionFlashes(request, \""errorMessage\"", \""warningMessage\"", \""successMessage\"");\n        request.setAttribute(\""csrf\"", csrf);\n        request.setAttribute(\""cacheName\"", cacheName);\n        request.setAttribute(\""listPager\"", listPager);\n        request.setAttribute(\""search\"", search);\n        request.getRequestDispatcher(\""system-cache-details.jsp\"").forward(request, response);\n    }"", ""target"": 0}]","[{""func_name"": ""doGet"", ""file_path"": ""xmppserver/src/main/java/org/jivesoftware/admin/servlet/SystemCacheDetailsServlet.java"", ""func_code"": ""@Override\n    protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n\n        final String cacheName = ParamUtils.getStringParameter(request, \""cacheName\"", \""\"").trim();\n        final Optional<Cache<?, ?>> optionalCache = Arrays.stream(CacheFactory.getAllCaches())\n            .filter(cache -> cacheName.equals(cache.getName()))\n            .findAny()\n            .map(cache -> (Cache<?, ?>) cache);\n\n        if (!optionalCache.isPresent()) {\n            request.setAttribute(\""warningMessage\"", LocaleUtils.getLocalizedString(\""system.cache-details.cache_not_found\"", Collections.singletonList(StringUtils.escapeHTMLTags(cacheName))));\n        }\n\n        final boolean secretKey = optionalCache.map(Cache::isKeySecret).orElse(Boolean.FALSE);\n        final boolean secretValue = optionalCache.map(Cache::isValueSecret).orElse(Boolean.FALSE);\n\n        final List<Map.Entry<String, String>> cacheEntries = optionalCache.map(Cache::entrySet)\n            .map(Collection::stream)\n            .orElseGet(Stream::empty)\n            .map(entry -> new AbstractMap.SimpleEntry<>(secretKey ? \""************\"" : entry.getKey().toString(), secretValue ? \""************\"" : entry.getValue().toString()))\n            .sorted(Comparator.comparing(Map.Entry::getKey))\n            .collect(Collectors.toList());\n\n        // Find what we're searching for\n        final Search search = new Search(request);\n        Predicate<Map.Entry<String, String>> predicate = entry -> true;\n        if (!search.key.isEmpty() && !secretKey) {\n            predicate = predicate.and(entry -> StringUtils.containsIgnoringCase(entry.getKey(), search.key));\n        }\n        if (!search.value.isEmpty() && !secretValue) {\n            predicate = predicate.and(entry -> StringUtils.containsIgnoringCase(entry.getValue(), search.value));\n        }\n\n        final ListPager<Map.Entry<String, String>> listPager = new ListPager<>(request, response, cacheEntries, predicate, SEARCH_FIELDS);\n\n        final String csrf = StringUtils.randomString(16);\n        CookieUtils.setCookie(request, response, \""csrf\"", csrf, -1);\n        addSessionFlashes(request, \""errorMessage\"", \""warningMessage\"", \""successMessage\"");\n        request.setAttribute(\""csrf\"", csrf);\n        request.setAttribute(\""cacheName\"", cacheName);\n        request.setAttribute(\""listPager\"", listPager);\n        request.setAttribute(\""search\"", search);\n        request.getRequestDispatcher(\""system-cache-details.jsp\"").forward(request, response);\n    }""}]","{""code"": 1}","[{""source"": ""code_info(file:SystemCacheDetailsServlet.java, lines:30-40)"", ""result"": ""import javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(value = \""/SystemCacheDetails.jsp\"")\npublic class SystemCacheDetailsServlet extends HttpServlet {\n\n    private static final String[] SEARCH_FIELDS = {\""cacheName\"", \""searchKey\"", \""searchValue\""};\n\n    @Override\n    protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n\n        final String cacheName = ParamUtils.getStringParameter(request, \""cacheName\"", \""\"").trim();\n""}]","xmppserver/src/main/java/org/jivesoftware/admin/servlet/SystemCacheDetailsServlet.java:40: `cacheName` was used in a localized warning message without HTML escaping. `cacheName` is initialized from HTTP request parameter (line 37: `final String cacheName = ParamUtils.getStringParameter(request, ""cacheName"", """").trim();`).",1.0,./github/other_context/CVE-2019-20363
44,CVE-2019-9917,CWE-20,c_cpp,ZNC before 1.7.3-rc1 allows an existing remote user to cause a Denial of Service (crash) via invalid encoding.,https://github.com/znc/znc/commit/64613bc8b6b4adf1e32231f9844d99cd512b8973,Don't crash if user specified invalid encoding.\n\nThis is CVE-2019-9917,5,"[{""func_name"": ""CUser::SetClientEncoding"", ""file_path"": ""src/User.cpp"", ""func_code"": ""void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}"", ""target"": 0}, {""func_name"": ""CIRCNetwork::SetEncoding"", ""file_path"": ""src/IRCNetwork.cpp"", ""func_code"": ""void CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = s;\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(s);\n    }\n}"", ""target"": 0}, {""func_name"": ""CZNC::FixupEncoding"", ""file_path"": ""src/znc.cpp"", ""func_code"": ""CString CZNC::FixupEncoding(const CString& sEncoding) const {\n    if (sEncoding.empty() && m_uiForceEncoding) {\n        return \""UTF-8\"";\n    }\n    return sEncoding;\n}"", ""target"": 0}, {""func_name"": ""CZNC::ForceEncoding"", ""file_path"": ""src/znc.cpp"", ""func_code"": ""void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        if (pSock->GetEncoding().empty()) {\n            pSock->SetEncoding(\""UTF-8\"");\n        }\n    }\n#endif\n}"", ""target"": 0}, {""func_name"": ""Set"", ""file_path"": ""modules/controlpanel.cpp"", ""func_code"": ""void Set(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        CString sUserName = sLine.Token(2);\n        CString sValue = sLine.Token(3, true);\n\n        if (sValue.empty()) {\n            PutModule(t_s(\""Usage: Set <variable> <username> <value>\""));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) return;\n\n        if (sVar == \""nick\"") {\n            pUser->SetNick(sValue);\n            PutModule(\""Nick = \"" + sValue);\n        } else if (sVar == \""altnick\"") {\n            pUser->SetAltNick(sValue);\n            PutModule(\""AltNick = \"" + sValue);\n        } else if (sVar == \""ident\"") {\n            pUser->SetIdent(sValue);\n            PutModule(\""Ident = \"" + sValue);\n        } else if (sVar == \""realname\"") {\n            pUser->SetRealName(sValue);\n            PutModule(\""RealName = \"" + sValue);\n        } else if (sVar == \""bindhost\"") {\n            if (!pUser->DenySetBindHost() || GetUser()->IsAdmin()) {\n                if (sValue.Equals(pUser->GetBindHost())) {\n                    PutModule(t_s(\""This bind host is already set!\""));\n                    return;\n                }\n\n                pUser->SetBindHost(sValue);\n                PutModule(\""BindHost = \"" + sValue);\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""multiclients\"") {\n            bool b = sValue.ToBool();\n            pUser->SetMultiClients(b);\n            PutModule(\""MultiClients = \"" + CString(b));\n        } else if (sVar == \""denyloadmod\"") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetDenyLoadMod(b);\n                PutModule(\""DenyLoadMod = \"" + CString(b));\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""denysetbindhost\"") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetDenySetBindHost(b);\n                PutModule(\""DenySetBindHost = \"" + CString(b));\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""defaultchanmodes\"") {\n            pUser->SetDefaultChanModes(sValue);\n            PutModule(\""DefaultChanModes = \"" + sValue);\n        } else if (sVar == \""quitmsg\"") {\n            pUser->SetQuitMsg(sValue);\n            PutModule(\""QuitMsg = \"" + sValue);\n        } else if (sVar == \""chanbuffersize\"" || sVar == \""buffercount\"") {\n            unsigned int i = sValue.ToUInt();\n            // Admins don't have to honour the buffer limit\n            if (pUser->SetChanBufferSize(i, GetUser()->IsAdmin())) {\n                PutModule(\""ChanBufferSize = \"" + sValue);\n            } else {\n                PutModule(t_f(\""Setting failed, limit for buffer size is {1}\"")(\n                    CString(CZNC::Get().GetMaxBufferSize())));\n            }\n        } else if (sVar == \""querybuffersize\"") {\n            unsigned int i = sValue.ToUInt();\n            // Admins don't have to honour the buffer limit\n            if (pUser->SetQueryBufferSize(i, GetUser()->IsAdmin())) {\n                PutModule(\""QueryBufferSize = \"" + sValue);\n            } else {\n                PutModule(t_f(\""Setting failed, limit for buffer size is {1}\"")(\n                    CString(CZNC::Get().GetMaxBufferSize())));\n            }\n        } else if (sVar == \""keepbuffer\"") {\n            // XXX compatibility crap, added in 0.207\n            bool b = !sValue.ToBool();\n            pUser->SetAutoClearChanBuffer(b);\n            PutModule(\""AutoClearChanBuffer = \"" + CString(b));\n        } else if (sVar == \""autoclearchanbuffer\"") {\n            bool b = sValue.ToBool();\n            pUser->SetAutoClearChanBuffer(b);\n            PutModule(\""AutoClearChanBuffer = \"" + CString(b));\n        } else if (sVar == \""autoclearquerybuffer\"") {\n            bool b = sValue.ToBool();\n            pUser->SetAutoClearQueryBuffer(b);\n            PutModule(\""AutoClearQueryBuffer = \"" + CString(b));\n        } else if (sVar == \""password\"") {\n            const CString sSalt = CUtils::GetSalt();\n            const CString sHash = CUser::SaltedHash(sValue, sSalt);\n            pUser->SetPass(sHash, CUser::HASH_DEFAULT, sSalt);\n            PutModule(t_s(\""Password has been changed!\""));\n        } else if (sVar == \""maxjoins\"") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetMaxJoins(i);\n            PutModule(\""MaxJoins = \"" + CString(pUser->MaxJoins()));\n        } else if (sVar == \""notraffictimeout\"") {\n            unsigned int i = sValue.ToUInt();\n            if (i < 30) {\n                PutModule(t_s(\""Timeout can't be less than 30 seconds!\""));\n            } else {\n                pUser->SetNoTrafficTimeout(i);\n                PutModule(\""NoTrafficTimeout = \"" +\n                          CString(pUser->GetNoTrafficTimeout()));\n            }\n        } else if (sVar == \""maxnetworks\"") {\n            if (GetUser()->IsAdmin()) {\n                unsigned int i = sValue.ToUInt();\n                pUser->SetMaxNetworks(i);\n                PutModule(\""MaxNetworks = \"" + sValue);\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""maxquerybuffers\"") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetMaxQueryBuffers(i);\n            PutModule(\""MaxQueryBuffers = \"" + sValue);\n        } else if (sVar == \""jointries\"") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetJoinTries(i);\n            PutModule(\""JoinTries = \"" + CString(pUser->JoinTries()));\n        } else if (sVar == \""timezone\"") {\n            pUser->SetTimezone(sValue);\n            PutModule(\""Timezone = \"" + pUser->GetTimezone());\n        } else if (sVar == \""admin\"") {\n            if (GetUser()->IsAdmin() && pUser != GetUser()) {\n                bool b = sValue.ToBool();\n                pUser->SetAdmin(b);\n                PutModule(\""Admin = \"" + CString(pUser->IsAdmin()));\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""prependtimestamp\"") {\n            bool b = sValue.ToBool();\n            pUser->SetTimestampPrepend(b);\n            PutModule(\""PrependTimestamp = \"" + CString(b));\n        } else if (sVar == \""appendtimestamp\"") {\n            bool b = sValue.ToBool();\n            pUser->SetTimestampAppend(b);\n            PutModule(\""AppendTimestamp = \"" + CString(b));\n        } else if (sVar == \""authonlyviamodule\"") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetAuthOnlyViaModule(b);\n                PutModule(\""AuthOnlyViaModule = \"" + CString(b));\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""timestampformat\"") {\n            pUser->SetTimestampFormat(sValue);\n            PutModule(\""TimestampFormat = \"" + sValue);\n        } else if (sVar == \""dccbindhost\"") {\n            if (!pUser->DenySetBindHost() || GetUser()->IsAdmin()) {\n                pUser->SetDCCBindHost(sValue);\n                PutModule(\""DCCBindHost = \"" + sValue);\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""statusprefix\"") {\n            if (sVar.find_first_of(\"" \\t\\n\"") == CString::npos) {\n                pUser->SetStatusPrefix(sValue);\n                PutModule(\""StatusPrefix = \"" + sValue);\n            } else {\n                PutModule(t_s(\""That would be a bad idea!\""));\n            }\n        }\n#ifdef HAVE_I18N\n        else if (sVar == \""language\"") {\n            auto mTranslations = CTranslationInfo::GetTranslations();\n            // TODO: maybe stop special-casing English\n            if (sValue == \""en\"") {\n                pUser->SetLanguage(\""\"");\n                PutModule(\""Language is set to English\"");\n            } else if (mTranslations.count(sValue)) {\n                pUser->SetLanguage(sValue);\n                PutModule(\""Language = \"" + sValue);\n            } else {\n                VCString vsCodes = {\""en\""};\n                for (const auto it : mTranslations) {\n                    vsCodes.push_back(it.first);\n                }\n                PutModule(t_f(\""Supported languages: {1}\"")(\n                    CString(\"", \"").Join(vsCodes.begin(), vsCodes.end())));\n            }\n        }\n#endif\n#ifdef HAVE_ICU\n        else if (sVar == \""clientencoding\"") {\n            pUser->SetClientEncoding(sValue);\n            PutModule(\""ClientEncoding = \"" + sValue);\n        }\n#endif\n        else\n            PutModule(t_s(\""Error: Unknown variable\""));\n    }"", ""target"": 0}]","[{""func_name"": ""CUser::SetClientEncoding"", ""file_path"": ""src/User.cpp"", ""func_code"": ""void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = CZNC::Get().FixupEncoding(s);\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(m_sClientEncoding);\n    }\n}""}, {""func_name"": ""CIRCNetwork::SetEncoding"", ""file_path"": ""src/IRCNetwork.cpp"", ""func_code"": ""void CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = CZNC::Get().FixupEncoding(s);\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(m_sEncoding);\n    }\n}""}, {""func_name"": ""CZNC::FixupEncoding"", ""file_path"": ""src/znc.cpp"", ""func_code"": ""CString CZNC::FixupEncoding(const CString& sEncoding) const {\n    if (!m_uiForceEncoding) {\n        return sEncoding;\n    }\n    if (sEncoding.empty()) {\n        return \""UTF-8\"";\n    }\n    const char* sRealEncoding = sEncoding.c_str();\n    if (sEncoding[0] == '*' || sEncoding[0] == '^') {\n        sRealEncoding++;\n    }\n    if (!*sRealEncoding) {\n        return \""UTF-8\"";\n    }\n#ifdef HAVE_ICU\n    UErrorCode e = U_ZERO_ERROR;\n    UConverter* cnv = ucnv_open(sRealEncoding, &e);\n    if (cnv) {\n        ucnv_close(cnv);\n    }\n    if (U_FAILURE(e)) {\n        return \""UTF-8\"";\n    }\n#endif\n    return sEncoding;\n}""}, {""func_name"": ""CZNC::ForceEncoding"", ""file_path"": ""src/znc.cpp"", ""func_code"": ""void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        pSock->SetEncoding(FixupEncoding(pSock->GetEncoding()));\n    }\n#endif\n}""}, {""func_name"": ""Set"", ""file_path"": ""modules/controlpanel.cpp"", ""func_code"": ""void Set(const CString& sLine) {\n        const CString sVar = sLine.Token(1).AsLower();\n        CString sUserName = sLine.Token(2);\n        CString sValue = sLine.Token(3, true);\n\n        if (sValue.empty()) {\n            PutModule(t_s(\""Usage: Set <variable> <username> <value>\""));\n            return;\n        }\n\n        CUser* pUser = FindUser(sUserName);\n        if (!pUser) return;\n\n        if (sVar == \""nick\"") {\n            pUser->SetNick(sValue);\n            PutModule(\""Nick = \"" + sValue);\n        } else if (sVar == \""altnick\"") {\n            pUser->SetAltNick(sValue);\n            PutModule(\""AltNick = \"" + sValue);\n        } else if (sVar == \""ident\"") {\n            pUser->SetIdent(sValue);\n            PutModule(\""Ident = \"" + sValue);\n        } else if (sVar == \""realname\"") {\n            pUser->SetRealName(sValue);\n            PutModule(\""RealName = \"" + sValue);\n        } else if (sVar == \""bindhost\"") {\n            if (!pUser->DenySetBindHost() || GetUser()->IsAdmin()) {\n                if (sValue.Equals(pUser->GetBindHost())) {\n                    PutModule(t_s(\""This bind host is already set!\""));\n                    return;\n                }\n\n                pUser->SetBindHost(sValue);\n                PutModule(\""BindHost = \"" + sValue);\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""multiclients\"") {\n            bool b = sValue.ToBool();\n            pUser->SetMultiClients(b);\n            PutModule(\""MultiClients = \"" + CString(b));\n        } else if (sVar == \""denyloadmod\"") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetDenyLoadMod(b);\n                PutModule(\""DenyLoadMod = \"" + CString(b));\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""denysetbindhost\"") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetDenySetBindHost(b);\n                PutModule(\""DenySetBindHost = \"" + CString(b));\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""defaultchanmodes\"") {\n            pUser->SetDefaultChanModes(sValue);\n            PutModule(\""DefaultChanModes = \"" + sValue);\n        } else if (sVar == \""quitmsg\"") {\n            pUser->SetQuitMsg(sValue);\n            PutModule(\""QuitMsg = \"" + sValue);\n        } else if (sVar == \""chanbuffersize\"" || sVar == \""buffercount\"") {\n            unsigned int i = sValue.ToUInt();\n            // Admins don't have to honour the buffer limit\n            if (pUser->SetChanBufferSize(i, GetUser()->IsAdmin())) {\n                PutModule(\""ChanBufferSize = \"" + sValue);\n            } else {\n                PutModule(t_f(\""Setting failed, limit for buffer size is {1}\"")(\n                    CString(CZNC::Get().GetMaxBufferSize())));\n            }\n        } else if (sVar == \""querybuffersize\"") {\n            unsigned int i = sValue.ToUInt();\n            // Admins don't have to honour the buffer limit\n            if (pUser->SetQueryBufferSize(i, GetUser()->IsAdmin())) {\n                PutModule(\""QueryBufferSize = \"" + sValue);\n            } else {\n                PutModule(t_f(\""Setting failed, limit for buffer size is {1}\"")(\n                    CString(CZNC::Get().GetMaxBufferSize())));\n            }\n        } else if (sVar == \""keepbuffer\"") {\n            // XXX compatibility crap, added in 0.207\n            bool b = !sValue.ToBool();\n            pUser->SetAutoClearChanBuffer(b);\n            PutModule(\""AutoClearChanBuffer = \"" + CString(b));\n        } else if (sVar == \""autoclearchanbuffer\"") {\n            bool b = sValue.ToBool();\n            pUser->SetAutoClearChanBuffer(b);\n            PutModule(\""AutoClearChanBuffer = \"" + CString(b));\n        } else if (sVar == \""autoclearquerybuffer\"") {\n            bool b = sValue.ToBool();\n            pUser->SetAutoClearQueryBuffer(b);\n            PutModule(\""AutoClearQueryBuffer = \"" + CString(b));\n        } else if (sVar == \""password\"") {\n            const CString sSalt = CUtils::GetSalt();\n            const CString sHash = CUser::SaltedHash(sValue, sSalt);\n            pUser->SetPass(sHash, CUser::HASH_DEFAULT, sSalt);\n            PutModule(t_s(\""Password has been changed!\""));\n        } else if (sVar == \""maxjoins\"") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetMaxJoins(i);\n            PutModule(\""MaxJoins = \"" + CString(pUser->MaxJoins()));\n        } else if (sVar == \""notraffictimeout\"") {\n            unsigned int i = sValue.ToUInt();\n            if (i < 30) {\n                PutModule(t_s(\""Timeout can't be less than 30 seconds!\""));\n            } else {\n                pUser->SetNoTrafficTimeout(i);\n                PutModule(\""NoTrafficTimeout = \"" +\n                          CString(pUser->GetNoTrafficTimeout()));\n            }\n        } else if (sVar == \""maxnetworks\"") {\n            if (GetUser()->IsAdmin()) {\n                unsigned int i = sValue.ToUInt();\n                pUser->SetMaxNetworks(i);\n                PutModule(\""MaxNetworks = \"" + sValue);\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""maxquerybuffers\"") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetMaxQueryBuffers(i);\n            PutModule(\""MaxQueryBuffers = \"" + sValue);\n        } else if (sVar == \""jointries\"") {\n            unsigned int i = sValue.ToUInt();\n            pUser->SetJoinTries(i);\n            PutModule(\""JoinTries = \"" + CString(pUser->JoinTries()));\n        } else if (sVar == \""timezone\"") {\n            pUser->SetTimezone(sValue);\n            PutModule(\""Timezone = \"" + pUser->GetTimezone());\n        } else if (sVar == \""admin\"") {\n            if (GetUser()->IsAdmin() && pUser != GetUser()) {\n                bool b = sValue.ToBool();\n                pUser->SetAdmin(b);\n                PutModule(\""Admin = \"" + CString(pUser->IsAdmin()));\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""prependtimestamp\"") {\n            bool b = sValue.ToBool();\n            pUser->SetTimestampPrepend(b);\n            PutModule(\""PrependTimestamp = \"" + CString(b));\n        } else if (sVar == \""appendtimestamp\"") {\n            bool b = sValue.ToBool();\n            pUser->SetTimestampAppend(b);\n            PutModule(\""AppendTimestamp = \"" + CString(b));\n        } else if (sVar == \""authonlyviamodule\"") {\n            if (GetUser()->IsAdmin()) {\n                bool b = sValue.ToBool();\n                pUser->SetAuthOnlyViaModule(b);\n                PutModule(\""AuthOnlyViaModule = \"" + CString(b));\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""timestampformat\"") {\n            pUser->SetTimestampFormat(sValue);\n            PutModule(\""TimestampFormat = \"" + sValue);\n        } else if (sVar == \""dccbindhost\"") {\n            if (!pUser->DenySetBindHost() || GetUser()->IsAdmin()) {\n                pUser->SetDCCBindHost(sValue);\n                PutModule(\""DCCBindHost = \"" + sValue);\n            } else {\n                PutModule(t_s(\""Access denied!\""));\n            }\n        } else if (sVar == \""statusprefix\"") {\n            if (sVar.find_first_of(\"" \\t\\n\"") == CString::npos) {\n                pUser->SetStatusPrefix(sValue);\n                PutModule(\""StatusPrefix = \"" + sValue);\n            } else {\n                PutModule(t_s(\""That would be a bad idea!\""));\n            }\n        }\n#ifdef HAVE_I18N\n        else if (sVar == \""language\"") {\n            auto mTranslations = CTranslationInfo::GetTranslations();\n            // TODO: maybe stop special-casing English\n            if (sValue == \""en\"") {\n                pUser->SetLanguage(\""\"");\n                PutModule(\""Language is set to English\"");\n            } else if (mTranslations.count(sValue)) {\n                pUser->SetLanguage(sValue);\n                PutModule(\""Language = \"" + sValue);\n            } else {\n                VCString vsCodes = {\""en\""};\n                for (const auto it : mTranslations) {\n                    vsCodes.push_back(it.first);\n                }\n                PutModule(t_f(\""Supported languages: {1}\"")(\n                    CString(\"", \"").Join(vsCodes.begin(), vsCodes.end())));\n            }\n        }\n#endif\n#ifdef HAVE_ICU\n        else if (sVar == \""clientencoding\"") {\n            pUser->SetClientEncoding(sValue);\n            PutModule(\""ClientEncoding = \"" + pUser->GetClientEncoding());\n        }\n#endif\n        else\n            PutModule(t_s(\""Error: Unknown variable\""));\n    }""}]","{""caller"": 1, ""value"": 1}","[{""source"": ""caller_info(func:SetClientEncoding)"", ""result"": [{""call_line"": 458, ""call_code"": ""SetClientEncoding(vsClient[0])"", ""caller_code"": ""bool CUser::ParseConfig(CConfig* pConfig, CString& sError) {\n    TOption<const CString&> StringOptions[] = {\n        {\""nick\"", &CUser::SetNick},\n        {\""quitmsg\"", &CUser::SetQuitMsg},\n        {\""altnick\"", &CUser::SetAltNick},\n        {\""ident\"", &CUser::SetIdent},\n        {\""realname\"", &CUser::SetRealName},\n        {\""chanmodes\"", &CUser::SetDefaultChanModes},\n        {\""bindhost\"", &CUser::SetBindHost},\n        {\""vhost\"", &CUser::SetBindHost},\n        {\""dccbindhost\"", &CUser::SetDCCBindHost},\n        {\""dccvhost\"", &CUser::SetDCCBindHost},\n        {\""timestampformat\"", &CUser::SetTimestampFormat},\n        {\""skin\"", &CUser::SetSkinName},\n        {\""clientencoding\"", &CUser::SetClientEncoding},\n    };\n    TOption<unsigned int> UIntOptions[] = {\n        {\""jointries\"", &CUser::SetJoinTries},\n        {\""maxnetworks\"", &CUser::SetMaxNetworks},\n        {\""maxquerybuffers\"", &CUser::SetMaxQueryBuffers},\n        {\""maxjoins\"", &CUser::SetMaxJoins},\n        {\""notraffictimeout\"", &CUser::SetNoTrafficTimeout},\n    };\n    TOption<bool> BoolOptions[] = {\n        {\""keepbuffer\"",\n         &CUser::SetKeepBuffer},  // XXX compatibility crap from pre-0.207\n        {\""autoclearchanbuffer\"", &CUser::SetAutoClearChanBuffer},\n        {\""autoclearquerybuffer\"", &CUser::SetAutoClearQueryBuffer},\n        {\""multiclients\"", &CUser::SetMultiClients},\n        {\""denyloadmod\"", &CUser::SetDenyLoadMod},\n        {\""admin\"", &CUser::SetAdmin},\n        {\""denysetbindhost\"", &CUser::SetDenySetBindHost},\n        {\""denysetvhost\"", &CUser::SetDenySetBindHost},\n        {\""appendtimestamp\"", &CUser::SetTimestampAppend},\n        {\""prependtimestamp\"", &CUser::SetTimestampPrepend},\n        {\""authonlyviamodule\"", &CUser::SetAuthOnlyViaModule},\n    };\n\n    for (const auto& Option : StringOptions) {\n        CString sValue;\n        if (pConfig->FindStringEntry(Option.name, sValue))\n            (this->*Option.pSetter)(sValue);\n    }\n    for (const auto& Option : UIntOptions) {\n        CString sValue;\n        if (pConfig->FindStringEntry(Option.name, sValue))\n            (this->*Option.pSetter)(sValue.ToUInt());\n    }\n    for (const auto& Option : BoolOptions) {\n        CString sValue;\n        if (pConfig->FindStringEntry(Option.name, sValue))\n            (this->*Option.pSetter)(sValue.ToBool());\n    }\n\n    VCString vsList;\n    pConfig->FindStringVector(\""allow\"", vsList);\n    for (const CString& sHost : vsList) {\n        AddAllowedHost(sHost);\n    }\n    pConfig->FindStringVector(\""ctcpreply\"", vsList);\n    for (const CString& sReply : vsList) {\n        AddCTCPReply(sReply.Token(0), sReply.Token(1, true));\n    }\n\n    CString sValue;\n\n    CString sDCCLookupValue;\n    pConfig->FindStringEntry(\""dcclookupmethod\"", sDCCLookupValue);\n    if (pConfig->FindStringEntry(\""bouncedccs\"", sValue)) {\n        if (sValue.ToBool()) {\n            CUtils::PrintAction(\""Loading Module [bouncedcc]\"");\n            CString sModRet;\n            bool bModRet = GetModules().LoadModule(\n                \""bouncedcc\"", \""\"", CModInfo::UserModule, this, nullptr, sModRet);\n\n            CUtils::PrintStatus(bModRet, sModRet);\n            if (!bModRet) {\n                sError = sModRet;\n                return false;\n            }\n\n            if (sDCCLookupValue.Equals(\""Client\"")) {\n                GetModules().FindModule(\""bouncedcc\"")->SetNV(\""UseClientIP\"", \""1\"");\n            }\n        }\n    }\n    if (pConfig->FindStringEntry(\""buffer\"", sValue))\n        SetBufferCount(sValue.ToUInt(), true);\n    if (pConfig->FindStringEntry(\""chanbuffersize\"", sValue))\n        SetChanBufferSize(sValue.ToUInt(), true);\n    if (pConfig->FindStringEntry(\""querybuffersize\"", sValue))\n        SetQueryBufferSize(sValue.ToUInt(), true);\n    if (pConfig->FindStringEntry(\""awaysuffix\"", sValue)) {\n        CUtils::PrintMessage(\n            \""WARNING: AwaySuffix has been deprecated, instead try -> \""\n            \""LoadModule = awaynick %nick%_\"" +\n            sValue);\n    }\n    if (pConfig->FindStringEntry(\""autocycle\"", sValue)) {\n        if (sValue.Equals(\""true\""))\n            CUtils::PrintError(\n                \""WARNING: AutoCycle has been removed, instead try -> \""\n                \""LoadModule = autocycle\"");\n    }\n    if (pConfig->FindStringEntry(\""keepnick\"", sValue)) {\n        if (sValue.Equals(\""true\""))\n            CUtils::PrintError(\n                \""WARNING: KeepNick has been deprecated, instead try -> \""\n                \""LoadModule = keepnick\"");\n    }\n    if (pConfig->FindStringEntry(\""statusprefix\"", sValue)) {\n        if (!SetStatusPrefix(sValue)) {\n            sError = \""Invalid StatusPrefix [\"" + sValue +\n                     \""] Must be 1-5 chars, no spaces.\"";\n            CUtils::PrintError(sError);\n            return false;\n        }\n    }\n    if (pConfig->FindStringEntry(\""timezone\"", sValue)) {\n        SetTimezone(sValue);\n    }\n    if (pConfig->FindStringEntry(\""timezoneoffset\"", sValue)) {\n        if (fabs(sValue.ToDouble()) > 0.1) {\n            CUtils::PrintError(\n                \""WARNING: TimezoneOffset has been deprecated, now you can set \""\n                \""your timezone by name\"");\n        }\n    }\n    if (pConfig->FindStringEntry(\""timestamp\"", sValue)) {\n        if (!sValue.Trim_n().Equals(\""true\"")) {\n            if (sValue.Trim_n().Equals(\""append\"")) {\n                SetTimestampAppend(true);\n                SetTimestampPrepend(false);\n            } else if (sValue.Trim_n().Equals(\""prepend\"")) {\n                SetTimestampAppend(false);\n                SetTimestampPrepend(true);\n            } else if (sValue.Trim_n().Equals(\""false\"")) {\n                SetTimestampAppend(false);\n                SetTimestampPrepend(false);\n            } else {\n                SetTimestampFormat(sValue);\n            }\n        }\n    }\n    if (pConfig->FindStringEntry(\""language\"", sValue)) {\n        SetLanguage(sValue);\n    }\n    pConfig->FindStringEntry(\""pass\"", sValue);\n    // There are different formats for this available:\n    // Pass = <plain text>\n    // Pass = <md5 hash> -\n    // Pass = plain#<plain text>\n    // Pass = <hash name>#<hash>\n    // Pass = <hash name>#<salted hash>#<salt>#\n    // 'Salted hash' means hash of 'password' + 'salt'\n    // Possible hashes are md5 and sha256\n    if (sValue.TrimSuffix(\""-\"")) {\n        SetPass(sValue.Trim_n(), CUser::HASH_MD5);\n    } else {\n        CString sMethod = sValue.Token(0, false, \""#\"");\n        CString sPass = sValue.Token(1, true, \""#\"");\n        if (sMethod == \""md5\"" || sMethod == \""sha256\"") {\n            CUser::eHashType type = CUser::HASH_MD5;\n            if (sMethod == \""sha256\"") type = CUser::HASH_SHA256;\n\n            CString sSalt = sPass.Token(1, false, \""#\"");\n            sPass = sPass.Token(0, false, \""#\"");\n            SetPass(sPass, type, sSalt);\n        } else if (sMethod == \""plain\"") {\n            SetPass(sPass, CUser::HASH_NONE);\n        } else {\n            SetPass(sValue, CUser::HASH_NONE);\n        }\n    }\n    CConfig::SubConfig subConf;\n    CConfig::SubConfig::const_iterator subIt;\n    pConfig->FindSubConfig(\""pass\"", subConf);\n    if (!sValue.empty() && !subConf.empty()) {\n        sError = \""Password defined more than once\"";\n        CUtils::PrintError(sError);\n        return false;\n    }\n    subIt = subConf.begin();\n    if (subIt != subConf.end()) {\n        CConfig* pSubConf = subIt->second.m_pSubConfig;\n        CString sHash;\n        CString sMethod;\n        CString sSalt;\n        CUser::eHashType method;\n        pSubConf->FindStringEntry(\""hash\"", sHash);\n        pSubConf->FindStringEntry(\""method\"", sMethod);\n        pSubConf->FindStringEntry(\""salt\"", sSalt);\n        if (sMethod.empty() || sMethod.Equals(\""plain\""))\n            method = CUser::HASH_NONE;\n        else if (sMethod.Equals(\""md5\""))\n            method = CUser::HASH_MD5;\n        else if (sMethod.Equals(\""sha256\""))\n            method = CUser::HASH_SHA256;\n        else {\n            sError = \""Invalid hash method\"";\n            CUtils::PrintError(sError);\n            return false;\n        }\n\n        SetPass(sHash, method, sSalt);\n        if (!pSubConf->empty()) {\n            sError = \""Unhandled lines in config!\"";\n            CUtils::PrintError(sError);\n\n            CZNC::DumpConfig(pSubConf);\n            return false;\n        }\n        ++subIt;\n    }\n    if (subIt != subConf.end()) {\n        sError = \""Password defined more than once\"";\n        CUtils::PrintError(sError);\n        return false;\n    }\n\n    pConfig->FindSubConfig(\""network\"", subConf);\n    for (subIt = subConf.begin(); subIt != subConf.end(); ++subIt) {\n        const CString& sNetworkName = subIt->first;\n\n        CUtils::PrintMessage(\""Loading network [\"" + sNetworkName + \""]\"");\n\n        CIRCNetwork* pNetwork = FindNetwork(sNetworkName);\n\n        if (!pNetwork) {\n            pNetwork = new CIRCNetwork(this, sNetworkName);\n        }\n\n        if (!pNetwork->ParseConfig(subIt->second.m_pSubConfig, sError)) {\n            return false;\n        }\n    }\n\n    if (pConfig->FindStringVector(\""server\"", vsList, false) ||\n        pConfig->FindStringVector(\""chan\"", vsList, false) ||\n        pConfig->FindSubConfig(\""chan\"", subConf, false)) {\n        CIRCNetwork* pNetwork = FindNetwork(\""default\"");\n        if (!pNetwork) {\n            CString sErrorDummy;\n            pNetwork = AddNetwork(\""default\"", sErrorDummy);\n        }\n\n        if (pNetwork) {\n            CUtils::PrintMessage(\n                \""NOTICE: Found deprecated config, upgrading to a network\"");\n\n            if (!pNetwork->ParseConfig(pConfig, sError, true)) {\n                return false;\n            }\n        }\n    }\n\n    pConfig->FindStringVector(\""loadmodule\"", vsList);\n    for (const CString& sMod : vsList) {\n        CString sModName = sMod.Token(0);\n        CString sNotice = \""Loading user module [\"" + sModName + \""]\"";\n\n        // XXX Legacy crap, added in ZNC 0.089\n        if (sModName == \""discon_kick\"") {\n            sNotice =\n                \""NOTICE: [discon_kick] was renamed, loading [disconkick] \""\n                \""instead\"";\n            sModName = \""disconkick\"";\n        }\n\n        // XXX Legacy crap, added in ZNC 0.099\n        if (sModName == \""fixfreenode\"") {\n            sNotice =\n                \""NOTICE: [fixfreenode] doesn't do anything useful anymore, \""\n                \""ignoring it\"";\n            CUtils::PrintMessage(sNotice);\n            continue;\n        }\n\n        // XXX Legacy crap, added in ZNC 0.207\n        if (sModName == \""admin\"") {\n            sNotice =\n                \""NOTICE: [admin] module was renamed, loading [controlpanel] \""\n                \""instead\"";\n            sModName = \""controlpanel\"";\n        }\n\n        // XXX Legacy crap, should have been added ZNC 0.207, but added only in\n        // 1.1 :(\n        if (sModName == \""away\"") {\n            sNotice = \""NOTICE: [away] was renamed, loading [awaystore] instead\"";\n            sModName = \""awaystore\"";\n        }\n\n        // XXX Legacy crap, added in 1.1; fakeonline module was dropped in 1.0\n        // and returned in 1.1\n        if (sModName == \""fakeonline\"") {\n            sNotice =\n                \""NOTICE: [fakeonline] was renamed, loading [modules_online] \""\n                \""instead\"";\n            sModName = \""modules_online\"";\n        }\n\n        // XXX Legacy crap, added in 1.3\n        if (sModName == \""charset\"") {\n            CUtils::PrintAction(\n                \""NOTICE: Charset support was moved to core, importing old \""\n                \""charset module settings\"");\n            size_t uIndex = 1;\n            if (sMod.Token(uIndex).Equals(\""-force\"")) {\n                uIndex++;\n            }\n            VCString vsClient, vsServer;\n            sMod.Token(uIndex).Split(\"",\"", vsClient);\n            sMod.Token(uIndex + 1).Split(\"",\"", vsServer);\n            if (vsClient.empty() || vsServer.empty()) {\n                CUtils::PrintStatus(\n                    false, \""charset module was loaded with wrong parameters.\"");\n                continue;\n            }\n            SetClientEncoding(vsClient[0]);\n            for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n                pNetwork->SetEncoding(vsServer[0]);\n            }\n            CUtils::PrintStatus(true, \""Using [\"" + vsClient[0] +\n                                          \""] for clients, and [\"" + vsServer[0] +\n                                          \""] for servers\"");\n            continue;\n        }\n\n        CString sModRet;\n        CString sArgs = sMod.Token(1, true);\n\n        bool bModRet = LoadModule(sModName, sArgs, sNotice, sModRet);\n\n        CUtils::PrintStatus(bModRet, sModRet);\n        if (!bModRet) {\n            // XXX The awaynick module was retired in 1.6 (still available as\n            // external module)\n            if (sModName == \""awaynick\"") {\n                // load simple_away instead, unless it's already on the list\n                if (std::find(vsList.begin(), vsList.end(), \""simple_away\"") ==\n                    vsList.end()) {\n                    sNotice = \""Loading [simple_away] module instead\"";\n                    sModName = \""simple_away\"";\n                    // not a fatal error if simple_away is not available\n                    LoadModule(sModName, sArgs, sNotice, sModRet);\n                }\n            } else {\n                sError = sModRet;\n                return false;\n            }\n        }\n        continue;\n    }\n\n    // Move ircconnectenabled to the networks\n    if (pConfig->FindStringEntry(\""ircconnectenabled\"", sValue)) {\n        for (CIRCNetwork* pNetwork : m_vIRCNetworks) {\n            pNetwork->SetIRCConnectEnabled(sValue.ToBool());\n        }\n    }\n\n    return true;\n}\n"", ""caller_start"": 139, ""file_path"": ""src/User.cpp""}, {""call_line"": 764, ""call_code"": ""SetClientEncoding(User.GetClientEncoding())"", ""caller_code"": ""bool CUser::Clone(const CUser& User, CString& sErrorRet, bool bCloneNetworks) {\n    sErrorRet.clear();\n\n    if (!User.IsValid(sErrorRet, true)) {\n        return false;\n    }\n\n    // user names can only specified for the constructor, changing it later\n    // on breaks too much stuff (e.g. lots of paths depend on the user name)\n    if (GetUserName() != User.GetUserName()) {\n        DEBUG(\""Ignoring username in CUser::Clone(), old username [\""\n              << GetUserName() << \""]; New username [\"" << User.GetUserName()\n              << \""]\"");\n    }\n\n    if (!User.GetPass().empty()) {\n        SetPass(User.GetPass(), User.GetPassHashType(), User.GetPassSalt());\n    }\n\n    SetNick(User.GetNick(false));\n    SetAltNick(User.GetAltNick(false));\n    SetIdent(User.GetIdent(false));\n    SetRealName(User.GetRealName());\n    SetStatusPrefix(User.GetStatusPrefix());\n    SetBindHost(User.GetBindHost());\n    SetDCCBindHost(User.GetDCCBindHost());\n    SetQuitMsg(User.GetQuitMsg());\n    SetSkinName(User.GetSkinName());\n    SetDefaultChanModes(User.GetDefaultChanModes());\n    SetChanBufferSize(User.GetChanBufferSize(), true);\n    SetQueryBufferSize(User.GetQueryBufferSize(), true);\n    SetJoinTries(User.JoinTries());\n    SetMaxNetworks(User.MaxNetworks());\n    SetMaxQueryBuffers(User.MaxQueryBuffers());\n    SetMaxJoins(User.MaxJoins());\n    SetNoTrafficTimeout(User.GetNoTrafficTimeout());\n    SetClientEncoding(User.GetClientEncoding());\n    SetLanguage(User.GetLanguage());\n\n    // Allowed Hosts\n    m_ssAllowedHosts.clear();\n    const set<CString>& ssHosts = User.GetAllowedHosts();\n    for (const CString& sHost : ssHosts) {\n        AddAllowedHost(sHost);\n    }\n\n    for (CClient* pSock : m_vClients) {\n        if (!IsHostAllowed(pSock->GetRemoteIP())) {\n            pSock->PutStatusNotice(\n                t_s(\""You are being disconnected because your IP is no longer \""\n                    \""allowed to connect to this user\""));\n            pSock->Close();\n        }\n    }\n\n    // !Allowed Hosts\n\n    // Networks\n    if (bCloneNetworks) {\n        CloneNetworks(User);\n    }\n    // !Networks\n\n    // CTCP Replies\n    m_mssCTCPReplies.clear();\n    const MCString& msReplies = User.GetCTCPReplies();\n    for (const auto& it : msReplies) {\n        AddCTCPReply(it.first, it.second);\n    }\n    // !CTCP Replies\n\n    // Flags\n    SetAutoClearChanBuffer(User.AutoClearChanBuffer());\n    SetAutoClearQueryBuffer(User.AutoClearQueryBuffer());\n    SetMultiClients(User.MultiClients());\n    SetDenyLoadMod(User.DenyLoadMod());\n    SetAdmin(User.IsAdmin());\n    SetDenySetBindHost(User.DenySetBindHost());\n    SetAuthOnlyViaModule(User.AuthOnlyViaModule());\n    SetTimestampAppend(User.GetTimestampAppend());\n    SetTimestampPrepend(User.GetTimestampPrepend());\n    SetTimestampFormat(User.GetTimestampFormat());\n    SetTimezone(User.GetTimezone());\n    // !Flags\n\n    // Modules\n    set<CString> ssUnloadMods;\n    CModules& vCurMods = GetModules();\n    const CModules& vNewMods = User.GetModules();\n\n    for (CModule* pNewMod : vNewMods) {\n        CString sModRet;\n        CModule* pCurMod = vCurMods.FindModule(pNewMod->GetModName());\n\n        if (!pCurMod) {\n            vCurMods.LoadModule(pNewMod->GetModName(), pNewMod->GetArgs(),\n                                CModInfo::UserModule, this, nullptr, sModRet);\n        } else if (pNewMod->GetArgs() != pCurMod->GetArgs()) {\n            vCurMods.ReloadModule(pNewMod->GetModName(), pNewMod->GetArgs(),\n                                  this, nullptr, sModRet);\n        }\n    }\n\n    for (CModule* pCurMod : vCurMods) {\n        CModule* pNewMod = vNewMods.FindModule(pCurMod->GetModName());\n\n        if (!pNewMod) {\n            ssUnloadMods.insert(pCurMod->GetModName());\n        }\n    }\n\n    for (const CString& sMod : ssUnloadMods) {\n        vCurMods.UnloadModule(sMod);\n    }\n    // !Modules\n\n    return true;\n}\n"", ""caller_start"": 728, ""file_path"": ""src/User.cpp""}]}, {""source"": ""value_info(file:controlpanel.cpp, value:sValue)"", ""result"": {""value_trace"": [{""full_code"": ""sValue = sLine.Token(3, true)"", ""line"": 305, ""func_name"": ""CAdminMod.Set:void(CString&)""}, {""full_code"": ""sValue = sLine.Token(4, true)"", ""line"": 585, ""func_name"": ""CAdminMod.SetNetwork:void(CString&)""}, {""full_code"": ""sValue = CString(pChan->GetBufferCount())"", ""line"": 763, ""func_name"": ""CAdminMod.GetChan:void(CString&)""}, {""full_code"": ""sValue += \"" (default)\"""", ""line"": 765, ""func_name"": ""CAdminMod.GetChan:void(CString&)""}, {""full_code"": ""sValue = CString(pChan->AutoClearChanBuffer())"", ""line"": 776, ""func_name"": ""CAdminMod.GetChan:void(CString&)""}], ""struct_var"": ""sValue"", ""struct_type"": ""CString"", ""struct_definition"": ""CString.CString:ANY(char)\n\nCString.CString:ANY(unsigned char)\n\nCString.CString:ANY(short)\n\nCString.CString:ANY(shortunsigned)\n\nCString.CString:ANY(int)\n\nCString.CString:ANY(unsigned int)\n\nCString.CString:ANY(long)\n\nCString.CString:ANY(longunsigned)\n\nCString.CString:ANY(longlong)\n\nCString.CString:ANY(longlongunsigned)\n\nCString.CString:ANY(double,int)\n\nCString.CString:ANY(float,int)\n\nCString\n\nCString\n\nCString""}}]","User-controlled encoding values (e.g., from ControlPanel's SET command in modules/controlpanel.cpp:305 or config parsing in src/User.cpp:458) are passed to CUser::SetClientEncoding() without validation. These values are directly assigned to m_sClientEncoding and propagated to CClient::SetEncoding(), which uses them in ICU operations (pre-patch). Invalid encodings trigger ICU errors, causing crashes. The patch adds CZNC::FixupEncoding() to validate encodings via ucnv_open() (src/znc.cpp:2104-2126), defaulting to UTF-8 on failure.",0.95,./github/other_context/CVE-2019-9917
45,CVE-2020-13973,CWE-79,java,"OWASP json-sanitizer before 1.2.1 allows XSS. An attacker who controls a substring of the input JSON, and controls another substring adjacent to a SCRIPT element in which the output is embedded as JavaScript, may be able to confuse the HTML parser as to where the SCRIPT element ends, and cause non-script content to be interpreted as JavaScript.",https://github.com/OWASP/json-sanitizer/commit/53ceaac3e0a10e86d512ce96a0056578f2d1978f,"Escape <!--, --> and <script\n\nIn HTML script elements, `</script` is not the only substring that\nswitches the HTML parser state even when contained in a JS string\nliteral. This commit adds escaping for `<!--`, `-->` and `<script`,\nwhich appear to be all substrings that cause state transitions which\nare not reset by the `""` closing the string literal.",1,"[{""func_name"": ""sanitizeString"", ""file_path"": ""src/main/java/com/google/json/JsonSanitizer.java"", ""func_code"": ""private void sanitizeString(int start, int end) {\n    boolean closed = false;\n    for (int i = start; i < end; ++i) {\n      char ch = jsonish.charAt(i);\n      switch (ch) {\n        // Fixup newlines.\n        case '\\n': replace(i, i + 1, \""\\\\n\""); break;\n        case '\\r': replace(i, i + 1, \""\\\\r\""); break;\n        // Not newlines in JSON but unparseable by JS eval.\n        case '\\u2028': replace(i, i + 1, \""\\\\u2028\""); break;\n        case '\\u2029': replace(i, i + 1, \""\\\\u2029\""); break;\n        // String delimiting quotes that need to be converted : 'foo' -> \""foo\""\n        // or internal quotes that might need to be escaped : f\""o -> f\\\""o.\n        case '\""': case '\\'':\n          if (i == start) {\n            if (ch == '\\'') { replace(i, i + 1, '\""'); }\n          } else {\n            if (i + 1 == end) {\n              char startDelim = jsonish.charAt(start);\n              if (startDelim != '\\'') {\n                // If we're sanitizing a string whose start was inferred, then\n                // treat '\""' as closing regardless.\n                startDelim = '\""';\n              }\n              closed = startDelim == ch;\n            }\n            if (closed) {\n              if (ch == '\\'') { replace(i, i + 1, '\""'); }\n            } else if (ch == '\""') {\n              insert(i, '\\\\');\n            }\n          }\n          break;\n        // Embedding.  Disallow </script and ]]> in string literals so that\n        // the output can be embedded in HTML script elements and in XML CDATA\n        // sections.\n        case '/':\n          // Don't over escape.  Many JSON bodies contain innocuous HTML\n          // that can be safely embedded.\n          if (i > start && i + 2 < end && '<' == jsonish.charAt(i - 1)\n              && 's' == (jsonish.charAt(i + 1) | 32)\n              && 'c' == (jsonish.charAt(i + 2) | 32)) {\n            insert(i, '\\\\');\n          }\n          break;\n        case ']':\n          if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n              && '>' == jsonish.charAt(i + 2)) {\n            replace(i, i + 1, \""\\\\u005d\"");\n          }\n          break;\n        // Normalize escape sequences.\n        case '\\\\':\n          if (i + 1 == end) {\n            elide(i, i + 1);\n            break;\n          }\n          char sch = jsonish.charAt(i + 1);\n          switch (sch) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\""':\n              ++i;\n              break;\n            case 'v':  // Recognized by JS but not by JSON.\n              replace(i, i + 2, \""\\\\u0008\"");\n              ++i;\n              break;\n            case 'x':\n              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                replace(i, i + 2, \""\\\\u00\"");  // \\xab -> \\u00ab\n                i += 3;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case 'u':\n              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                  && isHexAt(i + 4) && isHexAt(i + 5)) {\n                i += 5;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              int octalEnd = i + 1;\n              if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                ++octalEnd;\n                if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                  ++octalEnd;\n                }\n                int value = 0;\n                for (int j = i; j < octalEnd; ++j) {\n                  value = (value << 3) | (jsonish.charAt(j) - '0');\n                }\n                replace(i + 1, octalEnd, \""u00\"");\n                appendHex(value, 2);\n              }\n              i = octalEnd - 1;\n              break;\n            default:\n              // Literal char that is recognized by JS but not by JSON.\n              // \""\\-\"" is valid JS but not valid JSON.\n              elide(i, i + 1);\n              break;\n          }\n          break;\n        default:\n          // Escape all control code-points and isolated surrogates which are\n          // not embeddable in XML.\n          // http://www.w3.org/TR/xml/#charsets says\n          //     Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n          //            | [#x10000-#x10FFFF]\n          if (ch < 0x20) {\n            if (ch == 9 || ch == 0xa || ch == 0xd) { continue; }\n          } else if (ch < 0xd800) {  // Not a surrogate.\n            continue;\n          } else if (ch < 0xe000) {  // A surrogate\n            if (Character.isHighSurrogate(ch) && i+1 < end\n                && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n              ++i;  // Skip over low surrogate since we have already vetted it.\n              continue;\n            }\n          } else if (ch <= 0xfffd) {  // Not one of the 0xff.. controls.\n            continue;\n          }\n          replace(i, i + 1, \""\\\\u\"");\n          for (int j = 4; --j >= 0;) {\n            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!closed) { insert(end, '\""'); }\n  }"", ""target"": 0}]","[{""func_name"": ""sanitizeString"", ""file_path"": ""src/main/java/com/google/json/JsonSanitizer.java"", ""func_code"": ""private void sanitizeString(int start, int end) {\n    boolean closed = false;\n    for (int i = start; i < end; ++i) {\n      char ch = jsonish.charAt(i);\n      switch (ch) {\n        // Fixup newlines.\n        case '\\n': replace(i, i + 1, \""\\\\n\""); break;\n        case '\\r': replace(i, i + 1, \""\\\\r\""); break;\n        // Not newlines in JSON but unparseable by JS eval.\n        case '\\u2028': replace(i, i + 1, \""\\\\u2028\""); break;\n        case '\\u2029': replace(i, i + 1, \""\\\\u2029\""); break;\n        // String delimiting quotes that need to be converted : 'foo' -> \""foo\""\n        // or internal quotes that might need to be escaped : f\""o -> f\\\""o.\n        case '\""': case '\\'':\n          if (i == start) {\n            if (ch == '\\'') { replace(i, i + 1, '\""'); }\n          } else {\n            if (i + 1 == end) {\n              char startDelim = jsonish.charAt(start);\n              if (startDelim != '\\'') {\n                // If we're sanitizing a string whose start was inferred, then\n                // treat '\""' as closing regardless.\n                startDelim = '\""';\n              }\n              closed = startDelim == ch;\n            }\n            if (closed) {\n              if (ch == '\\'') { replace(i, i + 1, '\""'); }\n            } else if (ch == '\""') {\n              insert(i, '\\\\');\n            }\n          }\n          break;\n        // Embedding. Disallow <script, </script, <!--, --> and ]]> in string\n        // literals so that the output can be embedded in HTML script elements\n        // and in XML CDATA sections without affecting the parser state.\n        // References:\n        // https://www.w3.org/TR/html53/semantics-scripting.html#restrictions-for-contents-of-script-elements\n        // https://www.w3.org/TR/html53/syntax.html#script-data-escaped-state\n        // https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state\n        // https://www.w3.org/TR/xml/#sec-cdata-sect\n        case '<':\n          // Disallow <!--, which lets the HTML parser switch into the \""script\n          // data escaped\"" state.\n          // Disallow <script, which followed by various characters lets the\n          // HTML parser switch into or out of the \""script data double escaped\""\n          // state.\n          // Disallow </script, which ends a script block.\n          if (i + 3 >= end)\n            break;\n          char c1 = jsonish.charAt(i + 1);\n          char c2 = jsonish.charAt(i + 2);\n          char c3 = jsonish.charAt(i + 3);\n          char lc1 = (char) (c1 | 32);\n          char lc2 = (char) (c2 | 32);\n          char lc3 = (char) (c3 | 32);\n          if ((c1 == '!' && c2 == '-' && c3 == '-') ||\n              (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||\n              (c1 == '/' && lc2 == 's' && lc3 == 'c')) {\n            replace(i, i + 1, \""\\\\u003c\""); // Escaped <\n          }\n          break;\n        case '>':\n          // Disallow -->, which lets the HTML parser switch out of the \""script\n          // data escaped\"" or \""script data double escaped\"" state.\n          if ((i - 2) >= start && '-' == jsonish.charAt(i - 2)\n              && '-' == jsonish.charAt(i - 1)) {\n            replace(i, i + 1, \""\\\\u003e\""); // Escaped >\n          }\n          break;\n        case ']':\n          if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n              && '>' == jsonish.charAt(i + 2)) {\n            replace(i, i + 1, \""\\\\u005d\"");\n          }\n          break;\n        // Normalize escape sequences.\n        case '\\\\':\n          if (i + 1 == end) {\n            elide(i, i + 1);\n            break;\n          }\n          char sch = jsonish.charAt(i + 1);\n          switch (sch) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\""':\n              ++i;\n              break;\n            case 'v':  // Recognized by JS but not by JSON.\n              replace(i, i + 2, \""\\\\u0008\"");\n              ++i;\n              break;\n            case 'x':\n              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                replace(i, i + 2, \""\\\\u00\"");  // \\xab -> \\u00ab\n                i += 3;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case 'u':\n              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                  && isHexAt(i + 4) && isHexAt(i + 5)) {\n                i += 5;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              int octalEnd = i + 1;\n              if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                ++octalEnd;\n                if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                  ++octalEnd;\n                }\n                int value = 0;\n                for (int j = i; j < octalEnd; ++j) {\n                  value = (value << 3) | (jsonish.charAt(j) - '0');\n                }\n                replace(i + 1, octalEnd, \""u00\"");\n                appendHex(value, 2);\n              }\n              i = octalEnd - 1;\n              break;\n            default:\n              // Literal char that is recognized by JS but not by JSON.\n              // \""\\-\"" is valid JS but not valid JSON.\n              elide(i, i + 1);\n              break;\n          }\n          break;\n        default:\n          // Escape all control code-points and isolated surrogates which are\n          // not embeddable in XML.\n          // http://www.w3.org/TR/xml/#charsets says\n          //     Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n          //            | [#x10000-#x10FFFF]\n          if (ch < 0x20) {\n            if (ch == 9 || ch == 0xa || ch == 0xd) { continue; }\n          } else if (ch < 0xd800) {  // Not a surrogate.\n            continue;\n          } else if (ch < 0xe000) {  // A surrogate\n            if (Character.isHighSurrogate(ch) && i+1 < end\n                && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n              ++i;  // Skip over low surrogate since we have already vetted it.\n              continue;\n            }\n          } else if (ch <= 0xfffd) {  // Not one of the 0xff.. controls.\n            continue;\n          }\n          replace(i, i + 1, \""\\\\u\"");\n          for (int j = 4; --j >= 0;) {\n            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n          }\n          break;\n      }\n    }\n    if (!closed) { insert(end, '\""'); }\n  }""}]","{""caller"": 1, ""value"": 1}","[{""source"": ""caller_info(file:JsonSanitizer.java, func:sanitizeString)"", ""result"": [{""call_line"": 237, ""call_code"": ""this.sanitizeString(i, strEnd)"", ""caller_code"": ""  void sanitize() {\n    // Return to consistent state.\n    bracketDepth = cleaned = 0;\n    sanitizedJson = null;\n\n    State state = State.START_ARRAY;\n    int n = jsonish.length();\n\n    // Walk over each token and either validate it, by just advancing i and\n    // computing the next state, or manipulate cleaned&sanitizedJson so that\n    // sanitizedJson contains the sanitized equivalent of\n    // jsonish.substring(0, cleaned).\n    token_loop:\n    for (int i = 0; i < n; ++i) {\n      try {\n        char ch = jsonish.charAt(i);\n        if (SUPER_VERBOSE_AND_SLOW_LOGGING) {\n          String sanitizedJsonStr =\n            (sanitizedJson == null ? \""\"" : sanitizedJson)\n            + jsonish.substring(cleaned, i);\n          System.err.println(\""i=\"" + i + \"", ch=\"" + ch + \"", state=\"" + state\n                             + \"", sanitized=\"" + sanitizedJsonStr);\n        }\n        switch (ch) {\n          case '\\t': case '\\n': case '\\r': case ' ':\n            break;\n\n          case '\""': case '\\'':\n            state = requireValueState(i, state, true);\n            int strEnd = endOfQuotedString(jsonish, i);\n            sanitizeString(i, strEnd);\n            i = strEnd - 1;\n            break;\n\n          case '(': case ')':\n            // Often JSON-like content which is meant for use by eval is\n            // wrapped in parentheses so that the JS parser treats contained\n            // curly brackets as part of an object constructor instead of a\n            // block statement.\n            // We elide these grouping parentheses to ensure valid JSON.\n            elide(i, i + 1);\n            break;\n\n          case '{': case '[':\n            state = requireValueState(i, state, false);\n            if (isMap == null) {\n              isMap = new boolean[maximumNestingDepth];\n            }\n            boolean map = ch == '{';\n            isMap[bracketDepth] = map;\n            ++bracketDepth;\n            state = map ? State.START_MAP : State.START_ARRAY;\n            break;\n\n          case '}': case ']':\n            if (bracketDepth == 0) {\n              elide(i, jsonish.length());\n              break token_loop;\n            }\n\n            // Strip trailing comma to convert {\""a\"":0,} -> {\""a\"":0}\n            // and [1,2,3,] -> [1,2,3,]\n            switch (state) {\n              case BEFORE_VALUE:\n                insert(i, \""null\"");\n                break;\n              case BEFORE_ELEMENT: case BEFORE_KEY:\n                elideTrailingComma(i);\n                break;\n              case AFTER_KEY:\n                insert(i, \"":null\"");\n                break;\n              case START_MAP: case START_ARRAY:\n              case AFTER_ELEMENT: case AFTER_VALUE: break;\n            }\n\n            --bracketDepth;\n            char closeBracket = isMap[bracketDepth] ? '}' : ']';\n            if (ch != closeBracket) {\n              replace(i, i + 1, closeBracket);\n            }\n            state = bracketDepth == 0 || !isMap[bracketDepth - 1]\n                ? State.AFTER_ELEMENT : State.AFTER_VALUE;\n            break;\n          case ',':\n            if (bracketDepth == 0) { throw UNBRACKETED_COMMA; }\n            // Convert comma elisions like [1,,3] to [1,null,3].\n            // [1,,3] in JS is an array that has no element at index 1\n            // according to the \""in\"" operator so accessing index 1 will\n            // yield the special value \""undefined\"" which is equivalent to\n            // JS's \""null\"" value according to \""==\"".\n            switch (state) {\n              // Normal\n              case AFTER_ELEMENT:\n                state = State.BEFORE_ELEMENT;\n                break;\n              case AFTER_VALUE:\n                state = State.BEFORE_KEY;\n                break;\n              // Array elision.\n              case START_ARRAY: case BEFORE_ELEMENT:\n                insert(i, \""null\"");\n                state = State.BEFORE_ELEMENT;\n                break;\n              // Ignore\n              case START_MAP: case BEFORE_KEY:\n              case AFTER_KEY:\n                elide(i, i + 1);\n                break;\n              // Supply missing value.\n              case BEFORE_VALUE:\n                insert(i, \""null\"");\n                state = State.BEFORE_KEY;\n                break;\n            }\n            break;\n\n          case ':':\n            if (state == State.AFTER_KEY) {\n              state = State.BEFORE_VALUE;\n            } else {\n              elide(i, i + 1);\n            }\n            break;\n\n          case '/':\n            // Skip over JS-style comments since people like inserting them into\n            // data files and getting huffy with Crockford when he says no to\n            // versioning JSON to allow ignorable tokens.\n            int end = i + 1;\n            if (i + 1 < n) {\n              switch (jsonish.charAt(i + 1)) {\n                case '/':\n                  end = n;  // Worst case.\n                  for (int j = i + 2; j < n; ++j) {\n                    char cch = jsonish.charAt(j);\n                    if (cch == '\\n' || cch == '\\r'\n                        || cch == '\\u2028' || cch == '\\u2029') {\n                      end = j + 1;\n                      break;\n                    }\n                  }\n                  break;\n                case '*':\n                  end = n;\n                  if (i + 3 < n) {\n                    for (int j = i + 2;\n                         (j = jsonish.indexOf('/', j + 1)) >= 0;) {\n                      if (jsonish.charAt(j - 1) == '*') {\n                        end = j + 1;\n                        break;\n                      }\n                    }\n                  }\n                  break;\n              }\n            }\n            elide(i, end);\n            i = end - 1;\n            break;\n\n          default:\n            // Three kinds of other values can occur.\n            // 1. Numbers\n            // 2. Keyword values (\""false\"", \""null\"", \""true\"")\n            // 3. Unquoted JS property names as in the JS expression\n            //      ({ foo: \""bar\""})\n            //    which is equivalent to the JSON\n            //      { \""foo\"": \""bar\"" }\n            // 4. Cruft tokens like BOMs.\n\n            // Look for a run of '.', [0-9], [a-zA-Z_$], [+-] which subsumes\n            // all the above without including any JSON special characters\n            // outside keyword and number.\n            int runEnd;\n            for (runEnd = i; runEnd < n; ++runEnd) {\n              char tch = jsonish.charAt(runEnd);\n              if (('a' <= tch && tch <= 'z') || ('0' <= tch && tch <= '9')\n                  || tch == '+' || tch == '-' || tch == '.'\n                  || ('A' <= tch && tch <= 'Z') || tch == '_' || tch == '$') {\n                continue;\n              }\n              break;\n            }\n\n            if (runEnd == i) {\n              elide(i, i + 1);\n              break;\n            }\n\n            state = requireValueState(i, state, true);\n\n            boolean isNumber = ('0' <= ch && ch <= '9')\n               || ch == '.' || ch == '+' || ch == '-';\n            boolean isKeyword = !isNumber && isKeyword(i, runEnd);\n\n            if (!(isNumber || isKeyword)) {\n              // We're going to have to quote the output.  Further expand to\n              // include more of an unquoted token in a string.\n              for (; runEnd < n; ++runEnd) {\n                if (isJsonSpecialChar(runEnd)) {\n                  break;\n                }\n              }\n              if (runEnd < n && jsonish.charAt(runEnd) == '\""') {\n                ++runEnd;\n              }\n            }\n\n            if (state == State.AFTER_KEY) {\n              // We need to quote whatever we have since it is used as a\n              // property name in a map and only quoted strings can be used that\n              // way in JSON.\n              insert(i, '\""');\n              if (isNumber) {\n                // By JS rules,\n                //   { .5e-1: \""bar\"" }\n                // is the same as\n                //   { \""0.05\"": \""bar\"" }\n                // because a number literal is converted to its string form\n                // before being used as a property name.\n                canonicalizeNumber(i, runEnd);\n                // We intentionally ignore the return value of canonicalize.\n                // Uncanonicalizable numbers just get put straight through as\n                // string values.\n                insert(runEnd, '\""');\n              } else {\n                sanitizeString(i, runEnd);\n              }\n            } else {\n              if (isNumber) {\n                // Convert hex and octal constants to decimal and ensure that\n                // integer and fraction portions are not empty.\n                normalizeNumber(i, runEnd);\n              } else if (!isKeyword) {\n                // Treat as an unquoted string literal.\n                insert(i, '\""');\n                sanitizeString(i, runEnd);\n              }\n            }\n            i = runEnd - 1;\n        }\n      } catch (@SuppressWarnings(\""unused\"") UnbracketedComma e) {\n        elide(i, jsonish.length());\n        break;\n      }\n    }\n\n    if (state == State.START_ARRAY && bracketDepth == 0) {\n      // No tokens.  Only whitespace\n      insert(n, \""null\"");\n      state = State.AFTER_ELEMENT;\n    }\n\n    if (SUPER_VERBOSE_AND_SLOW_LOGGING) {\n      System.err.println(\n          \""state=\"" + state + \"", sanitizedJson=\"" + sanitizedJson\n          + \"", cleaned=\"" + cleaned + \"", bracketDepth=\"" + bracketDepth);\n    }\n\n    if ((sanitizedJson != null && sanitizedJson.length() != 0)\n        || cleaned != 0 || bracketDepth != 0) {\n      if (sanitizedJson == null) {\n        sanitizedJson = new StringBuilder(n + bracketDepth);\n      }\n      sanitizedJson.append(jsonish, cleaned, n);\n      cleaned = n;\n\n      switch (state) {\n        case BEFORE_ELEMENT: case BEFORE_KEY:\n          elideTrailingComma(n);\n          break;\n        case AFTER_KEY:\n          sanitizedJson.append(\"":null\"");\n          break;\n        case BEFORE_VALUE:\n          sanitizedJson.append(\""null\"");\n          break;\n        default: break;\n      }\n\n      // Insert brackets to close unclosed content.\n      while (bracketDepth != 0) {\n        sanitizedJson.append(isMap[--bracketDepth] ? '}' : ']');\n      }\n    }\n  }\n"", ""caller_start"": 207, ""file_path"": ""src/main/java/com/google/json/JsonSanitizer.java""}, {""call_line"": 434, ""call_code"": ""this.sanitizeString(i, runEnd)"", ""caller_code"": ""  void sanitize() {\n    // Return to consistent state.\n    bracketDepth = cleaned = 0;\n    sanitizedJson = null;\n\n    State state = State.START_ARRAY;\n    int n = jsonish.length();\n\n    // Walk over each token and either validate it, by just advancing i and\n    // computing the next state, or manipulate cleaned&sanitizedJson so that\n    // sanitizedJson contains the sanitized equivalent of\n    // jsonish.substring(0, cleaned).\n    token_loop:\n    for (int i = 0; i < n; ++i) {\n      try {\n        char ch = jsonish.charAt(i);\n        if (SUPER_VERBOSE_AND_SLOW_LOGGING) {\n          String sanitizedJsonStr =\n            (sanitizedJson == null ? \""\"" : sanitizedJson)\n            + jsonish.substring(cleaned, i);\n          System.err.println(\""i=\"" + i + \"", ch=\"" + ch + \"", state=\"" + state\n                             + \"", sanitized=\"" + sanitizedJsonStr);\n        }\n        switch (ch) {\n          case '\\t': case '\\n': case '\\r': case ' ':\n            break;\n\n          case '\""': case '\\'':\n            state = requireValueState(i, state, true);\n            int strEnd = endOfQuotedString(jsonish, i);\n            sanitizeString(i, strEnd);\n            i = strEnd - 1;\n            break;\n\n          case '(': case ')':\n            // Often JSON-like content which is meant for use by eval is\n            // wrapped in parentheses so that the JS parser treats contained\n            // curly brackets as part of an object constructor instead of a\n            // block statement.\n            // We elide these grouping parentheses to ensure valid JSON.\n            elide(i, i + 1);\n            break;\n\n          case '{': case '[':\n            state = requireValueState(i, state, false);\n            if (isMap == null) {\n              isMap = new boolean[maximumNestingDepth];\n            }\n            boolean map = ch == '{';\n            isMap[bracketDepth] = map;\n            ++bracketDepth;\n            state = map ? State.START_MAP : State.START_ARRAY;\n            break;\n\n          case '}': case ']':\n            if (bracketDepth == 0) {\n              elide(i, jsonish.length());\n              break token_loop;\n            }\n\n            // Strip trailing comma to convert {\""a\"":0,} -> {\""a\"":0}\n            // and [1,2,3,] -> [1,2,3,]\n            switch (state) {\n              case BEFORE_VALUE:\n                insert(i, \""null\"");\n                break;\n              case BEFORE_ELEMENT: case BEFORE_KEY:\n                elideTrailingComma(i);\n                break;\n              case AFTER_KEY:\n                insert(i, \"":null\"");\n                break;\n              case START_MAP: case START_ARRAY:\n              case AFTER_ELEMENT: case AFTER_VALUE: break;\n            }\n\n            --bracketDepth;\n            char closeBracket = isMap[bracketDepth] ? '}' : ']';\n            if (ch != closeBracket) {\n              replace(i, i + 1, closeBracket);\n            }\n            state = bracketDepth == 0 || !isMap[bracketDepth - 1]\n                ? State.AFTER_ELEMENT : State.AFTER_VALUE;\n            break;\n          case ',':\n            if (bracketDepth == 0) { throw UNBRACKETED_COMMA; }\n            // Convert comma elisions like [1,,3] to [1,null,3].\n            // [1,,3] in JS is an array that has no element at index 1\n            // according to the \""in\"" operator so accessing index 1 will\n            // yield the special value \""undefined\"" which is equivalent to\n            // JS's \""null\"" value according to \""==\"".\n            switch (state) {\n              // Normal\n              case AFTER_ELEMENT:\n                state = State.BEFORE_ELEMENT;\n                break;\n              case AFTER_VALUE:\n                state = State.BEFORE_KEY;\n                break;\n              // Array elision.\n              case START_ARRAY: case BEFORE_ELEMENT:\n                insert(i, \""null\"");\n                state = State.BEFORE_ELEMENT;\n                break;\n              // Ignore\n              case START_MAP: case BEFORE_KEY:\n              case AFTER_KEY:\n                elide(i, i + 1);\n                break;\n              // Supply missing value.\n              case BEFORE_VALUE:\n                insert(i, \""null\"");\n                state = State.BEFORE_KEY;\n                break;\n            }\n            break;\n\n          case ':':\n            if (state == State.AFTER_KEY) {\n              state = State.BEFORE_VALUE;\n            } else {\n              elide(i, i + 1);\n            }\n            break;\n\n          case '/':\n            // Skip over JS-style comments since people like inserting them into\n            // data files and getting huffy with Crockford when he says no to\n            // versioning JSON to allow ignorable tokens.\n            int end = i + 1;\n            if (i + 1 < n) {\n              switch (jsonish.charAt(i + 1)) {\n                case '/':\n                  end = n;  // Worst case.\n                  for (int j = i + 2; j < n; ++j) {\n                    char cch = jsonish.charAt(j);\n                    if (cch == '\\n' || cch == '\\r'\n                        || cch == '\\u2028' || cch == '\\u2029') {\n                      end = j + 1;\n                      break;\n                    }\n                  }\n                  break;\n                case '*':\n                  end = n;\n                  if (i + 3 < n) {\n                    for (int j = i + 2;\n                         (j = jsonish.indexOf('/', j + 1)) >= 0;) {\n                      if (jsonish.charAt(j - 1) == '*') {\n                        end = j + 1;\n                        break;\n                      }\n                    }\n                  }\n                  break;\n              }\n            }\n            elide(i, end);\n            i = end - 1;\n            break;\n\n          default:\n            // Three kinds of other values can occur.\n            // 1. Numbers\n            // 2. Keyword values (\""false\"", \""null\"", \""true\"")\n            // 3. Unquoted JS property names as in the JS expression\n            //      ({ foo: \""bar\""})\n            //    which is equivalent to the JSON\n            //      { \""foo\"": \""bar\"" }\n            // 4. Cruft tokens like BOMs.\n\n            // Look for a run of '.', [0-9], [a-zA-Z_$], [+-] which subsumes\n            // all the above without including any JSON special characters\n            // outside keyword and number.\n            int runEnd;\n            for (runEnd = i; runEnd < n; ++runEnd) {\n              char tch = jsonish.charAt(runEnd);\n              if (('a' <= tch && tch <= 'z') || ('0' <= tch && tch <= '9')\n                  || tch == '+' || tch == '-' || tch == '.'\n                  || ('A' <= tch && tch <= 'Z') || tch == '_' || tch == '$') {\n                continue;\n              }\n              break;\n            }\n\n            if (runEnd == i) {\n              elide(i, i + 1);\n              break;\n            }\n\n            state = requireValueState(i, state, true);\n\n            boolean isNumber = ('0' <= ch && ch <= '9')\n               || ch == '.' || ch == '+' || ch == '-';\n            boolean isKeyword = !isNumber && isKeyword(i, runEnd);\n\n            if (!(isNumber || isKeyword)) {\n              // We're going to have to quote the output.  Further expand to\n              // include more of an unquoted token in a string.\n              for (; runEnd < n; ++runEnd) {\n                if (isJsonSpecialChar(runEnd)) {\n                  break;\n                }\n              }\n              if (runEnd < n && jsonish.charAt(runEnd) == '\""') {\n                ++runEnd;\n              }\n            }\n\n            if (state == State.AFTER_KEY) {\n              // We need to quote whatever we have since it is used as a\n              // property name in a map and only quoted strings can be used that\n              // way in JSON.\n              insert(i, '\""');\n              if (isNumber) {\n                // By JS rules,\n                //   { .5e-1: \""bar\"" }\n                // is the same as\n                //   { \""0.05\"": \""bar\"" }\n                // because a number literal is converted to its string form\n                // before being used as a property name.\n                canonicalizeNumber(i, runEnd);\n                // We intentionally ignore the return value of canonicalize.\n                // Uncanonicalizable numbers just get put straight through as\n                // string values.\n                insert(runEnd, '\""');\n              } else {\n                sanitizeString(i, runEnd);\n              }\n            } else {\n              if (isNumber) {\n                // Convert hex and octal constants to decimal and ensure that\n                // integer and fraction portions are not empty.\n                normalizeNumber(i, runEnd);\n              } else if (!isKeyword) {\n                // Treat as an unquoted string literal.\n                insert(i, '\""');\n                sanitizeString(i, runEnd);\n              }\n            }\n            i = runEnd - 1;\n        }\n      } catch (@SuppressWarnings(\""unused\"") UnbracketedComma e) {\n        elide(i, jsonish.length());\n        break;\n      }\n    }\n\n    if (state == State.START_ARRAY && bracketDepth == 0) {\n      // No tokens.  Only whitespace\n      insert(n, \""null\"");\n      state = State.AFTER_ELEMENT;\n    }\n\n    if (SUPER_VERBOSE_AND_SLOW_LOGGING) {\n      System.err.println(\n          \""state=\"" + state + \"", sanitizedJson=\"" + sanitizedJson\n          + \"", cleaned=\"" + cleaned + \"", bracketDepth=\"" + bracketDepth);\n    }\n\n    if ((sanitizedJson != null && sanitizedJson.length() != 0)\n        || cleaned != 0 || bracketDepth != 0) {\n      if (sanitizedJson == null) {\n        sanitizedJson = new StringBuilder(n + bracketDepth);\n      }\n      sanitizedJson.append(jsonish, cleaned, n);\n      cleaned = n;\n\n      switch (state) {\n        case BEFORE_ELEMENT: case BEFORE_KEY:\n          elideTrailingComma(n);\n          break;\n        case AFTER_KEY:\n          sanitizedJson.append(\"":null\"");\n          break;\n        case BEFORE_VALUE:\n          sanitizedJson.append(\""null\"");\n          break;\n        default: break;\n      }\n\n      // Insert brackets to close unclosed content.\n      while (bracketDepth != 0) {\n        sanitizedJson.append(isMap[--bracketDepth] ? '}' : ']');\n      }\n    }\n  }\n"", ""caller_start"": 207, ""file_path"": ""src/main/java/com/google/json/JsonSanitizer.java""}, {""call_line"": 444, ""call_code"": ""this.sanitizeString(i, runEnd)"", ""caller_code"": ""  void sanitize() {\n    // Return to consistent state.\n    bracketDepth = cleaned = 0;\n    sanitizedJson = null;\n\n    State state = State.START_ARRAY;\n    int n = jsonish.length();\n\n    // Walk over each token and either validate it, by just advancing i and\n    // computing the next state, or manipulate cleaned&sanitizedJson so that\n    // sanitizedJson contains the sanitized equivalent of\n    // jsonish.substring(0, cleaned).\n    token_loop:\n    for (int i = 0; i < n; ++i) {\n      try {\n        char ch = jsonish.charAt(i);\n        if (SUPER_VERBOSE_AND_SLOW_LOGGING) {\n          String sanitizedJsonStr =\n            (sanitizedJson == null ? \""\"" : sanitizedJson)\n            + jsonish.substring(cleaned, i);\n          System.err.println(\""i=\"" + i + \"", ch=\"" + ch + \"", state=\"" + state\n                             + \"", sanitized=\"" + sanitizedJsonStr);\n        }\n        switch (ch) {\n          case '\\t': case '\\n': case '\\r': case ' ':\n            break;\n\n          case '\""': case '\\'':\n            state = requireValueState(i, state, true);\n            int strEnd = endOfQuotedString(jsonish, i);\n            sanitizeString(i, strEnd);\n            i = strEnd - 1;\n            break;\n\n          case '(': case ')':\n            // Often JSON-like content which is meant for use by eval is\n            // wrapped in parentheses so that the JS parser treats contained\n            // curly brackets as part of an object constructor instead of a\n            // block statement.\n            // We elide these grouping parentheses to ensure valid JSON.\n            elide(i, i + 1);\n            break;\n\n          case '{': case '[':\n            state = requireValueState(i, state, false);\n            if (isMap == null) {\n              isMap = new boolean[maximumNestingDepth];\n            }\n            boolean map = ch == '{';\n            isMap[bracketDepth] = map;\n            ++bracketDepth;\n            state = map ? State.START_MAP : State.START_ARRAY;\n            break;\n\n          case '}': case ']':\n            if (bracketDepth == 0) {\n              elide(i, jsonish.length());\n              break token_loop;\n            }\n\n            // Strip trailing comma to convert {\""a\"":0,} -> {\""a\"":0}\n            // and [1,2,3,] -> [1,2,3,]\n            switch (state) {\n              case BEFORE_VALUE:\n                insert(i, \""null\"");\n                break;\n              case BEFORE_ELEMENT: case BEFORE_KEY:\n                elideTrailingComma(i);\n                break;\n              case AFTER_KEY:\n                insert(i, \"":null\"");\n                break;\n              case START_MAP: case START_ARRAY:\n              case AFTER_ELEMENT: case AFTER_VALUE: break;\n            }\n\n            --bracketDepth;\n            char closeBracket = isMap[bracketDepth] ? '}' : ']';\n            if (ch != closeBracket) {\n              replace(i, i + 1, closeBracket);\n            }\n            state = bracketDepth == 0 || !isMap[bracketDepth - 1]\n                ? State.AFTER_ELEMENT : State.AFTER_VALUE;\n            break;\n          case ',':\n            if (bracketDepth == 0) { throw UNBRACKETED_COMMA; }\n            // Convert comma elisions like [1,,3] to [1,null,3].\n            // [1,,3] in JS is an array that has no element at index 1\n            // according to the \""in\"" operator so accessing index 1 will\n            // yield the special value \""undefined\"" which is equivalent to\n            // JS's \""null\"" value according to \""==\"".\n            switch (state) {\n              // Normal\n              case AFTER_ELEMENT:\n                state = State.BEFORE_ELEMENT;\n                break;\n              case AFTER_VALUE:\n                state = State.BEFORE_KEY;\n                break;\n              // Array elision.\n              case START_ARRAY: case BEFORE_ELEMENT:\n                insert(i, \""null\"");\n                state = State.BEFORE_ELEMENT;\n                break;\n              // Ignore\n              case START_MAP: case BEFORE_KEY:\n              case AFTER_KEY:\n                elide(i, i + 1);\n                break;\n              // Supply missing value.\n              case BEFORE_VALUE:\n                insert(i, \""null\"");\n                state = State.BEFORE_KEY;\n                break;\n            }\n            break;\n\n          case ':':\n            if (state == State.AFTER_KEY) {\n              state = State.BEFORE_VALUE;\n            } else {\n              elide(i, i + 1);\n            }\n            break;\n\n          case '/':\n            // Skip over JS-style comments since people like inserting them into\n            // data files and getting huffy with Crockford when he says no to\n            // versioning JSON to allow ignorable tokens.\n            int end = i + 1;\n            if (i + 1 < n) {\n              switch (jsonish.charAt(i + 1)) {\n                case '/':\n                  end = n;  // Worst case.\n                  for (int j = i + 2; j < n; ++j) {\n                    char cch = jsonish.charAt(j);\n                    if (cch == '\\n' || cch == '\\r'\n                        || cch == '\\u2028' || cch == '\\u2029') {\n                      end = j + 1;\n                      break;\n                    }\n                  }\n                  break;\n                case '*':\n                  end = n;\n                  if (i + 3 < n) {\n                    for (int j = i + 2;\n                         (j = jsonish.indexOf('/', j + 1)) >= 0;) {\n                      if (jsonish.charAt(j - 1) == '*') {\n                        end = j + 1;\n                        break;\n                      }\n                    }\n                  }\n                  break;\n              }\n            }\n            elide(i, end);\n            i = end - 1;\n            break;\n\n          default:\n            // Three kinds of other values can occur.\n            // 1. Numbers\n            // 2. Keyword values (\""false\"", \""null\"", \""true\"")\n            // 3. Unquoted JS property names as in the JS expression\n            //      ({ foo: \""bar\""})\n            //    which is equivalent to the JSON\n            //      { \""foo\"": \""bar\"" }\n            // 4. Cruft tokens like BOMs.\n\n            // Look for a run of '.', [0-9], [a-zA-Z_$], [+-] which subsumes\n            // all the above without including any JSON special characters\n            // outside keyword and number.\n            int runEnd;\n            for (runEnd = i; runEnd < n; ++runEnd) {\n              char tch = jsonish.charAt(runEnd);\n              if (('a' <= tch && tch <= 'z') || ('0' <= tch && tch <= '9')\n                  || tch == '+' || tch == '-' || tch == '.'\n                  || ('A' <= tch && tch <= 'Z') || tch == '_' || tch == '$') {\n                continue;\n              }\n              break;\n            }\n\n            if (runEnd == i) {\n              elide(i, i + 1);\n              break;\n            }\n\n            state = requireValueState(i, state, true);\n\n            boolean isNumber = ('0' <= ch && ch <= '9')\n               || ch == '.' || ch == '+' || ch == '-';\n            boolean isKeyword = !isNumber && isKeyword(i, runEnd);\n\n            if (!(isNumber || isKeyword)) {\n              // We're going to have to quote the output.  Further expand to\n              // include more of an unquoted token in a string.\n              for (; runEnd < n; ++runEnd) {\n                if (isJsonSpecialChar(runEnd)) {\n                  break;\n                }\n              }\n              if (runEnd < n && jsonish.charAt(runEnd) == '\""') {\n                ++runEnd;\n              }\n            }\n\n            if (state == State.AFTER_KEY) {\n              // We need to quote whatever we have since it is used as a\n              // property name in a map and only quoted strings can be used that\n              // way in JSON.\n              insert(i, '\""');\n              if (isNumber) {\n                // By JS rules,\n                //   { .5e-1: \""bar\"" }\n                // is the same as\n                //   { \""0.05\"": \""bar\"" }\n                // because a number literal is converted to its string form\n                // before being used as a property name.\n                canonicalizeNumber(i, runEnd);\n                // We intentionally ignore the return value of canonicalize.\n                // Uncanonicalizable numbers just get put straight through as\n                // string values.\n                insert(runEnd, '\""');\n              } else {\n                sanitizeString(i, runEnd);\n              }\n            } else {\n              if (isNumber) {\n                // Convert hex and octal constants to decimal and ensure that\n                // integer and fraction portions are not empty.\n                normalizeNumber(i, runEnd);\n              } else if (!isKeyword) {\n                // Treat as an unquoted string literal.\n                insert(i, '\""');\n                sanitizeString(i, runEnd);\n              }\n            }\n            i = runEnd - 1;\n        }\n      } catch (@SuppressWarnings(\""unused\"") UnbracketedComma e) {\n        elide(i, jsonish.length());\n        break;\n      }\n    }\n\n    if (state == State.START_ARRAY && bracketDepth == 0) {\n      // No tokens.  Only whitespace\n      insert(n, \""null\"");\n      state = State.AFTER_ELEMENT;\n    }\n\n    if (SUPER_VERBOSE_AND_SLOW_LOGGING) {\n      System.err.println(\n          \""state=\"" + state + \"", sanitizedJson=\"" + sanitizedJson\n          + \"", cleaned=\"" + cleaned + \"", bracketDepth=\"" + bracketDepth);\n    }\n\n    if ((sanitizedJson != null && sanitizedJson.length() != 0)\n        || cleaned != 0 || bracketDepth != 0) {\n      if (sanitizedJson == null) {\n        sanitizedJson = new StringBuilder(n + bracketDepth);\n      }\n      sanitizedJson.append(jsonish, cleaned, n);\n      cleaned = n;\n\n      switch (state) {\n        case BEFORE_ELEMENT: case BEFORE_KEY:\n          elideTrailingComma(n);\n          break;\n        case AFTER_KEY:\n          sanitizedJson.append(\"":null\"");\n          break;\n        case BEFORE_VALUE:\n          sanitizedJson.append(\""null\"");\n          break;\n        default: break;\n      }\n\n      // Insert brackets to close unclosed content.\n      while (bracketDepth != 0) {\n        sanitizedJson.append(isMap[--bracketDepth] ? '}' : ']');\n      }\n    }\n  }\n"", ""caller_start"": 207, ""file_path"": ""src/main/java/com/google/json/JsonSanitizer.java""}]}, {""source"": ""value_info(file:JsonSanitizer.java, value:jsonish)"", ""result"": {""value_trace"": [{""full_code"": ""this.jsonish = jsonish != null ? jsonish : \""null\"""", ""line"": 200, ""func_name"": ""com.google.json.JsonSanitizer.<init>:void(java.lang.String,int)""}], ""struct_var"": ""jsonish"", ""struct_type"": null, ""struct_definition"": null}}]","src/main/java/com/google/json/JsonSanitizer.java:542-574: The original `sanitizeString` method only escaped `</script`, leaving substrings like `<script`, `<!--`, and `-->` unescaped. These sequences, when embedded in HTML script elements, could trigger parser state transitions (e.g., exiting script context) and enable XSS. The patch adds logic to detect and escape these substrings by replacing `<` and `>` with `\\u003c`/`\\u003e`. The `jsonish` input (initialized in the constructor at line 200) is sanitized via `sanitizeString` calls in `sanitize()` (lines 237, 434, 444), ensuring string literals and unquoted tokens are processed. The vulnerability arises when attacker-controlled input contains these substrings, which bypassed prior escaping logic.",0.95,./github/other_context/CVE-2020-13973
46,CVE-2021-21261,CWE-74,c_cpp,"Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. A bug was discovered in the `flatpak-portal` service that can allow sandboxed applications to execute arbitrary code on the host system (a sandbox escape). This sandbox-escape bug is present in versions from 0.11.4 and before fixed versions 1.8.5 and 1.10.0. The Flatpak portal D-Bus service (`flatpak-portal`, also known by its D-Bus service name `org.freedesktop.portal.Flatpak`) allows apps in a Flatpak sandbox to launch their own subprocesses in a new sandbox instance, either with the same security settings as the caller or with more restrictive security settings. For example, this is used in Flatpak-packaged web browsers such as Chromium to launch subprocesses that will process untrusted web content, and give those subprocesses a more restrictive sandbox than the browser itself. In vulnerable versions, the Flatpak portal service passes caller-specified environment variables to non-sandboxed processes on the host system, and in particular to the `flatpak run` command that is used to launch the new sandbox instance. A malicious or compromised Flatpak app could set environment variables that are trusted by the `flatpak run` command, and use them to execute arbitrary code that is not in a sandbox. As a workaround, this vulnerability can be mitigated by preventing the `flatpak-portal` service from starting, but that mitigation will prevent many Flatpak apps from working correctly. This is fixed in versions 1.8.5 and 1.10.0.",https://github.com/flatpak/flatpak/commit/cc1401043c075268ecc652eac557ef8076b5eaba,"portal: Do not use caller-supplied variables in environment\n\nIf the caller specifies a variable that can be used to inject arbitrary\ncode into processes, we must not allow it to enter the environment\nblock used to run `flatpak run`, which runs unsandboxed.\n\nThis change requires the previous commit ""context: Add --env-fd option"",\nwhich adds infrastructure used here.\n\nTo be secure, this change also requires the previous commit\n""run: Convert all environment variables into bwrap arguments"", which\nprotects a non-setuid bwrap(1) from the same attack.\n\nSigned-off-by: Simon McVittie <smcv@collabora.com>\nPart-of: https://github.com/flatpak/flatpak/security/advisories/GHSA-4ppf-fxf6-vxg2",5,"[{""func_name"": ""handle_spawn"", ""file_path"": ""portal/flatpak-portal.c"", ""func_code"": ""static gboolean\nhandle_spawn (PortalFlatpak         *object,\n              GDBusMethodInvocation *invocation,\n              GUnixFDList           *fd_list,\n              const gchar           *arg_cwd_path,\n              const gchar *const    *arg_argv,\n              GVariant              *arg_fds,\n              GVariant              *arg_envs,\n              guint                  arg_flags,\n              GVariant              *arg_options)\n{\n  g_autoptr(GError) error = NULL;\n  ChildSetupData child_setup_data = { NULL };\n  GPid pid;\n  PidData *pid_data;\n  InstanceIdReadData *instance_id_read_data = NULL;\n  gsize i, j, n_fds, n_envs;\n  const gint *fds = NULL;\n  gint fds_len = 0;\n  g_autofree FdMapEntry *fd_map = NULL;\n  gchar **env;\n  gint32 max_fd;\n  GKeyFile *app_info;\n  g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);\n  g_autofree char *app_id = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *arch = NULL;\n  g_autofree char *app_commit = NULL;\n  g_autofree char *runtime_ref = NULL;\n  g_auto(GStrv) runtime_parts = NULL;\n  g_autofree char *runtime_commit = NULL;\n  g_autofree char *instance_path = NULL;\n  g_auto(GStrv) extra_args = NULL;\n  g_auto(GStrv) shares = NULL;\n  g_auto(GStrv) sockets = NULL;\n  g_auto(GStrv) devices = NULL;\n  g_auto(GStrv) sandbox_expose = NULL;\n  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n  g_autoptr(GString) env_string = g_string_new (\""\"");\n\n  child_setup_data.instance_id_fd = -1;\n  child_setup_data.env_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \""app-info\"");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n  g_assert (app_id != NULL);\n\n  g_debug (\""spawn() called from app: '%s'\"", app_id);\n  if (*app_id == 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""org.freedesktop.portal.Flatpak.Spawn only works in a flatpak\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (*arg_cwd_path == 0)\n    arg_cwd_path = NULL;\n\n  if (arg_argv == NULL || *arg_argv == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""No command given\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Unsupported flags enabled: 0x%x\"", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_ref = g_key_file_get_string (app_info,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  if (runtime_ref == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""No runtime found\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_parts = g_strsplit (runtime_ref, \""/\"", -1);\n\n  branch = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_BRANCH, NULL);\n  instance_path = g_key_file_get_string (app_info,\n                                         FLATPAK_METADATA_GROUP_INSTANCE,\n                                         FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);\n  arch = g_key_file_get_string (app_info,\n                                FLATPAK_METADATA_GROUP_INSTANCE,\n                                FLATPAK_METADATA_KEY_ARCH, NULL);\n  extra_args = g_key_file_get_string_list (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);\n  app_commit = g_key_file_get_string (app_info,\n                                      FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_APP_COMMIT, NULL);\n  runtime_commit = g_key_file_get_string (app_info,\n                                          FLATPAK_METADATA_GROUP_INSTANCE,\n                                          FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);\n  shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SHARED, NULL, NULL);\n  sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);\n  devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                        FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);\n\n  devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_DEVEL, NULL);\n\n  g_variant_lookup (arg_options, \""sandbox-expose\"", \""^as\"", &sandbox_expose);\n  g_variant_lookup (arg_options, \""sandbox-expose-ro\"", \""^as\"", &sandbox_expose_ro);\n  g_variant_lookup (arg_options, \""sandbox-flags\"", \""u\"", &sandbox_flags);\n  sandbox_expose_fd = g_variant_lookup_value (arg_options, \""sandbox-expose-fd\"", G_VARIANT_TYPE (\""ah\""));\n  sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, \""sandbox-expose-fd-ro\"", G_VARIANT_TYPE (\""ah\""));\n\n  if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Unsupported sandbox flags enabled: 0x%x\"", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_path == NULL &&\n      ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||\n       (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Invalid sandbox expose, caller has no instance path\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose[i];\n\n      g_debug (\""exposing %s\"", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\""exposing %s\"", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  g_debug (\""Running spawn command %s\"", arg_argv[0]);\n\n  n_fds = 0;\n  if (fds != NULL)\n    n_fds = g_variant_n_children (arg_fds);\n  fd_map = g_new0 (FdMapEntry, n_fds);\n\n  child_setup_data.fd_map = fd_map;\n  child_setup_data.fd_map_len = n_fds;\n\n  max_fd = -1;\n  for (i = 0; i < n_fds; i++)\n    {\n      gint32 handle, dest_fd;\n      int handle_fd;\n\n      g_variant_get_child (arg_fds, i, \""{uh}\"", &dest_fd, &handle);\n\n      if (handle >= fds_len || handle < 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \""No file descriptor for handle %d\"",\n                                                 handle);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      handle_fd = fds[handle];\n\n      fd_map[i].to = dest_fd;\n      fd_map[i].from = handle_fd;\n      fd_map[i].final = fd_map[i].to;\n\n      /* If stdin/out/err is a tty we try to set it as the controlling\n         tty for the app, this way we can use this to run in a terminal. */\n      if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&\n          !child_setup_data.set_tty &&\n          isatty (handle_fd))\n        {\n          child_setup_data.set_tty = TRUE;\n          child_setup_data.tty = handle_fd;\n        }\n\n      max_fd = MAX (max_fd, fd_map[i].to);\n      max_fd = MAX (max_fd, fd_map[i].from);\n    }\n\n  /* We make a second pass over the fds to find if any \""to\"" fd index\n     overlaps an already in use fd (i.e. one in the \""from\"" category\n     that are allocated randomly). If a fd overlaps \""to\"" fd then its\n     a caller issue and not our fault, so we ignore that. */\n  for (i = 0; i < n_fds; i++)\n    {\n      int to_fd = fd_map[i].to;\n      gboolean conflict = FALSE;\n\n      /* At this point we're fine with using \""from\"" values for this\n         value (because we handle to==from in the code), or values\n         that are before \""i\"" in the fd_map (because those will be\n         closed at this point when dup:ing). However, we can't\n         reuse a fd that is in \""from\"" for j > i. */\n      for (j = i + 1; j < n_fds; j++)\n        {\n          int from_fd = fd_map[j].from;\n          if (from_fd == to_fd)\n            {\n              conflict = TRUE;\n              break;\n            }\n        }\n\n      if (conflict)\n        fd_map[i].to = ++max_fd;\n    }\n\n  if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)\n    {\n      char *empty[] = { NULL };\n      env = g_strdupv (empty);\n    }\n  else\n    env = g_get_environ ();\n\n  n_envs = g_variant_n_children (arg_envs);\n  for (i = 0; i < n_envs; i++)\n    {\n      const char *var = NULL;\n      const char *val = NULL;\n      g_variant_get_child (arg_envs, i, \""{&s&s}\"", &var, &val);\n\n      env = g_environ_setenv (env, var, val, TRUE);\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup (\""flatpak\""));\n  g_ptr_array_add (flatpak_argv, g_strdup (\""run\""));\n\n  sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;\n\n  if (sandboxed)\n    {\n      g_ptr_array_add (flatpak_argv, g_strdup (\""--sandbox\""));\n\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""wayland\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=wayland\""));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""fallback-x11\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=fallback-x11\""));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""x11\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=x11\""));\n          if (shares != NULL && g_strv_contains ((const char * const *) shares, \""ipc\"") &&\n              sockets != NULL && (g_strv_contains ((const char * const *) sockets, \""fallback-x11\"") ||\n                                  g_strv_contains ((const char * const *) sockets, \""x11\"")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--share=ipc\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""pulseaudio\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=pulseaudio\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)\n        {\n          if (devices != NULL &&\n              (g_strv_contains ((const char * const *) devices, \""dri\"") ||\n               g_strv_contains ((const char * const *) devices, \""all\"")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--device=dri\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--session-bus\""));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--a11y-bus\""));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        {\n          if (g_str_has_prefix (extra_args[i], \""--env=\""))\n            {\n              const char *var_val = extra_args[i] + strlen (\""--env=\"");\n\n              if (var_val[0] == '\\0' || var_val[0] == '=')\n                {\n                  g_warning (\""Environment variable in extra-args has empty name\"");\n                  continue;\n                }\n\n              if (strchr (var_val, '=') == NULL)\n                {\n                  g_warning (\""Environment variable in extra-args has no value\"");\n                  continue;\n                }\n\n              g_string_append (env_string, var_val);\n              g_string_append_c (env_string, '\\0');\n            }\n          else\n            {\n              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n            }\n        }\n    }\n\n  if (env_string->len > 0)\n    {\n      g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n\n      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \""environ\"",\n                                                      env_string->str,\n                                                      env_string->len, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n      g_ptr_array_add (flatpak_argv,\n                       g_strdup_printf (\""--env-fd=%d\"",\n                                        child_setup_data.env_fd));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n\n      if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_NOT_SUPPORTED,\n                                                 \""Expose pids not supported with setuid bwrap\"");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      instance_id = g_key_file_get_string (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);\n\n      if (instance_id)\n        {\n          g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);\n          sender_pid1 = flatpak_instance_get_child_pid (instance);\n        }\n\n      if (sender_pid1 == 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \""Could not find requesting pid\"");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--parent-pid=%d\"", sender_pid1));\n\n      if (share_pids)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--parent-share-pids\""));\n      else\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--parent-expose-pids\""));\n    }\n\n  notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;\n  if (notify_start)\n    {\n      int pipe_fds[2];\n      if (pipe (pipe_fds) == -1)\n        {\n          int errsv = errno;\n          g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,\n                                                 g_io_error_from_errno (errsv),\n                                                 \""Failed to create instance ID pipe: %s\"",\n                                                 g_strerror (errsv));\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));\n      /* This is saved to ensure the portal's end gets closed after the exec. */\n      instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));\n\n      instance_id_read_data = g_new0 (InstanceIdReadData, 1);\n\n      g_input_stream_read_async (in_stream, instance_id_read_data->buffer,\n                                 INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,\n                                 instance_id_read_finish, instance_id_read_data);\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--instance-id-fd=%d\"", pipe_fds[1]));\n      child_setup_data.instance_id_fd = pipe_fds[1];\n    }\n\n  if (devel)\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--devel\""));\n\n  /* Inherit launcher network access from launcher, unless\n     NO_NETWORK set. */\n  if (shares != NULL && g_strv_contains ((const char * const *) shares, \""network\"") &&\n      !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--share=network\""));\n  else\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--unshare=network\""));\n\n\n  if (instance_path)\n    {\n      for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));\n      for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\""exposing %s\"", expose);\n    }\n\n  if (sandbox_expose_fd != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd, i, \""h\"", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));\n                }\n              else\n                {\n                  g_debug (\""unable to get path for sandbox-exposed fd %d, ignoring: %s\"",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \""No file descriptor for handle %d\"",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  if (sandbox_expose_fd_ro != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd_ro);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd_ro, i, \""h\"", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));\n                }\n              else\n                {\n                  g_debug (\""unable to get path for sandbox-exposed fd %d, ignoring: %s\"",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \""No file descriptor for handle %d\"",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime=%s\"", runtime_parts[1]));\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime-version=%s\"", runtime_parts[3]));\n\n  if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)\n    {\n      if (app_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--commit=%s\"", app_commit));\n      if (runtime_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime-commit=%s\"", runtime_commit));\n    }\n\n  if (arg_cwd_path != NULL)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--cwd=%s\"", arg_cwd_path));\n\n  if (arg_argv[0][0] != 0)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--command=%s\"", arg_argv[0]));\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""%s/%s/%s\"", app_id, arch ? arch : \""\"", branch ? branch : \""\""));\n  for (i = 1; arg_argv[i] != NULL; i++)\n    g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));\n  g_ptr_array_add (flatpak_argv, NULL);\n\n  if (opt_verbose)\n    {\n      g_autoptr(GString) cmd = g_string_new (\""\"");\n\n      for (i = 0; flatpak_argv->pdata[i] != NULL; i++)\n        {\n          if (i > 0)\n            g_string_append (cmd, \"" \"");\n          g_string_append (cmd, flatpak_argv->pdata[i]);\n        }\n\n      g_debug (\""Starting: %s\\n\"", cmd->str);\n    }\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async_with_pipes (NULL,\n                                 (char **) flatpak_argv->pdata,\n                                 env,\n                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                                 child_setup_func, &child_setup_data,\n                                 &pid,\n                                 NULL,\n                                 NULL,\n                                 NULL,\n                                 &error))\n    {\n      gint code = G_DBUS_ERROR_FAILED;\n      if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))\n        code = G_DBUS_ERROR_ACCESS_DENIED;\n      else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))\n        code = G_DBUS_ERROR_FILE_NOT_FOUND;\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,\n                                             \""Failed to start command: %s\"",\n                                             error->message);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_id_read_data)\n    instance_id_read_data->pid = pid;\n\n  pid_data = g_new0 (PidData, 1);\n  pid_data->pid = pid;\n  pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));\n  pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;\n  pid_data->expose_or_share_pids = (expose_pids || share_pids);\n  pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,\n                                                  pid,\n                                                  child_watch_died,\n                                                  pid_data,\n                                                  NULL);\n\n  g_debug (\""Client Pid is %d\"", pid_data->pid);\n\n  g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),\n                        pid_data);\n\n  portal_flatpak_complete_spawn (object, invocation, NULL, pid);\n  return G_DBUS_METHOD_INVOCATION_HANDLED;\n}"", ""target"": 0}, {""func_name"": ""child_setup_func"", ""file_path"": ""portal/flatpak-portal.c"", ""func_code"": ""static void\nchild_setup_func (gpointer user_data)\n{\n  ChildSetupData *data = (ChildSetupData *) user_data;\n  FdMapEntry *fd_map = data->fd_map;\n  sigset_t set;\n  int i;\n\n  flatpak_close_fds_workaround (3);\n\n  if (data->instance_id_fd != -1)\n    drop_cloexec (data->instance_id_fd);\n\n  /* Unblock all signals */\n  sigemptyset (&set);\n  if (pthread_sigmask (SIG_SETMASK, &set, NULL) == -1)\n    {\n      g_warning (\""Failed to unblock signals when starting child\"");\n      return;\n    }\n\n  /* Reset the handlers for all signals to their defaults. */\n  for (i = 1; i < NSIG; i++)\n    {\n      if (i != SIGSTOP && i != SIGKILL)\n        signal (i, SIG_DFL);\n    }\n\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].from != fd_map[i].to)\n        {\n          dup2 (fd_map[i].from, fd_map[i].to);\n          close (fd_map[i].from);\n        }\n    }\n\n  /* Second pass in case we needed an in-between fd value to avoid conflicts */\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].to != fd_map[i].final)\n        {\n          dup2 (fd_map[i].to, fd_map[i].final);\n          close (fd_map[i].to);\n        }\n\n      /* Ensure we inherit the final fd value */\n      drop_cloexec (fd_map[i].final);\n    }\n\n  /* We become our own session and process group, because it never makes sense\n     to share the flatpak-session-helper dbus activated process group */\n  setsid ();\n  setpgid (0, 0);\n\n  if (data->set_tty)\n    {\n      /* data->tty is our from fd which is closed at this point.\n       * so locate the destination fd and use it for the ioctl.\n       */\n      for (i = 0; i < data->fd_map_len; i++)\n        {\n          if (fd_map[i].from == data->tty)\n            {\n              if (ioctl (fd_map[i].final, TIOCSCTTY, 0) == -1)\n                g_debug (\""ioctl(%d, TIOCSCTTY, 0) failed: %s\"",\n                         fd_map[i].final, strerror (errno));\n              break;\n            }\n        }\n    }\n}"", ""target"": 0}, {""func_name"": ""handle_spawn"", ""file_path"": ""portal/flatpak-portal.c"", ""func_code"": ""static gboolean\nhandle_spawn (PortalFlatpak         *object,\n              GDBusMethodInvocation *invocation,\n              GUnixFDList           *fd_list,\n              const gchar           *arg_cwd_path,\n              const gchar *const    *arg_argv,\n              GVariant              *arg_fds,\n              GVariant              *arg_envs,\n              guint                  arg_flags,\n              GVariant              *arg_options)\n{\n  g_autoptr(GError) error = NULL;\n  ChildSetupData child_setup_data = { NULL };\n  GPid pid;\n  PidData *pid_data;\n  InstanceIdReadData *instance_id_read_data = NULL;\n  gsize i, j, n_fds, n_envs;\n  const gint *fds = NULL;\n  gint fds_len = 0;\n  g_autofree FdMapEntry *fd_map = NULL;\n  gchar **env;\n  gint32 max_fd;\n  GKeyFile *app_info;\n  g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);\n  g_autofree char *app_id = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *arch = NULL;\n  g_autofree char *app_commit = NULL;\n  g_autofree char *runtime_ref = NULL;\n  g_auto(GStrv) runtime_parts = NULL;\n  g_autofree char *runtime_commit = NULL;\n  g_autofree char *instance_path = NULL;\n  g_auto(GStrv) extra_args = NULL;\n  g_auto(GStrv) shares = NULL;\n  g_auto(GStrv) sockets = NULL;\n  g_auto(GStrv) devices = NULL;\n  g_auto(GStrv) sandbox_expose = NULL;\n  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n\n  child_setup_data.instance_id_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \""app-info\"");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n  g_assert (app_id != NULL);\n\n  g_debug (\""spawn() called from app: '%s'\"", app_id);\n  if (*app_id == 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""org.freedesktop.portal.Flatpak.Spawn only works in a flatpak\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (*arg_cwd_path == 0)\n    arg_cwd_path = NULL;\n\n  if (arg_argv == NULL || *arg_argv == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""No command given\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Unsupported flags enabled: 0x%x\"", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_ref = g_key_file_get_string (app_info,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  if (runtime_ref == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""No runtime found\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_parts = g_strsplit (runtime_ref, \""/\"", -1);\n\n  branch = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_BRANCH, NULL);\n  instance_path = g_key_file_get_string (app_info,\n                                         FLATPAK_METADATA_GROUP_INSTANCE,\n                                         FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);\n  arch = g_key_file_get_string (app_info,\n                                FLATPAK_METADATA_GROUP_INSTANCE,\n                                FLATPAK_METADATA_KEY_ARCH, NULL);\n  extra_args = g_key_file_get_string_list (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);\n  app_commit = g_key_file_get_string (app_info,\n                                      FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_APP_COMMIT, NULL);\n  runtime_commit = g_key_file_get_string (app_info,\n                                          FLATPAK_METADATA_GROUP_INSTANCE,\n                                          FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);\n  shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SHARED, NULL, NULL);\n  sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);\n  devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                        FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);\n\n  devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_DEVEL, NULL);\n\n  g_variant_lookup (arg_options, \""sandbox-expose\"", \""^as\"", &sandbox_expose);\n  g_variant_lookup (arg_options, \""sandbox-expose-ro\"", \""^as\"", &sandbox_expose_ro);\n  g_variant_lookup (arg_options, \""sandbox-flags\"", \""u\"", &sandbox_flags);\n  sandbox_expose_fd = g_variant_lookup_value (arg_options, \""sandbox-expose-fd\"", G_VARIANT_TYPE (\""ah\""));\n  sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, \""sandbox-expose-fd-ro\"", G_VARIANT_TYPE (\""ah\""));\n\n  if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Unsupported sandbox flags enabled: 0x%x\"", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_path == NULL &&\n      ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||\n       (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Invalid sandbox expose, caller has no instance path\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose[i];\n\n      g_debug (\""exposing %s\"", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\""exposing %s\"", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  g_debug (\""Running spawn command %s\"", arg_argv[0]);\n\n  n_fds = 0;\n  if (fds != NULL)\n    n_fds = g_variant_n_children (arg_fds);\n  fd_map = g_new0 (FdMapEntry, n_fds);\n\n  child_setup_data.fd_map = fd_map;\n  child_setup_data.fd_map_len = n_fds;\n\n  max_fd = -1;\n  for (i = 0; i < n_fds; i++)\n    {\n      gint32 handle, dest_fd;\n      int handle_fd;\n\n      g_variant_get_child (arg_fds, i, \""{uh}\"", &dest_fd, &handle);\n\n      if (handle >= fds_len || handle < 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \""No file descriptor for handle %d\"",\n                                                 handle);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      handle_fd = fds[handle];\n\n      fd_map[i].to = dest_fd;\n      fd_map[i].from = handle_fd;\n      fd_map[i].final = fd_map[i].to;\n\n      /* If stdin/out/err is a tty we try to set it as the controlling\n         tty for the app, this way we can use this to run in a terminal. */\n      if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&\n          !child_setup_data.set_tty &&\n          isatty (handle_fd))\n        {\n          child_setup_data.set_tty = TRUE;\n          child_setup_data.tty = handle_fd;\n        }\n\n      max_fd = MAX (max_fd, fd_map[i].to);\n      max_fd = MAX (max_fd, fd_map[i].from);\n    }\n\n  /* We make a second pass over the fds to find if any \""to\"" fd index\n     overlaps an already in use fd (i.e. one in the \""from\"" category\n     that are allocated randomly). If a fd overlaps \""to\"" fd then its\n     a caller issue and not our fault, so we ignore that. */\n  for (i = 0; i < n_fds; i++)\n    {\n      int to_fd = fd_map[i].to;\n      gboolean conflict = FALSE;\n\n      /* At this point we're fine with using \""from\"" values for this\n         value (because we handle to==from in the code), or values\n         that are before \""i\"" in the fd_map (because those will be\n         closed at this point when dup:ing). However, we can't\n         reuse a fd that is in \""from\"" for j > i. */\n      for (j = i + 1; j < n_fds; j++)\n        {\n          int from_fd = fd_map[j].from;\n          if (from_fd == to_fd)\n            {\n              conflict = TRUE;\n              break;\n            }\n        }\n\n      if (conflict)\n        fd_map[i].to = ++max_fd;\n    }\n\n  if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)\n    {\n      char *empty[] = { NULL };\n      env = g_strdupv (empty);\n    }\n  else\n    env = g_get_environ ();\n\n  n_envs = g_variant_n_children (arg_envs);\n  for (i = 0; i < n_envs; i++)\n    {\n      const char *var = NULL;\n      const char *val = NULL;\n      g_variant_get_child (arg_envs, i, \""{&s&s}\"", &var, &val);\n\n      env = g_environ_setenv (env, var, val, TRUE);\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup (\""flatpak\""));\n  g_ptr_array_add (flatpak_argv, g_strdup (\""run\""));\n\n  sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;\n\n  if (sandboxed)\n    {\n      g_ptr_array_add (flatpak_argv, g_strdup (\""--sandbox\""));\n\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""wayland\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=wayland\""));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""fallback-x11\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=fallback-x11\""));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""x11\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=x11\""));\n          if (shares != NULL && g_strv_contains ((const char * const *) shares, \""ipc\"") &&\n              sockets != NULL && (g_strv_contains ((const char * const *) sockets, \""fallback-x11\"") ||\n                                  g_strv_contains ((const char * const *) sockets, \""x11\"")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--share=ipc\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""pulseaudio\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=pulseaudio\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)\n        {\n          if (devices != NULL &&\n              (g_strv_contains ((const char * const *) devices, \""dri\"") ||\n               g_strv_contains ((const char * const *) devices, \""all\"")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--device=dri\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--session-bus\""));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--a11y-bus\""));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n\n      if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_NOT_SUPPORTED,\n                                                 \""Expose pids not supported with setuid bwrap\"");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      instance_id = g_key_file_get_string (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);\n\n      if (instance_id)\n        {\n          g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);\n          sender_pid1 = flatpak_instance_get_child_pid (instance);\n        }\n\n      if (sender_pid1 == 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \""Could not find requesting pid\"");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--parent-pid=%d\"", sender_pid1));\n\n      if (share_pids)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--parent-share-pids\""));\n      else\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--parent-expose-pids\""));\n    }\n\n  notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;\n  if (notify_start)\n    {\n      int pipe_fds[2];\n      if (pipe (pipe_fds) == -1)\n        {\n          int errsv = errno;\n          g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,\n                                                 g_io_error_from_errno (errsv),\n                                                 \""Failed to create instance ID pipe: %s\"",\n                                                 g_strerror (errsv));\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));\n      /* This is saved to ensure the portal's end gets closed after the exec. */\n      instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));\n\n      instance_id_read_data = g_new0 (InstanceIdReadData, 1);\n\n      g_input_stream_read_async (in_stream, instance_id_read_data->buffer,\n                                 INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,\n                                 instance_id_read_finish, instance_id_read_data);\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--instance-id-fd=%d\"", pipe_fds[1]));\n      child_setup_data.instance_id_fd = pipe_fds[1];\n    }\n\n  if (devel)\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--devel\""));\n\n  /* Inherit launcher network access from launcher, unless\n     NO_NETWORK set. */\n  if (shares != NULL && g_strv_contains ((const char * const *) shares, \""network\"") &&\n      !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--share=network\""));\n  else\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--unshare=network\""));\n\n\n  if (instance_path)\n    {\n      for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));\n      for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\""exposing %s\"", expose);\n    }\n\n  if (sandbox_expose_fd != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd, i, \""h\"", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));\n                }\n              else\n                {\n                  g_debug (\""unable to get path for sandbox-exposed fd %d, ignoring: %s\"",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \""No file descriptor for handle %d\"",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  if (sandbox_expose_fd_ro != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd_ro);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd_ro, i, \""h\"", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));\n                }\n              else\n                {\n                  g_debug (\""unable to get path for sandbox-exposed fd %d, ignoring: %s\"",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \""No file descriptor for handle %d\"",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime=%s\"", runtime_parts[1]));\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime-version=%s\"", runtime_parts[3]));\n\n  if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)\n    {\n      if (app_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--commit=%s\"", app_commit));\n      if (runtime_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime-commit=%s\"", runtime_commit));\n    }\n\n  if (arg_cwd_path != NULL)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--cwd=%s\"", arg_cwd_path));\n\n  if (arg_argv[0][0] != 0)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--command=%s\"", arg_argv[0]));\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""%s/%s/%s\"", app_id, arch ? arch : \""\"", branch ? branch : \""\""));\n  for (i = 1; arg_argv[i] != NULL; i++)\n    g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));\n  g_ptr_array_add (flatpak_argv, NULL);\n\n  if (opt_verbose)\n    {\n      g_autoptr(GString) cmd = g_string_new (\""\"");\n\n      for (i = 0; flatpak_argv->pdata[i] != NULL; i++)\n        {\n          if (i > 0)\n            g_string_append (cmd, \"" \"");\n          g_string_append (cmd, flatpak_argv->pdata[i]);\n        }\n\n      g_debug (\""Starting: %s\\n\"", cmd->str);\n    }\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async_with_pipes (NULL,\n                                 (char **) flatpak_argv->pdata,\n                                 env,\n                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                                 child_setup_func, &child_setup_data,\n                                 &pid,\n                                 NULL,\n                                 NULL,\n                                 NULL,\n                                 &error))\n    {\n      gint code = G_DBUS_ERROR_FAILED;\n      if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))\n        code = G_DBUS_ERROR_ACCESS_DENIED;\n      else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))\n        code = G_DBUS_ERROR_FILE_NOT_FOUND;\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,\n                                             \""Failed to start command: %s\"",\n                                             error->message);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_id_read_data)\n    instance_id_read_data->pid = pid;\n\n  pid_data = g_new0 (PidData, 1);\n  pid_data->pid = pid;\n  pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));\n  pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;\n  pid_data->expose_or_share_pids = (expose_pids || share_pids);\n  pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,\n                                                  pid,\n                                                  child_watch_died,\n                                                  pid_data,\n                                                  NULL);\n\n  g_debug (\""Client Pid is %d\"", pid_data->pid);\n\n  g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),\n                        pid_data);\n\n  portal_flatpak_complete_spawn (object, invocation, NULL, pid);\n  return G_DBUS_METHOD_INVOCATION_HANDLED;\n}"", ""target"": 0}, {""func_name"": ""flatpak_run_add_environment_args"", ""file_path"": ""common/flatpak-run.c"", ""func_code"": ""gboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\""Disallowing ipc access\"");\n      flatpak_bwrap_add_args (bwrap, \""--unshare-ipc\"", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\""Disallowing network access\"");\n      flatpak_bwrap_add_args (bwrap, \""--unshare-net\"", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \""--dev-bind\"", \""/dev\"", \""/dev\"",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\""/dev/shm\"", G_FILE_TEST_IS_DIR))\n        {\n          if ((context->devices & FLATPAK_CONTEXT_DEVICE_SHM) == 0)\n            flatpak_bwrap_add_args (bwrap,\n                                    \""--tmpfs\"", \""/dev/shm\"",\n                                    NULL);\n        }\n      else if (g_file_test (\""/dev/shm\"", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\""/dev/shm\"", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \""/run/shm\"") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\""/run/shm\"", G_FILE_TEST_IS_DIR))\n                flatpak_bwrap_add_args (bwrap,\n                                        \""--bind\"", \""/run/shm\"", \""/run/shm\"",\n                                        NULL);\n              else\n                flatpak_bwrap_add_args (bwrap,\n                                        \""--dir\"", \""/run/shm\"",\n                                        NULL);\n            }\n          else\n            g_warning (\""Unexpected /dev/shm symlink %s\"", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \""--dev\"", \""/dev\"",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\""Allowing dri access\"");\n          int i;\n          char *dri_devices[] = {\n            \""/dev/dri\"",\n            /* mali */\n            \""/dev/mali\"",\n            \""/dev/mali0\"",\n            \""/dev/umplock\"",\n            /* nvidia */\n            \""/dev/nvidiactl\"",\n            \""/dev/nvidia-modeset\"",\n            /* nvidia OpenCL/CUDA */\n            \""/dev/nvidia-uvm\"",\n            \""/dev/nvidia-uvm-tools\"",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \""--dev-bind\"", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \""/dev/nvidia%d\"", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \""--dev-bind\"", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\""Allowing kvm access\"");\n          if (g_file_test (\""/dev/kvm\"", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \""--dev-bind\"", \""/dev/kvm\"", \""/dev/kvm\"", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\""/dev/shm\"", NULL);\n\n          g_debug (\""Allowing /dev/shm access (as %s)\"", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \""--bind\"", real_dev_shm, \""/dev/shm\"", NULL);\n        }\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir, previous_app_id_dirs, &exports);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\""Allowing wayland access\"");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\""Allowing pulseaudio access\"");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  if (g_environ_getenv (bwrap->envp, \""LD_LIBRARY_PATH\"") != NULL)\n    {\n      /* LD_LIBRARY_PATH is overridden for setuid helper, so pass it as cmdline arg */\n      flatpak_bwrap_add_args (bwrap,\n                              \""--setenv\"", \""LD_LIBRARY_PATH\"", g_environ_getenv (bwrap->envp, \""LD_LIBRARY_PATH\""),\n                              NULL);\n      flatpak_bwrap_unset_env (bwrap, \""LD_LIBRARY_PATH\"");\n    }\n\n  if (g_environ_getenv (bwrap->envp, \""TMPDIR\"") != NULL)\n    {\n      /* TMPDIR is overridden for setuid helper, so pass it as cmdline arg */\n      flatpak_bwrap_add_args (bwrap,\n                              \""--setenv\"", \""TMPDIR\"", g_environ_getenv (bwrap->envp, \""TMPDIR\""),\n                              NULL);\n      flatpak_bwrap_unset_env (bwrap, \""TMPDIR\"");\n    }\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\""Failed to run in transient scope: %s\"", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}"", ""target"": 0}, {""func_name"": ""flatpak_run_app"", ""file_path"": ""common/flatpak-run.c"", ""func_code"": ""gboolean\nflatpak_run_app (FlatpakDecomposed *app_ref,\n                 FlatpakDeploy     *app_deploy,\n                 FlatpakContext    *extra_context,\n                 const char        *custom_runtime,\n                 const char        *custom_runtime_version,\n                 const char        *custom_runtime_commit,\n                 int                parent_pid,\n                 FlatpakRunFlags    flags,\n                 const char        *cwd,\n                 const char        *custom_command,\n                 char              *args[],\n                 int                n_args,\n                 int                instance_id_fd,\n                 char             **instance_dir_out,\n                 GCancellable      *cancellable,\n                 GError           **error)\n{\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(GBytes) runtime_deploy_data = NULL;\n  g_autoptr(GBytes) app_deploy_data = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(GFile) bin_ldconfig = NULL;\n  g_autoptr(GFile) app_id_dir = NULL;\n  g_autoptr(GFile) real_app_id_dir = NULL;\n  g_autofree char *default_runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) default_runtime = NULL;\n  g_autofree char *default_command = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GKeyFile) runtime_metakey = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  const char *command = \""/bin/sh\"";\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  int i;\n  g_autoptr(GPtrArray) previous_app_id_dirs = NULL;\n  g_autofree char *app_id = NULL;\n  g_autofree char *app_arch = NULL;\n  g_autofree char *app_info_path = NULL;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autofree char *commandline = NULL;\n  g_autofree char *doc_mount_path = NULL;\n  g_autofree char *app_extensions = NULL;\n  g_autofree char *runtime_extensions = NULL;\n  g_autofree char *checksum = NULL;\n  int ld_so_fd = -1;\n  g_autoptr(GFile) runtime_ld_so_conf = NULL;\n  gboolean generate_ld_so_conf = TRUE;\n  gboolean use_ld_so_cache = TRUE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n  gboolean parent_expose_pids = (flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS) != 0;\n  gboolean parent_share_pids = (flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS) != 0;\n  struct stat s;\n\n  if (!check_sudo (error))\n    return FALSE;\n\n  app_id = flatpak_decomposed_dup_id (app_ref);\n  app_arch = flatpak_decomposed_dup_arch (app_ref);\n\n  /* Check the user is allowed to run this flatpak. */\n  if (!check_parental_controls (app_ref, app_deploy, cancellable, error))\n    return FALSE;\n\n  /* Construct the bwrap context. */\n  bwrap = flatpak_bwrap_new (NULL);\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  if (app_deploy == NULL)\n    {\n      g_assert (flatpak_decomposed_is_runtime (app_ref));\n      default_runtime_pref = flatpak_decomposed_dup_pref (app_ref);\n    }\n  else\n    {\n      const gchar *key;\n\n      app_deploy_data = flatpak_deploy_get_deploy_data (app_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (app_deploy_data == NULL)\n        return FALSE;\n\n      if ((flags & FLATPAK_RUN_FLAG_DEVEL) != 0)\n        key = FLATPAK_METADATA_KEY_SDK;\n      else\n        key = FLATPAK_METADATA_KEY_RUNTIME;\n\n      metakey = flatpak_deploy_get_metadata (app_deploy);\n      default_runtime_pref = g_key_file_get_string (metakey,\n                                                    FLATPAK_METADATA_GROUP_APPLICATION,\n                                                    key, &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n    }\n\n  default_runtime = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, default_runtime_pref, error);\n  if (default_runtime == NULL)\n    return FALSE;\n\n  if (custom_runtime != NULL || custom_runtime_version != NULL)\n    {\n      g_auto(GStrv) custom_runtime_parts = NULL;\n      const char *custom_runtime_id = NULL;\n      const char *custom_runtime_arch = NULL;\n\n      if (custom_runtime)\n        {\n          custom_runtime_parts = g_strsplit (custom_runtime, \""/\"", 0);\n          for (i = 0; i < 3 && custom_runtime_parts[i] != NULL; i++)\n            {\n              if (strlen (custom_runtime_parts[i]) > 0)\n                {\n                  if (i == 0)\n                    custom_runtime_id = custom_runtime_parts[i];\n                  if (i == 1)\n                    custom_runtime_arch = custom_runtime_parts[i];\n\n                  if (i == 2 && custom_runtime_version == NULL)\n                    custom_runtime_version = custom_runtime_parts[i];\n                }\n            }\n        }\n\n      runtime_ref = flatpak_decomposed_new_from_decomposed (default_runtime,\n                                                            FLATPAK_KINDS_RUNTIME,\n                                                            custom_runtime_id,\n                                                            custom_runtime_arch,\n                                                            custom_runtime_version,\n                                                            error);\n      if (runtime_ref == NULL)\n        return FALSE;\n    }\n  else\n    runtime_ref = flatpak_decomposed_ref (default_runtime);\n\n  runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), custom_runtime_commit, NULL, cancellable, error);\n  if (runtime_deploy == NULL)\n    return FALSE;\n\n  runtime_deploy_data = flatpak_deploy_get_deploy_data (runtime_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n  if (runtime_deploy_data == NULL)\n    return FALSE;\n\n  runtime_metakey = flatpak_deploy_get_metadata (runtime_deploy);\n\n  app_context = flatpak_app_compute_permissions (metakey, runtime_metakey, error);\n  if (app_context == NULL)\n    return FALSE;\n\n  if (app_deploy != NULL)\n    {\n      overrides = flatpak_deploy_get_overrides (app_deploy);\n      flatpak_context_merge (app_context, overrides);\n    }\n\n  if (sandboxed)\n    flatpak_context_make_sandboxed (app_context);\n\n  if (extra_context)\n    flatpak_context_merge (app_context, extra_context);\n\n  runtime_files = flatpak_deploy_get_files (runtime_deploy);\n  bin_ldconfig = g_file_resolve_relative_path (runtime_files, \""bin/ldconfig\"");\n  if (!g_file_query_exists (bin_ldconfig, NULL))\n    use_ld_so_cache = FALSE;\n\n  if (app_deploy != NULL)\n    {\n      g_autofree const char **previous_ids = NULL;\n      gsize len = 0;\n      gboolean do_migrate;\n\n      real_app_id_dir = flatpak_get_data_dir (app_id);\n      app_files = flatpak_deploy_get_files (app_deploy);\n\n      previous_app_id_dirs = g_ptr_array_new_with_free_func (g_object_unref);\n      previous_ids = flatpak_deploy_data_get_previous_ids (app_deploy_data, &len);\n\n      do_migrate = !g_file_query_exists (real_app_id_dir, cancellable);\n\n      /* When migrating, find most recent old existing source and rename that to\n       * the new name.\n       *\n       * We ignore other names than that. For more recent names that don't exist\n       * we never ran them so nothing will even reference them. For older names\n       * either they were not used, or they were used but then the more recent\n       * name was used and a symlink to it was created.\n       *\n       * This means we may end up with a chain of symlinks: oldest -> old -> current.\n       * This is unfortunate but not really a problem, but for robustness reasons we\n       * don't want to mess with user files unnecessary. For example, the app dir could\n       * actually be a symlink for other reasons. Imagine for instance that you want to put the\n       * steam games somewhere else so you leave the app dir as a symlink to /mnt/steam.\n       */\n      for (i = len - 1; i >= 0; i--)\n        {\n          g_autoptr(GFile) previous_app_id_dir = NULL;\n          g_autoptr(GFileInfo) previous_app_id_dir_info = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          previous_app_id_dir = flatpak_get_data_dir (previous_ids[i]);\n          previous_app_id_dir_info = g_file_query_info (previous_app_id_dir,\n                                                        G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \"",\""\n                                                        G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                        cancellable,\n                                                        &local_error);\n          /* Warn about the migration failures, but don't make them fatal, then you can never run the app */\n          if (previous_app_id_dir_info == NULL)\n            {\n              if  (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) && do_migrate)\n                {\n                  g_warning (_(\""Failed to migrate from %s: %s\""), flatpak_file_get_path_cached (previous_app_id_dir),\n                             local_error->message);\n                  do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to the thing that we failed on */\n                }\n\n              g_clear_error (&local_error);\n              continue;\n            }\n\n          if (do_migrate)\n            {\n              do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to this dir */\n\n              if (!flatpak_file_rename (previous_app_id_dir, real_app_id_dir, cancellable, &local_error))\n                {\n                  g_warning (_(\""Failed to migrate old app data directory %s to new name %s: %s\""),\n                             flatpak_file_get_path_cached (previous_app_id_dir), app_id,\n                             local_error->message);\n                }\n              else\n                {\n                  /* Leave a symlink in place of the old data dir */\n                  if (!g_file_make_symbolic_link (previous_app_id_dir, app_id, cancellable, &local_error))\n                    {\n                      g_warning (_(\""Failed to create symlink while migrating %s: %s\""),\n                                 flatpak_file_get_path_cached (previous_app_id_dir),\n                                 local_error->message);\n                    }\n                }\n            }\n\n          /* Give app access to this old dir */\n          g_ptr_array_add (previous_app_id_dirs, g_steal_pointer (&previous_app_id_dir));\n        }\n\n      if (!flatpak_ensure_data_dir (real_app_id_dir, cancellable, error))\n        return FALSE;\n\n      if (!sandboxed)\n        app_id_dir = g_object_ref (real_app_id_dir);\n    }\n\n  flatpak_run_apply_env_default (bwrap, use_ld_so_cache);\n  flatpak_run_apply_env_vars (bwrap, app_context);\n  flatpak_run_apply_env_prompt (bwrap, app_id);\n\n  if (real_app_id_dir)\n    {\n      g_autoptr(GFile) sandbox_dir = g_file_get_child (real_app_id_dir, \""sandbox\"");\n      flatpak_bwrap_set_env (bwrap, \""FLATPAK_SANDBOX_DIR\"", flatpak_file_get_path_cached (sandbox_dir), TRUE);\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \""--ro-bind\"", flatpak_file_get_path_cached (runtime_files), \""/usr\"",\n                          \""--lock-file\"", \""/usr/.ref\"",\n                          NULL);\n\n  if (app_files != NULL)\n    flatpak_bwrap_add_args (bwrap,\n                            \""--ro-bind\"", flatpak_file_get_path_cached (app_files), \""/app\"",\n                            \""--lock-file\"", \""/app/.ref\"",\n                            NULL);\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \""--dir\"", \""/app\"",\n                            NULL);\n\n  if (metakey != NULL &&\n      !flatpak_run_add_extension_args (bwrap, metakey, app_ref, use_ld_so_cache, &app_extensions, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_run_add_extension_args (bwrap, runtime_metakey, runtime_ref, use_ld_so_cache, &runtime_extensions, cancellable, error))\n    return FALSE;\n\n  runtime_ld_so_conf = g_file_resolve_relative_path (runtime_files, \""etc/ld.so.conf\"");\n  if (lstat (flatpak_file_get_path_cached (runtime_ld_so_conf), &s) == 0)\n    generate_ld_so_conf = S_ISREG (s.st_mode) && s.st_size == 0;\n\n  /* At this point we have the minimal argv set up, with just the app, runtime and extensions.\n     We can reuse this to generate the ld.so.cache (if needed) */\n  if (use_ld_so_cache)\n    {\n      checksum = calculate_ld_cache_checksum (app_deploy_data, runtime_deploy_data,\n                                              app_extensions, runtime_extensions);\n      ld_so_fd = regenerate_ld_cache (bwrap->argv,\n                                      bwrap->fds,\n                                      app_id_dir,\n                                      checksum,\n                                      runtime_files,\n                                      generate_ld_so_conf,\n                                      cancellable, error);\n      if (ld_so_fd == -1)\n        return FALSE;\n      flatpak_bwrap_add_fd (bwrap, ld_so_fd);\n    }\n\n  flags |= flatpak_context_get_run_flags (app_context);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, app_id_dir, app_arch, flags, error))\n    return FALSE;\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return FALSE;\n    }\n\n  if (ld_so_fd != -1)\n    {\n      /* Don't add to fd_array, its already there */\n      flatpak_bwrap_add_arg (bwrap, \""--ro-bind-data\"");\n      flatpak_bwrap_add_arg_printf (bwrap, \""%d\"", ld_so_fd);\n      flatpak_bwrap_add_arg (bwrap, \""/etc/ld.so.cache\"");\n    }\n\n  if (!flatpak_run_add_app_info_args (bwrap,\n                                      app_files, app_deploy_data, app_extensions,\n                                      runtime_files, runtime_deploy_data, runtime_extensions,\n                                      app_id, flatpak_decomposed_get_branch (app_ref),\n                                      runtime_ref, app_id_dir, app_context, extra_context,\n                                      sandboxed, FALSE, flags & FLATPAK_RUN_FLAG_DEVEL,\n                                      &app_info_path, instance_id_fd, &instance_id_host_dir,\n                                      error))\n    return FALSE;\n\n  if (!flatpak_run_add_dconf_args (bwrap, app_id, metakey, error))\n    return FALSE;\n\n  if (!sandboxed && !(flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL))\n    add_document_portal_args (bwrap, app_id, &doc_mount_path);\n\n  if (!flatpak_run_add_environment_args (bwrap, app_info_path, flags,\n                                         app_id, app_context, app_id_dir, previous_app_id_dirs,\n                                         &exports, cancellable, error))\n    return FALSE;\n\n  if ((app_context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) != 0)\n    flatpak_run_add_resolved_args (bwrap);\n\n  flatpak_run_add_journal_args (bwrap);\n  add_font_path_args (bwrap);\n  add_icon_path_args (bwrap);\n\n  flatpak_bwrap_add_args (bwrap,\n                          /* Not in base, because we don't want this for flatpak build */\n                          \""--symlink\"", \""/app/lib/debug/source\"", \""/run/build\"",\n                          \""--symlink\"", \""/usr/lib/debug/source\"", \""/run/build-runtime\"",\n                          NULL);\n\n  if (cwd)\n    flatpak_bwrap_add_args (bwrap, \""--chdir\"", cwd, NULL);\n\n  if (parent_expose_pids || parent_share_pids)\n    {\n      g_autofree char *userns_path = NULL;\n      g_autofree char *pidns_path = NULL;\n      g_autofree char *userns2_path = NULL;\n      int userns_fd, userns2_fd, pidns_fd;\n\n      if (parent_pid == 0)\n        return flatpak_fail (error, \""No parent pid specified\"");\n\n      userns_path = g_strdup_printf (\""/proc/%d/root/run/.userns\"", parent_pid);\n\n      userns_fd = open_namespace_fd_if_needed (userns_path, \""/proc/self/ns/user\"");\n      if (userns_fd != -1)\n        {\n          flatpak_bwrap_add_args_data_fd (bwrap, \""--userns\"", userns_fd, NULL);\n\n          userns2_path = g_strdup_printf (\""/proc/%d/ns/user\"", parent_pid);\n          userns2_fd = open_namespace_fd_if_needed (userns2_path, userns_path);\n          if (userns2_fd != -1)\n            flatpak_bwrap_add_args_data_fd (bwrap, \""--userns2\"", userns2_fd, NULL);\n        }\n\n      pidns_path = g_strdup_printf (\""/proc/%d/ns/pid\"", parent_pid);\n      pidns_fd = open (pidns_path, O_RDONLY|O_CLOEXEC);\n      if (pidns_fd != -1)\n        flatpak_bwrap_add_args_data_fd (bwrap, \""--pidns\"", pidns_fd, NULL);\n    }\n\n  if (custom_command)\n    {\n      command = custom_command;\n    }\n  else if (metakey)\n    {\n      default_command = g_key_file_get_string (metakey,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_COMMAND,\n                                               &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n      command = default_command;\n    }\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, command);\n\n  if (!add_rest_args (bwrap, app_id,\n                      exports, (flags & FLATPAK_RUN_FLAG_FILE_FORWARDING) != 0,\n                      doc_mount_path,\n                      args, n_args, error))\n    return FALSE;\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\""Running '%s'\"", commandline);\n\n  if ((flags & FLATPAK_RUN_FLAG_BACKGROUND) != 0)\n    {\n      GPid child_pid;\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n      GSpawnFlags spawn_flags;\n\n      spawn_flags = G_SPAWN_SEARCH_PATH;\n      if (flags & FLATPAK_RUN_FLAG_DO_NOT_REAP)\n        spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD;\n\n      /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n      spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;\n\n      if (!g_spawn_async (NULL,\n                          (char **) bwrap->argv->pdata,\n                          bwrap->envp,\n                          spawn_flags,\n                          flatpak_bwrap_child_setup_cb, bwrap->fds,\n                          &child_pid,\n                          error))\n        return FALSE;\n\n      g_snprintf (pid_str, sizeof (pid_str), \""%d\"", child_pid);\n      pid_path = g_build_filename (instance_id_host_dir, \""pid\"", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n    }\n  else\n    {\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n\n      g_snprintf (pid_str, sizeof (pid_str), \""%d\"", getpid ());\n      pid_path = g_build_filename (instance_id_host_dir, \""pid\"", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n      /* Ensure we unset O_CLOEXEC for marked fds and rewind fds as needed.\n       * Note that this does not close fds that are not already marked O_CLOEXEC, because\n       * we do want to allow inheriting fds into flatpak run. */\n      flatpak_bwrap_child_setup (bwrap->fds, FALSE);\n\n      if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n        {\n          g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                               _(\""Unable to start app\""));\n          return FALSE;\n        }\n      /* Not actually reached... */\n    }\n\n  if (instance_dir_out)\n    *instance_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}"", ""target"": 0}]","[{""func_name"": ""handle_spawn"", ""file_path"": ""portal/flatpak-portal.c"", ""func_code"": ""static gboolean\nhandle_spawn (PortalFlatpak         *object,\n              GDBusMethodInvocation *invocation,\n              GUnixFDList           *fd_list,\n              const gchar           *arg_cwd_path,\n              const gchar *const    *arg_argv,\n              GVariant              *arg_fds,\n              GVariant              *arg_envs,\n              guint                  arg_flags,\n              GVariant              *arg_options)\n{\n  g_autoptr(GError) error = NULL;\n  ChildSetupData child_setup_data = { NULL };\n  GPid pid;\n  PidData *pid_data;\n  InstanceIdReadData *instance_id_read_data = NULL;\n  gsize i, j, n_fds, n_envs;\n  const gint *fds = NULL;\n  gint fds_len = 0;\n  g_autofree FdMapEntry *fd_map = NULL;\n  gchar **env;\n  gint32 max_fd;\n  GKeyFile *app_info;\n  g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);\n  g_autofree char *app_id = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *arch = NULL;\n  g_autofree char *app_commit = NULL;\n  g_autofree char *runtime_ref = NULL;\n  g_auto(GStrv) runtime_parts = NULL;\n  g_autofree char *runtime_commit = NULL;\n  g_autofree char *instance_path = NULL;\n  g_auto(GStrv) extra_args = NULL;\n  g_auto(GStrv) shares = NULL;\n  g_auto(GStrv) sockets = NULL;\n  g_auto(GStrv) devices = NULL;\n  g_auto(GStrv) sandbox_expose = NULL;\n  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n  g_autoptr(GString) env_string = g_string_new (\""\"");\n\n  child_setup_data.instance_id_fd = -1;\n  child_setup_data.env_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \""app-info\"");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n  g_assert (app_id != NULL);\n\n  g_debug (\""spawn() called from app: '%s'\"", app_id);\n  if (*app_id == 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""org.freedesktop.portal.Flatpak.Spawn only works in a flatpak\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (*arg_cwd_path == 0)\n    arg_cwd_path = NULL;\n\n  if (arg_argv == NULL || *arg_argv == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""No command given\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Unsupported flags enabled: 0x%x\"", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_ref = g_key_file_get_string (app_info,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  if (runtime_ref == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""No runtime found\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_parts = g_strsplit (runtime_ref, \""/\"", -1);\n\n  branch = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_BRANCH, NULL);\n  instance_path = g_key_file_get_string (app_info,\n                                         FLATPAK_METADATA_GROUP_INSTANCE,\n                                         FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);\n  arch = g_key_file_get_string (app_info,\n                                FLATPAK_METADATA_GROUP_INSTANCE,\n                                FLATPAK_METADATA_KEY_ARCH, NULL);\n  extra_args = g_key_file_get_string_list (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);\n  app_commit = g_key_file_get_string (app_info,\n                                      FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_APP_COMMIT, NULL);\n  runtime_commit = g_key_file_get_string (app_info,\n                                          FLATPAK_METADATA_GROUP_INSTANCE,\n                                          FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);\n  shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SHARED, NULL, NULL);\n  sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);\n  devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                        FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);\n\n  devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_DEVEL, NULL);\n\n  g_variant_lookup (arg_options, \""sandbox-expose\"", \""^as\"", &sandbox_expose);\n  g_variant_lookup (arg_options, \""sandbox-expose-ro\"", \""^as\"", &sandbox_expose_ro);\n  g_variant_lookup (arg_options, \""sandbox-flags\"", \""u\"", &sandbox_flags);\n  sandbox_expose_fd = g_variant_lookup_value (arg_options, \""sandbox-expose-fd\"", G_VARIANT_TYPE (\""ah\""));\n  sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, \""sandbox-expose-fd-ro\"", G_VARIANT_TYPE (\""ah\""));\n\n  if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Unsupported sandbox flags enabled: 0x%x\"", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_path == NULL &&\n      ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||\n       (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Invalid sandbox expose, caller has no instance path\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose[i];\n\n      g_debug (\""exposing %s\"", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\""exposing %s\"", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  g_debug (\""Running spawn command %s\"", arg_argv[0]);\n\n  n_fds = 0;\n  if (fds != NULL)\n    n_fds = g_variant_n_children (arg_fds);\n  fd_map = g_new0 (FdMapEntry, n_fds);\n\n  child_setup_data.fd_map = fd_map;\n  child_setup_data.fd_map_len = n_fds;\n\n  max_fd = -1;\n  for (i = 0; i < n_fds; i++)\n    {\n      gint32 handle, dest_fd;\n      int handle_fd;\n\n      g_variant_get_child (arg_fds, i, \""{uh}\"", &dest_fd, &handle);\n\n      if (handle >= fds_len || handle < 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \""No file descriptor for handle %d\"",\n                                                 handle);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      handle_fd = fds[handle];\n\n      fd_map[i].to = dest_fd;\n      fd_map[i].from = handle_fd;\n      fd_map[i].final = fd_map[i].to;\n\n      /* If stdin/out/err is a tty we try to set it as the controlling\n         tty for the app, this way we can use this to run in a terminal. */\n      if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&\n          !child_setup_data.set_tty &&\n          isatty (handle_fd))\n        {\n          child_setup_data.set_tty = TRUE;\n          child_setup_data.tty = handle_fd;\n        }\n\n      max_fd = MAX (max_fd, fd_map[i].to);\n      max_fd = MAX (max_fd, fd_map[i].from);\n    }\n\n  /* We make a second pass over the fds to find if any \""to\"" fd index\n     overlaps an already in use fd (i.e. one in the \""from\"" category\n     that are allocated randomly). If a fd overlaps \""to\"" fd then its\n     a caller issue and not our fault, so we ignore that. */\n  for (i = 0; i < n_fds; i++)\n    {\n      int to_fd = fd_map[i].to;\n      gboolean conflict = FALSE;\n\n      /* At this point we're fine with using \""from\"" values for this\n         value (because we handle to==from in the code), or values\n         that are before \""i\"" in the fd_map (because those will be\n         closed at this point when dup:ing). However, we can't\n         reuse a fd that is in \""from\"" for j > i. */\n      for (j = i + 1; j < n_fds; j++)\n        {\n          int from_fd = fd_map[j].from;\n          if (from_fd == to_fd)\n            {\n              conflict = TRUE;\n              break;\n            }\n        }\n\n      if (conflict)\n        fd_map[i].to = ++max_fd;\n    }\n\n  if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)\n    {\n      char *empty[] = { NULL };\n      env = g_strdupv (empty);\n    }\n  else\n    env = g_get_environ ();\n\n  /* Let the environment variables given by the caller override the ones\n   * from extra_args. Don't add them to @env, because they are controlled\n   * by our caller, which might be trying to use them to inject code into\n   * flatpak(1); add them to the environment block instead.\n   *\n   * We don't use --env= here, so that if the values are something that\n   * should not be exposed to other uids, they can remain confidential. */\n  n_envs = g_variant_n_children (arg_envs);\n  for (i = 0; i < n_envs; i++)\n    {\n      const char *var = NULL;\n      const char *val = NULL;\n      g_variant_get_child (arg_envs, i, \""{&s&s}\"", &var, &val);\n\n      if (var[0] == '\\0')\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \""Environment variable cannot have empty name\"");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      if (strchr (var, '=') != NULL)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \""Environment variable name cannot contain '='\"");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_string_append (env_string, var);\n      g_string_append_c (env_string, '=');\n      g_string_append (env_string, val);\n      g_string_append_c (env_string, '\\0');\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup (\""flatpak\""));\n  g_ptr_array_add (flatpak_argv, g_strdup (\""run\""));\n\n  sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;\n\n  if (sandboxed)\n    {\n      g_ptr_array_add (flatpak_argv, g_strdup (\""--sandbox\""));\n\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""wayland\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=wayland\""));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""fallback-x11\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=fallback-x11\""));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""x11\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=x11\""));\n          if (shares != NULL && g_strv_contains ((const char * const *) shares, \""ipc\"") &&\n              sockets != NULL && (g_strv_contains ((const char * const *) sockets, \""fallback-x11\"") ||\n                                  g_strv_contains ((const char * const *) sockets, \""x11\"")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--share=ipc\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""pulseaudio\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=pulseaudio\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)\n        {\n          if (devices != NULL &&\n              (g_strv_contains ((const char * const *) devices, \""dri\"") ||\n               g_strv_contains ((const char * const *) devices, \""all\"")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--device=dri\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--session-bus\""));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--a11y-bus\""));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        {\n          if (g_str_has_prefix (extra_args[i], \""--env=\""))\n            {\n              const char *var_val = extra_args[i] + strlen (\""--env=\"");\n\n              if (var_val[0] == '\\0' || var_val[0] == '=')\n                {\n                  g_warning (\""Environment variable in extra-args has empty name\"");\n                  continue;\n                }\n\n              if (strchr (var_val, '=') == NULL)\n                {\n                  g_warning (\""Environment variable in extra-args has no value\"");\n                  continue;\n                }\n\n              g_string_append (env_string, var_val);\n              g_string_append_c (env_string, '\\0');\n            }\n          else\n            {\n              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n            }\n        }\n    }\n\n  if (env_string->len > 0)\n    {\n      g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n\n      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \""environ\"",\n                                                      env_string->str,\n                                                      env_string->len, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n      g_ptr_array_add (flatpak_argv,\n                       g_strdup_printf (\""--env-fd=%d\"",\n                                        child_setup_data.env_fd));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n\n      if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_NOT_SUPPORTED,\n                                                 \""Expose pids not supported with setuid bwrap\"");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      instance_id = g_key_file_get_string (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);\n\n      if (instance_id)\n        {\n          g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);\n          sender_pid1 = flatpak_instance_get_child_pid (instance);\n        }\n\n      if (sender_pid1 == 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \""Could not find requesting pid\"");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--parent-pid=%d\"", sender_pid1));\n\n      if (share_pids)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--parent-share-pids\""));\n      else\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--parent-expose-pids\""));\n    }\n\n  notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;\n  if (notify_start)\n    {\n      int pipe_fds[2];\n      if (pipe (pipe_fds) == -1)\n        {\n          int errsv = errno;\n          g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,\n                                                 g_io_error_from_errno (errsv),\n                                                 \""Failed to create instance ID pipe: %s\"",\n                                                 g_strerror (errsv));\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));\n      /* This is saved to ensure the portal's end gets closed after the exec. */\n      instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));\n\n      instance_id_read_data = g_new0 (InstanceIdReadData, 1);\n\n      g_input_stream_read_async (in_stream, instance_id_read_data->buffer,\n                                 INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,\n                                 instance_id_read_finish, instance_id_read_data);\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--instance-id-fd=%d\"", pipe_fds[1]));\n      child_setup_data.instance_id_fd = pipe_fds[1];\n    }\n\n  if (devel)\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--devel\""));\n\n  /* Inherit launcher network access from launcher, unless\n     NO_NETWORK set. */\n  if (shares != NULL && g_strv_contains ((const char * const *) shares, \""network\"") &&\n      !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--share=network\""));\n  else\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--unshare=network\""));\n\n\n  if (instance_path)\n    {\n      for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));\n      for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\""exposing %s\"", expose);\n    }\n\n  if (sandbox_expose_fd != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd, i, \""h\"", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));\n                }\n              else\n                {\n                  g_debug (\""unable to get path for sandbox-exposed fd %d, ignoring: %s\"",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \""No file descriptor for handle %d\"",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  if (sandbox_expose_fd_ro != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd_ro);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd_ro, i, \""h\"", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));\n                }\n              else\n                {\n                  g_debug (\""unable to get path for sandbox-exposed fd %d, ignoring: %s\"",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \""No file descriptor for handle %d\"",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime=%s\"", runtime_parts[1]));\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime-version=%s\"", runtime_parts[3]));\n\n  if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)\n    {\n      if (app_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--commit=%s\"", app_commit));\n      if (runtime_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime-commit=%s\"", runtime_commit));\n    }\n\n  if (arg_cwd_path != NULL)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--cwd=%s\"", arg_cwd_path));\n\n  if (arg_argv[0][0] != 0)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--command=%s\"", arg_argv[0]));\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""%s/%s/%s\"", app_id, arch ? arch : \""\"", branch ? branch : \""\""));\n  for (i = 1; arg_argv[i] != NULL; i++)\n    g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));\n  g_ptr_array_add (flatpak_argv, NULL);\n\n  if (opt_verbose)\n    {\n      g_autoptr(GString) cmd = g_string_new (\""\"");\n\n      for (i = 0; flatpak_argv->pdata[i] != NULL; i++)\n        {\n          if (i > 0)\n            g_string_append (cmd, \"" \"");\n          g_string_append (cmd, flatpak_argv->pdata[i]);\n        }\n\n      g_debug (\""Starting: %s\\n\"", cmd->str);\n    }\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async_with_pipes (NULL,\n                                 (char **) flatpak_argv->pdata,\n                                 env,\n                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                                 child_setup_func, &child_setup_data,\n                                 &pid,\n                                 NULL,\n                                 NULL,\n                                 NULL,\n                                 &error))\n    {\n      gint code = G_DBUS_ERROR_FAILED;\n      if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))\n        code = G_DBUS_ERROR_ACCESS_DENIED;\n      else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))\n        code = G_DBUS_ERROR_FILE_NOT_FOUND;\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,\n                                             \""Failed to start command: %s\"",\n                                             error->message);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_id_read_data)\n    instance_id_read_data->pid = pid;\n\n  pid_data = g_new0 (PidData, 1);\n  pid_data->pid = pid;\n  pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));\n  pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;\n  pid_data->expose_or_share_pids = (expose_pids || share_pids);\n  pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,\n                                                  pid,\n                                                  child_watch_died,\n                                                  pid_data,\n                                                  NULL);\n\n  g_debug (\""Client Pid is %d\"", pid_data->pid);\n\n  g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),\n                        pid_data);\n\n  portal_flatpak_complete_spawn (object, invocation, NULL, pid);\n  return G_DBUS_METHOD_INVOCATION_HANDLED;\n}""}, {""func_name"": ""child_setup_func"", ""file_path"": ""portal/flatpak-portal.c"", ""func_code"": ""static void\nchild_setup_func (gpointer user_data)\n{\n  ChildSetupData *data = (ChildSetupData *) user_data;\n  FdMapEntry *fd_map = data->fd_map;\n  sigset_t set;\n  int i;\n\n  flatpak_close_fds_workaround (3);\n\n  if (data->instance_id_fd != -1)\n    drop_cloexec (data->instance_id_fd);\n\n  if (data->env_fd != -1)\n    drop_cloexec (data->env_fd);\n\n  /* Unblock all signals */\n  sigemptyset (&set);\n  if (pthread_sigmask (SIG_SETMASK, &set, NULL) == -1)\n    {\n      g_warning (\""Failed to unblock signals when starting child\"");\n      return;\n    }\n\n  /* Reset the handlers for all signals to their defaults. */\n  for (i = 1; i < NSIG; i++)\n    {\n      if (i != SIGSTOP && i != SIGKILL)\n        signal (i, SIG_DFL);\n    }\n\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].from != fd_map[i].to)\n        {\n          dup2 (fd_map[i].from, fd_map[i].to);\n          close (fd_map[i].from);\n        }\n    }\n\n  /* Second pass in case we needed an in-between fd value to avoid conflicts */\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].to != fd_map[i].final)\n        {\n          dup2 (fd_map[i].to, fd_map[i].final);\n          close (fd_map[i].to);\n        }\n\n      /* Ensure we inherit the final fd value */\n      drop_cloexec (fd_map[i].final);\n    }\n\n  /* We become our own session and process group, because it never makes sense\n     to share the flatpak-session-helper dbus activated process group */\n  setsid ();\n  setpgid (0, 0);\n\n  if (data->set_tty)\n    {\n      /* data->tty is our from fd which is closed at this point.\n       * so locate the destination fd and use it for the ioctl.\n       */\n      for (i = 0; i < data->fd_map_len; i++)\n        {\n          if (fd_map[i].from == data->tty)\n            {\n              if (ioctl (fd_map[i].final, TIOCSCTTY, 0) == -1)\n                g_debug (\""ioctl(%d, TIOCSCTTY, 0) failed: %s\"",\n                         fd_map[i].final, strerror (errno));\n              break;\n            }\n        }\n    }\n}""}, {""func_name"": ""handle_spawn"", ""file_path"": ""portal/flatpak-portal.c"", ""func_code"": ""static gboolean\nhandle_spawn (PortalFlatpak         *object,\n              GDBusMethodInvocation *invocation,\n              GUnixFDList           *fd_list,\n              const gchar           *arg_cwd_path,\n              const gchar *const    *arg_argv,\n              GVariant              *arg_fds,\n              GVariant              *arg_envs,\n              guint                  arg_flags,\n              GVariant              *arg_options)\n{\n  g_autoptr(GError) error = NULL;\n  ChildSetupData child_setup_data = { NULL };\n  GPid pid;\n  PidData *pid_data;\n  InstanceIdReadData *instance_id_read_data = NULL;\n  gsize i, j, n_fds, n_envs;\n  const gint *fds = NULL;\n  gint fds_len = 0;\n  g_autofree FdMapEntry *fd_map = NULL;\n  gchar **env;\n  gint32 max_fd;\n  GKeyFile *app_info;\n  g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);\n  g_autofree char *app_id = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *arch = NULL;\n  g_autofree char *app_commit = NULL;\n  g_autofree char *runtime_ref = NULL;\n  g_auto(GStrv) runtime_parts = NULL;\n  g_autofree char *runtime_commit = NULL;\n  g_autofree char *instance_path = NULL;\n  g_auto(GStrv) extra_args = NULL;\n  g_auto(GStrv) shares = NULL;\n  g_auto(GStrv) sockets = NULL;\n  g_auto(GStrv) devices = NULL;\n  g_auto(GStrv) sandbox_expose = NULL;\n  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n  g_autoptr(GString) env_string = g_string_new (\""\"");\n\n  child_setup_data.instance_id_fd = -1;\n  child_setup_data.env_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \""app-info\"");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n  g_assert (app_id != NULL);\n\n  g_debug (\""spawn() called from app: '%s'\"", app_id);\n  if (*app_id == 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""org.freedesktop.portal.Flatpak.Spawn only works in a flatpak\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (*arg_cwd_path == 0)\n    arg_cwd_path = NULL;\n\n  if (arg_argv == NULL || *arg_argv == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""No command given\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Unsupported flags enabled: 0x%x\"", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_ref = g_key_file_get_string (app_info,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  if (runtime_ref == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""No runtime found\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_parts = g_strsplit (runtime_ref, \""/\"", -1);\n\n  branch = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_BRANCH, NULL);\n  instance_path = g_key_file_get_string (app_info,\n                                         FLATPAK_METADATA_GROUP_INSTANCE,\n                                         FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);\n  arch = g_key_file_get_string (app_info,\n                                FLATPAK_METADATA_GROUP_INSTANCE,\n                                FLATPAK_METADATA_KEY_ARCH, NULL);\n  extra_args = g_key_file_get_string_list (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);\n  app_commit = g_key_file_get_string (app_info,\n                                      FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_APP_COMMIT, NULL);\n  runtime_commit = g_key_file_get_string (app_info,\n                                          FLATPAK_METADATA_GROUP_INSTANCE,\n                                          FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);\n  shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SHARED, NULL, NULL);\n  sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);\n  devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                        FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);\n\n  devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_DEVEL, NULL);\n\n  g_variant_lookup (arg_options, \""sandbox-expose\"", \""^as\"", &sandbox_expose);\n  g_variant_lookup (arg_options, \""sandbox-expose-ro\"", \""^as\"", &sandbox_expose_ro);\n  g_variant_lookup (arg_options, \""sandbox-flags\"", \""u\"", &sandbox_flags);\n  sandbox_expose_fd = g_variant_lookup_value (arg_options, \""sandbox-expose-fd\"", G_VARIANT_TYPE (\""ah\""));\n  sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, \""sandbox-expose-fd-ro\"", G_VARIANT_TYPE (\""ah\""));\n\n  if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Unsupported sandbox flags enabled: 0x%x\"", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_path == NULL &&\n      ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||\n       (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \""Invalid sandbox expose, caller has no instance path\"");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose[i];\n\n      g_debug (\""exposing %s\"", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\""exposing %s\"", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  g_debug (\""Running spawn command %s\"", arg_argv[0]);\n\n  n_fds = 0;\n  if (fds != NULL)\n    n_fds = g_variant_n_children (arg_fds);\n  fd_map = g_new0 (FdMapEntry, n_fds);\n\n  child_setup_data.fd_map = fd_map;\n  child_setup_data.fd_map_len = n_fds;\n\n  max_fd = -1;\n  for (i = 0; i < n_fds; i++)\n    {\n      gint32 handle, dest_fd;\n      int handle_fd;\n\n      g_variant_get_child (arg_fds, i, \""{uh}\"", &dest_fd, &handle);\n\n      if (handle >= fds_len || handle < 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \""No file descriptor for handle %d\"",\n                                                 handle);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      handle_fd = fds[handle];\n\n      fd_map[i].to = dest_fd;\n      fd_map[i].from = handle_fd;\n      fd_map[i].final = fd_map[i].to;\n\n      /* If stdin/out/err is a tty we try to set it as the controlling\n         tty for the app, this way we can use this to run in a terminal. */\n      if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&\n          !child_setup_data.set_tty &&\n          isatty (handle_fd))\n        {\n          child_setup_data.set_tty = TRUE;\n          child_setup_data.tty = handle_fd;\n        }\n\n      max_fd = MAX (max_fd, fd_map[i].to);\n      max_fd = MAX (max_fd, fd_map[i].from);\n    }\n\n  /* We make a second pass over the fds to find if any \""to\"" fd index\n     overlaps an already in use fd (i.e. one in the \""from\"" category\n     that are allocated randomly). If a fd overlaps \""to\"" fd then its\n     a caller issue and not our fault, so we ignore that. */\n  for (i = 0; i < n_fds; i++)\n    {\n      int to_fd = fd_map[i].to;\n      gboolean conflict = FALSE;\n\n      /* At this point we're fine with using \""from\"" values for this\n         value (because we handle to==from in the code), or values\n         that are before \""i\"" in the fd_map (because those will be\n         closed at this point when dup:ing). However, we can't\n         reuse a fd that is in \""from\"" for j > i. */\n      for (j = i + 1; j < n_fds; j++)\n        {\n          int from_fd = fd_map[j].from;\n          if (from_fd == to_fd)\n            {\n              conflict = TRUE;\n              break;\n            }\n        }\n\n      if (conflict)\n        fd_map[i].to = ++max_fd;\n    }\n\n  if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)\n    {\n      char *empty[] = { NULL };\n      env = g_strdupv (empty);\n    }\n  else\n    env = g_get_environ ();\n\n  n_envs = g_variant_n_children (arg_envs);\n  for (i = 0; i < n_envs; i++)\n    {\n      const char *var = NULL;\n      const char *val = NULL;\n      g_variant_get_child (arg_envs, i, \""{&s&s}\"", &var, &val);\n\n      env = g_environ_setenv (env, var, val, TRUE);\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup (\""flatpak\""));\n  g_ptr_array_add (flatpak_argv, g_strdup (\""run\""));\n\n  sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;\n\n  if (sandboxed)\n    {\n      g_ptr_array_add (flatpak_argv, g_strdup (\""--sandbox\""));\n\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""wayland\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=wayland\""));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""fallback-x11\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=fallback-x11\""));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""x11\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=x11\""));\n          if (shares != NULL && g_strv_contains ((const char * const *) shares, \""ipc\"") &&\n              sockets != NULL && (g_strv_contains ((const char * const *) sockets, \""fallback-x11\"") ||\n                                  g_strv_contains ((const char * const *) sockets, \""x11\"")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--share=ipc\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \""pulseaudio\""))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--socket=pulseaudio\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)\n        {\n          if (devices != NULL &&\n              (g_strv_contains ((const char * const *) devices, \""dri\"") ||\n               g_strv_contains ((const char * const *) devices, \""all\"")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\""--device=dri\""));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--session-bus\""));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--a11y-bus\""));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        {\n          if (g_str_has_prefix (extra_args[i], \""--env=\""))\n            {\n              const char *var_val = extra_args[i] + strlen (\""--env=\"");\n\n              if (var_val[0] == '\\0' || var_val[0] == '=')\n                {\n                  g_warning (\""Environment variable in extra-args has empty name\"");\n                  continue;\n                }\n\n              if (strchr (var_val, '=') == NULL)\n                {\n                  g_warning (\""Environment variable in extra-args has no value\"");\n                  continue;\n                }\n\n              g_string_append (env_string, var_val);\n              g_string_append_c (env_string, '\\0');\n            }\n          else\n            {\n              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n            }\n        }\n    }\n\n  if (env_string->len > 0)\n    {\n      g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n\n      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \""environ\"",\n                                                      env_string->str,\n                                                      env_string->len, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n      g_ptr_array_add (flatpak_argv,\n                       g_strdup_printf (\""--env-fd=%d\"",\n                                        child_setup_data.env_fd));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n\n      if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_NOT_SUPPORTED,\n                                                 \""Expose pids not supported with setuid bwrap\"");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      instance_id = g_key_file_get_string (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);\n\n      if (instance_id)\n        {\n          g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);\n          sender_pid1 = flatpak_instance_get_child_pid (instance);\n        }\n\n      if (sender_pid1 == 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \""Could not find requesting pid\"");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--parent-pid=%d\"", sender_pid1));\n\n      if (share_pids)\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--parent-share-pids\""));\n      else\n        g_ptr_array_add (flatpak_argv, g_strdup (\""--parent-expose-pids\""));\n    }\n\n  notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;\n  if (notify_start)\n    {\n      int pipe_fds[2];\n      if (pipe (pipe_fds) == -1)\n        {\n          int errsv = errno;\n          g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,\n                                                 g_io_error_from_errno (errsv),\n                                                 \""Failed to create instance ID pipe: %s\"",\n                                                 g_strerror (errsv));\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));\n      /* This is saved to ensure the portal's end gets closed after the exec. */\n      instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));\n\n      instance_id_read_data = g_new0 (InstanceIdReadData, 1);\n\n      g_input_stream_read_async (in_stream, instance_id_read_data->buffer,\n                                 INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,\n                                 instance_id_read_finish, instance_id_read_data);\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--instance-id-fd=%d\"", pipe_fds[1]));\n      child_setup_data.instance_id_fd = pipe_fds[1];\n    }\n\n  if (devel)\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--devel\""));\n\n  /* Inherit launcher network access from launcher, unless\n     NO_NETWORK set. */\n  if (shares != NULL && g_strv_contains ((const char * const *) shares, \""network\"") &&\n      !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--share=network\""));\n  else\n    g_ptr_array_add (flatpak_argv, g_strdup (\""--unshare=network\""));\n\n\n  if (instance_path)\n    {\n      for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));\n      for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\""exposing %s\"", expose);\n    }\n\n  if (sandbox_expose_fd != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd, i, \""h\"", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));\n                }\n              else\n                {\n                  g_debug (\""unable to get path for sandbox-exposed fd %d, ignoring: %s\"",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \""No file descriptor for handle %d\"",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  if (sandbox_expose_fd_ro != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd_ro);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd_ro, i, \""h\"", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));\n                }\n              else\n                {\n                  g_debug (\""unable to get path for sandbox-exposed fd %d, ignoring: %s\"",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \""No file descriptor for handle %d\"",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime=%s\"", runtime_parts[1]));\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime-version=%s\"", runtime_parts[3]));\n\n  if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)\n    {\n      if (app_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--commit=%s\"", app_commit));\n      if (runtime_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--runtime-commit=%s\"", runtime_commit));\n    }\n\n  if (arg_cwd_path != NULL)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--cwd=%s\"", arg_cwd_path));\n\n  if (arg_argv[0][0] != 0)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\""--command=%s\"", arg_argv[0]));\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\""%s/%s/%s\"", app_id, arch ? arch : \""\"", branch ? branch : \""\""));\n  for (i = 1; arg_argv[i] != NULL; i++)\n    g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));\n  g_ptr_array_add (flatpak_argv, NULL);\n\n  if (opt_verbose)\n    {\n      g_autoptr(GString) cmd = g_string_new (\""\"");\n\n      for (i = 0; flatpak_argv->pdata[i] != NULL; i++)\n        {\n          if (i > 0)\n            g_string_append (cmd, \"" \"");\n          g_string_append (cmd, flatpak_argv->pdata[i]);\n        }\n\n      g_debug (\""Starting: %s\\n\"", cmd->str);\n    }\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async_with_pipes (NULL,\n                                 (char **) flatpak_argv->pdata,\n                                 env,\n                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                                 child_setup_func, &child_setup_data,\n                                 &pid,\n                                 NULL,\n                                 NULL,\n                                 NULL,\n                                 &error))\n    {\n      gint code = G_DBUS_ERROR_FAILED;\n      if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))\n        code = G_DBUS_ERROR_ACCESS_DENIED;\n      else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))\n        code = G_DBUS_ERROR_FILE_NOT_FOUND;\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,\n                                             \""Failed to start command: %s\"",\n                                             error->message);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_id_read_data)\n    instance_id_read_data->pid = pid;\n\n  pid_data = g_new0 (PidData, 1);\n  pid_data->pid = pid;\n  pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));\n  pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;\n  pid_data->expose_or_share_pids = (expose_pids || share_pids);\n  pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,\n                                                  pid,\n                                                  child_watch_died,\n                                                  pid_data,\n                                                  NULL);\n\n  g_debug (\""Client Pid is %d\"", pid_data->pid);\n\n  g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),\n                        pid_data);\n\n  portal_flatpak_complete_spawn (object, invocation, NULL, pid);\n  return G_DBUS_METHOD_INVOCATION_HANDLED;\n}""}, {""func_name"": ""flatpak_run_add_environment_args"", ""file_path"": ""common/flatpak-run.c"", ""func_code"": ""gboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\""Disallowing ipc access\"");\n      flatpak_bwrap_add_args (bwrap, \""--unshare-ipc\"", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\""Disallowing network access\"");\n      flatpak_bwrap_add_args (bwrap, \""--unshare-net\"", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \""--dev-bind\"", \""/dev\"", \""/dev\"",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\""/dev/shm\"", G_FILE_TEST_IS_DIR))\n        {\n          if ((context->devices & FLATPAK_CONTEXT_DEVICE_SHM) == 0)\n            flatpak_bwrap_add_args (bwrap,\n                                    \""--tmpfs\"", \""/dev/shm\"",\n                                    NULL);\n        }\n      else if (g_file_test (\""/dev/shm\"", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\""/dev/shm\"", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \""/run/shm\"") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\""/run/shm\"", G_FILE_TEST_IS_DIR))\n                flatpak_bwrap_add_args (bwrap,\n                                        \""--bind\"", \""/run/shm\"", \""/run/shm\"",\n                                        NULL);\n              else\n                flatpak_bwrap_add_args (bwrap,\n                                        \""--dir\"", \""/run/shm\"",\n                                        NULL);\n            }\n          else\n            g_warning (\""Unexpected /dev/shm symlink %s\"", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \""--dev\"", \""/dev\"",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\""Allowing dri access\"");\n          int i;\n          char *dri_devices[] = {\n            \""/dev/dri\"",\n            /* mali */\n            \""/dev/mali\"",\n            \""/dev/mali0\"",\n            \""/dev/umplock\"",\n            /* nvidia */\n            \""/dev/nvidiactl\"",\n            \""/dev/nvidia-modeset\"",\n            /* nvidia OpenCL/CUDA */\n            \""/dev/nvidia-uvm\"",\n            \""/dev/nvidia-uvm-tools\"",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \""--dev-bind\"", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \""/dev/nvidia%d\"", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \""--dev-bind\"", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\""Allowing kvm access\"");\n          if (g_file_test (\""/dev/kvm\"", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \""--dev-bind\"", \""/dev/kvm\"", \""/dev/kvm\"", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\""/dev/shm\"", NULL);\n\n          g_debug (\""Allowing /dev/shm access (as %s)\"", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \""--bind\"", real_dev_shm, \""/dev/shm\"", NULL);\n        }\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir, previous_app_id_dirs, &exports);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\""Allowing wayland access\"");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\""Allowing pulseaudio access\"");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\""Failed to run in transient scope: %s\"", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}""}, {""func_name"": ""flatpak_run_app"", ""file_path"": ""common/flatpak-run.c"", ""func_code"": ""gboolean\nflatpak_run_app (FlatpakDecomposed *app_ref,\n                 FlatpakDeploy     *app_deploy,\n                 FlatpakContext    *extra_context,\n                 const char        *custom_runtime,\n                 const char        *custom_runtime_version,\n                 const char        *custom_runtime_commit,\n                 int                parent_pid,\n                 FlatpakRunFlags    flags,\n                 const char        *cwd,\n                 const char        *custom_command,\n                 char              *args[],\n                 int                n_args,\n                 int                instance_id_fd,\n                 char             **instance_dir_out,\n                 GCancellable      *cancellable,\n                 GError           **error)\n{\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(GBytes) runtime_deploy_data = NULL;\n  g_autoptr(GBytes) app_deploy_data = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(GFile) bin_ldconfig = NULL;\n  g_autoptr(GFile) app_id_dir = NULL;\n  g_autoptr(GFile) real_app_id_dir = NULL;\n  g_autofree char *default_runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) default_runtime = NULL;\n  g_autofree char *default_command = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GKeyFile) runtime_metakey = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  const char *command = \""/bin/sh\"";\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  int i;\n  g_autoptr(GPtrArray) previous_app_id_dirs = NULL;\n  g_autofree char *app_id = NULL;\n  g_autofree char *app_arch = NULL;\n  g_autofree char *app_info_path = NULL;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autofree char *commandline = NULL;\n  g_autofree char *doc_mount_path = NULL;\n  g_autofree char *app_extensions = NULL;\n  g_autofree char *runtime_extensions = NULL;\n  g_autofree char *checksum = NULL;\n  int ld_so_fd = -1;\n  g_autoptr(GFile) runtime_ld_so_conf = NULL;\n  gboolean generate_ld_so_conf = TRUE;\n  gboolean use_ld_so_cache = TRUE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n  gboolean parent_expose_pids = (flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS) != 0;\n  gboolean parent_share_pids = (flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS) != 0;\n  struct stat s;\n\n  if (!check_sudo (error))\n    return FALSE;\n\n  app_id = flatpak_decomposed_dup_id (app_ref);\n  app_arch = flatpak_decomposed_dup_arch (app_ref);\n\n  /* Check the user is allowed to run this flatpak. */\n  if (!check_parental_controls (app_ref, app_deploy, cancellable, error))\n    return FALSE;\n\n  /* Construct the bwrap context. */\n  bwrap = flatpak_bwrap_new (NULL);\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  if (app_deploy == NULL)\n    {\n      g_assert (flatpak_decomposed_is_runtime (app_ref));\n      default_runtime_pref = flatpak_decomposed_dup_pref (app_ref);\n    }\n  else\n    {\n      const gchar *key;\n\n      app_deploy_data = flatpak_deploy_get_deploy_data (app_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (app_deploy_data == NULL)\n        return FALSE;\n\n      if ((flags & FLATPAK_RUN_FLAG_DEVEL) != 0)\n        key = FLATPAK_METADATA_KEY_SDK;\n      else\n        key = FLATPAK_METADATA_KEY_RUNTIME;\n\n      metakey = flatpak_deploy_get_metadata (app_deploy);\n      default_runtime_pref = g_key_file_get_string (metakey,\n                                                    FLATPAK_METADATA_GROUP_APPLICATION,\n                                                    key, &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n    }\n\n  default_runtime = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, default_runtime_pref, error);\n  if (default_runtime == NULL)\n    return FALSE;\n\n  if (custom_runtime != NULL || custom_runtime_version != NULL)\n    {\n      g_auto(GStrv) custom_runtime_parts = NULL;\n      const char *custom_runtime_id = NULL;\n      const char *custom_runtime_arch = NULL;\n\n      if (custom_runtime)\n        {\n          custom_runtime_parts = g_strsplit (custom_runtime, \""/\"", 0);\n          for (i = 0; i < 3 && custom_runtime_parts[i] != NULL; i++)\n            {\n              if (strlen (custom_runtime_parts[i]) > 0)\n                {\n                  if (i == 0)\n                    custom_runtime_id = custom_runtime_parts[i];\n                  if (i == 1)\n                    custom_runtime_arch = custom_runtime_parts[i];\n\n                  if (i == 2 && custom_runtime_version == NULL)\n                    custom_runtime_version = custom_runtime_parts[i];\n                }\n            }\n        }\n\n      runtime_ref = flatpak_decomposed_new_from_decomposed (default_runtime,\n                                                            FLATPAK_KINDS_RUNTIME,\n                                                            custom_runtime_id,\n                                                            custom_runtime_arch,\n                                                            custom_runtime_version,\n                                                            error);\n      if (runtime_ref == NULL)\n        return FALSE;\n    }\n  else\n    runtime_ref = flatpak_decomposed_ref (default_runtime);\n\n  runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), custom_runtime_commit, NULL, cancellable, error);\n  if (runtime_deploy == NULL)\n    return FALSE;\n\n  runtime_deploy_data = flatpak_deploy_get_deploy_data (runtime_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n  if (runtime_deploy_data == NULL)\n    return FALSE;\n\n  runtime_metakey = flatpak_deploy_get_metadata (runtime_deploy);\n\n  app_context = flatpak_app_compute_permissions (metakey, runtime_metakey, error);\n  if (app_context == NULL)\n    return FALSE;\n\n  if (app_deploy != NULL)\n    {\n      overrides = flatpak_deploy_get_overrides (app_deploy);\n      flatpak_context_merge (app_context, overrides);\n    }\n\n  if (sandboxed)\n    flatpak_context_make_sandboxed (app_context);\n\n  if (extra_context)\n    flatpak_context_merge (app_context, extra_context);\n\n  runtime_files = flatpak_deploy_get_files (runtime_deploy);\n  bin_ldconfig = g_file_resolve_relative_path (runtime_files, \""bin/ldconfig\"");\n  if (!g_file_query_exists (bin_ldconfig, NULL))\n    use_ld_so_cache = FALSE;\n\n  if (app_deploy != NULL)\n    {\n      g_autofree const char **previous_ids = NULL;\n      gsize len = 0;\n      gboolean do_migrate;\n\n      real_app_id_dir = flatpak_get_data_dir (app_id);\n      app_files = flatpak_deploy_get_files (app_deploy);\n\n      previous_app_id_dirs = g_ptr_array_new_with_free_func (g_object_unref);\n      previous_ids = flatpak_deploy_data_get_previous_ids (app_deploy_data, &len);\n\n      do_migrate = !g_file_query_exists (real_app_id_dir, cancellable);\n\n      /* When migrating, find most recent old existing source and rename that to\n       * the new name.\n       *\n       * We ignore other names than that. For more recent names that don't exist\n       * we never ran them so nothing will even reference them. For older names\n       * either they were not used, or they were used but then the more recent\n       * name was used and a symlink to it was created.\n       *\n       * This means we may end up with a chain of symlinks: oldest -> old -> current.\n       * This is unfortunate but not really a problem, but for robustness reasons we\n       * don't want to mess with user files unnecessary. For example, the app dir could\n       * actually be a symlink for other reasons. Imagine for instance that you want to put the\n       * steam games somewhere else so you leave the app dir as a symlink to /mnt/steam.\n       */\n      for (i = len - 1; i >= 0; i--)\n        {\n          g_autoptr(GFile) previous_app_id_dir = NULL;\n          g_autoptr(GFileInfo) previous_app_id_dir_info = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          previous_app_id_dir = flatpak_get_data_dir (previous_ids[i]);\n          previous_app_id_dir_info = g_file_query_info (previous_app_id_dir,\n                                                        G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \"",\""\n                                                        G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                        cancellable,\n                                                        &local_error);\n          /* Warn about the migration failures, but don't make them fatal, then you can never run the app */\n          if (previous_app_id_dir_info == NULL)\n            {\n              if  (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) && do_migrate)\n                {\n                  g_warning (_(\""Failed to migrate from %s: %s\""), flatpak_file_get_path_cached (previous_app_id_dir),\n                             local_error->message);\n                  do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to the thing that we failed on */\n                }\n\n              g_clear_error (&local_error);\n              continue;\n            }\n\n          if (do_migrate)\n            {\n              do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to this dir */\n\n              if (!flatpak_file_rename (previous_app_id_dir, real_app_id_dir, cancellable, &local_error))\n                {\n                  g_warning (_(\""Failed to migrate old app data directory %s to new name %s: %s\""),\n                             flatpak_file_get_path_cached (previous_app_id_dir), app_id,\n                             local_error->message);\n                }\n              else\n                {\n                  /* Leave a symlink in place of the old data dir */\n                  if (!g_file_make_symbolic_link (previous_app_id_dir, app_id, cancellable, &local_error))\n                    {\n                      g_warning (_(\""Failed to create symlink while migrating %s: %s\""),\n                                 flatpak_file_get_path_cached (previous_app_id_dir),\n                                 local_error->message);\n                    }\n                }\n            }\n\n          /* Give app access to this old dir */\n          g_ptr_array_add (previous_app_id_dirs, g_steal_pointer (&previous_app_id_dir));\n        }\n\n      if (!flatpak_ensure_data_dir (real_app_id_dir, cancellable, error))\n        return FALSE;\n\n      if (!sandboxed)\n        app_id_dir = g_object_ref (real_app_id_dir);\n    }\n\n  flatpak_run_apply_env_default (bwrap, use_ld_so_cache);\n  flatpak_run_apply_env_vars (bwrap, app_context);\n  flatpak_run_apply_env_prompt (bwrap, app_id);\n\n  if (real_app_id_dir)\n    {\n      g_autoptr(GFile) sandbox_dir = g_file_get_child (real_app_id_dir, \""sandbox\"");\n      flatpak_bwrap_set_env (bwrap, \""FLATPAK_SANDBOX_DIR\"", flatpak_file_get_path_cached (sandbox_dir), TRUE);\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \""--ro-bind\"", flatpak_file_get_path_cached (runtime_files), \""/usr\"",\n                          \""--lock-file\"", \""/usr/.ref\"",\n                          NULL);\n\n  if (app_files != NULL)\n    flatpak_bwrap_add_args (bwrap,\n                            \""--ro-bind\"", flatpak_file_get_path_cached (app_files), \""/app\"",\n                            \""--lock-file\"", \""/app/.ref\"",\n                            NULL);\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \""--dir\"", \""/app\"",\n                            NULL);\n\n  if (metakey != NULL &&\n      !flatpak_run_add_extension_args (bwrap, metakey, app_ref, use_ld_so_cache, &app_extensions, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_run_add_extension_args (bwrap, runtime_metakey, runtime_ref, use_ld_so_cache, &runtime_extensions, cancellable, error))\n    return FALSE;\n\n  runtime_ld_so_conf = g_file_resolve_relative_path (runtime_files, \""etc/ld.so.conf\"");\n  if (lstat (flatpak_file_get_path_cached (runtime_ld_so_conf), &s) == 0)\n    generate_ld_so_conf = S_ISREG (s.st_mode) && s.st_size == 0;\n\n  /* At this point we have the minimal argv set up, with just the app, runtime and extensions.\n     We can reuse this to generate the ld.so.cache (if needed) */\n  if (use_ld_so_cache)\n    {\n      checksum = calculate_ld_cache_checksum (app_deploy_data, runtime_deploy_data,\n                                              app_extensions, runtime_extensions);\n      ld_so_fd = regenerate_ld_cache (bwrap->argv,\n                                      bwrap->fds,\n                                      app_id_dir,\n                                      checksum,\n                                      runtime_files,\n                                      generate_ld_so_conf,\n                                      cancellable, error);\n      if (ld_so_fd == -1)\n        return FALSE;\n      flatpak_bwrap_add_fd (bwrap, ld_so_fd);\n    }\n\n  flags |= flatpak_context_get_run_flags (app_context);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, app_id_dir, app_arch, flags, error))\n    return FALSE;\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return FALSE;\n    }\n\n  if (ld_so_fd != -1)\n    {\n      /* Don't add to fd_array, its already there */\n      flatpak_bwrap_add_arg (bwrap, \""--ro-bind-data\"");\n      flatpak_bwrap_add_arg_printf (bwrap, \""%d\"", ld_so_fd);\n      flatpak_bwrap_add_arg (bwrap, \""/etc/ld.so.cache\"");\n    }\n\n  if (!flatpak_run_add_app_info_args (bwrap,\n                                      app_files, app_deploy_data, app_extensions,\n                                      runtime_files, runtime_deploy_data, runtime_extensions,\n                                      app_id, flatpak_decomposed_get_branch (app_ref),\n                                      runtime_ref, app_id_dir, app_context, extra_context,\n                                      sandboxed, FALSE, flags & FLATPAK_RUN_FLAG_DEVEL,\n                                      &app_info_path, instance_id_fd, &instance_id_host_dir,\n                                      error))\n    return FALSE;\n\n  if (!flatpak_run_add_dconf_args (bwrap, app_id, metakey, error))\n    return FALSE;\n\n  if (!sandboxed && !(flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL))\n    add_document_portal_args (bwrap, app_id, &doc_mount_path);\n\n  if (!flatpak_run_add_environment_args (bwrap, app_info_path, flags,\n                                         app_id, app_context, app_id_dir, previous_app_id_dirs,\n                                         &exports, cancellable, error))\n    return FALSE;\n\n  if ((app_context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) != 0)\n    flatpak_run_add_resolved_args (bwrap);\n\n  flatpak_run_add_journal_args (bwrap);\n  add_font_path_args (bwrap);\n  add_icon_path_args (bwrap);\n\n  flatpak_bwrap_add_args (bwrap,\n                          /* Not in base, because we don't want this for flatpak build */\n                          \""--symlink\"", \""/app/lib/debug/source\"", \""/run/build\"",\n                          \""--symlink\"", \""/usr/lib/debug/source\"", \""/run/build-runtime\"",\n                          NULL);\n\n  if (cwd)\n    flatpak_bwrap_add_args (bwrap, \""--chdir\"", cwd, NULL);\n\n  if (parent_expose_pids || parent_share_pids)\n    {\n      g_autofree char *userns_path = NULL;\n      g_autofree char *pidns_path = NULL;\n      g_autofree char *userns2_path = NULL;\n      int userns_fd, userns2_fd, pidns_fd;\n\n      if (parent_pid == 0)\n        return flatpak_fail (error, \""No parent pid specified\"");\n\n      userns_path = g_strdup_printf (\""/proc/%d/root/run/.userns\"", parent_pid);\n\n      userns_fd = open_namespace_fd_if_needed (userns_path, \""/proc/self/ns/user\"");\n      if (userns_fd != -1)\n        {\n          flatpak_bwrap_add_args_data_fd (bwrap, \""--userns\"", userns_fd, NULL);\n\n          userns2_path = g_strdup_printf (\""/proc/%d/ns/user\"", parent_pid);\n          userns2_fd = open_namespace_fd_if_needed (userns2_path, userns_path);\n          if (userns2_fd != -1)\n            flatpak_bwrap_add_args_data_fd (bwrap, \""--userns2\"", userns2_fd, NULL);\n        }\n\n      pidns_path = g_strdup_printf (\""/proc/%d/ns/pid\"", parent_pid);\n      pidns_fd = open (pidns_path, O_RDONLY|O_CLOEXEC);\n      if (pidns_fd != -1)\n        flatpak_bwrap_add_args_data_fd (bwrap, \""--pidns\"", pidns_fd, NULL);\n    }\n\n  if (custom_command)\n    {\n      command = custom_command;\n    }\n  else if (metakey)\n    {\n      default_command = g_key_file_get_string (metakey,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_COMMAND,\n                                               &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n      command = default_command;\n    }\n\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, command);\n\n  if (!add_rest_args (bwrap, app_id,\n                      exports, (flags & FLATPAK_RUN_FLAG_FILE_FORWARDING) != 0,\n                      doc_mount_path,\n                      args, n_args, error))\n    return FALSE;\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\""Running '%s'\"", commandline);\n\n  if ((flags & FLATPAK_RUN_FLAG_BACKGROUND) != 0)\n    {\n      GPid child_pid;\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n      GSpawnFlags spawn_flags;\n\n      spawn_flags = G_SPAWN_SEARCH_PATH;\n      if (flags & FLATPAK_RUN_FLAG_DO_NOT_REAP)\n        spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD;\n\n      /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n      spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (!g_spawn_async (NULL,\n                          (char **) bwrap->argv->pdata,\n                          bwrap->envp,\n                          spawn_flags,\n                          flatpak_bwrap_child_setup_cb, bwrap->fds,\n                          &child_pid,\n                          error))\n        return FALSE;\n\n      g_snprintf (pid_str, sizeof (pid_str), \""%d\"", child_pid);\n      pid_path = g_build_filename (instance_id_host_dir, \""pid\"", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n    }\n  else\n    {\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n\n      g_snprintf (pid_str, sizeof (pid_str), \""%d\"", getpid ());\n      pid_path = g_build_filename (instance_id_host_dir, \""pid\"", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n      /* Ensure we unset O_CLOEXEC for marked fds and rewind fds as needed.\n       * Note that this does not close fds that are not already marked O_CLOEXEC, because\n       * we do want to allow inheriting fds into flatpak run. */\n      flatpak_bwrap_child_setup (bwrap->fds, FALSE);\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n        {\n          g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                               _(\""Unable to start app\""));\n          return FALSE;\n        }\n      /* Not actually reached... */\n    }\n\n  if (instance_dir_out)\n    *instance_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}""}]","{""function"": 1, ""code"": 1, ""caller"": 1}","[{""source"": ""func_info(func:flatpak_bwrap_envp_to_args)"", ""result"": [{""code"": ""void\nflatpak_bwrap_envp_to_args (FlatpakBwrap *bwrap)\n{\n  gsize i;\n\n  for (i = 0; bwrap->envp[i] != NULL; i++)\n    {\n      char *key_val = bwrap->envp[i];\n      char *eq = strchr (key_val, '=');\n\n      if (eq)\n        {\n          flatpak_bwrap_add_arg (bwrap, \""--setenv\"");\n          flatpak_bwrap_take_arg (bwrap, g_strndup (key_val, eq - key_val));\n          flatpak_bwrap_add_arg (bwrap, eq + 1);\n        }\n      else\n        {\n          g_warn_if_reached ();\n        }\n    }\n\n  g_strfreev (g_steal_pointer (&bwrap->envp));\n  bwrap->envp = g_strdupv (flatpak_bwrap_empty_env);\n}"", ""start_line"": 294, ""end_line"": 318, ""full_name"": ""flatpak_bwrap_envp_to_args"", ""file_path"": ""common/flatpak-bwrap.c""}]}, {""source"": ""code_info(file:flatpak-run.c, lines:1450-1470)"", ""result"": ""    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n""}, {""source"": ""caller_info(file:flatpak-run.c, func:flatpak_bwrap_envp_to_args)"", ""result"": [{""call_line"": 4053, ""call_code"": ""flatpak_bwrap_envp_to_args (bwrap)"", ""caller_code"": ""gboolean\nflatpak_run_app (FlatpakDecomposed *app_ref,\n                 FlatpakDeploy     *app_deploy,\n                 FlatpakContext    *extra_context,\n                 const char        *custom_runtime,\n                 const char        *custom_runtime_version,\n                 const char        *custom_runtime_commit,\n                 int                parent_pid,\n                 FlatpakRunFlags    flags,\n                 const char        *cwd,\n                 const char        *custom_command,\n                 char              *args[],\n                 int                n_args,\n                 int                instance_id_fd,\n                 char             **instance_dir_out,\n                 GCancellable      *cancellable,\n                 GError           **error)\n{\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(GBytes) runtime_deploy_data = NULL;\n  g_autoptr(GBytes) app_deploy_data = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(GFile) bin_ldconfig = NULL;\n  g_autoptr(GFile) app_id_dir = NULL;\n  g_autoptr(GFile) real_app_id_dir = NULL;\n  g_autofree char *default_runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) default_runtime = NULL;\n  g_autofree char *default_command = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GKeyFile) runtime_metakey = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  const char *command = \""/bin/sh\"";\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  int i;\n  g_autoptr(GPtrArray) previous_app_id_dirs = NULL;\n  g_autofree char *app_id = NULL;\n  g_autofree char *app_arch = NULL;\n  g_autofree char *app_info_path = NULL;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autofree char *commandline = NULL;\n  g_autofree char *doc_mount_path = NULL;\n  g_autofree char *app_extensions = NULL;\n  g_autofree char *runtime_extensions = NULL;\n  g_autofree char *checksum = NULL;\n  int ld_so_fd = -1;\n  g_autoptr(GFile) runtime_ld_so_conf = NULL;\n  gboolean generate_ld_so_conf = TRUE;\n  gboolean use_ld_so_cache = TRUE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n  gboolean parent_expose_pids = (flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS) != 0;\n  gboolean parent_share_pids = (flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS) != 0;\n  struct stat s;\n\n  if (!check_sudo (error))\n    return FALSE;\n\n  app_id = flatpak_decomposed_dup_id (app_ref);\n  app_arch = flatpak_decomposed_dup_arch (app_ref);\n\n  /* Check the user is allowed to run this flatpak. */\n  if (!check_parental_controls (app_ref, app_deploy, cancellable, error))\n    return FALSE;\n\n  /* Construct the bwrap context. */\n  bwrap = flatpak_bwrap_new (NULL);\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  if (app_deploy == NULL)\n    {\n      g_assert (flatpak_decomposed_is_runtime (app_ref));\n      default_runtime_pref = flatpak_decomposed_dup_pref (app_ref);\n    }\n  else\n    {\n      const gchar *key;\n\n      app_deploy_data = flatpak_deploy_get_deploy_data (app_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (app_deploy_data == NULL)\n        return FALSE;\n\n      if ((flags & FLATPAK_RUN_FLAG_DEVEL) != 0)\n        key = FLATPAK_METADATA_KEY_SDK;\n      else\n        key = FLATPAK_METADATA_KEY_RUNTIME;\n\n      metakey = flatpak_deploy_get_metadata (app_deploy);\n      default_runtime_pref = g_key_file_get_string (metakey,\n                                                    FLATPAK_METADATA_GROUP_APPLICATION,\n                                                    key, &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n    }\n\n  default_runtime = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, default_runtime_pref, error);\n  if (default_runtime == NULL)\n    return FALSE;\n\n  if (custom_runtime != NULL || custom_runtime_version != NULL)\n    {\n      g_auto(GStrv) custom_runtime_parts = NULL;\n      const char *custom_runtime_id = NULL;\n      const char *custom_runtime_arch = NULL;\n\n      if (custom_runtime)\n        {\n          custom_runtime_parts = g_strsplit (custom_runtime, \""/\"", 0);\n          for (i = 0; i < 3 && custom_runtime_parts[i] != NULL; i++)\n            {\n              if (strlen (custom_runtime_parts[i]) > 0)\n                {\n                  if (i == 0)\n                    custom_runtime_id = custom_runtime_parts[i];\n                  if (i == 1)\n                    custom_runtime_arch = custom_runtime_parts[i];\n\n                  if (i == 2 && custom_runtime_version == NULL)\n                    custom_runtime_version = custom_runtime_parts[i];\n                }\n            }\n        }\n\n      runtime_ref = flatpak_decomposed_new_from_decomposed (default_runtime,\n                                                            FLATPAK_KINDS_RUNTIME,\n                                                            custom_runtime_id,\n                                                            custom_runtime_arch,\n                                                            custom_runtime_version,\n                                                            error);\n      if (runtime_ref == NULL)\n        return FALSE;\n    }\n  else\n    runtime_ref = flatpak_decomposed_ref (default_runtime);\n\n  runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), custom_runtime_commit, NULL, cancellable, error);\n  if (runtime_deploy == NULL)\n    return FALSE;\n\n  runtime_deploy_data = flatpak_deploy_get_deploy_data (runtime_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n  if (runtime_deploy_data == NULL)\n    return FALSE;\n\n  runtime_metakey = flatpak_deploy_get_metadata (runtime_deploy);\n\n  app_context = flatpak_app_compute_permissions (metakey, runtime_metakey, error);\n  if (app_context == NULL)\n    return FALSE;\n\n  if (app_deploy != NULL)\n    {\n      overrides = flatpak_deploy_get_overrides (app_deploy);\n      flatpak_context_merge (app_context, overrides);\n    }\n\n  if (sandboxed)\n    flatpak_context_make_sandboxed (app_context);\n\n  if (extra_context)\n    flatpak_context_merge (app_context, extra_context);\n\n  runtime_files = flatpak_deploy_get_files (runtime_deploy);\n  bin_ldconfig = g_file_resolve_relative_path (runtime_files, \""bin/ldconfig\"");\n  if (!g_file_query_exists (bin_ldconfig, NULL))\n    use_ld_so_cache = FALSE;\n\n  if (app_deploy != NULL)\n    {\n      g_autofree const char **previous_ids = NULL;\n      gsize len = 0;\n      gboolean do_migrate;\n\n      real_app_id_dir = flatpak_get_data_dir (app_id);\n      app_files = flatpak_deploy_get_files (app_deploy);\n\n      previous_app_id_dirs = g_ptr_array_new_with_free_func (g_object_unref);\n      previous_ids = flatpak_deploy_data_get_previous_ids (app_deploy_data, &len);\n\n      do_migrate = !g_file_query_exists (real_app_id_dir, cancellable);\n\n      /* When migrating, find most recent old existing source and rename that to\n       * the new name.\n       *\n       * We ignore other names than that. For more recent names that don't exist\n       * we never ran them so nothing will even reference them. For older names\n       * either they were not used, or they were used but then the more recent\n       * name was used and a symlink to it was created.\n       *\n       * This means we may end up with a chain of symlinks: oldest -> old -> current.\n       * This is unfortunate but not really a problem, but for robustness reasons we\n       * don't want to mess with user files unnecessary. For example, the app dir could\n       * actually be a symlink for other reasons. Imagine for instance that you want to put the\n       * steam games somewhere else so you leave the app dir as a symlink to /mnt/steam.\n       */\n      for (i = len - 1; i >= 0; i--)\n        {\n          g_autoptr(GFile) previous_app_id_dir = NULL;\n          g_autoptr(GFileInfo) previous_app_id_dir_info = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          previous_app_id_dir = flatpak_get_data_dir (previous_ids[i]);\n          previous_app_id_dir_info = g_file_query_info (previous_app_id_dir,\n                                                        G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \"",\""\n                                                        G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                        cancellable,\n                                                        &local_error);\n          /* Warn about the migration failures, but don't make them fatal, then you can never run the app */\n          if (previous_app_id_dir_info == NULL)\n            {\n              if  (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) && do_migrate)\n                {\n                  g_warning (_(\""Failed to migrate from %s: %s\""), flatpak_file_get_path_cached (previous_app_id_dir),\n                             local_error->message);\n                  do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to the thing that we failed on */\n                }\n\n              g_clear_error (&local_error);\n              continue;\n            }\n\n          if (do_migrate)\n            {\n              do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to this dir */\n\n              if (!flatpak_file_rename (previous_app_id_dir, real_app_id_dir, cancellable, &local_error))\n                {\n                  g_warning (_(\""Failed to migrate old app data directory %s to new name %s: %s\""),\n                             flatpak_file_get_path_cached (previous_app_id_dir), app_id,\n                             local_error->message);\n                }\n              else\n                {\n                  /* Leave a symlink in place of the old data dir */\n                  if (!g_file_make_symbolic_link (previous_app_id_dir, app_id, cancellable, &local_error))\n                    {\n                      g_warning (_(\""Failed to create symlink while migrating %s: %s\""),\n                                 flatpak_file_get_path_cached (previous_app_id_dir),\n                                 local_error->message);\n                    }\n                }\n            }\n\n          /* Give app access to this old dir */\n          g_ptr_array_add (previous_app_id_dirs, g_steal_pointer (&previous_app_id_dir));\n        }\n\n      if (!flatpak_ensure_data_dir (real_app_id_dir, cancellable, error))\n        return FALSE;\n\n      if (!sandboxed)\n        app_id_dir = g_object_ref (real_app_id_dir);\n    }\n\n  flatpak_run_apply_env_default (bwrap, use_ld_so_cache);\n  flatpak_run_apply_env_vars (bwrap, app_context);\n  flatpak_run_apply_env_prompt (bwrap, app_id);\n\n  if (real_app_id_dir)\n    {\n      g_autoptr(GFile) sandbox_dir = g_file_get_child (real_app_id_dir, \""sandbox\"");\n      flatpak_bwrap_set_env (bwrap, \""FLATPAK_SANDBOX_DIR\"", flatpak_file_get_path_cached (sandbox_dir), TRUE);\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \""--ro-bind\"", flatpak_file_get_path_cached (runtime_files), \""/usr\"",\n                          \""--lock-file\"", \""/usr/.ref\"",\n                          NULL);\n\n  if (app_files != NULL)\n    flatpak_bwrap_add_args (bwrap,\n                            \""--ro-bind\"", flatpak_file_get_path_cached (app_files), \""/app\"",\n                            \""--lock-file\"", \""/app/.ref\"",\n                            NULL);\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \""--dir\"", \""/app\"",\n                            NULL);\n\n  if (metakey != NULL &&\n      !flatpak_run_add_extension_args (bwrap, metakey, app_ref, use_ld_so_cache, &app_extensions, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_run_add_extension_args (bwrap, runtime_metakey, runtime_ref, use_ld_so_cache, &runtime_extensions, cancellable, error))\n    return FALSE;\n\n  runtime_ld_so_conf = g_file_resolve_relative_path (runtime_files, \""etc/ld.so.conf\"");\n  if (lstat (flatpak_file_get_path_cached (runtime_ld_so_conf), &s) == 0)\n    generate_ld_so_conf = S_ISREG (s.st_mode) && s.st_size == 0;\n\n  /* At this point we have the minimal argv set up, with just the app, runtime and extensions.\n     We can reuse this to generate the ld.so.cache (if needed) */\n  if (use_ld_so_cache)\n    {\n      checksum = calculate_ld_cache_checksum (app_deploy_data, runtime_deploy_data,\n                                              app_extensions, runtime_extensions);\n      ld_so_fd = regenerate_ld_cache (bwrap->argv,\n                                      bwrap->fds,\n                                      app_id_dir,\n                                      checksum,\n                                      runtime_files,\n                                      generate_ld_so_conf,\n                                      cancellable, error);\n      if (ld_so_fd == -1)\n        return FALSE;\n      flatpak_bwrap_add_fd (bwrap, ld_so_fd);\n    }\n\n  flags |= flatpak_context_get_run_flags (app_context);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, app_id_dir, app_arch, flags, error))\n    return FALSE;\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return FALSE;\n    }\n\n  if (ld_so_fd != -1)\n    {\n      /* Don't add to fd_array, its already there */\n      flatpak_bwrap_add_arg (bwrap, \""--ro-bind-data\"");\n      flatpak_bwrap_add_arg_printf (bwrap, \""%d\"", ld_so_fd);\n      flatpak_bwrap_add_arg (bwrap, \""/etc/ld.so.cache\"");\n    }\n\n  if (!flatpak_run_add_app_info_args (bwrap,\n                                      app_files, app_deploy_data, app_extensions,\n                                      runtime_files, runtime_deploy_data, runtime_extensions,\n                                      app_id, flatpak_decomposed_get_branch (app_ref),\n                                      runtime_ref, app_id_dir, app_context, extra_context,\n                                      sandboxed, FALSE, flags & FLATPAK_RUN_FLAG_DEVEL,\n                                      &app_info_path, instance_id_fd, &instance_id_host_dir,\n                                      error))\n    return FALSE;\n\n  if (!flatpak_run_add_dconf_args (bwrap, app_id, metakey, error))\n    return FALSE;\n\n  if (!sandboxed && !(flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL))\n    add_document_portal_args (bwrap, app_id, &doc_mount_path);\n\n  if (!flatpak_run_add_environment_args (bwrap, app_info_path, flags,\n                                         app_id, app_context, app_id_dir, previous_app_id_dirs,\n                                         &exports, cancellable, error))\n    return FALSE;\n\n  if ((app_context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) != 0)\n    flatpak_run_add_resolved_args (bwrap);\n\n  flatpak_run_add_journal_args (bwrap);\n  add_font_path_args (bwrap);\n  add_icon_path_args (bwrap);\n\n  flatpak_bwrap_add_args (bwrap,\n                          /* Not in base, because we don't want this for flatpak build */\n                          \""--symlink\"", \""/app/lib/debug/source\"", \""/run/build\"",\n                          \""--symlink\"", \""/usr/lib/debug/source\"", \""/run/build-runtime\"",\n                          NULL);\n\n  if (cwd)\n    flatpak_bwrap_add_args (bwrap, \""--chdir\"", cwd, NULL);\n\n  if (parent_expose_pids || parent_share_pids)\n    {\n      g_autofree char *userns_path = NULL;\n      g_autofree char *pidns_path = NULL;\n      g_autofree char *userns2_path = NULL;\n      int userns_fd, userns2_fd, pidns_fd;\n\n      if (parent_pid == 0)\n        return flatpak_fail (error, \""No parent pid specified\"");\n\n      userns_path = g_strdup_printf (\""/proc/%d/root/run/.userns\"", parent_pid);\n\n      userns_fd = open_namespace_fd_if_needed (userns_path, \""/proc/self/ns/user\"");\n      if (userns_fd != -1)\n        {\n          flatpak_bwrap_add_args_data_fd (bwrap, \""--userns\"", userns_fd, NULL);\n\n          userns2_path = g_strdup_printf (\""/proc/%d/ns/user\"", parent_pid);\n          userns2_fd = open_namespace_fd_if_needed (userns2_path, userns_path);\n          if (userns2_fd != -1)\n            flatpak_bwrap_add_args_data_fd (bwrap, \""--userns2\"", userns2_fd, NULL);\n        }\n\n      pidns_path = g_strdup_printf (\""/proc/%d/ns/pid\"", parent_pid);\n      pidns_fd = open (pidns_path, O_RDONLY|O_CLOEXEC);\n      if (pidns_fd != -1)\n        flatpak_bwrap_add_args_data_fd (bwrap, \""--pidns\"", pidns_fd, NULL);\n    }\n\n  if (custom_command)\n    {\n      command = custom_command;\n    }\n  else if (metakey)\n    {\n      default_command = g_key_file_get_string (metakey,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_COMMAND,\n                                               &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n      command = default_command;\n    }\n\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, command);\n\n  if (!add_rest_args (bwrap, app_id,\n                      exports, (flags & FLATPAK_RUN_FLAG_FILE_FORWARDING) != 0,\n                      doc_mount_path,\n                      args, n_args, error))\n    return FALSE;\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\""Running '%s'\"", commandline);\n\n  if ((flags & FLATPAK_RUN_FLAG_BACKGROUND) != 0)\n    {\n      GPid child_pid;\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n      GSpawnFlags spawn_flags;\n\n      spawn_flags = G_SPAWN_SEARCH_PATH;\n      if (flags & FLATPAK_RUN_FLAG_DO_NOT_REAP)\n        spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD;\n\n      /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n      spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (!g_spawn_async (NULL,\n                          (char **) bwrap->argv->pdata,\n                          bwrap->envp,\n                          spawn_flags,\n                          flatpak_bwrap_child_setup_cb, bwrap->fds,\n                          &child_pid,\n                          error))\n        return FALSE;\n\n      g_snprintf (pid_str, sizeof (pid_str), \""%d\"", child_pid);\n      pid_path = g_build_filename (instance_id_host_dir, \""pid\"", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n    }\n  else\n    {\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n\n      g_snprintf (pid_str, sizeof (pid_str), \""%d\"", getpid ());\n      pid_path = g_build_filename (instance_id_host_dir, \""pid\"", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n      /* Ensure we unset O_CLOEXEC for marked fds and rewind fds as needed.\n       * Note that this does not close fds that are not already marked O_CLOEXEC, because\n       * we do want to allow inheriting fds into flatpak run. */\n      flatpak_bwrap_child_setup (bwrap->fds, FALSE);\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n        {\n          g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                               _(\""Unable to start app\""));\n          return FALSE;\n        }\n      /* Not actually reached... */\n    }\n\n  if (instance_dir_out)\n    *instance_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}\n"", ""caller_start"": 3636, ""file_path"": ""common/flatpak-run.c""}]}]","portal/flatpak-portal.c:1006 (original code): `g_environ_setenv` added caller-controlled environment variables directly to the environment block for `flatpak run`, allowing malicious values (e.g., `LD_PRELOAD`) to influence the host process. portal/flatpak-portal.c (patch): The revised `handle_spawn` validates variable names and routes them through `--env-fd` instead of `g_environ_setenv`, preventing direct environment injection. common/flatpak-run.c:4053: `flatpak_bwrap_envp_to_args` is called to convert environment variables into `--setenv` command-line arguments. common/flatpak-bwrap.c:294-318: `flatpak_bwrap_envp_to_args` processes each environment variable by splitting it into key/value pairs, adds `--setenv` to the `bwrap` argv, and clears the original environment (`bwrap->envp` becomes empty). This ensures no untrusted variables remain in the environment, mitigating code injection risks. common/flatpak-run.c:4080-4082: After `flatpak_bwrap_envp_to_args`, `g_assert (bwrap->envp[0] == NULL)` confirms the environment is cleared, preventing leakage of sensitive or malicious variables.",0.95,./github/other_context/CVE-2021-21261
47,CVE-2021-22879,CWE-74,c_cpp,"Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213,Validate sensitive URLs to onle allow http(s) schemes.\n\nSigned-off-by: allexzander <blackslayer4@gmail.com>,14,"[{""func_name"": ""ExternalWebEnginePage::acceptNavigationRequest"", ""file_path"": ""src/gui/wizard/webview.cpp"", ""func_code"": ""bool ExternalWebEnginePage::acceptNavigationRequest(const QUrl &url, QWebEnginePage::NavigationType type, bool isMainFrame)\n{\n    Q_UNUSED(type);\n    Q_UNUSED(isMainFrame);\n    QDesktopServices::openUrl(url);\n    return false;\n}"", ""target"": 0}, {""func_name"": ""Flow2Auth::fetchNewToken"", ""file_path"": ""src/gui/creds/flow2auth.cpp"", ""func_code"": ""void Flow2Auth::fetchNewToken(const TokenAction action)\n{\n    if(_isBusy)\n        return;\n\n    _isBusy = true;\n    _hasToken = false;\n\n    emit statusChanged(PollStatus::statusFetchToken, 0);\n\n    // Step 1: Initiate a login, do an anonymous POST request\n    QUrl url = Utility::concatUrlPath(_account->url().toString(), QLatin1String(\""/index.php/login/v2\""));\n\n    // add 'Content-Length: 0' header (see https://github.com/nextcloud/desktop/issues/1473)\n    QNetworkRequest req;\n    req.setHeader(QNetworkRequest::ContentLengthHeader, \""0\"");\n    req.setHeader(QNetworkRequest::UserAgentHeader, Utility::friendlyUserAgentString());\n\n    auto job = _account->sendRequest(\""POST\"", url, req);\n    job->setTimeout(qMin(30 * 1000ll, job->timeoutMsec()));\n\n    QObject::connect(job, &SimpleNetworkJob::finishedSignal, this, [this, action](QNetworkReply *reply) {\n        auto jsonData = reply->readAll();\n        QJsonParseError jsonParseError;\n        QJsonObject json = QJsonDocument::fromJson(jsonData, &jsonParseError).object();\n        QString pollToken, pollEndpoint, loginUrl;\n\n        if (reply->error() == QNetworkReply::NoError && jsonParseError.error == QJsonParseError::NoError\n            && !json.isEmpty()) {\n            pollToken = json.value(\""poll\"").toObject().value(\""token\"").toString();\n            pollEndpoint = json.value(\""poll\"").toObject().value(\""endpoint\"").toString();\n            loginUrl = json[\""login\""].toString();\n        }\n\n        if (reply->error() != QNetworkReply::NoError || jsonParseError.error != QJsonParseError::NoError\n            || json.isEmpty() || pollToken.isEmpty() || pollEndpoint.isEmpty() || loginUrl.isEmpty()) {\n            QString errorReason;\n            QString errorFromJson = json[\""error\""].toString();\n            if (!errorFromJson.isEmpty()) {\n                errorReason = tr(\""Error returned from the server: <em>%1</em>\"")\n                                  .arg(errorFromJson.toHtmlEscaped());\n            } else if (reply->error() != QNetworkReply::NoError) {\n                errorReason = tr(\""There was an error accessing the 'token' endpoint: <br><em>%1</em>\"")\n                                  .arg(reply->errorString().toHtmlEscaped());\n            } else if (jsonParseError.error != QJsonParseError::NoError) {\n                errorReason = tr(\""Could not parse the JSON returned from the server: <br><em>%1</em>\"")\n                                  .arg(jsonParseError.errorString());\n            } else {\n                errorReason = tr(\""The reply from the server did not contain all expected fields\"");\n            }\n            qCWarning(lcFlow2auth) << \""Error when getting the loginUrl\"" << json << errorReason;\n            emit result(Error, errorReason);\n            _pollTimer.stop();\n            _isBusy = false;\n            return;\n        }\n\n\n        _loginUrl = loginUrl;\n        _pollToken = pollToken;\n        _pollEndpoint = pollEndpoint;\n\n\n        // Start polling\n        ConfigFile cfg;\n        std::chrono::milliseconds polltime = cfg.remotePollInterval();\n        qCInfo(lcFlow2auth) << \""setting remote poll timer interval to\"" << polltime.count() << \""msec\"";\n        _secondsInterval = (polltime.count() / 1000);\n        _secondsLeft = _secondsInterval;\n        emit statusChanged(PollStatus::statusPollCountdown, _secondsLeft);\n\n        if(!_pollTimer.isActive()) {\n            _pollTimer.start();\n        }\n\n\n        switch(action)\n        {\n        case actionOpenBrowser:\n            // Try to open Browser\n            if (!QDesktopServices::openUrl(authorisationLink())) {\n                // We cannot open the browser, then we claim we don't support Flow2Auth.\n                // Our UI callee will ask the user to copy and open the link.\n                emit result(NotSupported);\n            }\n            break;\n        case actionCopyLinkToClipboard:\n            QApplication::clipboard()->setText(authorisationLink().toString(QUrl::FullyEncoded));\n            emit statusChanged(PollStatus::statusCopyLinkToClipboard, 0);\n            break;\n        }\n\n        _isBusy = false;\n        _hasToken = true;\n    });\n}"", ""target"": 0}, {""func_name"": ""OAuth::openBrowser"", ""file_path"": ""src/gui/creds/oauth.cpp"", ""func_code"": ""bool OAuth::openBrowser()\n{\n    if (!QDesktopServices::openUrl(authorisationLink())) {\n        // We cannot open the browser, then we claim we don't support OAuth.\n        emit result(NotSupported, QString());\n        return false;\n    }\n    return true;\n}"", ""target"": 0}, {""func_name"": ""OwncloudWizardResultPage::slotOpenServer"", ""file_path"": ""src/gui/wizard/owncloudwizardresultpage.cpp"", ""func_code"": ""void OwncloudWizardResultPage::slotOpenServer()\n{\n    Theme *theme = Theme::instance();\n    QUrl url = QUrl(field(\""OCUrl\"").toString() + theme->wizardUrlPostfix());\n    QDesktopServices::openUrl(url);\n}"", ""target"": 0}, {""func_name"": ""Utility::openBrowser"", ""file_path"": ""src/gui/guiutility.cpp"", ""func_code"": ""bool Utility::openBrowser(const QUrl &url, QWidget *errorWidgetParent)\n{\n    if (!QDesktopServices::openUrl(url)) {\n        if (errorWidgetParent) {\n            QMessageBox::warning(\n                errorWidgetParent,\n                QCoreApplication::translate(\""utility\"", \""Could not open browser\""),\n                QCoreApplication::translate(\""utility\"",\n                    \""There was an error when launching the browser to go to \""\n                    \""URL %1. Maybe no default browser is configured?\"")\n                    .arg(url.toString()));\n        }\n        qCWarning(lcUtility) << \""QDesktopServices::openUrl failed for\"" << url;\n        return false;\n    }\n    return true;\n}"", ""target"": 0}, {""func_name"": ""SocketApi::command_EDIT"", ""file_path"": ""src/gui/socketapi.cpp"", ""func_code"": ""void SocketApi::command_EDIT(const QString &localFile, SocketListener *listener)\n{\n    Q_UNUSED(listener)\n    auto fileData = FileData::get(localFile);\n    if (!fileData.folder) {\n        qCWarning(lcSocketApi) << \""Unknown path\"" << localFile;\n        return;\n    }\n\n    auto record = fileData.journalRecord();\n    if (!record.isValid())\n        return;\n\n    DirectEditor* editor = getDirectEditorForLocalFile(fileData.localPath);\n    if (!editor)\n        return;\n\n    auto *job = new JsonApiJob(fileData.folder->accountState()->account(), QLatin1String(\""ocs/v2.php/apps/files/api/v1/directEditing/open\""), this);\n\n    QUrlQuery params;\n    params.addQueryItem(\""path\"", fileData.serverRelativePath);\n    params.addQueryItem(\""editorId\"", editor->id());\n    job->addQueryParams(params);\n    job->usePOST();\n\n    QObject::connect(job, &JsonApiJob::jsonReceived, [](const QJsonDocument &json){\n        auto data = json.object().value(\""ocs\"").toObject().value(\""data\"").toObject();\n        auto url = QUrl(data.value(\""url\"").toString());\n\n        if(!url.isEmpty())\n            Utility::openBrowser(url, nullptr);\n    });\n    job->start();\n}"", ""target"": 0}, {""func_name"": ""OCC::SocketApi::openPrivateLink"", ""file_path"": ""src/gui/socketapi.cpp"", ""func_code"": ""void OCC::SocketApi::openPrivateLink(const QString &link)\n{\n    Utility::openBrowser(link, nullptr);\n}"", ""target"": 0}, {""func_name"": ""ActivityListModel::triggerAction"", ""file_path"": ""src/gui/tray/ActivityListModel.cpp"", ""func_code"": ""void ActivityListModel::triggerAction(int activityIndex, int actionIndex)\n{\n    if (activityIndex < 0 || activityIndex >= _finalList.size()) {\n        qCWarning(lcActivity) << \""Couldn't trigger action on activity at index\"" << activityIndex << \""/ final list size:\"" << _finalList.size();\n        return;\n    }\n\n    const auto activity = _finalList[activityIndex];\n\n    if (actionIndex < 0 || actionIndex >= activity._links.size()) {\n        qCWarning(lcActivity) << \""Couldn't trigger action at index\"" << actionIndex << \""/ actions list size:\"" << activity._links.size();\n        return;\n    }\n\n    const auto action = activity._links[actionIndex];\n\n    if (action._verb == \""WEB\"") {\n        QDesktopServices::openUrl(QUrl(action._link));\n        return;\n    }\n\n    emit sendNotificationRequest(activity._accName, action._link, action._verb, activityIndex);\n}"", ""target"": 0}, {""func_name"": ""ActivityListModel::triggerDefaultAction"", ""file_path"": ""src/gui/tray/ActivityListModel.cpp"", ""func_code"": ""void ActivityListModel::triggerDefaultAction(int activityIndex)\n{\n    if (activityIndex < 0 || activityIndex >= _finalList.size()) {\n        qCWarning(lcActivity) << \""Couldn't trigger default action at index\"" << activityIndex << \""/ final list size:\"" << _finalList.size();\n        return;\n    }\n\n    const auto modelIndex = index(activityIndex);\n    const auto path = data(modelIndex, PathRole).toUrl();\n\n    const auto activity = _finalList.at(activityIndex);\n    if (activity._status == SyncFileItem::Conflict) {\n        Q_ASSERT(!activity._file.isEmpty());\n        Q_ASSERT(!activity._folder.isEmpty());\n        Q_ASSERT(Utility::isConflictFile(activity._file));\n\n        const auto folder = FolderMan::instance()->folder(activity._folder);\n\n        const auto conflictedRelativePath = activity._file;\n        const auto baseRelativePath = folder->journalDb()->conflictFileBaseName(conflictedRelativePath.toUtf8());\n\n        const auto dir = QDir(folder->path());\n        const auto conflictedPath = dir.filePath(conflictedRelativePath);\n        const auto basePath = dir.filePath(baseRelativePath);\n\n        const auto baseName = QFileInfo(basePath).fileName();\n\n        if (!_currentConflictDialog.isNull()) {\n            _currentConflictDialog->close();\n        }\n        _currentConflictDialog = new ConflictDialog;\n        _currentConflictDialog->setBaseFilename(baseName);\n        _currentConflictDialog->setLocalVersionFilename(conflictedPath);\n        _currentConflictDialog->setRemoteVersionFilename(basePath);\n        _currentConflictDialog->setAttribute(Qt::WA_DeleteOnClose);\n        connect(_currentConflictDialog, &ConflictDialog::accepted, folder, [folder]() {\n            folder->scheduleThisFolderSoon();\n        });\n        _currentConflictDialog->open();\n        ownCloudGui::raiseDialog(_currentConflictDialog);\n        return;\n    }\n\n    if (path.isValid()) {\n        QDesktopServices::openUrl(path);\n    } else {\n        const auto link = data(modelIndex, LinkRole).toUrl();\n        QDesktopServices::openUrl(link);\n    }\n}"", ""target"": 0}, {""func_name"": ""UserModel::openCurrentAccountTalk"", ""file_path"": ""src/gui/tray/UserModel.cpp"", ""func_code"": ""Q_INVOKABLE void UserModel::openCurrentAccountTalk()\n{\n    if (!currentUser())\n        return;\n\n    const auto talkApp = currentUser()->talkApp();\n    if (talkApp) {\n        QDesktopServices::openUrl(talkApp->url());\n    } else {\n        qCWarning(lcActivity) << \""The Talk app is not enabled on\"" << currentUser()->server();\n    }\n}"", ""target"": 0}, {""func_name"": ""UserAppsModel::openAppUrl"", ""file_path"": ""src/gui/tray/UserModel.cpp"", ""func_code"": ""void UserAppsModel::openAppUrl(const QUrl &url)\n{\n    QDesktopServices::openUrl(url);\n}"", ""target"": 0}, {""func_name"": ""UserModel::openCurrentAccountServer"", ""file_path"": ""src/gui/tray/UserModel.cpp"", ""func_code"": ""Q_INVOKABLE void UserModel::openCurrentAccountServer()\n{\n    if (_currentUserId < 0 || _currentUserId >= _users.size())\n        return;\n\n    QString url = _users[_currentUserId]->server(false);\n    if (!(url.contains(\""http://\"") || url.contains(\""https://\""))) {\n        url = \""https://\"" + _users[_currentUserId]->server(false);\n    }\n    QDesktopServices::openUrl(QUrl(url));\n}"", ""target"": 0}, {""func_name"": ""ownCloudGui::slotOpenOwnCloud"", ""file_path"": ""src/gui/owncloudgui.cpp"", ""func_code"": ""void ownCloudGui::slotOpenOwnCloud()\n{\n    if (auto account = qvariant_cast<AccountPtr>(sender()->property(propertyAccountC))) {\n        QDesktopServices::openUrl(account->url());\n    }\n}"", ""target"": 0}, {""func_name"": ""AccountSettings::slotOpenOC"", ""file_path"": ""src/gui/accountsettings.cpp"", ""func_code"": ""void AccountSettings::slotOpenOC()\n{\n    if (_OCUrl.isValid())\n        QDesktopServices::openUrl(_OCUrl);\n}"", ""target"": 0}]","[{""func_name"": ""ExternalWebEnginePage::acceptNavigationRequest"", ""file_path"": ""src/gui/wizard/webview.cpp"", ""func_code"": ""bool ExternalWebEnginePage::acceptNavigationRequest(const QUrl &url, QWebEnginePage::NavigationType type, bool isMainFrame)\n{\n    Q_UNUSED(type);\n    Q_UNUSED(isMainFrame);\n    Utility::openBrowser(url);\n    return false;\n}""}, {""func_name"": ""Flow2Auth::fetchNewToken"", ""file_path"": ""src/gui/creds/flow2auth.cpp"", ""func_code"": ""void Flow2Auth::fetchNewToken(const TokenAction action)\n{\n    if(_isBusy)\n        return;\n\n    _isBusy = true;\n    _hasToken = false;\n\n    emit statusChanged(PollStatus::statusFetchToken, 0);\n\n    // Step 1: Initiate a login, do an anonymous POST request\n    QUrl url = Utility::concatUrlPath(_account->url().toString(), QLatin1String(\""/index.php/login/v2\""));\n\n    // add 'Content-Length: 0' header (see https://github.com/nextcloud/desktop/issues/1473)\n    QNetworkRequest req;\n    req.setHeader(QNetworkRequest::ContentLengthHeader, \""0\"");\n    req.setHeader(QNetworkRequest::UserAgentHeader, Utility::friendlyUserAgentString());\n\n    auto job = _account->sendRequest(\""POST\"", url, req);\n    job->setTimeout(qMin(30 * 1000ll, job->timeoutMsec()));\n\n    QObject::connect(job, &SimpleNetworkJob::finishedSignal, this, [this, action](QNetworkReply *reply) {\n        auto jsonData = reply->readAll();\n        QJsonParseError jsonParseError;\n        QJsonObject json = QJsonDocument::fromJson(jsonData, &jsonParseError).object();\n        QString pollToken, pollEndpoint, loginUrl;\n\n        if (reply->error() == QNetworkReply::NoError && jsonParseError.error == QJsonParseError::NoError\n            && !json.isEmpty()) {\n            pollToken = json.value(\""poll\"").toObject().value(\""token\"").toString();\n            pollEndpoint = json.value(\""poll\"").toObject().value(\""endpoint\"").toString();\n            loginUrl = json[\""login\""].toString();\n        }\n\n        if (reply->error() != QNetworkReply::NoError || jsonParseError.error != QJsonParseError::NoError\n            || json.isEmpty() || pollToken.isEmpty() || pollEndpoint.isEmpty() || loginUrl.isEmpty()) {\n            QString errorReason;\n            QString errorFromJson = json[\""error\""].toString();\n            if (!errorFromJson.isEmpty()) {\n                errorReason = tr(\""Error returned from the server: <em>%1</em>\"")\n                                  .arg(errorFromJson.toHtmlEscaped());\n            } else if (reply->error() != QNetworkReply::NoError) {\n                errorReason = tr(\""There was an error accessing the 'token' endpoint: <br><em>%1</em>\"")\n                                  .arg(reply->errorString().toHtmlEscaped());\n            } else if (jsonParseError.error != QJsonParseError::NoError) {\n                errorReason = tr(\""Could not parse the JSON returned from the server: <br><em>%1</em>\"")\n                                  .arg(jsonParseError.errorString());\n            } else {\n                errorReason = tr(\""The reply from the server did not contain all expected fields\"");\n            }\n            qCWarning(lcFlow2auth) << \""Error when getting the loginUrl\"" << json << errorReason;\n            emit result(Error, errorReason);\n            _pollTimer.stop();\n            _isBusy = false;\n            return;\n        }\n\n\n        _loginUrl = loginUrl;\n        _pollToken = pollToken;\n        _pollEndpoint = pollEndpoint;\n\n\n        // Start polling\n        ConfigFile cfg;\n        std::chrono::milliseconds polltime = cfg.remotePollInterval();\n        qCInfo(lcFlow2auth) << \""setting remote poll timer interval to\"" << polltime.count() << \""msec\"";\n        _secondsInterval = (polltime.count() / 1000);\n        _secondsLeft = _secondsInterval;\n        emit statusChanged(PollStatus::statusPollCountdown, _secondsLeft);\n\n        if(!_pollTimer.isActive()) {\n            _pollTimer.start();\n        }\n\n\n        switch(action)\n        {\n        case actionOpenBrowser:\n            // Try to open Browser\n            if (!Utility::openBrowser(authorisationLink())) {\n                // We cannot open the browser, then we claim we don't support Flow2Auth.\n                // Our UI callee will ask the user to copy and open the link.\n                emit result(NotSupported);\n            }\n            break;\n        case actionCopyLinkToClipboard:\n            QApplication::clipboard()->setText(authorisationLink().toString(QUrl::FullyEncoded));\n            emit statusChanged(PollStatus::statusCopyLinkToClipboard, 0);\n            break;\n        }\n\n        _isBusy = false;\n        _hasToken = true;\n    });\n}""}, {""func_name"": ""OAuth::openBrowser"", ""file_path"": ""src/gui/creds/oauth.cpp"", ""func_code"": ""bool OAuth::openBrowser()\n{\n    if (!Utility::openBrowser(authorisationLink())) {\n        // We cannot open the browser, then we claim we don't support OAuth.\n        emit result(NotSupported, QString());\n        return false;\n    }\n    return true;\n}""}, {""func_name"": ""OwncloudWizardResultPage::slotOpenServer"", ""file_path"": ""src/gui/wizard/owncloudwizardresultpage.cpp"", ""func_code"": ""void OwncloudWizardResultPage::slotOpenServer()\n{\n    Theme *theme = Theme::instance();\n    QUrl url = QUrl(field(\""OCUrl\"").toString() + theme->wizardUrlPostfix());\n    Utility::openBrowser(url);\n}""}, {""func_name"": ""Utility::openBrowser"", ""file_path"": ""src/gui/guiutility.cpp"", ""func_code"": ""bool Utility::openBrowser(const QUrl &url, QWidget *errorWidgetParent)\n{\n    const QStringList allowedUrlSchemes = {\n        \""http\"",\n        \""https\"",\n        \""oauthtest\""\n    };\n\n    if (!allowedUrlSchemes.contains(url.scheme())) {\n        qCWarning(lcUtility) << \""URL format is not supported, or it has been compromised for:\"" << url.toString();\n        return false;\n    }\n\n    if (!QDesktopServices::openUrl(url)) {\n        if (errorWidgetParent) {\n            QMessageBox::warning(\n                errorWidgetParent,\n                QCoreApplication::translate(\""utility\"", \""Could not open browser\""),\n                QCoreApplication::translate(\""utility\"",\n                    \""There was an error when launching the browser to go to \""\n                    \""URL %1. Maybe no default browser is configured?\"")\n                    .arg(url.toString()));\n        }\n        qCWarning(lcUtility) << \""QDesktopServices::openUrl failed for\"" << url;\n        return false;\n    }\n    return true;\n}""}, {""func_name"": ""SocketApi::command_EDIT"", ""file_path"": ""src/gui/socketapi.cpp"", ""func_code"": ""void SocketApi::command_EDIT(const QString &localFile, SocketListener *listener)\n{\n    Q_UNUSED(listener)\n    auto fileData = FileData::get(localFile);\n    if (!fileData.folder) {\n        qCWarning(lcSocketApi) << \""Unknown path\"" << localFile;\n        return;\n    }\n\n    auto record = fileData.journalRecord();\n    if (!record.isValid())\n        return;\n\n    DirectEditor* editor = getDirectEditorForLocalFile(fileData.localPath);\n    if (!editor)\n        return;\n\n    auto *job = new JsonApiJob(fileData.folder->accountState()->account(), QLatin1String(\""ocs/v2.php/apps/files/api/v1/directEditing/open\""), this);\n\n    QUrlQuery params;\n    params.addQueryItem(\""path\"", fileData.serverRelativePath);\n    params.addQueryItem(\""editorId\"", editor->id());\n    job->addQueryParams(params);\n    job->usePOST();\n\n    QObject::connect(job, &JsonApiJob::jsonReceived, [](const QJsonDocument &json){\n        auto data = json.object().value(\""ocs\"").toObject().value(\""data\"").toObject();\n        auto url = QUrl(data.value(\""url\"").toString());\n\n        if(!url.isEmpty())\n            Utility::openBrowser(url);\n    });\n    job->start();\n}""}, {""func_name"": ""OCC::SocketApi::openPrivateLink"", ""file_path"": ""src/gui/socketapi.cpp"", ""func_code"": ""void OCC::SocketApi::openPrivateLink(const QString &link)\n{\n    Utility::openBrowser(link);\n}""}, {""func_name"": ""ActivityListModel::triggerAction"", ""file_path"": ""src/gui/tray/ActivityListModel.cpp"", ""func_code"": ""void ActivityListModel::triggerAction(int activityIndex, int actionIndex)\n{\n    if (activityIndex < 0 || activityIndex >= _finalList.size()) {\n        qCWarning(lcActivity) << \""Couldn't trigger action on activity at index\"" << activityIndex << \""/ final list size:\"" << _finalList.size();\n        return;\n    }\n\n    const auto activity = _finalList[activityIndex];\n\n    if (actionIndex < 0 || actionIndex >= activity._links.size()) {\n        qCWarning(lcActivity) << \""Couldn't trigger action at index\"" << actionIndex << \""/ actions list size:\"" << activity._links.size();\n        return;\n    }\n\n    const auto action = activity._links[actionIndex];\n\n    if (action._verb == \""WEB\"") {\n        Utility::openBrowser(QUrl(action._link));\n        return;\n    }\n\n    emit sendNotificationRequest(activity._accName, action._link, action._verb, activityIndex);\n}""}, {""func_name"": ""ActivityListModel::triggerDefaultAction"", ""file_path"": ""src/gui/tray/ActivityListModel.cpp"", ""func_code"": ""void ActivityListModel::triggerDefaultAction(int activityIndex)\n{\n    if (activityIndex < 0 || activityIndex >= _finalList.size()) {\n        qCWarning(lcActivity) << \""Couldn't trigger default action at index\"" << activityIndex << \""/ final list size:\"" << _finalList.size();\n        return;\n    }\n\n    const auto modelIndex = index(activityIndex);\n    const auto path = data(modelIndex, PathRole).toUrl();\n\n    const auto activity = _finalList.at(activityIndex);\n    if (activity._status == SyncFileItem::Conflict) {\n        Q_ASSERT(!activity._file.isEmpty());\n        Q_ASSERT(!activity._folder.isEmpty());\n        Q_ASSERT(Utility::isConflictFile(activity._file));\n\n        const auto folder = FolderMan::instance()->folder(activity._folder);\n\n        const auto conflictedRelativePath = activity._file;\n        const auto baseRelativePath = folder->journalDb()->conflictFileBaseName(conflictedRelativePath.toUtf8());\n\n        const auto dir = QDir(folder->path());\n        const auto conflictedPath = dir.filePath(conflictedRelativePath);\n        const auto basePath = dir.filePath(baseRelativePath);\n\n        const auto baseName = QFileInfo(basePath).fileName();\n\n        if (!_currentConflictDialog.isNull()) {\n            _currentConflictDialog->close();\n        }\n        _currentConflictDialog = new ConflictDialog;\n        _currentConflictDialog->setBaseFilename(baseName);\n        _currentConflictDialog->setLocalVersionFilename(conflictedPath);\n        _currentConflictDialog->setRemoteVersionFilename(basePath);\n        _currentConflictDialog->setAttribute(Qt::WA_DeleteOnClose);\n        connect(_currentConflictDialog, &ConflictDialog::accepted, folder, [folder]() {\n            folder->scheduleThisFolderSoon();\n        });\n        _currentConflictDialog->open();\n        ownCloudGui::raiseDialog(_currentConflictDialog);\n        return;\n    }\n\n    if (path.isValid()) {\n        QDesktopServices::openUrl(path);\n    } else {\n        const auto link = data(modelIndex, LinkRole).toUrl();\n        Utility::openBrowser(link);\n    }\n}""}, {""func_name"": ""UserModel::openCurrentAccountTalk"", ""file_path"": ""src/gui/tray/UserModel.cpp"", ""func_code"": ""Q_INVOKABLE void UserModel::openCurrentAccountTalk()\n{\n    if (!currentUser())\n        return;\n\n    const auto talkApp = currentUser()->talkApp();\n    if (talkApp) {\n        Utility::openBrowser(talkApp->url());\n    } else {\n        qCWarning(lcActivity) << \""The Talk app is not enabled on\"" << currentUser()->server();\n    }\n}""}, {""func_name"": ""UserAppsModel::openAppUrl"", ""file_path"": ""src/gui/tray/UserModel.cpp"", ""func_code"": ""void UserAppsModel::openAppUrl(const QUrl &url)\n{\n    Utility::openBrowser(url);\n}""}, {""func_name"": ""UserModel::openCurrentAccountServer"", ""file_path"": ""src/gui/tray/UserModel.cpp"", ""func_code"": ""Q_INVOKABLE void UserModel::openCurrentAccountServer()\n{\n    if (_currentUserId < 0 || _currentUserId >= _users.size())\n        return;\n\n    QString url = _users[_currentUserId]->server(false);\n    if (!url.startsWith(\""http://\"") && !url.startsWith(\""https://\"")) {\n        url = \""https://\"" + _users[_currentUserId]->server(false);\n    }\n\n    QDesktopServices::openUrl(url);\n}""}, {""func_name"": ""ownCloudGui::slotOpenOwnCloud"", ""file_path"": ""src/gui/owncloudgui.cpp"", ""func_code"": ""void ownCloudGui::slotOpenOwnCloud()\n{\n    if (auto account = qvariant_cast<AccountPtr>(sender()->property(propertyAccountC))) {\n        Utility::openBrowser(account->url());\n    }\n}""}, {""func_name"": ""AccountSettings::slotOpenOC"", ""file_path"": ""src/gui/accountsettings.cpp"", ""func_code"": ""void AccountSettings::slotOpenOC()\n{\n    if (_OCUrl.isValid()) {\n        Utility::openBrowser(_OCUrl);\n    }\n}""}]","{""function"": 1}","[{""source"": ""func_info(file:UserModel.cpp, func:openCurrentAccountServer)"", ""result"": [{""code"": ""void UserModel::openCurrentAccountServer()\n{\n    if (_currentUserId < 0 || _currentUserId >= _users.size())\n        return;\n\n    QString url = _users[_currentUserId]->server(false);\n    if (!(url.contains(\""http://\"") || url.contains(\""https://\""))) {\n        url = \""https://\"" + _users[_currentUserId]->server(false);\n    }\n    QDesktopServices::openUrl(QUrl(url));\n}"", ""start_line"": 728, ""end_line"": 738, ""full_name"": ""OCC.UserModel.openCurrentAccountServer:void()"", ""file_path"": ""src/gui/tray/UserModel.cpp""}]}]",src/gui/tray/UserModel.cpp:732-734: UserModel::openCurrentAccountServer constructs a URL by prepending 'https://' if 'http://' or 'https://' is not found in the string. It then uses QDesktopServices::openUrl without validating the parsed scheme. This check is insufficient to prevent schemes like 'javascript:' or 'data:' from being executed.,0.95,./github/other_context/CVE-2021-22879
48,CVE-2021-45085,CWE-79,c_cpp,"XSS can occur in GNOME Web (aka Epiphany) before 40.4 and 41.x before 41.1 via an about: page, as demonstrated by ephy-about:overview when a user visits an XSS payload page often enough to place that page on the Most Visited list.",https://github.com/GNOME/epiphany/commit/359e465148254278337537b4f0ef4fd16df72bb4,"about-handler: properly encode page title/URL in about:overview\n\nOtherwise, web pages can execute code in about:overview via a malicious\npage title. It might be possible to do the same via the URL, so better\nencode that too.\n\nFixes #1612\n\nPart-of: <https://gitlab.gnome.org/GNOME/epiphany/-/merge_requests/1045>",1,"[{""func_name"": ""history_service_query_urls_cb"", ""file_path"": ""embed/ephy-about-handler.c"", ""func_code"": ""static void\nhistory_service_query_urls_cb (EphyHistoryService     *history,\n                               gboolean                success,\n                               GList                  *urls,\n                               WebKitURISchemeRequest *request)\n{\n  EphySnapshotService *snapshot_service;\n  EphyEmbedShell *shell;\n  GString *data_str;\n  gsize data_length;\n  char *lang;\n  GList *l;\n  guint list_length;\n\n  snapshot_service = ephy_snapshot_service_get_default ();\n  shell = ephy_embed_shell_get_default ();\n\n  data_str = g_string_new (NULL);\n\n  lang = g_strdup (pango_language_to_string (gtk_get_default_language ()));\n  g_strdelimit (lang, \""_-@\"", '\\0');\n\n  g_string_append_printf (data_str,\n                          \""<html xml:lang=\\\""%s\\\"" lang=\\\""%s\\\"" dir=\\\""%s\\\"">\\n\""\n                          \""<head>\\n\""\n                          \""  <title>%s</title>\\n\""\n                          \""  <meta http-equiv=\\\""content-type\\\"" content=\\\""text/html; charset=utf-8\\\"" />\\n\""\n                          \""  <meta name=\\\""viewport\\\"" content=\\\""width=device-width\\\"">\""\n                          \""  <link href=\\\""\""EPHY_PAGE_TEMPLATE_ABOUT_CSS \""\\\"" rel=\\\""stylesheet\\\"" type=\\\""text/css\\\"">\\n\""\n                          \""  <script> </script>\\n\""\n                          \""</head>\\n\""\n                          \""<body>\\n\"",\n                          lang, lang,\n                          ((gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL) ? \""rtl\"" : \""ltr\""),\n                          _(NEW_TAB_PAGE_TITLE));\n  g_free (lang);\n\n  list_length = g_list_length (urls);\n\n  if (list_length == 0 || !success) {\n    GtkIconInfo *icon_info;\n    g_autofree gchar *icon = g_strconcat (APPLICATION_ID, \""-symbolic\"", NULL);\n\n    icon_info = gtk_icon_theme_lookup_icon (gtk_icon_theme_get_default (),\n                                            icon,\n                                            128,\n                                            0);\n    g_string_append_printf (data_str,\n                            \""  <div id=\\\""overview\\\"" class=\\\""overview-empty\\\"">\\n\""\n                            \""    <img src=\\\""file://%s\\\""/>\\n\""\n                            \""    <div><h1>%s</h1></div>\\n\""\n                            \""    <div><p>%s</p></div>\\n\""\n                            \""  </div>\\n\""\n                            \""</body></html>\\n\"",\n                            icon_info ? gtk_icon_info_get_filename (icon_info) : \""\"",\n                            /* Displayed when opening the browser for the first time. */\n                            _(\""Welcome to Web\""), _(\""Start browsing and your most-visited sites will appear here.\""));\n    if (icon_info)\n      g_object_unref (icon_info);\n    goto out;\n  }\n\n  g_string_append (data_str,\n                   \""<div id=\\\""overview\\\"">\\n\"");\n\n  g_string_append (data_str,\n                   \""<div id=\\\""most-visited-grid\\\"">\\n\"");\n\n  for (l = urls; l; l = g_list_next (l)) {\n    EphyHistoryURL *url = (EphyHistoryURL *)l->data;\n    const char *snapshot;\n    g_autofree char *thumbnail_style = NULL;\n    g_autofree char *markup = NULL;\n\n    snapshot = ephy_snapshot_service_lookup_cached_snapshot_path (snapshot_service, url->url);\n    if (snapshot)\n      thumbnail_style = g_strdup_printf (\"" style=\\\""background: url(file://%s) no-repeat; background-size: 100%%;\\\""\"", snapshot);\n    else\n      ephy_embed_shell_schedule_thumbnail_update (shell, url);\n\n    markup = g_markup_escape_text (url->title, -1);\n    g_string_append_printf (data_str,\n                            \""<a class=\\\""overview-item\\\"" title=\\\""%s\\\"" href=\\\""%s\\\"">\""\n                            \""  <div class=\\\""overview-close-button\\\"" title=\\\""%s\\\""></div>\""\n                            \""  <span class=\\\""overview-thumbnail\\\""%s></span>\""\n                            \""  <span class=\\\""overview-title\\\"">%s</span>\""\n                            \""</a>\"",\n                            markup, url->url, _(\""Remove from overview\""),\n                            thumbnail_style ? thumbnail_style : \""\"", url->title);\n  }\n\n  data_str = g_string_append (data_str,\n                              \""  </div>\\n\""\n                              \""  </div>\\n\""\n                              \""</body></html>\\n\"");\n\nout:\n  data_length = data_str->len;\n  ephy_about_handler_finish_request (request, g_string_free (data_str, FALSE), data_length);\n  g_object_unref (request);\n}"", ""target"": 0}]","[{""func_name"": ""history_service_query_urls_cb"", ""file_path"": ""embed/ephy-about-handler.c"", ""func_code"": ""static void\nhistory_service_query_urls_cb (EphyHistoryService     *history,\n                               gboolean                success,\n                               GList                  *urls,\n                               WebKitURISchemeRequest *request)\n{\n  EphySnapshotService *snapshot_service;\n  EphyEmbedShell *shell;\n  GString *data_str;\n  gsize data_length;\n  char *lang;\n  GList *l;\n  guint list_length;\n\n  snapshot_service = ephy_snapshot_service_get_default ();\n  shell = ephy_embed_shell_get_default ();\n\n  data_str = g_string_new (NULL);\n\n  lang = g_strdup (pango_language_to_string (gtk_get_default_language ()));\n  g_strdelimit (lang, \""_-@\"", '\\0');\n\n  g_string_append_printf (data_str,\n                          \""<html xml:lang=\\\""%s\\\"" lang=\\\""%s\\\"" dir=\\\""%s\\\"">\\n\""\n                          \""<head>\\n\""\n                          \""  <title>%s</title>\\n\""\n                          \""  <meta http-equiv=\\\""content-type\\\"" content=\\\""text/html; charset=utf-8\\\"" />\\n\""\n                          \""  <meta name=\\\""viewport\\\"" content=\\\""width=device-width\\\"">\""\n                          \""  <link href=\\\""\""EPHY_PAGE_TEMPLATE_ABOUT_CSS \""\\\"" rel=\\\""stylesheet\\\"" type=\\\""text/css\\\"">\\n\""\n                          \""  <script> </script>\\n\""\n                          \""</head>\\n\""\n                          \""<body>\\n\"",\n                          lang, lang,\n                          ((gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL) ? \""rtl\"" : \""ltr\""),\n                          _(NEW_TAB_PAGE_TITLE));\n  g_free (lang);\n\n  list_length = g_list_length (urls);\n\n  if (list_length == 0 || !success) {\n    GtkIconInfo *icon_info;\n    g_autofree gchar *icon = g_strconcat (APPLICATION_ID, \""-symbolic\"", NULL);\n\n    icon_info = gtk_icon_theme_lookup_icon (gtk_icon_theme_get_default (),\n                                            icon,\n                                            128,\n                                            0);\n    g_string_append_printf (data_str,\n                            \""  <div id=\\\""overview\\\"" class=\\\""overview-empty\\\"">\\n\""\n                            \""    <img src=\\\""file://%s\\\""/>\\n\""\n                            \""    <div><h1>%s</h1></div>\\n\""\n                            \""    <div><p>%s</p></div>\\n\""\n                            \""  </div>\\n\""\n                            \""</body></html>\\n\"",\n                            icon_info ? gtk_icon_info_get_filename (icon_info) : \""\"",\n                            /* Displayed when opening the browser for the first time. */\n                            _(\""Welcome to Web\""), _(\""Start browsing and your most-visited sites will appear here.\""));\n    if (icon_info)\n      g_object_unref (icon_info);\n    goto out;\n  }\n\n  g_string_append (data_str,\n                   \""<div id=\\\""overview\\\"">\\n\"");\n\n  g_string_append (data_str,\n                   \""<div id=\\\""most-visited-grid\\\"">\\n\"");\n\n  for (l = urls; l; l = g_list_next (l)) {\n    EphyHistoryURL *url = (EphyHistoryURL *)l->data;\n    const char *snapshot;\n    g_autofree char *thumbnail_style = NULL;\n    g_autofree char *encoded_title = NULL;\n    g_autofree char *encoded_url = NULL;\n\n    snapshot = ephy_snapshot_service_lookup_cached_snapshot_path (snapshot_service, url->url);\n    if (snapshot)\n      thumbnail_style = g_strdup_printf (\"" style=\\\""background: url(file://%s) no-repeat; background-size: 100%%;\\\""\"", snapshot);\n    else\n      ephy_embed_shell_schedule_thumbnail_update (shell, url);\n\n    /* Title and URL are controlled by web content and could be malicious. */\n    encoded_title = ephy_encode_for_html_attribute (url->title);\n    encoded_url = ephy_encode_for_html_attribute (url->url);\n    g_string_append_printf (data_str,\n                            \""<a class=\\\""overview-item\\\"" title=\\\""%s\\\"" href=\\\""%s\\\"">\""\n                            \""  <div class=\\\""overview-close-button\\\"" title=\\\""%s\\\""></div>\""\n                            \""  <span class=\\\""overview-thumbnail\\\""%s></span>\""\n                            \""  <span class=\\\""overview-title\\\"">%s</span>\""\n                            \""</a>\"",\n                            encoded_title, encoded_url, _(\""Remove from overview\""),\n                            thumbnail_style ? thumbnail_style : \""\"", encoded_title);\n  }\n\n  data_str = g_string_append (data_str,\n                              \""  </div>\\n\""\n                              \""  </div>\\n\""\n                              \""</body></html>\\n\"");\n\nout:\n  data_length = data_str->len;\n  ephy_about_handler_finish_request (request, g_string_free (data_str, FALSE), data_length);\n  g_object_unref (request);\n}""}]","{""code"": 2, ""function"": 2}","[{""source"": ""code_info(file:ephy-history-url.h, lines:1-50)"", ""result"": ""error code""}, {""source"": ""func_info(func:ephy_encode_for_html_attribute)"", ""result"": [{""code"": ""char *\nephy_encode_for_html_attribute (const char *input)\n{\n  return encode_all_except_alnum (input, \""&#x%02x;\"");\n}"", ""start_line"": 64, ""end_line"": 68, ""full_name"": ""ephy_encode_for_html_attribute"", ""file_path"": ""lib/ephy-output-encoding.c""}]}, {""source"": ""func_info(func:ephy_history_url_new)"", ""result"": [{""code"": ""EphyHistoryURL *\nephy_history_url_new (const char *url,\n                      const char *title,\n                      int         visit_count,\n                      int         typed_count,\n         "", ""start_line"": 135, ""end_line"": 154, ""full_name"": ""ephy_history_url_new"", ""file_path"": ""lib/history/ephy-history-types.c""}]}, {""source"": ""code_info(file:ephy-history-url.c, lines:1-100)"", ""result"": ""error code""}]","The vulnerability arises from unencoded insertion of `url->title` and `url->url` (from `EphyHistoryURL`) into HTML attributes in `history_service_query_urls_cb` (embed/ephy-about-handler.c:430). These values are initialized via `ephy_history_url_new` (lib/history/ephy-history-types.c:135-154) without prior sanitization. The patch introduces `ephy_encode_for_html_attribute` (lib/ephy-output-encoding.c:64-68) to encode these values for HTML attribute contexts, preventing XSS.",1.0,./github/other_context/CVE-2021-45085
49,CVE-2021-45462,CWE-1284,c_cpp,"In Open5GS 2.4.0, a crafted packet from UE can crash SGW-U/UPF.",https://github.com/open5gs/open5gs/commit/a0f2535cb5a29bba6dbbccdb90c74ccd770cc700,A crafted packet from UE can crash SGW-U/UPF,3,"[{""func_name"": ""_gtpv1_u_recv_cb"", ""file_path"": ""src/sgwu/gtp-path.c"", ""func_code"": ""static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    sgwu_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \""ogs_recv() failed\"");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\""[DROP] Invalid GTPU version [%d]\"", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\""[RECV] Echo Request from [%s]\"", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\""[SEND] Echo Response to [%s]\"", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \""ogs_sendto() failed\"");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\"",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\""   QFI [0x%x]\"",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to peer NF */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\""[DROP] Cannot decode GTPU packet\"");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = SGWU_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    sgwu_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\""[DROP] Cannot find FAR by Error-Indication\"");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\""Unknown type [%d]\"", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n        if (report.type.downlink_data_report) {\n            ogs_assert(pdr->sess);\n            ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n            sess = SGWU_SESS(pdr->sess);\n            ogs_assert(sess);\n\n            report.downlink_data.pdr_id = pdr->id;\n            report.downlink_data.qfi = qfi; /* for 5GC */\n\n            ogs_assert(OGS_OK ==\n                sgwu_pfcp_send_session_report_request(sess, &report));\n        }\n    } else {\n        ogs_error(\""[DROP] Invalid GTPU Type [%d]\"", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}"", ""target"": 0}, {""func_name"": ""_gtpv1_u_recv_cb"", ""file_path"": ""src/upf/gtp-path.c"", ""func_code"": ""static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    sgwu_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \""ogs_recv() failed\"");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\""[DROP] Invalid GTPU version [%d]\"", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\""[RECV] Echo Request from [%s]\"", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\""[SEND] Echo Response to [%s]\"", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \""ogs_sendto() failed\"");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\"",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\""   QFI [0x%x]\"",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to peer NF */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\""[DROP] Cannot decode GTPU packet\"");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = SGWU_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    sgwu_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\""[DROP] Cannot find FAR by Error-Indication\"");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\""Unknown type [%d]\"", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n        if (report.type.downlink_data_report) {\n            ogs_assert(pdr->sess);\n            ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n            sess = SGWU_SESS(pdr->sess);\n            ogs_assert(sess);\n\n            report.downlink_data.pdr_id = pdr->id;\n            report.downlink_data.qfi = qfi; /* for 5GC */\n\n            ogs_assert(OGS_OK ==\n                sgwu_pfcp_send_session_report_request(sess, &report));\n        }\n    } else {\n        ogs_error(\""[DROP] Invalid GTPU Type [%d]\"", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}"", ""target"": 0}, {""func_name"": ""_gtpv1_u_recv_cb"", ""file_path"": ""src/smf/gtp-path.c"", ""func_code"": ""static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    sgwu_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \""ogs_recv() failed\"");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\""[DROP] Invalid GTPU version [%d]\"", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\""[RECV] Echo Request from [%s]\"", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\""[SEND] Echo Response to [%s]\"", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \""ogs_sendto() failed\"");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\"",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\""   QFI [0x%x]\"",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to peer NF */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\""[DROP] Cannot decode GTPU packet\"");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = SGWU_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    sgwu_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\""[DROP] Cannot find FAR by Error-Indication\"");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\""Unknown type [%d]\"", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n        if (report.type.downlink_data_report) {\n            ogs_assert(pdr->sess);\n            ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n            sess = SGWU_SESS(pdr->sess);\n            ogs_assert(sess);\n\n            report.downlink_data.pdr_id = pdr->id;\n            report.downlink_data.qfi = qfi; /* for 5GC */\n\n            ogs_assert(OGS_OK ==\n                sgwu_pfcp_send_session_report_request(sess, &report));\n        }\n    } else {\n        ogs_error(\""[DROP] Invalid GTPU Type [%d]\"", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}"", ""target"": 0}]","[{""func_name"": ""_gtpv1_u_recv_cb"", ""file_path"": ""src/sgwu/gtp-path.c"", ""func_code"": ""static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    sgwu_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \""ogs_recv() failed\"");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\""[DROP] Invalid GTPU version [%d]\"", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\""[RECV] Echo Request from [%s]\"", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\""[SEND] Echo Response to [%s]\"", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \""ogs_sendto() failed\"");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\"",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\""   QFI [0x%x]\"",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to peer NF */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\""[DROP] Cannot decode GTPU packet\"");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    if (gtp_h->type != OGS_GTPU_MSGTYPE_END_MARKER &&\n        pkbuf->len <= len) {\n        ogs_error(\""[DROP] Small GTPU packet(type:%d len:%d)\"", gtp_h->type, len);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = SGWU_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    sgwu_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\""[DROP] Cannot find FAR by Error-Indication\"");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\""Unknown type [%d]\"", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n        if (report.type.downlink_data_report) {\n            ogs_assert(pdr->sess);\n            ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n            sess = SGWU_SESS(pdr->sess);\n            ogs_assert(sess);\n\n            report.downlink_data.pdr_id = pdr->id;\n            report.downlink_data.qfi = qfi; /* for 5GC */\n\n            ogs_assert(OGS_OK ==\n                sgwu_pfcp_send_session_report_request(sess, &report));\n        }\n    } else {\n        ogs_error(\""[DROP] Invalid GTPU Type [%d]\"", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}""}, {""func_name"": ""_gtpv1_u_recv_cb"", ""file_path"": ""src/upf/gtp-path.c"", ""func_code"": ""static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    sgwu_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \""ogs_recv() failed\"");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\""[DROP] Invalid GTPU version [%d]\"", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\""[RECV] Echo Request from [%s]\"", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\""[SEND] Echo Response to [%s]\"", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \""ogs_sendto() failed\"");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\"",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\""   QFI [0x%x]\"",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to peer NF */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\""[DROP] Cannot decode GTPU packet\"");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    if (gtp_h->type != OGS_GTPU_MSGTYPE_END_MARKER &&\n        pkbuf->len <= len) {\n        ogs_error(\""[DROP] Small GTPU packet(type:%d len:%d)\"", gtp_h->type, len);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = SGWU_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    sgwu_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\""[DROP] Cannot find FAR by Error-Indication\"");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\""Unknown type [%d]\"", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n        if (report.type.downlink_data_report) {\n            ogs_assert(pdr->sess);\n            ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n            sess = SGWU_SESS(pdr->sess);\n            ogs_assert(sess);\n\n            report.downlink_data.pdr_id = pdr->id;\n            report.downlink_data.qfi = qfi; /* for 5GC */\n\n            ogs_assert(OGS_OK ==\n                sgwu_pfcp_send_session_report_request(sess, &report));\n        }\n    } else {\n        ogs_error(\""[DROP] Invalid GTPU Type [%d]\"", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}""}, {""func_name"": ""_gtpv1_u_recv_cb"", ""file_path"": ""src/smf/gtp-path.c"", ""func_code"": ""static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    sgwu_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \""ogs_recv() failed\"");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\""[DROP] Invalid GTPU version [%d]\"", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\""[RECV] Echo Request from [%s]\"", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\""[SEND] Echo Response to [%s]\"", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \""ogs_sendto() failed\"");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\"",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\""   QFI [0x%x]\"",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to peer NF */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\""[DROP] Cannot decode GTPU packet\"");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    if (gtp_h->type != OGS_GTPU_MSGTYPE_END_MARKER &&\n        pkbuf->len <= len) {\n        ogs_error(\""[DROP] Small GTPU packet(type:%d len:%d)\"", gtp_h->type, len);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = SGWU_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    sgwu_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\""[DROP] Cannot find FAR by Error-Indication\"");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\""Unknown type [%d]\"", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n        if (report.type.downlink_data_report) {\n            ogs_assert(pdr->sess);\n            ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n            sess = SGWU_SESS(pdr->sess);\n            ogs_assert(sess);\n\n            report.downlink_data.pdr_id = pdr->id;\n            report.downlink_data.qfi = qfi; /* for 5GC */\n\n            ogs_assert(OGS_OK ==\n                sgwu_pfcp_send_session_report_request(sess, &report));\n        }\n    } else {\n        ogs_error(\""[DROP] Invalid GTPU Type [%d]\"", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}""}]","{""code"": 3, ""function"": 6}","[{""source"": ""code_info(file:gtp-path.c, lines:110-130)"", ""result"": ""                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\""   QFI [0x%x]\"",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to peer NF */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\""[DROP] Cannot decode GTPU packet\"");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n""}, {""source"": ""code_info(file:gtp-path.c, lines:110-130)"", ""result"": ""            ogs_assert(replybuf);\n            ogs_pkbuf_reserve(replybuf, OGS_TUN_MAX_HEADROOM);\n            ogs_pkbuf_put(replybuf, OGS_MAX_PKT_LEN-OGS_TUN_MAX_HEADROOM);\n            size = nd_reply(replybuf->data, recvbuf->data, recvbuf->len,\n                proxy_mac_addr);\n            ogs_pkbuf_trim(replybuf, size);\n            ogs_info(\""[SEND] reply to ND solicit: %u\"", size);\n        }\n        if (replybuf) {\n            if (ogs_tun_write(fd, replybuf) != OGS_OK)\n                ogs_warn(\""ogs_tun_write() for reply failed\"");\n            goto cleanup;\n        }\n        if (eth_type != ETHERTYPE_IP && eth_type != ETHERTYPE_IPV6) {\n            ogs_error(\""[DROP] Invalid eth_type [%x]]\"", eth_type);\n            ogs_log_hexdump(OGS_LOG_ERROR, recvbuf->data, recvbuf->len);\n            goto cleanup;\n        }\n        ogs_pkbuf_pull(recvbuf, ETHER_HDR_LEN);\n    }\n\n    sess = upf_sess_find_by_ue_ip_address(recvbuf);\n""}, {""source"": ""code_info(file:gtp-path.c, lines:110-130)"", ""result"": ""    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \""ogs_recv() failed\"");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\""[DROP] Invalid GTPU version [%d]\"", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n""}, {""source"": ""func_info(func:ogs_gtpu_header_len)"", ""result"": [{""code"": ""int ogs_gtpu_header_len(ogs_pkbuf_t *pkbuf)\n{\n    ogs_gtp_header_t *gtp_h = NULL;\n    uint8_t *ext_h = NULL;\n    uint16_t len = 0;\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->data);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n\n    len = OGS_GTPV1U_HEADER_LEN;\n    if (pkbuf->len < len) return -1;\n\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n\n        len += OGS_GTPV1U_EXTENSION_HEADER_LEN;\n        if (pkbuf->len < len) return -1;\n\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         *\n         * If no such Header follows,\n         * then the value of the Next Extension Header Type shall be 0. */\n        while (*(ext_h = (((uint8_t *)gtp_h) + len - 1))) {\n        /*\n         * The length of the Extension header shall be defined\n         * in a variable length of 4 octets, i.e. m+1 = n*4 octets,\n         * where n is a positive integer.\n         */\n            len += (*(++ext_h)) * 4;\n            if (pkbuf->len < len) return -1;\n        }\n\n    } else if (gtp_h->flags & (OGS_GTPU_FLAGS_S|OGS_GTPU_FLAGS_PN)) {\n        /*\n         * If and only if one or more of these three flags are set,\n         * the fields Sequence Number, N-PDU and Extension Header\n         * shall be present. The sender shall set all the bits of\n         * the unused fields to zero. The receiver shall not evaluate\n         * the unused fields.\n         * For example, if only the E flag is set to 1, then\n         * the N-PDU Number and Sequence Number fields shall also be present,\n         * but will not have meaningful values and shall not be evaluated.\n         */\n        len += 4;\n    }\n\n    if (pkbuf->len < len) return -1;\n\n    return len;\n}\n"", ""start_line"": 22, ""end_line"": 74, ""full_name"": ""ogs_gtpu_header_len"", ""file_path"": ""lib/gtp/util.c""}]}, {""source"": ""func_info(func:ogs_gtpu_header_len)"", ""result"": [{""code"": ""int ogs_gtpu_header_len(ogs_pkbuf_t *pkbuf)\n{\n    ogs_gtp_header_t *gtp_h = NULL;\n    uint8_t *ext_h = NULL;\n    uint16_t len = 0;\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->data);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n\n    len = OGS_GTPV1U_HEADER_LEN;\n    if (pkbuf->len < len) return -1;\n\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n\n        len += OGS_GTPV1U_EXTENSION_HEADER_LEN;\n        if (pkbuf->len < len) return -1;\n\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         *\n         * If no such Header follows,\n         * then the value of the Next Extension Header Type shall be 0. */\n        while (*(ext_h = (((uint8_t *)gtp_h) + len - 1))) {\n        /*\n         * The length of the Extension header shall be defined\n         * in a variable length of 4 octets, i.e. m+1 = n*4 octets,\n         * where n is a positive integer.\n         */\n            len += (*(++ext_h)) * 4;\n            if (pkbuf->len < len) return -1;\n        }\n\n    } else if (gtp_h->flags & (OGS_GTPU_FLAGS_S|OGS_GTPU_FLAGS_PN)) {\n        /*\n         * If and only if one or more of these three flags are set,\n         * the fields Sequence Number, N-PDU and Extension Header\n         * shall be present. The sender shall set all the bits of\n         * the unused fields to zero. The receiver shall not evaluate\n         * the unused fields.\n         * For example, if only the E flag is set to 1, then\n         * the N-PDU Number and Sequence Number fields shall also be present,\n         * but will not have meaningful values and shall not be evaluated.\n         */\n        len += 4;\n    }\n\n    if (pkbuf->len < len) return -1;\n\n    return len;\n}\n"", ""start_line"": 22, ""end_line"": 74, ""full_name"": ""ogs_gtpu_header_len"", ""file_path"": ""lib/gtp/util.c""}]}, {""source"": ""func_info(func:ogs_gtpu_header_len)"", ""result"": [{""code"": ""int ogs_gtpu_header_len(ogs_pkbuf_t *pkbuf)\n{\n    ogs_gtp_header_t *gtp_h = NULL;\n    uint8_t *ext_h = NULL;\n    uint16_t len = 0;\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->data);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n\n    len = OGS_GTPV1U_HEADER_LEN;\n    if (pkbuf->len < len) return -1;\n\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n\n        len += OGS_GTPV1U_EXTENSION_HEADER_LEN;\n        if (pkbuf->len < len) return -1;\n\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         *\n         * If no such Header follows,\n         * then the value of the Next Extension Header Type shall be 0. */\n        while (*(ext_h = (((uint8_t *)gtp_h) + len - 1))) {\n        /*\n         * The length of the Extension header shall be defined\n         * in a variable length of 4 octets, i.e. m+1 = n*4 octets,\n         * where n is a positive integer.\n         */\n            len += (*(++ext_h)) * 4;\n            if (pkbuf->len < len) return -1;\n        }\n\n    } else if (gtp_h->flags & (OGS_GTPU_FLAGS_S|OGS_GTPU_FLAGS_PN)) {\n        /*\n         * If and only if one or more of these three flags are set,\n         * the fields Sequence Number, N-PDU and Extension Header\n         * shall be present. The sender shall set all the bits of\n         * the unused fields to zero. The receiver shall not evaluate\n         * the unused fields.\n         * For example, if only the E flag is set to 1, then\n         * the N-PDU Number and Sequence Number fields shall also be present,\n         * but will not have meaningful values and shall not be evaluated.\n         */\n        len += 4;\n    }\n\n    if (pkbuf->len < len) return -1;\n\n    return len;\n}\n"", ""start_line"": 22, ""end_line"": 74, ""full_name"": ""ogs_gtpu_header_len"", ""file_path"": ""lib/gtp/util.c""}]}, {""source"": ""func_info(file:gtp-path.c, func:_gtpv1_u_recv_cb)"", ""result"": [{""code"": ""static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    sgwu_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \""ogs_recv() failed\"");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\""[DROP] Invalid GTPU version [%d]\"", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\""[RECV] Echo Request from [%s]\"", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\""[SEND] Echo Response to [%s]\"", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \""ogs_sendto() failed\"");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\"",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\""   QFI [0x%x]\"",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to peer NF */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\""[DROP] Cannot decode GTPU packet\"");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = SGWU_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    sgwu_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\""[DROP] Cannot find FAR by Error-Indication\"");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\""Unknown type [%d]\"", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n        if (report.type.downlink_data_report) {\n            ogs_assert(pdr->sess);\n            ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n            sess = SGWU_SESS(pdr->sess);\n            ogs_assert(sess);\n\n            report.downlink_data.pdr_id = pdr->id;\n            report.downlink_data.qfi = qfi; /* for 5GC */\n\n            ogs_assert(OGS_OK ==\n                sgwu_pfcp_send_session_report_request(sess, &report));\n        }\n    } else {\n        ogs_error(\""[DROP] Invalid GTPU Type [%d]\"", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}\n"", ""start_line"": 27, ""end_line"": 232, ""full_name"": ""_gtpv1_u_recv_cb"", ""file_path"": ""src/sgwu/gtp-path.c""}]}, {""source"": ""func_info(file:gtp-path.c, func:_gtpv1_u_recv_cb)"", ""result"": [{""code"": ""static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    upf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n    ogs_pfcp_user_plane_report_t report;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_reserve(pkbuf, OGS_TUN_MAX_HEADROOM);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN-OGS_TUN_MAX_HEADROOM);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \""ogs_recv() failed\"");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\""[DROP] Invalid GTPU version [%d]\"", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\""[RECV] Echo Request from [%s]\"", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\""[SEND] Echo Response to [%s]\"", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \""ogs_sendto() failed\"");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\"",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\""   QFI [0x%x]\"",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to TUN interface */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\""[DROP] Cannot decode GTPU packet\"");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {\n        /* Nothing */\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_error_indication(pkbuf);\n        if (far) {\n            ogs_assert(true ==\n                ogs_pfcp_up_handle_error_indication(far, &report));\n\n            if (report.type.error_indication_report) {\n                ogs_assert(far->sess);\n                sess = UPF_SESS(far->sess);\n                ogs_assert(sess);\n\n                ogs_assert(OGS_OK ==\n                    upf_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else {\n            ogs_error(\""[DROP] Cannot find FAR by Error-Indication\"");\n            ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        }\n\n    } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        struct ip *ip_h = NULL;\n        ogs_pfcp_object_t *pfcp_object = NULL;\n        ogs_pfcp_sess_t *pfcp_sess = NULL;\n        ogs_pfcp_pdr_t *pdr = NULL;\n        ogs_pfcp_far_t *far = NULL;\n\n        ogs_pfcp_subnet_t *subnet = NULL;\n        ogs_pfcp_dev_t *dev = NULL;\n\n        ip_h = (struct ip *)pkbuf->data;\n        ogs_assert(ip_h);\n\n        pfcp_object = ogs_pfcp_object_find_by_teid(teid);\n        if (!pfcp_object) {\n            /* TODO : Send Error Indication */\n            goto cleanup;\n        }\n\n        switch(pfcp_object->type) {\n        case OGS_PFCP_OBJ_PDR_TYPE:\n            pdr = (ogs_pfcp_pdr_t *)pfcp_object;\n            ogs_assert(pdr);\n            break;\n        case OGS_PFCP_OBJ_SESS_TYPE:\n            pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;\n            ogs_assert(pfcp_sess);\n\n            ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {\n\n                /* Check if Source Interface */\n                if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&\n                    pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)\n                    continue;\n\n                /* Check if TEID */\n                if (teid != pdr->f_teid.teid)\n                    continue;\n\n                /* Check if QFI */\n                if (qfi && pdr->qfi != qfi)\n                    continue;\n\n                /* Check if Rule List in PDR */\n                if (ogs_list_first(&pdr->rule_list) &&\n                    ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)\n                    continue;\n\n                break;\n            }\n\n            if (!pdr) {\n                /* TODO : Send Error Indication */\n                goto cleanup;\n            }\n\n            break;\n        default:\n            ogs_fatal(\""Unknown type [%d]\"", pfcp_object->type);\n            ogs_assert_if_reached();\n        }\n\n        ogs_assert(pdr);\n        ogs_assert(pdr->sess);\n        ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);\n\n        sess = UPF_SESS(pdr->sess);\n        ogs_assert(sess);\n\n        far = pdr->far;\n        ogs_assert(far);\n\n        if (far->dst_if == OGS_PFCP_INTERFACE_CORE) {\n            uint16_t eth_type = 0;\n\n            if (ip_h->ip_v == 4 && sess->ipv4) {\n                subnet = sess->ipv4->subnet;\n                eth_type = ETHERTYPE_IP;\n            } else if (ip_h->ip_v == 6 && sess->ipv6) {\n                subnet = sess->ipv6->subnet;\n                eth_type = ETHERTYPE_IPV6;\n            }\n\n            if (!subnet) {\n#if 0 /* It's redundant log message */\n                ogs_error(\""[DROP] Cannot find subnet V:%d, IPv4:%p, IPv6:%p\"",\n                        ip_h->ip_v, sess->ipv4, sess->ipv6);\n                ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n#endif\n                goto cleanup;\n            }\n\n            dev = subnet->dev;\n            ogs_assert(dev);\n\n            if (dev->is_tap) {\n                ogs_assert(eth_type);\n                eth_type = htobe16(eth_type);\n                ogs_pkbuf_push(pkbuf, sizeof(eth_type));\n                memcpy(pkbuf->data, &eth_type, sizeof(eth_type));\n                ogs_pkbuf_push(pkbuf, ETHER_ADDR_LEN);\n                memcpy(pkbuf->data, proxy_mac_addr, ETHER_ADDR_LEN);\n                ogs_pkbuf_push(pkbuf, ETHER_ADDR_LEN);\n                memcpy(pkbuf->data, dev->mac_addr, ETHER_ADDR_LEN);\n            }\n\n            /* TODO: if destined to another UE, hairpin back out. */\n            if (ogs_tun_write(dev->fd, pkbuf) != OGS_OK)\n                ogs_warn(\""ogs_tun_write() failed\"");\n\n        } else if (far->dst_if == OGS_PFCP_INTERFACE_ACCESS) {\n            ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n            if (report.type.downlink_data_report) {\n                ogs_error(\""Indirect Data Fowarding Buffered\"");\n\n                report.downlink_data.pdr_id = pdr->id;\n                if (pdr->qer && pdr->qer->qfi)\n                    report.downlink_data.qfi = pdr->qer->qfi; /* for 5GC */\n\n                ogs_assert(OGS_OK ==\n                    upf_pfcp_send_session_report_request(sess, &report));\n            }\n\n        } else if (far->dst_if == OGS_PFCP_INTERFACE_CP_FUNCTION) {\n\n            if (!far->gnode) {\n                ogs_error(\""No Outer Header Creation in FAR\"");\n                goto cleanup;\n            }\n\n            if ((far->apply_action & OGS_PFCP_APPLY_ACTION_FORW) == 0) {\n                ogs_error(\""Not supported Apply Action [0x%x]\"",\n                            far->apply_action);\n                goto cleanup;\n            }\n\n            ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));\n\n            ogs_assert(report.type.downlink_data_report == 0);\n\n        } else {\n            ogs_fatal(\""Not implemented : FAR-DST_IF[%d]\"", far->dst_if);\n            ogs_assert_if_reached();\n        }\n    } else {\n        ogs_error(\""[DROP] Invalid GTPU Type [%d]\"", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}\n"", ""start_line"": 206, ""end_line"": 486, ""full_name"": ""_gtpv1_u_recv_cb<duplicate>1"", ""file_path"": ""src/upf/gtp-path.c""}]}, {""source"": ""func_info(file:gtp-path.c, func:_gtpv1_u_recv_cb)"", ""result"": [{""code"": ""static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int len;\n    ssize_t size;\n    char buf[OGS_ADDRSTRLEN];\n\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n\n    ogs_gtp_header_t *gtp_h = NULL;\n\n    uint32_t teid;\n    uint8_t qfi;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_PKT_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \""ogs_recv() failed\"");\n        goto cleanup;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    ogs_assert(pkbuf);\n    ogs_assert(pkbuf->len);\n\n    gtp_h = (ogs_gtp_header_t *)pkbuf->data;\n    if (gtp_h->version != OGS_GTP_VERSION_1) {\n        ogs_error(\""[DROP] Invalid GTPU version [%d]\"", gtp_h->version);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {\n        ogs_pkbuf_t *echo_rsp;\n\n        ogs_debug(\""[RECV] Echo Request from [%s]\"", OGS_ADDR(&from, buf));\n        echo_rsp = ogs_gtp_handle_echo_req(pkbuf);\n        ogs_expect(echo_rsp);\n        if (echo_rsp) {\n            ssize_t sent;\n\n            /* Echo reply */\n            ogs_debug(\""[SEND] Echo Response to [%s]\"", OGS_ADDR(&from, buf));\n\n            sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);\n            if (sent < 0 || sent != echo_rsp->len) {\n                ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                        \""ogs_sendto() failed\"");\n            }\n            ogs_pkbuf_free(echo_rsp);\n        }\n        goto cleanup;\n    }\n\n    teid = be32toh(gtp_h->teid);\n\n    ogs_debug(\""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\"",\n            gtp_h->type, OGS_ADDR(&from, buf), teid);\n\n    qfi = 0;\n    if (gtp_h->flags & OGS_GTPU_FLAGS_E) {\n        /*\n         * TS29.281\n         * 5.2.1 General format of the GTP-U Extension Header\n         * Figure 5.2.1-3: Definition of Extension Header Type\n         *\n         * Note 4 : For a GTP-PDU with several Extension Headers, the PDU\n         *          Session Container should be the first Extension Header\n         */\n        ogs_gtp_extension_header_t *extension_header =\n            (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);\n        ogs_assert(extension_header);\n        if (extension_header->type ==\n                OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {\n            if (extension_header->pdu_type ==\n                OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {\n                    ogs_debug(\""   QFI [0x%x]\"",\n                            extension_header->qos_flow_identifier);\n                    qfi = extension_header->qos_flow_identifier;\n            }\n        }\n    }\n\n    /* Remove GTP header and send packets to TUN interface */\n    len = ogs_gtpu_header_len(pkbuf);\n    if (len < 0) {\n        ogs_error(\""[DROP] Cannot decode GTPU packet\"");\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n        goto cleanup;\n    }\n    ogs_assert(ogs_pkbuf_pull(pkbuf, len));\n\n    if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {\n        smf_sess_t *sess = NULL;\n        ogs_pfcp_far_t *far = NULL;\n\n        far = ogs_pfcp_far_find_by_teid(teid);\n        if (!far) {\n            ogs_error(\""No FAR for TEID [%d]\"", teid);\n            goto cleanup;\n        }\n\n        if (far->dst_if != OGS_PFCP_INTERFACE_CP_FUNCTION) {\n            ogs_error(\""Invalid Destination Interface [%d]\"", far->dst_if);\n            goto cleanup;\n        }\n\n        if (qfi) {\n            ogs_error(\""QFI[%d] Found\"", qfi);\n            goto cleanup;\n        }\n\n        ogs_assert(far->sess);\n        sess = SMF_SESS(far->sess);\n        ogs_assert(sess);\n\n        if (sess->ipv6 && check_if_router_solicit(pkbuf) == true) {\n            struct ip6_hdr *ip6_h = (struct ip6_hdr *)pkbuf->data;\n            ogs_assert(ip6_h);\n            send_router_advertisement(sess, ip6_h->ip6_src.s6_addr);\n        }\n    } else {\n        ogs_error(\""[DROP] Invalid GTPU Type [%d]\"", gtp_h->type);\n        ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);\n    }\n\ncleanup:\n    ogs_pkbuf_free(pkbuf);\n}\n"", ""start_line"": 92, ""end_line"": 227, ""full_name"": ""_gtpv1_u_recv_cb<duplicate>0"", ""file_path"": ""src/smf/gtp-path.c""}]}]","src/sgwu/gtp-path.c:125-131: Missing validation of pkbuf->len against required payload length after ogs_pkbuf_pull. The crash occurs when a crafted packet with pkbuf->len == len (header-only) bypasses checks, leading to ogs_pkbuf_pull(pkbuf, len) which exhausts the buffer. Subsequent processing (e.g., struct ip *ip_h = (struct ip *)pkbuf->data) accesses invalid memory. ogs_gtpu_header_len(lib/gtp/util.c:22-74) validates header length but not payload. The patch adds a check to drop such packets.",0.95,./github/other_context/CVE-2021-45462
50,CVE-2022-26128,"CWE-119, CWE-1284",c_cpp,A buffer overflow vulnerability exists in FRRouting through 8.1.0 due to a wrong check on the input packet length in the babel_packet_examin function in babeld/message.c.,https://github.com/FRRouting/frr/commit/c3793352a8d76d2eee1edc38a9a16c1c8a6573f4,"babeld: fix #10502 #10503 by repairing the checks on length\n\nThis patch repairs the checking conditions on length in four functions:\nbabel_packet_examin, parse_hello_subtlv, parse_ihu_subtlv, and parse_update_subtlv\n\nSigned-off-by: qingkaishi <qingkaishi@gmail.com>",4,"[{""func_name"": ""parse_ihu_subtlv"", ""file_path"": ""babeld/message.c"", ""func_code"": ""static int\nparse_ihu_subtlv(const unsigned char *a, int alen,\n                 unsigned int *hello_send_us,\n                 unsigned int *hello_rtt_receive_time)\n{\n    int type, len, i = 0, ret = 0;\n\n    while(i < alen) {\n        type = a[0];\n        if(type == SUBTLV_PAD1) {\n            i++;\n            continue;\n        }\n\n        if(i + 1 > alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \""Received truncated sub-TLV on IHU message.\"");\n            return -1;\n        }\n        len = a[i + 1];\n        if(i + len > alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \""Received truncated sub-TLV on IHU message.\"");\n            return -1;\n        }\n\n        if(type == SUBTLV_PADN) {\n            /* Nothing to do. */\n        } else if(type == SUBTLV_TIMESTAMP) {\n            if(len >= 8) {\n                DO_NTOHL(*hello_send_us, a + i + 2);\n                DO_NTOHL(*hello_rtt_receive_time, a + i + 6);\n                ret = 1;\n            }\n            else {\n                flog_err(EC_BABEL_PACKET,\n\t\t\t  \""Received incorrect RTT sub-TLV on IHU message.\"");\n            }\n        } else {\n            debugf(BABEL_DEBUG_COMMON,\n                   \""Received unknown IHU sub-TLV type %d.\"", type);\n        }\n\n        i += len + 2;\n    }\n    return ret;\n}"", ""target"": 0}, {""func_name"": ""parse_update_subtlv"", ""file_path"": ""babeld/message.c"", ""func_code"": ""static void\nparse_update_subtlv(const unsigned char *a, int alen,\n                    unsigned char *channels)\n{\n    int type, len, i = 0;\n\n    while(i < alen) {\n        type = a[i];\n        if(type == SUBTLV_PAD1) {\n            i++;\n            continue;\n        }\n\n        if(i + 1 > alen) {\n            flog_err(EC_BABEL_PACKET, \""Received truncated attributes.\"");\n            return;\n        }\n        len = a[i + 1];\n        if(i + len > alen) {\n            flog_err(EC_BABEL_PACKET, \""Received truncated attributes.\"");\n            return;\n        }\n\n        if(type == SUBTLV_PADN) {\n            /* Nothing. */\n        } else if(type == SUBTLV_DIVERSITY) {\n            if(len > DIVERSITY_HOPS) {\n                flog_err(EC_BABEL_PACKET,\n\t\t\t  \""Received overlong channel information (%d > %d).n\"",\n                          len, DIVERSITY_HOPS);\n                len = DIVERSITY_HOPS;\n            }\n            if(memchr(a + i + 2, 0, len) != NULL) {\n                /* 0 is reserved. */\n                flog_err(EC_BABEL_PACKET, \""Channel information contains 0!\"");\n                return;\n            }\n            memset(channels, 0, DIVERSITY_HOPS);\n            memcpy(channels, a + i + 2, len);\n        } else {\n            debugf(BABEL_DEBUG_COMMON,\n                   \""Received unknown route attribute %d.\"", type);\n        }\n\n        i += len + 2;\n    }\n}"", ""target"": 0}, {""func_name"": ""parse_hello_subtlv"", ""file_path"": ""babeld/message.c"", ""func_code"": ""static int\nparse_hello_subtlv(const unsigned char *a, int alen,\n                   unsigned int *hello_send_us)\n{\n    int type, len, i = 0, ret = 0;\n\n    while(i < alen) {\n        type = a[0];\n        if(type == SUBTLV_PAD1) {\n            i++;\n            continue;\n        }\n\n        if(i + 1 > alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \""Received truncated sub-TLV on Hello message.\"");\n            return -1;\n        }\n        len = a[i + 1];\n        if(i + len > alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \""Received truncated sub-TLV on Hello message.\"");\n            return -1;\n        }\n\n        if(type == SUBTLV_PADN) {\n            /* Nothing to do. */\n        } else if(type == SUBTLV_TIMESTAMP) {\n            if(len >= 4) {\n                DO_NTOHL(*hello_send_us, a + i + 2);\n                ret = 1;\n            } else {\n                flog_err(EC_BABEL_PACKET,\n\t\t\t  \""Received incorrect RTT sub-TLV on Hello message.\"");\n            }\n        } else {\n            debugf(BABEL_DEBUG_COMMON,\n                   \""Received unknown Hello sub-TLV type %d.\"", type);\n        }\n\n        i += len + 2;\n    }\n    return ret;\n}"", ""target"": 0}, {""func_name"": ""babel_packet_examin"", ""file_path"": ""babeld/message.c"", ""func_code"": ""static int\nbabel_packet_examin(const unsigned char *packet, int packetlen)\n{\n    unsigned i = 0, bodylen;\n    const unsigned char *message;\n    unsigned char type, len;\n\n    if(packetlen < 4 || packet[0] != 42 || packet[1] != 2)\n        return 1;\n    DO_NTOHS(bodylen, packet + 2);\n    while (i < bodylen){\n        message = packet + 4 + i;\n        type = message[0];\n        if(type == MESSAGE_PAD1) {\n            i++;\n            continue;\n        }\n        if(i + 1 > bodylen) {\n            debugf(BABEL_DEBUG_COMMON,\""Received truncated message.\"");\n            return 1;\n        }\n        len = message[1];\n        if(i + len > bodylen) {\n            debugf(BABEL_DEBUG_COMMON,\""Received truncated message.\"");\n            return 1;\n        }\n        /* not Pad1 */\n        if(type <= MESSAGE_MAX && tlv_min_length[type] && len < tlv_min_length[type]) {\n            debugf(BABEL_DEBUG_COMMON,\""Undersized %u TLV\"", type);\n            return 1;\n        }\n        i += len + 2;\n    }\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""parse_ihu_subtlv"", ""file_path"": ""babeld/message.c"", ""func_code"": ""static int\nparse_ihu_subtlv(const unsigned char *a, int alen,\n                 unsigned int *hello_send_us,\n                 unsigned int *hello_rtt_receive_time)\n{\n    int type, len, i = 0, ret = 0;\n\n    while(i < alen) {\n        type = a[i];\n        if(type == SUBTLV_PAD1) {\n            i++;\n            continue;\n        }\n\n        if(i + 1 >= alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \""Received truncated sub-TLV on IHU message.\"");\n            return -1;\n        }\n        len = a[i + 1];\n        if(i + len + 2 > alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \""Received truncated sub-TLV on IHU message.\"");\n            return -1;\n        }\n\n        if(type == SUBTLV_PADN) {\n            /* Nothing to do. */\n        } else if(type == SUBTLV_TIMESTAMP) {\n            if(len >= 8) {\n                DO_NTOHL(*hello_send_us, a + i + 2);\n                DO_NTOHL(*hello_rtt_receive_time, a + i + 6);\n                ret = 1;\n            }\n            else {\n                flog_err(EC_BABEL_PACKET,\n\t\t\t  \""Received incorrect RTT sub-TLV on IHU message.\"");\n            }\n        } else {\n            debugf(BABEL_DEBUG_COMMON,\n                   \""Received unknown IHU sub-TLV type %d.\"", type);\n        }\n\n        i += len + 2;\n    }\n    return ret;\n}""}, {""func_name"": ""parse_update_subtlv"", ""file_path"": ""babeld/message.c"", ""func_code"": ""static void\nparse_update_subtlv(const unsigned char *a, int alen,\n                    unsigned char *channels)\n{\n    int type, len, i = 0;\n\n    while(i < alen) {\n        type = a[i];\n        if(type == SUBTLV_PAD1) {\n            i++;\n            continue;\n        }\n\n        if(i + 1 >= alen) {\n            flog_err(EC_BABEL_PACKET, \""Received truncated attributes.\"");\n            return;\n        }\n        len = a[i + 1];\n        if(i + len + 2 > alen) {\n            flog_err(EC_BABEL_PACKET, \""Received truncated attributes.\"");\n            return;\n        }\n\n        if(type == SUBTLV_PADN) {\n            /* Nothing. */\n        } else if(type == SUBTLV_DIVERSITY) {\n            if(len > DIVERSITY_HOPS) {\n                flog_err(EC_BABEL_PACKET,\n\t\t\t  \""Received overlong channel information (%d > %d).n\"",\n                          len, DIVERSITY_HOPS);\n                len = DIVERSITY_HOPS;\n            }\n            if(memchr(a + i + 2, 0, len) != NULL) {\n                /* 0 is reserved. */\n                flog_err(EC_BABEL_PACKET, \""Channel information contains 0!\"");\n                return;\n            }\n            memset(channels, 0, DIVERSITY_HOPS);\n            memcpy(channels, a + i + 2, len);\n        } else {\n            debugf(BABEL_DEBUG_COMMON,\n                   \""Received unknown route attribute %d.\"", type);\n        }\n\n        i += len + 2;\n    }\n}""}, {""func_name"": ""parse_hello_subtlv"", ""file_path"": ""babeld/message.c"", ""func_code"": ""static int\nparse_hello_subtlv(const unsigned char *a, int alen,\n                   unsigned int *hello_send_us)\n{\n    int type, len, i = 0, ret = 0;\n\n    while(i < alen) {\n        type = a[i];\n        if(type == SUBTLV_PAD1) {\n            i++;\n            continue;\n        }\n\n        if(i + 1 >= alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \""Received truncated sub-TLV on Hello message.\"");\n            return -1;\n        }\n        len = a[i + 1];\n        if(i + len + 2 > alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \""Received truncated sub-TLV on Hello message.\"");\n            return -1;\n        }\n\n        if(type == SUBTLV_PADN) {\n            /* Nothing to do. */\n        } else if(type == SUBTLV_TIMESTAMP) {\n            if(len >= 4) {\n                DO_NTOHL(*hello_send_us, a + i + 2);\n                ret = 1;\n            } else {\n                flog_err(EC_BABEL_PACKET,\n\t\t\t  \""Received incorrect RTT sub-TLV on Hello message.\"");\n            }\n        } else {\n            debugf(BABEL_DEBUG_COMMON,\n                   \""Received unknown Hello sub-TLV type %d.\"", type);\n        }\n\n        i += len + 2;\n    }\n    return ret;\n}""}, {""func_name"": ""babel_packet_examin"", ""file_path"": ""babeld/message.c"", ""func_code"": ""static int\nbabel_packet_examin(const unsigned char *packet, int packetlen)\n{\n    unsigned i = 0, bodylen;\n    const unsigned char *message;\n    unsigned char type, len;\n\n    if(packetlen < 4 || packet[0] != 42 || packet[1] != 2)\n        return 1;\n    DO_NTOHS(bodylen, packet + 2);\n    while (i < bodylen){\n        message = packet + 4 + i;\n        type = message[0];\n        if(type == MESSAGE_PAD1) {\n            i++;\n            continue;\n        }\n        if(i + 2 > bodylen) {\n            debugf(BABEL_DEBUG_COMMON,\""Received truncated message.\"");\n            return 1;\n        }\n        len = message[1];\n        if(i + len + 2 > bodylen) {\n            debugf(BABEL_DEBUG_COMMON,\""Received truncated message.\"");\n            return 1;\n        }\n        /* not Pad1 */\n        if(type <= MESSAGE_MAX && tlv_min_length[type] && len < tlv_min_length[type]) {\n            debugf(BABEL_DEBUG_COMMON,\""Undersized %u TLV\"", type);\n            return 1;\n        }\n        i += len + 2;\n    }\n    return 0;\n}""}]","{""code"": 1, ""function"": 1, ""value"": 1}","[{""source"": ""code_info(file:message.c, lines:100-130)"", ""result"": ""            if (dp == NULL || !v4mapped(dp)) return -1;\n            memcpy(prefix, dp, 12 + omitted);\n        }\n        if(pb > omitted) memcpy(prefix + 12 + omitted, p, pb - omitted);\n        ret = pb - omitted;\n        break;\n    case 2:\n        if(omitted > 16 || (pb > omitted && len < pb - omitted)) return -1;\n        if(omitted) {\n            if (dp == NULL || v4mapped(dp)) return -1;\n            memcpy(prefix, dp, omitted);\n        }\n        if(pb > omitted) memcpy(prefix + omitted, p, pb - omitted);\n        ret = pb - omitted;\n        break;\n    case 3:\n        if(pb > 8 && len < pb - 8) return -1;\n        prefix[0] = 0xfe;\n        prefix[1] = 0x80;\n        if(pb > 8) memcpy(prefix + 8, p, pb - 8);\n        ret = pb - 8;\n        break;\n    default:\n        return -1;\n    }\n\n    mask_prefix(p_r, prefix, plen < 0 ? 128 : ae == 1 ? plen + 96 : plen);\n    return ret;\n}\n\nstatic void\nparse_update_subtlv(const unsigned char *a, int alen,\n""}, {""source"": ""func_info(file:message.c, func:babel_packet_examin)"", ""result"": [{""code"": ""static int\nbabel_packet_examin(const unsigned char *packet, int packetlen)\n{\n    unsigned i = 0, bodylen;\n    const unsigned char *message;\n    unsigned char type, len;\n\n    if(packetlen < 4 || packet[0] != 42 || packet[1] != 2)\n        return 1;\n    DO_NTOHS(bodylen, packet + 2);\n    while (i < bodylen){\n        message = packet + 4 + i;\n        type = message[0];\n        if(type == MESSAGE_PAD1) {\n            i++;\n            continue;\n        }\n        if(i + 1 > bodylen) {\n            debugf(BABEL_DEBUG_COMMON,\""Received truncated message.\"");\n            return 1;\n        }\n        len = message[1];\n        if(i + len > bodylen) {\n            debugf(BABEL_DEBUG_COMMON,\""Received truncated message.\"");\n            return 1;\n        }\n        /* not Pad1 */\n        if(type <= MESSAGE_MAX && tlv_min_length[type] && len < tlv_min_length[type]) {\n            debugf(BABEL_DEBUG_COMMON,\""Undersized %u TLV\"", type);\n            return 1;\n        }\n        i += len + 2;\n    }\n    return 0;\n}"", ""start_line"": 288, ""end_line"": 322, ""full_name"": ""babel_packet_examin"", ""file_path"": ""babeld/message.c""}]}, {""source"": ""value_info(file:message.c, value:bodylen)"", ""result"": {""value_trace"": [{""full_code"": ""bodylen = ntohs(_dd)"", ""line"": 297, ""func_name"": ""babel_packet_examin""}, {""full_code"": ""bodylen = ntohs(_dd)"", ""line"": 367, ""func_name"": ""parse_packet""}, {""full_code"": ""bodylen = packetlen - 4"", ""line"": 372, ""func_name"": ""parse_packet""}], ""struct_var"": ""bodylen"", ""struct_type"": ""unsigned"", ""struct_definition"": ""unsigned""}}]","In `babel_packet_examin` (message.c:288-322), the original check `i + len > bodylen` (line 309) did not account for the 2-byte header (type + length), allowing invalid sub-TLV lengths to be processed. Similarly, in `parse_hello_subtlv` (message.c:183-195), `parse_ihu_subtlv` (message.c:229-241), and `parse_update_subtlv` (message.c:141-153), checks like `i + len > alen` (e.g., line 145) omitted the 2-byte header. The patch adds `+2` to these checks (e.g., `i + len + 2 > alen`), ensuring the full sub-TLV header is accounted for. This prevents buffer overflows when parsing packets with maliciously crafted lengths. `bodylen` is derived from `packet + 2` (message.c:297) via `DO_NTOHS`, which is user-controlled and not validated against `packetlen`, creating a potential overflow risk if unchecked.",0.95,./github/other_context/CVE-2022-26128
51,CVE-2022-2845,CWE-1284,c_cpp,Improper Validation of Specified Quantity in Input in GitHub repository vim/vim prior to 9.0.0218.,https://github.com/vim/vim/commit/e98c88c44c308edaea5994b8ad4363e65030968c,"patch 9.0.0218: reading before the start of the line\n\nProblem:    Reading before the start of the line.\nSolution:   When displaying ""$"" check the column is not negative.",1,"[{""func_name"": ""display_dollar"", ""file_path"": ""src/edit.c"", ""func_code"": ""void\ndisplay_dollar(colnr_T col)\n{\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\t// If on the last byte of a multi-byte move to the first byte.\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    // recompute w_wrow and w_wcol\n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}"", ""target"": 0}]","[{""func_name"": ""display_dollar"", ""file_path"": ""src/edit.c"", ""func_code"": ""void\ndisplay_dollar(colnr_T col_arg)\n{\n    colnr_T col = col_arg < 0 ? 0 : col_arg;\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\t// If on the last byte of a multi-byte move to the first byte.\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    // recompute w_wrow and w_wcol\n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}""}]","{""caller"": 1, ""value"": 1}","[{""source"": ""caller_info(file:edit.c, func:display_dollar)"", ""result"": [{""call_line"": 912, ""call_code"": ""display_dollar(oap->end.col - !oap->inclusive)"", ""caller_code"": ""    int\nop_delete(oparg_T *oap)\n{\n    int\t\t\tn;\n    linenr_T\t\tlnum;\n    char_u\t\t*ptr;\n    char_u\t\t*newp, *oldp;\n    struct block_def\tbd;\n    linenr_T\t\told_lcount = curbuf->b_ml.ml_line_count;\n    int\t\t\tdid_yank = FALSE;\n\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to do\n\treturn OK;\n\n    // Nothing to delete, return here.\tDo prepare undo, for op_change().\n    if (oap->empty)\n\treturn u_save_cursor();\n\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn FAIL;\n    }\n\n    if (VIsual_select && oap->is_VIsual)\n\t// use register given with CTRL_R, defaults to zero\n\toap->regname = VIsual_select_reg;\n\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&oap->regname);\n#endif\n\n    if (has_mbyte)\n\tmb_adjust_opend(oap);\n\n    /*\n     * Imitate the strange Vi behaviour: If the delete spans more than one\n     * line and motion_type == MCHAR and the result is a blank line, make the\n     * delete linewise.  Don't do this for the change command or Visual mode.\n     */\n    if (       oap->motion_type == MCHAR\n\t    && !oap->is_VIsual\n\t    && !oap->block_mode\n\t    && oap->line_count > 1\n\t    && oap->motion_force == NUL\n\t    && oap->op_type == OP_DELETE)\n    {\n\tptr = ml_get(oap->end.lnum) + oap->end.col;\n\tif (*ptr != NUL)\n\t    ptr += oap->inclusive;\n\tptr = skipwhite(ptr);\n\tif (*ptr == NUL && inindent(0))\n\t    oap->motion_type = MLINE;\n    }\n\n    /*\n     * Check for trying to delete (e.g. \""D\"") in an empty line.\n     * Note: For the change operator it is ok.\n     */\n    if (       oap->motion_type == MCHAR\n\t    && oap->line_count == 1\n\t    && oap->op_type == OP_DELETE\n\t    && *ml_get(oap->start.lnum) == NUL)\n    {\n\t/*\n\t * It's an error to operate on an empty region, when 'E' included in\n\t * 'cpoptions' (Vi compatible).\n\t */\n\tif (virtual_op)\n\t    // Virtual editing: Nothing gets deleted, but we set the '[ and ']\n\t    // marks as if it happened.\n\t    goto setmarks;\n\tif (vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL)\n\t    beep_flush();\n\treturn OK;\n    }\n\n    /*\n     * Do a yank of whatever we're about to delete.\n     * If a yank register was specified, put the deleted text into that\n     * register.  For the black hole register '_' don't yank anything.\n     */\n    if (oap->regname != '_')\n    {\n\tif (oap->regname != 0)\n\t{\n\t    // check for read-only register\n\t    if (!valid_yank_reg(oap->regname, TRUE))\n\t    {\n\t\tbeep_flush();\n\t\treturn OK;\n\t    }\n\t    get_yank_register(oap->regname, TRUE); // yank into specif'd reg.\n\t    if (op_yank(oap, TRUE, FALSE) == OK)   // yank without message\n\t\tdid_yank = TRUE;\n\t}\n\telse\n\t    reset_y_append(); // not appending to unnamed register\n\n\t/*\n\t * Put deleted text into register 1 and shift number registers if the\n\t * delete contains a line break, or when using a specific operator (Vi\n\t * compatible)\n\t */\n\tif (oap->motion_type == MLINE || oap->line_count > 1\n\t\t\t\t\t\t\t   || oap->use_reg_one)\n\t{\n\t    shift_delete_registers();\n\t    if (op_yank(oap, TRUE, FALSE) == OK)\n\t\tdid_yank = TRUE;\n\t}\n\n\t// Yank into small delete register when no named register specified\n\t// and the delete is within one line.\n\tif ((\n#ifdef FEAT_CLIPBOARD\n\t    ((clip_unnamed & CLIP_UNNAMED) && oap->regname == '*') ||\n\t    ((clip_unnamed & CLIP_UNNAMED_PLUS) && oap->regname == '+') ||\n#endif\n\t    oap->regname == 0) && oap->motion_type != MLINE\n\t\t\t\t\t\t      && oap->line_count == 1)\n\t{\n\t    oap->regname = '-';\n\t    get_yank_register(oap->regname, TRUE);\n\t    if (op_yank(oap, TRUE, FALSE) == OK)\n\t\tdid_yank = TRUE;\n\t    oap->regname = 0;\n\t}\n\n\t/*\n\t * If there's too much stuff to fit in the yank register, then get a\n\t * confirmation before doing the delete. This is crude, but simple.\n\t * And it avoids doing a delete of something we can't put back if we\n\t * want.\n\t */\n\tif (!did_yank)\n\t{\n\t    int msg_silent_save = msg_silent;\n\n\t    msg_silent = 0;\t// must display the prompt\n\t    n = ask_yesno((char_u *)_(\""cannot yank; delete anyway\""), TRUE);\n\t    msg_silent = msg_silent_save;\n\t    if (n != 'y')\n\t    {\n\t\temsg(_(e_command_aborted));\n\t\treturn FAIL;\n\t    }\n\t}\n\n#if defined(FEAT_EVAL)\n\tif (did_yank && has_textyankpost())\n\t    yank_do_autocmd(oap, get_y_current());\n#endif\n    }\n\n    /*\n     * block mode delete\n     */\n    if (oap->block_mode)\n    {\n\tif (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t    return FAIL;\n\n\tfor (lnum = curwin->w_cursor.lnum; lnum <= oap->end.lnum; ++lnum)\n\t{\n\t    block_prep(oap, &bd, lnum, TRUE);\n\t    if (bd.textlen == 0)\t// nothing to delete\n\t\tcontinue;\n\n\t    // Adjust cursor position for tab replaced by spaces and 'lbr'.\n\t    if (lnum == curwin->w_cursor.lnum)\n\t    {\n\t\tcurwin->w_cursor.col = bd.textcol + bd.startspaces;\n\t\tcurwin->w_cursor.coladd = 0;\n\t    }\n\n\t    // \""n\"" == number of chars deleted\n\t    // If we delete a TAB, it may be replaced by several characters.\n\t    // Thus the number of characters may increase!\n\t    n = bd.textlen - bd.startspaces - bd.endspaces;\n\t    oldp = ml_get(lnum);\n\t    newp = alloc(STRLEN(oldp) + 1 - n);\n\t    if (newp == NULL)\n\t\tcontinue;\n\t    // copy up to deleted part\n\t    mch_memmove(newp, oldp, (size_t)bd.textcol);\n\t    // insert spaces\n\t    vim_memset(newp + bd.textcol, ' ',\n\t\t\t\t     (size_t)(bd.startspaces + bd.endspaces));\n\t    // copy the part after the deleted part\n\t    oldp += bd.textcol + bd.textlen;\n\t    STRMOVE(newp + bd.textcol + bd.startspaces + bd.endspaces, oldp);\n\t    // replace the line\n\t    ml_replace(lnum, newp, FALSE);\n\n#ifdef FEAT_PROP_POPUP\n\t    if (curbuf->b_has_textprop && n != 0)\n\t\tadjust_prop_columns(lnum, bd.textcol, -n, 0);\n#endif\n\t}\n\n\tcheck_cursor_col();\n\tchanged_lines(curwin->w_cursor.lnum, curwin->w_cursor.col,\n\t\t\t\t\t\t       oap->end.lnum + 1, 0L);\n\toap->line_count = 0;\t    // no lines deleted\n    }\n    else if (oap->motion_type == MLINE)\n    {\n\tif (oap->op_type == OP_CHANGE)\n\t{\n\t    // Delete the lines except the first one.  Temporarily move the\n\t    // cursor to the next line.  Save the current line number, if the\n\t    // last line is deleted it may be changed.\n\t    if (oap->line_count > 1)\n\t    {\n\t\tlnum = curwin->w_cursor.lnum;\n\t\t++curwin->w_cursor.lnum;\n\t\tdel_lines((long)(oap->line_count - 1), TRUE);\n\t\tcurwin->w_cursor.lnum = lnum;\n\t    }\n\t    if (u_save_cursor() == FAIL)\n\t\treturn FAIL;\n\t    if (curbuf->b_p_ai)\t\t    // don't delete indent\n\t    {\n\t\tbeginline(BL_WHITE);\t    // cursor on first non-white\n\t\tdid_ai = TRUE;\t\t    // delete the indent when ESC hit\n\t\tai_col = curwin->w_cursor.col;\n\t    }\n\t    else\n\t\tbeginline(0);\t\t    // cursor in column 0\n\t    truncate_line(FALSE);   // delete the rest of the line\n\t\t\t\t    // leave cursor past last char in line\n\t    if (oap->line_count > 1)\n\t\tu_clearline();\t    // \""U\"" command not possible after \""2cc\""\n\t}\n\telse\n\t{\n\t    del_lines(oap->line_count, TRUE);\n\t    beginline(BL_WHITE | BL_FIX);\n\t    u_clearline();\t// \""U\"" command not possible after \""dd\""\n\t}\n    }\n    else\n    {\n\tif (virtual_op)\n\t{\n\t    int\t\tendcol = 0;\n\n\t    // For virtualedit: break the tabs that are partly included.\n\t    if (gchar_pos(&oap->start) == '\\t')\n\t    {\n\t\tif (u_save_cursor() == FAIL)\t// save first line for undo\n\t\t    return FAIL;\n\t\tif (oap->line_count == 1)\n\t\t    endcol = getviscol2(oap->end.col, oap->end.coladd);\n\t\tcoladvance_force(getviscol2(oap->start.col, oap->start.coladd));\n\t\toap->start = curwin->w_cursor;\n\t\tif (oap->line_count == 1)\n\t\t{\n\t\t    coladvance(endcol);\n\t\t    oap->end.col = curwin->w_cursor.col;\n\t\t    oap->end.coladd = curwin->w_cursor.coladd;\n\t\t    curwin->w_cursor = oap->start;\n\t\t}\n\t    }\n\n\t    // Break a tab only when it's included in the area.\n\t    if (gchar_pos(&oap->end) == '\\t'\n\t\t\t\t     && (int)oap->end.coladd < oap->inclusive)\n\t    {\n\t\t// save last line for undo\n\t\tif (u_save((linenr_T)(oap->end.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\t\t    return FAIL;\n\t\tcurwin->w_cursor = oap->end;\n\t\tcoladvance_force(getviscol2(oap->end.col, oap->end.coladd));\n\t\toap->end = curwin->w_cursor;\n\t\tcurwin->w_cursor = oap->start;\n\t    }\n\t    if (has_mbyte)\n\t\tmb_adjust_opend(oap);\n\t}\n\n\tif (oap->line_count == 1)\t// delete characters within one line\n\t{\n\t    if (u_save_cursor() == FAIL)\t// save line for undo\n\t\treturn FAIL;\n\n\t    // if 'cpoptions' contains '$', display '$' at end of change\n\t    if (       vim_strchr(p_cpo, CPO_DOLLAR) != NULL\n\t\t    && oap->op_type == OP_CHANGE\n\t\t    && oap->end.lnum == curwin->w_cursor.lnum\n\t\t    && !oap->is_VIsual)\n\t\tdisplay_dollar(oap->end.col - !oap->inclusive);\n\n\t    n = oap->end.col - oap->start.col + 1 - !oap->inclusive;\n\n\t    if (virtual_op)\n\t    {\n\t\t// fix up things for virtualedit-delete:\n\t\t// break the tabs which are going to get in our way\n\t\tchar_u\t\t*curline = ml_get_curline();\n\t\tint\t\tlen = (int)STRLEN(curline);\n\n\t\tif (oap->end.coladd != 0\n\t\t\t&& (int)oap->end.col >= len - 1\n\t\t\t&& !(oap->start.coladd && (int)oap->end.col >= len - 1))\n\t\t    n++;\n\t\t// Delete at least one char (e.g, when on a control char).\n\t\tif (n == 0 && oap->start.coladd != oap->end.coladd)\n\t\t    n = 1;\n\n\t\t// When deleted a char in the line, reset coladd.\n\t\tif (gchar_cursor() != NUL)\n\t\t    curwin->w_cursor.coladd = 0;\n\t    }\n\t    (void)del_bytes((long)n, !virtual_op,\n\t\t\t    oap->op_type == OP_DELETE && !oap->is_VIsual);\n\t}\n\telse\t\t\t\t// delete characters between lines\n\t{\n\t    pos_T   curpos;\n\n\t    // save deleted and changed lines for undo\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n\t\t (linenr_T)(curwin->w_cursor.lnum + oap->line_count)) == FAIL)\n\t\treturn FAIL;\n\n\t    truncate_line(TRUE);\t// delete from cursor to end of line\n\n\t    curpos = curwin->w_cursor;\t// remember curwin->w_cursor\n\t    ++curwin->w_cursor.lnum;\n\t    del_lines((long)(oap->line_count - 2), FALSE);\n\n\t    // delete from start of line until op_end\n\t    n = (oap->end.col + 1 - !oap->inclusive);\n\t    curwin->w_cursor.col = 0;\n\t    (void)del_bytes((long)n, !virtual_op,\n\t\t\t    oap->op_type == OP_DELETE && !oap->is_VIsual);\n\t    curwin->w_cursor = curpos;\t// restore curwin->w_cursor\n\t    (void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t}\n\tif (oap->op_type == OP_DELETE)\n\t    auto_format(FALSE, TRUE);\n    }\n\n    msgmore(curbuf->b_ml.ml_line_count - old_lcount);\n\nsetmarks:\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tif (oap->block_mode)\n\t{\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = oap->start.col;\n\t}\n\telse\n\t    curbuf->b_op_end = oap->start;\n\tcurbuf->b_op_start = oap->start;\n    }\n\n    return OK;\n}\n"", ""caller_start"": 618, ""file_path"": ""src/ops.c""}]}, {""source"": ""value_info(file:ops.c, value:oap->end.col)"", ""result"": {""value_trace"": [{""full_code"": ""oap->end.col = curwin->w_cursor.col"", ""line"": 879, ""func_name"": ""op_delete""}, {""full_code"": ""oap->end.col += mb_tail_off(p, p + oap->end.col)"", ""line"": 995, ""func_name"": ""mb_adjust_opend""}, {""full_code"": ""oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum))"", ""line"": 1167, ""func_name"": ""op_replace""}, {""full_code"": ""--oap->end.col"", ""line"": 1169, ""func_name"": ""op_replace""}, {""full_code"": ""oap->end.col += new_byte_len - old_byte_len"", ""line"": 1187, ""func_name"": ""op_replace""}], ""struct_var"": ""oap"", ""struct_type"": null, ""struct_definition"": null}}]","src/edit.c:1750: Negative 'col_arg' passed to 'display_dollar' from 'src/ops.c:912' (op_delete: display_dollar(oap->end.col - !oap->inclusive)). 'oap->end.col' is set to 'curwin->w_cursor.col' in 'src/ops.c:879'. If 'curwin->w_cursor.col' is 0 and 'oap->inclusive' is 0, the argument becomes -1. This triggers the vulnerability due to lack of validation in 'display_dollar' before the patch.",0.95,./github/other_context/CVE-2022-2845
52,CVE-2022-31135,CWE-129,c_cpp,"Akashi is an open source server implementation of the Attorney Online video game based on the Ace Attorney universe. Affected versions of Akashi are subject to a denial of service attack. An attacker can use a specially crafted evidence packet to make an illegal modification, causing a server crash. This can be used to mount a denial-of-service exploit. Users are advised to upgrade. There is no known workaround for this issue.",https://github.com/AttorneyOnline/akashi/commit/5566cdfedddef1f219aee33477d9c9690bf2f78b,Fix out of bounds crash on evidence,2,"[{""func_name"": ""AOClient::pktRemoveEvidence"", ""file_path"": ""core/src/packets.cpp"", ""func_code"": ""void AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->deleteEvidence(idx);\n    }\n    sendEvidenceList(area);\n}"", ""target"": 0}, {""func_name"": ""AOClient::pktEditEvidence"", ""file_path"": ""core/src/packets.cpp"", ""func_code"": ""void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}"", ""target"": 0}]","[{""func_name"": ""AOClient::pktRemoveEvidence"", ""file_path"": ""core/src/packets.cpp"", ""func_code"": ""void AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    if (is_int && idx < area->evidence().size() && idx >= 0) {\n        area->deleteEvidence(idx);\n    }\n    sendEvidenceList(area);\n}""}, {""func_name"": ""AOClient::pktEditEvidence"", ""file_path"": ""core/src/packets.cpp"", ""func_code"": ""void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx < area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}""}]","{""function"": 2, ""code"": 1}","[{""source"": ""func_info(func:deleteEvidence)"", ""result"": [{""code"": ""void AreaData::deleteEvidence(int f_eviId)\n{\n    m_evidence.removeAt(f_eviId);\n}"", ""start_line"": 240, ""end_line"": 243, ""full_name"": ""AreaData.deleteEvidence:void(int)"", ""file_path"": ""core/src/area_data.cpp""}]}, {""source"": ""func_info(func:replaceEvidence)"", ""result"": [{""code"": ""void AreaData::replaceEvidence(int f_eviId, const AreaData::Evidence &f_newEvi_r)\n{\n    m_evidence.replace(f_eviId, f_newEvi_r);\n}"", ""start_line"": 245, ""end_line"": 248, ""full_name"": ""AreaData.replaceEvidence:void(int,AreaData.Evidence&)"", ""file_path"": ""core/src/area_data.cpp""}]}, {""source"": ""code_info(file:areadata.h, lines:100-120)"", ""result"": ""error code""}]","In `AOClient::pktRemoveEvidence` (core/src/packets.cpp:379-381) and `AOClient::pktEditEvidence` (core/src/packets.cpp:392-394), the original condition `idx <= area->evidence().size()` allowed an index equal to the list size, which is invalid for zero-based indexing. This caused `AreaData::deleteEvidence` (core/src/areadata.cpp:240-243) and `AreaData::replaceEvidence` (core/src/areadata.cpp:245-248) to perform out-of-bounds operations, leading to a crash. The patch replaces `<=` with `<` to enforce valid index ranges.",0.95,./github/other_context/CVE-2022-31135
53,CVE-2022-31197,CWE-89,java,"PostgreSQL JDBC Driver (PgJDBC for short) allows Java programs to connect to a PostgreSQL database using standard, database independent Java code. The PGJDBC implementation of the `java.sql.ResultRow.refreshRow()` method is not performing escaping of column names so a malicious column name that contains a statement terminator, e.g. `;`, could lead to SQL injection. This could lead to executing additional SQL commands as the application's JDBC user. User applications that do not invoke the `ResultSet.refreshRow()` method are not impacted. User application that do invoke that method are impacted if the underlying database that they are querying via their JDBC application may be under the control of an attacker. The attack requires the attacker to trick the user into executing SQL against a table name who's column names would contain the malicious SQL and subsequently invoke the `refreshRow()` method on the ResultSet. Note that the application's JDBC user and the schema owner need not be the same. A JDBC application that executes as a privileged user querying database schemas owned by potentially malicious less-privileged users would be vulnerable. In that situation it may be possible for the malicious user to craft a schema that causes the application to execute commands as the privileged user. Patched versions will be released as `42.2.26` and `42.4.1`. Users are advised to upgrade. There are no known workarounds for this issue.",https://github.com/pgjdbc/pgjdbc/commit/739e599d52ad80f8dcd6efedc6157859b1a9d637,"Merge pull request from GHSA-r38f-c4h4-hqq2\n\nFixes SQL generated in PgResultSet.refresh() to escape column identifiers so as to prevent SQL injection.\n\nPreviously, the column names for both key and data columns in the table were copied as-is into the generated\nSQL. This allowed a malicious table with column names that include statement terminator to be parsed and\nexecuted as multiple separate commands.\n\nAlso adds a new test class ResultSetRefreshTest to verify this change.",1,"[{""func_name"": ""refreshRow"", ""file_path"": ""pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSet.java"", ""func_code"": ""@Override\n  public void refreshRow() throws SQLException {\n    checkUpdateable();\n    if (onInsertRow) {\n      throw new PSQLException(GT.tr(\""Can''t refresh the insert row.\""),\n          PSQLState.INVALID_CURSOR_STATE);\n    }\n\n    if (isBeforeFirst() || isAfterLast() || castNonNull(rows, \""rows\"").isEmpty()) {\n      return;\n    }\n\n    StringBuilder selectSQL = new StringBuilder(\""select \"");\n\n    ResultSetMetaData rsmd = getMetaData();\n    PGResultSetMetaData pgmd = (PGResultSetMetaData) rsmd;\n    for (int i = 1; i <= rsmd.getColumnCount(); i++) {\n      if (i > 1) {\n        selectSQL.append(\"", \"");\n      }\n      selectSQL.append(pgmd.getBaseColumnName(i));\n    }\n    selectSQL.append(\"" from \"").append(onlyTable).append(tableName).append(\"" where \"");\n\n    List<PrimaryKey> primaryKeys = castNonNull(this.primaryKeys, \""primaryKeys\"");\n    int numKeys = primaryKeys.size();\n\n    for (int i = 0; i < numKeys; i++) {\n\n      PrimaryKey primaryKey = primaryKeys.get(i);\n      selectSQL.append(primaryKey.name).append(\"" = ?\"");\n\n      if (i < numKeys - 1) {\n        selectSQL.append(\"" and \"");\n      }\n    }\n    String sqlText = selectSQL.toString();\n    if (connection.getLogger().isLoggable(Level.FINE)) {\n      connection.getLogger().log(Level.FINE, \""selecting {0}\"", sqlText);\n    }\n    // because updateable result sets do not yet support binary transfers we must request refresh\n    // with updateable result set to get field data in correct format\n    PreparedStatement selectStatement = null;\n    try {\n      selectStatement = connection.prepareStatement(sqlText,\n          ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);\n\n      for (int i = 0; i < numKeys; i++) {\n        selectStatement.setObject(i + 1, primaryKeys.get(i).getValue());\n      }\n\n      PgResultSet rs = (PgResultSet) selectStatement.executeQuery();\n\n      if (rs.next()) {\n        // we know that the row is updatable as it was tested above.\n        if ( rs.thisRow == null ) {\n          rowBuffer = null;\n        } else {\n          rowBuffer = castNonNull(rs.thisRow).updateableCopy();\n        }\n      }\n\n      castNonNull(rows).set(currentRow, castNonNull(rowBuffer));\n      thisRow = rowBuffer;\n\n      connection.getLogger().log(Level.FINE, \""done updates\"");\n\n      rs.close();\n    } finally {\n      JdbcBlackHole.close(selectStatement);\n    }\n  }"", ""target"": 0}]","[{""func_name"": ""refreshRow"", ""file_path"": ""pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSet.java"", ""func_code"": ""@Override\n  public void refreshRow() throws SQLException {\n    checkUpdateable();\n    if (onInsertRow) {\n      throw new PSQLException(GT.tr(\""Can''t refresh the insert row.\""),\n          PSQLState.INVALID_CURSOR_STATE);\n    }\n\n    if (isBeforeFirst() || isAfterLast() || castNonNull(rows, \""rows\"").isEmpty()) {\n      return;\n    }\n\n    StringBuilder selectSQL = new StringBuilder(\""select \"");\n\n    ResultSetMetaData rsmd = getMetaData();\n    PGResultSetMetaData pgmd = (PGResultSetMetaData) rsmd;\n    for (int i = 1; i <= rsmd.getColumnCount(); i++) {\n      if (i > 1) {\n        selectSQL.append(\"", \"");\n      }\n      Utils.escapeIdentifier(selectSQL, pgmd.getBaseColumnName(i));\n    }\n    selectSQL.append(\"" from \"").append(onlyTable).append(tableName).append(\"" where \"");\n\n    List<PrimaryKey> primaryKeys = castNonNull(this.primaryKeys, \""primaryKeys\"");\n    int numKeys = primaryKeys.size();\n\n    for (int i = 0; i < numKeys; i++) {\n\n      PrimaryKey primaryKey = primaryKeys.get(i);\n      Utils.escapeIdentifier(selectSQL, primaryKey.name);\n      selectSQL.append(\"" = ?\"");\n\n      if (i < numKeys - 1) {\n        selectSQL.append(\"" and \"");\n      }\n    }\n    String sqlText = selectSQL.toString();\n    if (connection.getLogger().isLoggable(Level.FINE)) {\n      connection.getLogger().log(Level.FINE, \""selecting {0}\"", sqlText);\n    }\n    // because updateable result sets do not yet support binary transfers we must request refresh\n    // with updateable result set to get field data in correct format\n    PreparedStatement selectStatement = null;\n    try {\n      selectStatement = connection.prepareStatement(sqlText,\n          ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);\n\n      for (int i = 0; i < numKeys; i++) {\n        selectStatement.setObject(i + 1, primaryKeys.get(i).getValue());\n      }\n\n      PgResultSet rs = (PgResultSet) selectStatement.executeQuery();\n\n      if (rs.next()) {\n        // we know that the row is updatable as it was tested above.\n        if ( rs.thisRow == null ) {\n          rowBuffer = null;\n        } else {\n          rowBuffer = castNonNull(rs.thisRow).updateableCopy();\n        }\n      }\n\n      castNonNull(rows).set(currentRow, castNonNull(rowBuffer));\n      thisRow = rowBuffer;\n\n      connection.getLogger().log(Level.FINE, \""done updates\"");\n\n      rs.close();\n    } finally {\n      JdbcBlackHole.close(selectStatement);\n    }\n  }""}]","{""function"": 2}","[{""source"": ""func_info(func:escapeIdentifier)"", ""result"": [{""code"": ""  String escapeIdentifier(String identifier) throws SQLException;\n"", ""start_line"": 202, ""end_line"": 202, ""full_name"": ""org.postgresql.PGConnection.escapeIdentifier:java.lang.String(java.lang.String)"", ""file_path"": ""pgjdbc/src/main/java/org/postgresql/PGConnection.java""}, {""code"": ""  public static StringBuilder escapeIdentifier(@Nullable StringBuilder sbuf, String value)\n      throws SQLException {\n    if (sbuf == null) {\n      sbuf = new StringBuilder(2 + (value.length() + 10) / 10 * 11); // Add 10% for escaping.\n    }\n    doAppendEscapedIdentifier(sbuf, value);\n    return sbuf;\n  }\n"", ""start_line"": 117, ""end_line"": 124, ""full_name"": ""org.postgresql.core.Utils.escapeIdentifier:java.lang.StringBuilder(java.lang.StringBuilder,java.lang.String)"", ""file_path"": ""pgjdbc/src/main/java/org/postgresql/core/Utils.java""}, {""code"": ""  @Override\n  public String escapeIdentifier(String identifier) throws SQLException {\n    return Utils.escapeIdentifier(null, identifier).toString();\n  }\n"", ""start_line"": 1273, ""end_line"": 1276, ""full_name"": ""org.postgresql.jdbc.PgConnection.escapeIdentifier:java.lang.String(java.lang.String)"", ""file_path"": ""pgjdbc/src/main/java/org/postgresql/jdbc/PgConnection.java""}]}, {""source"": ""func_info(file:Utils.java, func:doAppendEscapedIdentifier)"", ""result"": [{""code"": ""  private static void doAppendEscapedIdentifier(Appendable sbuf, String value) throws SQLException {\n    try {\n      sbuf.append('\""');\n\n      for (int i = 0; i < value.length(); ++i) {\n        char ch = value.charAt(i);\n        if (ch == '\\0') {\n          throw new PSQLException(GT.tr(\""Zero bytes may not occur in identifiers.\""),\n              PSQLState.INVALID_PARAMETER_VALUE);\n        }\n        if (ch == '\""') {\n          sbuf.append(ch);\n        }\n        sbuf.append(ch);\n      }\n\n      sbuf.append('\""');\n    } catch (IOException e) {\n      throw new PSQLException(GT.tr(\""No IOException expected from StringBuffer or StringBuilder\""),\n          PSQLState.UNEXPECTED_ERROR, e);\n    }\n  }\n"", ""start_line"": 133, ""end_line"": 154, ""full_name"": ""org.postgresql.core.Utils.doAppendEscapedIdentifier:void(java.lang.Appendable,java.lang.String)"", ""file_path"": ""pgjdbc/src/main/java/org/postgresql/core/Utils.java""}]}]","PgResultSet.java:1419-1420, PgResultSet.java:1429-1430: Direct appending of unescaped column names (pgmd.getBaseColumnName(i) and primaryKey.name) into SQL strings allowed injection. Patch replaces this with Utils.escapeIdentifier(), which uses org.postgresql.core.Utils.doAppendEscapedIdentifier (Utils.java:133-154) to quote identifiers with "" and escape internal "" characters. This prevents injection by ensuring malicious characters like ; are treated as literal parts of identifier names, not SQL syntax.",0.95,./github/other_context/CVE-2022-31197
54,CVE-2022-4399,CWE-89,c_cpp,A vulnerability was found in TicklishHoneyBee nodau. It has been rated as critical. Affected by this issue is some unknown functionality of the file src/db.c. The manipulation of the argument value/name leads to sql injection. The name of the patch is 7a7d737a3929f335b9717ddbd31db91151b69ad2. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-215252.,https://github.com/TicklishHoneyBee/nodau/commit/7a7d737a3929f335b9717ddbd31db91151b69ad2,"Use parametetrized SQL statement\n\nMove to parametetrized SQL statement allows using chars like ""'"" in\nnotes and also avoid sql injection",2,"[{""func_name"": ""db_update"", ""file_path"": ""src/db.c"", ""func_code"": ""int db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\t/* create the sql statement using the name/text for this note\n\t * if it's meant to be encrypted, then crypt_key will be set */\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tr = asprintf(&sql, \""UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\"", value, name);\n\t\tfree(value);\n\t\tif (r < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \""UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\"", value, name) < 0)\n\t\t\treturn 1;\n\t}\n\n\t/* do it */\n\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n\tfree(sql);\n\treturn r;\n}"", ""target"": 0}, {""func_name"": ""edit_ext"", ""file_path"": ""src/edit.c"", ""func_code"": ""static int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\n\tstrcpy(buff,\""/tmp/nodau.XXXXXX\"");\n\tfd = mkstemp(buff);\n\n\tif (fd < 0)\n\t\treturn 1;\n\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\t/* find the file length */\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\t/* load the note into memory */\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\t/* delete the file */\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\t/* find the note data */\n\t\t\t\tl = strstr(b,\""-----\"");\n\t\t\t\tif (l) {\n\t\t\t\t\t/* save the note */\n\t\t\t\t\tl += 6;\n\t\t\t\t\tif (db_update(name,l))\n\t\t\t\t\t\treturn 1;\n\n\t\t\t\t\t/* let the user know */\n\t\t\t\t\tprintf(\""%s saved\\n\"",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\n\t/* insert data into file */\n\tsz = sprintf(\n\t\tb,\n\t\t\""%s (%s)\\nText above this line is ignored\\n-----\\n%s\"",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\n\tst = execl(editor,editor,buff,(char*)NULL);\n\n\t/* we should only ever get here if something goes wrong with exec */\n\texit(st);\n\n\t/* and we shouldn't ever get here, but it stops the compiler complaining */\n\treturn 1;\n}"", ""target"": 0}]","[{""func_name"": ""db_update"", ""file_path"": ""src/db.c"", ""func_code"": ""int db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\t/* create the sql statement using the name/text for this note\n\t * if it's meant to be encrypted, then crypt_key will be set */\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tif (asprintf(&sql, \""UPDATE nodau set text=?, encrypted='true' WHERE name=?\"") < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \""UPDATE nodau set text=?, encrypted='false' WHERE name=?\"") < 0)\n\t\t\treturn 1;\n\t}\n\n\tsqlite3_stmt *compiled_statement;\n\tr = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);\n\tif (r != SQLITE_OK)\n\t\treturn 1;\n\n\tr= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);\n\tr= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);\n\tif (r != SQLITE_OK)\n\t\treturn 1;\n\n\t/* do it */\n\tr = sqlite3_step(compiled_statement);\n\tif (r != SQLITE_DONE) {\n\t\tfprintf(stderr, \""Error #%d: %s\\n\"", r, db_err());\n\t\treturn 1;\n\t}\n\tr = sqlite3_finalize(compiled_statement);\n\tif (r != SQLITE_OK)\n\t\tfprintf(stderr, \""Error #%d: %s\\n\"", r, db_err());\n\n\tfree(sql);\n\tif (crypt_key)\n\t\tfree(value);\n\treturn r;\n}""}, {""func_name"": ""edit_ext"", ""file_path"": ""src/edit.c"", ""func_code"": ""static int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\n\tstrcpy(buff,\""/tmp/nodau.XXXXXX\"");\n\tfd = mkstemp(buff);\n\n\tif (fd < 0)\n\t\treturn 1;\n\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\t/* find the file length */\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\t/* load the note into memory */\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\t/* delete the file */\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\t/* find the note data */\n\t\t\t\tl = strstr(b,\""-----\"");\n\t\t\t\tif (l) {\n\t\t\t\t\t/* save the note */\n\t\t\t\t\tl += 6;\n\t\t\t\t\tint r = db_update(name,l);\n\t\t\t\t\tif (r != SQLITE_DONE && r != SQLITE_OK)\n\t\t\t\t\t\treturn 1;\n\n\t\t\t\t\t/* let the user know */\n\t\t\t\t\tprintf(\""%s saved\\n\"",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\n\t/* insert data into file */\n\tsz = sprintf(\n\t\tb,\n\t\t\""%s (%s)\\nText above this line is ignored\\n-----\\n%s\"",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\n\tst = execl(editor,editor,buff,(char*)NULL);\n\n\t/* we should only ever get here if something goes wrong with exec */\n\texit(st);\n\n\t/* and we shouldn't ever get here, but it stops the compiler complaining */\n\treturn 1;\n}""}]","{""value"": 5, ""caller"": 4}","[{""source"": ""value_info(file:db.c, value:name)"", ""result"": {""value_trace"": [{""full_code"": ""name = result->data[COLUMN(0,COL_NAME)]"", ""line"": 388, ""func_name"": ""db_edit""}, {""full_code"": ""name = result->data[COLUMN(0,COL_NAME)]"", ""line"": 429, ""func_name"": ""db_append""}, {""full_code"": ""name = result->data[COLUMN(0,COL_NAME)]"", ""line"": 470, ""func_name"": ""db_show""}, {""full_code"": ""name = result->data[COLUMN(0,COL_NAME)]"", ""line"": 579, ""func_name"": ""db_encrypt""}], ""struct_var"": ""name"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""value_info(file:db.c, value:value)"", ""result"": {""value_trace"": [{""full_code"": ""value = note_encrypt(value,crypt_key)"", ""line"": 287, ""func_name"": ""db_update""}], ""struct_var"": ""value"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:db.c, value:value)"", ""result"": {""value_trace"": [{""full_code"": ""value = note_encrypt(value,crypt_key)"", ""line"": 287, ""func_name"": ""db_update""}], ""struct_var"": ""value"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:db.c, func:db_update)"", ""result"": [{""call_line"": 586, ""call_code"": ""db_update(name,text)"", ""caller_code"": ""int db_encrypt(char* search)\n{\n\t/* search by name */\n\tsql_result *result;\n\tchar* crypt;\n\tint r = 0;\n\tresult = db_get(\""SELECT * FROM nodau WHERE name = '%s'\"",search);\n\n\t/* there's already a note with that name */\n\tif (result->num_rows) {\n\t\tchar* name;\n\t\tchar* text;\n\n\t\t/* get the data */\n\t\tname = result->data[COLUMN(0,COL_NAME)];\n\t\ttext = result->data[COLUMN(0,COL_TEXT)];\n\t\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t\t/* encrypt it if it's not already */\n\t\tif (!strcmp(crypt,\""false\"")) {\n\t\t\tcrypt = crypt_get_key();\n\t\t\tr = db_update(name,text);\n\t\t}else{\n\t\t\tprintf(\""Note '%s' is already encrypted\\n\"",search);\n\t\t}\n\t\tdb_result_free(result);\n\t\treturn r;\n\t}\n\n\t/* free the search result */\n\tdb_result_free(result);\n\n\t/* create the new entry */\n\tdb_insert(search,\""new entry\"");\n\n\tif (db_data.error_msg)\n\t\tfprintf(stderr,\""%s\\n\"",db_data.error_msg);\n\n\tcrypt = crypt_get_key();\n\t/* open for editing */\n\treturn db_edit(search);\n}"", ""caller_start"": 565, ""file_path"": ""src/db.c""}, {""call_line"": 635, ""call_code"": ""db_update(search,t)"", ""caller_code"": ""int db_decrypt(char* search)\n{\n\t/* search by name */\n\tsql_result *result;\n\tint r;\n\tresult = db_get(\""SELECT * FROM nodau WHERE name = '%s'\"",search);\n\n\t/* found the note */\n\tif (result->num_rows) {\n\t\tchar* text;\n\t\tchar* crypt;\n\n\t\t/* get the data */\n\t\ttext = result->data[COLUMN(0,COL_TEXT)];\n\t\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t\t/* decrypt it if it is encrypted */\n\t\tif (!strcmp(crypt,\""true\"")) {\n\t\t\tchar* t;\n\t\t\tcrypt = crypt_get_key();\n\t\t\tt = note_decrypt(text,crypt);\n\t\t\tif (!t)\n\t\t\t\treturn 1;\n\t\t\tfree(crypt_key);\n\t\t\tcrypt_key = NULL;\n\t\t\tr = db_update(search,t);\n\t\t\tdb_result_free(result);\n\t\t\treturn r;\n\t\t}else{\n\t\t\tprintf(\""Note '%s' is not encrypted\\n\"",search);\n\t\t\tdb_result_free(result);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tprintf(\""No notes matches '%s'\\n\"",search);\n\tdb_result_free(result);\n\n\treturn 0;\n}"", ""caller_start"": 610, ""file_path"": ""src/db.c""}, {""call_line"": 143, ""call_code"": ""db_update(name,buffer)"", ""caller_code"": ""static int edit_builtin(char* name, char* date, char* data)\n{\n\tchar buffer[256];\n\tint bl;\n\t/* still editing? */\n\tint quit = 0;\n\t/* character storage */\n\tint plch = 0;\n\tint lch = 0;\n\tint ch = 0;\n\n\t/* set the local data */\n\tbname = name;\n\tbdate = date;\n\t/* find the buffer length */\n\tbl = strlen(data);\n\t/* create the buffer */\n\t/* fill the buffer with 0's */\n\tmemset(&buffer,0,256);\n\n\t/* if the note is too long, shorten it */\n\tif (bl > 255) {\n\t\tdata[255] = 0;\n\t\tbl = 255;\n\t}\n\n\t/* put the note into the buffer */\n\tsprintf(buffer, \""%s\"", data);\n\n\t/* init ncurses */\n\tinitscr();\n\t/* no line buffering */\n\tcbreak();\n\t/* get all the keys */\n\tkeypad(stdscr, TRUE);\n\t/* don't echo keypresses */\n\tnoecho();\n\n\t/* while we are editing */\n\twhile (!quit) {\n\t\t/* draw the screen */\n\t\tdraw(buffer);\n\t\t/* set previous last char to last char */\n\t\tplch = lch;\n\t\t/* set last char to char */\n\t\tlch = ch;\n\t\t/* get char */\n\t\tch = getch();\n\t\t/* if it's printable or newline */\n\t\tif (isprint(ch) || ch == '\\n') {\n\t\t\tbl++;\n\t\t\t/* if the note is under 255 chars, add the char */\n\t\t\tif (bl < 255) {\n\t\t\t\tbuffer[bl-1] = ch;\n\t\t\t\tbuffer[bl] = 0;\n\t\t\t}\n\t\t/* backspace means delete a char */\n\t\t}else if (ch == 127 || ch == KEY_BACKSPACE) {\n\t\t\t/* if we've got one to delete */\n\t\t\tif (bl > 0) {\n\t\t\t\tbl--;\n\t\t\t\tbuffer[bl] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* check for newline dot exit */\n\t\tif (plch == '\\n' && lch == '.' && ch == '\\n') {\n\t\t\t/* don't include the dot in the note */\n\t\t\tbl -= 3;\n\t\t\tbuffer[bl] = 0;\n\t\t\tquit = 1;\n\t\t/* check for escape exit */\n\t\t}else if (ch == 27) {\n\t\t\tquit = 1;\n\t\t}\n\t}\n\n\t/* exit curses */\n\tendwin();\n\n\t/* save the note */\n\tif (!db_update(name,buffer))\n\t\treturn 1;\n\n\t/* let the user know */\n\tprintf(\""%s saved\\n\"",name);\n\n\treturn 0;\n}\n"", ""caller_start"": 62, ""file_path"": ""src/edit.c""}, {""call_line"": 196, ""call_code"": ""db_update(name,l)"", ""caller_code"": ""static int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\n\tstrcpy(buff,\""/tmp/nodau.XXXXXX\"");\n\tfd = mkstemp(buff);\n\n\tif (fd < 0)\n\t\treturn 1;\n\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\t/* find the file length */\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\t/* load the note into memory */\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\t/* delete the file */\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\t/* find the note data */\n\t\t\t\tl = strstr(b,\""-----\"");\n\t\t\t\tif (l) {\n\t\t\t\t\t/* save the note */\n\t\t\t\t\tl += 6;\n\t\t\t\t\tif (db_update(name,l))\n\t\t\t\t\t\treturn 1;\n\n\t\t\t\t\t/* let the user know */\n\t\t\t\t\tprintf(\""%s saved\\n\"",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\n\t/* insert data into file */\n\tsz = sprintf(\n\t\tb,\n\t\t\""%s (%s)\\nText above this line is ignored\\n-----\\n%s\"",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\n\tst = execl(editor,editor,buff,(char*)NULL);\n\n\t/* we should only ever get here if something goes wrong with exec */\n\texit(st);\n\n\t/* and we shouldn't ever get here, but it stops the compiler complaining */\n\treturn 1;\n}\n"", ""caller_start"": 153, ""file_path"": ""src/edit.c""}]}, {""source"": ""caller_info(file:db.c, func:db_encrypt)"", ""result"": [{""call_line"": 141, ""call_code"": ""db_encrypt(args)"", ""caller_code"": ""int main(int argc, char** argv)\n{\n\tchar* args;\n\t/* no option, print usage */\n\tif (argc < 2) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\n\tconfig_load();\n\n\t/* connect to the db or error */\n\tif (db_connect()) {\n\t\tfprintf(stderr, \""Can't open database: %s\\n\"", db_err());\n\t\tdb_close();\n\t\treturn 0;\n\t}\n\n\t/* compile the arguments */\n\targs = get_args(argc,argv);\n\n\t/* if listing notes */\n\tif (strcmp(argv[1],\""list\"") == 0) {\n\t\tdb_list(args);\n\t}else{\n\t\t/* if null argument print usage */\n\t\tif (args == NULL || argc <3) {\n\t\t\tusage();\n\t\t/* if creating a new note */\n\t\t}else if (strcmp(argv[1],\""new\"") == 0 || strcmp(argv[1],\""create\"") == 0) {\n\t\t\tdb_new(args);\n\t\t/* if opening/editing an existing note */\n\t\t}else if (strcmp(argv[1],\""open\"") == 0 || strcmp(argv[1],\""edit\"") == 0) {\n\t\t\tdb_edit(args);\n\t\t/* append to a note if data is on stdin */\n\t\t}else if (strcmp(argv[1],\""append\"") == 0) {\n\t\t\tif (isatty(STDIN_FILENO)) {\n\t\t\t\tdb_edit(args);\n\t\t\t}else{\n\t\t\t\tdb_append(args);\n\t\t\t}\n\t\t/* encrypt a new or existing note */\n\t\t}else if (strcmp(argv[1],\""encrypt\"") == 0) {\n\t\t\tdb_encrypt(args);\n\t\t/* decrypt an existing note */\n\t\t}else if (strcmp(argv[1],\""decrypt\"") == 0) {\n\t\t\tdb_decrypt(args);\n\t\t/* display an existing note */\n\t\t}else if (strcmp(argv[1],\""show\"") == 0) {\n\t\t\tdb_show(args);\n\t\t/* if deleting note/s */\n\t\t}else if (strcmp(argv[1],\""del\"") == 0) {\n\t\t\tdb_del(args);\n\t\t/* unknown option, print usage */\n\t\t}else{\n\t\t\tusage();\n\t\t}\n\t}\n\n\t/* free args if we can */\n\tif (args != NULL)\n\t\tfree(args);\n\n\t/* close the database */\n\tdb_close();\n\n\t/* save config */\n\tconfig_save();\n\n\treturn 0;\n}\n"", ""caller_start"": 98, ""file_path"": ""src/nodau.c""}]}, {""source"": ""caller_info(file:db.c, func:db_decrypt)"", ""result"": [{""call_line"": 144, ""call_code"": ""db_decrypt(args)"", ""caller_code"": ""int main(int argc, char** argv)\n{\n\tchar* args;\n\t/* no option, print usage */\n\tif (argc < 2) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\n\tconfig_load();\n\n\t/* connect to the db or error */\n\tif (db_connect()) {\n\t\tfprintf(stderr, \""Can't open database: %s\\n\"", db_err());\n\t\tdb_close();\n\t\treturn 0;\n\t}\n\n\t/* compile the arguments */\n\targs = get_args(argc,argv);\n\n\t/* if listing notes */\n\tif (strcmp(argv[1],\""list\"") == 0) {\n\t\tdb_list(args);\n\t}else{\n\t\t/* if null argument print usage */\n\t\tif (args == NULL || argc <3) {\n\t\t\tusage();\n\t\t/* if creating a new note */\n\t\t}else if (strcmp(argv[1],\""new\"") == 0 || strcmp(argv[1],\""create\"") == 0) {\n\t\t\tdb_new(args);\n\t\t/* if opening/editing an existing note */\n\t\t}else if (strcmp(argv[1],\""open\"") == 0 || strcmp(argv[1],\""edit\"") == 0) {\n\t\t\tdb_edit(args);\n\t\t/* append to a note if data is on stdin */\n\t\t}else if (strcmp(argv[1],\""append\"") == 0) {\n\t\t\tif (isatty(STDIN_FILENO)) {\n\t\t\t\tdb_edit(args);\n\t\t\t}else{\n\t\t\t\tdb_append(args);\n\t\t\t}\n\t\t/* encrypt a new or existing note */\n\t\t}else if (strcmp(argv[1],\""encrypt\"") == 0) {\n\t\t\tdb_encrypt(args);\n\t\t/* decrypt an existing note */\n\t\t}else if (strcmp(argv[1],\""decrypt\"") == 0) {\n\t\t\tdb_decrypt(args);\n\t\t/* display an existing note */\n\t\t}else if (strcmp(argv[1],\""show\"") == 0) {\n\t\t\tdb_show(args);\n\t\t/* if deleting note/s */\n\t\t}else if (strcmp(argv[1],\""del\"") == 0) {\n\t\t\tdb_del(args);\n\t\t/* unknown option, print usage */\n\t\t}else{\n\t\t\tusage();\n\t\t}\n\t}\n\n\t/* free args if we can */\n\tif (args != NULL)\n\t\tfree(args);\n\n\t/* close the database */\n\tdb_close();\n\n\t/* save config */\n\tconfig_save();\n\n\treturn 0;\n}\n"", ""caller_start"": 98, ""file_path"": ""src/nodau.c""}]}, {""source"": ""value_info(file:db.c, value:text)"", ""result"": {""value_trace"": [{""full_code"": ""text = result->data[COLUMN(0,COL_TEXT)]"", ""line"": 389, ""func_name"": ""db_edit""}, {""full_code"": ""text = note_decrypt(text,crypt)"", ""line"": 395, ""func_name"": ""db_edit""}, {""full_code"": ""text = result->data[COLUMN(0,COL_TEXT)]"", ""line"": 430, ""func_name"": ""db_append""}, {""full_code"": ""text = note_decrypt(text,crypt)"", ""line"": 436, ""func_name"": ""db_append""}, {""full_code"": ""text = result->data[COLUMN(0,COL_TEXT)]"", ""line"": 471, ""func_name"": ""db_show""}], ""struct_var"": ""text"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""caller_info(file:db.c, func:db_new)"", ""result"": [{""call_line"": 381, ""call_code"": ""db_new(search)"", ""caller_code"": ""int db_edit(char* search)\n{\n\tchar* date;\n\tchar* name;\n\tchar* text;\n\tchar* crypt;\n\tint r;\n\t/* get the note by name */\n\tsql_result *result;\n\tresult = db_get(\""SELECT * FROM nodau WHERE name = '%s'\"",search);\n\n\t/* nothing there */\n\tif (result->num_rows == 0) {\n\t\tdb_result_free(result);\n\t\tif (config_read(\""edit_autocreate\"",\""false\"")) {\n\t\t\tprintf(\""No notes match '%s'\\n\"",search);\n\t\t}else{\n\t\t\t return db_new(search);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* get the data */\n\tdate = db_gettime(result->data[COLUMN(0,COL_DATE)]);\n\tname = result->data[COLUMN(0,COL_NAME)];\n\ttext = result->data[COLUMN(0,COL_TEXT)];\n\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t/* get the passphrase if it's encrypted */\n\tif (!strcmp(crypt,\""true\"")) {\n\t\tcrypt = crypt_get_key();\n\t\ttext = note_decrypt(text,crypt);\n\t\tif (!text)\n\t\t\treturn 1;\n\t}\n\n\t/* edit the note */\n\tr = edit(name, date, text);\n\n\t/* free the result */\n\tdb_result_free(result);\n\n\treturn r;\n}"", ""caller_start"": 364, ""file_path"": ""src/db.c""}, {""call_line"": 424, ""call_code"": ""db_new(search)"", ""caller_code"": ""int db_append(char* search)\n{\n\tchar* date;\n\tchar* name;\n\tchar* text;\n\tchar* crypt;\n\tint r;\n\t/* get the note by name */\n\tsql_result *result;\n\tresult = db_get(\""SELECT * FROM nodau WHERE name = '%s'\"",search);\n\n\t/* nothing there */\n\tif (result->num_rows == 0) {\n\t\tdb_result_free(result);\n\t\treturn db_new(search);\n\t}\n\n\t/* get the data */\n\tdate = db_gettime(result->data[COLUMN(0,COL_DATE)]);\n\tname = result->data[COLUMN(0,COL_NAME)];\n\ttext = result->data[COLUMN(0,COL_TEXT)];\n\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t/* get the passphrase if it's encrypted */\n\tif (!strcmp(crypt,\""true\"")) {\n\t\tcrypt = crypt_get_key();\n\t\ttext = note_decrypt(text,crypt);\n\t\tif (!text)\n\t\t\treturn 1;\n\t}\n\n\t/* edit the note */\n\tr = edit_stdin(name, date, text,1);\n\n\t/* free the result */\n\tdb_result_free(result);\n\n\treturn r;\n}"", ""caller_start"": 410, ""file_path"": ""src/db.c""}, {""call_line"": 128, ""call_code"": ""db_new(args)"", ""caller_code"": ""int main(int argc, char** argv)\n{\n\tchar* args;\n\t/* no option, print usage */\n\tif (argc < 2) {\n\t\tusage();\n\t\treturn 0;\n\t}\n\n\tconfig_load();\n\n\t/* connect to the db or error */\n\tif (db_connect()) {\n\t\tfprintf(stderr, \""Can't open database: %s\\n\"", db_err());\n\t\tdb_close();\n\t\treturn 0;\n\t}\n\n\t/* compile the arguments */\n\targs = get_args(argc,argv);\n\n\t/* if listing notes */\n\tif (strcmp(argv[1],\""list\"") == 0) {\n\t\tdb_list(args);\n\t}else{\n\t\t/* if null argument print usage */\n\t\tif (args == NULL || argc <3) {\n\t\t\tusage();\n\t\t/* if creating a new note */\n\t\t}else if (strcmp(argv[1],\""new\"") == 0 || strcmp(argv[1],\""create\"") == 0) {\n\t\t\tdb_new(args);\n\t\t/* if opening/editing an existing note */\n\t\t}else if (strcmp(argv[1],\""open\"") == 0 || strcmp(argv[1],\""edit\"") == 0) {\n\t\t\tdb_edit(args);\n\t\t/* append to a note if data is on stdin */\n\t\t}else if (strcmp(argv[1],\""append\"") == 0) {\n\t\t\tif (isatty(STDIN_FILENO)) {\n\t\t\t\tdb_edit(args);\n\t\t\t}else{\n\t\t\t\tdb_append(args);\n\t\t\t}\n\t\t/* encrypt a new or existing note */\n\t\t}else if (strcmp(argv[1],\""encrypt\"") == 0) {\n\t\t\tdb_encrypt(args);\n\t\t/* decrypt an existing note */\n\t\t}else if (strcmp(argv[1],\""decrypt\"") == 0) {\n\t\t\tdb_decrypt(args);\n\t\t/* display an existing note */\n\t\t}else if (strcmp(argv[1],\""show\"") == 0) {\n\t\t\tdb_show(args);\n\t\t/* if deleting note/s */\n\t\t}else if (strcmp(argv[1],\""del\"") == 0) {\n\t\t\tdb_del(args);\n\t\t/* unknown option, print usage */\n\t\t}else{\n\t\t\tusage();\n\t\t}\n\t}\n\n\t/* free args if we can */\n\tif (args != NULL)\n\t\tfree(args);\n\n\t/* close the database */\n\tdb_close();\n\n\t/* save config */\n\tconfig_save();\n\n\treturn 0;\n}\n"", ""caller_start"": 98, ""file_path"": ""src/nodau.c""}]}, {""source"": ""value_info(file:db.c, value:text)"", ""result"": {""value_trace"": [{""full_code"": ""text = result->data[COLUMN(0,COL_TEXT)]"", ""line"": 389, ""func_name"": ""db_edit""}, {""full_code"": ""text = note_decrypt(text,crypt)"", ""line"": 395, ""func_name"": ""db_edit""}, {""full_code"": ""text = result->data[COLUMN(0,COL_TEXT)]"", ""line"": 430, ""func_name"": ""db_append""}, {""full_code"": ""text = note_decrypt(text,crypt)"", ""line"": 436, ""func_name"": ""db_append""}, {""full_code"": ""text = result->data[COLUMN(0,COL_TEXT)]"", ""line"": 471, ""func_name"": ""db_show""}], ""struct_var"": ""text"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}]","src/db.c: Vulnerable code used `asprintf` to directly insert 'name' (user-controlled via command-line/search) and 'value' (user-controlled via editor input) into SQL strings in `db_update` (lines 286-305). 'name' is passed from `db_encrypt`/`db_decrypt` (src/db.c:586,635) and `edit_ext`/`edit_builtin` (src/edit.c:143,196), which derive from command-line arguments (src/nodau.c:141-144). 'value' originates from `note_encrypt` (src/db.c:287) and user-provided `buffer`/`l` in edit functions. Patch replaces this with parameterized queries (lines 286-305).",0.95,./github/other_context/CVE-2022-4399
55,CVE-2022-43550,CWE-77,java,A command injection vulnerability exists in Jitsi before commit 8aa7be58522f4264078d54752aae5483bfd854b2 when launching browsers on Windows which could allow an attacker to insert an arbitrary URL which opens up the opportunity to remote execution.,https://github.com/jitsi/jitsi/commit/8aa7be58522f4264078d54752aae5483bfd854b2,Adds a check for valid http link when opening a browser.,1,"[{""func_name"": ""openURL"", ""file_path"": ""modules/service/browserlauncher/src/main/java/net/java/sip/communicator/impl/browserlauncher/BrowserLauncherImpl.java"", ""func_code"": ""public void openURL(final String url)\n    {\n        Thread launchBrowserThread\n            = new Thread(getClass().getName())\n                    {\n                        @Override\n                        public void run()\n                        {\n                            try\n                            {\n                                launchBrowser(url);\n                            }\n                            catch (Exception e)\n                            {\n                                logger.error(\""Failed to launch browser\"", e);\n                            }\n                        }\n                    };\n\n        launchBrowserThread.start();\n    }"", ""target"": 0}]","[{""func_name"": ""openURL"", ""file_path"": ""modules/service/browserlauncher/src/main/java/net/java/sip/communicator/impl/browserlauncher/BrowserLauncherImpl.java"", ""func_code"": ""public void openURL(final String url)\n    {\n        if (url == null || !url.startsWith(\""http\""))\n        {\n            logger.warn(\""Not a valid URL to open:\"" + url);\n            return;\n        }\n        Thread launchBrowserThread\n            = new Thread(getClass().getName())\n                    {\n                        @Override\n                        public void run()\n                        {\n                            try\n                            {\n                                launchBrowser(url);\n                            }\n                            catch (Exception e)\n                            {\n                                logger.error(\""Failed to launch browser\"", e);\n                            }\n                        }\n                    };\n\n        launchBrowserThread.start();\n    }""}]","{""caller"": 1, ""value"": 10, ""function"": 2}","[{""source"": ""caller_info(file:BrowserLauncherImpl.java, func:openURL)"", ""result"": [{""call_line"": 1261, ""call_code"": ""getBrowserLauncher().openURL(currentHref)"", ""caller_code"": ""    public void mouseClicked(MouseEvent e)\n    {\n        Point p = e.getPoint();\n        SwingUtilities.convertPointToScreen(p, e.getComponent());\n\n        if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0\n            || (e.isControlDown() && !e.isMetaDown()))\n        {\n            openContextMenu(p);\n        }\n        else if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0\n            && currentHref != null && currentHref.length() != 0)\n        {\n            URI uri;\n            try\n            {\n                uri = new URI(currentHref);\n            }\n            catch (URISyntaxException e1)\n            {\n                logger.error(\""Failed to open hyperlink in chat window. \"" +\n                        \""Error was: Invalid URL - \"" + currentHref);\n                return;\n            }\n            if(\""jitsi\"".equals(uri.getScheme()))\n            {\n                for(ChatLinkClickedListener l:chatLinkClickedListeners)\n                {\n                    l.chatLinkClicked(uri);\n                }\n            }\n            else\n                GuiActivator.getBrowserLauncher().openURL(currentHref);\n\n            // after opening the link remove the currentHref to avoid\n            // clicking on the window to gain focus to open the link again\n            this.currentHref = \""\"";\n        }\n    }\n"", ""caller_start"": 1229, ""file_path"": ""modules/impl/gui/src/main/java/net/java/sip/communicator/impl/gui/main/chat/ChatConversationPanel.java""}, {""call_line"": 359, ""call_code"": ""getBrowserLauncher().openURL(currentHref)"", ""caller_code"": ""    public ChatConversationPanel(ChatConversationContainer chatContainer)\n    {\n        editorKit = new ChatConversationEditorKit(this);\n\n        this.chatContainer = chatContainer;\n\n        isHistory = (chatContainer instanceof HistoryWindow);\n\n        this.rightButtonMenu = new ChatRightButtonMenu(this);\n\n        this.document = (HTMLDocument) editorKit.createDefaultDocument();\n\n        this.document.addDocumentListener(editorKit);\n\n        this.chatTextPane.setEditorKitForContentType(\""text/html\"", editorKit);\n        this.chatTextPane.setEditorKit(editorKit);\n        this.chatTextPane.setEditable(false);\n        this.chatTextPane.setDocument(document);\n        this.chatTextPane.setDragEnabled(true);\n\n        chatTextPane.putClientProperty(\n            JEditorPane.HONOR_DISPLAY_PROPERTIES, Boolean.TRUE);\n        Constants.loadSimpleStyle(\n            document.getStyleSheet(), chatTextPane.getFont());\n\n        this.chatTextPane.addHyperlinkListener(this);\n        this.chatTextPane.addMouseListener(this);\n        this.chatTextPane.setCursor(\n            Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));\n\n        this.addChatLinkClickedListener(showPreview);\n\n        this.setWheelScrollingEnabled(true);\n\n        this.setViewportView(chatTextPane);\n\n        this.setBorder(null);\n\n        this.setHorizontalScrollBarPolicy(\n            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\n        ToolTipManager.sharedInstance().registerComponent(chatTextPane);\n\n        String copyLinkString\n            = GuiActivator.getResources().getI18NString(\""service.gui.COPY_LINK\"");\n\n        copyLinkItem\n            = new JMenuItem(copyLinkString,\n                new ImageIcon(ImageLoader.getImage(ImageLoader.COPY_ICON)));\n\n        copyLinkItem.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                StringSelection stringSelection = new StringSelection(\n                    currentHref);\n                Clipboard clipboard = Toolkit.getDefaultToolkit()\n                    .getSystemClipboard();\n                clipboard.setContents(stringSelection,\n                    ChatConversationPanel.this);\n            }\n        });\n\n        String openLinkString\n            = GuiActivator.getResources().getI18NString(\n                \""service.gui.OPEN_IN_BROWSER\"");\n\n        openLinkItem =\n            new JMenuItem(\n                openLinkString,\n                new ImageIcon(ImageLoader.getImage(ImageLoader.BROWSER_ICON)));\n\n        openLinkItem.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                GuiActivator.getBrowserLauncher().openURL(currentHref);\n\n                // after opening the link remove the currentHref to avoid\n                // clicking on the window to gain focus to open the link again\n                ChatConversationPanel.this.currentHref = \""\"";\n            }\n        });\n\n        openLinkItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n                \""service.gui.OPEN_IN_BROWSER\""));\n\n        copyLinkItem.setMnemonic(\n            GuiActivator.getResources().getI18nMnemonic(\n                \""service.gui.COPY_LINK\""));\n\n        configureReplacementItem = new JMenuItem(\n            GuiActivator.getResources().getI18NString(\n                \""plugin.chatconfig.replacement.CONFIGURE_REPLACEMENT\""),\n            GuiActivator.getResources().getImage(\n                \""service.gui.icons.CONFIGURE_ICON\""));\n\n        configureReplacementItem.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                final ConfigurationContainer configContainer\n                    = GuiActivator.getUIService().getConfigurationContainer();\n\n                ConfigurationForm chatConfigForm = getChatConfigForm();\n\n                if (chatConfigForm != null)\n                {\n                    configContainer.setSelected(chatConfigForm);\n\n                    configContainer.setVisible(true);\n                }\n            }\n        });\n\n        this.isSimpleTheme = ConfigurationUtils.isChatSimpleThemeEnabled();\n\n        /*\n         * When we append a new message (regardless of whether it is a string or\n         * an UI component), we want to make it visible in the viewport of this\n         * JScrollPane so that the user can see it.\n         */\n        ComponentListener componentListener = new ComponentAdapter()\n        {\n            @Override\n            public void componentResized(ComponentEvent e)\n            {\n                synchronized (scrollToBottomRunnable)\n                {\n                    if (!scrollToBottomIsPending)\n                        return;\n                    scrollToBottomIsPending = false;\n\n                    /*\n                     * Yana Stamcheva, pointed out that Java 5 (on Linux only?)\n                     * needs invokeLater for JScrollBar.\n                     */\n                    SwingUtilities.invokeLater(scrollToBottomRunnable);\n                }\n            }\n        };\n\n        chatTextPane.addComponentListener(componentListener);\n        getViewport().addComponentListener(componentListener);\n    }\n"", ""caller_start"": 283, ""file_path"": ""modules/impl/gui/src/main/java/net/java/sip/communicator/impl/gui/main/chat/ChatConversationPanel.java""}, {""call_line"": 1891, ""call_code"": ""getBrowserLauncher().openURL(urlDetails.get(0))"", ""caller_code"": ""    private static void openURL(\n        TreeContactList treeContactList, TreeNode treeNode, JButton button)\n    {\n        if (treeNode != null && treeNode instanceof ContactNode)\n        {\n            UIContact contactDescriptor\n                = ((ContactNode) treeNode).getContactDescriptor();\n\n            List<String> urlDetails = null;\n\n            if (contactDescriptor instanceof MetaUIContact)\n            {\n                List<URLDetail> details =\n                    getURLDetails(contactDescriptor, null, false);\n\n                if(details == null)\n                    return;\n\n                urlDetails = new ArrayList<String>();\n\n                Iterator<URLDetail> detailIterator = details.iterator();\n                while(detailIterator.hasNext())\n                {\n                    final URLDetail wd = detailIterator.next();\n                    urlDetails.add(wd.getDetailValue().toString());\n                }\n            }\n            else if (contactDescriptor.getDescriptor()\n                instanceof SourceContact)\n            {\n                SourceContact src =\n                    (SourceContact)contactDescriptor.getDescriptor();\n                try\n                {\n                    List<ContactDetail> cDetails  =\n                        src.getContactDetails(ContactDetail.Category.Web);\n\n                    if(cDetails == null)\n                        return;\n\n                    urlDetails = new ArrayList<String>();\n\n                    for(ContactDetail det : cDetails)\n                    {\n                        urlDetails.add(det.getDetail());\n                    }\n                }\n                catch(OperationNotSupportedException onse)\n                {}\n            }\n\n            if(urlDetails == null)\n                return;\n\n            if(urlDetails.size() == 1)\n            {\n                GuiActivator.getBrowserLauncher().openURL(urlDetails.get(0));\n            }\n            else\n            {\n                Point location = new Point(button.getX(),\n                    button.getY() + button.getHeight());\n\n                SwingUtilities.convertPointToScreen(\n                    location, treeContactList);\n\n                location.y = location.y\n                    + treeContactList.getPathBounds(\n                            treeContactList.getSelectionPath()).y;\n                location.x += 8;\n                location.y -= 8;\n\n                List<JMenuItem> items = new ArrayList<JMenuItem>();\n                Iterator<String> detailIterator = urlDetails.iterator();\n                while(detailIterator.hasNext())\n                {\n                    String url = detailIterator.next();\n\n                    String displayStr = url;\n                    // do not display too long links\n                    if(displayStr.length() > 60)\n                    {\n                        displayStr = displayStr.substring(0, 60);\n                        displayStr += \""...\"";\n                    }\n                    final JMenuItem menuItem = new JMenuItem(displayStr);\n                    menuItem.setName(url);\n                    menuItem.setToolTipText(url);\n\n                    menuItem.addActionListener(new ActionListener()\n                    {\n                        public void actionPerformed(ActionEvent e)\n                        {\n                            GuiActivator.getBrowserLauncher().openURL(\n                                menuItem.getName());\n                        }\n                    });\n                    items.add(menuItem);\n                }\n\n                new ExtendedPopupMenu(\n                        treeContactList,\n                        null,\n                        items).showPopupMenu(location.x, location.y);\n            }\n        }\n    }\n"", ""caller_start"": 1835, ""file_path"": ""modules/impl/gui/src/main/java/net/java/sip/communicator/impl/gui/main/contactlist/ContactListTreeCellRenderer.java""}, {""call_line"": 1928, ""call_code"": ""getBrowserLauncher().openURL(menuItem.getName())"", ""caller_code"": ""    private static void openURL(\n        TreeContactList treeContactList, TreeNode treeNode, JButton button)\n    {\n        if (treeNode != null && treeNode instanceof ContactNode)\n        {\n            UIContact contactDescriptor\n                = ((ContactNode) treeNode).getContactDescriptor();\n\n            List<String> urlDetails = null;\n\n            if (contactDescriptor instanceof MetaUIContact)\n            {\n                List<URLDetail> details =\n                    getURLDetails(contactDescriptor, null, false);\n\n                if(details == null)\n                    return;\n\n                urlDetails = new ArrayList<String>();\n\n                Iterator<URLDetail> detailIterator = details.iterator();\n                while(detailIterator.hasNext())\n                {\n                    final URLDetail wd = detailIterator.next();\n                    urlDetails.add(wd.getDetailValue().toString());\n                }\n            }\n            else if (contactDescriptor.getDescriptor()\n                instanceof SourceContact)\n            {\n                SourceContact src =\n                    (SourceContact)contactDescriptor.getDescriptor();\n                try\n                {\n                    List<ContactDetail> cDetails  =\n                        src.getContactDetails(ContactDetail.Category.Web);\n\n                    if(cDetails == null)\n                        return;\n\n                    urlDetails = new ArrayList<String>();\n\n                    for(ContactDetail det : cDetails)\n                    {\n                        urlDetails.add(det.getDetail());\n                    }\n                }\n                catch(OperationNotSupportedException onse)\n                {}\n            }\n\n            if(urlDetails == null)\n                return;\n\n            if(urlDetails.size() == 1)\n            {\n                GuiActivator.getBrowserLauncher().openURL(urlDetails.get(0));\n            }\n            else\n            {\n                Point location = new Point(button.getX(),\n                    button.getY() + button.getHeight());\n\n                SwingUtilities.convertPointToScreen(\n                    location, treeContactList);\n\n                location.y = location.y\n                    + treeContactList.getPathBounds(\n                            treeContactList.getSelectionPath()).y;\n                location.x += 8;\n                location.y -= 8;\n\n                List<JMenuItem> items = new ArrayList<JMenuItem>();\n                Iterator<String> detailIterator = urlDetails.iterator();\n                while(detailIterator.hasNext())\n                {\n                    String url = detailIterator.next();\n\n                    String displayStr = url;\n                    // do not display too long links\n                    if(displayStr.length() > 60)\n                    {\n                        displayStr = displayStr.substring(0, 60);\n                        displayStr += \""...\"";\n                    }\n                    final JMenuItem menuItem = new JMenuItem(displayStr);\n                    menuItem.setName(url);\n                    menuItem.setToolTipText(url);\n\n                    menuItem.addActionListener(new ActionListener()\n                    {\n                        public void actionPerformed(ActionEvent e)\n                        {\n                            GuiActivator.getBrowserLauncher().openURL(\n                                menuItem.getName());\n                        }\n                    });\n                    items.add(menuItem);\n                }\n\n                new ExtendedPopupMenu(\n                        treeContactList,\n                        null,\n                        items).showPopupMenu(location.x, location.y);\n            }\n        }\n    }\n"", ""caller_start"": 1835, ""file_path"": ""modules/impl/gui/src/main/java/net/java/sip/communicator/impl/gui/main/contactlist/ContactListTreeCellRenderer.java""}]}, {""source"": ""value_info(value:url)"", ""result"": {""value_trace"": [{""full_code"": ""URL url = new URL(urlString)"", ""line"": 174, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.ChatTransferHandler.importData:boolean(javax.swing.JComponent,java.awt.datatransfer.Transferable)""}, {""full_code"": ""String url = m.group().trim()"", ""line"": 83, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.replacers.URLReplacer.replace:void(java.lang.StringBuilder,java.lang.String)""}, {""full_code"": ""String url = detailIterator.next()"", ""line"": 1911, ""func_name"": ""net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.openURL:void(net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList,javax.swing.tree.TreeNode,javax.swing.JButton)""}, {""full_code"": ""String url = chooseOpenH264URL()"", ""line"": 354, ""func_name"": ""net.java.sip.communicator.impl.neomedia.codec.video.h264.OpenH264Retriever.downloadInNewThread.Thread$0.run:void()""}, {""full_code"": ""String url = discoverProvisioningURL()"", ""line"": 239, ""func_name"": ""net.java.sip.communicator.impl.provdisc.dhcp.DHCPProvisioningDiscover.run:void()""}], ""struct_var"": ""url"", ""struct_type"": ""java.net.URL"", ""struct_definition"": null}}, {""source"": ""value_info(file:ChatConversationPanel.java, value:currentHref)"", ""result"": {""value_trace"": [{""full_code"": ""this.currentHref = href"", ""line"": 1192, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.hyperlinkUpdate:void(javax.swing.event.HyperlinkEvent)""}, {""full_code"": ""this.currentHref = \""\"""", ""line"": 1196, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.hyperlinkUpdate:void(javax.swing.event.HyperlinkEvent)""}, {""full_code"": ""this.currentHref = \""\"""", ""line"": 1265, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.mouseClicked:void(java.awt.event.MouseEvent)""}, {""full_code"": ""ChatConversationPanel.this.currentHref = \""\"""", ""line"": 363, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.<init>.ActionListener$1.actionPerformed:void(java.awt.event.ActionEvent)""}], ""struct_var"": ""currentHref"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:ContactListTreeCellRenderer.java, value:urlDetails)"", ""result"": {""value_trace"": [{""full_code"": ""List urlDetails = null"", ""line"": 1843, ""func_name"": ""net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.openURL:void(net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList,javax.swing.tree.TreeNode,javax.swing.JButton)""}, {""full_code"": ""urlDetails = new ArrayList<String>()"", ""line"": 1853, ""func_name"": ""net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.openURL:void(net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList,javax.swing.tree.TreeNode,javax.swing.JButton)""}, {""full_code"": ""urlDetails = new ArrayList<String>()"", ""line"": 1875, ""func_name"": ""net.java.sip.communicator.impl.gui.main.contactlist.ContactListTreeCellRenderer.openURL:void(net.java.sip.communicator.impl.gui.main.contactlist.TreeContactList,javax.swing.tree.TreeNode,javax.swing.JButton)""}], ""struct_var"": ""urlDetails"", ""struct_type"": ""java.util.List"", ""struct_definition"": null}}, {""source"": ""value_info(file:ChatConversationPanel.java, value:href)"", ""result"": {""value_trace"": [{""full_code"": ""String href = e.getDescription()"", ""line"": 1188, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.hyperlinkUpdate:void(javax.swing.event.HyperlinkEvent)""}], ""struct_var"": ""href"", ""struct_type"": ""java.lang.String"", ""struct_definition"": null}}, {""source"": ""value_info(file:ContactListTreeCellRenderer.java, value:ContactDetail)"", ""result"": {""value_trace"": [{""full_code"": ""uiContactDetailList = contactPhoneUtil.getAdditionalNumbers()"", ""line"": 1690, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.ChatPanel.sendSmsMessage:void()""}, {""full_code"": ""uiContactDetailList = contactPhoneUtil.getAdditionalMobileNumbers()"", ""line"": 1693, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.ChatPanel.sendSmsMessage:void()""}, {""full_code"": ""long ChooseUIContactDetailPopupMenu$ContactMenuItem.serialVersionUID = 0L"", ""line"": 182, ""func_name"": ""net.java.sip.communicator.impl.gui.main.contactlist.ChooseUIContactDetailPopupMenu$ContactMenuItem.<clinit>:void()""}, {""full_code"": ""long ChooseUIContactDetailPopupMenu.serialVersionUID = 0L"", ""line"": 50, ""func_name"": ""net.java.sip.communicator.impl.gui.main.contactlist.ChooseUIContactDetailPopupMenu.<clinit>:void()""}, {""full_code"": ""outlookContactDetail = (MsOutlookAddrBookContactDetail) contactDetail"", ""line"": 119, ""func_name"": ""net.java.sip.communicator.plugin.addrbook.msoutlook.MsOutlookAddrBookSourceContact.save:void()""}], ""struct_var"": ""ContactDetail"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:ChatConversationPanel.java, value:href)"", ""result"": {""value_trace"": [{""full_code"": ""String href = e.getDescription()"", ""line"": 1188, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.hyperlinkUpdate:void(javax.swing.event.HyperlinkEvent)""}], ""struct_var"": ""href"", ""struct_type"": ""java.lang.String"", ""struct_definition"": null}}, {""source"": ""func_info(func:getDetail)"", ""result"": [{""code"": ""    public String getDetail()\n    {\n        return contactDetailValue;\n    }\n"", ""start_line"": 556, ""end_line"": 559, ""full_name"": ""net.java.sip.communicator.service.contactsource.ContactDetail.getDetail:java.lang.String()"", ""file_path"": ""modules/service/contactsource/src/main/java/net/java/sip/communicator/service/contactsource/ContactDetail.java""}]}, {""source"": ""value_info(file:ChatConversationPanel.java, value:href)"", ""result"": {""value_trace"": [{""full_code"": ""String href = e.getDescription()"", ""line"": 1188, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.hyperlinkUpdate:void(javax.swing.event.HyperlinkEvent)""}], ""struct_var"": ""href"", ""struct_type"": ""java.lang.String"", ""struct_definition"": null}}, {""source"": ""value_info(file:ContactDetail.java, value:contactDetailValue)"", ""result"": {""value_trace"": [{""full_code"": ""this.contactDetailValue = contactDetailValue"", ""line"": 436, ""func_name"": ""net.java.sip.communicator.service.contactsource.ContactDetail.<init>:void(java.lang.String,java.lang.String,net.java.sip.communicator.service.contactsource.ContactDetail$Category,net.java.sip.communicator.service.contactsource.ContactDetail$SubCategory[])""}, {""full_code"": ""this.contactDetailValue = value"", ""line"": 83, ""func_name"": ""net.java.sip.communicator.service.contactsource.EditableContactDetail.setDetail:void(java.lang.String)""}], ""struct_var"": ""contactDetailValue"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:ChatConversationPanel.java, value:href)"", ""result"": {""value_trace"": [{""full_code"": ""String href = e.getDescription()"", ""line"": 1188, ""func_name"": ""net.java.sip.communicator.impl.gui.main.chat.ChatConversationPanel.hyperlinkUpdate:void(javax.swing.event.HyperlinkEvent)""}], ""struct_var"": ""href"", ""struct_type"": ""java.lang.String"", ""struct_definition"": null}}, {""source"": ""value_info(file:ContactDetail.java, value:contactDetailValue)"", ""result"": {""value_trace"": [{""full_code"": ""this.contactDetailValue = contactDetailValue"", ""line"": 436, ""func_name"": ""net.java.sip.communicator.service.contactsource.ContactDetail.<init>:void(java.lang.String,java.lang.String,net.java.sip.communicator.service.contactsource.ContactDetail$Category,net.java.sip.communicator.service.contactsource.ContactDetail$SubCategory[])""}, {""full_code"": ""this.contactDetailValue = value"", ""line"": 83, ""func_name"": ""net.java.sip.communicator.service.contactsource.EditableContactDetail.setDetail:void(java.lang.String)""}], ""struct_var"": ""contactDetailValue"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:getDetail)"", ""result"": [{""code"": ""    public String getDetail()\n    {\n        return contactDetailValue;\n    }\n"", ""start_line"": 556, ""end_line"": 559, ""full_name"": ""net.java.sip.communicator.service.contactsource.ContactDetail.getDetail:java.lang.String()"", ""file_path"": ""modules/service/contactsource/src/main/java/net/java/sip/communicator/service/contactsource/ContactDetail.java""}]}]","BrowserLauncherImpl.java:1836-1840: Missing validation of `url` input allowed arbitrary URLs to be processed. Callers in ChatConversationPanel.java:1261/359 set `currentHref` from `href` (HyperlinkEvent.getDescription()), and ContactListTreeCellRenderer.java:1891/1928 pass `urlDetails.get(0)` derived from `ContactDetail.getDetail():556` (ContactDetail.java:436/83). These values originate from user-controlled inputs (e.g., chat hyperlinks or contact details) without sanitization, enabling command injection when passed to `openURL`. Patch added 'http' prefix check, but pre-existing logic allowed unsanitized URLs to trigger browser launch.",0.95,./github/other_context/CVE-2022-43550
56,CVE-2022-4904,CWE-1284,c_cpp,"A flaw was found in the c-ares package. The ares_set_sortlist is missing checks about the validity of the input string, which allows a possible arbitrary length stack overflow. This issue may cause a denial of service or a limited impact on confidentiality and integrity.",https://github.com/c-ares/c-ares/commit/ac596026e77244481fd68736ae7f15855803a08a,"Add str len check in config_sortlist to avoid stack overflow\n\nIn ares_set_sortlist, it calls config_sortlist(..., sortstr) to parse\nthe input str and initialize a sortlist configuration.\n\nHowever, ares_set_sortlist has not any checks about the validity of the input str.\nIt is very easy to create an arbitrary length stack overflow with the unchecked\n`memcpy(ipbuf, str, q-str);` and `memcpy(ipbufpfx, str, q-str);`\nstatements in the config_sortlist call, which could potentially cause severe\nsecurity impact in practical programs.\n\nThis commit add necessary check for `ipbuf` and `ipbufpfx` which avoid the\npotential stack overflows.\n\nfixes #496\n\nSigned-off-by: hopper-vul <hopper.vul@gmail.com>",1,"[{""func_name"": ""config_sortlist"", ""file_path"": ""src/lib/ares_init.c"", ""func_code"": ""static int config_sortlist(struct apattern **sortlist, int *nsort,\n                           const char *str)\n{\n  struct apattern pat;\n  const char *q;\n\n  /* Add sortlist entries. */\n  while (*str && *str != ';')\n    {\n      int bits;\n      char ipbuf[16], ipbufpfx[32];\n      /* Find just the IP */\n      q = str;\n      while (*q && *q != '/' && *q != ';' && !ISSPACE(*q))\n        q++;\n      memcpy(ipbuf, str, q-str);\n      ipbuf[q-str] = '\\0';\n      /* Find the prefix */\n      if (*q == '/')\n        {\n          const char *str2 = q+1;\n          while (*q && *q != ';' && !ISSPACE(*q))\n            q++;\n          memcpy(ipbufpfx, str, q-str);\n          ipbufpfx[q-str] = '\\0';\n          str = str2;\n        }\n      else\n        ipbufpfx[0] = '\\0';\n      /* Lets see if it is CIDR */\n      /* First we'll try IPv6 */\n      if ((bits = ares_inet_net_pton(AF_INET6, ipbufpfx[0] ? ipbufpfx : ipbuf,\n                                     &pat.addrV6,\n                                     sizeof(pat.addrV6))) > 0)\n        {\n          pat.type = PATTERN_CIDR;\n          pat.mask.bits = (unsigned short)bits;\n          pat.family = AF_INET6;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      else if (ipbufpfx[0] &&\n               (bits = ares_inet_net_pton(AF_INET, ipbufpfx, &pat.addrV4,\n                                          sizeof(pat.addrV4))) > 0)\n        {\n          pat.type = PATTERN_CIDR;\n          pat.mask.bits = (unsigned short)bits;\n          pat.family = AF_INET;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      /* See if it is just a regular IP */\n      else if (ip_addr(ipbuf, q-str, &pat.addrV4) == 0)\n        {\n          if (ipbufpfx[0])\n            {\n              memcpy(ipbuf, str, q-str);\n              ipbuf[q-str] = '\\0';\n              if (ip_addr(ipbuf, q-str, &pat.mask.addr4) != 0)\n                natural_mask(&pat);\n            }\n          else\n            natural_mask(&pat);\n          pat.family = AF_INET;\n          pat.type = PATTERN_MASK;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      else\n        {\n          while (*q && *q != ';' && !ISSPACE(*q))\n            q++;\n        }\n      str = q;\n      while (ISSPACE(*str))\n        str++;\n    }\n\n  return ARES_SUCCESS;\n}"", ""target"": 0}]","[{""func_name"": ""config_sortlist"", ""file_path"": ""src/lib/ares_init.c"", ""func_code"": ""static int config_sortlist(struct apattern **sortlist, int *nsort,\n                           const char *str)\n{\n  struct apattern pat;\n  const char *q;\n\n  /* Add sortlist entries. */\n  while (*str && *str != ';')\n    {\n      int bits;\n      char ipbuf[16], ipbufpfx[32];\n      /* Find just the IP */\n      q = str;\n      while (*q && *q != '/' && *q != ';' && !ISSPACE(*q))\n        q++;\n      if (q-str >= 16)\n        return ARES_EBADSTR;\n      memcpy(ipbuf, str, q-str);\n      ipbuf[q-str] = '\\0';\n      /* Find the prefix */\n      if (*q == '/')\n        {\n          const char *str2 = q+1;\n          while (*q && *q != ';' && !ISSPACE(*q))\n            q++;\n          if (q-str >= 32)\n            return ARES_EBADSTR;\n          memcpy(ipbufpfx, str, q-str);\n          ipbufpfx[q-str] = '\\0';\n          str = str2;\n        }\n      else\n        ipbufpfx[0] = '\\0';\n      /* Lets see if it is CIDR */\n      /* First we'll try IPv6 */\n      if ((bits = ares_inet_net_pton(AF_INET6, ipbufpfx[0] ? ipbufpfx : ipbuf,\n                                     &pat.addrV6,\n                                     sizeof(pat.addrV6))) > 0)\n        {\n          pat.type = PATTERN_CIDR;\n          pat.mask.bits = (unsigned short)bits;\n          pat.family = AF_INET6;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      else if (ipbufpfx[0] &&\n               (bits = ares_inet_net_pton(AF_INET, ipbufpfx, &pat.addrV4,\n                                          sizeof(pat.addrV4))) > 0)\n        {\n          pat.type = PATTERN_CIDR;\n          pat.mask.bits = (unsigned short)bits;\n          pat.family = AF_INET;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      /* See if it is just a regular IP */\n      else if (ip_addr(ipbuf, q-str, &pat.addrV4) == 0)\n        {\n          if (ipbufpfx[0])\n            {\n              memcpy(ipbuf, str, q-str);\n              ipbuf[q-str] = '\\0';\n              if (ip_addr(ipbuf, q-str, &pat.mask.addr4) != 0)\n                natural_mask(&pat);\n            }\n          else\n            natural_mask(&pat);\n          pat.family = AF_INET;\n          pat.type = PATTERN_MASK;\n          if (!sortlist_alloc(sortlist, nsort, &pat)) {\n            ares_free(*sortlist);\n            *sortlist = NULL;\n            return ARES_ENOMEM;\n          }\n        }\n      else\n        {\n          while (*q && *q != ';' && !ISSPACE(*q))\n            q++;\n        }\n      str = q;\n      while (ISSPACE(*str))\n        str++;\n    }\n\n  return ARES_SUCCESS;\n}""}]","{""function"": 1}","[{""source"": ""func_info(file:ares_init.c, func:ares_set_sortlist)"", ""result"": [{""code"": ""int ares_set_sortlist(ares_channel channel, const char *sortstr)\n{\n  int nsort = 0;\n  struct apattern *sortlist = NULL;\n  int status;\n\n  if (!channel)\n    return ARES_ENODATA;\n\n  status = config_sortlist(&sortlist, &nsort, sortstr);\n  if (status == ARES_SUCCESS && sortlist) {\n    if (channel->sortlist)\n      ares_free(channel->sortlist);\n    channel->sortlist = sortlist;\n    channel->nsort = nsort;\n  }\n  return status;\n}"", ""start_line"": 2281, ""end_line"": 2298, ""full_name"": ""ares_set_sortlist"", ""file_path"": ""src/lib/ares_init.c""}]}]","1. ares_set_sortlist (src/lib/ares_init.c:2281) accepts a user-provided const char *sortstr without input validation.\n2. Calls config_sortlist(&sortlist, &nsort, sortstr) without sanitizing the input string.\n3. config_sortlist (src/lib/ares_init.c:1914-1924) parses the string by advancing a pointer `q` and uses memcpy(ipbuf, str, q-str) and memcpy(ipbufpfx, str, q-str) without bounds checks on the length (q-str). This allows an attacker to craft a long string, causing stack overflow when copying to fixed-size buffers (ipbuf[16], ipbufpfx[32]).",0.95,./github/other_context/CVE-2022-4904
57,CVE-2023-26119,CWE-94,java,"Versions of the package net.sourceforge.htmlunit:htmlunit from 0 and before 3.0.0 are vulnerable to Remote Code Execution (RCE) via XSTL, when browsing the attacker’s webpage.",https://github.com/HtmlUnit/htmlunit/commit/641325bbc84702dc9800ec7037aec061ce21956b,enable FEATURE_SECURE_PROCESSING for the XSLT processor,1,"[{""func_name"": ""transform"", ""file_path"": ""src/main/java/com/gargoylesoftware/htmlunit/javascript/host/xml/XSLTProcessor.java"", ""func_code"": ""private Object transform(final Node source) {\n        try {\n            final DomNode sourceDomNode = source.getDomNodeOrDie();\n            Source xmlSource = new DOMSource(sourceDomNode);\n\n            final DomNode xsltDomNode = style_.getDomNodeOrDie();\n            final Source xsltSource = new DOMSource(xsltDomNode);\n\n            final TransformerFactory transformerFactory = TransformerFactory.newInstance();\n\n            final SgmlPage page = sourceDomNode.getPage();\n            if (page != null && page.getWebClient().getBrowserVersion()\n                                            .hasFeature(JS_XSLT_TRANSFORM_INDENT)) {\n                final DomNode outputNode = findOutputNode(xsltDomNode);\n                if (outputNode != null) {\n                    final org.w3c.dom.Node indentNode = outputNode.getAttributes().getNamedItem(\""indent\"");\n                    if (indentNode != null && \""yes\"".equalsIgnoreCase(indentNode.getNodeValue())) {\n                        try {\n                            transformerFactory.setAttribute(\""indent-number\"", new Integer(2));\n                        }\n                        catch (final IllegalArgumentException e) {\n                            // ignore\n                        }\n                        final Transformer transformer = transformerFactory.newTransformer(xsltSource);\n                        transformer.setOutputProperty(OutputKeys.INDENT, \""yes\"");\n                        try {\n                            transformer.setOutputProperty(\""{http://xml.apache.org/xslt}indent-amount\"", \""2\"");\n                        }\n                        catch (final IllegalArgumentException e) {\n                            // ignore\n                        }\n\n                        for (final Map.Entry<String, Object> entry : parameters_.entrySet()) {\n                            transformer.setParameter(entry.getKey(), entry.getValue());\n                        }\n\n                        // hack to preserve indention\n                        // the transformer only accepts the OutputKeys.INDENT setting if\n                        // the StreamResult is used\n                        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n                            transformer.transform(xmlSource, new StreamResult(out));\n                            final WebResponseData data =\n                                    new WebResponseData(out.toByteArray(), 200, null, Collections.emptyList());\n                            final WebResponse response = new WebResponse(data, null, 0);\n                            return XmlUtils.buildDocument(response);\n                        }\n                    }\n                }\n            }\n\n            final Transformer transformer = transformerFactory.newTransformer(xsltSource);\n            for (final Map.Entry<String, Object> entry : parameters_.entrySet()) {\n                transformer.setParameter(entry.getKey(), entry.getValue());\n            }\n\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            final org.w3c.dom.Document containerDocument = factory.newDocumentBuilder().newDocument();\n            final org.w3c.dom.Element containerElement = containerDocument.createElement(\""container\"");\n            containerDocument.appendChild(containerElement);\n\n            final DOMResult result = new DOMResult(containerElement);\n            transformer.transform(xmlSource, result);\n\n            final org.w3c.dom.Node transformedNode = result.getNode();\n            final org.w3c.dom.Node transformedFirstChild = transformedNode.getFirstChild();\n            if (transformedFirstChild != null && transformedFirstChild.getNodeType() == Node.ELEMENT_NODE) {\n                return transformedNode;\n            }\n\n            // output is not DOM (text)\n            xmlSource = new DOMSource(source.getDomNodeOrDie());\n            final StringWriter writer = new StringWriter();\n            final Result streamResult = new StreamResult(writer);\n            transformer.transform(xmlSource, streamResult);\n            return writer.toString();\n        }\n        catch (final Exception e) {\n            throw Context.reportRuntimeError(\""Exception: \"" + e);\n        }\n    }"", ""target"": 0}]","[{""func_name"": ""transform"", ""file_path"": ""src/main/java/com/gargoylesoftware/htmlunit/javascript/host/xml/XSLTProcessor.java"", ""func_code"": ""private Object transform(final Node source) {\n        try {\n            final DomNode sourceDomNode = source.getDomNodeOrDie();\n            Source xmlSource = new DOMSource(sourceDomNode);\n\n            final DomNode xsltDomNode = style_.getDomNodeOrDie();\n            final Source xsltSource = new DOMSource(xsltDomNode);\n\n            final TransformerFactory transformerFactory = TransformerFactory.newInstance();\n\n            // By default, the JDK turns on FSP for DOM and SAX parsers and XML schema validators,\n            // which sets a number of processing limits on the processors. Conversely, by default,\n            // the JDK turns off FSP for transformers and XPath, which enables extension functions for XSLT and XPath.\n            transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n\n            final SgmlPage page = sourceDomNode.getPage();\n            if (page != null && page.getWebClient().getBrowserVersion()\n                                            .hasFeature(JS_XSLT_TRANSFORM_INDENT)) {\n                final DomNode outputNode = findOutputNode(xsltDomNode);\n                if (outputNode != null) {\n                    final org.w3c.dom.Node indentNode = outputNode.getAttributes().getNamedItem(\""indent\"");\n                    if (indentNode != null && \""yes\"".equalsIgnoreCase(indentNode.getNodeValue())) {\n                        try {\n                            transformerFactory.setAttribute(\""indent-number\"", new Integer(2));\n                        }\n                        catch (final IllegalArgumentException e) {\n                            // ignore\n                        }\n                        final Transformer transformer = transformerFactory.newTransformer(xsltSource);\n                        transformer.setOutputProperty(OutputKeys.INDENT, \""yes\"");\n                        try {\n                            transformer.setOutputProperty(\""{http://xml.apache.org/xslt}indent-amount\"", \""2\"");\n                        }\n                        catch (final IllegalArgumentException e) {\n                            // ignore\n                        }\n\n                        for (final Map.Entry<String, Object> entry : parameters_.entrySet()) {\n                            transformer.setParameter(entry.getKey(), entry.getValue());\n                        }\n\n                        // hack to preserve indention\n                        // the transformer only accepts the OutputKeys.INDENT setting if\n                        // the StreamResult is used\n                        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n                            transformer.transform(xmlSource, new StreamResult(out));\n                            final WebResponseData data =\n                                    new WebResponseData(out.toByteArray(), 200, null, Collections.emptyList());\n                            final WebResponse response = new WebResponse(data, null, 0);\n                            return XmlUtils.buildDocument(response);\n                        }\n                    }\n                }\n            }\n\n            final Transformer transformer = transformerFactory.newTransformer(xsltSource);\n            for (final Map.Entry<String, Object> entry : parameters_.entrySet()) {\n                transformer.setParameter(entry.getKey(), entry.getValue());\n            }\n\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            final org.w3c.dom.Document containerDocument = factory.newDocumentBuilder().newDocument();\n            final org.w3c.dom.Element containerElement = containerDocument.createElement(\""container\"");\n            containerDocument.appendChild(containerElement);\n\n            final DOMResult result = new DOMResult(containerElement);\n            transformer.transform(xmlSource, result);\n\n            final org.w3c.dom.Node transformedNode = result.getNode();\n            final org.w3c.dom.Node transformedFirstChild = transformedNode.getFirstChild();\n            if (transformedFirstChild != null && transformedFirstChild.getNodeType() == Node.ELEMENT_NODE) {\n                return transformedNode;\n            }\n\n            // output is not DOM (text)\n            xmlSource = new DOMSource(source.getDomNodeOrDie());\n            final StringWriter writer = new StringWriter();\n            final Result streamResult = new StreamResult(writer);\n            transformer.transform(xmlSource, streamResult);\n            return writer.toString();\n        }\n        catch (final Exception e) {\n            throw Context.reportRuntimeError(\""Exception: \"" + e);\n        }\n    }""}]","{""code"": 2}","[{""source"": ""code_info(file:XSLTProcessor.java, lines:120-150)"", ""result"": ""     */\n    private Object transform(final Node source) {\n        try {\n            final DomNode sourceDomNode = source.getDomNodeOrDie();\n            Source xmlSource = new DOMSource(sourceDomNode);\n\n            final DomNode xsltDomNode = style_.getDomNodeOrDie();\n            final Source xsltSource = new DOMSource(xsltDomNode);\n\n            final TransformerFactory transformerFactory = TransformerFactory.newInstance();\n\n            final SgmlPage page = sourceDomNode.getPage();\n            if (page != null && page.getWebClient().getBrowserVersion()\n                                            .hasFeature(JS_XSLT_TRANSFORM_INDENT)) {\n                final DomNode outputNode = findOutputNode(xsltDomNode);\n                if (outputNode != null) {\n                    final org.w3c.dom.Node indentNode = outputNode.getAttributes().getNamedItem(\""indent\"");\n                    if (indentNode != null && \""yes\"".equalsIgnoreCase(indentNode.getNodeValue())) {\n                        try {\n                            transformerFactory.setAttribute(\""indent-number\"", new Integer(2));\n                        }\n                        catch (final IllegalArgumentException e) {\n                            // ignore\n                        }\n                        final Transformer transformer = transformerFactory.newTransformer(xsltSource);\n                        transformer.setOutputProperty(OutputKeys.INDENT, \""yes\"");\n                        try {\n                            transformer.setOutputProperty(\""{http://xml.apache.org/xslt}indent-amount\"", \""2\"");\n                        }\n                        catch (final IllegalArgumentException e) {\n                            // ignore\n                        }\n""}, {""source"": ""code_info(file:XSLTProcessor.java, lines:50-100)"", ""result"": ""import com.gargoylesoftware.htmlunit.javascript.configuration.JsxFunction;\nimport com.gargoylesoftware.htmlunit.javascript.host.dom.Document;\nimport com.gargoylesoftware.htmlunit.javascript.host.dom.DocumentFragment;\nimport com.gargoylesoftware.htmlunit.javascript.host.dom.Node;\nimport com.gargoylesoftware.htmlunit.util.XmlUtils;\nimport com.gargoylesoftware.htmlunit.xml.XmlPage;\n\nimport net.sourceforge.htmlunit.corejs.javascript.Context;\n\n/**\n * A JavaScript object for {@code XSLTProcessor}.\n *\n * @author Ahmed Ashour\n * @author Ronald Brill\n */\n@JsxClass({CHROME, EDGE, FF, FF_ESR})\npublic class XSLTProcessor extends HtmlUnitScriptable {\n\n    private Node style_;\n    private final Map<String, Object> parameters_ = new HashMap<>();\n\n    /**\n     * Default constructor.\n     */\n    @JsxConstructor\n    public XSLTProcessor() {\n    }\n\n    /**\n     * Imports the specified stylesheet into this XSLTProcessor for transformations. The specified node\n     * may be either a document node or an element node. If it is a document node, then the document can\n     * contain either a XSLT stylesheet or a LRE stylesheet. If it is an element node, it must be the\n     * xsl:stylesheet (or xsl:transform) element of an XSLT stylesheet.\n     *\n     * @param style the root-node of an XSLT stylesheet (may be a document node or an element node)\n     */\n    @JsxFunction\n    public void importStylesheet(final Node style) {\n        style_ = style;\n    }\n\n    /**\n     * Transforms the node source applying the stylesheet given by the importStylesheet() function.\n     * The owner document of the output node owns the returned document fragment.\n     *\n     * @param source the node to be transformed\n     * @return the result of the transformation\n     */\n    @JsxFunction\n    public XMLDocument transformToDocument(final Node source) {\n        final XMLDocument doc = new XMLDocument();\n        doc.setPrototype(getPrototype(doc.getClass()));\n""}]","XSLTProcessor.java:132-136: TransformerFactory lacks FEATURE_SECURE_PROCESSING, enabling XSLT extension functions. xsltDomNode (XSLTProcessor.java:128) is derived from `style_`, set via `importStylesheet(Node style)` (XSLTProcessor.java:50-100). The `importStylesheet` method is exposed as a @JsxFunction, indicating it is accessible to untrusted web content (e.g., attacker-controlled JavaScript). This allows an attacker to supply malicious XSLT with extension functions, leading to RCE when processed.",0.95,./github/other_context/CVE-2023-26119
58,CVE-2023-27601,CWE-20,c_cpp,"OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.7 and 3.2.4, OpenSIPS crashes when a malformed SDP body is received and is processed by the `delete_sdp_line` function in the sipmsgops module. This issue can be reproduced by calling the function with an SDP body that does not terminate by a line feed (i.e. `\n`).

The vulnerability was found while performing black-box fuzzing against an OpenSIPS server running a configuration that made use of the functions `codec_delete_except_re` and `codec_delete_re`. The same issue was also discovered while performing coverage guided fuzzing on the function `codec_delete_except_re`. The crash happens because the function `delete_sdp_line` expects that an SDP line is terminated by a line feed (`\n`):

By abusing this vulnerability, an attacker is able to crash the server. It affects configurations containing functions that rely on the affected code, such as the function `codec_delete_except_re`. Due to the sanity check that is performed in the `del_lump` function, exploitation of this issue will generate an `abort` in the lumps processing function, resulting in a Denial of Service. This issue has been fixed in versions 3.1.7 and 3.2.4.",https://github.com/OpenSIPS/opensips/commit/8f87c7c03da55f9c79bd92e67fa2c94b2a7ce5cf,"[sipmsgops] fix codec_delete_XX() parsing\n\nIssue discovered during OpenSIPS Security Audit 2021,\n        by Alfred Farrugia & Sandro Gauci (Enable Security)\n\nhttps://github.com/OpenSIPS/opensips/security/advisories/GHSA-xj5x-g52f-548h",2,"[{""func_name"": ""delete_sdp_line"", ""file_path"": ""modules/sipmsgops/codecs.c"", ""func_code"": ""int delete_sdp_line( struct sip_msg * msg, char * s)\n{\n\tchar * start,*end;\n\n\tif( !s )\n\t\treturn 1;\n\n\tstart = s;\n\tend  = s;\n\n\twhile(*start != '\\n')\n\t\tstart--;\n\tstart++;\n\n\twhile(*end != '\\n')\n\t\tend++;\n\tend++;\n\n\t/* delete the entry */\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""stream_process"", ""file_path"": ""modules/sipmsgops/codecs.c"", ""func_code"": ""static int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,\n\t\t\tstr * s, str* ss, regex_t* re, int op,int description)\n{\n\tstatic sdp_payload_attr_t static_payloads[] = {\n\t/* as per http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xml */\n\t{ NULL,0,{ \""0\"",1},{\""PCMU\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 0 - PCMU/8000  */\n\t{ NULL,0,{ \""3\"",1},{ \""GSM\"",3},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 3 -  GSM/8000  */\n\t{ NULL,0,{ \""4\"",1},{\""G723\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 4 - G723/8000  */\n\t{ NULL,0,{ \""5\"",1},{\""DVI4\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 5 - DVI4/8000  */\n\t{ NULL,0,{ \""6\"",1},{\""DVI4\"",4},{\""16000\"",5},{NULL,0},{NULL,0} },   /* 6 - DVI4/16000 */\n\t{ NULL,0,{ \""7\"",1},{ \""LPC\"",3},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 7 -  LPC/8000  */\n\t{ NULL,0,{ \""8\"",1},{\""PCMA\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 8 - PCMA/8000  */\n\t{ NULL,0,{ \""9\"",1},{\""G722\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 9 - G722/8000  */\n\t{ NULL,0,{\""10\"",2},{ \""L16\"",3},{\""44100\"",5},{NULL,0},{NULL,0} },   /*10 -  L16/44100 */\n\t{ NULL,0,{\""11\"",2},{ \""L16\"",3},{\""44100\"",5},{NULL,0},{NULL,0} },   /*11 -  L16/44100 */\n\t{ NULL,0,{\""12\"",2},{\""QCELP\"",5},{\""8000\"",4},{NULL,0},{NULL,0} },   /*12 -QCELP/8000  */\n\t{ NULL,0,{\""13\"",2},{  \""CN\"",2},{ \""8000\"",4},{NULL,0},{NULL,0} },   /*13 -   CN/8000  */\n\t{ NULL,0,{\""14\"",2},{ \""MPA\"",3},{\""90000\"",5},{NULL,0},{NULL,0} },   /*14 -  MPA/90000 */\n\t{ NULL,0,{\""15\"",2},{\""G728\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /*15 - G728/8000  */\n\t{ NULL,0,{\""16\"",2},{\""DVI4\"",4},{\""11025\"",5},{NULL,0},{NULL,0} },   /*16 - DVI4/11025 */\n\t{ NULL,0,{\""17\"",2},{\""DVI4\"",4},{\""22050\"",5},{NULL,0},{NULL,0} },   /*17 - DVI4/22050 */\n\t{ NULL,0,{\""18\"",2},{\""G729\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /*18 - G729/8000  */\n\t{ NULL,0,{\""25\"",2},{\""CelB\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /*25 - CelB/8000  */\n\t{ NULL,0,{\""26\"",2},{\""JPEG\"",4},{\""90000\"",5},{NULL,0},{NULL,0} },   /*26 - JPEG/90000 */\n\t{ NULL,0,{\""28\"",2},{  \""nv\"",2},{\""90000\"",5},{NULL,0},{NULL,0} },   /*28 -   nv/90000 */\n\t{ NULL,0,{\""31\"",2},{\""H261\"",4},{\""90000\"",5},{NULL,0},{NULL,0} },   /*31 - H261/90000 */\n\t{ NULL,0,{\""32\"",2},{ \""MPV\"",3},{\""90000\"",5},{NULL,0},{NULL,0} },   /*32 -  MPV/90000 */\n\t{ NULL,0,{\""33\"",2},{\""MP2T\"",4},{\""90000\"",5},{NULL,0},{NULL,0} },   /*33 - MP2T/90000 */\n\t{ NULL,0,{\""34\"",2},{\""H263\"",4},{\""90000\"",5},{NULL,0},{NULL,0} },   /*34 - H263/90000 */\n\t{ NULL,0,{\""t38\"",3},{\""t38\"",3},{     \""\"",0},{NULL,0},{NULL,0} },   /*T38- fax        */\n\t{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }\n\t};\n\tsdp_payload_attr_t *payload;\n\tchar *cur, *tmp, *buff, temp;\n\tstruct lump * lmp;\n\tstr found;\n\tint ret, i,match, buff_len, is_static;\n\tregmatch_t pmatch;\n\n\n\tlmp = get_associated_lump(msg, cell);\n\tif( lmp == NULL)\n\t{\n\t\tLM_ERR(\""There is no lump for this sdp cell\\n\"");\n\t\treturn -1;\n\t}\n\n\t/* is stream deleted ?? */\n\tif (lmp->len == 0)\n\t\treturn -1;\n\n\n\tbuff_len = 0;\n\tret = 0;\n\n\tbuff = pkg_malloc(lmp->len+1);\n\tif( buff == NULL)\n\t{\n\t\tLM_ERR(\""Out of memory\\n\"");\n\t\treturn -1;\n\t}\n\n\t/* search through each payload */\n\tis_static = 0;\n\tpayload = cell->payload_attr;\n\n\twhile(payload)\n\t{\n\t\tif( payload->rtp_enc.s == NULL\n\t\t || (payload->rtp_clock.s == NULL && ss != NULL)\n\t\t || payload->rtp_payload.s == NULL)\n\t\t{\n\t\t\tgoto next_payload;\n\t\t}\n\n\t\tmatch = 0;\n\n\t\tif( description == DESC_REGEXP ||description == DESC_REGEXP_COMPLEMENT )\n\t\t{\n\t\t\t/* try to match a regexp */\n\t\t\tif (is_static) {\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t} else {\n\t\t\t\ttemp = payload->rtp_enc.s[payload->rtp_enc.len];\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = 0;\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = temp;\n\t\t\t}\n\t\t}\n\n\t\tif( description == DESC_REGEXP_COMPLEMENT)\n\t\t\tmatch = !match;\n\n\t\tif( description == DESC_NAME  )\n\t\t{\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\tpayload->rtp_enc.len) == 0;\n\t\t}\n\n\t\tif( description == DESC_NAME_AND_CLOCK)\n\t\t{\n\t\t\t/* try to match name and clock if there is one */\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\n\t\t\t\tpayload->rtp_enc.len) == 0\n\t\t\t&&\n\t\t\t(ss == NULL || ( ss->len == payload->rtp_clock.len &&\n\t\t\tstrncasecmp( ss->s, payload->rtp_clock.s ,\n\t\t\t\tpayload->rtp_clock.len) == 0\n\t\t\t) );\n\t\t}\n\n\t\t/* if found, search its index in the m= line */\n\t\tif (match) {\n\n\t\t\tmatch = 0;\n\n\t\t\tcur = lmp->u.value;\n\t\t\twhile( !match && cur < lmp->u.value + lmp->len)\n\t\t\t{\n\t\t\t\t/* find the end of the number */\n\t\t\t\tfound.s = cur;\n\n\t\t\t\twhile(  cur < lmp->u.value + lmp->len &&  *cur != ' ' )\n\t\t\t\t\tcur++;\n\n\t\t\t\tfound.len = cur - found.s;\n\n\t\t\t\t/* does it matches payload number */\n\t\t\t\tif ( found.len == payload->rtp_payload.len &&\n\t\t\t\tstrncmp( found.s,payload->rtp_payload.s,found.len) == 0) {\n\t\t\t\t\tmatch = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* continue on searching => skip spaces\n\t\t\t\t\t   if there still are any */\n\t\t\t\t\twhile( cur < lmp->u.value + lmp->len && * cur == ' '  )\n\t\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* have we found both payload and index */\n\t\t\tif (match) {\n\n\t\t\t\tif(op == FIND)\n\t\t\t\t{\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif( op == DELETE && !is_static )\n\t\t\t\t{\n\t\t\t\t\t/* find the full 'a=...' entry */\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\""Unable to add delete lump for a=\\n\"");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->fmtp_string.s) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\""Unable to add delete lump for a=\\n\"");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\t/* take the previous whitespaces as well */\n\t\t\t\t\twhile (found.s > lmp->u.value && *(found.s - 1) == ' ') {\n\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* when trimming the very last payload, avoid trailing ws */\n\t\t\t\t\tif (cur == lmp->u.value + lmp->len) {\n\t\t\t\t\t\ttmp = found.s;\n\t\t\t\t\t\twhile (*(--tmp) == ' ') {\n\t\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* delete the string and update iterators */\n\t\t\t\t\tfor(tmp=found.s ; tmp< lmp->u.value + lmp->len ; tmp++ )\n\t\t\t\t\t\t*tmp  = *(tmp+found.len);\n\n\t\t\t\t\t//cur -= found.len;\n\t\t\t\t\tlmp->len -= found.len;\n\t\t\t\t}\n\n\t\t\t\t/* add the deleted number into a buffer to be addded later */\n\t\t\t\tif( op == ADD_TO_FRONT  || op == ADD_TO_BACK)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&buff[buff_len],\"" \"",1);\n\t\t\t\t\tbuff_len++;\n\n\t\t\t\t\tmemcpy(&buff[buff_len],payload->rtp_payload.s,\n\t\t\t\t\t\tpayload->rtp_payload.len);\n\n\t\t\t\t\tbuff_len += payload->rtp_payload.len;\n\t\t\t\t}\n\n\t\t\t\tret = 1;\n\t\t\t}\n\n\t\t}\n\n\t\t/* next payload */\n\tnext_payload:\n\t\tif (!is_static) {\n\t\t\tpayload = payload->next;\n\t\t\tif (payload==NULL) {\n\t\t\t\tpayload = static_payloads;\n\t\t\t\tis_static = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tpayload ++;\n\t\t\tif (payload->rtp_payload.s==NULL)\n\t\t\t\tpayload=NULL;\n\t\t}\n\t}\n\n\n\tif( op == ADD_TO_FRONT && buff_len >0 )\n\t{\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\""No more pkg memory\\n\"");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tfor( i = lmp->len -1 ; i>=0;i--)\n\t\t\tlmp->u.value[i+buff_len] = lmp->u.value[i];\n\n\t\tmemcpy(lmp->u.value,buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\tif( op == ADD_TO_BACK && buff_len >0 )\n\t{\n\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\""No more pkg memory\\n\"");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tmemcpy(&lmp->u.value[lmp->len],buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\t/* if we ended up with a 0-length lump, then it means that all payloads\n\t * have been deleted, therefore we need to disable the media stream */\n\tif (lmp->len == 0) {\n\t\t/* replace the media port with 0 - we also replace the spaces before\n\t\t * and after the port, to make sure we have a larger buffer */\n\t\tlmp = del_lump(msg, cell->port.s - msg->buf - 1, cell->port.len + 2, 0);\n\t\tif (!lmp) {\n\t\t\tLM_ERR(\""could not add lump to disable stream!\\n\"");\n\t\t\tgoto end;\n\t\t}\n\t\ttmp = pkg_malloc(3);\n\t\tif (!tmp) {\n\t\t\tLM_ERR(\""oom for port 0\\n\"");\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(tmp, \"" 0 \"", 3);\n\t\tif (!insert_new_lump_after(lmp, tmp, 3, 0))\n\t\t\tLM_ERR(\""could not insert lump to disable stream!\\n\"");\n\t}\n\nend:\n\tpkg_free(buff);\n\treturn ret;\n}"", ""target"": 0}]","[{""func_name"": ""delete_sdp_line"", ""file_path"": ""modules/sipmsgops/codecs.c"", ""func_code"": ""int delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell *stream)\n{\n\tchar * start,*end;\n\n\tif( !s )\n\t\treturn 1;\n\n\tstart = s;\n\tend  = s;\n\n\twhile(*start != '\\n' && start > stream->body.s)\n\t\tstart--;\n\tstart++;\n\n\twhile(*end != '\\n' && end < (stream->body.s+stream->body.len) )\n\t\tend++;\n\tend++;\n\n\t/* delete the entry */\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}""}, {""func_name"": ""stream_process"", ""file_path"": ""modules/sipmsgops/codecs.c"", ""func_code"": ""static int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,\n\t\t\tstr * s, str* ss, regex_t* re, int op,int description)\n{\n\tstatic sdp_payload_attr_t static_payloads[] = {\n\t/* as per http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xml */\n\t{ NULL,0,{ \""0\"",1},{\""PCMU\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 0 - PCMU/8000  */\n\t{ NULL,0,{ \""3\"",1},{ \""GSM\"",3},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 3 -  GSM/8000  */\n\t{ NULL,0,{ \""4\"",1},{\""G723\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 4 - G723/8000  */\n\t{ NULL,0,{ \""5\"",1},{\""DVI4\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 5 - DVI4/8000  */\n\t{ NULL,0,{ \""6\"",1},{\""DVI4\"",4},{\""16000\"",5},{NULL,0},{NULL,0} },   /* 6 - DVI4/16000 */\n\t{ NULL,0,{ \""7\"",1},{ \""LPC\"",3},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 7 -  LPC/8000  */\n\t{ NULL,0,{ \""8\"",1},{\""PCMA\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 8 - PCMA/8000  */\n\t{ NULL,0,{ \""9\"",1},{\""G722\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /* 9 - G722/8000  */\n\t{ NULL,0,{\""10\"",2},{ \""L16\"",3},{\""44100\"",5},{NULL,0},{NULL,0} },   /*10 -  L16/44100 */\n\t{ NULL,0,{\""11\"",2},{ \""L16\"",3},{\""44100\"",5},{NULL,0},{NULL,0} },   /*11 -  L16/44100 */\n\t{ NULL,0,{\""12\"",2},{\""QCELP\"",5},{\""8000\"",4},{NULL,0},{NULL,0} },   /*12 -QCELP/8000  */\n\t{ NULL,0,{\""13\"",2},{  \""CN\"",2},{ \""8000\"",4},{NULL,0},{NULL,0} },   /*13 -   CN/8000  */\n\t{ NULL,0,{\""14\"",2},{ \""MPA\"",3},{\""90000\"",5},{NULL,0},{NULL,0} },   /*14 -  MPA/90000 */\n\t{ NULL,0,{\""15\"",2},{\""G728\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /*15 - G728/8000  */\n\t{ NULL,0,{\""16\"",2},{\""DVI4\"",4},{\""11025\"",5},{NULL,0},{NULL,0} },   /*16 - DVI4/11025 */\n\t{ NULL,0,{\""17\"",2},{\""DVI4\"",4},{\""22050\"",5},{NULL,0},{NULL,0} },   /*17 - DVI4/22050 */\n\t{ NULL,0,{\""18\"",2},{\""G729\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /*18 - G729/8000  */\n\t{ NULL,0,{\""25\"",2},{\""CelB\"",4},{ \""8000\"",4},{NULL,0},{NULL,0} },   /*25 - CelB/8000  */\n\t{ NULL,0,{\""26\"",2},{\""JPEG\"",4},{\""90000\"",5},{NULL,0},{NULL,0} },   /*26 - JPEG/90000 */\n\t{ NULL,0,{\""28\"",2},{  \""nv\"",2},{\""90000\"",5},{NULL,0},{NULL,0} },   /*28 -   nv/90000 */\n\t{ NULL,0,{\""31\"",2},{\""H261\"",4},{\""90000\"",5},{NULL,0},{NULL,0} },   /*31 - H261/90000 */\n\t{ NULL,0,{\""32\"",2},{ \""MPV\"",3},{\""90000\"",5},{NULL,0},{NULL,0} },   /*32 -  MPV/90000 */\n\t{ NULL,0,{\""33\"",2},{\""MP2T\"",4},{\""90000\"",5},{NULL,0},{NULL,0} },   /*33 - MP2T/90000 */\n\t{ NULL,0,{\""34\"",2},{\""H263\"",4},{\""90000\"",5},{NULL,0},{NULL,0} },   /*34 - H263/90000 */\n\t{ NULL,0,{\""t38\"",3},{\""t38\"",3},{     \""\"",0},{NULL,0},{NULL,0} },   /*T38- fax        */\n\t{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }\n\t};\n\tsdp_payload_attr_t *payload;\n\tchar *cur, *tmp, *buff, temp;\n\tstruct lump * lmp;\n\tstr found;\n\tint ret, i,match, buff_len, is_static;\n\tregmatch_t pmatch;\n\n\n\tlmp = get_associated_lump(msg, cell);\n\tif( lmp == NULL)\n\t{\n\t\tLM_ERR(\""There is no lump for this sdp cell\\n\"");\n\t\treturn -1;\n\t}\n\n\t/* is stream deleted ?? */\n\tif (lmp->len == 0)\n\t\treturn -1;\n\n\n\tbuff_len = 0;\n\tret = 0;\n\n\tbuff = pkg_malloc(lmp->len+1);\n\tif( buff == NULL)\n\t{\n\t\tLM_ERR(\""Out of memory\\n\"");\n\t\treturn -1;\n\t}\n\n\t/* search through each payload */\n\tis_static = 0;\n\tpayload = cell->payload_attr;\n\n\twhile(payload)\n\t{\n\t\tif( payload->rtp_enc.s == NULL\n\t\t || (payload->rtp_clock.s == NULL && ss != NULL)\n\t\t || payload->rtp_payload.s == NULL)\n\t\t{\n\t\t\tgoto next_payload;\n\t\t}\n\n\t\tmatch = 0;\n\n\t\tif( description == DESC_REGEXP ||description == DESC_REGEXP_COMPLEMENT )\n\t\t{\n\t\t\t/* try to match a regexp */\n\t\t\tif (is_static) {\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t} else {\n\t\t\t\ttemp = payload->rtp_enc.s[payload->rtp_enc.len];\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = 0;\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = temp;\n\t\t\t}\n\t\t}\n\n\t\tif( description == DESC_REGEXP_COMPLEMENT)\n\t\t\tmatch = !match;\n\n\t\tif( description == DESC_NAME  )\n\t\t{\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\tpayload->rtp_enc.len) == 0;\n\t\t}\n\n\t\tif( description == DESC_NAME_AND_CLOCK)\n\t\t{\n\t\t\t/* try to match name and clock if there is one */\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\n\t\t\t\tpayload->rtp_enc.len) == 0\n\t\t\t&&\n\t\t\t(ss == NULL || ( ss->len == payload->rtp_clock.len &&\n\t\t\tstrncasecmp( ss->s, payload->rtp_clock.s ,\n\t\t\t\tpayload->rtp_clock.len) == 0\n\t\t\t) );\n\t\t}\n\n\t\t/* if found, search its index in the m= line */\n\t\tif (match) {\n\n\t\t\tmatch = 0;\n\n\t\t\tcur = lmp->u.value;\n\t\t\twhile( !match && cur < lmp->u.value + lmp->len)\n\t\t\t{\n\t\t\t\t/* find the end of the number */\n\t\t\t\tfound.s = cur;\n\n\t\t\t\twhile(  cur < lmp->u.value + lmp->len &&  *cur != ' ' )\n\t\t\t\t\tcur++;\n\n\t\t\t\tfound.len = cur - found.s;\n\n\t\t\t\t/* does it matches payload number */\n\t\t\t\tif ( found.len == payload->rtp_payload.len &&\n\t\t\t\tstrncmp( found.s,payload->rtp_payload.s,found.len) == 0) {\n\t\t\t\t\tmatch = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* continue on searching => skip spaces\n\t\t\t\t\t   if there still are any */\n\t\t\t\t\twhile( cur < lmp->u.value + lmp->len && * cur == ' '  )\n\t\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* have we found both payload and index */\n\t\t\tif (match) {\n\n\t\t\t\tif(op == FIND)\n\t\t\t\t{\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif( op == DELETE && !is_static )\n\t\t\t\t{\n\t\t\t\t\t/* find the full 'a=...' entry */\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\""Unable to add delete lump for a=\\n\"");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->fmtp_string.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\""Unable to add delete lump for a=\\n\"");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\t/* take the previous whitespaces as well */\n\t\t\t\t\twhile (found.s > lmp->u.value && *(found.s - 1) == ' ') {\n\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* when trimming the very last payload, avoid trailing ws */\n\t\t\t\t\tif (cur == lmp->u.value + lmp->len) {\n\t\t\t\t\t\ttmp = found.s;\n\t\t\t\t\t\twhile (*(--tmp) == ' ') {\n\t\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* delete the string and update iterators */\n\t\t\t\t\tfor(tmp=found.s ; tmp< lmp->u.value + lmp->len ; tmp++ )\n\t\t\t\t\t\t*tmp  = *(tmp+found.len);\n\n\t\t\t\t\t//cur -= found.len;\n\t\t\t\t\tlmp->len -= found.len;\n\t\t\t\t}\n\n\t\t\t\t/* add the deleted number into a buffer to be addded later */\n\t\t\t\tif( op == ADD_TO_FRONT  || op == ADD_TO_BACK)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&buff[buff_len],\"" \"",1);\n\t\t\t\t\tbuff_len++;\n\n\t\t\t\t\tmemcpy(&buff[buff_len],payload->rtp_payload.s,\n\t\t\t\t\t\tpayload->rtp_payload.len);\n\n\t\t\t\t\tbuff_len += payload->rtp_payload.len;\n\t\t\t\t}\n\n\t\t\t\tret = 1;\n\t\t\t}\n\n\t\t}\n\n\t\t/* next payload */\n\tnext_payload:\n\t\tif (!is_static) {\n\t\t\tpayload = payload->next;\n\t\t\tif (payload==NULL) {\n\t\t\t\tpayload = static_payloads;\n\t\t\t\tis_static = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tpayload ++;\n\t\t\tif (payload->rtp_payload.s==NULL)\n\t\t\t\tpayload=NULL;\n\t\t}\n\t}\n\n\n\tif( op == ADD_TO_FRONT && buff_len >0 )\n\t{\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\""No more pkg memory\\n\"");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tfor( i = lmp->len -1 ; i>=0;i--)\n\t\t\tlmp->u.value[i+buff_len] = lmp->u.value[i];\n\n\t\tmemcpy(lmp->u.value,buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\tif( op == ADD_TO_BACK && buff_len >0 )\n\t{\n\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\""No more pkg memory\\n\"");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tmemcpy(&lmp->u.value[lmp->len],buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\t/* if we ended up with a 0-length lump, then it means that all payloads\n\t * have been deleted, therefore we need to disable the media stream */\n\tif (lmp->len == 0) {\n\t\t/* replace the media port with 0 - we also replace the spaces before\n\t\t * and after the port, to make sure we have a larger buffer */\n\t\tlmp = del_lump(msg, cell->port.s - msg->buf - 1, cell->port.len + 2, 0);\n\t\tif (!lmp) {\n\t\t\tLM_ERR(\""could not add lump to disable stream!\\n\"");\n\t\t\tgoto end;\n\t\t}\n\t\ttmp = pkg_malloc(3);\n\t\tif (!tmp) {\n\t\t\tLM_ERR(\""oom for port 0\\n\"");\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(tmp, \"" 0 \"", 3);\n\t\tif (!insert_new_lump_after(lmp, tmp, 3, 0))\n\t\t\tLM_ERR(\""could not insert lump to disable stream!\\n\"");\n\t}\n\nend:\n\tpkg_free(buff);\n\treturn ret;\n}""}]","{""value"": 2, ""caller"": 1, ""function"": 11}","[{""source"": ""value_info(file:codecs.c, value:stream->body.s)"", ""result"": {""value_trace"": [{""full_code"": ""stream->body.s = shm_malloc(body->len)"", ""line"": 164, ""func_name"": ""srs_add_raw_sdp_stream""}, {""full_code"": ""stream->body.s = NULL"", ""line"": 381, ""func_name"": ""srs_fill_sdp_stream""}, {""full_code"": ""stream->body.s = shm_malloc(globals_buf.len +\n\t\t\t\t\tmedia_buf.len + tmp_buf.len + tmp_len)"", ""line"": 409, ""func_name"": ""srs_fill_sdp_stream""}], ""struct_var"": ""stream"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:codecs.c, value:stream->body.len)"", ""result"": {""value_trace"": [{""full_code"": ""stream->body.len = body->len"", ""line"": 173, ""func_name"": ""srs_add_raw_sdp_stream""}, {""full_code"": ""stream->body.len = media_buf.len"", ""line"": 418, ""func_name"": ""srs_fill_sdp_stream""}, {""full_code"": ""stream->body.len += globals_buf.len"", ""line"": 421, ""func_name"": ""srs_fill_sdp_stream""}, {""full_code"": ""stream->body.len += tmp_buf.len"", ""line"": 424, ""func_name"": ""srs_fill_sdp_stream""}, {""full_code"": ""stream->body.len += 8"", ""line"": 428, ""func_name"": ""srs_fill_sdp_stream""}], ""struct_var"": ""stream"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:codecs.c, func:stream_process)"", ""result"": [{""call_line"": 337, ""call_code"": ""stream_process(msg,cur_cell,str1,str2,re,op,desc)"", ""caller_code"": ""static int do_for_all_streams(struct sip_msg* msg, str* str1,str * str2,\n\t\t\t\tregex_t* re, int op,int desc)\n{\n\tstruct sdp_session_cell * cur_session;\n\tsdp_info_t *sdp;\n\tint rez;\n\n\tif (msg==NULL || msg==FAKED_REPLY)\n\t\treturn -1;\n\n\tsdp = parse_sdp(msg);\n\tif (!sdp) {\n\t\tLM_DBG(\""Message has no SDP\\n\"");\n\t\treturn -1;\n\t}\n\n\tif (get_codec_lumps(msg)<0) {\n\t\tLM_ERR(\""failed to prepare changes for codecs\\n\"");\n\t\treturn -1;\n\t}\n\n\tcur_session = sdp->sessions;\n\trez = -1;\n\n\twhile(cur_session)\n\t{\n\t\tstruct sdp_stream_cell * cur_cell = cur_session->streams;\n\n\t\twhile(cur_cell)\n\t\t{\n\t\t\tif(stream_process(msg,cur_cell,str1,str2,re,op,desc)==1)\n\t\t\t\trez = 1;\n\t\t\tcur_cell = cur_cell->next;\n\t\t}\n\n\t\tcur_session = cur_session->next;\n\n\t}\n\n\treturn rez;\n}"", ""caller_start"": 307, ""file_path"": ""modules/sipmsgops/codecs.c""}]}, {""source"": ""func_info(func:srs_add_raw_sdp_stream)"", ""result"": [{""code"": ""int srs_add_raw_sdp_stream(int label, int medianum, str *body,\n\t\tsiprec_uuid *uuid, struct src_sess *sess, struct src_part *part)\n{\n\tstruct srs_sdp_stream *stream = NULL;\n\n\tstream = shm_malloc(sizeof *stream);\n\tif (!stream) {\n\t\tLM_ERR(\""cannot allocate memory for new stream!\\n\"");\n\t\treturn -1;\n\t}\n\tmemset(stream, 0, sizeof *stream);\n\tstream->body.s = shm_malloc(body->len);\n\tif (!stream->body.s) {\n\t\tLM_ERR(\""cannot add body for the loaded stream!\\n\"");\n\t\tshm_free(stream);\n\t\treturn -1;\n\t}\n\tstream->label = label;\n\tstream->medianum = medianum;\n\tmemcpy(stream->body.s, body->s, body->len);\n\tstream->body.len = body->len;\n\n\tmemcpy(stream->uuid, uuid, sizeof *uuid);\n\tlist_add_tail(&stream->list, &part->streams);\n\tsess->streams_no++;\n\n\treturn 0;\n}"", ""start_line"": 153, ""end_line"": 180, ""full_name"": ""srs_add_raw_sdp_stream"", ""file_path"": ""modules/siprec/siprec_body.c""}]}, {""source"": ""func_info(func:srs_fill_sdp_stream)"", ""result"": [{""code"": ""int srs_fill_sdp_stream(struct sip_msg *msg, struct src_sess *sess,\n\t\tstruct src_part *part, int update)\n{\n\tchar sdp_type;\n\tchar *tmps;\n\tchar *allocated_buf;\n\tint label_len, media_inactive, tmp_len;\n\tsdp_info_t *msg_sdp;\n\tsdp_session_cell_t *msg_session;\n\tsdp_stream_cell_t *msg_stream;\n\tstr tmp_buf, globals_buf, media_buf, line;\n\tchar *start, *end;\n\tint streams_no = 0;\n\tint medianum = 0;\n\tint label;\n\tint stream_port;\n\tint inactive_streams = 0;\n\tint free_sdp = 0;\n\n\tstruct srs_sdp_stream *stream = NULL;\n\n\tmsg_sdp = siprec_parse_sdp(msg, &free_sdp);\n\tif (!msg_sdp)\n\t\treturn 0;\n\tallocated_buf = NULL;\n\t/*\n\t * we are only interested by streams, because everything else will be\n\t * generated by us\n\t */\n\tfor (msg_session = msg_sdp->sessions; msg_session;\n\t\t\tmsg_session = msg_session->next) {\n\t\t/* we first compute the global lines */\n\n\t\t/*\n\t\t * we need to parse it line by line, because the parser does not\n\t\t * support that; we allocate the whole body in sdp and adjust in shm\n\t\t */\n\t\tallocated_buf = pkg_malloc(msg_session->body.len);\n\t\tif (!allocated_buf) {\n\t\t\tLM_ERR(\""no more pkg memory to build body stream!\\n\"");\n\t\t\tgoto error;\n\t\t}\n\t\ttmp_buf.s = allocated_buf;\n\t\ttmp_buf.len = 0;\n\n\t\tstart = msg_session->body.s;\n\t\tend = start + msg_session->body.len;\n\n\t\twhile ((sdp_type = srs_get_sdp_line(start, end, &line)) != 0) {\n\t\t\t/* globals are just until they reach m= line */\n\t\t\tif (sdp_type == 'm')\n\t\t\t\tbreak;\n\t\t\t/* XXX: we need separate buffers for each type, because they need\n\t\t\t * to be all in order when we put them in the session */\n\t\t\telse if (sdp_type == 'b' ||sdp_type == 'z' || sdp_type == 'k' || sdp_type == 'a') {\n\t\t\t\tmemcpy(tmp_buf.s + tmp_buf.len, line.s, line.len);\n\t\t\t\ttmp_buf.len += line.len;\n\t\t\t}\n\t\t\tstart += line.len;\n\t\t}\n\t\tglobals_buf = tmp_buf;\n\n\t\tfor (msg_stream = msg_session->streams; msg_stream;\n\t\t\t\tmsg_stream = msg_stream->next) {\n\n\t\t\t/* if it is not RTP, we are not interested */\n\t\t\tif (!msg_stream->is_rtp)\n\t\t\t\tcontinue;\n\n\t\t\t/* use the rest of the buffer here */\n\t\t\ttmp_buf.s += globals_buf.len;\n\t\t\ttmp_buf.len = 0;\n\t\t\tmedia_buf.s = 0;\n\t\t\tmedia_buf.len = 0;\n\n\t\t\tstart = msg_stream->body.s;\n\t\t\tend = start + msg_stream->body.len;\n\n\t\t\tmedia_inactive = msg_stream->is_on_hold ? 1: 0;\n\t\t\tmedianum++;\n\n\t\t\tif (update) {\n\t\t\t\tstream = srs_get_part_stream(part, medianum);\n\t\t\t\tif (!stream) {\n\t\t\t\t\tLM_ERR(\""cannot find stream for medianum = %d\\n\"", medianum);\n\t\t\t\t\tgoto stream_error;\n\t\t\t\t}\n\t\t\t\tstream_port = stream->port;\n\t\t\t} else {\n\t\t\t\tstream_port = srs_new_port();\n\t\t\t}\n\n\t\t\twhile ((sdp_type = srs_get_sdp_line(start, end, &line)) != 0) {\n\t\t\t\tswitch (sdp_type) {\n\t\t\t\tcase 'm':\n\t\t\t\t\t/*\n\t\t\t\t\t * the m line needs to be copied almost idetically, except\n\t\t\t\t\t * the port needs to be altered to make sure it does not\n\t\t\t\t\t * overlap\n\t\t\t\t\t */\n\t\t\t\t\tmedia_buf = tmp_buf;\n\n\t\t\t\t\t/* media */\n\t\t\t\t\tmemcpy(media_buf.s, line.s, msg_stream->port.s - line.s);\n\t\t\t\t\tmedia_buf.len += msg_stream->port.s - line.s;\n\n\t\t\t\t\t/* port */\n\t\t\t\t\ttmps = int2str(stream_port, &tmp_len);\n\t\t\t\t\tmemcpy(media_buf.s + media_buf.len, tmps, tmp_len);\n\t\t\t\t\tmedia_buf.len += tmp_len;\n\t\t\t\t\tmedia_buf.s[media_buf.len++] = ' ';\n\n\t\t\t\t\t/* the rest of the transport */\n\t\t\t\t\ttmp_len = line.len - (msg_stream->transport.s - line.s);\n\t\t\t\t\tmemcpy(media_buf.s + media_buf.len, msg_stream->transport.s, tmp_len);\n\t\t\t\t\tmedia_buf.len += tmp_len;\n\n\t\t\t\t\t/* adjust the tmp_buf */\n\t\t\t\t\ttmp_buf.s += media_buf.len;\n\t\t\t\t\ttmp_buf.len = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'a':\n\t\t\t\t\t/* we skip a=send/recv/only and a=label attributes\n\t\t\t\t\t * because they will be added later by us */\n\t\t\t\t\tif (line.len > 8 /* a=label: */ &&\n\t\t\t\t\t\t\tmemcmp(line.s + 2, \""label:\"", 6) == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse if (line.len > 2 /* a= */ + 8 + 1/* \\r */ &&\n\t\t\t\t\t\t\t(line.s[10] == '\\r' || line.s[10] == '\\n')) {\n\t\t\t\t\t\tif (memcmp(line.s + 2, \""sendrecv\"", 8) == 0 ||\n\t\t\t\t\t\t\t\tmemcmp(line.s + 2, \""sendonly\"", 8) == 0) {\n\t\t\t\t\t\t\tmedia_inactive = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (memcmp(line.s + 2, \""recvonly\"", 8) == 0 ||\n\t\t\t\t\t\t\t\tmemcmp(line.s + 2, \""inactive\"", 8) == 0) {\n\t\t\t\t\t\t\tmedia_inactive = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLM_INFO(\""check passed for [%.*s]\\n\"", 8, line.s + 2);\n\t\t\t\t\t}\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'k':\n\t\t\t\t\tmemcpy(tmp_buf.s + tmp_buf.len, line.s, line.len);\n\t\t\t\t\ttmp_buf.len += line.len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstart += line.len;\n\t\t\t}\n\n\t\t\tif (update) {\n\t\t\t\t/* get the stream from the participant */\n\t\t\t\tif (stream->body.s) {\n\t\t\t\t\tshm_free(stream->body.s);\n\t\t\t\t\tstream->body.s = NULL;\n\t\t\t\t}\n\t\t\t\tlabel = stream->label;\n\t\t\t} else {\n\n\t\t\t\tstream = shm_malloc(sizeof *stream);\n\t\t\t\tif (!stream) {\n\t\t\t\t\tLM_ERR(\""cannot alloc new stream!\\n\"");\n\t\t\t\t\tgoto stream_error;\n\t\t\t\t}\n\t\t\t\tmemset(stream, 0, sizeof *stream);\n\n\t\t\t\tstream->medianum = medianum;\n\n\t\t\t\t/* initialize uuid */\n\t\t\t\tsiprec_build_uuid(stream->uuid);\n\t\t\t\tstream->port = stream_port;\n\n\t\t\t\tlabel = sess->streams_no + 1;\n\t\t\t\t/* all good, add it into the sdp */\n\t\t\t\tstream->label = label;\n\t\t\t}\n\t\t\t/* compute the extra length of the stream */\n\t\t\ttmp_len = 12/* a=inactive\\r\\n or a=sendonly\\r\\n */;\n\t\t\ttmps = int2str(label, &label_len);\n\t\t\ttmp_len += 8 /* a=label: */ + label_len + 2 /* \\r\\n */;\n\n\t\t\t/* create a new stream to dump all data into */\n\t\t\tstream->body.s = shm_malloc(globals_buf.len +\n\t\t\t\t\tmedia_buf.len + tmp_buf.len + tmp_len);\n\t\t\tif (!stream->body.s) {\n\t\t\t\tLM_ERR(\""cannot alloc new body for stream!\\n\"");\n\t\t\t\tgoto stream_error;\n\t\t\t}\n\n\t\t\t/* m line */\n\t\t\tmemcpy(stream->body.s, media_buf.s, media_buf.len);\n\t\t\tstream->body.len = media_buf.len;\n\n\t\t\tmemcpy(stream->body.s + stream->body.len, globals_buf.s, globals_buf.len);\n\t\t\tstream->body.len += globals_buf.len;\n\n\t\t\tmemcpy(stream->body.s + stream->body.len, tmp_buf.s, tmp_buf.len);\n\t\t\tstream->body.len += tmp_buf.len;\n\n\t\t\t/* a=label line */\n\t\t\tmemcpy(stream->body.s + stream->body.len, \""a=label:\"", 8);\n\t\t\tstream->body.len += 8;\n\t\t\tmemcpy(stream->body.s + stream->body.len, tmps, label_len);\n\t\t\tstream->body.len += label_len;\n\t\t\tmemcpy(stream->body.s + stream->body.len, \""\\r\\na=\"", 4);\n\t\t\tstream->body.len += 4;\n\n\t\t\t/* sendonly or inactive */\n\t\t\tif (media_inactive) {\n\t\t\t\tmemcpy(stream->body.s + stream->body.len, \""inactive\\r\\n\"", 10);\n\t\t\t\tinactive_streams++;\n\t\t\t} else\n\t\t\t\tmemcpy(stream->body.s + stream->body.len, \""sendonly\\r\\n\"", 10);\n\t\t\tstream->body.len += 10;\n\n\t\t\tif (!update) {\n\t\t\t\tlist_add_tail(&stream->list, &part->streams);\n\t\t\t\tsess->streams_no++;\n\t\t\t}\n\n\t\t\tstreams_no++;\n\t\t}\n\t\tpkg_free(allocated_buf);\n\t}\n\t/* update inactive streams */\n\tif (free_sdp)\n\t\tfree_sdp_content(msg_sdp);\n\tsess->streams_inactive = inactive_streams;\n\treturn streams_no;\nstream_error:\n\tpkg_free(allocated_buf);\nerror:\n\tif (free_sdp)\n\t\tfree_sdp_content(msg_sdp);\n\treturn -1;\n}\n"", ""start_line"": 226, ""end_line"": 462, ""full_name"": ""srs_fill_sdp_stream"", ""file_path"": ""modules/siprec/siprec_body.c""}]}, {""source"": ""func_info(func:parse_sdp)"", ""result"": [{""code"": ""sdp_info_t* parse_sdp(struct sip_msg* _m)\n{\n\tstruct body_part *part;\n\tsdp_info_t *sdp, *ret;\n\n\tif ( parse_sip_body(_m)<0 || _m->body==NULL) {\n\t\tLM_DBG(\""message body has length zero\\n\"");\n\t\treturn NULL;\n\t}\n\n\tret = NULL;\n\n\t/* iterate all body parts and look for the SDP mime */\n\tfor( part=&_m->body->first ; part ; part=part->next) {\n\n\t\t/* skip body parts which were deleted or newly added */\n\t\tif (!is_body_part_received(part))\n\t\t\tcontinue;\n\n\t\tif ( part->mime != ((TYPE_APPLICATION<<16)+SUBTYPE_SDP) )\n\t\t\tcontinue;\n\n\t\tif (part->parsed) {\n\t\t\tif (!ret)\n\t\t\t\tret = part->parsed;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( (sdp=new_sdp())==NULL ) {\n\t\t\tLM_ERR(\""Can't create new sdp, skipping\\n\"");\n\t\t} else {\n\t\t\tif (parse_sdp_session(&part->body, 0, NULL, sdp)<0) {\n\t\t\t\tLM_ERR(\""failed to parse SDP for body part, skipping\\n\"");\n\t\t\t\tfree_sdp( sdp );\n\t\t\t} else {\n\t\t\t\tpart->parsed = (void*)sdp;\n\t\t\t\tpart->free_parsed_f = (free_parsed_part_function)free_sdp;\n\t\t\t\t/* remember the first found SDP */\n\t\t\t\tif (!ret) ret = sdp;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n"", ""start_line"": 633, ""end_line"": 677, ""full_name"": ""parse_sdp"", ""file_path"": ""parser/sdp/sdp.c""}]}, {""source"": ""func_info(func:srs_add_raw_sdp_stream)"", ""result"": [{""code"": ""int srs_add_raw_sdp_stream(int label, int medianum, str *body,\n\t\tsiprec_uuid *uuid, struct src_sess *sess, struct src_part *part)\n{\n\tstruct srs_sdp_stream *stream = NULL;\n\n\tstream = shm_malloc(sizeof *stream);\n\tif (!stream) {\n\t\tLM_ERR(\""cannot allocate memory for new stream!\\n\"");\n\t\treturn -1;\n\t}\n\tmemset(stream, 0, sizeof *stream);\n\tstream->body.s = shm_malloc(body->len);\n\tif (!stream->body.s) {\n\t\tLM_ERR(\""cannot add body for the loaded stream!\\n\"");\n\t\tshm_free(stream);\n\t\treturn -1;\n\t}\n\tstream->label = label;\n\tstream->medianum = medianum;\n\tmemcpy(stream->body.s, body->s, body->len);\n\tstream->body.len = body->len;\n\n\tmemcpy(stream->uuid, uuid, sizeof *uuid);\n\tlist_add_tail(&stream->list, &part->streams);\n\tsess->streams_no++;\n\n\treturn 0;\n}"", ""start_line"": 153, ""end_line"": 180, ""full_name"": ""srs_add_raw_sdp_stream"", ""file_path"": ""modules/siprec/siprec_body.c""}]}, {""source"": ""func_info(func:srs_fill_sdp_stream)"", ""result"": [{""code"": ""int srs_fill_sdp_stream(struct sip_msg *msg, struct src_sess *sess,\n\t\tstruct src_part *part, int update)\n{\n\tchar sdp_type;\n\tchar *tmps;\n\tchar *allocated_buf;\n\tint label_len, media_inactive, tmp_len;\n\tsdp_info_t *msg_sdp;\n\tsdp_session_cell_t *msg_session;\n\tsdp_stream_cell_t *msg_stream;\n\tstr tmp_buf, globals_buf, media_buf, line;\n\tchar *start, *end;\n\tint streams_no = 0;\n\tint medianum = 0;\n\tint label;\n\tint stream_port;\n\tint inactive_streams = 0;\n\tint free_sdp = 0;\n\n\tstruct srs_sdp_stream *stream = NULL;\n\n\tmsg_sdp = siprec_parse_sdp(msg, &free_sdp);\n\tif (!msg_sdp)\n\t\treturn 0;\n\tallocated_buf = NULL;\n\t/*\n\t * we are only interested by streams, because everything else will be\n\t * generated by us\n\t */\n\tfor (msg_session = msg_sdp->sessions; msg_session;\n\t\t\tmsg_session = msg_session->next) {\n\t\t/* we first compute the global lines */\n\n\t\t/*\n\t\t * we need to parse it line by line, because the parser does not\n\t\t * support that; we allocate the whole body in sdp and adjust in shm\n\t\t */\n\t\tallocated_buf = pkg_malloc(msg_session->body.len);\n\t\tif (!allocated_buf) {\n\t\t\tLM_ERR(\""no more pkg memory to build body stream!\\n\"");\n\t\t\tgoto error;\n\t\t}\n\t\ttmp_buf.s = allocated_buf;\n\t\ttmp_buf.len = 0;\n\n\t\tstart = msg_session->body.s;\n\t\tend = start + msg_session->body.len;\n\n\t\twhile ((sdp_type = srs_get_sdp_line(start, end, &line)) != 0) {\n\t\t\t/* globals are just until they reach m= line */\n\t\t\tif (sdp_type == 'm')\n\t\t\t\tbreak;\n\t\t\t/* XXX: we need separate buffers for each type, because they need\n\t\t\t * to be all in order when we put them in the session */\n\t\t\telse if (sdp_type == 'b' ||sdp_type == 'z' || sdp_type == 'k' || sdp_type == 'a') {\n\t\t\t\tmemcpy(tmp_buf.s + tmp_buf.len, line.s, line.len);\n\t\t\t\ttmp_buf.len += line.len;\n\t\t\t}\n\t\t\tstart += line.len;\n\t\t}\n\t\tglobals_buf = tmp_buf;\n\n\t\tfor (msg_stream = msg_session->streams; msg_stream;\n\t\t\t\tmsg_stream = msg_stream->next) {\n\n\t\t\t/* if it is not RTP, we are not interested */\n\t\t\tif (!msg_stream->is_rtp)\n\t\t\t\tcontinue;\n\n\t\t\t/* use the rest of the buffer here */\n\t\t\ttmp_buf.s += globals_buf.len;\n\t\t\ttmp_buf.len = 0;\n\t\t\tmedia_buf.s = 0;\n\t\t\tmedia_buf.len = 0;\n\n\t\t\tstart = msg_stream->body.s;\n\t\t\tend = start + msg_stream->body.len;\n\n\t\t\tmedia_inactive = msg_stream->is_on_hold ? 1: 0;\n\t\t\tmedianum++;\n\n\t\t\tif (update) {\n\t\t\t\tstream = srs_get_part_stream(part, medianum);\n\t\t\t\tif (!stream) {\n\t\t\t\t\tLM_ERR(\""cannot find stream for medianum = %d\\n\"", medianum);\n\t\t\t\t\tgoto stream_error;\n\t\t\t\t}\n\t\t\t\tstream_port = stream->port;\n\t\t\t} else {\n\t\t\t\tstream_port = srs_new_port();\n\t\t\t}\n\n\t\t\twhile ((sdp_type = srs_get_sdp_line(start, end, &line)) != 0) {\n\t\t\t\tswitch (sdp_type) {\n\t\t\t\tcase 'm':\n\t\t\t\t\t/*\n\t\t\t\t\t * the m line needs to be copied almost idetically, except\n\t\t\t\t\t * the port needs to be altered to make sure it does not\n\t\t\t\t\t * overlap\n\t\t\t\t\t */\n\t\t\t\t\tmedia_buf = tmp_buf;\n\n\t\t\t\t\t/* media */\n\t\t\t\t\tmemcpy(media_buf.s, line.s, msg_stream->port.s - line.s);\n\t\t\t\t\tmedia_buf.len += msg_stream->port.s - line.s;\n\n\t\t\t\t\t/* port */\n\t\t\t\t\ttmps = int2str(stream_port, &tmp_len);\n\t\t\t\t\tmemcpy(media_buf.s + media_buf.len, tmps, tmp_len);\n\t\t\t\t\tmedia_buf.len += tmp_len;\n\t\t\t\t\tmedia_buf.s[media_buf.len++] = ' ';\n\n\t\t\t\t\t/* the rest of the transport */\n\t\t\t\t\ttmp_len = line.len - (msg_stream->transport.s - line.s);\n\t\t\t\t\tmemcpy(media_buf.s + media_buf.len, msg_stream->transport.s, tmp_len);\n\t\t\t\t\tmedia_buf.len += tmp_len;\n\n\t\t\t\t\t/* adjust the tmp_buf */\n\t\t\t\t\ttmp_buf.s += media_buf.len;\n\t\t\t\t\ttmp_buf.len = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'a':\n\t\t\t\t\t/* we skip a=send/recv/only and a=label attributes\n\t\t\t\t\t * because they will be added later by us */\n\t\t\t\t\tif (line.len > 8 /* a=label: */ &&\n\t\t\t\t\t\t\tmemcmp(line.s + 2, \""label:\"", 6) == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse if (line.len > 2 /* a= */ + 8 + 1/* \\r */ &&\n\t\t\t\t\t\t\t(line.s[10] == '\\r' || line.s[10] == '\\n')) {\n\t\t\t\t\t\tif (memcmp(line.s + 2, \""sendrecv\"", 8) == 0 ||\n\t\t\t\t\t\t\t\tmemcmp(line.s + 2, \""sendonly\"", 8) == 0) {\n\t\t\t\t\t\t\tmedia_inactive = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (memcmp(line.s + 2, \""recvonly\"", 8) == 0 ||\n\t\t\t\t\t\t\t\tmemcmp(line.s + 2, \""inactive\"", 8) == 0) {\n\t\t\t\t\t\t\tmedia_inactive = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLM_INFO(\""check passed for [%.*s]\\n\"", 8, line.s + 2);\n\t\t\t\t\t}\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'k':\n\t\t\t\t\tmemcpy(tmp_buf.s + tmp_buf.len, line.s, line.len);\n\t\t\t\t\ttmp_buf.len += line.len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstart += line.len;\n\t\t\t}\n\n\t\t\tif (update) {\n\t\t\t\t/* get the stream from the participant */\n\t\t\t\tif (stream->body.s) {\n\t\t\t\t\tshm_free(stream->body.s);\n\t\t\t\t\tstream->body.s = NULL;\n\t\t\t\t}\n\t\t\t\tlabel = stream->label;\n\t\t\t} else {\n\n\t\t\t\tstream = shm_malloc(sizeof *stream);\n\t\t\t\tif (!stream) {\n\t\t\t\t\tLM_ERR(\""cannot alloc new stream!\\n\"");\n\t\t\t\t\tgoto stream_error;\n\t\t\t\t}\n\t\t\t\tmemset(stream, 0, sizeof *stream);\n\n\t\t\t\tstream->medianum = medianum;\n\n\t\t\t\t/* initialize uuid */\n\t\t\t\tsiprec_build_uuid(stream->uuid);\n\t\t\t\tstream->port = stream_port;\n\n\t\t\t\tlabel = sess->streams_no + 1;\n\t\t\t\t/* all good, add it into the sdp */\n\t\t\t\tstream->label = label;\n\t\t\t}\n\t\t\t/* compute the extra length of the stream */\n\t\t\ttmp_len = 12/* a=inactive\\r\\n or a=sendonly\\r\\n */;\n\t\t\ttmps = int2str(label, &label_len);\n\t\t\ttmp_len += 8 /* a=label: */ + label_len + 2 /* \\r\\n */;\n\n\t\t\t/* create a new stream to dump all data into */\n\t\t\tstream->body.s = shm_malloc(globals_buf.len +\n\t\t\t\t\tmedia_buf.len + tmp_buf.len + tmp_len);\n\t\t\tif (!stream->body.s) {\n\t\t\t\tLM_ERR(\""cannot alloc new body for stream!\\n\"");\n\t\t\t\tgoto stream_error;\n\t\t\t}\n\n\t\t\t/* m line */\n\t\t\tmemcpy(stream->body.s, media_buf.s, media_buf.len);\n\t\t\tstream->body.len = media_buf.len;\n\n\t\t\tmemcpy(stream->body.s + stream->body.len, globals_buf.s, globals_buf.len);\n\t\t\tstream->body.len += globals_buf.len;\n\n\t\t\tmemcpy(stream->body.s + stream->body.len, tmp_buf.s, tmp_buf.len);\n\t\t\tstream->body.len += tmp_buf.len;\n\n\t\t\t/* a=label line */\n\t\t\tmemcpy(stream->body.s + stream->body.len, \""a=label:\"", 8);\n\t\t\tstream->body.len += 8;\n\t\t\tmemcpy(stream->body.s + stream->body.len, tmps, label_len);\n\t\t\tstream->body.len += label_len;\n\t\t\tmemcpy(stream->body.s + stream->body.len, \""\\r\\na=\"", 4);\n\t\t\tstream->body.len += 4;\n\n\t\t\t/* sendonly or inactive */\n\t\t\tif (media_inactive) {\n\t\t\t\tmemcpy(stream->body.s + stream->body.len, \""inactive\\r\\n\"", 10);\n\t\t\t\tinactive_streams++;\n\t\t\t} else\n\t\t\t\tmemcpy(stream->body.s + stream->body.len, \""sendonly\\r\\n\"", 10);\n\t\t\tstream->body.len += 10;\n\n\t\t\tif (!update) {\n\t\t\t\tlist_add_tail(&stream->list, &part->streams);\n\t\t\t\tsess->streams_no++;\n\t\t\t}\n\n\t\t\tstreams_no++;\n\t\t}\n\t\tpkg_free(allocated_buf);\n\t}\n\t/* update inactive streams */\n\tif (free_sdp)\n\t\tfree_sdp_content(msg_sdp);\n\tsess->streams_inactive = inactive_streams;\n\treturn streams_no;\nstream_error:\n\tpkg_free(allocated_buf);\nerror:\n\tif (free_sdp)\n\t\tfree_sdp_content(msg_sdp);\n\treturn -1;\n}\n"", ""start_line"": 226, ""end_line"": 462, ""full_name"": ""srs_fill_sdp_stream"", ""file_path"": ""modules/siprec/siprec_body.c""}]}, {""source"": ""func_info(func:parse_sdp)"", ""result"": [{""code"": ""sdp_info_t* parse_sdp(struct sip_msg* _m)\n{\n\tstruct body_part *part;\n\tsdp_info_t *sdp, *ret;\n\n\tif ( parse_sip_body(_m)<0 || _m->body==NULL) {\n\t\tLM_DBG(\""message body has length zero\\n\"");\n\t\treturn NULL;\n\t}\n\n\tret = NULL;\n\n\t/* iterate all body parts and look for the SDP mime */\n\tfor( part=&_m->body->first ; part ; part=part->next) {\n\n\t\t/* skip body parts which were deleted or newly added */\n\t\tif (!is_body_part_received(part))\n\t\t\tcontinue;\n\n\t\tif ( part->mime != ((TYPE_APPLICATION<<16)+SUBTYPE_SDP) )\n\t\t\tcontinue;\n\n\t\tif (part->parsed) {\n\t\t\tif (!ret)\n\t\t\t\tret = part->parsed;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( (sdp=new_sdp())==NULL ) {\n\t\t\tLM_ERR(\""Can't create new sdp, skipping\\n\"");\n\t\t} else {\n\t\t\tif (parse_sdp_session(&part->body, 0, NULL, sdp)<0) {\n\t\t\t\tLM_ERR(\""failed to parse SDP for body part, skipping\\n\"");\n\t\t\t\tfree_sdp( sdp );\n\t\t\t} else {\n\t\t\t\tpart->parsed = (void*)sdp;\n\t\t\t\tpart->free_parsed_f = (free_parsed_part_function)free_sdp;\n\t\t\t\t/* remember the first found SDP */\n\t\t\t\tif (!ret) ret = sdp;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n"", ""start_line"": 633, ""end_line"": 677, ""full_name"": ""parse_sdp"", ""file_path"": ""parser/sdp/sdp.c""}]}, {""source"": ""func_info(func:parse_sip_body)"", ""result"": [{""code"": ""int parse_sip_body(struct sip_msg * msg)\n{\n\tchar *start, *end;\n\tint type = 0;\n\tstruct body_part *part, *last;\n\tstr delimiter, body;\n\n\t/* is body already parsed ? */\n\tif (msg->body)\n\t\treturn 0;\n\n\tif ( get_body(msg,&body)!=0 || body.len==0)\n\t\treturn 0;\n\n\ttype = parse_content_type_hdr(msg);\n\tif (type <= 0)\n\t\treturn 0;\n\n\tmsg->body = pkg_malloc(sizeof (struct sip_msg_body));\n\tif (msg->body == 0)\n\t{\n\t\tLM_ERR(\""Unable to allocate memory\\n\"");\n\t\treturn -1;\n\t}\n\tmemset(msg->body, 0, sizeof (struct sip_msg_body));\n\n\tmsg->body->body = body;\n\n\tmsg->body->boundary = ((content_t *) msg->content_type->parsed)->boundary;\n\n\tif ((type >> 16) == TYPE_MULTIPART)\n\t{\n\t\tmsg->body->flags |= SIP_BODY_RCV_MULTIPART;\n\t\tdelimiter = ((content_t*) msg->content_type->parsed)->boundary;\n\n\t\tLM_DBG(\""Starting parsing with boundary = [%.*s]\\n\"",\n\t\t\tdelimiter.len, delimiter.s);\n\n\t\tstart = find_line_delimiter( body.s, body.s + body.len, delimiter);\n\t\tif (start == NULL) {\n\t\t\tLM_ERR(\""Unable to parse multipart type:\""\n\t\t\t\t\"" malformed - missing start delimiters\\n\"");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* mark as first part (no previous one) */\n\t\tlast = NULL;\n\n\t\twhile (1)\n\t\t{\n\t\t\tend = find_line_delimiter(start + 1, body.s + body.len,\n\t\t\t\tdelimiter);\n\t\t\tif (end == NULL)\n\t\t\t\tbreak;\n\n\t\t\t/* is it the first part ? */\n\t\t\tif (last==NULL) {\n\t\t\t\tpart = &msg->body->first;\n\t\t\t} else {\n\t\t\t\tif ( (part=new_part()) == NULL )\n\t\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* add 4 to delimiter 2 for \""--\""*/\n\t\t\tif (parse_single_part(part, start + delimiter.len + 2, end)!=0) {\n\t\t\t\tLM_ERR(\""Unable to parse part:[%.*s]\\n\"",(int)(end-start),start);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* set the parsing for the next cycle */\n\t\t\tstart = end;\n\n\t\t\t/* link the new part; note that the first part is part of \n\t\t\t * the body structure, no need to be linked */\n\t\t\tif (last)\n\t\t\t\tlast->next = part;\n\t\t\tlast = part;\n\t\t\tmsg->body->part_count++;\n\n\t\t}\n\n\t} else {\n\n\t\t/* only one part in the body */\n\t\tpart = &msg->body->first;\n\n\t\tpart->mime = type;\n\t\tpart->mime_s = msg->content_type->body;\n\t\tpart->body = body;\n\t\tpart->headers.s = NULL;\n\t\tpart->headers.len = 0;\n\t\tmsg->body->part_count++;\n\t}\n\n\tmsg->body->updated_part_count = msg->body->part_count;\n\n\treturn 0;\n\n};\n"", ""start_line"": 230, ""end_line"": 328, ""full_name"": ""parse_sip_body"", ""file_path"": ""parser/parse_body.c""}]}, {""source"": ""func_info(func:parse_sdp)"", ""result"": [{""code"": ""sdp_info_t* parse_sdp(struct sip_msg* _m)\n{\n\tstruct body_part *part;\n\tsdp_info_t *sdp, *ret;\n\n\tif ( parse_sip_body(_m)<0 || _m->body==NULL) {\n\t\tLM_DBG(\""message body has length zero\\n\"");\n\t\treturn NULL;\n\t}\n\n\tret = NULL;\n\n\t/* iterate all body parts and look for the SDP mime */\n\tfor( part=&_m->body->first ; part ; part=part->next) {\n\n\t\t/* skip body parts which were deleted or newly added */\n\t\tif (!is_body_part_received(part))\n\t\t\tcontinue;\n\n\t\tif ( part->mime != ((TYPE_APPLICATION<<16)+SUBTYPE_SDP) )\n\t\t\tcontinue;\n\n\t\tif (part->parsed) {\n\t\t\tif (!ret)\n\t\t\t\tret = part->parsed;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( (sdp=new_sdp())==NULL ) {\n\t\t\tLM_ERR(\""Can't create new sdp, skipping\\n\"");\n\t\t} else {\n\t\t\tif (parse_sdp_session(&part->body, 0, NULL, sdp)<0) {\n\t\t\t\tLM_ERR(\""failed to parse SDP for body part, skipping\\n\"");\n\t\t\t\tfree_sdp( sdp );\n\t\t\t} else {\n\t\t\t\tpart->parsed = (void*)sdp;\n\t\t\t\tpart->free_parsed_f = (free_parsed_part_function)free_sdp;\n\t\t\t\t/* remember the first found SDP */\n\t\t\t\tif (!ret) ret = sdp;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n"", ""start_line"": 633, ""end_line"": 677, ""full_name"": ""parse_sdp"", ""file_path"": ""parser/sdp/sdp.c""}]}, {""source"": ""func_info(func:srs_add_raw_sdp_stream)"", ""result"": [{""code"": ""int srs_add_raw_sdp_stream(int label, int medianum, str *body,\n\t\tsiprec_uuid *uuid, struct src_sess *sess, struct src_part *part)\n{\n\tstruct srs_sdp_stream *stream = NULL;\n\n\tstream = shm_malloc(sizeof *stream);\n\tif (!stream) {\n\t\tLM_ERR(\""cannot allocate memory for new stream!\\n\"");\n\t\treturn -1;\n\t}\n\tmemset(stream, 0, sizeof *stream);\n\tstream->body.s = shm_malloc(body->len);\n\tif (!stream->body.s) {\n\t\tLM_ERR(\""cannot add body for the loaded stream!\\n\"");\n\t\tshm_free(stream);\n\t\treturn -1;\n\t}\n\tstream->label = label;\n\tstream->medianum = medianum;\n\tmemcpy(stream->body.s, body->s, body->len);\n\tstream->body.len = body->len;\n\n\tmemcpy(stream->uuid, uuid, sizeof *uuid);\n\tlist_add_tail(&stream->list, &part->streams);\n\tsess->streams_no++;\n\n\treturn 0;\n}"", ""start_line"": 153, ""end_line"": 180, ""full_name"": ""srs_add_raw_sdp_stream"", ""file_path"": ""modules/siprec/siprec_body.c""}]}, {""source"": ""func_info(func:srs_fill_sdp_stream)"", ""result"": [{""code"": ""int srs_fill_sdp_stream(struct sip_msg *msg, struct src_sess *sess,\n\t\tstruct src_part *part, int update)\n{\n\tchar sdp_type;\n\tchar *tmps;\n\tchar *allocated_buf;\n\tint label_len, media_inactive, tmp_len;\n\tsdp_info_t *msg_sdp;\n\tsdp_session_cell_t *msg_session;\n\tsdp_stream_cell_t *msg_stream;\n\tstr tmp_buf, globals_buf, media_buf, line;\n\tchar *start, *end;\n\tint streams_no = 0;\n\tint medianum = 0;\n\tint label;\n\tint stream_port;\n\tint inactive_streams = 0;\n\tint free_sdp = 0;\n\n\tstruct srs_sdp_stream *stream = NULL;\n\n\tmsg_sdp = siprec_parse_sdp(msg, &free_sdp);\n\tif (!msg_sdp)\n\t\treturn 0;\n\tallocated_buf = NULL;\n\t/*\n\t * we are only interested by streams, because everything else will be\n\t * generated by us\n\t */\n\tfor (msg_session = msg_sdp->sessions; msg_session;\n\t\t\tmsg_session = msg_session->next) {\n\t\t/* we first compute the global lines */\n\n\t\t/*\n\t\t * we need to parse it line by line, because the parser does not\n\t\t * support that; we allocate the whole body in sdp and adjust in shm\n\t\t */\n\t\tallocated_buf = pkg_malloc(msg_session->body.len);\n\t\tif (!allocated_buf) {\n\t\t\tLM_ERR(\""no more pkg memory to build body stream!\\n\"");\n\t\t\tgoto error;\n\t\t}\n\t\ttmp_buf.s = allocated_buf;\n\t\ttmp_buf.len = 0;\n\n\t\tstart = msg_session->body.s;\n\t\tend = start + msg_session->body.len;\n\n\t\twhile ((sdp_type = srs_get_sdp_line(start, end, &line)) != 0) {\n\t\t\t/* globals are just until they reach m= line */\n\t\t\tif (sdp_type == 'm')\n\t\t\t\tbreak;\n\t\t\t/* XXX: we need separate buffers for each type, because they need\n\t\t\t * to be all in order when we put them in the session */\n\t\t\telse if (sdp_type == 'b' ||sdp_type == 'z' || sdp_type == 'k' || sdp_type == 'a') {\n\t\t\t\tmemcpy(tmp_buf.s + tmp_buf.len, line.s, line.len);\n\t\t\t\ttmp_buf.len += line.len;\n\t\t\t}\n\t\t\tstart += line.len;\n\t\t}\n\t\tglobals_buf = tmp_buf;\n\n\t\tfor (msg_stream = msg_session->streams; msg_stream;\n\t\t\t\tmsg_stream = msg_stream->next) {\n\n\t\t\t/* if it is not RTP, we are not interested */\n\t\t\tif (!msg_stream->is_rtp)\n\t\t\t\tcontinue;\n\n\t\t\t/* use the rest of the buffer here */\n\t\t\ttmp_buf.s += globals_buf.len;\n\t\t\ttmp_buf.len = 0;\n\t\t\tmedia_buf.s = 0;\n\t\t\tmedia_buf.len = 0;\n\n\t\t\tstart = msg_stream->body.s;\n\t\t\tend = start + msg_stream->body.len;\n\n\t\t\tmedia_inactive = msg_stream->is_on_hold ? 1: 0;\n\t\t\tmedianum++;\n\n\t\t\tif (update) {\n\t\t\t\tstream = srs_get_part_stream(part, medianum);\n\t\t\t\tif (!stream) {\n\t\t\t\t\tLM_ERR(\""cannot find stream for medianum = %d\\n\"", medianum);\n\t\t\t\t\tgoto stream_error;\n\t\t\t\t}\n\t\t\t\tstream_port = stream->port;\n\t\t\t} else {\n\t\t\t\tstream_port = srs_new_port();\n\t\t\t}\n\n\t\t\twhile ((sdp_type = srs_get_sdp_line(start, end, &line)) != 0) {\n\t\t\t\tswitch (sdp_type) {\n\t\t\t\tcase 'm':\n\t\t\t\t\t/*\n\t\t\t\t\t * the m line needs to be copied almost idetically, except\n\t\t\t\t\t * the port needs to be altered to make sure it does not\n\t\t\t\t\t * overlap\n\t\t\t\t\t */\n\t\t\t\t\tmedia_buf = tmp_buf;\n\n\t\t\t\t\t/* media */\n\t\t\t\t\tmemcpy(media_buf.s, line.s, msg_stream->port.s - line.s);\n\t\t\t\t\tmedia_buf.len += msg_stream->port.s - line.s;\n\n\t\t\t\t\t/* port */\n\t\t\t\t\ttmps = int2str(stream_port, &tmp_len);\n\t\t\t\t\tmemcpy(media_buf.s + media_buf.len, tmps, tmp_len);\n\t\t\t\t\tmedia_buf.len += tmp_len;\n\t\t\t\t\tmedia_buf.s[media_buf.len++] = ' ';\n\n\t\t\t\t\t/* the rest of the transport */\n\t\t\t\t\ttmp_len = line.len - (msg_stream->transport.s - line.s);\n\t\t\t\t\tmemcpy(media_buf.s + media_buf.len, msg_stream->transport.s, tmp_len);\n\t\t\t\t\tmedia_buf.len += tmp_len;\n\n\t\t\t\t\t/* adjust the tmp_buf */\n\t\t\t\t\ttmp_buf.s += media_buf.len;\n\t\t\t\t\ttmp_buf.len = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'a':\n\t\t\t\t\t/* we skip a=send/recv/only and a=label attributes\n\t\t\t\t\t * because they will be added later by us */\n\t\t\t\t\tif (line.len > 8 /* a=label: */ &&\n\t\t\t\t\t\t\tmemcmp(line.s + 2, \""label:\"", 6) == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse if (line.len > 2 /* a= */ + 8 + 1/* \\r */ &&\n\t\t\t\t\t\t\t(line.s[10] == '\\r' || line.s[10] == '\\n')) {\n\t\t\t\t\t\tif (memcmp(line.s + 2, \""sendrecv\"", 8) == 0 ||\n\t\t\t\t\t\t\t\tmemcmp(line.s + 2, \""sendonly\"", 8) == 0) {\n\t\t\t\t\t\t\tmedia_inactive = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (memcmp(line.s + 2, \""recvonly\"", 8) == 0 ||\n\t\t\t\t\t\t\t\tmemcmp(line.s + 2, \""inactive\"", 8) == 0) {\n\t\t\t\t\t\t\tmedia_inactive = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLM_INFO(\""check passed for [%.*s]\\n\"", 8, line.s + 2);\n\t\t\t\t\t}\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'k':\n\t\t\t\t\tmemcpy(tmp_buf.s + tmp_buf.len, line.s, line.len);\n\t\t\t\t\ttmp_buf.len += line.len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstart += line.len;\n\t\t\t}\n\n\t\t\tif (update) {\n\t\t\t\t/* get the stream from the participant */\n\t\t\t\tif (stream->body.s) {\n\t\t\t\t\tshm_free(stream->body.s);\n\t\t\t\t\tstream->body.s = NULL;\n\t\t\t\t}\n\t\t\t\tlabel = stream->label;\n\t\t\t} else {\n\n\t\t\t\tstream = shm_malloc(sizeof *stream);\n\t\t\t\tif (!stream) {\n\t\t\t\t\tLM_ERR(\""cannot alloc new stream!\\n\"");\n\t\t\t\t\tgoto stream_error;\n\t\t\t\t}\n\t\t\t\tmemset(stream, 0, sizeof *stream);\n\n\t\t\t\tstream->medianum = medianum;\n\n\t\t\t\t/* initialize uuid */\n\t\t\t\tsiprec_build_uuid(stream->uuid);\n\t\t\t\tstream->port = stream_port;\n\n\t\t\t\tlabel = sess->streams_no + 1;\n\t\t\t\t/* all good, add it into the sdp */\n\t\t\t\tstream->label = label;\n\t\t\t}\n\t\t\t/* compute the extra length of the stream */\n\t\t\ttmp_len = 12/* a=inactive\\r\\n or a=sendonly\\r\\n */;\n\t\t\ttmps = int2str(label, &label_len);\n\t\t\ttmp_len += 8 /* a=label: */ + label_len + 2 /* \\r\\n */;\n\n\t\t\t/* create a new stream to dump all data into */\n\t\t\tstream->body.s = shm_malloc(globals_buf.len +\n\t\t\t\t\tmedia_buf.len + tmp_buf.len + tmp_len);\n\t\t\tif (!stream->body.s) {\n\t\t\t\tLM_ERR(\""cannot alloc new body for stream!\\n\"");\n\t\t\t\tgoto stream_error;\n\t\t\t}\n\n\t\t\t/* m line */\n\t\t\tmemcpy(stream->body.s, media_buf.s, media_buf.len);\n\t\t\tstream->body.len = media_buf.len;\n\n\t\t\tmemcpy(stream->body.s + stream->body.len, globals_buf.s, globals_buf.len);\n\t\t\tstream->body.len += globals_buf.len;\n\n\t\t\tmemcpy(stream->body.s + stream->body.len, tmp_buf.s, tmp_buf.len);\n\t\t\tstream->body.len += tmp_buf.len;\n\n\t\t\t/* a=label line */\n\t\t\tmemcpy(stream->body.s + stream->body.len, \""a=label:\"", 8);\n\t\t\tstream->body.len += 8;\n\t\t\tmemcpy(stream->body.s + stream->body.len, tmps, label_len);\n\t\t\tstream->body.len += label_len;\n\t\t\tmemcpy(stream->body.s + stream->body.len, \""\\r\\na=\"", 4);\n\t\t\tstream->body.len += 4;\n\n\t\t\t/* sendonly or inactive */\n\t\t\tif (media_inactive) {\n\t\t\t\tmemcpy(stream->body.s + stream->body.len, \""inactive\\r\\n\"", 10);\n\t\t\t\tinactive_streams++;\n\t\t\t} else\n\t\t\t\tmemcpy(stream->body.s + stream->body.len, \""sendonly\\r\\n\"", 10);\n\t\t\tstream->body.len += 10;\n\n\t\t\tif (!update) {\n\t\t\t\tlist_add_tail(&stream->list, &part->streams);\n\t\t\t\tsess->streams_no++;\n\t\t\t}\n\n\t\t\tstreams_no++;\n\t\t}\n\t\tpkg_free(allocated_buf);\n\t}\n\t/* update inactive streams */\n\tif (free_sdp)\n\t\tfree_sdp_content(msg_sdp);\n\tsess->streams_inactive = inactive_streams;\n\treturn streams_no;\nstream_error:\n\tpkg_free(allocated_buf);\nerror:\n\tif (free_sdp)\n\t\tfree_sdp_content(msg_sdp);\n\treturn -1;\n}\n"", ""start_line"": 226, ""end_line"": 462, ""full_name"": ""srs_fill_sdp_stream"", ""file_path"": ""modules/siprec/siprec_body.c""}]}, {""source"": ""func_info(func:parse_sip_body)"", ""result"": [{""code"": ""int parse_sip_body(struct sip_msg * msg)\n{\n\tchar *start, *end;\n\tint type = 0;\n\tstruct body_part *part, *last;\n\tstr delimiter, body;\n\n\t/* is body already parsed ? */\n\tif (msg->body)\n\t\treturn 0;\n\n\tif ( get_body(msg,&body)!=0 || body.len==0)\n\t\treturn 0;\n\n\ttype = parse_content_type_hdr(msg);\n\tif (type <= 0)\n\t\treturn 0;\n\n\tmsg->body = pkg_malloc(sizeof (struct sip_msg_body));\n\tif (msg->body == 0)\n\t{\n\t\tLM_ERR(\""Unable to allocate memory\\n\"");\n\t\treturn -1;\n\t}\n\tmemset(msg->body, 0, sizeof (struct sip_msg_body));\n\n\tmsg->body->body = body;\n\n\tmsg->body->boundary = ((content_t *) msg->content_type->parsed)->boundary;\n\n\tif ((type >> 16) == TYPE_MULTIPART)\n\t{\n\t\tmsg->body->flags |= SIP_BODY_RCV_MULTIPART;\n\t\tdelimiter = ((content_t*) msg->content_type->parsed)->boundary;\n\n\t\tLM_DBG(\""Starting parsing with boundary = [%.*s]\\n\"",\n\t\t\tdelimiter.len, delimiter.s);\n\n\t\tstart = find_line_delimiter( body.s, body.s + body.len, delimiter);\n\t\tif (start == NULL) {\n\t\t\tLM_ERR(\""Unable to parse multipart type:\""\n\t\t\t\t\"" malformed - missing start delimiters\\n\"");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* mark as first part (no previous one) */\n\t\tlast = NULL;\n\n\t\twhile (1)\n\t\t{\n\t\t\tend = find_line_delimiter(start + 1, body.s + body.len,\n\t\t\t\tdelimiter);\n\t\t\tif (end == NULL)\n\t\t\t\tbreak;\n\n\t\t\t/* is it the first part ? */\n\t\t\tif (last==NULL) {\n\t\t\t\tpart = &msg->body->first;\n\t\t\t} else {\n\t\t\t\tif ( (part=new_part()) == NULL )\n\t\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* add 4 to delimiter 2 for \""--\""*/\n\t\t\tif (parse_single_part(part, start + delimiter.len + 2, end)!=0) {\n\t\t\t\tLM_ERR(\""Unable to parse part:[%.*s]\\n\"",(int)(end-start),start);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* set the parsing for the next cycle */\n\t\t\tstart = end;\n\n\t\t\t/* link the new part; note that the first part is part of \n\t\t\t * the body structure, no need to be linked */\n\t\t\tif (last)\n\t\t\t\tlast->next = part;\n\t\t\tlast = part;\n\t\t\tmsg->body->part_count++;\n\n\t\t}\n\n\t} else {\n\n\t\t/* only one part in the body */\n\t\tpart = &msg->body->first;\n\n\t\tpart->mime = type;\n\t\tpart->mime_s = msg->content_type->body;\n\t\tpart->body = body;\n\t\tpart->headers.s = NULL;\n\t\tpart->headers.len = 0;\n\t\tmsg->body->part_count++;\n\t}\n\n\tmsg->body->updated_part_count = msg->body->part_count;\n\n\treturn 0;\n\n};\n"", ""start_line"": 230, ""end_line"": 328, ""full_name"": ""parse_sip_body"", ""file_path"": ""parser/parse_body.c""}]}]","Unbounded pointer traversal in `delete_sdp_line` (modules/sipmsgops/codecs.c:351-358) when searching for '\\n' in SDP bodies. The function does not verify that `start` and `end` pointers remain within `stream->body.s` and `stream->body.len`, leading to invalid memory access when processing malformed SDP bodies. `stream->body.s` and `.len` are initialized in `srs_add_raw_sdp_stream` (modules/siprec/siprec_body.c:153-180) and `srs_fill_sdp_stream` (modules/siprec/siprec_body.c:226-462), which copy SDP data from parsed SIP messages via `parse_sdp` (parser/sdp/sdp.c:633-677). The trigger chain is: SIP message → `parse_sip_body` (parser/parse_body.c:230-328) → `parse_sdp` → `srs_*` functions → `do_for_all_streams` (modules/sipmsgops/codecs.c:307) → `stream_process` → `delete_sdp_line`.",0.95,./github/other_context/CVE-2023-27601
59,CVE-2023-28425,CWE-77,c_cpp,"Redis is an in-memory database that persists on disk. Starting in version 7.0.8 and prior to version 7.0.10, authenticated users can use the MSETNX command to trigger a runtime assertion and termination of the Redis server process. The problem is fixed in Redis version 7.0.10.",https://github.com/redis/redis/commit/48e0d4788434833b47892fe9f3d91be7687f25c9,Avoid assertion when MSETNX is used with the same key twice (CVE-2023-28425) (#11940)\n\nUsing the same key twice in MSETNX command would trigger an assertion.\r\n\r\nThis reverts #11594 (introduced in Redis 7.0.8),1,"[{""func_name"": ""msetGenericCommand"", ""file_path"": ""src/t_string.c"", ""func_code"": ""void msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Handle the NX flag. The MSETNX semantic is to return zero and don't\n     * set anything if at least one key already exists. */\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\""set\"",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}"", ""target"": 0}]","[{""func_name"": ""msetGenericCommand"", ""file_path"": ""src/t_string.c"", ""func_code"": ""void msetGenericCommand(client *c, int nx) {\n    int j;\n\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Handle the NX flag. The MSETNX semantic is to return zero and don't\n     * set anything if at least one key already exists. */\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n    }\n\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], 0);\n        notifyKeyspaceEvent(NOTIFY_STRING,\""set\"",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}""}]","{""function"": 2, ""code"": 1}","[{""source"": ""func_info(func:setKey)"", ""result"": [{""code"": ""void setKey(client *c, redisDb *db, robj *key, robj *val, int flags) {\n    int keyfound = 0;\n\n    if (flags & SETKEY_ALREADY_EXIST)\n        keyfound = 1;\n    else if (!(flags & SETKEY_DOESNT_EXIST))\n        keyfound = (lookupKeyWrite(db,key) != NULL);\n\n    if (!keyfound) {\n        dbAdd(db,key,val);\n    } else {\n        dbSetValue(db,key,val,1);\n    }\n    incrRefCount(val);\n    if (!(flags & SETKEY_KEEPTTL)) removeExpire(db,key);\n    if (!(flags & SETKEY_NO_SIGNAL)) signalModifiedKey(c,db,key);\n}"", ""start_line"": 281, ""end_line"": 297, ""full_name"": ""setKey"", ""file_path"": ""src/db.c""}]}, {""source"": ""func_info(file:db.c, func:dbAdd)"", ""result"": [{""code"": ""void dbAdd(redisDb *db, robj *key, robj *val) {\n    sds copy = sdsdup(key->ptr);\n    dictEntry *de = dictAddRaw(db->dict, copy, NULL);\n    serverAssertWithInfo(NULL, key, de != NULL);\n    dictSetVal(db->dict, de, val);\n    signalKeyAsReady(db, key, val->type);\n    if (server.cluster_enabled) slotToKeyAddEntry(de, db);\n    notifyKeyspaceEvent(NOTIFY_NEW,\""new\"",key,db->id);\n}"", ""start_line"": 191, ""end_line"": 199, ""full_name"": ""dbAdd"", ""file_path"": ""src/db.c""}]}, {""source"": ""code_info(file:db.c, lines:100-150)"", ""result"": ""        int is_ro_replica = server.masterhost && server.repl_slave_ro;\n        int expire_flags = 0;\n        if (flags & LOOKUP_WRITE && !is_ro_replica)\n            expire_flags |= EXPIRE_FORCE_DELETE_EXPIRED;\n        if (flags & LOOKUP_NOEXPIRE)\n            expire_flags |= EXPIRE_AVOID_DELETE_EXPIRED;\n        if (expireIfNeeded(db, key, expire_flags)) {\n            /* The key is no longer valid. */\n            val = NULL;\n        }\n    }\n\n    if (val) {\n        /* Update the access time for the ageing algorithm.\n         * Don't do it if we have a saving child, as this will trigger\n         * a copy on write madness. */\n        if (server.current_client && server.current_client->flags & CLIENT_NO_TOUCH &&\n            server.current_client->cmd->proc != touchCommand)\n            flags |= LOOKUP_NOTOUCH;\n        if (!hasActiveChildProcess() && !(flags & LOOKUP_NOTOUCH)){\n            if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {\n                updateLFU(val);\n            } else {\n                val->lru = LRU_CLOCK();\n            }\n        }\n\n        if (!(flags & (LOOKUP_NOSTATS | LOOKUP_WRITE)))\n            server.stat_keyspace_hits++;\n        /* TODO: Use separate hits stats for WRITE */\n    } else {\n        if (!(flags & (LOOKUP_NONOTIFY | LOOKUP_WRITE)))\n            notifyKeyspaceEvent(NOTIFY_KEY_MISS, \""keymiss\"", key, db->id);\n        if (!(flags & (LOOKUP_NOSTATS | LOOKUP_WRITE)))\n            server.stat_keyspace_misses++;\n        /* TODO: Use separate misses stats and notify event for WRITE */\n    }\n\n    return val;\n}\n\n/* Lookup a key for read operations, or return NULL if the key is not found\n * in the specified DB.\n *\n * This API should not be used when we write to the key after obtaining\n * the object linked to the key, but only for read only operations.\n *\n * This function is equivalent to lookupKey(). The point of using this function\n * rather than lookupKey() directly is to indicate that the purpose is to read\n * the key. */\nrobj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {\n    serverAssert(!(flags & LOOKUP_WRITE));\n""}]","src/t_string.c:575-576: SETKEY_DOESNT_EXIST flag passed to setKey() → src/db.c:281-297: setKey() skipped existence check → src/db.c:191-199: dbAdd() called for existing key → serverAssertWithInfo(NULL, key, de != NULL) failed (de == NULL) due to duplicate key in MSETNX",0.95,./github/other_context/CVE-2023-28425
60,CVE-2023-31126,CWE-79,java,"`org.xwiki.commons:xwiki-commons-xml` is an XML library used by the open-source wiki platform XWiki. The HTML sanitizer, introduced in version 14.6-rc-1, allows the injection of arbitrary HTML code and thus cross-site scripting via invalid data attributes. This vulnerability does not affect restricted cleaning in HTMLCleaner as there attributes are cleaned and thus characters like `/` and `>` are removed in all attribute names. This problem has been patched in XWiki 14.10.4 and 15.0 RC1 by making sure that data attributes only contain allowed characters. There are no known workarounds apart from upgrading to a version including the fix.",https://github.com/xwiki/xwiki-commons/commit/0b8e9c45b7e7457043938f35265b2aa5adc76a68,XCOMMONS-2606: Properly validate data attributes in SecureHTMLElementSanitizer\n\n* Make sure that the attribute is XML-compatible\n* Add tests,1,"[{""func_name"": ""isAttributeAllowed"", ""file_path"": ""xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/SecureHTMLElementSanitizer.java"", ""func_code"": ""@Override\n    public boolean isAttributeAllowed(String elementName, String attributeName, String attributeValue)\n    {\n        boolean result = false;\n\n        String lowerElement = elementName.toLowerCase();\n        String lowerAttribute = attributeName.toLowerCase();\n\n        if ((DATA_ATTR.matcher(lowerAttribute).find() || ARIA_ATTR.matcher(lowerAttribute).find())\n            && !this.forbidAttributes.contains(lowerAttribute))\n        {\n            result = true;\n        } else if (isAttributeAllowed(lowerAttribute) && !this.forbidAttributes.contains(lowerAttribute)) {\n            result = isAllowedValue(lowerElement, lowerAttribute, attributeValue);\n        }\n\n        return result;\n    }"", ""target"": 0}]","[{""func_name"": ""isAttributeAllowed"", ""file_path"": ""xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/SecureHTMLElementSanitizer.java"", ""func_code"": ""@Override\n    public boolean isAttributeAllowed(String elementName, String attributeName, String attributeValue)\n    {\n        boolean result = false;\n\n        String lowerElement = elementName.toLowerCase();\n        String lowerAttribute = attributeName.toLowerCase();\n\n        if ((DATA_ATTR.matcher(lowerAttribute).matches() || ARIA_ATTR.matcher(lowerAttribute).matches())\n            && !this.forbidAttributes.contains(lowerAttribute))\n        {\n            result = true;\n        } else if (isAttributeAllowed(lowerAttribute) && !this.forbidAttributes.contains(lowerAttribute)) {\n            result = isAllowedValue(lowerElement, lowerAttribute, attributeValue);\n        }\n\n        return result;\n    }""}]","{""code"": 1, ""caller"": 1}","[{""source"": ""code_info(file:SecureHTMLElementSanitizer.java, lines:1-200)"", ""result"": ""/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\n/*\n * Alternatively, at your choice, the contents of this file may be used under the terms of the Mozilla Public License,\n * v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\npackage org.xwiki.xml.internal.html;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.phase.Initializable;\nimport org.xwiki.component.phase.InitializationException;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.xml.html.HTMLElementSanitizer;\n\n/**\n * Secure default implementation of {@link HTMLElementSanitizer} based on a definition of allowed elements and\n * attributes.\n * <p>\n * This is heavily inspired by DOMPurify by Cure53 and other contributors | Released under the Apache license 2.0 and\n * Mozilla Public License 2.0 - <a href=\""https://github.com/cure53/DOMPurify/blob/main/LICENSE\"">LICENSE</a>.\n *\n * @version $Id: 155c6d783bbdf08fcc91ea51007197715dfff39a $\n * @since 14.6RC1\n */\n@Component\n@Named(SecureHTMLElementSanitizer.HINT)\n@Singleton\n@Unstable\npublic class SecureHTMLElementSanitizer implements HTMLElementSanitizer, Initializable\n{\n    /**\n     * The hint of this component.\n     */\n    public static final String HINT = \""secure\"";\n\n    static final Pattern IS_SCRIPT_OR_DATA = Pattern.compile(\""^(?:\\\\w+script|data):\"", Pattern.CASE_INSENSITIVE);\n\n    static final Pattern ATTR_WHITESPACE =\n        Pattern.compile(\""[\\\\u0000-\\\\u0020\\\\u00A0\\\\u1680\\\\u180E\\\\u2000-\\\\u2029\\\\u205F\\\\u3000]\"");\n\n    static final Pattern DATA_ATTR = Pattern.compile(\""^data-[\\\\-\\\\w.\\\\u00B7-\\\\uFFFF]\"");\n\n    static final Pattern ARIA_ATTR = Pattern.compile(\""^aria-[\\\\-\\\\w]+$\"");\n\n    static final Pattern IS_ALLOWED_URI = Pattern.compile(\""^(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):\"",\n        Pattern.CASE_INSENSITIVE);\n\n    static final Pattern IS_NO_URI = Pattern.compile(\""^(?:[^a-z]|[a-z+.\\\\-]+(?:[^a-z+.\\\\-:]|$))\"",\n        Pattern.CASE_INSENSITIVE);\n\n    @Inject\n    private HTMLElementSanitizerConfiguration htmlElementSanitizerConfiguration;\n\n    @Inject\n    private HTMLDefinitions htmlDefinitions;\n\n    @Inject\n    private SVGDefinitions svgDefinitions;\n\n    @Inject\n    private MathMLDefinitions mathMLDefinitions;\n\n    /**\n     * Additionally allowed elements.\n     */\n    private final Set<String> extraAllowedTags;\n\n    /**\n     * Additionally allowed attributes.\n     */\n    private final Set<String> extraAllowedAttributes;\n\n    /**\n     * XML attributes that should be allowed.\n     */\n    private final Set<String> xmlAttributes;\n\n    /**\n     * Tags that are safe for data: URIs.\n     */\n    private final Set<String> dataUriTags;\n\n    /**\n     * Attributes safe for values like \""javascript:\"".\n     */\n    private final Set<String> uriSafeAttributes;\n\n    private final Set<String> forbidTags;\n\n    private final Set<String> forbidAttributes;\n\n    private boolean allowUnknownProtocols;\n\n    private Pattern allowedUriPattern;\n\n    /**\n     * Default constructor.\n     */\n    public SecureHTMLElementSanitizer()\n    {\n        this.dataUriTags = new HashSet<>(Arrays.asList(\""audio\"", \""video\"", \""img\"", \""source\"", \""image\"", \""track\""));\n\n        this.uriSafeAttributes = new HashSet<>(\n            Arrays.asList(\""alt\"", \""class\"", \""for\"", \""id\"", \""label\"", \""name\"", \""pattern\"", \""placeholder\"", \""role\"", \""summary\"",\n                \""title\"", \""value\"", \""style\"", \""xmlns\""));\n\n        this.xmlAttributes =\n            new HashSet<>(Arrays.asList(\""xlink:href\"", \""xml:id\"", \""xlink:title\"", \""xml:space\"", \""xmlns:xlink\""));\n\n        this.extraAllowedTags = new HashSet<>();\n\n        this.extraAllowedAttributes = new HashSet<>();\n\n        this.forbidTags = new HashSet<>();\n\n        this.forbidAttributes = new HashSet<>();\n\n        this.allowedUriPattern = IS_ALLOWED_URI;\n    }\n\n    @Override\n    public void initialize() throws InitializationException\n    {\n        this.extraAllowedTags.addAll(this.htmlElementSanitizerConfiguration.getExtraAllowedTags());\n        this.extraAllowedAttributes.addAll(this.htmlElementSanitizerConfiguration.getExtraAllowedAttributes());\n        this.uriSafeAttributes.addAll(this.htmlElementSanitizerConfiguration.getExtraUriSafeAttributes());\n        this.dataUriTags.addAll(this.htmlElementSanitizerConfiguration.getExtraDataUriTags());\n        this.allowUnknownProtocols = this.htmlElementSanitizerConfiguration.isAllowUnknownProtocols();\n        this.forbidTags.addAll(this.htmlElementSanitizerConfiguration.getForbidTags());\n        this.forbidAttributes.addAll(this.htmlElementSanitizerConfiguration.getForbidAttributes());\n        String configuredRegexp = this.htmlElementSanitizerConfiguration.getAllowedUriRegexp();\n        if (StringUtils.isNotBlank(configuredRegexp)) {\n            this.allowedUriPattern = Pattern.compile(configuredRegexp, Pattern.CASE_INSENSITIVE);\n        }\n    }\n\n    @Override\n    public boolean isElementAllowed(String elementName)\n    {\n        return !this.forbidTags.contains(elementName)\n            && (this.extraAllowedTags.contains(elementName) || isElementSafe(elementName));\n    }\n\n    private boolean isElementSafe(String elementName)\n    {\n        return this.htmlDefinitions.isSafeTag(elementName) || this.svgDefinitions.isSafeTag(elementName)\n            || this.mathMLDefinitions.isSafeTag(elementName);\n    }\n\n    @Override\n    public boolean isAttributeAllowed(String elementName, String attributeName, String attributeValue)\n    {\n        boolean result = false;\n\n        String lowerElement = elementName.toLowerCase();\n        String lowerAttribute = attributeName.toLowerCase();\n\n        if ((DATA_ATTR.matcher(lowerAttribute).find() || ARIA_ATTR.matcher(lowerAttribute).find())\n            && !this.forbidAttributes.contains(lowerAttribute))\n        {\n            result = true;\n        } else if (isAttributeAllowed(lowerAttribute) && !this.forbidAttributes.contains(lowerAttribute)) {\n            result = isAllowedValue(lowerElement, lowerAttribute, attributeValue);\n        }\n\n        return result;\n    }\n\n    private boolean isAllowedValue(String lowercaseElementName, String lowercaseAttributeName, String attributeValue)\n    {\n        // Break into several statements to avoid too long boolean expression.\n        boolean result = StringUtils.isBlank(attributeValue);\n        if (!result) {\n            String valueNoWhitespace = ATTR_WHITESPACE.matcher(attributeValue).replaceAll(\""\"");\n""}, {""source"": ""caller_info(file:SecureHTMLElementSanitizer.java, func:isAttributeAllowed)"", ""result"": [{""call_line"": 189, ""call_code"": ""this.isAttributeAllowed(lowerAttribute)"", ""caller_code"": ""    @Override\n    public boolean isAttributeAllowed(String elementName, String attributeName, String attributeValue)\n    {\n        boolean result = false;\n\n        String lowerElement = elementName.toLowerCase();\n        String lowerAttribute = attributeName.toLowerCase();\n\n        if ((DATA_ATTR.matcher(lowerAttribute).find() || ARIA_ATTR.matcher(lowerAttribute).find())\n            && !this.forbidAttributes.contains(lowerAttribute))\n        {\n            result = true;\n        } else if (isAttributeAllowed(lowerAttribute) && !this.forbidAttributes.contains(lowerAttribute)) {\n            result = isAllowedValue(lowerElement, lowerAttribute, attributeValue);\n        }\n\n        return result;\n    }\n"", ""caller_start"": 177, ""file_path"": ""xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/SecureHTMLElementSanitizer.java""}, {""call_line"": 133, ""call_code"": ""this.getImplementation().isAttributeAllowed(elementName, attributeName, value)"", ""caller_code"": ""    @Override\n    public boolean isAttributeAllowed(String elementName, String attributeName, String value)\n    {\n        return getImplementation().isAttributeAllowed(elementName, attributeName, value);\n    }\n"", ""caller_start"": 130, ""file_path"": ""xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/DefaultHTMLElementSanitizer.java""}, {""call_line"": 117, ""call_code"": ""this.htmlElementSanitizer.isAttributeAllowed(element.getTagName(), attr.getName(), attr.getValue())"", ""caller_code"": ""    private void cleanDocument(Element rootElement)\n    {\n        List<Element> elementsToRemove = new ArrayList<>();\n        traverseWithNamespace(rootElement, (element, currentNamespace) -> {\n            if (currentNamespace == TagInformation.INVALID\n                || !this.htmlElementSanitizer.isElementAllowed(element.getTagName()))\n            {\n                elementsToRemove.add(element);\n                return true;\n            } else {\n                getAttributes(element).stream()\n                    .filter(\n                        attr -> !this.htmlElementSanitizer.isAttributeAllowed(element.getTagName(), attr.getName(),\n                            attr.getValue())\n                    )\n                    .forEach(element::removeAttributeNode);\n                return false;\n            }\n        });\n\n        elementsToRemove.forEach(element -> element.getParentNode().removeChild(element));\n    }\n"", ""caller_start"": 105, ""file_path"": ""xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/filter/SanitizerFilter.java""}]}]","xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/SecureHTMLElementSanitizer.java:60-62: The `DATA_ATTR` regex (`^data-[\\\\-\\\\w.\\\\u00B7-\\\\uFFFF]`) was validated using `find()` instead of `matches()`, allowing partial matches. This permitted invalid characters in data attributes (e.g., `/`, `>`) to pass validation, enabling XSS. The patch enforces full string validation with `matches()`.",0.95,./github/other_context/CVE-2023-31126
61,CVE-2023-51252,CWE-79,java,"PublicCMS 4.0 is vulnerable to Cross Site Scripting (XSS). Because files can be uploaded and online preview function is provided, pdf files and html files containing malicious code are uploaded, an XSS popup window is realized through online viewing.",https://github.com/sanluan/PublicCMS/commit/2459a3f92c680ae011a369f32306c17df07caaa0,https://github.com/sanluan/PublicCMS/issues/79,2,"[{""func_name"": ""save"", ""file_path"": ""publiccms-parent/publiccms-core/src/main/java/com/publiccms/controller/admin/cms/CmsWebFileAdminController.java"", ""func_code"": ""@RequestMapping(\""save\"")\n    @Csrf\n    public String save(@RequestAttribute SysSite site, @SessionAttribute SysUser admin, String path, String content,\n            HttpServletRequest request, ModelMap model) {\n        if (CommonUtils.notEmpty(path)) {\n            try {\n                String filepath = siteComponent.getWebFilePath(site.getId(), path);\n                content = new String(VerificationUtils.base64Decode(content), Constants.DEFAULT_CHARSET);\n                if (CmsFileUtils.createFile(filepath, content)) {\n                    logOperateService.save(\n                            new LogOperate(site.getId(), admin.getId(), admin.getDeptId(), LogLoginService.CHANNEL_WEB_MANAGER,\n                                    \""save.web.webfile\"", RequestUtils.getIpAddress(request), CommonUtils.getDate(), path));\n                } else {\n                    String historyFilePath = siteComponent.getWebHistoryFilePath(site.getId(), path, true);\n                    CmsFileUtils.updateFile(filepath, historyFilePath, content);\n                    logOperateService.save(\n                            new LogOperate(site.getId(), admin.getId(), admin.getDeptId(), LogLoginService.CHANNEL_WEB_MANAGER,\n                                    \""update.web.webfile\"", RequestUtils.getIpAddress(request), CommonUtils.getDate(), path));\n                }\n            } catch (IOException e) {\n                model.addAttribute(CommonConstants.ERROR, e.getMessage());\n                log.error(e.getMessage(), e);\n                return CommonConstants.TEMPLATE_ERROR;\n            }\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }"", ""target"": 0}, {""func_name"": ""upload"", ""file_path"": ""publiccms-parent/publiccms-core/src/main/java/com/publiccms/controller/admin/cms/CmsWebFileAdminController.java"", ""func_code"": ""@RequestMapping(\""doUpload\"")\n    @Csrf\n    public String upload(@RequestAttribute SysSite site, @SessionAttribute SysUser admin, MultipartFile[] files, String path,\n            boolean privatefile, boolean overwrite, HttpServletRequest request, ModelMap model) {\n        if (null != files) {\n            try {\n                for (MultipartFile file : files) {\n                    String originalName = file.getOriginalFilename();\n                    String suffix = CmsFileUtils.getSuffix(originalName);\n                    String filepath = CommonUtils.joinString(path, Constants.SEPARATOR, originalName);\n                    String fuleFilePath = siteComponent.getWebFilePath(site.getId(), filepath);\n                    if (overwrite || !CmsFileUtils.exists(fuleFilePath)) {\n                        if (CmsFileUtils.exists(fuleFilePath)) {\n                            String historyFilePath = siteComponent.getWebHistoryFilePath(site.getId(), filepath, true);\n                            try {\n                                CmsFileUtils.copyFileToFile(historyFilePath, historyFilePath);\n                            } catch (IOException e1) {\n                            }\n                        }\n                        CmsFileUtils.upload(file, fuleFilePath);\n                        if (CmsFileUtils.isSafe(fuleFilePath, suffix)) {\n                            FileUploadResult uploadResult = CmsFileUtils.getFileSize(fuleFilePath, originalName, suffix);\n                            logUploadService.save(new LogUpload(site.getId(), admin.getId(), LogLoginService.CHANNEL_WEB_MANAGER,\n                                    originalName, privatefile, CmsFileUtils.getFileType(CmsFileUtils.getSuffix(originalName)),\n                                    file.getSize(), uploadResult.getWidth(), uploadResult.getHeight(),\n                                    RequestUtils.getIpAddress(request), CommonUtils.getDate(), filepath));\n                        } else {\n                            CmsFileUtils.delete(fuleFilePath);\n                            model.addAttribute(CommonConstants.ERROR, LanguagesUtils.getMessage(\n                                    CommonConstants.applicationContext, request.getLocale(), \""verify.custom.file.unsafe\""));\n                            return CommonConstants.TEMPLATE_ERROR;\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                model.addAttribute(CommonConstants.ERROR, e.getMessage());\n                log.error(e.getMessage(), e);\n                return CommonConstants.TEMPLATE_ERROR;\n            }\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }"", ""target"": 0}]","[{""func_name"": ""save"", ""file_path"": ""publiccms-parent/publiccms-core/src/main/java/com/publiccms/controller/admin/cms/CmsWebFileAdminController.java"", ""func_code"": ""@RequestMapping(\""save\"")\n    @Csrf\n    public String save(@RequestAttribute SysSite site, @SessionAttribute SysUser admin, String path, String content,\n            HttpServletRequest request, ModelMap model) {\n        if (CommonUtils.notEmpty(path)) {\n            try {\n                String suffix = CmsFileUtils.getSuffix(path);\n                if (ArrayUtils.contains(safeConfigComponent.getSafeSuffix(site), suffix)) {\n                    String filepath = siteComponent.getWebFilePath(site.getId(), path);\n                    content = new String(VerificationUtils.base64Decode(content), Constants.DEFAULT_CHARSET);\n                    if (CmsFileUtils.createFile(filepath, content)) {\n                        logOperateService.save(new LogOperate(site.getId(), admin.getId(), admin.getDeptId(),\n                                LogLoginService.CHANNEL_WEB_MANAGER, \""save.web.webfile\"", RequestUtils.getIpAddress(request),\n                                CommonUtils.getDate(), path));\n                    } else {\n                        String historyFilePath = siteComponent.getWebHistoryFilePath(site.getId(), path, true);\n                        CmsFileUtils.updateFile(filepath, historyFilePath, content);\n                        logOperateService.save(new LogOperate(site.getId(), admin.getId(), admin.getDeptId(),\n                                LogLoginService.CHANNEL_WEB_MANAGER, \""update.web.webfile\"", RequestUtils.getIpAddress(request),\n                                CommonUtils.getDate(), path));\n                    }\n                } else {\n                    model.addAttribute(CommonConstants.ERROR, LanguagesUtils.getMessage(CommonConstants.applicationContext,\n                            request.getLocale(), \""verify.custom.fileType\""));\n                    return CommonConstants.TEMPLATE_ERROR;\n                }\n            } catch (IOException e) {\n                model.addAttribute(CommonConstants.ERROR, e.getMessage());\n                log.error(e.getMessage(), e);\n                return CommonConstants.TEMPLATE_ERROR;\n            }\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }""}, {""func_name"": ""upload"", ""file_path"": ""publiccms-parent/publiccms-core/src/main/java/com/publiccms/controller/admin/cms/CmsWebFileAdminController.java"", ""func_code"": ""@RequestMapping(\""doUpload\"")\n    @Csrf\n    public String upload(@RequestAttribute SysSite site, @SessionAttribute SysUser admin, MultipartFile[] files, String path,\n            boolean privatefile, boolean overwrite, HttpServletRequest request, ModelMap model) {\n        if (null != files) {\n            try {\n                for (MultipartFile file : files) {\n                    String originalName = file.getOriginalFilename();\n                    String suffix = CmsFileUtils.getSuffix(originalName);\n                    String filepath = CommonUtils.joinString(path, Constants.SEPARATOR, originalName);\n                    String fuleFilePath = siteComponent.getWebFilePath(site.getId(), filepath);\n                    if (ArrayUtils.contains(safeConfigComponent.getSafeSuffix(site), suffix)) {\n                        if (overwrite || !CmsFileUtils.exists(fuleFilePath)) {\n                            if (CmsFileUtils.exists(fuleFilePath)) {\n                                String historyFilePath = siteComponent.getWebHistoryFilePath(site.getId(), filepath, true);\n                                try {\n                                    CmsFileUtils.copyFileToFile(historyFilePath, historyFilePath);\n                                } catch (IOException e1) {\n                                }\n                            }\n                            CmsFileUtils.upload(file, fuleFilePath);\n                            if (CmsFileUtils.isSafe(fuleFilePath, suffix)) {\n                                FileUploadResult uploadResult = CmsFileUtils.getFileSize(fuleFilePath, originalName, suffix);\n                                logUploadService.save(new LogUpload(site.getId(), admin.getId(),\n                                        LogLoginService.CHANNEL_WEB_MANAGER, originalName, privatefile,\n                                        CmsFileUtils.getFileType(CmsFileUtils.getSuffix(originalName)), file.getSize(),\n                                        uploadResult.getWidth(), uploadResult.getHeight(), RequestUtils.getIpAddress(request),\n                                        CommonUtils.getDate(), filepath));\n                            } else {\n                                CmsFileUtils.delete(fuleFilePath);\n                                model.addAttribute(CommonConstants.ERROR, LanguagesUtils.getMessage(\n                                        CommonConstants.applicationContext, request.getLocale(), \""verify.custom.file.unsafe\""));\n                                return CommonConstants.TEMPLATE_ERROR;\n                            }\n                        }\n                    } else {\n                        model.addAttribute(CommonConstants.ERROR, LanguagesUtils.getMessage(CommonConstants.applicationContext,\n                                request.getLocale(), \""verify.custom.fileType\""));\n                        return CommonConstants.TEMPLATE_ERROR;\n                    }\n                }\n            } catch (IOException e) {\n                model.addAttribute(CommonConstants.ERROR, e.getMessage());\n                log.error(e.getMessage(), e);\n                return CommonConstants.TEMPLATE_ERROR;\n            }\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }""}]","{""function"": 2, ""code"": 1}","[{""source"": ""func_info(func:getSafeSuffix)"", ""result"": [{""code"": ""    public String[] getSafeSuffix(SysSite site) {\n        Map<String, String> config = configDataComponent.getConfigData(site.getId(), CONFIG_CODE);\n        String value = config.get(CONFIG_ALLOW_FILES);\n        if (CommonUtils.empty(value)) {\n            return CmsFileUtils.ALLOW_FILES;\n        }\n        return StringUtils.split(value, Constants.COMMA);\n    }\n"", ""start_line"": 183, ""end_line"": 190, ""full_name"": ""com.publiccms.logic.component.config.SafeConfigComponent.getSafeSuffix:java.lang.String[](com.publiccms.entities.sys.SysSite)"", ""file_path"": ""publiccms-parent/publiccms-core/src/main/java/com/publiccms/logic/component/config/SafeConfigComponent.java""}]}, {""source"": ""func_info(func:isSafe)"", ""result"": [{""code"": ""    public static boolean isSafe(String filepath, String suffix) {\n        File file = new File(filepath);\n        if (CommonUtils.notEmpty(suffix) && file.isFile()) {\n            if (suffix.endsWith(ImageUtils.FORMAT_NAME_SVG)) {\n                try {\n                    return ImageUtils.svgSafe(file);\n                } catch (IOException e) {\n                    return false;\n                }\n            } else if (suffix.endsWith(FILE_TYPE_PDF)) {\n                try (PDDocument document = PDDocument.load(file)) {\n                    return document.getDocument().getObjects().stream()\n                            .noneMatch(obj -> COSName.JS.equals(obj) || COSName.JAVA_SCRIPT.equals(obj));\n                } catch (IOException e) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n"", ""start_line"": 513, ""end_line"": 532, ""full_name"": ""com.publiccms.common.tools.CmsFileUtils.isSafe:boolean(java.lang.String,java.lang.String)"", ""file_path"": ""publiccms-parent/publiccms-core/src/main/java/com/publiccms/common/tools/CmsFileUtils.java""}]}, {""source"": ""code_info(file:CmsWebFileAdminController.java, lines:145-155)"", ""result"": ""            }\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }\n\n    /**\n     * @param site\n     * @param admin\n     * @param file\n     * @param filename\n     * @param base64File\n     * @param originalFilename\n""}]","1. `CmsWebFileAdminController.upload()` (lines 30-37) checks file suffixes against `safeConfigComponent.getSafeSuffix(site)` (defined in `SafeConfigComponent.getSafeSuffix()` at lines 183-190). If the suffix is allowed, the file is uploaded.\n2. `CmsFileUtils.isSafe()` (lines 513-532) checks PDF/SVG safety but returns `true` for HTML files (no explicit validation).\n3. If `CmsFileUtils.ALLOW_FILES` (default fallback) includes HTML/PDF suffixes, attackers can upload malicious HTML/PDF files containing XSS payloads.\n4. During online preview, the HTML/PDF is rendered, executing the XSS payload (e.g., `<script>alert('XSS')</script>` in an HTML file).",0.95,./github/other_context/CVE-2023-51252
62,CVE-2013-7226,"CWE-189, CWE-20",c_cpp,"Integer overflow in the gdImageCrop function in ext/gd/gd.c in PHP 5.5.x before 5.5.9 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an imagecrop function call with a large x dimension value, leading to a heap-based buffer overflow.",https://github.com/php/php-src/commit/8f4a5373bb71590352fd934028d6dde5bc18530b,Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop())\n\nInitial fix was PHP stuff\nThis one is libgd fix.\n\n- filter invalid crop size\n- dont try to copy on invalid position\n- fix crop size when out of src image\n- fix possible NULL deref\n- fix possible integer overfloow,2,"[{""func_name"": ""gdImageCrop"", ""file_path"": ""ext/gd/libgd/gd_crop.c"", ""func_code"": ""gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t\tgdImagePaletteCopy(dst, src);\n\t}\n\tdst->transparent = src->transparent;\n\n\tif (src->sx < (crop->x + crop->width -1)) {\n\t\tcrop->width = src->sx - crop->x + 1;\n\t}\n\tif (src->sy < (crop->y + crop->height -1)) {\n\t\tcrop->height = src->sy - crop->y + 1;\n\t}\n#if 0\nprintf(\""rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\"", crop->x, crop->y, crop->width, crop->height);\n#endif\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tint y = crop->y;\n\t\tif (src->trueColor) {\n\t\t\tunsigned int dst_y = 0;\n\t\t\twhile (y < (crop->y + (crop->height - 1))) {\n\t\t\t\t/* TODO: replace 4 w/byte per channel||pitch once available */\n\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tint x;\n\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dst;\n\t}\n}"", ""target"": 0}, {""func_name"": ""php_imagepolygon"", ""file_path"": ""ext/gd/gd.c"", ""func_code"": ""static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""rall\"", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \""Image\"", le_gd);\n\n\tnpoints = NPOINTS;\n\tcol = COL;\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""You must have at least 3 points in your array\"");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""You must give a positive number of points\"");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Trying to use %d points in array with only %d points\"", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL((var));\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL(var);\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t}\n\t}\n\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\n\tefree(points);\n\tRETURN_TRUE;\n}"", ""target"": 0}]","[{""func_name"": ""gdImageCrop"", ""file_path"": ""ext/gd/libgd/gd_crop.c"", ""func_code"": ""gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\n\t/* check size */\n\tif (crop->width<=0 || crop->height<=0) {\n\t\treturn NULL;\n\t}\n\n\t/* allocate the requested size (could be only partially filled) */\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t\tgdImagePaletteCopy(dst, src);\n\t}\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->transparent = src->transparent;\n\n\t/* check position in the src image */\n\tif (crop->x < 0 || crop->x>=src->sx || crop->y<0 || crop->y>=src->sy) {\n\t\treturn dst;\n\t}\n\n\t/* reduce size if needed */\n\tif ((src->sx - crop->width) < crop->x) {\n\t\tcrop->width = src->sx - crop->x;\n\t}\n\tif ((src->sy - crop->height) < crop->y) {\n\t\tcrop->height = src->sy - crop->y;\n\t}\n\n#if 0\nprintf(\""rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\"", crop->x, crop->y, crop->width, crop->height);\n#endif\n\tint y = crop->y;\n\tif (src->trueColor) {\n\t\tunsigned int dst_y = 0;\n\t\twhile (y < (crop->y + (crop->height - 1))) {\n\t\t\t/* TODO: replace 4 w/byte per channel||pitch once available */\n\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n\t\t}\n\t} else {\n\t\tint x;\n\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n\t\t\t}\n\t\t}\n\t}\n\treturn dst;\n}""}, {""func_name"": ""php_imagepolygon"", ""file_path"": ""ext/gd/gd.c"", ""func_code"": ""static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""rall\"", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \""Image\"", le_gd);\n\n\tnpoints = NPOINTS;\n\tcol = COL;\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""You must have at least 3 points in your array\"");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""You must give a positive number of points\"");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Trying to use %d points in array with only %d points\"", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **var;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\tpoints[i].x = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t\t}\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **var;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\tpoints[i].y = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\n\tefree(points);\n\tRETURN_TRUE;\n}""}]","{""code"": 1, ""function"": 1, ""caller"": 1}","[{""source"": ""code_info(file:gd_crop.c, lines:1-44)"", ""result"": ""/**\n * Title: Crop\n *\n * A couple of functions to crop images, automatically (auto detection of\n * the borders color), using a given color (with or without tolerance)\n * or using a selection.\n *\n * The threshold method works relatively well but it can be improved.\n * Maybe L*a*b* and Delta-E will give better results (and a better\n * granularity).\n *\n * Example:\n * (start code)\n *   im2 = gdImageAutoCrop(im, GD_CROP_SIDES);\n *   if (im2) {\n\n *   }\n *   gdImageDestroy(im2);\n *  (end code)\n **/\n\n#include <gd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\nstatic int gdGuessBackgroundColorFromCorners(gdImagePtr im, int *color);\nstatic int gdColorMatch(gdImagePtr im, int col1, int col2, float threshold);\n\n/**\n * Function: gdImageCrop\n *  Crops the src image using the area defined by the <crop> rectangle.\n *  The result is returned as a new image.\n *\n *\n * Parameters:\n * \tsrc - Source image\n *  crop - Rectangular region to crop\n *\n * Returns:\n *  <gdImagePtr> on success or NULL\n */\ngdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n""}, {""source"": ""func_info(file:gd_crop.c, func:gdImageCrop)"", ""result"": [{""code"": ""gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {"", ""start_line"": 43, ""end_line"": 85, ""full_name"": ""gdImageCrop"", ""file_path"": ""ext/gd/libgd/gd_crop.c""}]}, {""source"": ""caller_info(file:gd_crop.c, func:gdImageCrop)"", ""result"": [{""call_line"": 194, ""call_code"": ""gdImageCrop(im, &crop)"", ""caller_code"": ""gdImagePtr gdImageCropAuto(gdImagePtr im, const unsigned int mode)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint color, corners, match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\tswitch (mode) {\n\t\tcase GD_CROP_TRANSPARENT:\n\t\t\tcolor = gdImageGetTransparent(im);\n\t\t\tbreak;\n\n\t\tcase GD_CROP_BLACK:\n\t\t\tcolor = gdImageColorClosestAlpha(im, 0, 0, 0, 0);\n\t\t\tbreak;\n\n\t\tcase GD_CROP_WHITE:\n\t\t\tcolor = gdImageColorClosestAlpha(im, 255, 255, 255, 0);\n\t\t\tbreak;\n\n\t\tcase GD_CROP_SIDES:\n\t\t\tcorners = gdGuessBackgroundColorFromCorners(im, &color);\n\t\t\tbreak;\n\n\t\tcase GD_CROP_DEFAULT:\n\t\tdefault:\n\t\t\tcolor = gdImageGetTransparent(im);\n\t\t\tif (color == -1) {\n\t\t\t\tcorners = gdGuessBackgroundColorFromCorners(im, &color);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y..."", ""caller_start"": 103, ""file_path"": ""ext/gd/libgd/gd_crop.c""}, {""call_line"": 284, ""call_code"": ""gdImageCrop(im, &crop)"", ""caller_code"": ""gdImagePtr gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 1.0) {\n\t\treturn NULL;\n\t}\n\n\t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n\t * for the true color and palette images\n\t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t..."", ""caller_start"": 216, ""file_path"": ""ext/gd/libgd/gd_crop.c""}, {""call_line"": 5040, ""call_code"": ""gdImageCrop(im, &rect)"", ""caller_code"": ""PHP_FUNCTION(imagecrop)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tgdImagePtr im_crop;\n\tgdRect rect;\n\tzval *z_rect;\n\tzval **tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ra\"", &IM, &z_rect) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \""Image\"", le_gd);\n\n\tif (zend_hash_find(HASH_OF(z_rect), \""x\"", sizeof(\""x\""), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.x = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.x = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing x position\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_hash_find(HASH_OF(z_rect), \""y\"", sizeof(\""x\""), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.y = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.y = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Missing y pos..."", ""caller_start"": 4965, ""file_path"": ""ext/gd/gd.c""}]}]","The vulnerability originates in PHP_FUNCTION(imagecrop) (ext/gd/gd.c:4965-5040), where user-provided `z_rect` values for `x`, `y`, `width`, and `height` are converted to long integers and directly assigned to the `rect` struct without range checks. These unvalidated values are then passed to `gdImageCrop` (ext/gd/libgd/gd_crop.c:45-72), which uses them to allocate memory via `gdImageCreateTrueColor`. Large values trigger integer overflow in `crop->width * 4` during `memcpy`, leading to heap-based buffer overflow.",0.95,./github/other_context/CVE-2013-7226
63,CVE-2014-125074,CWE-89,java,A vulnerability was found in Nayshlok Voyager. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the file Voyager/src/models/DatabaseAccess.java. The manipulation leads to sql injection. The identifier of the patch is f1249f438cd8c39e7ef2f6c8f2ab76b239a02fae. It is recommended to apply a patch to fix this issue. The identifier VDB-218005 was assigned to this vulnerability.,https://github.com/Nayshlok/Voyager/commit/f1249f438cd8c39e7ef2f6c8f2ab76b239a02fae,"fixed problems in register controller, and worked at preventing sql-injection in database access",9,"[{""func_name"": ""registerUser"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic void registerUser(Account user){\n\t\tDriver driver = new SQLServerDriver();\n\t\tString connectionUrl = \""jdbc:sqlserver://n8bu1j6855.database.windows.net:1433;database=VoyagerDB;user=VoyageLogin@n8bu1j6855;password={GroupP@ssword};encrypt=true;hostNameInCertificate=*.database.windows.net;loginTimeout=30;\"";\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Insert INTO UserTable (userName, userPassword, userEmail, userRole) \""\n\t\t\t\t\t+ \""VALUES ('\"" + user.getUsername() + \""', '\"" + user.getPassword() + \""', '\"" + user.getEmail() + \""', '\"" + user.getRole().toString() + \""');\"");\n\t\t\tstatement.execute();\n\t\t\tSystem.out.println(\""Registration Successful\"");\n\t\t} catch (SQLException e) {\n\t\t\tif(e.getMessage().contains(\""UNIQUE KEY\"")){\n\t\t\t\tSystem.err.println(\""User has already been registered.\"");\n\t\t\t\tthrow new UsernameAlreadyExistsException();\n\t\t\t}\n\t\t\telse{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}"", ""target"": 0}, {""func_name"": ""updateUser"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic void updateUser(Account user){\n\t\tDriver driver = new SQLServerDriver();\n\t\tString connectionUrl = \""jdbc:sqlserver://n8bu1j6855.database.windows.net:1433;database=VoyagerDB;user=VoyageLogin@n8bu1j6855;password={GroupP@ssword};encrypt=true;hostNameInCertificate=*.database.windows.net;loginTimeout=30;\"";\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""UPDATE UserTable \""\n\t\t\t\t\t+ \""SET userPassword='\"" + user.getPassword() + \""', userEmail='\"" + user.getEmail() + \""', userRole='\"" + user.getRole().toString() + \""'\""\n\t\t\t\t\t+ \""WHERE userName='\"" + user.getUsername() + \""'\"");\n\t\t\tstatement.execute();\n\t\t\tSystem.out.println(\""Update successful\"");\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}"", ""target"": 0}, {""func_name"": ""login"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic Account login(String username, String password){\n\t\tAccount account = null;\n\t\tDriver driver = new SQLServerDriver();\n\t\tString connectionUrl = \""jdbc:sqlserver://n8bu1j6855.database.windows.net:1433;database=VoyagerDB;user=VoyageLogin@n8bu1j6855;password={GroupP@ssword};encrypt=true;hostNameInCertificate=*.database.windows.net;loginTimeout=30;\"";\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Select userName, userPassword, userEmail, userRole from UserTable where userName = '\"" + username + \""'\"");\n\t\t\tResultSet rs = statement.executeQuery();\n\t\t\trs.next();\n\t\t\tString storedPass = rs.getString(\""userPassword\"");\n\t\t\tif(storedPass.equals(password)){\n\t\t\t\tSystem.out.println(\""Successfully logged in\"");\n\t\t\t\taccount = new Account(rs.getString(\""userName\""), rs.getString(\""userEmail\""), \""\"", Roles.valueOf(rs.getString(\""userRole\"")), rs.getString(\""userPassword\""));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthrow new BadLoginException(\""The username/password combination is incorrect\"");\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tif(e.getMessage().contains(\""result set has no current row\"")){\n\t\t\t\tthrow new BadLoginException(\""The username/password combination is incorrect\"");\n\t\t\t}\n\t\t}\t\n\t\t\n\t\treturn account;\n\t}"", ""target"": 0}, {""func_name"": ""getUserName"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic String getUserName(int userId){\n\t\tString userName = null;\n\t\tDriver driver = new SQLServerDriver();\n\t\tString connectionUrl = \""jdbc:sqlserver://n8bu1j6855.database.windows.net:1433;database=VoyagerDB;user=VoyageLogin@n8bu1j6855;password={GroupP@ssword};encrypt=true;hostNameInCertificate=*.database.windows.net;loginTimeout=30;\"";\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Select userName from UserTable where userId = '\"" + userId + \""'\"");\n\t\t\tResultSet rs = statement.executeQuery();\n\t\t\trs.next();\n\t\t\tuserName = rs.getString(\""userName\"");\n\t\t\t\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\t\n\t\treturn userName;\n\t}"", ""target"": 0}, {""func_name"": ""enterPost"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic void enterPost(Post post){\n\t\tDriver driver = new SQLServerDriver();\n\t\tString connectionUrl = \""jdbc:sqlserver://n8bu1j6855.database.windows.net:1433;database=VoyagerDB;user=VoyageLogin@n8bu1j6855;password={GroupP@ssword};encrypt=true;hostNameInCertificate=*.database.windows.net;loginTimeout=30;\"";\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Insert INTO PostTable (postTitle, postAuthorId, postTime, postContent) \""\n\t\t\t\t\t+ \""VALUES ('\"" + post.getTitle() + \""', '\"" + this.getUserId(post.getAuthor()) + \""', CURRENT_TIMESTAMP, '\"" + post.getMessage() + \""');\"");\n\t\t\tstatement.execute();\n\t\t\tSystem.out.println(\""Successful post\"");\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}"", ""target"": 0}, {""func_name"": ""removeUser"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic void removeUser(Account user){\n\t\tDriver driver = new SQLServerDriver();\n\t\tString connectionUrl = \""jdbc:sqlserver://n8bu1j6855.database.windows.net:1433;database=VoyagerDB;user=VoyageLogin@n8bu1j6855;password={GroupP@ssword};encrypt=true;hostNameInCertificate=*.database.windows.net;loginTimeout=30;\"";\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""DELETE FROM UserTable WHERE userName='\"" + user.getUsername() + \""'\"");\n\t\t\tstatement.execute();\n\t\t\tSystem.out.println(\""Removal sucessful\"");\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}"", ""target"": 0}, {""func_name"": ""getUserId"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic int getUserId(String user){\n\t\tAccount account = null;\n\t\tint id = -1;\n\t\tDriver driver = new SQLServerDriver();\n\t\tString connectionUrl = \""jdbc:sqlserver://n8bu1j6855.database.windows.net:1433;database=VoyagerDB;user=VoyageLogin@n8bu1j6855;password={GroupP@ssword};encrypt=true;hostNameInCertificate=*.database.windows.net;loginTimeout=30;\"";\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Select userId from UserTable where userName = '\"" + user + \""'\"");\n\t\t\tResultSet rs = statement.executeQuery();\n\t\t\trs.next();\n\t\t\tString storedId = rs.getString(\""userId\"");\n\t\t\tid = Integer.parseInt(storedId);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\treturn id;\n\t}"", ""target"": 0}, {""func_name"": ""retrievePost"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic Post retrievePost(String postTitle){\n\t\tPost post = null;\n\t\tDriver driver = new SQLServerDriver();\n\t\tString connectionUrl = \""jdbc:sqlserver://n8bu1j6855.database.windows.net:1433;database=VoyagerDB;user=VoyageLogin@n8bu1j6855;password={GroupP@ssword};encrypt=true;hostNameInCertificate=*.database.windows.net;loginTimeout=30;\"";\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Select postTitle, postAuthorId, postTime, postContent from PostTable where postTitle = '\"" + postTitle + \""'\"");\n\t\t\tResultSet rs = statement.executeQuery();\n\t\t\trs.next();\n\t\t\tpost = new Post(rs.getString(\""postTitle\""), rs.getString(\""postContent\""), this.getUserName(rs.getInt(\""postAuthorId\"")));\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\t\n\t\treturn post;\n\t}"", ""target"": 0}, {""func_name"": ""commitUserRegisterUser"", ""file_path"": ""Voyager/src/Controllers/RegisterController.java"", ""func_code"": ""public ModelAndView commitUserRegisterUser() {\n\t\tString username = \""\"";\n\t\tString password = \""\"";\n\t\tString confirmPassword = \""\"";\n\t\tString email = \""\"";\n\t\tString confirmEmail = \""\"";\n\t\tString avatarPath = \""\"";\n\t\ttry{\n\t\t\tusername = this.getValue(request.getPart(\""username\""));\n\t\t\tpassword = this.getValue(request.getPart(\""password\""));\n\t\t\tconfirmPassword = this.getValue(request.getPart(\""confirmPassword\""));\n\t\t\temail = this.getValue(request.getPart(\""email\""));\n\t\t\tconfirmEmail = this.getValue(request.getPart(\""confirmEmail\""));\n\t\t\tavatarPath = FileUploadController.getFileName(request.getPart(\""image\""));\n\t\t} catch (ServletException e1) {\n\t\t\te1.printStackTrace();\n\t\t} catch (IOException e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\t\t\n\t\t\n\t\tRegisterUserModel model = new RegisterUserModel();\n\t\tModelAndView mv = null;\n\t\t\n\t\tif(!password.equals(confirmPassword)) {\n\t\t\tmodel.setErrorMessage(\""Bad username/password. \"");\n\t\t\trequest.setAttribute(\""attemptedAccount\"", new Account(username, email, avatarPath, Roles.User, password));\n\t\t\tmv = new ModelAndView(model, \""/WEB-INF/register.jsp\"");\n\t\t}\n\t\tif(!email.equals(confirmEmail)){\n\t\t\tmodel.setErrorMessage(model.getErrorMessage() + \""Emails did not match. \"");\n\t\t\trequest.setAttribute(\""attemptedAccount\"", new Account(username, email, avatarPath, Roles.User, password));\n\t\t\tmv = new ModelAndView(model, \""/WEB-INF/register.jsp\"");\n\t\t}\n\t\ttry {\n\t\t\tAccount user = new Account(username, email, avatarPath, Roles.User, password);\n\t\t\tdataService.registerUser(user);\n\t\t\tFileUploadController.processRequest(request, response, filePath);\n\t\t\tmodel.setUser(user);\n\t\t\tmv = new ModelAndView(model, \""/WEB-INF/account/profile.jsp\"");\n\t\t} catch(UsernameAlreadyExistsException e) {\n\t\t\trequest.setAttribute(\""attemptedAccount\"", new Account(username, email, avatarPath, Roles.User, password));\n\t\t\tmodel.setErrorMessage(\""Username has already been used.\"");\n\t\t\tmv = new ModelAndView(model, \""/WEB-INF/register.jsp\"");\n\t\t} catch (ServletException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treturn mv;\n\t}"", ""target"": 1}]","[{""func_name"": ""registerUser"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic void registerUser(Account user){\n\t\tDriver driver = new SQLServerDriver();\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Insert INTO UserTable (userName, userPassword, userEmail, userRole) \""\n\t\t\t\t\t+ \""VALUES (?, ?, ?, ?);\"");\n\t\t\tstatement.setString(1, user.getUsername());\n\t\t\tstatement.setString(2, user.getPassword());\n\t\t\tstatement.setString(3, user.getEmail());\n\t\t\tstatement.setString(4, user.getRole().toString());\n\t\t\tstatement.execute();\n\t\t\tSystem.out.println(\""Registration Successful\"");\n\t\t} catch (SQLException e) {\n\t\t\tif(e.getMessage().contains(\""UNIQUE KEY\"")){\n\t\t\t\tSystem.err.println(\""User has already been registered.\"");\n\t\t\t\tthrow new UsernameAlreadyExistsException();\n\t\t\t}\n\t\t\telse{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}""}, {""func_name"": ""updateUser"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic void updateUser(Account user){\n\t\tDriver driver = new SQLServerDriver();\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""UPDATE UserTable \""\n\t\t\t\t\t+ \""SET userPassword=?, userEmail=?, userRole=?\""\n\t\t\t\t\t+ \""WHERE userName=?\"");\n\t\t\tstatement.setString(1, user.getPassword());\n\t\t\tstatement.setString(2, user.getEmail());\n\t\t\tstatement.setString(3, user.getRole().toString());\n\t\t\tstatement.setString(4, user.getUsername());\n\t\t\tstatement.execute();\n\t\t\tSystem.out.println(\""Update successful\"");\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}""}, {""func_name"": ""login"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic Account login(String username, String password){\n\t\tAccount account = null;\n\t\tDriver driver = new SQLServerDriver();\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Select userName, userPassword, userEmail, userRole from UserTable where userName = ?\"");\n\t\t\tstatement.setString(1, username);\n\t\t\tResultSet rs = statement.executeQuery();\n\t\t\trs.next();\n\t\t\tString storedPass = rs.getString(\""userPassword\"");\n\t\t\tif(storedPass.equals(password)){\n\t\t\t\tSystem.out.println(\""Successfully logged in\"");\n\t\t\t\taccount = new Account(rs.getString(\""userName\""), rs.getString(\""userEmail\""), \""\"", Roles.valueOf(rs.getString(\""userRole\"")), rs.getString(\""userPassword\""));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthrow new BadLoginException(\""The username/password combination is incorrect\"");\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tif(e.getMessage().contains(\""result set has no current row\"")){\n\t\t\t\tthrow new BadLoginException(\""The username/password combination is incorrect\"");\n\t\t\t}\n\t\t}\t\n\t\t\n\t\treturn account;\n\t}""}, {""func_name"": ""getUserName"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic String getUserName(int userId){\n\t\tString userName = null;\n\t\tDriver driver = new SQLServerDriver();\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Select userName from UserTable where userId = ?\"");\n\t\t\tstatement.setInt(1, userId);\n\t\t\tResultSet rs = statement.executeQuery();\n\t\t\trs.next();\n\t\t\tuserName = rs.getString(\""userName\"");\n\t\t\t\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\t\n\t\treturn userName;\n\t}""}, {""func_name"": ""enterPost"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic void enterPost(Post post){\n\t\tDriver driver = new SQLServerDriver();\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Insert INTO PostTable (postTitle, postAuthorId, postTime, postContent) \""\n\t\t\t\t\t+ \""VALUES ('\"" + post.getTitle() + \""', '\"" + this.getUserId(post.getAuthor()) + \""', CURRENT_TIMESTAMP, '\"" + post.getMessage() + \""');\"");\n\t\t\tstatement.setString(1, post.getTitle());\n\t\t\tstatement.setInt(2, this.getUserId(post.getAuthor()));\n\t\t\tstatement.setString(3, post.getMessage());\n\t\t\tstatement.execute();\n\t\t\tSystem.out.println(\""Successful post\"");\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}""}, {""func_name"": ""removeUser"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic void removeUser(Account user){\n\t\tDriver driver = new SQLServerDriver();\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""DELETE FROM UserTable WHERE userName=?\"");\n\t\t\tstatement.setString(1, user.getUsername());\n\t\t\tstatement.execute();\n\t\t\tSystem.out.println(\""Removal sucessful\"");\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}""}, {""func_name"": ""getUserId"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic int getUserId(String user){\n\t\tint id = -1;\n\t\tDriver driver = new SQLServerDriver();\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Select userId from UserTable where userName = ?\"");\n\t\t\tstatement.setString(1, user);\n\t\t\tResultSet rs = statement.executeQuery();\n\t\t\trs.next();\n\t\t\tString storedId = rs.getString(\""userId\"");\n\t\t\tid = Integer.parseInt(storedId);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\treturn id;\n\t}""}, {""func_name"": ""retrievePost"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java"", ""func_code"": ""@Override\n\tpublic Post retrievePost(String postTitle){\n\t\tPost post = null;\n\t\tDriver driver = new SQLServerDriver();\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Select postTitle, postAuthorId, postTime, postContent from PostTable where postTitle = '\"" + postTitle + \""'\"");\n\t\t\tResultSet rs = statement.executeQuery();\n\t\t\trs.next();\n\t\t\tpost = new Post(rs.getString(\""postTitle\""), rs.getString(\""postContent\""), this.getUserName(rs.getInt(\""postAuthorId\"")));\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\t\n\t\treturn post;\n\t}""}, {""func_name"": ""commitUserRegisterUser"", ""file_path"": ""Voyager/src/Controllers/RegisterController.java"", ""func_code"": ""public ModelAndView commitUserRegisterUser() {\n\t\tString username = \""\"";\n\t\tString password = \""\"";\n\t\tString confirmPassword = \""\"";\n\t\tString email = \""\"";\n\t\tString confirmEmail = \""\"";\n\t\tString avatarPath = \""\"";\n\t\ttry{\n\t\t\tusername = this.getValue(request.getPart(\""username\""));\n\t\t\tpassword = this.getValue(request.getPart(\""password\""));\n\t\t\tconfirmPassword = this.getValue(request.getPart(\""confirmPassword\""));\n\t\t\temail = this.getValue(request.getPart(\""email\""));\n\t\t\tconfirmEmail = this.getValue(request.getPart(\""confirmEmail\""));\n\t\t\tavatarPath = FileUploadController.getFileName(request.getPart(\""image\""));\n\t\t} catch (ServletException e1) {\n\t\t\te1.printStackTrace();\n\t\t} catch (IOException e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\t\t\n\t\t\n\t\tRegisterUserModel model = new RegisterUserModel();\n\t\tModelAndView mv = null;\n\t\t\n\t\tif(!password.equals(confirmPassword)) {\n\t\t\trequest.setAttribute(\""attemptedAccount\"", new Account(username, email, avatarPath, Roles.User, password));\n\t\t\tmv = new ModelAndView(\""Passwords did not match\"", \""/WEB-INF/register.jsp\"");\n\t\t}\n\t\tif(!email.equals(confirmEmail)){\n\t\t\trequest.setAttribute(\""attemptedAccount\"", new Account(username, email, avatarPath, Roles.User, password));\n\t\t\tmv = new ModelAndView(\""Emails did not match. \"", \""/WEB-INF/register.jsp\"");\n\t\t}\n\t\ttry {\n\t\t\tAccount user = new Account(username, email, avatarPath, Roles.User, password);\n\t\t\tdataService.registerUser(user);\n\t\t\tFileUploadController.processRequest(request, response, filePath);\n\t\t\tmodel.setUser(user);\n\t\t\tmv = new ModelAndView(model, \""/WEB-INF/account/profile.jsp\"");\n\t\t} catch(UsernameAlreadyExistsException e) {\n\t\t\trequest.setAttribute(\""attemptedAccount\"", new Account(username, email, avatarPath, Roles.User, password));\n\t\t\tmv = new ModelAndView(\""Username has already been used.\"", \""/WEB-INF/register.jsp\"");\n\t\t} catch (ServletException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treturn mv;\n\t}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(file:DatabaseAccess.java, func:retrievePost)"", ""result"": [{""code"": ""\t@Override\n\tpublic Post retrievePost(String postTitle){\n\t\tPost post = null;\n\t\tDriver driver = new SQLServerDriver();\n\t\tString connectionUrl = \""jdbc:sqlserver://n8bu1j6855.database.windows.net:1433;database=VoyagerDB;user=VoyageLogin@n8bu1j6855;password={GroupP@ssword};encrypt=true;hostNameInCertificate=*.database.windows.net;loginTimeout=30;\"";\n\t\ttry {\n\t\t\tConnection con = driver.connect(connectionUrl, new Properties());\n\t\t\tPreparedStatement statement = con.prepareStatement(\""Select postTitle, postAuthorId, postTime, postContent from PostTable where postTitle = '\"" + postTitle + \""'\"");\n\t\t\tResultSet rs = statement.executeQuery();\n\t\t\trs.next();\n\t\t\tpost = new Post(rs.getString(\""postTitle\""), rs.getString(\""postContent\""), this.getUserName(rs.getInt(\""postAuthorId\"")));\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t\t\n\t\treturn post;\n\t}\n"", ""start_line"": 177, ""end_line"": 194, ""full_name"": ""models.DatabaseAccess.retrievePost:models.Post(java.lang.String)"", ""file_path"": ""Voyager/src/models/DatabaseAccess.java""}]}, {""source"": ""code_info(file:DatabaseAccess.java, lines:21-25)"", ""result"": ""\t@Override\n\tpublic Account login(String username, String password){\n\t\tAccount account = null;\n\t\tDriver driver = new SQLServerDriver();\n\t\tString connectionUrl = \""jdbc:sqlserver://n8bu1j6855.database.windows.net:1433;database=VoyagerDB;user=VoyageLogin@n8bu1j6855;password={GroupP@ssword};encrypt=true;hostNameInCertificate=*.database.windows.net;loginTimeout=30;\"";\n""}]","Voyager/src/models/DatabaseAccess.java: retrievePost@func_after constructs a PreparedStatement with `?` but does not call `statement.setString(1, postTitle)` to bind the input. This leaves the `postTitle` parameter unescaped, enabling SQL injection when the query is executed.",0.95,./github/other_context/CVE-2014-125074
64,CVE-2014-2986,CWE-20,c_cpp,"The vgic_distr_mmio_write function in the virtual guest interrupt controller (GIC) distributor (arch/arm/vgic.c) in Xen 4.4.x, when running on an ARM system, allows local guest users to cause a denial of service (NULL pointer dereference and host crash) via unspecified vectors.",https://github.com/xen-project/xen/commit/bf70db7cea3794cf2f3c8d714b460bba86b04791,xen/arm: vgic: Check rank in GICD_ICFGR* emulation before locking\n\nThe function vgic_irq_rank may return NULL is the IRQ is not in range handled\nby the guest. This will result to derefence a NULL pointer which will crash\nXen.\n\nI've checked the rest of the emulation and this is only place where the lock\nis taken before the rank is checked.\n\nThis is CVE-2014-2986 / XSA-94.\n\nSigned-off-by: Julien Grall <julien.grall@linaro.org>\nReported-by: Thomas Leonard <talex5@gmail.com>\nReviewed-by: Jan Beulich <JBeulich@suse.com>\nAcked-by: Ian Campbell <ian.campbell@citrix.com>,1,"[{""func_name"": ""vgic_distr_mmio_write"", ""file_path"": ""xen/arch/arm/vgic.c"", ""func_code"": ""static int vgic_distr_mmio_write(struct vcpu *v, mmio_info_t *info)\n{\n    struct hsr_dabt dabt = info->dabt;\n    struct cpu_user_regs *regs = guest_cpu_user_regs();\n    register_t *r = select_user_reg(regs, dabt.reg);\n    struct vgic_irq_rank *rank;\n    int offset = (int)(info->gpa - v->domain->arch.vgic.dbase);\n    int gicd_reg = REG(offset);\n    uint32_t tr;\n\n    switch ( gicd_reg )\n    {\n    case GICD_CTLR:\n        if ( dabt.size != 2 ) goto bad_width;\n        /* Ignore all but the enable bit */\n        v->domain->arch.vgic.ctlr = (*r) & GICD_CTL_ENABLE;\n        return 1;\n\n    /* R/O -- write ignored */\n    case GICD_TYPER:\n    case GICD_IIDR:\n        goto write_ignore;\n\n    /* Implementation defined -- write ignored */\n    case REG(0x020) ... REG(0x03c):\n        goto write_ignore;\n\n    case GICD_IGROUPR ... GICD_IGROUPRN:\n        /* We do not implement security extensions for guests, write ignore */\n        goto write_ignore;\n\n    case GICD_ISENABLER ... GICD_ISENABLERN:\n        if ( dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ISENABLER);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        tr = rank->ienable;\n        rank->ienable |= *r;\n        vgic_unlock_rank(v, rank);\n        vgic_enable_irqs(v, (*r) & (~tr), gicd_reg - GICD_ISENABLER);\n        return 1;\n\n    case GICD_ICENABLER ... GICD_ICENABLERN:\n        if ( dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ICENABLER);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        tr = rank->ienable;\n        rank->ienable &= ~*r;\n        vgic_unlock_rank(v, rank);\n        vgic_disable_irqs(v, (*r) & tr, gicd_reg - GICD_ICENABLER);\n        return 1;\n\n    case GICD_ISPENDR ... GICD_ISPENDRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        printk(\""vGICD: unhandled %s write %#\""PRIregister\"" to ISPENDR%d\\n\"",\n               dabt.size ? \""word\"" : \""byte\"", *r, gicd_reg - GICD_ISPENDR);\n        return 0;\n\n    case GICD_ICPENDR ... GICD_ICPENDRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        printk(\""vGICD: unhandled %s write %#\""PRIregister\"" to ICPENDR%d\\n\"",\n               dabt.size ? \""word\"" : \""byte\"", *r, gicd_reg - GICD_ICPENDR);\n        return 0;\n\n    case GICD_ISACTIVER ... GICD_ISACTIVERN:\n        if ( dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ISACTIVER);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        rank->iactive &= ~*r;\n        vgic_unlock_rank(v, rank);\n        return 1;\n\n    case GICD_ICACTIVER ... GICD_ICACTIVERN:\n        if ( dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ICACTIVER);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        rank->iactive &= ~*r;\n        vgic_unlock_rank(v, rank);\n        return 1;\n\n    case GICD_ITARGETSR ... GICD_ITARGETSR + 7:\n        /* SGI/PPI target is read only */\n        goto write_ignore;\n\n    case GICD_ITARGETSR + 8 ... GICD_ITARGETSRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 8, gicd_reg - GICD_ITARGETSR);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        if ( dabt.size == 2 )\n            rank->itargets[REG_RANK_INDEX(8, gicd_reg - GICD_ITARGETSR)] = *r;\n        else\n            byte_write(&rank->itargets[REG_RANK_INDEX(8, gicd_reg - GICD_ITARGETSR)],\n                       *r, offset);\n        vgic_unlock_rank(v, rank);\n        return 1;\n\n    case GICD_IPRIORITYR ... GICD_IPRIORITYRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 8, gicd_reg - GICD_IPRIORITYR);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        if ( dabt.size == 2 )\n            rank->ipriority[REG_RANK_INDEX(8, gicd_reg - GICD_IPRIORITYR)] = *r;\n        else\n            byte_write(&rank->ipriority[REG_RANK_INDEX(8, gicd_reg - GICD_IPRIORITYR)],\n                       *r, offset);\n        vgic_unlock_rank(v, rank);\n        return 1;\n\n    case GICD_ICFGR: /* SGIs */\n        goto write_ignore;\n    case GICD_ICFGR + 1: /* PPIs */\n        /* It is implementation defined if these are writeable. We chose not */\n        goto write_ignore;\n    case GICD_ICFGR + 2 ... GICD_ICFGRN: /* SPIs */\n        if ( dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 2, gicd_reg - GICD_ICFGR);\n        vgic_lock_rank(v, rank);\n        if ( rank == NULL) goto write_ignore;\n        rank->icfg[REG_RANK_INDEX(2, gicd_reg - GICD_ICFGR)] = *r;\n        vgic_unlock_rank(v, rank);\n        return 1;\n\n    case GICD_NSACR ... GICD_NSACRN:\n        /* We do not implement security extensions for guests, write ignore */\n        goto write_ignore;\n\n    case GICD_SGIR:\n        if ( dabt.size != 2 )\n            goto bad_width;\n        return vgic_to_sgi(v, *r);\n\n    case GICD_CPENDSGIR ... GICD_CPENDSGIRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        printk(\""vGICD: unhandled %s write %#\""PRIregister\"" to ICPENDSGIR%d\\n\"",\n               dabt.size ? \""word\"" : \""byte\"", *r, gicd_reg - GICD_CPENDSGIR);\n        return 0;\n\n    case GICD_SPENDSGIR ... GICD_SPENDSGIRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        printk(\""vGICD: unhandled %s write %#\""PRIregister\"" to ISPENDSGIR%d\\n\"",\n               dabt.size ? \""word\"" : \""byte\"", *r, gicd_reg - GICD_SPENDSGIR);\n        return 0;\n\n    /* Implementation defined -- write ignored */\n    case REG(0xfd0) ... REG(0xfe4):\n        goto write_ignore;\n\n    /* R/O -- write ignore */\n    case GICD_ICPIDR2:\n        goto write_ignore;\n\n    /* Implementation defined -- write ignored */\n    case REG(0xfec) ... REG(0xffc):\n        goto write_ignore;\n\n    /* Reserved -- write ignored */\n    case REG(0x00c) ... REG(0x01c):\n    case REG(0x040) ... REG(0x07c):\n    case REG(0x7fc):\n    case REG(0xbfc):\n    case REG(0xf04) ... REG(0xf0c):\n    case REG(0xf30) ... REG(0xfcc):\n        goto write_ignore;\n\n    default:\n        printk(\""vGICD: unhandled write r%d=%\""PRIregister\"" offset %#08x\\n\"",\n               dabt.reg, *r, offset);\n        return 0;\n    }\n\nbad_width:\n    printk(\""vGICD: bad write width %d r%d=%\""PRIregister\"" offset %#08x\\n\"",\n           dabt.size, dabt.reg, *r, offset);\n    domain_crash_synchronous();\n    return 0;\n\nwrite_ignore:\n    if ( dabt.size != 2 ) goto bad_width;\n    return 1;\n}"", ""target"": 0}]","[{""func_name"": ""vgic_distr_mmio_write"", ""file_path"": ""xen/arch/arm/vgic.c"", ""func_code"": ""static int vgic_distr_mmio_write(struct vcpu *v, mmio_info_t *info)\n{\n    struct hsr_dabt dabt = info->dabt;\n    struct cpu_user_regs *regs = guest_cpu_user_regs();\n    register_t *r = select_user_reg(regs, dabt.reg);\n    struct vgic_irq_rank *rank;\n    int offset = (int)(info->gpa - v->domain->arch.vgic.dbase);\n    int gicd_reg = REG(offset);\n    uint32_t tr;\n\n    switch ( gicd_reg )\n    {\n    case GICD_CTLR:\n        if ( dabt.size != 2 ) goto bad_width;\n        /* Ignore all but the enable bit */\n        v->domain->arch.vgic.ctlr = (*r) & GICD_CTL_ENABLE;\n        return 1;\n\n    /* R/O -- write ignored */\n    case GICD_TYPER:\n    case GICD_IIDR:\n        goto write_ignore;\n\n    /* Implementation defined -- write ignored */\n    case REG(0x020) ... REG(0x03c):\n        goto write_ignore;\n\n    case GICD_IGROUPR ... GICD_IGROUPRN:\n        /* We do not implement security extensions for guests, write ignore */\n        goto write_ignore;\n\n    case GICD_ISENABLER ... GICD_ISENABLERN:\n        if ( dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ISENABLER);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        tr = rank->ienable;\n        rank->ienable |= *r;\n        vgic_unlock_rank(v, rank);\n        vgic_enable_irqs(v, (*r) & (~tr), gicd_reg - GICD_ISENABLER);\n        return 1;\n\n    case GICD_ICENABLER ... GICD_ICENABLERN:\n        if ( dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ICENABLER);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        tr = rank->ienable;\n        rank->ienable &= ~*r;\n        vgic_unlock_rank(v, rank);\n        vgic_disable_irqs(v, (*r) & tr, gicd_reg - GICD_ICENABLER);\n        return 1;\n\n    case GICD_ISPENDR ... GICD_ISPENDRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        printk(\""vGICD: unhandled %s write %#\""PRIregister\"" to ISPENDR%d\\n\"",\n               dabt.size ? \""word\"" : \""byte\"", *r, gicd_reg - GICD_ISPENDR);\n        return 0;\n\n    case GICD_ICPENDR ... GICD_ICPENDRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        printk(\""vGICD: unhandled %s write %#\""PRIregister\"" to ICPENDR%d\\n\"",\n               dabt.size ? \""word\"" : \""byte\"", *r, gicd_reg - GICD_ICPENDR);\n        return 0;\n\n    case GICD_ISACTIVER ... GICD_ISACTIVERN:\n        if ( dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ISACTIVER);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        rank->iactive &= ~*r;\n        vgic_unlock_rank(v, rank);\n        return 1;\n\n    case GICD_ICACTIVER ... GICD_ICACTIVERN:\n        if ( dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 1, gicd_reg - GICD_ICACTIVER);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        rank->iactive &= ~*r;\n        vgic_unlock_rank(v, rank);\n        return 1;\n\n    case GICD_ITARGETSR ... GICD_ITARGETSR + 7:\n        /* SGI/PPI target is read only */\n        goto write_ignore;\n\n    case GICD_ITARGETSR + 8 ... GICD_ITARGETSRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 8, gicd_reg - GICD_ITARGETSR);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        if ( dabt.size == 2 )\n            rank->itargets[REG_RANK_INDEX(8, gicd_reg - GICD_ITARGETSR)] = *r;\n        else\n            byte_write(&rank->itargets[REG_RANK_INDEX(8, gicd_reg - GICD_ITARGETSR)],\n                       *r, offset);\n        vgic_unlock_rank(v, rank);\n        return 1;\n\n    case GICD_IPRIORITYR ... GICD_IPRIORITYRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 8, gicd_reg - GICD_IPRIORITYR);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        if ( dabt.size == 2 )\n            rank->ipriority[REG_RANK_INDEX(8, gicd_reg - GICD_IPRIORITYR)] = *r;\n        else\n            byte_write(&rank->ipriority[REG_RANK_INDEX(8, gicd_reg - GICD_IPRIORITYR)],\n                       *r, offset);\n        vgic_unlock_rank(v, rank);\n        return 1;\n\n    case GICD_ICFGR: /* SGIs */\n        goto write_ignore;\n    case GICD_ICFGR + 1: /* PPIs */\n        /* It is implementation defined if these are writeable. We chose not */\n        goto write_ignore;\n    case GICD_ICFGR + 2 ... GICD_ICFGRN: /* SPIs */\n        if ( dabt.size != 2 ) goto bad_width;\n        rank = vgic_irq_rank(v, 2, gicd_reg - GICD_ICFGR);\n        if ( rank == NULL) goto write_ignore;\n        vgic_lock_rank(v, rank);\n        rank->icfg[REG_RANK_INDEX(2, gicd_reg - GICD_ICFGR)] = *r;\n        vgic_unlock_rank(v, rank);\n        return 1;\n\n    case GICD_NSACR ... GICD_NSACRN:\n        /* We do not implement security extensions for guests, write ignore */\n        goto write_ignore;\n\n    case GICD_SGIR:\n        if ( dabt.size != 2 )\n            goto bad_width;\n        return vgic_to_sgi(v, *r);\n\n    case GICD_CPENDSGIR ... GICD_CPENDSGIRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        printk(\""vGICD: unhandled %s write %#\""PRIregister\"" to ICPENDSGIR%d\\n\"",\n               dabt.size ? \""word\"" : \""byte\"", *r, gicd_reg - GICD_CPENDSGIR);\n        return 0;\n\n    case GICD_SPENDSGIR ... GICD_SPENDSGIRN:\n        if ( dabt.size != 0 && dabt.size != 2 ) goto bad_width;\n        printk(\""vGICD: unhandled %s write %#\""PRIregister\"" to ISPENDSGIR%d\\n\"",\n               dabt.size ? \""word\"" : \""byte\"", *r, gicd_reg - GICD_SPENDSGIR);\n        return 0;\n\n    /* Implementation defined -- write ignored */\n    case REG(0xfd0) ... REG(0xfe4):\n        goto write_ignore;\n\n    /* R/O -- write ignore */\n    case GICD_ICPIDR2:\n        goto write_ignore;\n\n    /* Implementation defined -- write ignored */\n    case REG(0xfec) ... REG(0xffc):\n        goto write_ignore;\n\n    /* Reserved -- write ignored */\n    case REG(0x00c) ... REG(0x01c):\n    case REG(0x040) ... REG(0x07c):\n    case REG(0x7fc):\n    case REG(0xbfc):\n    case REG(0xf04) ... REG(0xf0c):\n    case REG(0xf30) ... REG(0xfcc):\n        goto write_ignore;\n\n    default:\n        printk(\""vGICD: unhandled write r%d=%\""PRIregister\"" offset %#08x\\n\"",\n               dabt.reg, *r, offset);\n        return 0;\n    }\n\nbad_width:\n    printk(\""vGICD: bad write width %d r%d=%\""PRIregister\"" offset %#08x\\n\"",\n           dabt.size, dabt.reg, *r, offset);\n    domain_crash_synchronous();\n    return 0;\n\nwrite_ignore:\n    if ( dabt.size != 2 ) goto bad_width;\n    return 1;\n}""}]","{""function"": 1}","[{""source"": ""func_info(file:vgic.c, func:vgic_irq_rank)"", ""result"": [{""code"": ""static struct vgic_irq_rank *vgic_irq_rank(struct vcpu *v, int b, int n)\n{\n    int rank = REG_RANK_NR(b, n);\n\n    if ( rank == 0 )\n        return &v->arch.vgic.private_irqs;\n    else if ( rank <= DOMAIN_NR_RANKS(v->domain) )\n        return &v->domain->arch.vgic.shared_irqs[rank - 1];\n    else\n        return NULL;\n}"", ""start_line"": 64, ""end_line"": 74, ""full_name"": ""vgic_irq_rank"", ""file_path"": ""xen/arch/arm/vgic.c""}]}]","xen/arch/arm/vgic.c:593-595: In vgic_distr_mmio_write, 'rank' is assigned via vgic_irq_rank, which returns NULL for out-of-range IRQs. The original code calls vgic_lock_rank(rank) without checking if 'rank' is NULL, leading to a NULL dereference during locking/unlocking. The patch adds a NULL check before locking/unlocking. The failure in vgic_irq_rank (xen/arch/arm/vgic.c:64-74) occurs when 'rank' exceeds DOMAIN_NR_RANKS, returning NULL.",0.95,./github/other_context/CVE-2014-2986
65,CVE-2014-5336,CWE-20,c_cpp,"Monkey HTTP Server before 1.5.3, when the File Descriptor Table (FDT) is enabled and custom error messages are set, allows remote attackers to cause a denial of service (file descriptor consumption) via an HTTP request that triggers an error message.",https://github.com/monkey/monkey/commit/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd,"Request: new request session flag to mark those files opened by FDT\n\nThis patch aims to fix a potential DDoS problem that can be caused\nin the server quering repetitive non-existent resources.\n\nWhen serving a static file, the core use Vhost FDT mechanism, but if\nit sends a static error page it does a direct open(2). When closing\nthe resources for the same request it was just calling mk_vhost_close()\nwhich did not clear properly the file descriptor.\n\nThis patch adds a new field on the struct session_request called 'fd_is_fdt',\nwhich contains MK_TRUE or MK_FALSE depending of how fd_file was opened.\n\nThanks to Matthew Daley <mattd@bugfuzz.com> for report and troubleshoot this\nproblem.\n\nSigned-off-by: Eduardo Silva <eduardo@monkey.io>",4,"[{""func_name"": ""mk_vhost_fdt_close"", ""file_path"": ""src/mk_vhost.c"", ""func_code"": ""static inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n\n    /* We got the hash table, now look around the chains array */\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        /* Increment the readers and check if we should close */\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    return close(sr->fd_file);\n}"", ""target"": 0}, {""func_name"": ""mk_vhost_fdt_open"", ""file_path"": ""src/mk_vhost.c"", ""func_code"": ""static inline int mk_vhost_fdt_open(int id, unsigned int hash,\n                                    struct session_request *sr)\n{\n    int i;\n    int fd;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n\n    /* We got the hash table, now look around the chains array */\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        /* Increment the readers and return the shared FD */\n        hc->readers++;\n        return hc->fd;\n    }\n\n    /*\n     * Get here means that no entry exists in the hash table for the\n     * requested file descriptor and hash, we must try to open the file\n     * and register the entry in the table.\n     */\n    fd = open(sr->real_path.data, sr->file_info.flags_read_only);\n    if (fd == -1) {\n        return -1;\n    }\n\n    /* If chains are full, just return the new FD, bad luck... */\n    if (ht->av_slots <= 0) {\n        return fd;\n    }\n\n    /* Register the new entry in an available slot */\n    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {\n        hc = &ht->chain[i];\n        if (hc->fd == -1) {\n            hc->fd   = fd;\n            hc->hash = hash;\n            hc->readers++;\n            ht->av_slots--;\n\n            sr->vhost_fdt_id   = id;\n            sr->vhost_fdt_hash = hash;\n\n            return fd;\n        }\n    }\n\n    return -1;\n}"", ""target"": 0}, {""func_name"": ""mk_request_free"", ""file_path"": ""src/mk_request.c"", ""func_code"": ""void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}"", ""target"": 0}, {""func_name"": ""mk_request_error"", ""file_path"": ""src/mk_request.c"", ""func_code"": ""int mk_request_error(int http_status, struct client_session *cs,\n                     struct session_request *sr) {\n    int ret, fd;\n    mk_ptr_t message, *page = 0;\n    struct error_page *entry;\n    struct mk_list *head;\n    struct file_info finfo;\n\n    mk_header_set_http_status(sr, http_status);\n\n    /*\n     * We are nice sending error pages for clients who at least respect\n     * the especification\n     */\n    if (http_status != MK_CLIENT_LENGTH_REQUIRED &&\n        http_status != MK_CLIENT_BAD_REQUEST &&\n        http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE) {\n\n        /* Lookup a customized error page */\n        mk_list_foreach(head, &sr->host_conf->error_pages) {\n            entry = mk_list_entry(head, struct error_page, _head);\n            if (entry->status != http_status) {\n                continue;\n            }\n\n            /* validate error file */\n            ret = mk_file_get_info(entry->real_path, &finfo);\n            if (ret == -1) {\n                break;\n            }\n\n            /* open file */\n            fd = open(entry->real_path, config->open_flags);\n            if (fd == -1) {\n                break;\n            }\n\n            sr->fd_file = fd;\n            sr->bytes_to_send = finfo.size;\n            sr->headers.content_length = finfo.size;\n            sr->headers.real_length    = finfo.size;\n\n            memcpy(&sr->file_info, &finfo, sizeof(struct file_info));\n\n            mk_header_send(cs->socket, cs, sr);\n            return mk_http_send_file(cs, sr);\n        }\n    }\n\n    mk_ptr_reset(&message);\n\n    switch (http_status) {\n    case MK_CLIENT_BAD_REQUEST:\n        page = mk_request_set_default_page(\""Bad Request\"",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_FORBIDDEN:\n        page = mk_request_set_default_page(\""Forbidden\"",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_NOT_FOUND:\n        mk_string_build(&message.data, &message.len,\n                        \""The requested URL was not found on this server.\"");\n        page = mk_request_set_default_page(\""Not Found\"",\n                                           message,\n                                           sr->host_conf->host_signature);\n        mk_ptr_free(&message);\n        break;\n\n    case MK_CLIENT_REQUEST_ENTITY_TOO_LARGE:\n        mk_string_build(&message.data, &message.len,\n                        \""The request entity is too large.\"");\n        page = mk_request_set_default_page(\""Entity too large\"",\n                                           message,\n                                           sr->host_conf->host_signature);\n        mk_ptr_free(&message);\n        break;\n\n    case MK_CLIENT_METHOD_NOT_ALLOWED:\n        page = mk_request_set_default_page(\""Method Not Allowed\"",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_REQUEST_TIMEOUT:\n    case MK_CLIENT_LENGTH_REQUIRED:\n        break;\n\n    case MK_SERVER_NOT_IMPLEMENTED:\n        page = mk_request_set_default_page(\""Method Not Implemented\"",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_SERVER_INTERNAL_ERROR:\n        page = mk_request_set_default_page(\""Internal Server Error\"",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_SERVER_HTTP_VERSION_UNSUP:\n        mk_ptr_reset(&message);\n        page = mk_request_set_default_page(\""HTTP Version Not Supported\"",\n                                           message,\n                                           sr->host_conf->host_signature);\n        break;\n    }\n\n    if (page) {\n        sr->headers.content_length = page->len;\n    }\n\n    sr->headers.location = NULL;\n    sr->headers.cgi = SH_NOCGI;\n    sr->headers.pconnections_left = 0;\n    sr->headers.last_modified = -1;\n\n    if (!page) {\n        mk_ptr_reset(&sr->headers.content_type);\n    }\n    else {\n        mk_ptr_set(&sr->headers.content_type, \""text/html\\r\\n\"");\n    }\n\n    mk_header_send(cs->socket, cs, sr);\n\n    if (page) {\n        if (sr->method != MK_HTTP_METHOD_HEAD)\n            mk_socket_send(cs->socket, page->data, page->len);\n\n        mk_ptr_free(page);\n        mk_mem_free(page);\n    }\n\n    /* Turn off TCP_CORK */\n    mk_server_cork_flag(cs->socket, TCP_CORK_OFF);\n    return EXIT_ERROR;\n}"", ""target"": 0}]","[{""func_name"": ""mk_vhost_fdt_close"", ""file_path"": ""src/mk_vhost.c"", ""func_code"": ""static inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n\n    /* We got the hash table, now look around the chains array */\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        /* Increment the readers and check if we should close */\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n    return close(sr->fd_file);\n}""}, {""func_name"": ""mk_vhost_fdt_open"", ""file_path"": ""src/mk_vhost.c"", ""func_code"": ""static inline int mk_vhost_fdt_open(int id, unsigned int hash,\n                                    struct session_request *sr)\n{\n    int i;\n    int fd;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n\n    /* We got the hash table, now look around the chains array */\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        /* Increment the readers and return the shared FD */\n        hc->readers++;\n        return hc->fd;\n    }\n\n    /*\n     * Get here means that no entry exists in the hash table for the\n     * requested file descriptor and hash, we must try to open the file\n     * and register the entry in the table.\n     */\n    fd = open(sr->real_path.data, sr->file_info.flags_read_only);\n    if (fd == -1) {\n        return -1;\n    }\n\n    /* If chains are full, just return the new FD, bad luck... */\n    if (ht->av_slots <= 0) {\n        return fd;\n    }\n\n    /* Register the new entry in an available slot */\n    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {\n        hc = &ht->chain[i];\n        if (hc->fd == -1) {\n            hc->fd   = fd;\n            hc->hash = hash;\n            hc->readers++;\n            ht->av_slots--;\n\n            sr->vhost_fdt_id   = id;\n            sr->vhost_fdt_hash = hash;\n            sr->fd_is_fdt      = MK_TRUE;\n\n            return fd;\n        }\n    }\n\n    return -1;\n}""}, {""func_name"": ""mk_request_free"", ""file_path"": ""src/mk_request.c"", ""func_code"": ""void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        if (sr->fd_is_fdt == MK_TRUE) {\n            mk_vhost_close(sr);\n        }\n        else {\n            close(sr->fd_file);\n        }\n    }\n\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}""}, {""func_name"": ""mk_request_error"", ""file_path"": ""src/mk_request.c"", ""func_code"": ""int mk_request_error(int http_status, struct client_session *cs,\n                     struct session_request *sr) {\n    int ret, fd;\n    mk_ptr_t message, *page = 0;\n    struct error_page *entry;\n    struct mk_list *head;\n    struct file_info finfo;\n\n    mk_header_set_http_status(sr, http_status);\n\n    /*\n     * We are nice sending error pages for clients who at least respect\n     * the especification\n     */\n    if (http_status != MK_CLIENT_LENGTH_REQUIRED &&\n        http_status != MK_CLIENT_BAD_REQUEST &&\n        http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE) {\n\n        /* Lookup a customized error page */\n        mk_list_foreach(head, &sr->host_conf->error_pages) {\n            entry = mk_list_entry(head, struct error_page, _head);\n            if (entry->status != http_status) {\n                continue;\n            }\n\n            /* validate error file */\n            ret = mk_file_get_info(entry->real_path, &finfo);\n            if (ret == -1) {\n                break;\n            }\n\n            /* open file */\n            fd = open(entry->real_path, config->open_flags);\n            if (fd == -1) {\n                break;\n            }\n\n            sr->fd_file   = fd;\n            sr->fd_is_fdt = MK_FALSE;\n            sr->bytes_to_send = finfo.size;\n            sr->headers.content_length = finfo.size;\n            sr->headers.real_length    = finfo.size;\n\n            memcpy(&sr->file_info, &finfo, sizeof(struct file_info));\n\n            mk_header_send(cs->socket, cs, sr);\n            return mk_http_send_file(cs, sr);\n        }\n    }\n\n    mk_ptr_reset(&message);\n\n    switch (http_status) {\n    case MK_CLIENT_BAD_REQUEST:\n        page = mk_request_set_default_page(\""Bad Request\"",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_FORBIDDEN:\n        page = mk_request_set_default_page(\""Forbidden\"",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_NOT_FOUND:\n        mk_string_build(&message.data, &message.len,\n                        \""The requested URL was not found on this server.\"");\n        page = mk_request_set_default_page(\""Not Found\"",\n                                           message,\n                                           sr->host_conf->host_signature);\n        mk_ptr_free(&message);\n        break;\n\n    case MK_CLIENT_REQUEST_ENTITY_TOO_LARGE:\n        mk_string_build(&message.data, &message.len,\n                        \""The request entity is too large.\"");\n        page = mk_request_set_default_page(\""Entity too large\"",\n                                           message,\n                                           sr->host_conf->host_signature);\n        mk_ptr_free(&message);\n        break;\n\n    case MK_CLIENT_METHOD_NOT_ALLOWED:\n        page = mk_request_set_default_page(\""Method Not Allowed\"",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_CLIENT_REQUEST_TIMEOUT:\n    case MK_CLIENT_LENGTH_REQUIRED:\n        break;\n\n    case MK_SERVER_NOT_IMPLEMENTED:\n        page = mk_request_set_default_page(\""Method Not Implemented\"",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_SERVER_INTERNAL_ERROR:\n        page = mk_request_set_default_page(\""Internal Server Error\"",\n                                           sr->uri,\n                                           sr->host_conf->host_signature);\n        break;\n\n    case MK_SERVER_HTTP_VERSION_UNSUP:\n        mk_ptr_reset(&message);\n        page = mk_request_set_default_page(\""HTTP Version Not Supported\"",\n                                           message,\n                                           sr->host_conf->host_signature);\n        break;\n    }\n\n    if (page) {\n        sr->headers.content_length = page->len;\n    }\n\n    sr->headers.location = NULL;\n    sr->headers.cgi = SH_NOCGI;\n    sr->headers.pconnections_left = 0;\n    sr->headers.last_modified = -1;\n\n    if (!page) {\n        mk_ptr_reset(&sr->headers.content_type);\n    }\n    else {\n        mk_ptr_set(&sr->headers.content_type, \""text/html\\r\\n\"");\n    }\n\n    mk_header_send(cs->socket, cs, sr);\n\n    if (page) {\n        if (sr->method != MK_HTTP_METHOD_HEAD)\n            mk_socket_send(cs->socket, page->data, page->len);\n\n        mk_ptr_free(page);\n        mk_mem_free(page);\n    }\n\n    /* Turn off TCP_CORK */\n    mk_server_cork_flag(cs->socket, TCP_CORK_OFF);\n    return EXIT_ERROR;\n}""}]","{""caller"": 1}","[{""source"": ""caller_info(func:mk_request_error)"", ""result"": [{""call_line"": 376, ""call_code"": ""mk_request_error(MK_CLIENT_FORBIDDEN, cs, sr)"", ""caller_code"": ""int mk_http_init(struct client_session *cs, struct session_request *sr)\n{\n    int ret;\n    int bytes = 0;\n    struct mimetype *mime;\n\n    MK_TRACE(\""[FD %i] HTTP Protocol Init, session %p\"", cs->socket, sr);\n\n    /* Request to root path of the virtualhost in question */\n    if (sr->uri_processed.len == 1 && sr->uri_processed.data[0] == '/') {\n        sr->real_path.data = sr->host_conf->documentroot.data;\n        sr->real_path.len = sr->host_conf->documentroot.len;\n    }\n\n    /* Compose real path */\n    if (sr->user_home == MK_FALSE) {\n        int len;\n\n        len = sr->host_conf->documentroot.len + sr->uri_processed.len;\n        if (len < MK_PATH_BASE) {\n            memcpy(sr->real_path_static,\n                   sr->host_conf->documentroot.data,\n                   sr->host_conf->documentroot.len);\n            memcpy(sr->real_path_static + sr->host_conf->documentroot.len,\n                   sr->uri_processed.data,\n                   sr->uri_processed.len);\n            sr->real_path_s..."", ""caller_start"": 328, ""file_path"": ""src/mk_http.c""}, {""call_line"": 388, ""call_code"": ""mk_request_error(sr->headers.status, cs, sr)"", ""caller_code"": ""int mk_http_init(struct client_session *cs, struct session_request *sr)\n{\n    int ret;\n    int bytes = 0;\n    struct mimetype *mime;\n\n    MK_TRACE(\""[FD %i] HTTP Protocol Init, session %p\"", cs->socket, sr);\n\n    /* Request to root path of the virtualhost in question */\n    if (sr->uri_processed.len == 1 && sr->uri_processed.data[0] == '/') {\n        sr->real_path.data = sr->host_conf->documentroot.data;\n        sr->real_path.len = sr->host_conf->documentroot.len;\n    }\n\n    /* Compose real path */\n    if (sr->user_home == MK_FALSE) {\n        int len;\n\n        len = sr->host_conf->documentroot.len + sr->uri_processed.len;\n        if (len < MK_PATH_BASE) {\n            memcpy(sr->real_path_static,\n                   sr->host_conf->documentroot.data,\n                   sr->host_conf->documentroot.len);\n            memcpy(sr->real_path_static + sr->host_conf->documentroot.len,\n                   sr->uri_processed.data,\n                   sr->uri_processed.len);\n            sr->real_path_s..."", ""caller_start"": 328, ""file_path"": ""src/mk_http.c""}, {""call_line"": 391, ""call_code"": ""mk_request_error(MK_CLIENT_FORBIDDEN, cs, sr)"", ""caller_code"": ""int mk_http_init(struct client_session *cs, struct session_request *sr)\n{\n    int ret;\n    int bytes = 0;\n    struct mimetype *mime;\n\n    MK_TRACE(\""[FD %i] HTTP Protocol Init, session %p\"", cs->socket, sr);\n\n    /* Request to root path of the virtualhost in question */\n    if (sr->uri_processed.len == 1 && sr->uri_processed.data[0] == '/') {\n        sr->real_path.data = sr->host_conf->documentroot.data;\n        sr->real_path.len = sr->host_conf->documentroot.len;\n    }\n\n    /* Compose real path */\n    if (sr->user_home == MK_FALSE) {\n        int len;\n\n        len = sr->host_conf->documentroot.len + sr->uri_processed.len;\n        if (len < MK_PATH_BASE) {\n            memcpy(sr->real_path_static,\n                   sr->host_conf->documentroot.data,\n                   sr->host_conf->documentroot.len);\n            memcpy(sr->real_path_static + sr->host_conf->documentroot.len,\n                   sr->uri_processed.data,\n                   sr->uri_processed.len);\n            sr->real_path_s..."", ""caller_start"": 328, ""file_path"": ""src/mk_http.c""}]}]","The vulnerability arises when an HTTP request triggers an error condition (e.g., forbidden access or invalid path) in mk_http_init (src/mk_http.c:376, 388, 391). This invokes mk_request_error, which opens an error page via direct open(2), setting sr->fd_is_fdt=MK_FALSE (src/mk_request.c:842-843). During cleanup in mk_request_free (src/mk_request.c:100-105), the flag (added by the patch) ensures direct FDs are closed via close(). Prior to the patch, mk_vhost_close() was called unconditionally, failing to close direct FDs, leading to leaks. The trigger chain is fully evidenced by the provided code, with the struct session_request modification implied by the patch.",0.95,./github/other_context/CVE-2014-5336
66,CVE-2014-8323,CWE-20,c_cpp,buddy-ng.c in Aircrack-ng before 1.2 Beta 3 allows remote attackers to cause a denial of service (segmentation fault) via a response with a crafted length parameter.,https://github.com/aircrack-ng/aircrack-ng/commit/da087238963c1239fdabd47dc1b65279605aca70,Buddy-ng: Fixed segmentation fault (Closes #15 on GitHub).\n\ngit-svn-id: http://svn.aircrack-ng.org/trunk@2418 28c6078b-6c39-48e3-add9-af49d547ecab,1,"[{""func_name"": ""handle"", ""file_path"": ""src/buddy-ng.c"", ""func_code"": ""int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\n\t/* inet check */\n\tif (len == S_HELLO_LEN && memcmp(data, \""sorbo\"", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\n\t\tprintf(\""Inet check by %s %d\\n\"",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\t*cmd++ = htons(S_CMD_PACKET);\n\t*cmd++ = *pid;\n\tplen = len - 2;\n\n\tlast_id = ntohs(*pid);\n\tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\n\tprintf(\""Got packet %d %d\"", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\"" (DUP)\\n\"");\n\t\treturn 0;\n\t}\n\tprintf(\""\\n\"");\n\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""handle"", ""file_path"": ""src/buddy-ng.c"", ""func_code"": ""int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\n\t/* inet check */\n\tif (len == S_HELLO_LEN && memcmp(data, \""sorbo\"", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\n\t\tprintf(\""Inet check by %s %d\\n\"",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\t*cmd++ = htons(S_CMD_PACKET);\n\t*cmd++ = *pid;\n\tplen = len - 2;\n    if (plen < 0)\n        return 0;\n\n\tlast_id = ntohs(*pid);\n\tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\n\tprintf(\""Got packet %d %d\"", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\"" (DUP)\\n\"");\n\t\treturn 0;\n\t}\n\tprintf(\""\\n\"");\n\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\n\treturn 0;\n}""}]","{""value"": 1, ""caller"": 1}","[{""source"": ""value_info(file:buddy-ng.c, value:len)"", ""result"": {""value_trace"": [{""full_code"": ""len = sizeof(s_in)"", ""line"": 163, ""func_name"": ""handle_dude""}, {""full_code"": ""len = 1"", ""line"": 262, ""func_name"": ""main<duplicate>10""}, {""full_code"": ""len = sizeof(dude_sin)"", ""line"": 274, ""func_name"": ""main<duplicate>10""}], ""struct_var"": ""len"", ""struct_type"": ""socklen_t"", ""struct_definition"": ""socklen_t""}}, {""source"": ""caller_info(file:buddy-ng.c, func:handle)"", ""result"": [{""call_line"": 169, ""call_code"": ""handle(dude, buf, rc, &s_in)"", ""caller_code"": ""void handle_dude(int dude, int udp)\n{\n\tunsigned char buf[2048];\n\tint rc;\n\tfd_set rfds;\n\tint maxfd;\n\tstruct sockaddr_in s_in;\n\tsocklen_t len;\n\n\t/* handshake */\n\trc = recv(dude, buf, 5, 0);\n\tif (rc != 5) {\n\t\tclose(dude);\n\t\treturn;\n\t}\n\n\tif (memcmp(buf, \""sorbo\"", 5) != 0) {\n\t\tclose(dude);\n\t\treturn;\n\t}\n\n\tif (send(dude, \""sorbox\"", 6, 0) != 6) {\n\t\tclose(dude);\n\t\treturn;\n\t}\n\n\tprintf(\""Handshake complete\\n\"");\n\tmemset(ids, 0, sizeof(ids));\n\tlast_id = 0;\n\twrap = 0;\n\n\twhile (1) {\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(udp, &rfds);\n\t\tFD_SET(dude, &rfds);\n\n\t\tif (dude > udp)\n\t\t\tmaxfd = dude;\n\t\telse\n\t\t\tmaxfd = udp;\n\n\t\tif (select(maxfd+1, &rfds, NULL, NULL, NULL) == -1)\n\t\t\terr(1, \""select()\"");\n\n\t\tif (FD_ISSET(dude, &rfds))\n\t\t\tbreak;\n\n\t\tif (!FD_ISSET(udp, &rfds))\n\t\t\tcontinue;\n\n\t\tlen = sizeof(s_in);\n\t\trc = recvfrom(udp, buf, sizeof(buf), 0,\n\t\t\t      (struct sockaddr*) &s_in, &len);\n\t\tif (rc == -1)\n\t\t\terr(1, \""read()\"");\n\n\t\tif (handle(dude, buf, rc, &s_in))\n\t\t\tbreak;\n\t}\n\tclose(dude);\n}"", ""caller_start"": 113, ""file_path"": ""src/buddy-ng.c""}]}]","src/buddy-ng.c:84-86: 'plen' is calculated as 'len - 2' without validating 'len'. 'len' is initialized as 'sizeof(s_in)' (src/buddy-ng.c:163) but is modified by 'recvfrom' (src/buddy-ng.c:274) during packet reception. If 'len' is less than 2, 'plen' becomes negative, leading to invalid memory access when used in subsequent operations (e.g., '*pid' dereference).",0.95,./github/other_context/CVE-2014-8323
67,CVE-2014-8324,CWE-20,c_cpp,network.c in Aircrack-ng before 1.2 Beta 3 allows remote attackers to cause a denial of service (segmentation fault) via a response with a crafted length parameter.,https://github.com/aircrack-ng/aircrack-ng/commit/88702a3ce4c28a973bf69023cd0312f412f6193e,OSdep: Fixed segmentation fault that happens with a malicious server sending a negative length (Closes #16 on GitHub).\n\ngit-svn-id: http://svn.aircrack-ng.org/trunk@2419 28c6078b-6c39-48e3-add9-af49d547ecab,1,"[{""func_name"": ""net_get"", ""file_path"": ""src/osdep/network.c"", ""func_code"": ""int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\""PLEN %d type %d len %d\\n\"",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); /* XXX */\n\n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\n\treturn nh.nh_type;\n}"", ""target"": 0}]","[{""func_name"": ""net_get"", ""file_path"": ""src/osdep/network.c"", ""func_code"": ""int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\""PLEN %d type %d len %d\\n\"",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len && plen > 0); /* XXX */\n\n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\n\treturn nh.nh_type;\n}""}]","{""code"": 1, ""value"": 1, ""query"": 1}","[{""source"": ""code_info(file:network.c, lines:120-140)"", ""result"": ""int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\""PLEN %d type %d len %d\\n\"",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); /* XXX */\n\n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n""}, {""source"": ""value_info(file:network.c, value:plen)"", ""result"": {""value_trace"": [{""full_code"": ""plen = ntohl(nh.nh_len)"", ""line"": 130, ""func_name"": ""net_get""}], ""struct_var"": ""plen"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""query_info(query:cpg.typeDecl.name(\""net_hdr\"").l)"", ""result"": [{""inheritsFromTypeFullName"": [], ""name"": ""net_hdr"", ""lineNumber"": 5299, ""fullName"": ""net_hdr"", ""code"": ""struct net_hdr {\n\tuint8_t\t\tnh_type;\n\tuint32_t\tnh_len;\n\tuint8_t\t\tnh_data[0];\n} __packed"", ""columnNumber"": 1, ""filename"": ""src/aireplay-ng.c""}, {""inheritsFromTypeFullName"": [], ""name"": ""net_hdr"", ""lineNumber"": 29, ""fullName"": ""net_hdr<duplicate>0"", ""code"": ""struct net_hdr {\n\tuint8_t\t\tnh_type;\n\tuint32_t\tnh_len;\n\tuint8_t\t\tnh_data[0];\n} __packed"", ""columnNumber"": 1, ""filename"": ""src/osdep/network.h""}]}]","src/osdep/network.c:130-132: 'plen' is derived from 'nh.nh_len' (a uint32_t in 'struct net_hdr' defined in src/osdep/network.h:29). When 'nh.nh_len' exceeds INT_MAX (e.g., 0x80000001), 'ntohl(nh.nh_len)' produces a value that overflows into a negative int. The original code lacked a check for negative 'plen', allowing 'net_read_exact' (line 135) to process a negative length, triggering a segmentation fault. The patch enforces 'plen > 0' to prevent this.",0.95,./github/other_context/CVE-2014-8324
68,CVE-2015-5685,CWE-20,c_cpp,"The lazy_bdecode function in BitTorrent DHT bootstrap server (bootstrap-dht ) allows remote attackers to execute arbitrary code via a crafted packet, related to ""improper indexing.""",https://github.com/bittorrent/bootstrap-dht/commit/e809ea80e3527e32c40756eddd8b2ae44bc3af1a,Check for out-of-bounds bencoded lengths before advancing buffer pointer,1,"[{""func_name"": ""lazy_bdecode"", ""file_path"": ""lazy_bdecode.cpp"", ""func_code"": ""int lazy_bdecode(char const* start, char const* end, lazy_entry& ret\n\t\t, error_code& ec, int* error_pos, int depth_limit, int item_limit)\n\t{\n\t\tchar const* const orig_start = start;\n\t\tret.clear();\n\t\tif (start == end) return 0;\n\n\t\tstd::vector<lazy_entry*> stack;\n\n\t\tstack.push_back(&ret);\n\t\twhile (start <= end)\n\t\t{\n\t\t\tif (stack.empty()) break; // done!\n\n\t\t\tlazy_entry* top = stack.back();\n\n\t\t\tif (int(stack.size()) > depth_limit) TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);\n\t\t\tif (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\tchar t = *start;\n\t\t\t++start;\n\t\t\tif (start >= end && t != 'e') TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\n\t\t\tswitch (top->type())\n\t\t\t{\n\t\t\t\tcase lazy_entry::dict_t:\n\t\t\t\t{\n\t\t\t\t\tif (t == 'e')\n\t\t\t\t\t{\n\t\t\t\t\t\ttop->set_end(start);\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!numeric(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);\n\t\t\t\t\tboost::int64_t len = t - '0';\n\t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n\t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n\n\t\t\t\t\tif (start + len + 1 > end)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n\n\t\t\t\t\t++start;\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tlazy_entry* ent = top->dict_append(start);\n\t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n\t\t\t\t\tstart += len;\n\t\t\t\t\tif (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tstack.push_back(ent);\n\t\t\t\t\tt = *start;\n\t\t\t\t\t++start;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase lazy_entry::list_t:\n\t\t\t\t{\n\t\t\t\t\tif (t == 'e')\n\t\t\t\t\t{\n\t\t\t\t\t\ttop->set_end(start);\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlazy_entry* ent = top->list_append();\n\t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n\t\t\t\t\tstack.push_back(ent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault: break;\n\t\t\t}\n\n\t\t\t--item_limit;\n\t\t\tif (item_limit <= 0) TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);\n\n\t\t\ttop = stack.back();\n\t\t\tswitch (t)\n\t\t\t{\n\t\t\t\tcase 'd':\n\t\t\t\t\ttop->construct_dict(start - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'l':\n\t\t\t\t\ttop->construct_list(start - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'i':\n\t\t\t\t{\n\t\t\t\t\tchar const* int_start = start;\n\t\t\t\t\tstart = find_char(start, end, 'e');\n\t\t\t\t\ttop->construct_int(int_start, start - int_start);\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tTORRENT_ASSERT(*start == 'e');\n\t\t\t\t\t++start;\n\t\t\t\t\tstack.pop_back();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif (!numeric(t))\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_value);\n\n\t\t\t\t\tboost::int64_t len = t - '0';\n\t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n\t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n\t\t\t\t\tif (start + len + 1 > end)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n\n\t\t\t\t\t++start;\n\t\t\t\t\ttop->construct_string(start, int(len));\n\t\t\t\t\tstack.pop_back();\n\t\t\t\t\tstart += len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn 0;\n\t}"", ""target"": 0}]","[{""func_name"": ""lazy_bdecode"", ""file_path"": ""lazy_bdecode.cpp"", ""func_code"": ""int lazy_bdecode(char const* start, char const* end, lazy_entry& ret\n\t\t, error_code& ec, int* error_pos, int depth_limit, int item_limit)\n\t{\n\t\tchar const* const orig_start = start;\n\t\tret.clear();\n\t\tif (start == end) return 0;\n\n\t\tstd::vector<lazy_entry*> stack;\n\n\t\tstack.push_back(&ret);\n\t\twhile (start <= end)\n\t\t{\n\t\t\tif (stack.empty()) break; // done!\n\n\t\t\tlazy_entry* top = stack.back();\n\n\t\t\tif (int(stack.size()) > depth_limit) TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);\n\t\t\tif (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\tchar t = *start;\n\t\t\t++start;\n\t\t\tif (start >= end && t != 'e') TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\n\t\t\tswitch (top->type())\n\t\t\t{\n\t\t\t\tcase lazy_entry::dict_t:\n\t\t\t\t{\n\t\t\t\t\tif (t == 'e')\n\t\t\t\t\t{\n\t\t\t\t\t\ttop->set_end(start);\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!numeric(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);\n\t\t\t\t\tboost::int64_t len = t - '0';\n\t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n\t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n\n\t\t\t\t\t// remaining buffer size excluding ':'\n\t\t\t\t\tconst ptrdiff_t buff_size = end - start - 1;\n\t\t\t\t\tif (len > buff_size)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n\n\t\t\t\t\t++start;\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tlazy_entry* ent = top->dict_append(start);\n\t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n\t\t\t\t\tstart += len;\n\t\t\t\t\tif (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tstack.push_back(ent);\n\t\t\t\t\tt = *start;\n\t\t\t\t\t++start;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase lazy_entry::list_t:\n\t\t\t\t{\n\t\t\t\t\tif (t == 'e')\n\t\t\t\t\t{\n\t\t\t\t\t\ttop->set_end(start);\n\t\t\t\t\t\tstack.pop_back();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlazy_entry* ent = top->list_append();\n\t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n\t\t\t\t\tstack.push_back(ent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault: break;\n\t\t\t}\n\n\t\t\t--item_limit;\n\t\t\tif (item_limit <= 0) TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);\n\n\t\t\ttop = stack.back();\n\t\t\tswitch (t)\n\t\t\t{\n\t\t\t\tcase 'd':\n\t\t\t\t\ttop->construct_dict(start - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'l':\n\t\t\t\t\ttop->construct_list(start - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'i':\n\t\t\t\t{\n\t\t\t\t\tchar const* int_start = start;\n\t\t\t\t\tstart = find_char(start, end, 'e');\n\t\t\t\t\ttop->construct_int(int_start, start - int_start);\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tTORRENT_ASSERT(*start == 'e');\n\t\t\t\t\t++start;\n\t\t\t\t\tstack.pop_back();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif (!numeric(t))\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_value);\n\n\t\t\t\t\tboost::int64_t len = t - '0';\n\t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n\t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n\n\t\t\t\t\t// remaining buffer size excluding ':'\n\t\t\t\t\tconst ptrdiff_t buff_size = end - start - 1;\n\t\t\t\t\tif (len > buff_size)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n\n\t\t\t\t\t++start;\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n\t\t\t\t\ttop->construct_string(start, int(len));\n\t\t\t\t\tstack.pop_back();\n\t\t\t\t\tstart += len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn 0;\n\t}""}]","{""function"": 2, ""value"": 2, ""code"": 1, ""caller"": 1}","[{""source"": ""func_info(file:lazy_bdecode.cpp, func:parse_int)"", ""result"": [{""code"": ""char const* parse_int(char const* start, char const* end, char delimiter\n\t\t, boost::int64_t& val, bdecode_errors::error_code_enum& ec)\n\t{\n\t\twhile (start < end && *start != delimiter)\n\t\t{\n\t\t\tif (!numer"", ""start_line"": 77, ""end_line"": 105, ""full_name"": ""libtorrent.parse_int:char*(char*,char*,char,boost.int64_t&,libtorrent.bdecode_errors.error_code_enum&)"", ""file_path"": ""lazy_bdecode.cpp""}]}, {""source"": ""value_info(file:lazy_bdecode.cpp, value:start)"", ""result"": {""value_trace"": [{""full_code"": ""++start"", ""line"": 100, ""func_name"": ""libtorrent.parse_int:char*(char*,char*,char,boost.int64_t&,libtorrent.bdecode_errors.error_code_enum&)""}, {""full_code"": ""++start"", ""line"": 109, ""func_name"": ""libtorrent.find_char:char*(char*,char*,char)""}, {""full_code"": ""++start"", ""line"": 133, ""func_name"": ""libtorrent.lazy_bdecode:int(char*,char*,libtorrent.lazy_entry&,error_code&,int*,int,int)""}, {""full_code"": ""start = parse_int(start, end, ':', len, e)"", ""line"": 149, ""func_name"": ""libtorrent.lazy_bdecode:int(char*,char*,libtorrent.lazy_entry&,error_code&,int*,int,int)""}, {""full_code"": ""++start"", ""line"": 159, ""func_name"": ""libtorrent.lazy_bdecode:int(char*,char*,libtorrent.lazy_entry&,error_code&,int*,int,int)""}], ""struct_var"": ""start"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:lazy_bdecode.cpp, value:end)"", ""result"": {""value_trace"": [{""full_code"": ""send_size = boost.asio.socket_base.send_buffer_size(512 * 1024)"", ""line"": 1094, ""func_name"": ""main:int(int,char[]*)""}], ""struct_var"": ""end"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:lazy_bdecode.cpp, func:lazy_bdecode)"", ""result"": [{""code"": ""int lazy_bdecode(char const* start, char const* end, lazy_entry& ret\n\t\t, error_code& ec, int* error_pos, int depth_limit, int item_limit)\n\t{\n\t\tchar const* const orig_start = start;\n\t\tret.clear();\n\t\tif"", ""start_line"": 114, ""end_line"": 234, ""full_name"": ""libtorrent.lazy_bdecode:int(char*,char*,libtorrent.lazy_entry&,error_code&,int*,int,int)"", ""file_path"": ""lazy_bdecode.cpp""}]}, {""source"": ""code_info(file:lazy_bdecode.cpp, lines:77-105)"", ""result"": ""\tchar const* parse_int(char const* start, char const* end, char delimiter\n\t\t, boost::int64_t& val, bdecode_errors::error_code_enum& ec)\n\t{\n\t\twhile (start < end && *start != delimiter)\n\t\t{\n\t\t\tif (!numeric(*start))\n\t\t\t{\n\t\t\t\tec = bdecode_errors::expected_string;\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tif (val > INT64_MAX / 10)\n\t\t\t{\n\t\t\t\tec = bdecode_errors::overflow;\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tval *= 10;\n\t\t\tint digit = *start - '0';\n\t\t\tif (val > INT64_MAX - digit)\n\t\t\t{\n\t\t\t\tec = bdecode_errors::overflow;\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tval += digit;\n\t\t\t++start;\n\t\t}\n\t\tif (*start != delimiter)\n\t\t\tec = bdecode_errors::expected_colon;\n\t\treturn start;\n\t}\n\n""}, {""source"": ""caller_info(file:lazy_bdecode.cpp, func:lazy_bdecode)"", ""result"": [{""call_line"": 717, ""call_code"": ""lazy_bdecode(packet, &packet[len], e, ec, nullptr, 5, 100)"", ""caller_code"": ""void router_thread(int threadid, udp::socket& sock)\n{\n\tprintf(\""starting thread %d\\n\"", threadid);\n\n\tping_queue_t ping_queue;\n\tnode_buffer_t node_buffer;\n\n\t// always keep the last 16 nodes that have talked to us.\n\t// these are used as backups when we don't have enough nodes\n\t// in the node buffer\n\tboost::circular_buffer<node_entry_t> last_nodes(nodes_in_response);\n\n\tstd::random_device r;\n\tstd::mt19937 rand(r());\n\tstd::uniform_int_distribution<uint8_t> random_byte(0, 0xff);\n\n\t// the incoming packet\n\tchar packet[1500];\n\n\t// the response packet\n\tchar response[1500];\n\n\tfor (;;)\n\t{\n\t\tudp::endpoint ep;\n\t\terror_code ec;\n\n#ifdef DEBUG_STATS\n\t\tnodebuf_size[threadid] = node_buffer.size();\n#endif\n\n\t\t// rotate the secrets every 10 minutes\n\t\tsteady_clock::time_point now = steady_clock::now();\n\t\tif (last_secret_rotate + minutes(10) < now)\n\t\t{\n\t\t\tstd::lock_guard<std::mutex> l(secret_mutex);\n\t\t\tif (last_secret_rotate + minutes(10) < now)\n\t\t\t{\n\t\t\t\tlast_secret_rotate = now;\n\n\t\t\t\trand.seed(r());\n\t\t\t\t// ..."", ""caller_start"": 576, ""file_path"": ""main.cpp""}]}]","The vulnerability arises from an out-of-bounds buffer access in 'lazy_bdecode.cpp' (153-155, 219-221) when parsing Bencoded strings. The 'len' value, parsed via 'parse_int' (77-105), is used to advance the buffer pointer 'start' without ensuring that 'len' does not exceed the remaining buffer size (`buff_size = end - start - 1`). The original check (`start + len + 1 > end`) failed to account for integer overflow or incorrect buffer arithmetic, allowing malicious packets to trigger invalid memory access. The patch explicitly validates 'len' against 'buff_size' to prevent this. 'start' and 'end' are initialized from the incoming DHT packet buffer in 'main.cpp:717' (`packet` and `&packet[len]`), completing the trigger chain.",0.95,./github/other_context/CVE-2015-5685
69,CVE-2015-6243,CWE-20,c_cpp,"The dissector-table implementation in epan/packet.c in Wireshark 1.12.x before 1.12.7 mishandles table searches for empty strings, which allows remote attackers to cause a denial of service (application crash) via a crafted packet, related to the (1) dissector_get_string_handle and (2) dissector_get_default_string_handle functions.",https://github.com/wireshark/wireshark/commit/eb1ccbdccde89701f255f921d88992878057477d,Protect dissector_get_(default_)string_handle() against NULL input string\n\nBug: 11381\nChange-Id: Ib102a23b3d840144757ce692312ff13009c5c95e\nReviewed-on: https://code.wireshark.org/review/9717\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>,2,"[{""func_name"": ""dissector_get_default_string_handle"", ""file_path"": ""epan/packet.c"", ""func_code"": ""dissector_handle_t\ndissector_get_default_string_handle(const char *name, const gchar *string)\n{\n\tdissector_table_t sub_dissectors = find_dissector_table(name);\n\n\tif (sub_dissectors != NULL) {\n\t\tdtbl_entry_t *dtbl_entry = find_string_dtbl_entry(sub_dissectors, string);\n\t\tif (dtbl_entry != NULL)\n\t\t\treturn dtbl_entry->initial;\n\t}\n\treturn NULL;\n}"", ""target"": 0}, {""func_name"": ""dissector_get_string_handle"", ""file_path"": ""epan/packet.c"", ""func_code"": ""dissector_handle_t\ndissector_get_string_handle(dissector_table_t sub_dissectors,\n\t\t\t    const gchar *string)\n{\n\tdtbl_entry_t *dtbl_entry;\n\n\tdtbl_entry = find_string_dtbl_entry(sub_dissectors, string);\n\tif (dtbl_entry != NULL)\n\t\treturn dtbl_entry->current;\n\telse\n\t\treturn NULL;\n}"", ""target"": 0}]","[{""func_name"": ""dissector_get_default_string_handle"", ""file_path"": ""epan/packet.c"", ""func_code"": ""dissector_handle_t\ndissector_get_default_string_handle(const char *name, const gchar *string)\n{\n\tdissector_table_t sub_dissectors;\n\n\tif (!string) return 0;\n\tsub_dissectors = find_dissector_table(name);\n\tif (sub_dissectors != NULL) {\n\t\tdtbl_entry_t *dtbl_entry = find_string_dtbl_entry(sub_dissectors, string);\n\t\tif (dtbl_entry != NULL)\n\t\t\treturn dtbl_entry->initial;\n\t}\n\treturn NULL;\n}""}, {""func_name"": ""dissector_get_string_handle"", ""file_path"": ""epan/packet.c"", ""func_code"": ""dissector_handle_t\ndissector_get_string_handle(dissector_table_t sub_dissectors,\n\t\t\t    const gchar *string)\n{\n\tdtbl_entry_t *dtbl_entry;\n\n\tif (!string) return 0;\n\tdtbl_entry = find_string_dtbl_entry(sub_dissectors, string);\n\tif (dtbl_entry != NULL)\n\t\treturn dtbl_entry->current;\n\telse\n\t\treturn NULL;\n}""}]","{""function"": 1}","[{""source"": ""func_info(file:packet.c, func:find_string_dtbl_entry)"", ""result"": [{""code"": ""static dtbl_entry_t *\nfind_string_dtbl_entry(dissector_table_t const sub_dissectors, const gchar *pattern)\n{\n\tdtbl_entry_t *ret;\n\tchar *key;\n\n\tswitch (sub_dissectors->type) {\n\n\tcase FT_STRING:\n\tcase FT_STRINGZ:\n\tcase FT_STRINGZPAD:\n\t\t/*\n\t\t * You can do a string lookup in these tables.\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * But you can't do a string lookup in any other types\n\t\t * of tables.\n\t\t */\n\t\tg_assert_not_reached();\n\t}\n\n\tif (sub_dissectors->param == TRUE) {\n\t\tkey = g_ascii_strdown(pattern, -1);\n\t} else {\n\t\tkey = g_strdup(pattern);\n\t}\n\n\t/*\n\t * Find the entry.\n\t */\n\tret = (dtbl_entry_t *)g_hash_table_lookup(sub_dissectors->hash_table, key);\n\n\tg_free(key);\n\n\treturn ret;\n}"", ""start_line"": 1195, ""end_line"": 1233, ""full_name"": ""find_string_dtbl_entry"", ""file_path"": ""epan/packet.c""}]}]","The functions dissector_get_string_handle (epan/packet.c:1460) and dissector_get_default_string_handle (epan/packet.c:1470) passed unvalidated 'string' parameters to find_string_dtbl_entry (epan/packet.c:1195-1233). If 'string' was NULL, find_string_dtbl_entry would call g_ascii_strdown/g_strdup with NULL, causing a NULL dereference. The patch added 'if (!string) return 0;' checks to block invalid inputs.",0.95,./github/other_context/CVE-2015-6243
70,CVE-2015-6244,CWE-20,c_cpp,"The dissect_zbee_secure function in epan/dissectors/packet-zbee-security.c in the ZigBee dissector in Wireshark 1.12.x before 1.12.7 improperly relies on length fields contained in packet data, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",https://github.com/wireshark/wireshark/commit/655b0dc623e29da212be3e205314624fe3182562,"use the captured length as payload length for zigbee decryption\n\nthis length is used for allocating a buffer and for crypto calculations\nwe should use the bytes that were actually captured, not the reported\nlength\n\nthe capture in https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=11389\nhas one packet with a stupidly large reported length and a reasonable\ncapture length (and one completely bogus packet) - this fix ensures that\nthe decryption does not break for the former packet\n\nalso, tvb_reported_length_remaining() does not return values < 0 any\nmore, remove the check for this\n\nBug: 11389\nChange-Id: I42cb4526483160416b51e3cb72442148b5fac4f3\nReviewed-on: https://code.wireshark.org/review/9950\nReviewed-by: Anders Broman <a.broman58@gmail.com>",4,"[{""func_name"": ""dissect_zbee_secure"", ""file_path"": ""epan/dissectors/packet-zbee-security.c"", ""func_code"": ""tvbuff_t *\ndissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint offset)\n{\n    proto_tree     *sec_tree;\n\n    zbee_security_packet    packet;\n    guint           mic_len;\n    gint            payload_len;\n    tvbuff_t       *payload_tvb;\n\n#ifdef HAVE_LIBGCRYPT\n    proto_item         *ti;\n    proto_item         *key_item;\n    guint8             *enc_buffer;\n    guint8             *dec_buffer;\n    gboolean            decrypted;\n    GSList            **nwk_keyring;\n    GSList             *GSList_i;\n    key_record_t       *key_rec = NULL;\n#endif\n    zbee_nwk_hints_t   *nwk_hints;\n    ieee802154_hints_t *ieee_hints;\n    ieee802154_map_rec *map_rec = NULL;\n\n    static const int * sec_flags[] = {\n        &hf_zbee_sec_key_id,\n        &hf_zbee_sec_nonce,\n        NULL\n    };\n\n    /* Init */\n    memset(&packet, 0, sizeof(zbee_security_packet));\n\n    /* Get pointers to any useful frame data from lower layers */\n    nwk_hints = (zbee_nwk_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(ZBEE_PROTOABBREV_NWK), 0);\n    ieee_hints = (ieee802154_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(IEEE802154_PROTOABBREV_WPAN), 0);\n\n    /* Create a subtree for the security information. */\n    sec_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_zbee_sec, NULL, \""ZigBee Security Header\"");\n\n    /*  Get and display the Security control field */\n    packet.control  = tvb_get_guint8(tvb, offset);\n\n    /* Patch the security level. */\n    packet.control &= ~ZBEE_SEC_CONTROL_LEVEL;\n    packet.control |= (ZBEE_SEC_CONTROL_LEVEL & gPREF_zbee_sec_level);\n\n    /*\n     * Eww, I think I just threw up a little...  ZigBee requires this field\n     * to be patched before computing the MIC, but we don't have write-access\n     * to the tvbuff. So we need to allocate a copy of the whole thing just\n     * so we can fix these 3 bits. Memory allocated by tvb_memdup(wmem_packet_scope(),...)\n     * is automatically freed before the next packet is processed.\n     */\n#ifdef HAVE_LIBGCRYPT\n    enc_buffer = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, 0, tvb_captured_length(tvb));\n    /*\n     * Override the const qualifiers and patch the security level field, we\n     * know it is safe to overide the const qualifiers because we just\n     * allocated this memory via tvb_memdup(wmem_packet_scope(),...).\n     */\n    enc_buffer[offset] = packet.control;\n#endif /* HAVE_LIBGCRYPT */\n    packet.level    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_LEVEL);\n    packet.key_id   = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_KEY);\n    packet.nonce    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_NONCE);\n\n    proto_tree_add_bitmask(sec_tree, tvb, offset, hf_zbee_sec_field, ett_zbee_sec_control, sec_flags, ENC_NA);\n    offset += 1;\n\n    /* Get and display the frame counter field. */\n    packet.counter = tvb_get_letohl(tvb, offset);\n    if (tree) {\n        proto_tree_add_uint(sec_tree, hf_zbee_sec_counter, tvb, offset, 4, packet.counter);\n    }\n    offset += 4;\n\n    if (packet.nonce) {\n        /* Get and display the source address of the device that secured this payload. */\n        packet.src64 = tvb_get_letoh64(tvb, offset);\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_src64, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n        }\n#if 1\n        if (!pinfo->fd->flags.visited) {\n            switch ( packet.key_id ) {\n                case ZBEE_SEC_KEY_LINK:\n                if (nwk_hints && ieee_hints) {\n                    /* Map this long address with the nwk layer short address. */\n                    nwk_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, nwk_hints->src,\n                            ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                case ZBEE_SEC_KEY_NWK:\n                if (ieee_hints) {\n                    /* Map this long address with the ieee short address. */\n                    ieee_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, ieee_hints->src16,\n                        ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                /* We ignore the extended source addresses used to encrypt payloads with these\n                 * types of keys, because they can emerge from APS tunnels created by nodes whose\n                 * short address is not recorded in the packet. */\n                case ZBEE_SEC_KEY_TRANSPORT:\n                case ZBEE_SEC_KEY_LOAD:\n                break;\n            }\n        }\n#endif\n        offset += 8;\n    }\n    else {\n        /* Look for a source address in hints */\n        switch ( packet.key_id ) {\n            case ZBEE_SEC_KEY_NWK:\n                /* use the ieee extended source address for NWK decryption */\n                if ( ieee_hints && (map_rec = ieee_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n\n            default:\n                /* use the nwk extended source address for APS decryption */\n                if ( nwk_hints && (map_rec = nwk_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n        }\n    }\n\n    if (packet.key_id == ZBEE_SEC_KEY_NWK) {\n        /* Get and display the key sequence number. */\n        packet.key_seqno = tvb_get_guint8(tvb, offset);\n        if (tree) {\n            proto_tree_add_uint(sec_tree, hf_zbee_sec_key_seqno, tvb, offset, 1, packet.key_seqno);\n        }\n        offset += 1;\n    }\n\n    /* Determine the length of the MIC. */\n    switch (packet.level) {\n        case ZBEE_SEC_ENC:\n        case ZBEE_SEC_NONE:\n        default:\n            mic_len=0;\n            break;\n\n        case ZBEE_SEC_ENC_MIC32:\n        case ZBEE_SEC_MIC32:\n            mic_len=4;\n            break;\n\n        case ZBEE_SEC_ENC_MIC64:\n        case ZBEE_SEC_MIC64:\n            mic_len=8;\n            break;\n\n        case ZBEE_SEC_ENC_MIC128:\n        case ZBEE_SEC_MIC128:\n            mic_len=16;\n            break;\n    } /* switch */\n\n    /* Get and display the MIC. */\n    if (mic_len) {\n        /* Display the MIC. */\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_mic, tvb, (gint)(tvb_captured_length(tvb)-mic_len),\n                   mic_len, ENC_NA);\n        }\n    }\n\n    /* Check for null payload. */\n    if ( !(payload_len = tvb_reported_length_remaining(tvb, offset+mic_len)) ) {\n        return NULL;\n    } else if ( payload_len < 0 ) {\n        THROW(ReportedBoundsError);\n    }\n\n    /**********************************************\n     *  Perform Security Operations on the Frame  *\n     **********************************************\n     */\n    if ((packet.level == ZBEE_SEC_NONE) ||\n        (packet.level == ZBEE_SEC_MIC32) ||\n        (packet.level == ZBEE_SEC_MIC64) ||\n        (packet.level == ZBEE_SEC_MIC128)) {\n\n        /* Payload is only integrity protected. Just return the sub-tvbuff. */\n        return tvb_new_subset_length(tvb, offset, payload_len);\n    }\n\n#ifdef HAVE_LIBGCRYPT\n    /* Allocate memory to decrypt the payload into. */\n    dec_buffer = (guint8 *)g_malloc(payload_len);\n\n    decrypted = FALSE;\n    if ( packet.src64 ) {\n        if (pinfo->fd->flags.visited) {\n            if ( nwk_hints ) {\n                /* Use previously found key */\n                switch ( packet.key_id ) {\n                    case ZBEE_SEC_KEY_NWK:\n                        if ( (key_rec = nwk_hints->nwk) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, nwk_hints->nwk->key);\n                        }\n                        break;\n\n                    default:\n                        if ( (key_rec = nwk_hints->link) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, nwk_hints->link->key);\n                        }\n                        break;\n                }\n            }\n        } /* ( !pinfo->fd->flags.visited ) */\n        else {\n            /* We only search for sniffed keys in the first pass,\n             * to save time, and because decrypting with keys\n             * transported in future packets is cheating */\n\n            /* Lookup NWK and link key in hash for this pan. */\n            /* This overkill approach is a placeholder for a hash that looks up\n             * a key ring for a link key associated with a pair of devices.\n             */\n            if ( nwk_hints ) {\n                nwk_keyring = (GSList **)g_hash_table_lookup(zbee_table_nwk_keyring, &nwk_hints->src_pan);\n\n                if ( nwk_keyring ) {\n                    GSList_i = *nwk_keyring;\n                    while ( GSList_i && !decrypted ) {\n                        decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                        if (decrypted) {\n                            /* save pointer to the successful key record */\n                            switch (packet.key_id) {\n                                case ZBEE_SEC_KEY_NWK:\n                                    key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                    break;\n\n                                default:\n                                    key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                    break;\n                            }\n                        } else {\n                            GSList_i = g_slist_next(GSList_i);\n                        }\n                    }\n                }\n\n                /* Loop through user's password table for preconfigured keys, our last resort */\n                GSList_i = zbee_pc_keyring;\n                while ( GSList_i && !decrypted ) {\n                    decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                            payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                    if (decrypted) {\n                        /* save pointer to the successful key record */\n                        switch (packet.key_id) {\n                            case ZBEE_SEC_KEY_NWK:\n                                key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                break;\n\n                            default:\n                                key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                break;\n                        }\n                    } else {\n                        GSList_i = g_slist_next(GSList_i);\n                    }\n                }\n            }\n        } /* ( ! pinfo->fd->flags.visited ) */\n    } /* ( packet.src64 ) */\n\n    if ( decrypted ) {\n        if ( tree && key_rec ) {\n            key_item = proto_tree_add_bytes(sec_tree, hf_zbee_sec_key, tvb, 0, ZBEE_SEC_CONST_KEYSIZE, key_rec->key);\n            PROTO_ITEM_SET_GENERATED(key_item);\n\n            if ( key_rec->frame_num == ZBEE_SEC_PC_KEY ) {\n                ti = proto_tree_add_string(sec_tree, hf_zbee_sec_decryption_key, tvb, 0, 0, key_rec->label);\n            } else {\n                ti = proto_tree_add_uint(sec_tree, hf_zbee_sec_key_origin, tvb, 0, 0,\n                        key_rec->frame_num);\n            }\n            PROTO_ITEM_SET_GENERATED(ti);\n        }\n\n        /* Found a key that worked, setup the new tvbuff_t and return */\n        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_len, payload_len);\n        tvb_set_free_cb(payload_tvb, g_free); /* set up callback to free dec_buffer */\n        add_new_data_source(pinfo, payload_tvb, \""Decrypted ZigBee Payload\"");\n\n        /* Done! */\n        return payload_tvb;\n    }\n\n    g_free(dec_buffer);\n#endif /* HAVE_LIBGCRYPT */\n\n    /* Add expert info. */\n    expert_add_info(pinfo, sec_tree, &ei_zbee_sec_encrypted_payload);\n    /* Create a buffer for the undecrypted payload. */\n    payload_tvb = tvb_new_subset(tvb, offset, payload_len, -1);\n    /* Dump the payload to the data dissector. */\n    call_dissector(data_handle, payload_tvb, pinfo, tree);\n    /* Couldn't decrypt, so return NULL. */\n    return NULL;\n}"", ""target"": 0}, {""func_name"": ""zbee_security_register"", ""file_path"": ""epan/dissectors/packet-zbee-security.c"", ""func_code"": ""void zbee_security_register(module_t *zbee_prefs, int proto)\n{\n    static hf_register_info hf[] = {\n        { &hf_zbee_sec_field,\n          { \""Security Control Field\"",   \""zbee.sec.field\"", FT_UINT8, BASE_HEX, NULL,\n            0x0, NULL, HFILL }},\n\n        { &hf_zbee_sec_key_id,\n          { \""Key Id\"",                    \""zbee.sec.key\"", FT_UINT8, BASE_HEX, VALS(zbee_sec_key_names),\n            ZBEE_SEC_CONTROL_KEY, NULL, HFILL }},\n\n        { &hf_zbee_sec_nonce,\n          { \""Extended Nonce\"",         \""zbee.sec.ext_nonce\"", FT_BOOLEAN, 8, NULL, ZBEE_SEC_CONTROL_NONCE,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_counter,\n          { \""Frame Counter\"",          \""zbee.sec.counter\"", FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_src64,\n          { \""Extended Source\"",                 \""zbee.sec.src64\"", FT_EUI64, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_key_seqno,\n          { \""Key Sequence Number\"",    \""zbee.sec.key_seqno\"", FT_UINT8, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_mic,\n          { \""Message Integrity Code\"", \""zbee.sec.mic\"", FT_BYTES, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_key,\n          { \""Key\"", \""zbee.sec.key\"", FT_BYTES, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_key_origin,\n          { \""Key Origin\"", \""zbee.sec.key.origin\"", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_decryption_key,\n          { \""Key Label\"", \""zbee.sec.decryption_key\"", FT_STRING, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }}\n    };\n\n    static gint *ett[] = {\n        &ett_zbee_sec,\n        &ett_zbee_sec_control\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_zbee_sec_encrypted_payload, { \""zbee_sec.encrypted_payload\"", PI_UNDECODED, PI_WARN, \""Encrypted Payload\"", EXPFILL }},\n        { &ei_zbee_sec_extended_source_unknown, { \""zbee_sec.extended_source_unknown\"", PI_PROTOCOL, PI_NOTE, \""Extended Source: Unknown\"", EXPFILL }},\n    };\n\n    expert_module_t* expert_zbee_sec;\n\n    static uat_field_t key_uat_fields[] = {\n        UAT_FLD_CSTRING(uat_key_records, string, \""Key\"",\n                        \""A 16-byte key in hexadecimal with optional dash-,\\n\""\n                        \""colon-, or space-separator characters, or a\\n\""\n                        \""a 16-character string in double-quotes.\""),\n        UAT_FLD_VS(uat_key_records, byte_order, \""Byte Order\"", byte_order_vals,\n                        \""Byte order of key.\""),\n        UAT_FLD_CSTRING(uat_key_records, label, \""Label\"", \""User label for key.\""),\n        UAT_END_FIELDS\n    };\n\n    /* If no prefs module was supplied, register our own. */\n    if (zbee_prefs == NULL) {\n        zbee_prefs = prefs_register_protocol(proto, NULL);\n    }\n\n    /*  Register preferences */\n    prefs_register_enum_preference(zbee_prefs, \""seclevel\"", \""Security Level\"",\n                 \""Specifies the security level to use in the\\n\""\n                 \""decryption process. This value is ignored\\n\""\n                 \""for ZigBee 2004 and unsecured networks.\"",\n                 &gPREF_zbee_sec_level, zbee_sec_level_enums, FALSE);\n\n    zbee_sec_key_table_uat = uat_new(\""Pre-configured Keys\"",\n                               sizeof(uat_key_record_t),\n                               \""zigbee_pc_keys\"",\n                               TRUE,\n                               &uat_key_records,\n                               &num_uat_key_records,\n                               UAT_AFFECTS_DISSECTION, /* affects dissection of packets, but not set of named fields */\n                               NULL,  /* TODO: ptr to help manual? */\n                               uat_key_record_copy_cb,\n                               uat_key_record_update_cb,\n                               uat_key_record_free_cb,\n                               uat_key_record_post_update,\n                               key_uat_fields );\n\n    prefs_register_uat_preference(zbee_prefs,\n                                  \""key_table\"",\n                                  \""Pre-configured Keys\"",\n                                  \""Pre-configured link or network keys.\"",\n                                  zbee_sec_key_table_uat);\n\n    proto_register_field_array(proto, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n    expert_zbee_sec = expert_register_protocol(proto);\n    expert_register_field_array(expert_zbee_sec, ei, array_length(ei));\n\n}"", ""target"": 1}, {""func_name"": ""dissect_zbee_secure"", ""file_path"": ""epan/dissectors/packet-zbee-security.c"", ""func_code"": ""tvbuff_t *\ndissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint offset)\n{\n    proto_tree     *sec_tree;\n\n    zbee_security_packet    packet;\n    guint           mic_len;\n    gint            payload_reported_len;\n    tvbuff_t       *payload_tvb;\n\n#ifdef HAVE_LIBGCRYPT\n    gint               payload_captured_len;\n    proto_item         *ti;\n    proto_item         *key_item;\n    guint8             *enc_buffer;\n    guint8             *dec_buffer;\n    gboolean            decrypted;\n    GSList            **nwk_keyring;\n    GSList             *GSList_i;\n    key_record_t       *key_rec = NULL;\n#endif\n    zbee_nwk_hints_t   *nwk_hints;\n    ieee802154_hints_t *ieee_hints;\n    ieee802154_map_rec *map_rec = NULL;\n\n    static const int * sec_flags[] = {\n        &hf_zbee_sec_key_id,\n        &hf_zbee_sec_nonce,\n        NULL\n    };\n\n    /* Init */\n    memset(&packet, 0, sizeof(zbee_security_packet));\n\n    /* Get pointers to any useful frame data from lower layers */\n    nwk_hints = (zbee_nwk_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(ZBEE_PROTOABBREV_NWK), 0);\n    ieee_hints = (ieee802154_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(IEEE802154_PROTOABBREV_WPAN), 0);\n\n    /* Create a subtree for the security information. */\n    sec_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_zbee_sec, NULL, \""ZigBee Security Header\"");\n\n    /*  Get and display the Security control field */\n    packet.control  = tvb_get_guint8(tvb, offset);\n\n    /* Patch the security level. */\n    packet.control &= ~ZBEE_SEC_CONTROL_LEVEL;\n    packet.control |= (ZBEE_SEC_CONTROL_LEVEL & gPREF_zbee_sec_level);\n\n    /*\n     * Eww, I think I just threw up a little...  ZigBee requires this field\n     * to be patched before computing the MIC, but we don't have write-access\n     * to the tvbuff. So we need to allocate a copy of the whole thing just\n     * so we can fix these 3 bits. Memory allocated by tvb_memdup(wmem_packet_scope(),...)\n     * is automatically freed before the next packet is processed.\n     */\n#ifdef HAVE_LIBGCRYPT\n    enc_buffer = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, 0, tvb_captured_length(tvb));\n    /*\n     * Override the const qualifiers and patch the security level field, we\n     * know it is safe to overide the const qualifiers because we just\n     * allocated this memory via tvb_memdup(wmem_packet_scope(),...).\n     */\n    enc_buffer[offset] = packet.control;\n#endif /* HAVE_LIBGCRYPT */\n    packet.level    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_LEVEL);\n    packet.key_id   = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_KEY);\n    packet.nonce    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_NONCE);\n\n    proto_tree_add_bitmask(sec_tree, tvb, offset, hf_zbee_sec_field, ett_zbee_sec_control, sec_flags, ENC_NA);\n    offset += 1;\n\n    /* Get and display the frame counter field. */\n    packet.counter = tvb_get_letohl(tvb, offset);\n    if (tree) {\n        proto_tree_add_uint(sec_tree, hf_zbee_sec_counter, tvb, offset, 4, packet.counter);\n    }\n    offset += 4;\n\n    if (packet.nonce) {\n        /* Get and display the source address of the device that secured this payload. */\n        packet.src64 = tvb_get_letoh64(tvb, offset);\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_src64, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n        }\n#if 1\n        if (!pinfo->fd->flags.visited) {\n            switch ( packet.key_id ) {\n                case ZBEE_SEC_KEY_LINK:\n                if (nwk_hints && ieee_hints) {\n                    /* Map this long address with the nwk layer short address. */\n                    nwk_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, nwk_hints->src,\n                            ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                case ZBEE_SEC_KEY_NWK:\n                if (ieee_hints) {\n                    /* Map this long address with the ieee short address. */\n                    ieee_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, ieee_hints->src16,\n                        ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                /* We ignore the extended source addresses used to encrypt payloads with these\n                 * types of keys, because they can emerge from APS tunnels created by nodes whose\n                 * short address is not recorded in the packet. */\n                case ZBEE_SEC_KEY_TRANSPORT:\n                case ZBEE_SEC_KEY_LOAD:\n                break;\n            }\n        }\n#endif\n        offset += 8;\n    }\n    else {\n        /* Look for a source address in hints */\n        switch ( packet.key_id ) {\n            case ZBEE_SEC_KEY_NWK:\n                /* use the ieee extended source address for NWK decryption */\n                if ( ieee_hints && (map_rec = ieee_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n\n            default:\n                /* use the nwk extended source address for APS decryption */\n                if ( nwk_hints && (map_rec = nwk_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n        }\n    }\n\n    if (packet.key_id == ZBEE_SEC_KEY_NWK) {\n        /* Get and display the key sequence number. */\n        packet.key_seqno = tvb_get_guint8(tvb, offset);\n        if (tree) {\n            proto_tree_add_uint(sec_tree, hf_zbee_sec_key_seqno, tvb, offset, 1, packet.key_seqno);\n        }\n        offset += 1;\n    }\n\n    /* Determine the length of the MIC. */\n    switch (packet.level) {\n        case ZBEE_SEC_ENC:\n        case ZBEE_SEC_NONE:\n        default:\n            mic_len=0;\n            break;\n\n        case ZBEE_SEC_ENC_MIC32:\n        case ZBEE_SEC_MIC32:\n            mic_len=4;\n            break;\n\n        case ZBEE_SEC_ENC_MIC64:\n        case ZBEE_SEC_MIC64:\n            mic_len=8;\n            break;\n\n        case ZBEE_SEC_ENC_MIC128:\n        case ZBEE_SEC_MIC128:\n            mic_len=16;\n            break;\n    } /* switch */\n\n    /* Get and display the MIC. */\n    if (mic_len) {\n        /* Display the MIC. */\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_mic, tvb, (gint)(tvb_captured_length(tvb)-mic_len),\n                   mic_len, ENC_NA);\n        }\n    }\n\n    /* Check for null payload. */\n    payload_reported_len = tvb_reported_length_remaining(tvb, offset+mic_len);\n    if (payload_reported_len == 0)\n        return NULL;\n\n    /**********************************************\n     *  Perform Security Operations on the Frame  *\n     **********************************************\n     */\n    if ((packet.level == ZBEE_SEC_NONE) ||\n        (packet.level == ZBEE_SEC_MIC32) ||\n        (packet.level == ZBEE_SEC_MIC64) ||\n        (packet.level == ZBEE_SEC_MIC128)) {\n\n        /* Payload is only integrity protected. Just return the sub-tvbuff. */\n        return tvb_new_subset_length(tvb, offset, payload_reported_len);\n    }\n\n#ifdef HAVE_LIBGCRYPT\n    /* How much payload was actually captured? */\n    payload_captured_len = tvb_captured_length_remaining(tvb, offset+mic_len);\n\n    /* Allocate memory to decrypt the payload into. */\n    dec_buffer = (guint8 *)g_malloc(payload_captured_len);\n\n    decrypted = FALSE;\n    if ( packet.src64 ) {\n        if (pinfo->fd->flags.visited) {\n            if ( nwk_hints ) {\n                /* Use previously found key */\n                switch ( packet.key_id ) {\n                    case ZBEE_SEC_KEY_NWK:\n                        if ( (key_rec = nwk_hints->nwk) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_captured_len, mic_len, nwk_hints->nwk->key);\n                        }\n                        break;\n\n                    default:\n                        if ( (key_rec = nwk_hints->link) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_captured_len, mic_len, nwk_hints->link->key);\n                        }\n                        break;\n                }\n            }\n        } /* ( !pinfo->fd->flags.visited ) */\n        else {\n            /* We only search for sniffed keys in the first pass,\n             * to save time, and because decrypting with keys\n             * transported in future packets is cheating */\n\n            /* Lookup NWK and link key in hash for this pan. */\n            /* This overkill approach is a placeholder for a hash that looks up\n             * a key ring for a link key associated with a pair of devices.\n             */\n            if ( nwk_hints ) {\n                nwk_keyring = (GSList **)g_hash_table_lookup(zbee_table_nwk_keyring, &nwk_hints->src_pan);\n\n                if ( nwk_keyring ) {\n                    GSList_i = *nwk_keyring;\n                    while ( GSList_i && !decrypted ) {\n                        decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                        if (decrypted) {\n                            /* save pointer to the successful key record */\n                            switch (packet.key_id) {\n                                case ZBEE_SEC_KEY_NWK:\n                                    key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                    break;\n\n                                default:\n                                    key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                    break;\n                            }\n                        } else {\n                            GSList_i = g_slist_next(GSList_i);\n                        }\n                    }\n                }\n\n                /* Loop through user's password table for preconfigured keys, our last resort */\n                GSList_i = zbee_pc_keyring;\n                while ( GSList_i && !decrypted ) {\n                    decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                            payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                    if (decrypted) {\n                        /* save pointer to the successful key record */\n                        switch (packet.key_id) {\n                            case ZBEE_SEC_KEY_NWK:\n                                key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                break;\n\n                            default:\n                                key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                break;\n                        }\n                    } else {\n                        GSList_i = g_slist_next(GSList_i);\n                    }\n                }\n            }\n        } /* ( ! pinfo->fd->flags.visited ) */\n    } /* ( packet.src64 ) */\n\n    if ( decrypted ) {\n        if ( tree && key_rec ) {\n            key_item = proto_tree_add_bytes(sec_tree, hf_zbee_sec_key, tvb, 0, ZBEE_SEC_CONST_KEYSIZE, key_rec->key);\n            PROTO_ITEM_SET_GENERATED(key_item);\n\n            if ( key_rec->frame_num == ZBEE_SEC_PC_KEY ) {\n                ti = proto_tree_add_string(sec_tree, hf_zbee_sec_decryption_key, tvb, 0, 0, key_rec->label);\n            } else {\n                ti = proto_tree_add_uint(sec_tree, hf_zbee_sec_key_origin, tvb, 0, 0,\n                        key_rec->frame_num);\n            }\n            PROTO_ITEM_SET_GENERATED(ti);\n        }\n\n        /* Found a key that worked, setup the new tvbuff_t and return */\n        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_captured_len, payload_reported_len);\n        tvb_set_free_cb(payload_tvb, g_free); /* set up callback to free dec_buffer */\n        add_new_data_source(pinfo, payload_tvb, \""Decrypted ZigBee Payload\"");\n\n        /* Done! */\n        return payload_tvb;\n    }\n\n    g_free(dec_buffer);\n#endif /* HAVE_LIBGCRYPT */\n\n    /* Add expert info. */\n    expert_add_info(pinfo, sec_tree, &ei_zbee_sec_encrypted_payload);\n    /* Create a buffer for the undecrypted payload. */\n    payload_tvb = tvb_new_subset_length(tvb, offset, payload_reported_len);\n    /* Dump the payload to the data dissector. */\n    call_dissector(data_handle, payload_tvb, pinfo, tree);\n    /* Couldn't decrypt, so return NULL. */\n    return NULL;\n}"", ""target"": 1}, {""func_name"": ""dissect_zbee_secure"", ""file_path"": ""epan/dissectors/packet-zbee-security.c"", ""func_code"": ""tvbuff_t *\ndissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint offset)\n{\n    proto_tree     *sec_tree;\n\n    zbee_security_packet    packet;\n    guint           mic_len;\n    gint            payload_len;\n    tvbuff_t       *payload_tvb;\n\n#ifdef HAVE_LIBGCRYPT\n    proto_item         *ti;\n    proto_item         *key_item;\n    guint8             *enc_buffer;\n    guint8             *dec_buffer;\n    gboolean            decrypted;\n    GSList            **nwk_keyring;\n    GSList             *GSList_i;\n    key_record_t       *key_rec = NULL;\n#endif\n    zbee_nwk_hints_t   *nwk_hints;\n    ieee802154_hints_t *ieee_hints;\n    ieee802154_map_rec *map_rec = NULL;\n\n    static const int * sec_flags[] = {\n        &hf_zbee_sec_key_id,\n        &hf_zbee_sec_nonce,\n        NULL\n    };\n\n    /* Init */\n    memset(&packet, 0, sizeof(zbee_security_packet));\n\n    /* Get pointers to any useful frame data from lower layers */\n    nwk_hints = (zbee_nwk_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(ZBEE_PROTOABBREV_NWK), 0);\n    ieee_hints = (ieee802154_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(IEEE802154_PROTOABBREV_WPAN), 0);\n\n    /* Create a subtree for the security information. */\n    sec_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_zbee_sec, NULL, \""ZigBee Security Header\"");\n\n    /*  Get and display the Security control field */\n    packet.control  = tvb_get_guint8(tvb, offset);\n\n    /* Patch the security level. */\n    packet.control &= ~ZBEE_SEC_CONTROL_LEVEL;\n    packet.control |= (ZBEE_SEC_CONTROL_LEVEL & gPREF_zbee_sec_level);\n\n    /*\n     * Eww, I think I just threw up a little...  ZigBee requires this field\n     * to be patched before computing the MIC, but we don't have write-access\n     * to the tvbuff. So we need to allocate a copy of the whole thing just\n     * so we can fix these 3 bits. Memory allocated by tvb_memdup(wmem_packet_scope(),...)\n     * is automatically freed before the next packet is processed.\n     */\n#ifdef HAVE_LIBGCRYPT\n    enc_buffer = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, 0, tvb_captured_length(tvb));\n    /*\n     * Override the const qualifiers and patch the security level field, we\n     * know it is safe to overide the const qualifiers because we just\n     * allocated this memory via tvb_memdup(wmem_packet_scope(),...).\n     */\n    enc_buffer[offset] = packet.control;\n#endif /* HAVE_LIBGCRYPT */\n    packet.level    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_LEVEL);\n    packet.key_id   = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_KEY);\n    packet.nonce    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_NONCE);\n\n    proto_tree_add_bitmask(sec_tree, tvb, offset, hf_zbee_sec_field, ett_zbee_sec_control, sec_flags, ENC_NA);\n    offset += 1;\n\n    /* Get and display the frame counter field. */\n    packet.counter = tvb_get_letohl(tvb, offset);\n    if (tree) {\n        proto_tree_add_uint(sec_tree, hf_zbee_sec_counter, tvb, offset, 4, packet.counter);\n    }\n    offset += 4;\n\n    if (packet.nonce) {\n        /* Get and display the source address of the device that secured this payload. */\n        packet.src64 = tvb_get_letoh64(tvb, offset);\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_src64, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n        }\n#if 1\n        if (!pinfo->fd->flags.visited) {\n            switch ( packet.key_id ) {\n                case ZBEE_SEC_KEY_LINK:\n                if (nwk_hints && ieee_hints) {\n                    /* Map this long address with the nwk layer short address. */\n                    nwk_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, nwk_hints->src,\n                            ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                case ZBEE_SEC_KEY_NWK:\n                if (ieee_hints) {\n                    /* Map this long address with the ieee short address. */\n                    ieee_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, ieee_hints->src16,\n                        ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                /* We ignore the extended source addresses used to encrypt payloads with these\n                 * types of keys, because they can emerge from APS tunnels created by nodes whose\n                 * short address is not recorded in the packet. */\n                case ZBEE_SEC_KEY_TRANSPORT:\n                case ZBEE_SEC_KEY_LOAD:\n                break;\n            }\n        }\n#endif\n        offset += 8;\n    }\n    else {\n        /* Look for a source address in hints */\n        switch ( packet.key_id ) {\n            case ZBEE_SEC_KEY_NWK:\n                /* use the ieee extended source address for NWK decryption */\n                if ( ieee_hints && (map_rec = ieee_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n\n            default:\n                /* use the nwk extended source address for APS decryption */\n                if ( nwk_hints && (map_rec = nwk_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n        }\n    }\n\n    if (packet.key_id == ZBEE_SEC_KEY_NWK) {\n        /* Get and display the key sequence number. */\n        packet.key_seqno = tvb_get_guint8(tvb, offset);\n        if (tree) {\n            proto_tree_add_uint(sec_tree, hf_zbee_sec_key_seqno, tvb, offset, 1, packet.key_seqno);\n        }\n        offset += 1;\n    }\n\n    /* Determine the length of the MIC. */\n    switch (packet.level) {\n        case ZBEE_SEC_ENC:\n        case ZBEE_SEC_NONE:\n        default:\n            mic_len=0;\n            break;\n\n        case ZBEE_SEC_ENC_MIC32:\n        case ZBEE_SEC_MIC32:\n            mic_len=4;\n            break;\n\n        case ZBEE_SEC_ENC_MIC64:\n        case ZBEE_SEC_MIC64:\n            mic_len=8;\n            break;\n\n        case ZBEE_SEC_ENC_MIC128:\n        case ZBEE_SEC_MIC128:\n            mic_len=16;\n            break;\n    } /* switch */\n\n    /* Get and display the MIC. */\n    if (mic_len) {\n        /* Display the MIC. */\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_mic, tvb, (gint)(tvb_captured_length(tvb)-mic_len),\n                   mic_len, ENC_NA);\n        }\n    }\n\n    /* Check for null payload. */\n    payload_len = tvb_captured_length_remaining(tvb, offset+mic_len);\n    if (payload_len == 0)\n        return NULL;\n\n    /**********************************************\n     *  Perform Security Operations on the Frame  *\n     **********************************************\n     */\n    if ((packet.level == ZBEE_SEC_NONE) ||\n        (packet.level == ZBEE_SEC_MIC32) ||\n        (packet.level == ZBEE_SEC_MIC64) ||\n        (packet.level == ZBEE_SEC_MIC128)) {\n\n        /* Payload is only integrity protected. Just return the sub-tvbuff. */\n        return tvb_new_subset_length(tvb, offset, payload_len);\n    }\n\n#ifdef HAVE_LIBGCRYPT\n    /* Allocate memory to decrypt the payload into. */\n    dec_buffer = (guint8 *)g_malloc(payload_len);\n\n    decrypted = FALSE;\n    if ( packet.src64 ) {\n        if (pinfo->fd->flags.visited) {\n            if ( nwk_hints ) {\n                /* Use previously found key */\n                switch ( packet.key_id ) {\n                    case ZBEE_SEC_KEY_NWK:\n                        if ( (key_rec = nwk_hints->nwk) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, nwk_hints->nwk->key);\n                        }\n                        break;\n\n                    default:\n                        if ( (key_rec = nwk_hints->link) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, nwk_hints->link->key);\n                        }\n                        break;\n                }\n            }\n        } /* ( !pinfo->fd->flags.visited ) */\n        else {\n            /* We only search for sniffed keys in the first pass,\n             * to save time, and because decrypting with keys\n             * transported in future packets is cheating */\n\n            /* Lookup NWK and link key in hash for this pan. */\n            /* This overkill approach is a placeholder for a hash that looks up\n             * a key ring for a link key associated with a pair of devices.\n             */\n            if ( nwk_hints ) {\n                nwk_keyring = (GSList **)g_hash_table_lookup(zbee_table_nwk_keyring, &nwk_hints->src_pan);\n\n                if ( nwk_keyring ) {\n                    GSList_i = *nwk_keyring;\n                    while ( GSList_i && !decrypted ) {\n                        decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                        if (decrypted) {\n                            /* save pointer to the successful key record */\n                            switch (packet.key_id) {\n                                case ZBEE_SEC_KEY_NWK:\n                                    key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                    break;\n\n                                default:\n                                    key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                    break;\n                            }\n                        } else {\n                            GSList_i = g_slist_next(GSList_i);\n                        }\n                    }\n                }\n\n                /* Loop through user's password table for preconfigured keys, our last resort */\n                GSList_i = zbee_pc_keyring;\n                while ( GSList_i && !decrypted ) {\n                    decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                            payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                    if (decrypted) {\n                        /* save pointer to the successful key record */\n                        switch (packet.key_id) {\n                            case ZBEE_SEC_KEY_NWK:\n                                key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                break;\n\n                            default:\n                                key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                break;\n                        }\n                    } else {\n                        GSList_i = g_slist_next(GSList_i);\n                    }\n                }\n            }\n        } /* ( ! pinfo->fd->flags.visited ) */\n    } /* ( packet.src64 ) */\n\n    if ( decrypted ) {\n        if ( tree && key_rec ) {\n            key_item = proto_tree_add_bytes(sec_tree, hf_zbee_sec_key, tvb, 0, ZBEE_SEC_CONST_KEYSIZE, key_rec->key);\n            PROTO_ITEM_SET_GENERATED(key_item);\n\n            if ( key_rec->frame_num == ZBEE_SEC_PC_KEY ) {\n                ti = proto_tree_add_string(sec_tree, hf_zbee_sec_decryption_key, tvb, 0, 0, key_rec->label);\n            } else {\n                ti = proto_tree_add_uint(sec_tree, hf_zbee_sec_key_origin, tvb, 0, 0,\n                        key_rec->frame_num);\n            }\n            PROTO_ITEM_SET_GENERATED(ti);\n        }\n\n        /* Found a key that worked, setup the new tvbuff_t and return */\n        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_len, payload_len);\n        tvb_set_free_cb(payload_tvb, g_free); /* set up callback to free dec_buffer */\n        add_new_data_source(pinfo, payload_tvb, \""Decrypted ZigBee Payload\"");\n\n        /* Done! */\n        return payload_tvb;\n    }\n\n    g_free(dec_buffer);\n#endif /* HAVE_LIBGCRYPT */\n\n    /* Add expert info. */\n    expert_add_info(pinfo, sec_tree, &ei_zbee_sec_encrypted_payload);\n    /* Create a buffer for the undecrypted payload. */\n    payload_tvb = tvb_new_subset(tvb, offset, payload_len, -1);\n    /* Dump the payload to the data dissector. */\n    call_dissector(data_handle, payload_tvb, pinfo, tree);\n    /* Couldn't decrypt, so return NULL. */\n    return NULL;\n}"", ""target"": 1}]","[{""func_name"": ""dissect_zbee_secure"", ""file_path"": ""epan/dissectors/packet-zbee-security.c"", ""func_code"": ""tvbuff_t *\ndissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint offset)\n{\n    proto_tree     *sec_tree;\n\n    zbee_security_packet    packet;\n    guint           mic_len;\n    gint            payload_len;\n    tvbuff_t       *payload_tvb;\n\n#ifdef HAVE_LIBGCRYPT\n    proto_item         *ti;\n    proto_item         *key_item;\n    guint8             *enc_buffer;\n    guint8             *dec_buffer;\n    gboolean            decrypted;\n    GSList            **nwk_keyring;\n    GSList             *GSList_i;\n    key_record_t       *key_rec = NULL;\n#endif\n    zbee_nwk_hints_t   *nwk_hints;\n    ieee802154_hints_t *ieee_hints;\n    ieee802154_map_rec *map_rec = NULL;\n\n    static const int * sec_flags[] = {\n        &hf_zbee_sec_key_id,\n        &hf_zbee_sec_nonce,\n        NULL\n    };\n\n    /* Init */\n    memset(&packet, 0, sizeof(zbee_security_packet));\n\n    /* Get pointers to any useful frame data from lower layers */\n    nwk_hints = (zbee_nwk_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(ZBEE_PROTOABBREV_NWK), 0);\n    ieee_hints = (ieee802154_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(IEEE802154_PROTOABBREV_WPAN), 0);\n\n    /* Create a subtree for the security information. */\n    sec_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_zbee_sec, NULL, \""ZigBee Security Header\"");\n\n    /*  Get and display the Security control field */\n    packet.control  = tvb_get_guint8(tvb, offset);\n\n    /* Patch the security level. */\n    packet.control &= ~ZBEE_SEC_CONTROL_LEVEL;\n    packet.control |= (ZBEE_SEC_CONTROL_LEVEL & gPREF_zbee_sec_level);\n\n    /*\n     * Eww, I think I just threw up a little...  ZigBee requires this field\n     * to be patched before computing the MIC, but we don't have write-access\n     * to the tvbuff. So we need to allocate a copy of the whole thing just\n     * so we can fix these 3 bits. Memory allocated by tvb_memdup(wmem_packet_scope(),...)\n     * is automatically freed before the next packet is processed.\n     */\n#ifdef HAVE_LIBGCRYPT\n    enc_buffer = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, 0, tvb_captured_length(tvb));\n    /*\n     * Override the const qualifiers and patch the security level field, we\n     * know it is safe to overide the const qualifiers because we just\n     * allocated this memory via tvb_memdup(wmem_packet_scope(),...).\n     */\n    enc_buffer[offset] = packet.control;\n#endif /* HAVE_LIBGCRYPT */\n    packet.level    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_LEVEL);\n    packet.key_id   = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_KEY);\n    packet.nonce    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_NONCE);\n\n    proto_tree_add_bitmask(sec_tree, tvb, offset, hf_zbee_sec_field, ett_zbee_sec_control, sec_flags, ENC_NA);\n    offset += 1;\n\n    /* Get and display the frame counter field. */\n    packet.counter = tvb_get_letohl(tvb, offset);\n    if (tree) {\n        proto_tree_add_uint(sec_tree, hf_zbee_sec_counter, tvb, offset, 4, packet.counter);\n    }\n    offset += 4;\n\n    if (packet.nonce) {\n        /* Get and display the source address of the device that secured this payload. */\n        packet.src64 = tvb_get_letoh64(tvb, offset);\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_src64, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n        }\n#if 1\n        if (!pinfo->fd->flags.visited) {\n            switch ( packet.key_id ) {\n                case ZBEE_SEC_KEY_LINK:\n                if (nwk_hints && ieee_hints) {\n                    /* Map this long address with the nwk layer short address. */\n                    nwk_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, nwk_hints->src,\n                            ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                case ZBEE_SEC_KEY_NWK:\n                if (ieee_hints) {\n                    /* Map this long address with the ieee short address. */\n                    ieee_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, ieee_hints->src16,\n                        ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                /* We ignore the extended source addresses used to encrypt payloads with these\n                 * types of keys, because they can emerge from APS tunnels created by nodes whose\n                 * short address is not recorded in the packet. */\n                case ZBEE_SEC_KEY_TRANSPORT:\n                case ZBEE_SEC_KEY_LOAD:\n                break;\n            }\n        }\n#endif\n        offset += 8;\n    }\n    else {\n        /* Look for a source address in hints */\n        switch ( packet.key_id ) {\n            case ZBEE_SEC_KEY_NWK:\n                /* use the ieee extended source address for NWK decryption */\n                if ( ieee_hints && (map_rec = ieee_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n\n            default:\n                /* use the nwk extended source address for APS decryption */\n                if ( nwk_hints && (map_rec = nwk_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n        }\n    }\n\n    if (packet.key_id == ZBEE_SEC_KEY_NWK) {\n        /* Get and display the key sequence number. */\n        packet.key_seqno = tvb_get_guint8(tvb, offset);\n        if (tree) {\n            proto_tree_add_uint(sec_tree, hf_zbee_sec_key_seqno, tvb, offset, 1, packet.key_seqno);\n        }\n        offset += 1;\n    }\n\n    /* Determine the length of the MIC. */\n    switch (packet.level) {\n        case ZBEE_SEC_ENC:\n        case ZBEE_SEC_NONE:\n        default:\n            mic_len=0;\n            break;\n\n        case ZBEE_SEC_ENC_MIC32:\n        case ZBEE_SEC_MIC32:\n            mic_len=4;\n            break;\n\n        case ZBEE_SEC_ENC_MIC64:\n        case ZBEE_SEC_MIC64:\n            mic_len=8;\n            break;\n\n        case ZBEE_SEC_ENC_MIC128:\n        case ZBEE_SEC_MIC128:\n            mic_len=16;\n            break;\n    } /* switch */\n\n    /* Get and display the MIC. */\n    if (mic_len) {\n        /* Display the MIC. */\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_mic, tvb, (gint)(tvb_captured_length(tvb)-mic_len),\n                   mic_len, ENC_NA);\n        }\n    }\n\n    /* Check for null payload. */\n    payload_len = tvb_captured_length_remaining(tvb, offset+mic_len);\n    if (payload_len == 0)\n        return NULL;\n\n    /**********************************************\n     *  Perform Security Operations on the Frame  *\n     **********************************************\n     */\n    if ((packet.level == ZBEE_SEC_NONE) ||\n        (packet.level == ZBEE_SEC_MIC32) ||\n        (packet.level == ZBEE_SEC_MIC64) ||\n        (packet.level == ZBEE_SEC_MIC128)) {\n\n        /* Payload is only integrity protected. Just return the sub-tvbuff. */\n        return tvb_new_subset_length(tvb, offset, payload_len);\n    }\n\n#ifdef HAVE_LIBGCRYPT\n    /* Allocate memory to decrypt the payload into. */\n    dec_buffer = (guint8 *)g_malloc(payload_len);\n\n    decrypted = FALSE;\n    if ( packet.src64 ) {\n        if (pinfo->fd->flags.visited) {\n            if ( nwk_hints ) {\n                /* Use previously found key */\n                switch ( packet.key_id ) {\n                    case ZBEE_SEC_KEY_NWK:\n                        if ( (key_rec = nwk_hints->nwk) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, nwk_hints->nwk->key);\n                        }\n                        break;\n\n                    default:\n                        if ( (key_rec = nwk_hints->link) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, nwk_hints->link->key);\n                        }\n                        break;\n                }\n            }\n        } /* ( !pinfo->fd->flags.visited ) */\n        else {\n            /* We only search for sniffed keys in the first pass,\n             * to save time, and because decrypting with keys\n             * transported in future packets is cheating */\n\n            /* Lookup NWK and link key in hash for this pan. */\n            /* This overkill approach is a placeholder for a hash that looks up\n             * a key ring for a link key associated with a pair of devices.\n             */\n            if ( nwk_hints ) {\n                nwk_keyring = (GSList **)g_hash_table_lookup(zbee_table_nwk_keyring, &nwk_hints->src_pan);\n\n                if ( nwk_keyring ) {\n                    GSList_i = *nwk_keyring;\n                    while ( GSList_i && !decrypted ) {\n                        decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                        if (decrypted) {\n                            /* save pointer to the successful key record */\n                            switch (packet.key_id) {\n                                case ZBEE_SEC_KEY_NWK:\n                                    key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                    break;\n\n                                default:\n                                    key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                    break;\n                            }\n                        } else {\n                            GSList_i = g_slist_next(GSList_i);\n                        }\n                    }\n                }\n\n                /* Loop through user's password table for preconfigured keys, our last resort */\n                GSList_i = zbee_pc_keyring;\n                while ( GSList_i && !decrypted ) {\n                    decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                            payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                    if (decrypted) {\n                        /* save pointer to the successful key record */\n                        switch (packet.key_id) {\n                            case ZBEE_SEC_KEY_NWK:\n                                key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                break;\n\n                            default:\n                                key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                break;\n                        }\n                    } else {\n                        GSList_i = g_slist_next(GSList_i);\n                    }\n                }\n            }\n        } /* ( ! pinfo->fd->flags.visited ) */\n    } /* ( packet.src64 ) */\n\n    if ( decrypted ) {\n        if ( tree && key_rec ) {\n            key_item = proto_tree_add_bytes(sec_tree, hf_zbee_sec_key, tvb, 0, ZBEE_SEC_CONST_KEYSIZE, key_rec->key);\n            PROTO_ITEM_SET_GENERATED(key_item);\n\n            if ( key_rec->frame_num == ZBEE_SEC_PC_KEY ) {\n                ti = proto_tree_add_string(sec_tree, hf_zbee_sec_decryption_key, tvb, 0, 0, key_rec->label);\n            } else {\n                ti = proto_tree_add_uint(sec_tree, hf_zbee_sec_key_origin, tvb, 0, 0,\n                        key_rec->frame_num);\n            }\n            PROTO_ITEM_SET_GENERATED(ti);\n        }\n\n        /* Found a key that worked, setup the new tvbuff_t and return */\n        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_len, payload_len);\n        tvb_set_free_cb(payload_tvb, g_free); /* set up callback to free dec_buffer */\n        add_new_data_source(pinfo, payload_tvb, \""Decrypted ZigBee Payload\"");\n\n        /* Done! */\n        return payload_tvb;\n    }\n\n    g_free(dec_buffer);\n#endif /* HAVE_LIBGCRYPT */\n\n    /* Add expert info. */\n    expert_add_info(pinfo, sec_tree, &ei_zbee_sec_encrypted_payload);\n    /* Create a buffer for the undecrypted payload. */\n    payload_tvb = tvb_new_subset(tvb, offset, payload_len, -1);\n    /* Dump the payload to the data dissector. */\n    call_dissector(data_handle, payload_tvb, pinfo, tree);\n    /* Couldn't decrypt, so return NULL. */\n    return NULL;\n}""}, {""func_name"": ""zbee_security_register"", ""file_path"": ""epan/dissectors/packet-zbee-security.c"", ""func_code"": ""void zbee_security_register(module_t *zbee_prefs, int proto)\n{\n    static hf_register_info hf[] = {\n        { &hf_zbee_sec_field,\n          { \""Security Control Field\"",   \""zbee.sec.field\"", FT_UINT8, BASE_HEX, NULL,\n            0x0, NULL, HFILL }},\n\n        { &hf_zbee_sec_key_id,\n          { \""Key Id\"",                    \""zbee.sec.key\"", FT_UINT8, BASE_HEX, VALS(zbee_sec_key_names),\n            ZBEE_SEC_CONTROL_KEY, NULL, HFILL }},\n\n        { &hf_zbee_sec_nonce,\n          { \""Extended Nonce\"",         \""zbee.sec.ext_nonce\"", FT_BOOLEAN, 8, NULL, ZBEE_SEC_CONTROL_NONCE,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_counter,\n          { \""Frame Counter\"",          \""zbee.sec.counter\"", FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_src64,\n          { \""Extended Source\"",                 \""zbee.sec.src64\"", FT_EUI64, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_key_seqno,\n          { \""Key Sequence Number\"",    \""zbee.sec.key_seqno\"", FT_UINT8, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_mic,\n          { \""Message Integrity Code\"", \""zbee.sec.mic\"", FT_BYTES, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_key,\n          { \""Key\"", \""zbee.sec.key\"", FT_BYTES, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_key_origin,\n          { \""Key Origin\"", \""zbee.sec.key.origin\"", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }},\n\n        { &hf_zbee_sec_decryption_key,\n          { \""Key Label\"", \""zbee.sec.decryption_key\"", FT_STRING, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }}\n    };\n\n    static gint *ett[] = {\n        &ett_zbee_sec,\n        &ett_zbee_sec_control\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_zbee_sec_encrypted_payload, { \""zbee_sec.encrypted_payload\"", PI_UNDECODED, PI_WARN, \""Encrypted Payload\"", EXPFILL }},\n        { &ei_zbee_sec_encrypted_payload_sliced, { \""zbee_sec.encrypted_payload_sliced\"", PI_UNDECODED, PI_WARN, \""Encrypted payload, cut short when capturing - can't decrypt\"", EXPFILL }},\n        { &ei_zbee_sec_extended_source_unknown, { \""zbee_sec.extended_source_unknown\"", PI_PROTOCOL, PI_NOTE, \""Extended Source: Unknown\"", EXPFILL }},\n    };\n\n    expert_module_t* expert_zbee_sec;\n\n    static uat_field_t key_uat_fields[] = {\n        UAT_FLD_CSTRING(uat_key_records, string, \""Key\"",\n                        \""A 16-byte key in hexadecimal with optional dash-,\\n\""\n                        \""colon-, or space-separator characters, or a\\n\""\n                        \""a 16-character string in double-quotes.\""),\n        UAT_FLD_VS(uat_key_records, byte_order, \""Byte Order\"", byte_order_vals,\n                        \""Byte order of key.\""),\n        UAT_FLD_CSTRING(uat_key_records, label, \""Label\"", \""User label for key.\""),\n        UAT_END_FIELDS\n    };\n\n    /* If no prefs module was supplied, register our own. */\n    if (zbee_prefs == NULL) {\n        zbee_prefs = prefs_register_protocol(proto, NULL);\n    }\n\n    /*  Register preferences */\n    prefs_register_enum_preference(zbee_prefs, \""seclevel\"", \""Security Level\"",\n                 \""Specifies the security level to use in the\\n\""\n                 \""decryption process. This value is ignored\\n\""\n                 \""for ZigBee 2004 and unsecured networks.\"",\n                 &gPREF_zbee_sec_level, zbee_sec_level_enums, FALSE);\n\n    zbee_sec_key_table_uat = uat_new(\""Pre-configured Keys\"",\n                               sizeof(uat_key_record_t),\n                               \""zigbee_pc_keys\"",\n                               TRUE,\n                               &uat_key_records,\n                               &num_uat_key_records,\n                               UAT_AFFECTS_DISSECTION, /* affects dissection of packets, but not set of named fields */\n                               NULL,  /* TODO: ptr to help manual? */\n                               uat_key_record_copy_cb,\n                               uat_key_record_update_cb,\n                               uat_key_record_free_cb,\n                               uat_key_record_post_update,\n                               key_uat_fields );\n\n    prefs_register_uat_preference(zbee_prefs,\n                                  \""key_table\"",\n                                  \""Pre-configured Keys\"",\n                                  \""Pre-configured link or network keys.\"",\n                                  zbee_sec_key_table_uat);\n\n    proto_register_field_array(proto, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n    expert_zbee_sec = expert_register_protocol(proto);\n    expert_register_field_array(expert_zbee_sec, ei, array_length(ei));\n\n}""}, {""func_name"": ""dissect_zbee_secure"", ""file_path"": ""epan/dissectors/packet-zbee-security.c"", ""func_code"": ""tvbuff_t *\ndissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint offset)\n{\n    proto_tree     *sec_tree;\n\n    zbee_security_packet    packet;\n    guint           mic_len;\n    gint            payload_len;\n    tvbuff_t       *payload_tvb;\n\n#ifdef HAVE_LIBGCRYPT\n    proto_item         *ti;\n    proto_item         *key_item;\n    guint8             *enc_buffer;\n    guint8             *dec_buffer;\n    gboolean            decrypted;\n    GSList            **nwk_keyring;\n    GSList             *GSList_i;\n    key_record_t       *key_rec = NULL;\n#endif\n    zbee_nwk_hints_t   *nwk_hints;\n    ieee802154_hints_t *ieee_hints;\n    ieee802154_map_rec *map_rec = NULL;\n\n    static const int * sec_flags[] = {\n        &hf_zbee_sec_key_id,\n        &hf_zbee_sec_nonce,\n        NULL\n    };\n\n    /* Init */\n    memset(&packet, 0, sizeof(zbee_security_packet));\n\n    /* Get pointers to any useful frame data from lower layers */\n    nwk_hints = (zbee_nwk_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(ZBEE_PROTOABBREV_NWK), 0);\n    ieee_hints = (ieee802154_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(IEEE802154_PROTOABBREV_WPAN), 0);\n\n    /* Create a subtree for the security information. */\n    sec_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_zbee_sec, NULL, \""ZigBee Security Header\"");\n\n    /*  Get and display the Security control field */\n    packet.control  = tvb_get_guint8(tvb, offset);\n\n    /* Patch the security level. */\n    packet.control &= ~ZBEE_SEC_CONTROL_LEVEL;\n    packet.control |= (ZBEE_SEC_CONTROL_LEVEL & gPREF_zbee_sec_level);\n\n    /*\n     * Eww, I think I just threw up a little...  ZigBee requires this field\n     * to be patched before computing the MIC, but we don't have write-access\n     * to the tvbuff. So we need to allocate a copy of the whole thing just\n     * so we can fix these 3 bits. Memory allocated by tvb_memdup(wmem_packet_scope(),...)\n     * is automatically freed before the next packet is processed.\n     */\n#ifdef HAVE_LIBGCRYPT\n    enc_buffer = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, 0, tvb_captured_length(tvb));\n    /*\n     * Override the const qualifiers and patch the security level field, we\n     * know it is safe to overide the const qualifiers because we just\n     * allocated this memory via tvb_memdup(wmem_packet_scope(),...).\n     */\n    enc_buffer[offset] = packet.control;\n#endif /* HAVE_LIBGCRYPT */\n    packet.level    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_LEVEL);\n    packet.key_id   = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_KEY);\n    packet.nonce    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_NONCE);\n\n    proto_tree_add_bitmask(sec_tree, tvb, offset, hf_zbee_sec_field, ett_zbee_sec_control, sec_flags, ENC_NA);\n    offset += 1;\n\n    /* Get and display the frame counter field. */\n    packet.counter = tvb_get_letohl(tvb, offset);\n    if (tree) {\n        proto_tree_add_uint(sec_tree, hf_zbee_sec_counter, tvb, offset, 4, packet.counter);\n    }\n    offset += 4;\n\n    if (packet.nonce) {\n        /* Get and display the source address of the device that secured this payload. */\n        packet.src64 = tvb_get_letoh64(tvb, offset);\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_src64, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n        }\n#if 1\n        if (!pinfo->fd->flags.visited) {\n            switch ( packet.key_id ) {\n                case ZBEE_SEC_KEY_LINK:\n                if (nwk_hints && ieee_hints) {\n                    /* Map this long address with the nwk layer short address. */\n                    nwk_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, nwk_hints->src,\n                            ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                case ZBEE_SEC_KEY_NWK:\n                if (ieee_hints) {\n                    /* Map this long address with the ieee short address. */\n                    ieee_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, ieee_hints->src16,\n                        ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                /* We ignore the extended source addresses used to encrypt payloads with these\n                 * types of keys, because they can emerge from APS tunnels created by nodes whose\n                 * short address is not recorded in the packet. */\n                case ZBEE_SEC_KEY_TRANSPORT:\n                case ZBEE_SEC_KEY_LOAD:\n                break;\n            }\n        }\n#endif\n        offset += 8;\n    }\n    else {\n        /* Look for a source address in hints */\n        switch ( packet.key_id ) {\n            case ZBEE_SEC_KEY_NWK:\n                /* use the ieee extended source address for NWK decryption */\n                if ( ieee_hints && (map_rec = ieee_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n\n            default:\n                /* use the nwk extended source address for APS decryption */\n                if ( nwk_hints && (map_rec = nwk_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n        }\n    }\n\n    if (packet.key_id == ZBEE_SEC_KEY_NWK) {\n        /* Get and display the key sequence number. */\n        packet.key_seqno = tvb_get_guint8(tvb, offset);\n        if (tree) {\n            proto_tree_add_uint(sec_tree, hf_zbee_sec_key_seqno, tvb, offset, 1, packet.key_seqno);\n        }\n        offset += 1;\n    }\n\n    /* Determine the length of the MIC. */\n    switch (packet.level) {\n        case ZBEE_SEC_ENC:\n        case ZBEE_SEC_NONE:\n        default:\n            mic_len=0;\n            break;\n\n        case ZBEE_SEC_ENC_MIC32:\n        case ZBEE_SEC_MIC32:\n            mic_len=4;\n            break;\n\n        case ZBEE_SEC_ENC_MIC64:\n        case ZBEE_SEC_MIC64:\n            mic_len=8;\n            break;\n\n        case ZBEE_SEC_ENC_MIC128:\n        case ZBEE_SEC_MIC128:\n            mic_len=16;\n            break;\n    } /* switch */\n\n    /* Get and display the MIC. */\n    if (mic_len) {\n        /* Display the MIC. */\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_mic, tvb, (gint)(tvb_captured_length(tvb)-mic_len),\n                   mic_len, ENC_NA);\n        }\n    }\n\n    /* Check for null payload. */\n    payload_len = tvb_reported_length_remaining(tvb, offset+mic_len);\n    if (payload_len == 0)\n        return NULL;\n\n    /**********************************************\n     *  Perform Security Operations on the Frame  *\n     **********************************************\n     */\n    if ((packet.level == ZBEE_SEC_NONE) ||\n        (packet.level == ZBEE_SEC_MIC32) ||\n        (packet.level == ZBEE_SEC_MIC64) ||\n        (packet.level == ZBEE_SEC_MIC128)) {\n\n        /* Payload is only integrity protected. Just return the sub-tvbuff. */\n        return tvb_new_subset_length(tvb, offset, payload_len);\n    }\n\n#ifdef HAVE_LIBGCRYPT\n    /* Have we captured all the payload? */\n    if (tvb_captured_length_remaining(tvb, offset+mic_len) < payload_len) {\n        /*\n         * No - don't try to decrypt it.\n         *\n         * XXX - it looks as if the decryption code is assuming we have the\n         * MIC, which won't be the case if the packet was cut short.  Is\n         * that in fact that case, or can we still make this work with a\n         * partially-captured packet?\n         */\n        /* Add expert info. */\n        expert_add_info(pinfo, sec_tree, &ei_zbee_sec_encrypted_payload_sliced);\n        /* Create a buffer for the undecrypted payload. */\n        payload_tvb = tvb_new_subset_length(tvb, offset, payload_len);\n        /* Dump the payload to the data dissector. */\n        call_dissector(data_handle, payload_tvb, pinfo, tree);\n        /* Couldn't decrypt, so return NULL. */\n        return NULL;\n    }         \n\n    /* Allocate memory to decrypt the payload into. */\n    dec_buffer = (guint8 *)g_malloc(payload_len);\n\n    decrypted = FALSE;\n    if ( packet.src64 ) {\n        if (pinfo->fd->flags.visited) {\n            if ( nwk_hints ) {\n                /* Use previously found key */\n                switch ( packet.key_id ) {\n                    case ZBEE_SEC_KEY_NWK:\n                        if ( (key_rec = nwk_hints->nwk) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, nwk_hints->nwk->key);\n                        }\n                        break;\n\n                    default:\n                        if ( (key_rec = nwk_hints->link) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, nwk_hints->link->key);\n                        }\n                        break;\n                }\n            }\n        } /* ( !pinfo->fd->flags.visited ) */\n        else {\n            /* We only search for sniffed keys in the first pass,\n             * to save time, and because decrypting with keys\n             * transported in future packets is cheating */\n\n            /* Lookup NWK and link key in hash for this pan. */\n            /* This overkill approach is a placeholder for a hash that looks up\n             * a key ring for a link key associated with a pair of devices.\n             */\n            if ( nwk_hints ) {\n                nwk_keyring = (GSList **)g_hash_table_lookup(zbee_table_nwk_keyring, &nwk_hints->src_pan);\n\n                if ( nwk_keyring ) {\n                    GSList_i = *nwk_keyring;\n                    while ( GSList_i && !decrypted ) {\n                        decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                        if (decrypted) {\n                            /* save pointer to the successful key record */\n                            switch (packet.key_id) {\n                                case ZBEE_SEC_KEY_NWK:\n                                    key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                    break;\n\n                                default:\n                                    key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                    break;\n                            }\n                        } else {\n                            GSList_i = g_slist_next(GSList_i);\n                        }\n                    }\n                }\n\n                /* Loop through user's password table for preconfigured keys, our last resort */\n                GSList_i = zbee_pc_keyring;\n                while ( GSList_i && !decrypted ) {\n                    decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                            payload_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                    if (decrypted) {\n                        /* save pointer to the successful key record */\n                        switch (packet.key_id) {\n                            case ZBEE_SEC_KEY_NWK:\n                                key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                break;\n\n                            default:\n                                key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                break;\n                        }\n                    } else {\n                        GSList_i = g_slist_next(GSList_i);\n                    }\n                }\n            }\n        } /* ( ! pinfo->fd->flags.visited ) */\n    } /* ( packet.src64 ) */\n\n    if ( decrypted ) {\n        if ( tree && key_rec ) {\n            key_item = proto_tree_add_bytes(sec_tree, hf_zbee_sec_key, tvb, 0, ZBEE_SEC_CONST_KEYSIZE, key_rec->key);\n            PROTO_ITEM_SET_GENERATED(key_item);\n\n            if ( key_rec->frame_num == ZBEE_SEC_PC_KEY ) {\n                ti = proto_tree_add_string(sec_tree, hf_zbee_sec_decryption_key, tvb, 0, 0, key_rec->label);\n            } else {\n                ti = proto_tree_add_uint(sec_tree, hf_zbee_sec_key_origin, tvb, 0, 0,\n                        key_rec->frame_num);\n            }\n            PROTO_ITEM_SET_GENERATED(ti);\n        }\n\n        /* Found a key that worked, setup the new tvbuff_t and return */\n        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_len, payload_len);\n        tvb_set_free_cb(payload_tvb, g_free); /* set up callback to free dec_buffer */\n        add_new_data_source(pinfo, payload_tvb, \""Decrypted ZigBee Payload\"");\n\n        /* Done! */\n        return payload_tvb;\n    }\n\n    g_free(dec_buffer);\n#endif /* HAVE_LIBGCRYPT */\n\n    /* Add expert info. */\n    expert_add_info(pinfo, sec_tree, &ei_zbee_sec_encrypted_payload);\n    /* Create a buffer for the undecrypted payload. */\n    payload_tvb = tvb_new_subset_length(tvb, offset, payload_len);\n    /* Dump the payload to the data dissector. */\n    call_dissector(data_handle, payload_tvb, pinfo, tree);\n    /* Couldn't decrypt, so return NULL. */\n    return NULL;\n}""}, {""func_name"": ""dissect_zbee_secure"", ""file_path"": ""epan/dissectors/packet-zbee-security.c"", ""func_code"": ""tvbuff_t *\ndissect_zbee_secure(tvbuff_t *tvb, packet_info *pinfo, proto_tree* tree, guint offset)\n{\n    proto_tree     *sec_tree;\n\n    zbee_security_packet    packet;\n    guint           mic_len;\n    gint            payload_reported_len;\n    tvbuff_t       *payload_tvb;\n\n#ifdef HAVE_LIBGCRYPT\n    gint               payload_captured_len;\n    proto_item         *ti;\n    proto_item         *key_item;\n    guint8             *enc_buffer;\n    guint8             *dec_buffer;\n    gboolean            decrypted;\n    GSList            **nwk_keyring;\n    GSList             *GSList_i;\n    key_record_t       *key_rec = NULL;\n#endif\n    zbee_nwk_hints_t   *nwk_hints;\n    ieee802154_hints_t *ieee_hints;\n    ieee802154_map_rec *map_rec = NULL;\n\n    static const int * sec_flags[] = {\n        &hf_zbee_sec_key_id,\n        &hf_zbee_sec_nonce,\n        NULL\n    };\n\n    /* Init */\n    memset(&packet, 0, sizeof(zbee_security_packet));\n\n    /* Get pointers to any useful frame data from lower layers */\n    nwk_hints = (zbee_nwk_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(ZBEE_PROTOABBREV_NWK), 0);\n    ieee_hints = (ieee802154_hints_t *)p_get_proto_data(wmem_file_scope(), pinfo,\n        proto_get_id_by_filter_name(IEEE802154_PROTOABBREV_WPAN), 0);\n\n    /* Create a subtree for the security information. */\n    sec_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_zbee_sec, NULL, \""ZigBee Security Header\"");\n\n    /*  Get and display the Security control field */\n    packet.control  = tvb_get_guint8(tvb, offset);\n\n    /* Patch the security level. */\n    packet.control &= ~ZBEE_SEC_CONTROL_LEVEL;\n    packet.control |= (ZBEE_SEC_CONTROL_LEVEL & gPREF_zbee_sec_level);\n\n    /*\n     * Eww, I think I just threw up a little...  ZigBee requires this field\n     * to be patched before computing the MIC, but we don't have write-access\n     * to the tvbuff. So we need to allocate a copy of the whole thing just\n     * so we can fix these 3 bits. Memory allocated by tvb_memdup(wmem_packet_scope(),...)\n     * is automatically freed before the next packet is processed.\n     */\n#ifdef HAVE_LIBGCRYPT\n    enc_buffer = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, 0, tvb_captured_length(tvb));\n    /*\n     * Override the const qualifiers and patch the security level field, we\n     * know it is safe to overide the const qualifiers because we just\n     * allocated this memory via tvb_memdup(wmem_packet_scope(),...).\n     */\n    enc_buffer[offset] = packet.control;\n#endif /* HAVE_LIBGCRYPT */\n    packet.level    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_LEVEL);\n    packet.key_id   = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_KEY);\n    packet.nonce    = zbee_get_bit_field(packet.control, ZBEE_SEC_CONTROL_NONCE);\n\n    proto_tree_add_bitmask(sec_tree, tvb, offset, hf_zbee_sec_field, ett_zbee_sec_control, sec_flags, ENC_NA);\n    offset += 1;\n\n    /* Get and display the frame counter field. */\n    packet.counter = tvb_get_letohl(tvb, offset);\n    if (tree) {\n        proto_tree_add_uint(sec_tree, hf_zbee_sec_counter, tvb, offset, 4, packet.counter);\n    }\n    offset += 4;\n\n    if (packet.nonce) {\n        /* Get and display the source address of the device that secured this payload. */\n        packet.src64 = tvb_get_letoh64(tvb, offset);\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_src64, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n        }\n#if 1\n        if (!pinfo->fd->flags.visited) {\n            switch ( packet.key_id ) {\n                case ZBEE_SEC_KEY_LINK:\n                if (nwk_hints && ieee_hints) {\n                    /* Map this long address with the nwk layer short address. */\n                    nwk_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, nwk_hints->src,\n                            ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                case ZBEE_SEC_KEY_NWK:\n                if (ieee_hints) {\n                    /* Map this long address with the ieee short address. */\n                    ieee_hints->map_rec = ieee802154_addr_update(&zbee_nwk_map, ieee_hints->src16,\n                        ieee_hints->src_pan, packet.src64, pinfo->current_proto, pinfo->fd->num);\n                }\n                break;\n\n                /* We ignore the extended source addresses used to encrypt payloads with these\n                 * types of keys, because they can emerge from APS tunnels created by nodes whose\n                 * short address is not recorded in the packet. */\n                case ZBEE_SEC_KEY_TRANSPORT:\n                case ZBEE_SEC_KEY_LOAD:\n                break;\n            }\n        }\n#endif\n        offset += 8;\n    }\n    else {\n        /* Look for a source address in hints */\n        switch ( packet.key_id ) {\n            case ZBEE_SEC_KEY_NWK:\n                /* use the ieee extended source address for NWK decryption */\n                if ( ieee_hints && (map_rec = ieee_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n\n            default:\n                /* use the nwk extended source address for APS decryption */\n                if ( nwk_hints && (map_rec = nwk_hints->map_rec) )\n                    packet.src64 = map_rec->addr64;\n                else\n                    proto_tree_add_expert(sec_tree, pinfo, &ei_zbee_sec_extended_source_unknown, tvb, 0, 0);\n                break;\n        }\n    }\n\n    if (packet.key_id == ZBEE_SEC_KEY_NWK) {\n        /* Get and display the key sequence number. */\n        packet.key_seqno = tvb_get_guint8(tvb, offset);\n        if (tree) {\n            proto_tree_add_uint(sec_tree, hf_zbee_sec_key_seqno, tvb, offset, 1, packet.key_seqno);\n        }\n        offset += 1;\n    }\n\n    /* Determine the length of the MIC. */\n    switch (packet.level) {\n        case ZBEE_SEC_ENC:\n        case ZBEE_SEC_NONE:\n        default:\n            mic_len=0;\n            break;\n\n        case ZBEE_SEC_ENC_MIC32:\n        case ZBEE_SEC_MIC32:\n            mic_len=4;\n            break;\n\n        case ZBEE_SEC_ENC_MIC64:\n        case ZBEE_SEC_MIC64:\n            mic_len=8;\n            break;\n\n        case ZBEE_SEC_ENC_MIC128:\n        case ZBEE_SEC_MIC128:\n            mic_len=16;\n            break;\n    } /* switch */\n\n    /* Get and display the MIC. */\n    if (mic_len) {\n        /* Display the MIC. */\n        if (tree) {\n            proto_tree_add_item(sec_tree, hf_zbee_sec_mic, tvb, (gint)(tvb_captured_length(tvb)-mic_len),\n                   mic_len, ENC_NA);\n        }\n    }\n\n    /* Check for null payload. */\n    payload_reported_len = tvb_reported_length_remaining(tvb, offset+mic_len);\n    if (payload_reported_len == 0)\n        return NULL;\n\n    /**********************************************\n     *  Perform Security Operations on the Frame  *\n     **********************************************\n     */\n    if ((packet.level == ZBEE_SEC_NONE) ||\n        (packet.level == ZBEE_SEC_MIC32) ||\n        (packet.level == ZBEE_SEC_MIC64) ||\n        (packet.level == ZBEE_SEC_MIC128)) {\n\n        /* Payload is only integrity protected. Just return the sub-tvbuff. */\n        return tvb_new_subset_length(tvb, offset, payload_reported_len);\n    }\n\n#ifdef HAVE_LIBGCRYPT\n    /* How much payload was actually captured? */\n    payload_captured_len = tvb_captured_length_remaining(tvb, offset+mic_len);\n\n    /* Allocate memory to decrypt the payload into. */\n    dec_buffer = (guint8 *)g_malloc(payload_captured_len);\n\n    decrypted = FALSE;\n    if ( packet.src64 ) {\n        if (pinfo->fd->flags.visited) {\n            if ( nwk_hints ) {\n                /* Use previously found key */\n                switch ( packet.key_id ) {\n                    case ZBEE_SEC_KEY_NWK:\n                        if ( (key_rec = nwk_hints->nwk) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_captured_len, mic_len, nwk_hints->nwk->key);\n                        }\n                        break;\n\n                    default:\n                        if ( (key_rec = nwk_hints->link) ) {\n                            decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_captured_len, mic_len, nwk_hints->link->key);\n                        }\n                        break;\n                }\n            }\n        } /* ( !pinfo->fd->flags.visited ) */\n        else {\n            /* We only search for sniffed keys in the first pass,\n             * to save time, and because decrypting with keys\n             * transported in future packets is cheating */\n\n            /* Lookup NWK and link key in hash for this pan. */\n            /* This overkill approach is a placeholder for a hash that looks up\n             * a key ring for a link key associated with a pair of devices.\n             */\n            if ( nwk_hints ) {\n                nwk_keyring = (GSList **)g_hash_table_lookup(zbee_table_nwk_keyring, &nwk_hints->src_pan);\n\n                if ( nwk_keyring ) {\n                    GSList_i = *nwk_keyring;\n                    while ( GSList_i && !decrypted ) {\n                        decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                                payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                        if (decrypted) {\n                            /* save pointer to the successful key record */\n                            switch (packet.key_id) {\n                                case ZBEE_SEC_KEY_NWK:\n                                    key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                    break;\n\n                                default:\n                                    key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                    break;\n                            }\n                        } else {\n                            GSList_i = g_slist_next(GSList_i);\n                        }\n                    }\n                }\n\n                /* Loop through user's password table for preconfigured keys, our last resort */\n                GSList_i = zbee_pc_keyring;\n                while ( GSList_i && !decrypted ) {\n                    decrypted = zbee_sec_decrypt_payload( &packet, enc_buffer, offset, dec_buffer,\n                            payload_captured_len, mic_len, ((key_record_t *)(GSList_i->data))->key);\n\n                    if (decrypted) {\n                        /* save pointer to the successful key record */\n                        switch (packet.key_id) {\n                            case ZBEE_SEC_KEY_NWK:\n                                key_rec = nwk_hints->nwk = (key_record_t *)(GSList_i->data);\n                                break;\n\n                            default:\n                                key_rec = nwk_hints->link = (key_record_t *)(GSList_i->data);\n                                break;\n                        }\n                    } else {\n                        GSList_i = g_slist_next(GSList_i);\n                    }\n                }\n            }\n        } /* ( ! pinfo->fd->flags.visited ) */\n    } /* ( packet.src64 ) */\n\n    if ( decrypted ) {\n        if ( tree && key_rec ) {\n            key_item = proto_tree_add_bytes(sec_tree, hf_zbee_sec_key, tvb, 0, ZBEE_SEC_CONST_KEYSIZE, key_rec->key);\n            PROTO_ITEM_SET_GENERATED(key_item);\n\n            if ( key_rec->frame_num == ZBEE_SEC_PC_KEY ) {\n                ti = proto_tree_add_string(sec_tree, hf_zbee_sec_decryption_key, tvb, 0, 0, key_rec->label);\n            } else {\n                ti = proto_tree_add_uint(sec_tree, hf_zbee_sec_key_origin, tvb, 0, 0,\n                        key_rec->frame_num);\n            }\n            PROTO_ITEM_SET_GENERATED(ti);\n        }\n\n        /* Found a key that worked, setup the new tvbuff_t and return */\n        payload_tvb = tvb_new_child_real_data(tvb, dec_buffer, payload_captured_len, payload_reported_len);\n        tvb_set_free_cb(payload_tvb, g_free); /* set up callback to free dec_buffer */\n        add_new_data_source(pinfo, payload_tvb, \""Decrypted ZigBee Payload\"");\n\n        /* Done! */\n        return payload_tvb;\n    }\n\n    g_free(dec_buffer);\n#endif /* HAVE_LIBGCRYPT */\n\n    /* Add expert info. */\n    expert_add_info(pinfo, sec_tree, &ei_zbee_sec_encrypted_payload);\n    /* Create a buffer for the undecrypted payload. */\n    payload_tvb = tvb_new_subset_length(tvb, offset, payload_reported_len);\n    /* Dump the payload to the data dissector. */\n    call_dissector(data_handle, payload_tvb, pinfo, tree);\n    /* Couldn't decrypt, so return NULL. */\n    return NULL;\n}""}]","{""function"": 2, ""code"": 1}","[{""source"": ""func_info(func:tvb_captured_length_remaining)"", ""result"": [{""code"": ""gint\ntvb_captured_length_remaining(const tvbuff_t *tvb, const gint offset)\n{\n\tguint abs_offset, rem_length;\n\tint   exception;\n\n\tDISSECTOR_ASSERT(tvb && tvb->initialized);\n\n\texception = compute_offset_and_remaining(tvb, offset, &abs_offset, &rem_length);\n\tif (exception)\n\t\treturn 0;\n\n\treturn rem_length;\n}"", ""start_line"": 442, ""end_line"": 455, ""full_name"": ""tvb_captured_length_remaining"", ""file_path"": ""epan/tvbuff.c""}]}, {""source"": ""func_info(func:tvb_reported_length_remaining)"", ""result"": [{""code"": ""gint\ntvb_reported_length_remaining(const tvbuff_t *tvb, const gint offset)\n{\n\tguint abs_offset;\n\tint   exception;\n\n\tDISSECTOR_ASSERT(tvb && tvb->initialized);\n\n\texception = compute_offset(tvb, offset, &abs_offset);\n\tif (exception)\n\t\treturn 0;\n\n\tif (tvb->reported_length >= abs_offset)\n\t\treturn tvb->reported_length - abs_offset;\n\telse\n\t\treturn 0;\n}"", ""start_line"": 630, ""end_line"": 646, ""full_name"": ""tvb_reported_length_remaining"", ""file_path"": ""epan/tvbuff.c""}]}, {""source"": ""code_info(file:packet-zbee-security.c, lines:640-660)"", ""result"": ""        return NULL;\n    } else if ( payload_len < 0 ) {\n        THROW(ReportedBoundsError);\n    }\n\n    /**********************************************\n     *  Perform Security Operations on the Frame  *\n     **********************************************\n     */\n    if ((packet.level == ZBEE_SEC_NONE) ||\n        (packet.level == ZBEE_SEC_MIC32) ||\n        (packet.level == ZBEE_SEC_MIC64) ||\n        (packet.level == ZBEE_SEC_MIC128)) {\n\n        /* Payload is only integrity protected. Just return the sub-tvbuff. */\n        return tvb_new_subset_length(tvb, offset, payload_len);\n    }\n\n#ifdef HAVE_LIBGCRYPT\n    /* Allocate memory to decrypt the payload into. */\n    dec_buffer = (guint8 *)g_malloc(payload_len);\n\n""}]","The root cause is the use of tvb_reported_length_remaining (epan/dissectors/packet-zbee-security.c:637) instead of tvb_captured_length_remaining. This allowed an attacker to provide a packet with a large reported length while keeping the actual captured data small, leading to buffer allocation mismatches during decryption. The patch replaces this with tvb_captured_length_remaining (epan/tvbuff.c:442-455), which calculates remaining length based on actual captured data, not the reported length (epan/tvbuff.c:630-646). The payload_len is then used for tvb_new_subset_length (epan/dissectors/packet-zbee-security.c:640-660) and g_malloc, ensuring correct buffer allocation.",0.95,./github/other_context/CVE-2015-6244
71,CVE-2015-9059,CWE-77,c_cpp,picocom before 2.0 has a command injection vulnerability in the 'send and receive file' command because the command line is executed by /bin/sh unsafely.,https://github.com/npat-efault/picocom/commit/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1,"Do not use ""/bin/sh"" to run external commands.\n\nPicocom no longer uses /bin/sh to run external commands for\nfile-transfer operations. Parsing the command line and spliting it into\narguments is now performed internally by picocom, using quoting rules\nvery similar to those of the Unix shell. Hopefully, this makes it\nimpossible to inject shell-commands when supplying filenames or\nextra arguments to the send- and receive-file commands.",2,"[{""func_name"": ""do_command"", ""file_path"": ""picocom.c"", ""func_code"": ""int\ndo_command (unsigned char c)\n{\n\tstatic int dtr_up = 0;\n\tint newbaud, newflow, newparity, newbits;\n\tconst char *xfr_cmd;\n\tchar *fname;\n\tint r;\n\n\tswitch (c) {\n\tcase KEY_EXIT:\n\t\treturn 1;\n\tcase KEY_QUIT:\n\t\tterm_set_hupcl(tty_fd, 0);\n\t\tterm_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tterm_erase(tty_fd);\n\t\treturn 1;\n\tcase KEY_STATUS:\n\t\tshow_status(dtr_up);\n\t\tbreak;\n\tcase KEY_PULSE:\n\t\tfd_printf(STO, \""\\r\\n*** pulse DTR ***\\r\\n\"");\n\t\tif ( term_pulse_dtr(tty_fd) < 0 )\n\t\t\tfd_printf(STO, \""*** FAILED\\r\\n\"");\n\t\tbreak;\n\tcase KEY_TOGGLE:\n\t\tif ( dtr_up )\n\t\t\tr = term_lower_dtr(tty_fd);\n\t\telse\n\t\t\tr = term_raise_dtr(tty_fd);\n\t\tif ( r >= 0 ) dtr_up = ! dtr_up;\n\t\tfd_printf(STO, \""\\r\\n*** DTR: %s ***\\r\\n\"", \n\t\t\t\t  dtr_up ? \""up\"" : \""down\"");\n\t\tbreak;\n\tcase KEY_BAUD_UP:\n\tcase KEY_BAUD_DN:\n\t\tif (c == KEY_BAUD_UP)\n\t\t\topts.baud = baud_up(opts.baud);\n\t\telse \n\t\t\topts.baud = baud_down(opts.baud);\n\t\tterm_set_baudrate(tty_fd, opts.baud);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbaud = term_get_baudrate(tty_fd, NULL);\n\t\tif ( opts.baud != newbaud ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** baud: %d (%d) ***\\r\\n\"", \n\t\t\t\t\t  opts.baud, newbaud);\n\t\t} else {\n\t\t\tfd_printf(STO, \""\\r\\n*** baud: %d ***\\r\\n\"", opts.baud);\n\t\t}\n\t\tset_tty_write_sz(newbaud);\n\t\tbreak;\n\tcase KEY_FLOW:\n\t\topts.flow = flow_next(opts.flow);\n\t\tterm_set_flowcntrl(tty_fd, opts.flow);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewflow = term_get_flowcntrl(tty_fd);\n\t\tif ( opts.flow != newflow ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** flow: %s (%s) ***\\r\\n\"", \n\t\t\t\t\t  flow_str[opts.flow], flow_str[newflow]);\n\t\t} else {\n\t\t\tfd_printf(STO, \""\\r\\n*** flow: %s ***\\r\\n\"", \n\t\t\t\t\t  flow_str[opts.flow]);\n\t\t}\n\t\tbreak;\n\tcase KEY_PARITY:\n\t\topts.parity = parity_next(opts.parity);\n\t\tterm_set_parity(tty_fd, opts.parity);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewparity = term_get_parity(tty_fd);\n\t\tif (opts.parity != newparity ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** parity: %s (%s) ***\\r\\n\"",\n\t\t\t\t\t  parity_str[opts.parity], \n\t\t\t\t\t  parity_str[newparity]);\n\t\t} else {\n\t\t\tfd_printf(STO, \""\\r\\n*** parity: %s ***\\r\\n\"", \n\t\t\t\t\t  parity_str[opts.parity]);\n\t\t}\n\t\tbreak;\n\tcase KEY_BITS:\n\t\topts.databits = bits_next(opts.databits);\n\t\tterm_set_databits(tty_fd, opts.databits);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbits = term_get_databits(tty_fd);\n\t\tif (opts.databits != newbits ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** databits: %d (%d) ***\\r\\n\"",\n\t\t\t\t\t  opts.databits, newbits);\n\t\t} else {\n\t\t\tfd_printf(STO, \""\\r\\n*** databits: %d ***\\r\\n\"", \n\t\t\t\t\t  opts.databits);\n\t\t}\n\t\tbreak;\n\tcase KEY_LECHO:\n\t\topts.lecho = ! opts.lecho;\n\t\tfd_printf(STO, \""\\r\\n*** local echo: %s ***\\r\\n\"", \n\t\t\t\t  opts.lecho ? \""yes\"" : \""no\"");\n\t\tbreak;\n\tcase KEY_SEND:\n\tcase KEY_RECEIVE:\n\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** command disabled ***\\r\\n\"");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \""*** cannot read filename ***\\r\\n\"");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \""\\r\\n*** break sent ***\\r\\n\"");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""run_cmd"", ""file_path"": ""picocom.c"", ""func_code"": ""int\nrun_cmd(int fd, ...)\n{\n\tpid_t pid;\n\tsigset_t sigm, sigm_old;\n\n\t/* block signals, let child establish its own handlers */\n\tsigemptyset(&sigm);\n\tsigaddset(&sigm, SIGTERM);\n\tsigprocmask(SIG_BLOCK, &sigm, &sigm_old);\n\n\tpid = fork();\n\tif ( pid < 0 ) {\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\tfd_printf(STO, \""*** cannot fork: %s ***\\r\\n\"", strerror(errno));\n\t\treturn -1;\n\t} else if ( pid ) {\n\t\t/* father: picocom */\n\t\tint status, r;\n\n\t\t/* reset the mask */\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\t/* wait for child to finish */\n\t\tdo {\n\t\t\tr = waitpid(pid, &status, 0);\n\t\t} while ( r < 0 && errno == EINTR );\n\t\t/* reset terminal (back to raw mode) */\n\t\tterm_apply(STI);\n\t\t/* check and report child return status */\n\t\tif ( WIFEXITED(status) ) { \n\t\t\tfd_printf(STO, \""\\r\\n*** exit status: %d ***\\r\\n\"", \n\t\t\t\t\t  WEXITSTATUS(status));\n\t\t\treturn WEXITSTATUS(status);\n\t\t} else if ( WIFSIGNALED(status) ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** killed by signal: %d ***\\r\\n\"", \n\t\t\t\t\t  WTERMSIG(status));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tfd_printf(STO, \""\\r\\n*** abnormal termination: 0x%x ***\\r\\n\"", r);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* child: external program */\n\t\tlong fl;\n\t\tchar cmd[512];\n\n\t\t/* unmanage terminal, and reset it to canonical mode */\n\t\tterm_remove(STI);\n\t\t/* unmanage serial port fd, without reset */\n\t\tterm_erase(fd);\n\t\t/* set serial port fd to blocking mode */\n\t\tfl = fcntl(fd, F_GETFL); \n\t\tfl &= ~O_NONBLOCK;\n\t\tfcntl(fd, F_SETFL, fl);\n\t\t/* connect stdin and stdout to serial port */\n\t\tclose(STI);\n\t\tclose(STO);\n\t\tdup2(fd, STI);\n\t\tdup2(fd, STO);\n\t\t{\n\t\t\t/* build command-line */\n\t\t\tchar *c, *ce;\n\t\t\tconst char *s;\n\t\t\tint n;\n\t\t\tva_list vls;\n\t\t\t\n\t\t\tstrcpy(cmd, EXEC);\n\t\t\tc = &cmd[sizeof(EXEC)- 1];\n\t\t\tce = cmd + sizeof(cmd) - 1;\n\t\t\tva_start(vls, fd);\n\t\t\twhile ( (s = va_arg(vls, const char *)) ) {\n\t\t\t\tn = strlen(s);\n\t\t\t\tif ( c + n + 1 >= ce ) break;\n\t\t\t\tmemcpy(c, s, n); c += n;\n\t\t\t\t*c++ = ' ';\n\t\t\t}\n\t\t\tva_end(vls);\n\t\t\t*c = '\\0';\n\t\t}\n\t\t/* run extenral command */\n\t\tfd_printf(STDERR_FILENO, \""%s\\n\"", &cmd[sizeof(EXEC) - 1]);\n\t\testablish_child_signal_handlers();\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\texecl(\""/bin/sh\"", \""sh\"", \""-c\"", cmd, NULL);\n\t\texit(42);\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""do_command"", ""file_path"": ""picocom.c"", ""func_code"": ""int\ndo_command (unsigned char c)\n{\n\tstatic int dtr_up = 0;\n\tint newbaud, newflow, newparity, newbits;\n\tconst char *xfr_cmd;\n\tchar *fname;\n\tint r;\n\n\tswitch (c) {\n\tcase KEY_EXIT:\n\t\treturn 1;\n\tcase KEY_QUIT:\n\t\tterm_set_hupcl(tty_fd, 0);\n\t\tterm_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tterm_erase(tty_fd);\n\t\treturn 1;\n\tcase KEY_STATUS:\n\t\tshow_status(dtr_up);\n\t\tbreak;\n\tcase KEY_PULSE:\n\t\tfd_printf(STO, \""\\r\\n*** pulse DTR ***\\r\\n\"");\n\t\tif ( term_pulse_dtr(tty_fd) < 0 )\n\t\t\tfd_printf(STO, \""*** FAILED\\r\\n\"");\n\t\tbreak;\n\tcase KEY_TOGGLE:\n\t\tif ( dtr_up )\n\t\t\tr = term_lower_dtr(tty_fd);\n\t\telse\n\t\t\tr = term_raise_dtr(tty_fd);\n\t\tif ( r >= 0 ) dtr_up = ! dtr_up;\n\t\tfd_printf(STO, \""\\r\\n*** DTR: %s ***\\r\\n\"", \n\t\t\t\t  dtr_up ? \""up\"" : \""down\"");\n\t\tbreak;\n\tcase KEY_BAUD_UP:\n\tcase KEY_BAUD_DN:\n\t\tif (c == KEY_BAUD_UP)\n\t\t\topts.baud = baud_up(opts.baud);\n\t\telse \n\t\t\topts.baud = baud_down(opts.baud);\n\t\tterm_set_baudrate(tty_fd, opts.baud);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbaud = term_get_baudrate(tty_fd, NULL);\n\t\tif ( opts.baud != newbaud ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** baud: %d (%d) ***\\r\\n\"", \n\t\t\t\t\t  opts.baud, newbaud);\n\t\t} else {\n\t\t\tfd_printf(STO, \""\\r\\n*** baud: %d ***\\r\\n\"", opts.baud);\n\t\t}\n\t\tset_tty_write_sz(newbaud);\n\t\tbreak;\n\tcase KEY_FLOW:\n\t\topts.flow = flow_next(opts.flow);\n\t\tterm_set_flowcntrl(tty_fd, opts.flow);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewflow = term_get_flowcntrl(tty_fd);\n\t\tif ( opts.flow != newflow ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** flow: %s (%s) ***\\r\\n\"", \n\t\t\t\t\t  flow_str[opts.flow], flow_str[newflow]);\n\t\t} else {\n\t\t\tfd_printf(STO, \""\\r\\n*** flow: %s ***\\r\\n\"", \n\t\t\t\t\t  flow_str[opts.flow]);\n\t\t}\n\t\tbreak;\n\tcase KEY_PARITY:\n\t\topts.parity = parity_next(opts.parity);\n\t\tterm_set_parity(tty_fd, opts.parity);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewparity = term_get_parity(tty_fd);\n\t\tif (opts.parity != newparity ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** parity: %s (%s) ***\\r\\n\"",\n\t\t\t\t\t  parity_str[opts.parity], \n\t\t\t\t\t  parity_str[newparity]);\n\t\t} else {\n\t\t\tfd_printf(STO, \""\\r\\n*** parity: %s ***\\r\\n\"", \n\t\t\t\t\t  parity_str[opts.parity]);\n\t\t}\n\t\tbreak;\n\tcase KEY_BITS:\n\t\topts.databits = bits_next(opts.databits);\n\t\tterm_set_databits(tty_fd, opts.databits);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbits = term_get_databits(tty_fd);\n\t\tif (opts.databits != newbits ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** databits: %d (%d) ***\\r\\n\"",\n\t\t\t\t\t  opts.databits, newbits);\n\t\t} else {\n\t\t\tfd_printf(STO, \""\\r\\n*** databits: %d ***\\r\\n\"", \n\t\t\t\t\t  opts.databits);\n\t\t}\n\t\tbreak;\n\tcase KEY_LECHO:\n\t\topts.lecho = ! opts.lecho;\n\t\tfd_printf(STO, \""\\r\\n*** local echo: %s ***\\r\\n\"", \n\t\t\t\t  opts.lecho ? \""yes\"" : \""no\"");\n\t\tbreak;\n\tcase KEY_SEND:\n\tcase KEY_RECEIVE:\n\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** command disabled ***\\r\\n\"");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \""*** cannot read filename ***\\r\\n\"");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \""\\r\\n*** break sent ***\\r\\n\"");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}""}, {""func_name"": ""run_cmd"", ""file_path"": ""picocom.c"", ""func_code"": ""int\nrun_cmd(int fd, const char *cmd, const char *args_extra)\n{\n\tpid_t pid;\n\tsigset_t sigm, sigm_old;\n\n\t/* block signals, let child establish its own handlers */\n\tsigemptyset(&sigm);\n\tsigaddset(&sigm, SIGTERM);\n\tsigprocmask(SIG_BLOCK, &sigm, &sigm_old);\n\n\tpid = fork();\n\tif ( pid < 0 ) {\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\tfd_printf(STO, \""*** cannot fork: %s ***\\r\\n\"", strerror(errno));\n\t\treturn -1;\n\t} else if ( pid ) {\n\t\t/* father: picocom */\n\t\tint status, r;\n\n\t\t/* reset the mask */\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\t/* wait for child to finish */\n\t\tdo {\n\t\t\tr = waitpid(pid, &status, 0);\n\t\t} while ( r < 0 && errno == EINTR );\n\t\t/* reset terminal (back to raw mode) */\n\t\tterm_apply(STI);\n\t\t/* check and report child return status */\n\t\tif ( WIFEXITED(status) ) { \n\t\t\tfd_printf(STO, \""\\r\\n*** exit status: %d ***\\r\\n\"", \n\t\t\t\t\t  WEXITSTATUS(status));\n\t\t\treturn WEXITSTATUS(status);\n\t\t} else if ( WIFSIGNALED(status) ) {\n\t\t\tfd_printf(STO, \""\\r\\n*** killed by signal: %d ***\\r\\n\"", \n\t\t\t\t\t  WTERMSIG(status));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tfd_printf(STO, \""\\r\\n*** abnormal termination: 0x%x ***\\r\\n\"", r);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* child: external program */\n\t\tlong fl;\n\t\tint argc;\n\t\tchar *argv[RUNCMD_ARGS_MAX + 1];\n\t\tint r;\n\t\t\t\n\t\t/* unmanage terminal, and reset it to canonical mode */\n\t\tterm_remove(STI);\n\t\t/* unmanage serial port fd, without reset */\n\t\tterm_erase(fd);\n\t\t/* set serial port fd to blocking mode */\n\t\tfl = fcntl(fd, F_GETFL); \n\t\tfl &= ~O_NONBLOCK;\n\t\tfcntl(fd, F_SETFL, fl);\n\t\t/* connect stdin and stdout to serial port */\n\t\tclose(STI);\n\t\tclose(STO);\n\t\tdup2(fd, STI);\n\t\tdup2(fd, STO);\n\t\t\n\t\t/* build command arguments vector */\n\t\targc = 0;\n\t\tr = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);\n\t\tif ( r < 0 ) {\n\t\t\tfd_printf(STDERR_FILENO, \""Cannot parse command\\n\"");\n\t\t\texit(RUNCMD_EXEC_FAIL);\n\t\t}\n\t\tr = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);\n\t\tif ( r < 0 ) {\n\t\t\tfd_printf(STDERR_FILENO, \""Cannot parse extra args\\n\"");\n\t\t\texit(RUNCMD_EXEC_FAIL);\n\t\t}\n\t\tif ( argc < 1 ) {\n\t\t\tfd_printf(STDERR_FILENO, \""No command given\\n\"");\n\t\t\texit(RUNCMD_EXEC_FAIL);\n\t\t}\t\n\t\targv[argc] = NULL;\n\t\t\t\n\t\t/* run extenral command */\n\t\tfd_printf(STDERR_FILENO, \""$ %s %s\\n\"", cmd, args_extra);\n\t\testablish_child_signal_handlers();\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\texecvp(argv[0], argv);\n\n\t\tfd_printf(STDERR_FILENO, \""exec: %s\\n\"", strerror(errno));\n\t\texit(RUNCMD_EXEC_FAIL);\n\t}\n}""}]","{""function"": 2, ""value"": 1}","[{""source"": ""func_info(func:split_quoted)"", ""result"": [{""code"": ""int\nsplit_quoted (const char *s, int *argc, char *argv[], int argv_sz)\n{\n    char arg_buff[MAX_ARG_LEN]; /* current argument buffer */\n    char *ap, *ae;              /* arg_buff current ptr & end-guard */\n    const char *c;              /* current input charcter ptr */\n    char qc;                    /* current quote character */\n    enum states state;          /* current state */\n    enum err_codes err;         /* error end-code */\n    int flags;                  /* warning flags */\n\n    ap = &arg_buff[0];\n    ae = &arg_buff[MAX_ARG_LEN - 1];\n    c = &s[0];\n    state = ST_DELIM;\n    err = ERR_OK;\n    flags = 0;\n    qc = SQ; /* silence compiler waring */\n\n    while ( state != ST_END ) {\n        switch (state) {\n        case ST_DELIM:\n            while ( is_delim(*c) ) c++;\n            if ( *c == SQ || *c == DQ ) {\n                qc = *c; c++; state = ST_QUOTE; \n                break;\n            }\n            if ( *c == EOS ) {\n                state = ST_END;\n                break;\n            }\n            if ( *c == BS ) {\n                c++;\n                if ( *c == NL ) {\n                    c++;\n                    break;\n                }\n                if ( *c == EOS ) {\n                    state = ST_END; err = ERR_BS_AT_EOS;\n                    break;\n                }\n            }\n            /* All other cases incl. character after BS */\n            save(); c++; state = ST_ARG;\n            break;\n        case ST_QUOTE:\n            while ( *c != qc && ( *c != BS || qc == SQ ) && *c != EOS ) {\n                save(); c++;\n            }\n            if ( *c == qc ) {\n                c++; state = ST_ARG;\n                break;\n            }\n            if ( *c == BS ) {\n                assert (qc == DQ);\n                c++;\n                if ( *c == NL) {\n                    c++;\n                    break;\n                }\n                if (*c == EOS) {\n                    state = ST_END; err = ERR_BS_AT_EOS;\n                    break;\n                }\n                if ( ! is_dq_escapable(*c) ) {\n                    c--; save(); c++;\n                }\n                save(); c++;\n                break;\n            }\n            if ( *c == EOS ) {\n                state = ST_END; err = ERR_SQ_OPEN_AT_EOS;\n                break;\n            }\n            assert(0);\n        case ST_ARG:\n            if ( *c == SQ || *c == DQ ) {\n                qc = *c; c++; state = ST_QUOTE;\n                break;\n            }\n            if ( is_delim(*c) || *c == EOS ) {\n                push();\n                state = (*c == EOS) ? ST_END : ST_DELIM;\n                c++;\n                break;\n            }\n            if ( *c == BS ) {\n                c++;\n                if ( *c == NL ) {\n                    c++;\n                    break;\n                }\n                if ( *c == EOS ) {\n                    state = ST_END; err = ERR_BS_AT_EOS;\n                    break;\n                }\n            }\n            /* All other cases, incl. character after BS */\n            save(); c++;\n            break;\n        default:\n            assert(0);\n        }\n    }\n    \n    return ( err != ERR_OK ) ? -1 : flags;\n}\n"", ""start_line"": 86, ""end_line"": 192, ""full_name"": ""split_quoted"", ""file_path"": ""split.c""}]}, {""source"": ""func_info(file:split.c, func:split_quoted)"", ""result"": [{""code"": ""int\nsplit_quoted (const char *s, int *argc, char *argv[], int argv_sz)\n{\n    char arg_buff[MAX_ARG_LEN]; /* current argument buffer */\n    char *ap, *ae;              /* arg_buff current ptr & end-guard */\n    const char *c;              /* current input charcter ptr */\n    char qc;                    /* current quote character */\n    enum states state;          /* current state */\n    enum err_codes err;         /* error end-code */\n    int flags;                  /* warning flags */\n\n    ap = &arg_buff[0];\n    ae = &arg_buff[MAX_ARG_LEN - 1];\n    c = &s[0];\n    state = ST_DELIM;\n    err = ERR_OK;\n    flags = 0;\n    qc = SQ; /* silence compiler waring */\n\n    while ( state != ST_END ) {\n        switch (state) {\n        case ST_DELIM:\n            while ( is_delim(*c) ) c++;\n            if ( *c == SQ || *c == DQ ) {\n                qc = *c; c++; state = ST_QUOTE; \n                break;\n            }\n            if ( *c == EOS ) {\n                state = ST_END;\n                break;\n            }\n            if ( *c == BS ) {\n                c++;\n                if ( *c == NL ) {\n                    c++;\n                    break;\n                }\n                if ( *c == EOS ) {\n                    state = ST_END; err = ERR_BS_AT_EOS;\n                    break;\n                }\n            }\n            /* All other cases incl. character after BS */\n            save(); c++; state = ST_ARG;\n            break;\n        case ST_QUOTE:\n            while ( *c != qc && ( *c != BS || qc == SQ ) && *c != EOS ) {\n                save(); c++;\n            }\n            if ( *c == qc ) {\n                c++; state = ST_ARG;\n                break;\n            }\n            if ( *c == BS ) {\n                assert (qc == DQ);\n                c++;\n                if ( *c == NL) {\n                    c++;\n                    break;\n                }\n                if (*c == EOS) {\n                    state = ST_END; err = ERR_BS_AT_EOS;\n                    break;\n                }\n                if ( ! is_dq_escapable(*c) ) {\n                    c--; save(); c++;\n                }\n                save(); c++;\n                break;\n            }\n            if ( *c == EOS ) {\n                state = ST_END; err = ERR_SQ_OPEN_AT_EOS;\n                break;\n            }\n            assert(0);\n        case ST_ARG:\n            if ( *c == SQ || *c == DQ ) {\n                qc = *c; c++; state = ST_QUOTE;\n                break;\n            }\n            if ( is_delim(*c) || *c == EOS ) {\n                push();\n                state = (*c == EOS) ? ST_END : ST_DELIM;\n                c++;\n                break;\n            }\n            if ( *c == BS ) {\n                c++;\n                if ( *c == NL ) {\n                    c++;\n                    break;\n                }\n                if ( *c == EOS ) {\n                    state = ST_END; err = ERR_BS_AT_EOS;\n                    break;\n                }\n            }\n            /* All other cases, incl. character after BS */\n            save(); c++;\n            break;\n        default:\n            assert(0);\n        }\n    }\n    \n    return ( err != ERR_OK ) ? -1 : flags;\n}\n"", ""start_line"": 86, ""end_line"": 192, ""full_name"": ""split_quoted"", ""file_path"": ""split.c""}]}, {""source"": ""value_info(file:picocom.c, value:xfr_cmd)"", ""result"": {""value_trace"": [{""full_code"": ""xfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd"", ""line"": 937, ""func_name"": ""do_command""}], ""struct_var"": ""xfr_cmd"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}]","Original vulnerability: picocom.c:782-796 used `execl('/bin/sh', 'sh', '-c', cmd)` to execute commands, allowing shell injection via user-controlled input (e.g., filenames). Patch: Replaced with `execvp(argv[0], argv)` after parsing input with split_quoted(). split_quoted() (split.c:86-192) parses input into an argv array using quoting/escaping rules similar to the shell. The xfr_cmd (picocom.c:937) is set from opts.send_cmd/receive_cmd, which are user-provided configuration values. The patch prevents injection by eliminating /bin/sh and directly executing parsed arguments.",0.95,./github/other_context/CVE-2015-9059
72,CVE-2015-8718,CWE-20,c_cpp,"Double free vulnerability in epan/dissectors/packet-nlm.c in the NLM dissector in Wireshark 1.12.x before 1.12.9 and 2.0.x before 2.0.1, when the ""Match MSG/RES packets for async NLM"" option is enabled, allows remote attackers to cause a denial of service (application crash) via a crafted packet.",https://github.com/wireshark/wireshark/commit/81dfe6d450ada42d12f20ac26a6d8ae2302df37e,"NLM: fix double memory free when using ""Match MSG/RES packets for async NLM"" option\n\nChange-Id: Ie4f5f8e1ccf9d7b6c7fbee6126697c65f2cc17df\nReviewed-on: https://code.wireshark.org/review/11431\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",3,"[{""func_name"": ""nlm_register_unmatched_res"", ""file_path"": ""epan/dissectors/packet-nlm.c"", ""func_code"": ""static void\nnlm_register_unmatched_res(packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n\tnlm_msg_res_unmatched_data umd;\n\tnlm_msg_res_unmatched_data *old_umd;\n\n\tumd.cookie_len=tvb_get_ntohl(tvb, offset);\n\tumd.cookie=tvb_get_ptr(tvb, offset+4, -1);\n\n\t/* have we seen this cookie before? */\n\told_umd=(nlm_msg_res_unmatched_data *)g_hash_table_lookup(nlm_msg_res_unmatched, (gconstpointer)&umd);\n\tif(old_umd){\n\t\tnlm_msg_res_matched_data *md;\n\n\t\tmd=(nlm_msg_res_matched_data *)g_malloc(sizeof(nlm_msg_res_matched_data));\n\t\tmd->req_frame=old_umd->req_frame;\n\t\tmd->rep_frame=pinfo->fd->num;\n\t\tmd->ns=old_umd->ns;\n\t\tg_hash_table_insert(nlm_msg_res_matched, GINT_TO_POINTER(md->req_frame), (gpointer)md);\n\t\tg_hash_table_insert(nlm_msg_res_matched, GINT_TO_POINTER(md->rep_frame), (gpointer)md);\n\n\t\tg_hash_table_remove(nlm_msg_res_unmatched, (gconstpointer)old_umd);\n\t\tg_free((gpointer)old_umd->cookie);\n\t\tg_free(old_umd);\n\t}\n}"", ""target"": 0}, {""func_name"": ""nlm_register_unmatched_msg"", ""file_path"": ""epan/dissectors/packet-nlm.c"", ""func_code"": ""static void\nnlm_register_unmatched_msg(packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n\tnlm_msg_res_unmatched_data *umd;\n\tnlm_msg_res_unmatched_data *old_umd;\n\n\t/* allocate and build the unmatched structure for this request */\n\tumd=(nlm_msg_res_unmatched_data *)g_malloc(sizeof(nlm_msg_res_unmatched_data));\n\tumd->req_frame=pinfo->fd->num;\n\tumd->ns=pinfo->fd->abs_ts;\n\tumd->cookie_len=tvb_get_ntohl(tvb, offset);\n\tumd->cookie=(const guint8 *)tvb_memdup(NULL, tvb, offset+4, umd->cookie_len);\n\n\t/* remove any old duplicates */\n\told_umd=(nlm_msg_res_unmatched_data *)g_hash_table_lookup(nlm_msg_res_unmatched, (gconstpointer)umd);\n\tif(old_umd){\n\t\tg_hash_table_remove(nlm_msg_res_unmatched, (gconstpointer)old_umd);\n\t\tg_free((gpointer)old_umd->cookie);\n\t\tg_free(old_umd);\n\t}\n\n\t/* add new one */\n\tg_hash_table_insert(nlm_msg_res_unmatched, (gpointer)umd, (gpointer)umd);\n}"", ""target"": 0}, {""func_name"": ""nlm_msg_res_unmatched_value_destroy"", ""file_path"": ""epan/dissectors/packet-nlm.c"", ""func_code"": ""static void\nnlm_msg_res_unmatched_value_destroy(gpointer value)\n{\n\tnlm_msg_res_unmatched_data *umd = (nlm_msg_res_unmatched_data *)value;\n\n\tg_free((gpointer)umd->cookie);\n\tg_free(umd);\n}"", ""target"": 0}]","[{""func_name"": ""nlm_register_unmatched_res"", ""file_path"": ""epan/dissectors/packet-nlm.c"", ""func_code"": ""static void\nnlm_register_unmatched_res(packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n\tnlm_msg_res_unmatched_data umd;\n\tnlm_msg_res_unmatched_data *old_umd;\n\n\tumd.cookie_len=tvb_get_ntohl(tvb, offset);\n\tumd.cookie=tvb_get_ptr(tvb, offset+4, -1);\n\n\t/* have we seen this cookie before? */\n\told_umd=(nlm_msg_res_unmatched_data *)g_hash_table_lookup(nlm_msg_res_unmatched, (gconstpointer)&umd);\n\tif(old_umd){\n\t\tnlm_msg_res_matched_data *md_req, *md_rep;\n\n\t\tmd_req=(nlm_msg_res_matched_data *)g_malloc(sizeof(nlm_msg_res_matched_data));\n\t\tmd_req->req_frame=old_umd->req_frame;\n\t\tmd_req->rep_frame=pinfo->fd->num;\n\t\tmd_req->ns=old_umd->ns;\n\t\tmd_rep=(nlm_msg_res_matched_data *)g_memdup(md_req, sizeof(nlm_msg_res_matched_data));\n\t\tg_hash_table_insert(nlm_msg_res_matched, GINT_TO_POINTER(md_req->req_frame), (gpointer)md_req);\n\t\tg_hash_table_insert(nlm_msg_res_matched, GINT_TO_POINTER(md_rep->rep_frame), (gpointer)md_rep);\n\n\t\tg_hash_table_remove(nlm_msg_res_unmatched, (gconstpointer)old_umd);\n\t}\n}""}, {""func_name"": ""nlm_register_unmatched_msg"", ""file_path"": ""epan/dissectors/packet-nlm.c"", ""func_code"": ""static void\nnlm_register_unmatched_msg(packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n\tnlm_msg_res_unmatched_data *umd;\n\tnlm_msg_res_unmatched_data *old_umd;\n\n\t/* allocate and build the unmatched structure for this request */\n\tumd=(nlm_msg_res_unmatched_data *)g_malloc(sizeof(nlm_msg_res_unmatched_data));\n\tumd->req_frame=pinfo->fd->num;\n\tumd->ns=pinfo->fd->abs_ts;\n\tumd->cookie_len=tvb_get_ntohl(tvb, offset);\n\tumd->cookie=(const guint8 *)tvb_memdup(NULL, tvb, offset+4, umd->cookie_len);\n\n\t/* remove any old duplicates */\n\told_umd=(nlm_msg_res_unmatched_data *)g_hash_table_lookup(nlm_msg_res_unmatched, (gconstpointer)umd);\n\tif(old_umd){\n\t\tg_hash_table_remove(nlm_msg_res_unmatched, (gconstpointer)old_umd);\n\t}\n\n\t/* add new one */\n\tg_hash_table_insert(nlm_msg_res_unmatched, (gpointer)umd, (gpointer)umd);\n}""}, {""func_name"": ""nlm_msg_res_unmatched_value_destroy"", ""file_path"": ""epan/dissectors/packet-nlm.c"", ""func_code"": ""static void\nnlm_msg_res_unmatched_value_destroy(gpointer value)\n{\n\tnlm_msg_res_unmatched_data *umd = (nlm_msg_res_unmatched_data *)value;\n\n\twmem_free(NULL, (gpointer)umd->cookie);\n\tg_free(umd);\n}""}]","{""code"": 3, ""value"": 1}","[{""source"": ""code_info(file:packet-nlm.c, lines:100-140)"", ""result"": ""\tgood enough for now\n*/\ntypedef struct _nlm_msg_res_unmatched_data {\n\tint req_frame;\n\tnstime_t ns;\n\tint cookie_len;\n\tconst guint8 *cookie;\n} nlm_msg_res_unmatched_data;\n\ntypedef struct _nlm_msg_res_matched_data {\n\tint req_frame;\n\tint rep_frame;\n\tnstime_t ns;\n} nlm_msg_res_matched_data;\n\nstatic void\nnlm_msg_res_unmatched_value_destroy(gpointer value)\n{\n\tnlm_msg_res_unmatched_data *umd = (nlm_msg_res_unmatched_data *)value;\n\n\tg_free((gpointer)umd->cookie);\n\tg_free(umd);\n}\n\nstatic guint\nnlm_msg_res_unmatched_hash(gconstpointer k)\n{\n\tconst nlm_msg_res_unmatched_data *umd = (const nlm_msg_res_unmatched_data *)k;\n\tguint8 hash=0;\n\tint i;\n\n\tfor(i=0;i<umd->cookie_len;i++){\n\t\thash^=umd->cookie[i];\n\t}\n\n\treturn hash;\n}\nstatic guint\nnlm_msg_res_matched_hash(gconstpointer k)\n{\n\tguint hash = GPOINTER_TO_UINT(k);\n\n""}, {""source"": ""code_info(file:packet-nlm.c, lines:200-240)"", ""result"": ""{\n\tnlm_msg_res_matched_data *md;\n\n\tmd=(nlm_msg_res_matched_data *)g_hash_table_lookup(nlm_msg_res_matched, GINT_TO_POINTER(pinfo->fd->num));\n\tif(md){\n\t\tproto_tree_add_uint(tree, hf_nlm_reply_in, tvb, 0, 0, md->rep_frame);\n\t}\n}\nstatic void\nnlm_match_fhandle_reply(packet_info *pinfo, proto_tree *tree)\n{\n\tnlm_msg_res_matched_data *md;\n\n\tmd=(nlm_msg_res_matched_data *)g_hash_table_lookup(nlm_msg_res_matched, GINT_TO_POINTER(pinfo->fd->num));\n\tif(md && md->rep_frame){\n\t\tdissect_fhandle_hidden(pinfo,\n\t\t\t\ttree, md->req_frame);\n\t}\n}\nstatic void\nnlm_match_fhandle_request(packet_info *pinfo, proto_tree *tree)\n{\n\tnlm_msg_res_matched_data *md;\n\n\tmd=(nlm_msg_res_matched_data *)g_hash_table_lookup(nlm_msg_res_matched, GINT_TO_POINTER(pinfo->fd->num));\n\tif(md && md->rep_frame){\n\t\tdissect_fhandle_hidden(pinfo,\n\t\t\t\ttree, md->rep_frame);\n\t}\n}\n\nstatic void\nnlm_register_unmatched_res(packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n\tnlm_msg_res_unmatched_data umd;\n\tnlm_msg_res_unmatched_data *old_umd;\n\n\tumd.cookie_len=tvb_get_ntohl(tvb, offset);\n\tumd.cookie=tvb_get_ptr(tvb, offset+4, -1);\n\n\t/* have we seen this cookie before? */\n\told_umd=(nlm_msg_res_unmatched_data *)g_hash_table_lookup(nlm_msg_res_unmatched, (gconstpointer)&umd);\n""}, {""source"": ""code_info(file:packet-nlm.c, lines:140-200)"", ""result"": ""\tguint hash = GPOINTER_TO_UINT(k);\n\n\treturn hash;\n}\n\nstatic gint\nnlm_msg_res_unmatched_equal(gconstpointer k1, gconstpointer k2)\n{\n\tconst nlm_msg_res_unmatched_data *umd1 = (const nlm_msg_res_unmatched_data *)k1;\n\tconst nlm_msg_res_unmatched_data *umd2 = (const nlm_msg_res_unmatched_data *)k2;\n\n\tif(umd1->cookie_len!=umd2->cookie_len){\n\t\treturn 0;\n\t}\n\n\treturn( memcmp(umd1->cookie, umd2->cookie, umd1->cookie_len) == 0);\n}\nstatic gint\nnlm_msg_res_matched_equal(gconstpointer k1, gconstpointer k2)\n{\n\tguint mk1 = GPOINTER_TO_UINT(k1);\n\tguint mk2 = GPOINTER_TO_UINT(k2);\n\n\treturn( mk1==mk2 );\n}\n\nstatic void\nnlm_msg_res_match_init(void)\n{\n\tnlm_msg_res_unmatched =\n\t\tg_hash_table_new_full(nlm_msg_res_unmatched_hash,\n\t\tnlm_msg_res_unmatched_equal,\n\t\tNULL, nlm_msg_res_unmatched_value_destroy);\n\tnlm_msg_res_matched = g_hash_table_new_full(nlm_msg_res_matched_hash,\n\t\tnlm_msg_res_matched_equal, NULL, (GDestroyNotify)g_free);\n}\n\nstatic void\nnlm_msg_res_match_cleanup(void)\n{\n\tg_hash_table_destroy(nlm_msg_res_unmatched);\n\tg_hash_table_destroy(nlm_msg_res_matched);\n}\n\nstatic void\nnlm_print_msgres_reply(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb)\n{\n\tnlm_msg_res_matched_data *md;\n\n\tmd=(nlm_msg_res_matched_data *)g_hash_table_lookup(nlm_msg_res_matched, GINT_TO_POINTER(pinfo->fd->num));\n\tif(md){\n\t\tnstime_t ns;\n\t\tproto_tree_add_uint(tree, hf_nlm_request_in, tvb, 0, 0, md->req_frame);\n\t\tnstime_delta(&ns, &pinfo->fd->abs_ts, &md->ns);\n\t\tproto_tree_add_time(tree, hf_nlm_time, tvb, 0, 0, &ns);\n\t}\n}\n\nstatic void\nnlm_print_msgres_request(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb)\n{\n\tnlm_msg_res_matched_data *md;\n""}, {""source"": ""value_info(file:packet-nlm.c, value:nlm_msg_res_unmatched)"", ""result"": {""value_trace"": [{""full_code"": ""*nlm_msg_res_unmatched = NULL"", ""line"": 95, ""func_name"": ""epan/dissectors/packet-nlm.c:<global>""}], ""struct_var"": ""nlm_msg_res_unmatched"", ""struct_type"": ""GHashTable*"", ""struct_definition"": ""GHashTable""}}]","1. The vulnerability originates in `nlm_register_unmatched_res` (packet-nlm.c:241-252) and `nlm_register_unmatched_msg` (packet-nlm.c:273-277). Both functions perform a lookup using `g_hash_table_lookup` to retrieve `umd` from `nlm_msg_res_unmatched`. Evidence stops here for the insertion process of `umd` into the hash table.\n2. The `umd` structure is defined as `nlm_msg_res_unmatched_data` (packet-nlm.c:100-140) and initialized in `nlm_register_unmatched_res` using `tvb_get_ntohl` and `tvb_get_ptr` (packet-nlm.c:200-240). However, no evidence exists for its insertion into `nlm_msg_res_unmatched`.\n3. The destructor function `nlm_msg_res_unmatched_value_destroy` (packet-nlm.c:118) frees `umd->cookie` using `g_free`, which contributed to the vulnerability when combined with redundant free calls in `nlm_register_unmatched_res` and `nlm_register_unmatched_msg`.\n4. `nlm_msg_res_unmatched` is initialized as a `GHashTable*` in `nlm_msg_res_match_init` (packet-nlm.c:172-177), with custom hash, equality, and destructor functions. However, no evidence exists for the insertion of `umd` into this hash table.\nGAP: Evidence for the insertion of `umd` into `nlm_msg_res_unmatched` is missing. This prevents tracing the exact conditions under which the double free occurs. This gap is marked as unobtainable after exhausting all acquisition strategies.",0.95,./github/other_context/CVE-2015-8718
73,CVE-2016-4425,CWE-20,c_cpp,"Jansson 2.7 and earlier allows context-dependent attackers to cause a denial of service (deep recursion, stack consumption, and crash) via crafted JSON data.",https://github.com/akheron/jansson/commit/64ce0ad3731ebd77e02897b07920eadd0e2cc318,Fix for issue #282\n\nThe fix limits recursion depths when parsing arrays and objects.\nThe limit is configurable via the `JSON_PARSER_MAX_DEPTH` setting\nwithin `jansson_config.h` and is set by default to 2048.\n\nUpdate the RFC conformance document to note the limit; the RFC\nallows limits to be set by the implementation so nothing has\nactually changed w.r.t. conformance state.\n\nReported by Gustavo Grieco.,2,"[{""func_name"": ""parse_json"", ""file_path"": ""src/load.c"", ""func_code"": ""static json_t *parse_json(lex_t *lex, size_t flags, json_error_t *error)\n{\n    json_t *result;\n\n    lex_scan(lex, error);\n    if(!(flags & JSON_DECODE_ANY)) {\n        if(lex->token != '[' && lex->token != '{') {\n            error_set(error, lex, \""'[' or '{' expected\"");\n            return NULL;\n        }\n    }\n\n    result = parse_value(lex, flags, error);\n    if(!result)\n        return NULL;\n\n    if(!(flags & JSON_DISABLE_EOF_CHECK)) {\n        lex_scan(lex, error);\n        if(lex->token != TOKEN_EOF) {\n            error_set(error, lex, \""end of file expected\"");\n            json_decref(result);\n            return NULL;\n        }\n    }\n\n    if(error) {\n        /* Save the position even though there was no error */\n        error->position = (int)lex->stream.position;\n    }\n\n    return result;\n}"", ""target"": 0}, {""func_name"": ""parse_value"", ""file_path"": ""src/load.c"", ""func_code"": ""static json_t *parse_value(lex_t *lex, size_t flags, json_error_t *error)\n{\n    json_t *json;\n\n    switch(lex->token) {\n        case TOKEN_STRING: {\n            const char *value = lex->value.string.val;\n            size_t len = lex->value.string.len;\n\n            if(!(flags & JSON_ALLOW_NUL)) {\n                if(memchr(value, '\\0', len)) {\n                    error_set(error, lex, \""\\\\u0000 is not allowed without JSON_ALLOW_NUL\"");\n                    return NULL;\n                }\n            }\n\n            json = jsonp_stringn_nocheck_own(value, len);\n            if(json) {\n                lex->value.string.val = NULL;\n                lex->value.string.len = 0;\n            }\n            break;\n        }\n\n        case TOKEN_INTEGER: {\n            json = json_integer(lex->value.integer);\n            break;\n        }\n\n        case TOKEN_REAL: {\n            json = json_real(lex->value.real);\n            break;\n        }\n\n        case TOKEN_TRUE:\n            json = json_true();\n            break;\n\n        case TOKEN_FALSE:\n            json = json_false();\n            break;\n\n        case TOKEN_NULL:\n            json = json_null();\n            break;\n\n        case '{':\n            json = parse_object(lex, flags, error);\n            break;\n\n        case '[':\n            json = parse_array(lex, flags, error);\n            break;\n\n        case TOKEN_INVALID:\n            error_set(error, lex, \""invalid token\"");\n            return NULL;\n\n        default:\n            error_set(error, lex, \""unexpected token\"");\n            return NULL;\n    }\n\n    if(!json)\n        return NULL;\n\n    return json;\n}"", ""target"": 0}]","[{""func_name"": ""parse_json"", ""file_path"": ""src/load.c"", ""func_code"": ""static json_t *parse_json(lex_t *lex, size_t flags, json_error_t *error)\n{\n    json_t *result;\n\n    lex->depth = 0;\n\n    lex_scan(lex, error);\n    if(!(flags & JSON_DECODE_ANY)) {\n        if(lex->token != '[' && lex->token != '{') {\n            error_set(error, lex, \""'[' or '{' expected\"");\n            return NULL;\n        }\n    }\n\n    result = parse_value(lex, flags, error);\n    if(!result)\n        return NULL;\n\n    if(!(flags & JSON_DISABLE_EOF_CHECK)) {\n        lex_scan(lex, error);\n        if(lex->token != TOKEN_EOF) {\n            error_set(error, lex, \""end of file expected\"");\n            json_decref(result);\n            return NULL;\n        }\n    }\n\n    if(error) {\n        /* Save the position even though there was no error */\n        error->position = (int)lex->stream.position;\n    }\n\n    return result;\n}""}, {""func_name"": ""parse_value"", ""file_path"": ""src/load.c"", ""func_code"": ""static json_t *parse_value(lex_t *lex, size_t flags, json_error_t *error)\n{\n    json_t *json;\n\n    lex->depth++;\n    if(lex->depth > JSON_PARSER_MAX_DEPTH) {\n        error_set(error, lex, \""maximum parsing depth reached\"");\n        return NULL;\n    }\n\n    switch(lex->token) {\n        case TOKEN_STRING: {\n            const char *value = lex->value.string.val;\n            size_t len = lex->value.string.len;\n\n            if(!(flags & JSON_ALLOW_NUL)) {\n                if(memchr(value, '\\0', len)) {\n                    error_set(error, lex, \""\\\\u0000 is not allowed without JSON_ALLOW_NUL\"");\n                    return NULL;\n                }\n            }\n\n            json = jsonp_stringn_nocheck_own(value, len);\n            if(json) {\n                lex->value.string.val = NULL;\n                lex->value.string.len = 0;\n            }\n            break;\n        }\n\n        case TOKEN_INTEGER: {\n            json = json_integer(lex->value.integer);\n            break;\n        }\n\n        case TOKEN_REAL: {\n            json = json_real(lex->value.real);\n            break;\n        }\n\n        case TOKEN_TRUE:\n            json = json_true();\n            break;\n\n        case TOKEN_FALSE:\n            json = json_false();\n            break;\n\n        case TOKEN_NULL:\n            json = json_null();\n            break;\n\n        case '{':\n            json = parse_object(lex, flags, error);\n            break;\n\n        case '[':\n            json = parse_array(lex, flags, error);\n            break;\n\n        case TOKEN_INVALID:\n            error_set(error, lex, \""invalid token\"");\n            return NULL;\n\n        default:\n            error_set(error, lex, \""unexpected token\"");\n            return NULL;\n    }\n\n    if(!json)\n        return NULL;\n\n    lex->depth--;\n    return json;\n}""}]","{""caller"": 1}","[{""source"": ""caller_info(file:load.c, func:parse_value)"", ""result"": [{""call_line"": 728, ""call_code"": ""parse_value(lex, flags, error)"", ""caller_code"": ""static json_t *parse_object(lex_t *lex, size_t flags, json_error_t *error)\n{\n    json_t *object = json_object();\n    if(!object)\n        return NULL;\n\n    lex_scan(lex, error);\n    if(lex->token == '}')\n        return object;\n\n    while(1) {\n        char *key;\n        size_t len;\n        json_t *value;\n\n        if(lex->token != TOKEN_STRING) {\n            error_set(error, lex, \""string or '}' expected\"");\n            goto error;\n        }\n\n        key = lex_steal_string(lex, &len);\n        if(!key)\n            return NULL;\n        if (memchr(key, '\\0', len)) {\n            jsonp_free(key);\n            error_set(error, lex, \""NUL byte in object key not supported\"");\n            goto error;\n        }\n\n        if(flags & JSON_REJECT_DUPLICATES) {\n            if(json_object_get(object, key)) {\n                jsonp_free(key);\n                error_set(error, lex, \""duplicate object key\"");\n                goto error;\n            }\n        }\n\n        lex_scan(lex, error);\n        if(lex->token != ':') {\n            jsonp_free(key);\n            error_set(error, lex, \""':' expected\"");\n            goto error;\n        }\n\n        lex_scan(lex, error);\n        value = parse_value(lex, flags, error);\n        if(!value) {\n            jsonp_free(key);\n            goto error;\n        }\n\n        if(json_object_set_nocheck(object, key, value)) {\n            jsonp_free(key);\n            json_decref(value);\n            goto error;\n        }\n\n        json_decref(value);\n        jsonp_free(key);\n\n        lex_scan(lex, error);\n        if(lex->token != ',')\n            break;\n\n        lex_scan(lex, error);\n    }\n\n    if(lex->token != '}') {\n        error_set(error, lex, \""'}' expected\"");\n        goto error;\n    }\n\n    return object;\n\nerror:\n    json_decref(object);\n    return NULL;\n}\n"", ""caller_start"": 683, ""file_path"": ""src/load.c""}, {""call_line"": 773, ""call_code"": ""parse_value(lex, flags, error)"", ""caller_code"": ""static json_t *parse_array(lex_t *lex, size_t flags, json_error_t *error)\n{\n    json_t *array = json_array();\n    if(!array)\n        return NULL;\n\n    lex_scan(lex, error);\n    if(lex->token == ']')\n        return array;\n\n    while(lex->token) {\n        json_t *elem = parse_value(lex, flags, error);\n        if(!elem)\n            goto error;\n\n        if(json_array_append(array, elem)) {\n            json_decref(elem);\n            goto error;\n        }\n        json_decref(elem);\n\n        lex_scan(lex, error);\n        if(lex->token != ',')\n            break;\n\n        lex_scan(lex, error);\n    }\n\n    if(lex->token != ']') {\n        error_set(error, lex, \""']' expected\"");\n        goto error;\n    }\n\n    return array;\n\nerror:\n    json_decref(array);\n    return NULL;\n}"", ""caller_start"": 762, ""file_path"": ""src/load.c""}, {""call_line"": 883, ""call_code"": ""parse_value(lex, flags, error)"", ""caller_code"": ""static json_t *parse_json(lex_t *lex, size_t flags, json_error_t *error)\n{\n    json_t *result;\n\n    lex_scan(lex, error);\n    if(!(flags & JSON_DECODE_ANY)) {\n        if(lex->token != '[' && lex->token != '{') {\n            error_set(error, lex, \""'[' or '{' expected\"");\n            return NULL;\n        }\n    }\n\n    result = parse_value(lex, flags, error);\n    if(!result)\n        return NULL;\n\n    if(!(flags & JSON_DISABLE_EOF_CHECK)) {\n        lex_scan(lex, error);\n        if(lex->token != TOKEN_EOF) {\n            error_set(error, lex, \""end of file expected\"");\n            json_decref(result);\n            return NULL;\n        }\n    }\n\n    if(error) {\n        /* Save the position even though there was no error */\n        error->position = (int)lex->stream.position;\n    }\n\n    return result;\n}"", ""caller_start"": 871, ""file_path"": ""src/load.c""}]}]","Recursion depth tracking is added in `parse_value` (src/load.c:803-810, 866-872) to limit parsing depth. Depth is initialized in `parse_json` (src/load.c:872). Recursive calls to `parse_value` occur via `parse_array` (src/load.c:773) and `parse_object` (src/load.c:728), which are called by `parse_value` for nested arrays/objects. Excessive recursion would trigger `lex->depth > JSON_PARSER_MAX_DEPTH` (src/load.c:805).",0.95,./github/other_context/CVE-2016-4425
74,CVE-2016-5351,CWE-20,c_cpp,"epan/crypt/airpdcap.c in the IEEE 802.11 dissector in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles the lack of an EAPOL_RSN_KEY, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",https://github.com/wireshark/wireshark/commit/9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4,Make sure EAPOL body is big enough for a EAPOL_RSN_KEY.\n\nA pointer to a EAPOL_RSN_KEY is set on the packet presuming the\nwhole EAPOL_RSN_KEY is there.  That's not always the case for\nfuzzed/malicious captures.\n\nBug: 11585\nChange-Id: Ib94b8aceef444c7820e43b969596efdb8dbecccd\nReviewed-on: https://code.wireshark.org/review/15540\nReviewed-by: Michael Mann <mmann78@netscape.net>\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>,1,"[{""func_name"": ""AirPDcapScanForKeys"", ""file_path"": ""epan/crypt/airpdcap.c"", ""func_code"": ""static INT AirPDcapScanForKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    AIRPDCAP_SEC_ASSOCIATION_ID id\n)\n{\n    const UCHAR *addr;\n    guint bodyLength;\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\n    PAIRPDCAP_SEC_ASSOCIATION sa;\n    guint offset = 0;\n    const guint8 dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x88, 0x8E        /* Type: 802.1X authentication */\n    };\n    const guint8 bt_dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\n        0x00, 0x03        /* Type: Bluetooth Security */\n    };\n    const guint8 tdls_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\n        0x02,             /* Payload Type: TDLS */\n        0X0C              /* Action Category: TDLS */\n    };\n\n    const EAPOL_RSN_KEY *pEAPKey;\n#ifdef _DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n    AIRPDCAP_DEBUG_TRACE_START(\""AirPDcapScanForKeys\"");\n\n    /* cache offset in the packet data */\n    offset = mac_header_len;\n\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Authentication: EAPOL packet\"", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=8;\n\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\n        if (data[offset+1]!=3) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Not EAPOL-Key\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\n        bodyLength=pntoh16(data+offset+2);\n        if ((tot_len-offset-4) < bodyLength) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""EAPOL body too short\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip EAPOL MPDU and go to the first byte of the body */\n        offset+=4;\n\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\n\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Not valid key descriptor type\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* start with descriptor body */\n        offset+=1;\n\n        /* search for a cached Security Association for current BSSID and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""No SA for BSSID found\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* It could be a Pairwise Key exchange, check */\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Message too short for Group Key\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Key bitfields not correct for Group Key\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n        /* get the Security Association structure for the broadcast MAC and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\n\n        /* get STA address */\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\n#ifdef _DEBUG\n            g_snprintf(msgbuf, MSGBUF_LEN, \""ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\"", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n#endif\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""SA not found\"", AIRPDCAP_DEBUG_LEVEL_5);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sta_sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Try to extract the group key and install it in the SA */\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\n\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\n        const guint8 *initiator, *responder;\n        guint8 action;\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\n        AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Authentication: TDLS Action Frame\"", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=10;\n\n        /* check if the packet is a TDLS response or confirm */\n        action = data[offset];\n        if (action!=1 && action!=2) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Not Response nor confirm\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* check status */\n        offset++;\n        status=pntoh16(data+offset);\n        if (status!=0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""TDLS setup not successfull\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip Token + capabilities */\n        offset+=5;\n\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\n\n        while(offset < (tot_len - 2)) {\n            if (data[offset] == 48) {\n                offset_rsne = offset;\n            } else if (data[offset] == 55) {\n                offset_fte = offset;\n            } else if (data[offset] == 56) {\n                offset_timeout = offset;\n            } else if (data[offset] == 101) {\n                offset_link = offset;\n            }\n\n            if (tot_len < offset + data[offset + 1] + 2) {\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n            offset += data[offset + 1] + 2;\n        }\n\n        if (offset_rsne == 0 || offset_fte == 0 ||\n            offset_timeout == 0 || offset_link == 0)\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Cannot Find all necessary IEs\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Found RSNE/Fast BSS/Timeout Interval/Link IEs\"", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\n        initiator = &data[offset_link + 8];\n        responder = &data[offset_link + 14];\n\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\n        }\n\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        if (sa->validKey) {\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\n                /* Already have valid key for this SA, no need to redo key derivation */\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n            } else {\n                /* We are opening a new session with the same two STA, save previous sa  */\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n                sa->next=tmp_sa;\n                sa->validKey = FALSE;\n            }\n        }\n\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\n            == AIRPDCAP_RET_SUCCESS) {\n            AIRPDCAP_DEBUG_TRACE_END(\""AirPDcapScanForKeys\"");\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    } else {\n        AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Skipping: not an EAPOL packet\"", AIRPDCAP_DEBUG_LEVEL_3);\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\""AirPDcapScanForKeys\"");\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}"", ""target"": 0}]","[{""func_name"": ""AirPDcapScanForKeys"", ""file_path"": ""epan/crypt/airpdcap.c"", ""func_code"": ""static INT AirPDcapScanForKeys(\n    PAIRPDCAP_CONTEXT ctx,\n    const guint8 *data,\n    const guint mac_header_len,\n    const guint tot_len,\n    AIRPDCAP_SEC_ASSOCIATION_ID id\n)\n{\n    const UCHAR *addr;\n    guint bodyLength;\n    PAIRPDCAP_SEC_ASSOCIATION sta_sa;\n    PAIRPDCAP_SEC_ASSOCIATION sa;\n    guint offset = 0;\n    const guint8 dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x88, 0x8E        /* Type: 802.1X authentication */\n    };\n    const guint8 bt_dot1x_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */\n        0x00, 0x03        /* Type: Bluetooth Security */\n    };\n    const guint8 tdls_header[] = {\n        0xAA,             /* DSAP=SNAP */\n        0xAA,             /* SSAP=SNAP */\n        0x03,             /* Control field=Unnumbered frame */\n        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */\n        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */\n        0x02,             /* Payload Type: TDLS */\n        0X0C              /* Action Category: TDLS */\n    };\n\n    const EAPOL_RSN_KEY *pEAPKey;\n#ifdef _DEBUG\n#define MSGBUF_LEN 255\n    CHAR msgbuf[MSGBUF_LEN];\n#endif\n    AIRPDCAP_DEBUG_TRACE_START(\""AirPDcapScanForKeys\"");\n\n    /* cache offset in the packet data */\n    offset = mac_header_len;\n\n    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */\n    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Authentication: EAPOL packet\"", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=8;\n\n        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */\n        if (data[offset+1]!=3) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Not EAPOL-Key\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* get and check the body length (IEEE 802.1X-2004, pg. 25) */\n        bodyLength=pntoh16(data+offset+2);\n        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""EAPOL body too short\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip EAPOL MPDU and go to the first byte of the body */\n        offset+=4;\n\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\n\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Not valid key descriptor type\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* start with descriptor body */\n        offset+=1;\n\n        /* search for a cached Security Association for current BSSID and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""No SA for BSSID found\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* It could be a Pairwise Key exchange, check */\n        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n\n        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Message too short for Group Key\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */\n        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\n            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\n            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||\n            AIRPDCAP_EAP_SEC(data[offset]) != 1){\n\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Key bitfields not correct for Group Key\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */\n        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\n\n        /* get the Security Association structure for the broadcast MAC and AP */\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */\n\n        /* get STA address */\n        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\n            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\n#ifdef _DEBUG\n            g_snprintf(msgbuf, MSGBUF_LEN, \""ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\\t\"", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\n#endif\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\n        } else {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""SA not found\"", AIRPDCAP_DEBUG_LEVEL_5);\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        sta_sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sta_sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        /* Try to extract the group key and install it in the SA */\n        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\n\n    } else if (memcmp(data+offset, tdls_header, 10) == 0) {\n        const guint8 *initiator, *responder;\n        guint8 action;\n        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\n        AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Authentication: TDLS Action Frame\"", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* skip LLC header */\n        offset+=10;\n\n        /* check if the packet is a TDLS response or confirm */\n        action = data[offset];\n        if (action!=1 && action!=2) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Not Response nor confirm\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* check status */\n        offset++;\n        status=pntoh16(data+offset);\n        if (status!=0) {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""TDLS setup not successfull\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip Token + capabilities */\n        offset+=5;\n\n        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */\n\n        while(offset < (tot_len - 2)) {\n            if (data[offset] == 48) {\n                offset_rsne = offset;\n            } else if (data[offset] == 55) {\n                offset_fte = offset;\n            } else if (data[offset] == 56) {\n                offset_timeout = offset;\n            } else if (data[offset] == 101) {\n                offset_link = offset;\n            }\n\n            if (tot_len < offset + data[offset + 1] + 2) {\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n            offset += data[offset + 1] + 2;\n        }\n\n        if (offset_rsne == 0 || offset_fte == 0 ||\n            offset_timeout == 0 || offset_link == 0)\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Cannot Find all necessary IEs\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Found RSNE/Fast BSS/Timeout Interval/Link IEs\"", AIRPDCAP_DEBUG_LEVEL_3);\n\n        /* Will create a Security Association between 2 STA. Need to get both MAC address */\n        initiator = &data[offset_link + 8];\n        responder = &data[offset_link + 14];\n\n        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\n            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\n        } else {\n            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\n            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\n        }\n\n        sa = AirPDcapGetSaPtr(ctx, &id);\n        if (sa == NULL){\n            return AIRPDCAP_RET_REQ_DATA;\n        }\n\n        if (sa->validKey) {\n            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\n                /* Already have valid key for this SA, no need to redo key derivation */\n                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n            } else {\n                /* We are opening a new session with the same two STA, save previous sa  */\n                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\n                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n                sa->next=tmp_sa;\n                sa->validKey = FALSE;\n            }\n        }\n\n        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\n            == AIRPDCAP_RET_SUCCESS) {\n            AIRPDCAP_DEBUG_TRACE_END(\""AirPDcapScanForKeys\"");\n            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n        }\n    } else {\n        AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Skipping: not an EAPOL packet\"", AIRPDCAP_DEBUG_LEVEL_3);\n    }\n\n    AIRPDCAP_DEBUG_TRACE_END(\""AirPDcapScanForKeys\"");\n    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n}""}]","{""code"": 1}","[{""source"": ""code_info(file:airpdcap.c, lines:575-590)"", ""result"": ""            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""EAPOL body too short\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        /* skip EAPOL MPDU and go to the first byte of the body */\n        offset+=4;\n\n        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\n\n        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */\n        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */\n            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */\n        {\n            AIRPDCAP_DEBUG_PRINT_LINE(\""AirPDcapScanForKeys\"", \""Not valid key descriptor type\"", AIRPDCAP_DEBUG_LEVEL_3);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n""}]","The root cause is the lack of validation in `airpdcap.c:572` to ensure `bodyLength` is at least `sizeof(EAPOL_RSN_KEY)` before assigning and dereferencing `pEAPKey` at `airpdcap.c:575-576`. This allows processing packets with insufficient data, leading to a crash when accessing `pEAPKey->type`.",0.95,./github/other_context/CVE-2016-5351
75,CVE-2016-6129,CWE-20,c_cpp,"The rsa_verify_hash_ex function in rsa_verify_hash.c in LibTomCrypt, as used in OP-TEE before 2.2.0, does not validate that the message length is equal to the ASN.1 encoded data length, which makes it easier for remote attackers to forge RSA signatures or public certificates by leveraging a Bleichenbacher signature forgery attack.",https://github.com/libtom/libtomcrypt/commit/5eb9743410ce4657e9d54fef26a2ee31a1b5dd09,rsa_verify_hash: fix possible bleichenbacher signature attack,1,"[{""func_name"": ""rsa_verify_hash_ex"", ""file_path"": ""src/pk/rsa/rsa_verify_hash.c"", ""func_code"": ""int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n                       const unsigned char *hash,     unsigned long hashlen,\n                             int            padding,\n                             int            hash_idx, unsigned long saltlen,\n                             int           *stat,     rsa_key      *key)\n{\n  unsigned long modulus_bitlen, modulus_bytelen, x;\n  int           err;\n  unsigned char *tmpbuf;\n\n  LTC_ARGCHK(hash  != NULL);\n  LTC_ARGCHK(sig   != NULL);\n  LTC_ARGCHK(stat  != NULL);\n  LTC_ARGCHK(key   != NULL);\n\n  /* default to invalid */\n  *stat = 0;\n\n  /* valid padding? */\n\n  if ((padding != LTC_PKCS_1_V1_5) &&\n      (padding != LTC_PKCS_1_PSS)) {\n    return CRYPT_PK_INVALID_PADDING;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    /* valid hash ? */\n    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {\n       return err;\n    }\n  }\n\n  /* get modulus len in bits */\n  modulus_bitlen = mp_count_bits( (key->N));\n\n  /* outlen must be at least the size of the modulus */\n  modulus_bytelen = mp_unsigned_bin_size( (key->N));\n  if (modulus_bytelen != siglen) {\n     return CRYPT_INVALID_PACKET;\n  }\n\n  /* allocate temp buffer for decoded sig */\n  tmpbuf = XMALLOC(siglen);\n  if (tmpbuf == NULL) {\n     return CRYPT_MEM;\n  }\n\n  /* RSA decode it  */\n  x = siglen;\n  if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {\n     XFREE(tmpbuf);\n     return err;\n  }\n\n  /* make sure the output is the right size */\n  if (x != siglen) {\n     XFREE(tmpbuf);\n     return CRYPT_INVALID_PACKET;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    /* PSS decode and verify it */\n\n    if(modulus_bitlen%8 == 1){\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n    else{\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n\n  } else {\n    /* PKCS #1 v1.5 decode it */\n    unsigned char *out;\n    unsigned long outlen, loid[16];\n    int           decoded;\n    ltc_asn1_list digestinfo[2], siginfo[2];\n\n    /* not all hashes have OIDs... so sad */\n    if (hash_descriptor[hash_idx].OIDlen == 0) {\n       err = CRYPT_INVALID_ARG;\n       goto bail_2;\n    }\n\n    /* allocate temp buffer for decoded hash */\n    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;\n    out    = XMALLOC(outlen);\n    if (out == NULL) {\n      err = CRYPT_MEM;\n      goto bail_2;\n    }\n\n    if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {\n      XFREE(out);\n      goto bail_2;\n    }\n\n    /* now we must decode out[0...outlen-1] using ASN.1, test the OID and then test the hash */\n    /* construct the SEQUENCE\n      SEQUENCE {\n         SEQUENCE {hashoid OID\n                   blah    NULL\n         }\n         hash    OCTET STRING\n      }\n   */\n    LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));\n    LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);\n    LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);\n    LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);\n\n    if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) {\n       XFREE(out);\n       goto bail_2;\n    }\n\n    /* test OID */\n    if ((digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n        (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&\n        (siginfo[1].size == hashlen) &&\n        (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {\n       *stat = 1;\n    }\n\n#ifdef LTC_CLEAN_STACK\n    zeromem(out, outlen);\n#endif\n    XFREE(out);\n  }\n\nbail_2:\n#ifdef LTC_CLEAN_STACK\n  zeromem(tmpbuf, siglen);\n#endif\n  XFREE(tmpbuf);\n  return err;\n}"", ""target"": 0}]","[{""func_name"": ""rsa_verify_hash_ex"", ""file_path"": ""src/pk/rsa/rsa_verify_hash.c"", ""func_code"": ""int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n                       const unsigned char *hash,     unsigned long hashlen,\n                             int            padding,\n                             int            hash_idx, unsigned long saltlen,\n                             int           *stat,     rsa_key      *key)\n{\n  unsigned long modulus_bitlen, modulus_bytelen, x;\n  int           err;\n  unsigned char *tmpbuf;\n\n  LTC_ARGCHK(hash  != NULL);\n  LTC_ARGCHK(sig   != NULL);\n  LTC_ARGCHK(stat  != NULL);\n  LTC_ARGCHK(key   != NULL);\n\n  /* default to invalid */\n  *stat = 0;\n\n  /* valid padding? */\n\n  if ((padding != LTC_PKCS_1_V1_5) &&\n      (padding != LTC_PKCS_1_PSS)) {\n    return CRYPT_PK_INVALID_PADDING;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    /* valid hash ? */\n    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {\n       return err;\n    }\n  }\n\n  /* get modulus len in bits */\n  modulus_bitlen = mp_count_bits( (key->N));\n\n  /* outlen must be at least the size of the modulus */\n  modulus_bytelen = mp_unsigned_bin_size( (key->N));\n  if (modulus_bytelen != siglen) {\n     return CRYPT_INVALID_PACKET;\n  }\n\n  /* allocate temp buffer for decoded sig */\n  tmpbuf = XMALLOC(siglen);\n  if (tmpbuf == NULL) {\n     return CRYPT_MEM;\n  }\n\n  /* RSA decode it  */\n  x = siglen;\n  if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {\n     XFREE(tmpbuf);\n     return err;\n  }\n\n  /* make sure the output is the right size */\n  if (x != siglen) {\n     XFREE(tmpbuf);\n     return CRYPT_INVALID_PACKET;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    /* PSS decode and verify it */\n\n    if(modulus_bitlen%8 == 1){\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n    else{\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n\n  } else {\n    /* PKCS #1 v1.5 decode it */\n    unsigned char *out;\n    unsigned long outlen, loid[16], reallen;\n    int           decoded;\n    ltc_asn1_list digestinfo[2], siginfo[2];\n\n    /* not all hashes have OIDs... so sad */\n    if (hash_descriptor[hash_idx].OIDlen == 0) {\n       err = CRYPT_INVALID_ARG;\n       goto bail_2;\n    }\n\n    /* allocate temp buffer for decoded hash */\n    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;\n    out    = XMALLOC(outlen);\n    if (out == NULL) {\n      err = CRYPT_MEM;\n      goto bail_2;\n    }\n\n    if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {\n      XFREE(out);\n      goto bail_2;\n    }\n\n    /* now we must decode out[0...outlen-1] using ASN.1, test the OID and then test the hash */\n    /* construct the SEQUENCE\n      SEQUENCE {\n         SEQUENCE {hashoid OID\n                   blah    NULL\n         }\n         hash    OCTET STRING\n      }\n   */\n    LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));\n    LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);\n    LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);\n    LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);\n\n    if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) {\n       XFREE(out);\n       goto bail_2;\n    }\n\n    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {\n       XFREE(out);\n       goto bail_2;\n    }\n\n    /* test OID */\n    if ((reallen == outlen) &&\n        (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n        (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&\n        (siginfo[1].size == hashlen) &&\n        (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {\n       *stat = 1;\n    }\n\n#ifdef LTC_CLEAN_STACK\n    zeromem(out, outlen);\n#endif\n    XFREE(out);\n  }\n\nbail_2:\n#ifdef LTC_CLEAN_STACK\n  zeromem(tmpbuf, siglen);\n#endif\n  XFREE(tmpbuf);\n  return err;\n}""}]","{""function"": 1, ""code"": 2, ""value"": 2, ""query"": 1}","[{""source"": ""func_info(func:der_length_sequence)"", ""result"": [{""code"": ""int der_length_sequence(ltc_asn1_list *list, unsigned long inlen,\n                        unsigned long *outlen) \n{\n   int           err, type;\n   unsigned long size, x, y, i;\n   void          *data;\n\n   LTC_ARGCHK(list    != NULL);\n   LTC_ARGCHK(outlen  != NULL);\n\n   /* get size of output that will be required */\n   y = 0;\n   for (i = 0; i < inlen; i++) {\n       type = list[i].type;\n       size = list[i].size;\n       data = list[i].data;\n\n       if (type == LTC_ASN1_EOL) { \n          break;\n       }\n\n       switch (type) {\n           case LTC_ASN1_BOOLEAN:\n              if ((err = der_length_boolean(&x)) != CRYPT_OK) {\n                 goto LBL_ERR;\n              }\n              y += x;\n              break;\n          \n           case LTC_ASN1_INTEGER:\n               if ((err = der_length_integer(data, &x)) != CRYPT_OK) {\n                  goto LBL_ERR;\n               }\n               y += x;\n               break;\n\n           case LTC_ASN1_SHORT_INTEGER:\n               if ((err = der_length_short_integer(*((unsigned long *)data), &x)) != CRYPT_OK) {\n                  goto LBL_ERR;\n               }\n               y += x;\n               break;\n\n           case LTC_ASN1_BIT_STRING:\n               if ((err = der_length_bit_string(size, &x)) != CRYPT_OK) {\n                  goto LBL_ERR;\n               }\n               y += x;\n               break;\n\n           case LTC_ASN1_OCTET_STRING:\n               if ((err = der_length_octet_string(size, &x)) != CRYPT_OK) {\n                  goto LBL_ERR;\n               }\n               y += x;\n               break;\n\n           case LTC_ASN1_NULL:\n               y += 2;\n               break;\n\n           case LTC_ASN1_OBJECT_IDENTIFIER:\n               if ((err = der_length_object_identifier(data, size, &x)) != CRYPT_OK) {\n                  goto LBL_ERR;\n               }\n               y += x;\n               break;\n\n           case LTC_ASN1_IA5_STRING:\n               if ((err = der_length_ia5_string(data, size, &x)) != CRYPT_OK) {\n                  goto LBL_ERR;\n               }\n               y += x;\n               break;\n\n           case LTC_ASN1_PRINTABLE_STRING:\n               if ((err = der_length_printable_string(data, size, &x)) != CRYPT_OK) {\n                  goto LBL_ERR;\n               }\n               y += x;\n               break;\n\n           case LTC_ASN1_UTCTIME:\n               if ((err = der_length_utctime(data, &x)) != CRYPT_OK) {\n                  goto LBL_ERR;\n               }\n               y += x;\n               break;\n\n           case LTC_ASN1_UTF8_STRING:\n               if ((err = der_length_utf8_string(data, size, &x)) != CRYPT_OK) {\n                  goto LBL_ERR;\n               }\n               y += x;\n               break;\n\n           case LTC_ASN1_SET:\n           case LTC_ASN1_SETOF:\n           case LTC_ASN1_SEQUENCE:\n               if ((err = der_length_sequence(data, size, &x)) != CRYPT_OK) {\n                  goto LBL_ERR;\n               }\n               y += x;\n               break;\n\n          \n           default:\n               err = CRYPT_INVALID_ARG;\n               goto LBL_ERR;\n       }\n   }\n\n   /* calc header size */\n   if (y < 128) {\n      y += 2;\n   } else if (y < 256) {\n      /* 0x30 0x81 LL */\n      y += 3;\n   } else if (y < 65536UL) {\n      /* 0x30 0x82 LL LL */\n      y += 4;\n   } else if (y < 16777216UL) {\n      /* 0x30 0x83 LL LL LL */\n      y += 5;\n   } else {\n      err = CRYPT_INVALID_ARG;\n      goto LBL_ERR;\n   }\n\n   /* store size */\n   *outlen = y;\n   err     = CRYPT_OK;\n\nLBL_ERR:\n   return err;\n}\n"", ""start_line"": 27, ""end_line"": 162, ""full_name"": ""der_length_sequence"", ""file_path"": ""src/pk/asn1/der/sequence/der_length_sequence.c""}]}, {""source"": ""code_info(file:rsa_verify_hash.c, lines:100-120)"", ""result"": ""      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n\n  } else {\n    /* PKCS #1 v1.5 decode it */\n    unsigned char *out;\n    unsigned long outlen, loid[16];\n    int           decoded;\n    ltc_asn1_list digestinfo[2], siginfo[2];\n\n    /* not all hashes have OIDs... so sad */\n    if (hash_descriptor[hash_idx].OIDlen == 0) {\n       err = CRYPT_INVALID_ARG;\n       goto bail_2;\n    }\n\n    /* allocate temp buffer for decoded hash */\n    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;\n    out    = XMALLOC(outlen);\n    if (out == NULL) {\n      err = CRYPT_MEM;\n""}, {""source"": ""value_info(file:rsa_verify_hash.c, value:outlen)"", ""result"": {""value_trace"": [{""full_code"": ""outlen = sizeof(key)"", ""line"": 181, ""func_name"": ""main<duplicate>1""}, {""full_code"": ""outlen = sizeof(md)"", ""line"": 142, ""func_name"": ""hash_gen""}], ""struct_var"": ""outlen"", ""struct_type"": ""longunsigned"", ""struct_definition"": ""longunsigned""}}, {""source"": ""value_info(file:rsa_verify_hash.c, value:outlen)"", ""result"": {""value_trace"": [{""full_code"": ""outlen = sizeof(key)"", ""line"": 181, ""func_name"": ""main<duplicate>1""}, {""full_code"": ""outlen = sizeof(md)"", ""line"": 142, ""func_name"": ""hash_gen""}], ""struct_var"": ""outlen"", ""struct_type"": ""longunsigned"", ""struct_definition"": ""longunsigned""}}, {""source"": ""code_info(file:rsa_verify_hash.c, lines:110-120)"", ""result"": ""    /* not all hashes have OIDs... so sad */\n    if (hash_descriptor[hash_idx].OIDlen == 0) {\n       err = CRYPT_INVALID_ARG;\n       goto bail_2;\n    }\n\n    /* allocate temp buffer for decoded hash */\n    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;\n    out    = XMALLOC(outlen);\n    if (out == NULL) {\n      err = CRYPT_MEM;\n""}, {""source"": ""query_info(query:cpg.method.name(\"".*pkcs.*1.*5.*decode.*\"").l)"", ""result"": [{""name"": ""pkcs_1_v1_5_decode"", ""signature"": ""int(unsigned char*,longunsigned,int,longunsigned,unsigned char*,longunsigned*,int*)"", ""lineNumberEnd"": 104, ""columnNumberEnd"": 1, ""fullName"": ""pkcs_1_v1_5_decode"", ""code"": ""int pkcs_1_v1_5_decode(const unsigned char *msg,\n                             unsigned long  msglen,\n                                       int  block_type,\n                             unsigned long  modulus_bitlen,\n                             unsigned char *out,\n                             unsigned long *outlen,\n                                       int *is_valid)\n{\n  unsigned long modulus_len, ps_len, i;\n  int result;\n\n  /* default to invalid packet */\n  *is_valid = 0;\n\n  modulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);\n\n  /* test message size */\n\n  if ((msglen > modulus_len) || (modulus_len < 11)) {\n    return CRYPT_PK_INVALID_SIZE;\n  }\n\n  /* separate encoded message */\n\n  if ((msg[0] != 0x00) || (msg[1] != (unsigned char)block_type)) {\n    result = CRYPT_INVALID_PACKET;\n    goto bail;\n  }\n\n  if (block_type == LTC_PKCS_1_EME) {\n    for (i = 2; i < modulus_len; i++) {\n      /* separator */\n      if (msg[i] == 0x00) { break; }\n    }\n    ps_len = i++ - 2;\n\n   ..."", ""lineNumber"": 32, ""columnNumber"": 1, ""filename"": ""src/pk/pkcs1/pkcs_1_v1_5_decode.c""}]}]","src/pk/rsa/rsa_verify_hash.c:146-149: Missing validation of ASN.1 encoded data length (`reallen`) vs decoded buffer length (`outlen`). The `outlen` is computed as `((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3` (src/pk/rsa/rsa_verify_hash.c:113), assuming the DER structure fits. However, `pkcs_1_v1_5_decode` (src/pk/pkcs1/pkcs_1_v1_5_decode.c:32-104) only validates PKCS#1 v1.5 formatting (e.g., leading 0x00, block type) and does not enforce DER structure length constraints. The patch adds a `reallen == outlen` check via `der_length_sequence` (src/pk/asn1/der/sequence/der_length_sequence.c:27-162), which correctly computes DER lengths, closing the vulnerability.",0.95,./github/other_context/CVE-2016-6129
76,CVE-2016-7162,CWE-20,c_cpp,The _g_file_remove_directory function in file-utils.c in File Roller 3.5.4 through 3.20.2 allows remote attackers to delete arbitrary files via a symlink attack on a folder in an archive.,https://github.com/GNOME/file-roller/commit/f70be1f41688859ec8dbe266df35a1839ceb96c5,do not follow symlinks when deleting a folder recursively\n\n[bug #698554],1,"[{""func_name"": ""_g_file_remove_directory"", ""file_path"": ""src/file-utils.c"", ""func_code"": ""gboolean\n_g_file_remove_directory (GFile         *directory,\n\t\t\t  GCancellable  *cancellable,\n\t\t\t  GError       **error)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *info;\n\tgboolean         error_occurred = FALSE;\n\n\tif (directory == NULL)\n\t\treturn TRUE;\n\n\tenumerator = g_file_enumerate_children (directory,\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \"",\""\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n\t\t\t\t\t        0,\n\t\t\t\t\t        cancellable,\n\t\t\t\t\t        error);\n\n\twhile (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {\n\t\tGFile *child;\n\n\t\tchild = g_file_get_child (directory, g_file_info_get_name (info));\n\t\tswitch (g_file_info_get_file_type (info)) {\n\t\tcase G_FILE_TYPE_DIRECTORY:\n\t\t\tif (! _g_file_remove_directory (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (! g_file_delete (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tg_object_unref (child);\n\t\tg_object_unref (info);\n\t}\n\n\tif (! error_occurred && ! g_file_delete (directory, cancellable, error))\n \t\terror_occurred = TRUE;\n\n\tg_object_unref (enumerator);\n\n\treturn ! error_occurred;\n}"", ""target"": 0}]","[{""func_name"": ""_g_file_remove_directory"", ""file_path"": ""src/file-utils.c"", ""func_code"": ""gboolean\n_g_file_remove_directory (GFile         *directory,\n\t\t\t  GCancellable  *cancellable,\n\t\t\t  GError       **error)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *info;\n\tgboolean         error_occurred = FALSE;\n\n\tif (directory == NULL)\n\t\treturn TRUE;\n\n\tenumerator = g_file_enumerate_children (directory,\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \"",\"" G_FILE_ATTRIBUTE_STANDARD_TYPE,\n\t\t\t\t\t\tG_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t        cancellable,\n\t\t\t\t\t        error);\n\n\twhile (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {\n\t\tGFile *child;\n\n\t\tchild = g_file_get_child (directory, g_file_info_get_name (info));\n\t\tswitch (g_file_info_get_file_type (info)) {\n\t\tcase G_FILE_TYPE_DIRECTORY:\n\t\t\tif (! _g_file_remove_directory (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (! g_file_delete (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tg_object_unref (child);\n\t\tg_object_unref (info);\n\t}\n\n\tif (! error_occurred && ! g_file_delete (directory, cancellable, error))\n \t\terror_occurred = TRUE;\n\n\tg_object_unref (enumerator);\n\n\treturn ! error_occurred;\n}""}]","{""caller"": 1}","[{""source"": ""caller_info(file:file-utils.c, func:_g_file_remove_directory)"", ""result"": [{""call_line"": 426, ""call_code"": ""_g_file_remove_directory (child, cancellable, error)"", ""caller_code"": ""gboolean\n_g_file_remove_directory (GFile         *directory,\n\t\t\t  GCancellable  *cancellable,\n\t\t\t  GError       **error)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *info;\n\tgboolean         error_occurred = FALSE;\n\n\tif (directory == NULL)\n\t\treturn TRUE;\n\n\tenumerator = g_file_enumerate_children (directory,\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \"",\""\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n\t\t\t\t\t        0,\n\t\t\t\t\t        cancellable,\n\t\t\t\t\t        error);\n\n\twhile (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {\n\t\tGFile *child;\n\n\t\tchild = g_file_get_child (directory, g_file_info_get_name (info));\n\t\tswitch (g_file_info_get_file_type (info)) {\n\t\tcase G_FILE_TYPE_DIRECTORY:\n\t\t\tif (! _g_file_remove_directory (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (! g_file_delete (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tg_object_unref (child);\n\t\tg_object_unref (info);\n\t}\n\n\tif (! error_occurred && ! g_file_delete (directory, cancellable, error))\n \t\terror_occurred = TRUE;\n\n\tg_object_unref (enumerator);\n\n\treturn ! error_occurred;\n}\n"", ""caller_start"": 401, ""file_path"": ""src/file-utils.c""}, {""call_line"": 1323, ""call_code"": ""_g_file_remove_directory (fr_archive_get_last_extraction_destination (e_data->archive), NULL, NULL)"", ""caller_code"": ""static void\nextract_here_ready_cb (GObject      *source_object,\n\t\t       GAsyncResult *result,\n\t\t       gpointer      user_data)\n{\n\tExtractHereData *e_data = user_data;\n\tGError          *error = NULL;\n\n\tfr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error);\n\tif (error != NULL) {\n\t\t_g_file_remove_directory (fr_archive_get_last_extraction_destination (e_data->archive), NULL, NULL);\n\t\tg_simple_async_result_set_from_error (e_data->result, error);\n\t\tg_error_free (error);\n\t}\n\telse\n\t\tmove_here (e_data->archive, e_data->cancellable);\n\n\tg_simple_async_result_complete_in_idle (e_data->result);\n\n\textract_here_data_free (e_data);\n}"", ""caller_start"": 1313, ""file_path"": ""src/fr-archive.c""}, {""call_line"": 117, ""call_code"": ""_g_file_remove_directory (self->priv->temp_dir, NULL, NULL)"", ""caller_code"": ""static void\n_fr_command_remove_temp_work_dir (FrCommand *self)\n{\n\tif (self->priv->temp_dir == NULL)\n\t\treturn;\n\t_g_file_remove_directory (self->priv->temp_dir, NULL, NULL);\n\t_g_clear_object (&self->priv->temp_dir);\n}"", ""caller_start"": 112, ""file_path"": ""src/fr-command.c""}, {""call_line"": 202, ""call_code"": ""_g_file_remove_directory (self->priv->temp_extraction_dir, NULL, NULL)"", ""caller_code"": ""static void\ncopy_extracted_files_done (GError   *error,\n\t\t\t   gpointer  user_data)\n{\n\tXferData  *xfer_data = user_data;\n\tFrCommand *self = FR_COMMAND (xfer_data->archive);\n\n\tif (error != NULL)\n\t\tg_simple_async_result_set_from_error (xfer_data->result, error);\n\n\t_g_file_remove_directory (self->priv->temp_extraction_dir, NULL, NULL);\n\t_g_clear_object (&self->priv->temp_extraction_dir);\n\n\tg_simple_async_result_complete_in_idle (xfer_data->result);\n\n\txfer_data_free (xfer_data);\n}"", ""caller_start"": 192, ""file_path"": ""src/fr-command.c""}]}]","src/file-utils.c:412: The original code used g_file_enumerate_children() without G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, enabling symlink traversal during directory enumeration. Attackers could exploit this by placing malicious symlinks in archives, leading to unintended file deletion during recursive removal. The patch adds the flag to block symlink following. Callers at src/file-utils.c:426 (recursive deletion), src/fr-archive.c:1323 (extraction cleanup), and src/fr-command.c:117/202 (temp dir removal) are all protected by the fixed function.",0.95,./github/other_context/CVE-2016-7162
77,CVE-2016-9317,CWE-20,c_cpp,The gdImageCreate function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (system hang) via an oversized image.,https://github.com/libgd/libgd/commit/1846f48e5fcdde996e7c27a4bbac5d0aef183e4b,Fix #340: System frozen\n\ngdImageCreate() doesn't check for oversized images and as such is prone\nto DoS vulnerabilities. We fix that by applying the same overflow check\nthat is already in place for gdImageCreateTrueColor().\n\nCVE-2016-9317,1,"[{""func_name"": ""gdImageCreate"", ""file_path"": ""src/gd.c"", ""func_code"": ""BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}"", ""target"": 0}]","[{""func_name"": ""gdImageCreate"", ""file_path"": ""src/gd.c"", ""func_code"": ""BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\n\tif (overflow2(sizeof (unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}""}]","{""value"": 2, ""function"": 1}","[{""source"": ""value_info(file:gd.c, value:sy)"", ""result"": {""value_trace"": [{""full_code"": ""sy = syd + scY"", ""line"": 3376, ""func_name"": ""gdImageCopyRotated""}, {""full_code"": ""sy = sy1"", ""line"": 3471, ""func_name"": ""gdImageCopyResampled""}, {""full_code"": ""sy = floorf(sy)"", ""line"": 3479, ""func_name"": ""gdImageCopyResampled""}, {""full_code"": ""sy += 1.0f"", ""line"": 3517, ""func_name"": ""gdImageCopyResampled""}, {""full_code"": ""sy = im1->sy"", ""line"": 3984, ""func_name"": ""gdImageCompare""}], ""struct_var"": ""sy"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""value_info(file:gd.c, value:sy)"", ""result"": {""value_trace"": [{""full_code"": ""sy = syd + scY"", ""line"": 3376, ""func_name"": ""gdImageCopyRotated""}, {""full_code"": ""sy = sy1"", ""line"": 3471, ""func_name"": ""gdImageCopyResampled""}, {""full_code"": ""sy = floorf(sy)"", ""line"": 3479, ""func_name"": ""gdImageCopyResampled""}, {""full_code"": ""sy += 1.0f"", ""line"": 3517, ""func_name"": ""gdImageCopyResampled""}, {""full_code"": ""sy = im1->sy"", ""line"": 3984, ""func_name"": ""gdImageCompare""}], ""struct_var"": ""sy"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""func_info(file:gd.c, func:gdImageCreate)"", ""result"": [{""code"": ""BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}\n"", ""start_line"": 183, ""end_line"": 249, ""full_name"": ""gdImageCreate"", ""file_path"": ""src/gd.c""}]}]","src/gd.c:190: gdImageCreate uses user-controlled 'sy' parameter without prior validation. The patch added overflow2(sizeof(unsigned char *), sy) to prevent oversized allocations, confirming 'sy' was unbounded before. The vulnerability arises because 'sy' directly controls memory allocation size (src/gd.c:207) without bounds checks prior to the patch.",0.95,./github/other_context/CVE-2016-9317
78,CVE-2017-11410,"CWE-20, CWE-835",c_cpp,"In Wireshark through 2.0.13 and 2.2.x through 2.2.7, the WBXML dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-wbxml.c by adding validation of the relationships between indexes and lengths. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-7702.",https://github.com/wireshark/wireshark/commit/3c7168cc5f044b4da8747d35da0b2b204dabf398,WBXML: Fix some more potential infinite loops.\n\ntvb_get_guintvar can generate some unrealistic values so do some\nsanity checking on them.\n\nBug: 13796\nChange-Id: I2d5f7a48c2e982a419ea6ab3ac0000be3b6bcbc7\nReviewed-on: https://code.wireshark.org/review/22121\nReviewed-by: Michael Mann <mmann78@netscape.net>\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit 50fa2d95833ec2e2b0de3000eda7b290fc23eaeb)\nReviewed-on: https://code.wireshark.org/review/22130,2,"[{""func_name"": ""parse_wbxml_attribute_list_defined"", ""file_path"": ""epan/dissectors/packet-wbxml.c"", ""func_code"": ""static guint32\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,\n\t\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map)\n{\n\tguint32     tvb_len = tvb_reported_length (tvb);\n\tguint32     off     = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint8      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\n\tconst char *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\n\tgchar      *str;\n\n\tDebugLog((\""parse_wbxml_attr_defined (level = %u, offset = %u)\\n\"", level, offset));\n\t/* Parse attributes */\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\""ATTR: (top of while) level = %3u, peek = 0x%02X, \""\n\t\t\t  \""off = %u, tvb_len = %u\\n\"", level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_attr,\n                         \""      |  Attr | A -->%3d | SWITCH_PAGE (Attr code page)    |\"",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \"">\"" or \""/>\""\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\""ATTR: level = %u, Return: len = %u\\n\"",\n\t\t\t\t  level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), ent);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | STR_I (Inline string)           |     %s\\'%s\\'\"",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\t/* ALWAYS means the start of a new attribute,\n\t\t\t * and may only contain the NAME of the attribute.\n\t\t\t */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tattr_save_known = 0;\n\t\t\t\tattr_save_literal = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), attr_save_literal);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | EXT_I_%1x    (Extension Token)    |     %s(%s: \\'%s\\')\"",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \""Inline string extension\""), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map != NULL) {\n\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""EXT_T_%1x (%s)\"", peek & 0x03,\n\t\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""Extension Token, integer value: (%u\"", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s)\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\tif (len <= tvb_len) {\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), str);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \""Single-byte extension\"");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | EXT_%1x      (Extension Token)    |     %s(%s)\"",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (attr_save_known) { /* Knwon attribute */\n\t\t\t\t\t\tif (map->opaque_binary_attr) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL attribute */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t\t         \""  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\"",\n\t\t\t\t\t\t\t         level, *codepage_attr, Indent (level), tmp_str);\n\t\t\t\t\t\toff += 1 + len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\"",\n\t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\"",\n\t\t\t\t\t\t\t     level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\""ATTR: level = %u, Return: len = %u\\n\"",\n\t\t\t\t\t  level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_invalid_token, tvb, off, 1,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | %-10s     (Invalid Token!) | WBXML parsing stops here.\"",\n\t\t\t\t\t     level, *codepage_attr, val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \""(unknown 0x%x)\""));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known atribute token */\n\t\t\tchar* s;\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrValue, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""attrValue_0x%02X\"", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrvalue, tvb, off, 1, s,\n\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    |   Known attrValue 0x%02X          |       %s%s\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrStart, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""attrStart_0x%02X\"", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrstart, tvb, off, 1, s,\n\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    |   Known attrStart 0x%02X          |   %s%s\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t} /* End WHILE */\n\tDebugLog((\""ATTR: level = %u, Return: len = %u (end of function body)\\n\"",\n\t\t  level, off - offset));\n\treturn (off - offset);\n}"", ""target"": 0}, {""func_name"": ""parse_wbxml_tag_defined"", ""file_path"": ""epan/dissectors/packet-wbxml.c"", ""func_code"": ""static guint32\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n\t\t\t const wbxml_decoding *map)\n{\n\tguint32     tvb_len  = tvb_reported_length (tvb);\n\tguint32     off      = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tgchar      *str;\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n\n\tif (*level == 255) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\n\t\treturn tvb_len;\n\t}\n\tDebugLog((\""parse_wbxml_tag_defined (level = %u, offset = %u)\\n\"", *level, offset));\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\""STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\"", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\n\t\t\t\t\t     \""      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\"",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\"",\n\t\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \""\"",\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\"",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_save_literal ? tag_save_literal : \""\"");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\""STAG: level = %u, Return: len = %u\\n\"", *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\"",\n\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (*level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \""Inline string extension\""),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\n\t\t\t\t\t\t\t\t  str_tbl, *level, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (PI)                        | %s?>\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map)\n\t\t\t\t{\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""EXT_T_%1x (%s)\"", peek & 0x03,\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""(Extension Token, integer value: %u)\"", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\"",\n\t\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \""Single-byte extension\"");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\"",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (tag_save_known) { /* Knwon tag */\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\"",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tmp_str);\n\t\t\t\t\toff += 1 + len;\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\"",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), idx);\n\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\"",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\""STAG: level = %u, Return: len = %u\\n\"", *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\""STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\"", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t} else {\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(wmem_packet_scope(), \""Tag_0x%02X\"",\n\t\t\t\t\t\t\ttag_new_known);\n\t\t\t\t}\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\""STAG: Tag in Tag - RECURSE! (off = %u)\\n\"", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\n\t\t\t\t\t\t\t\t       level, codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (attribute list)            | %s>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\""Tag in Tag - No recursion this time! (off = %u)\\n\"", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\""<Tag/> in Tag - No recursion! (off = %u)\\n\"", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \""\"",\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n\t\t\t\t/* TODO: Do I have to reset code page here? */\n\t\t\t}\n\t\t} /* if (tag & 0x3F) >= 5 */\n\t} /* while */\n\tDebugLog((\""STAG: level = %u, Return: len = %u (end of function body)\\n\"", *level, off - offset));\n\treturn (off - offset);\n}"", ""target"": 0}]","[{""func_name"": ""parse_wbxml_attribute_list_defined"", ""file_path"": ""epan/dissectors/packet-wbxml.c"", ""func_code"": ""static guint32\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,\n\t\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map)\n{\n\tguint32     tvb_len = tvb_reported_length (tvb);\n\tguint32     off     = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint8      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\n\tconst char *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\n\tgchar      *str;\n\n\tDebugLog((\""parse_wbxml_attr_defined (level = %u, offset = %u)\\n\"", level, offset));\n\t/* Parse attributes */\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\""ATTR: (top of while) level = %3u, peek = 0x%02X, \""\n\t\t\t  \""off = %u, tvb_len = %u\\n\"", level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_attr,\n                         \""      |  Attr | A -->%3d | SWITCH_PAGE (Attr code page)    |\"",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \"">\"" or \""/>\""\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\""ATTR: level = %u, Return: len = %u\\n\"",\n\t\t\t\t  level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), ent);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | STR_I (Inline string)           |     %s\\'%s\\'\"",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\t/* ALWAYS means the start of a new attribute,\n\t\t\t * and may only contain the NAME of the attribute.\n\t\t\t */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tattr_save_known = 0;\n\t\t\t\tattr_save_literal = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), attr_save_literal);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | EXT_I_%1x    (Extension Token)    |     %s(%s: \\'%s\\')\"",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \""Inline string extension\""), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map != NULL) {\n\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""EXT_T_%1x (%s)\"", peek & 0x03,\n\t\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""Extension Token, integer value: (%u\"", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s)\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\tif (len <= tvb_len) {\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), str);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \""Single-byte extension\"");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | EXT_%1x      (Extension Token)    |     %s(%s)\"",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (attr_save_known) { /* Knwon attribute */\n\t\t\t\t\t\tif (map->opaque_binary_attr) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL attribute */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t\t         \""  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\"",\n\t\t\t\t\t\t\t         level, *codepage_attr, Indent (level), tmp_str);\n\t\t\t\t\t\toff += 1 + len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len)) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\"",\n\t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\"",\n\t\t\t\t\t\t\t     level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\""ATTR: level = %u, Return: len = %u\\n\"",\n\t\t\t\t\t  level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_invalid_token, tvb, off, 1,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | %-10s     (Invalid Token!) | WBXML parsing stops here.\"",\n\t\t\t\t\t     level, *codepage_attr, val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \""(unknown 0x%x)\""));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known atribute token */\n\t\t\tchar* s;\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrValue, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""attrValue_0x%02X\"", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrvalue, tvb, off, 1, s,\n\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    |   Known attrValue 0x%02X          |       %s%s\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrStart, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""attrStart_0x%02X\"", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrstart, tvb, off, 1, s,\n\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    |   Known attrStart 0x%02X          |   %s%s\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t} /* End WHILE */\n\tDebugLog((\""ATTR: level = %u, Return: len = %u (end of function body)\\n\"",\n\t\t  level, off - offset));\n\treturn (off - offset);\n}""}, {""func_name"": ""parse_wbxml_tag_defined"", ""file_path"": ""epan/dissectors/packet-wbxml.c"", ""func_code"": ""static guint32\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n\t\t\t const wbxml_decoding *map)\n{\n\tguint32     tvb_len  = tvb_reported_length (tvb);\n\tguint32     off      = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tgchar      *str;\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n\n\tif (*level == 255) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\n\t\treturn tvb_len;\n\t}\n\tDebugLog((\""parse_wbxml_tag_defined (level = %u, offset = %u)\\n\"", *level, offset));\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\""STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\"", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\n\t\t\t\t\t     \""      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\"",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\"",\n\t\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \""\"",\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\"",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_save_literal ? tag_save_literal : \""\"");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\""STAG: level = %u, Return: len = %u\\n\"", *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\"",\n\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (*level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \""Inline string extension\""),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\n\t\t\t\t\t\t\t\t  str_tbl, *level, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (PI)                        | %s?>\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map)\n\t\t\t\t{\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""EXT_T_%1x (%s)\"", peek & 0x03,\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""(Extension Token, integer value: %u)\"", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\"",\n\t\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \""Single-byte extension\"");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\"",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (tag_save_known) { /* Knwon tag */\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\"",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tmp_str);\n\t\t\t\t\toff += 1 + len;\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len))\n\t\t\t\t\t{\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t         \""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\"",\n\t\t\t\t\t\t         *level, *codepage_stag, Indent (*level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\"",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\""STAG: level = %u, Return: len = %u\\n\"", *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\""STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\"", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t} else {\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(wmem_packet_scope(), \""Tag_0x%02X\"",\n\t\t\t\t\t\t\ttag_new_known);\n\t\t\t\t}\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\""STAG: Tag in Tag - RECURSE! (off = %u)\\n\"", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\n\t\t\t\t\t\t\t\t       level, codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (attribute list)            | %s>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\""Tag in Tag - No recursion this time! (off = %u)\\n\"", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\""<Tag/> in Tag - No recursion! (off = %u)\\n\"", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \""\"",\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n\t\t\t\t/* TODO: Do I have to reset code page here? */\n\t\t\t}\n\t\t} /* if (tag & 0x3F) >= 5 */\n\t} /* while */\n\tDebugLog((\""STAG: level = %u, Return: len = %u (end of function body)\\n\"", *level, off - offset));\n\treturn (off - offset);\n}""}]","{""function"": 1, ""value"": 1}","[{""source"": ""func_info(func:tvb_get_guintvar)"", ""result"": [{""code"": ""guint\ntvb_get_guintvar (tvbuff_t *tvb, guint offset, guint *octetCount, packet_info *pinfo, expert_field *ei)\n{\n    guint value   = 0;\n    guint octet;\n    guint counter = 0;\n    char  cont    = 1;\n\n#ifdef DEBUG\n    if (octetCount != NULL)\n    {\n        fprintf (stderr, \""dissect_wap: Starting tvb_get_guintvar at offset %d, count=%d\\n\"", offset, *octetCount);\n        /* counter = *octetCount; */\n    }\n    else\n    {\n        fprintf (stderr, \""dissect_wap: Starting tvb_get_guintvar at offset %d, count=NULL\\n\"", offset);\n    }\n#endif\n\n    while (cont != 0)\n    {\n        value <<= 7;  /* Value only exists in 7 of the 8 bits */\n        octet = tvb_get_guint8 (tvb, offset+counter);\n        counter += 1;\n        value   += (octet & 0x7F);\n        cont = (octet & 0x80);\n#ifdef DEBUG\n        fprintf (stderr, \""dissect_wap: computing: octet is %d (0x%02x), count=%d, value=%d, cont=%d\\n\"",\n                 octet, octet, counter, value, cont);\n#endif\n    }\n\n    if (counter > 5) {\n        proto_tree_add_expert(NULL, pinfo, ei, tvb, offset, counter);\n        value = 0;\n    }\n    if (octetCount != NULL)\n    {\n        *octetCount = counter;\n#ifdef DEBUG\n        fprintf (stderr, \""dissect_wap: Leaving tvb_get_guintvar count=%d, value=%u\\n\"", *octetCount, value);\n#endif\n    }\n\n    return (value);\n}\n"", ""start_line"": 40, ""end_line"": 86, ""full_name"": ""tvb_get_guintvar"", ""file_path"": ""epan/dissectors/packet-wap.c""}]}, {""source"": ""value_info(file:packet-wbxml.c, value:tvb_len)"", ""result"": {""value_trace"": [{""full_code"": ""tvb_len = tvb_reported_length (tvb)"", ""line"": 7056, ""func_name"": ""parse_wbxml_attribute_list_defined""}, {""full_code"": ""tvb_len  = tvb_reported_length (tvb)"", ""line"": 7321, ""func_name"": ""parse_wbxml_tag_defined""}], ""struct_var"": ""tvb_len"", ""struct_type"": ""guint32"", ""struct_definition"": ""static guint32\n\nstatic guint32\n\ntypedef unsigned int guint32;\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32""}}]","Untrusted input from tvb_get_guintvar (epan/dissectors/packet-wap.c:40-86) returns variable-length integers without validating against tvb_len (derived from tvb_reported_length in epan/dissectors/packet-wbxml.c:7056 and 7321). This allows oversized idx/len values in parse_wbxml_attribute_list_defined (epan/dissectors/packet-wbxml.c:7229) and parse_wbxml_tag_defined (epan/dissectors/packet-wbxml.c:7493), causing infinite loops during data parsing. Patches added idx < tvb_len checks to limit processing to valid buffer ranges.",0.95,./github/other_context/CVE-2017-11410
79,CVE-2017-12843,CWE-20,c_cpp,"Cyrus IMAP before 3.0.3 allows remote authenticated users to write to arbitrary files via a crafted (1) SYNCAPPLY, (2) SYNCGET or (3) SYNCRESTORE command.",https://github.com/cyrusimap/cyrus-imapd/commit/5edadcfb83bf27107578830801817f9e6d0ad941,dlist: don't allow overwrite of arbitrary files,1,"[{""func_name"": ""dlist_reserve_path"", ""file_path"": ""imap/dlist.c"", ""func_code"": ""EXPORTED const char *dlist_reserve_path(const char *part, int isarchive,\n                                        const struct message_guid *guid)\n{\n    static char buf[MAX_MAILBOX_PATH];\n    const char *base;\n\n    /* part can be either a configured partition name, or a path */\n    if (strchr(part, '/')) {\n        base = part;\n    }\n    else {\n        base = isarchive ? config_archivepartitiondir(part)\n                         : config_partitiondir(part);\n    }\n\n    /* we expect to have a base at this point, so let's assert that */\n    assert(base != NULL);\n\n    snprintf(buf, MAX_MAILBOX_PATH, \""%s/sync./%lu/%s\"",\n                  base, (unsigned long)getpid(),\n                  message_guid_encode(guid));\n\n    /* gotta make sure we can create files */\n    if (cyrus_mkdir(buf, 0755)) {\n        /* it's going to fail later, but at least this will help */\n        syslog(LOG_ERR, \""IOERROR: failed to create %s/sync./%lu/ for reserve: %m\"",\n                        base, (unsigned long)getpid());\n    }\n    return buf;\n}"", ""target"": 0}]","[{""func_name"": ""dlist_reserve_path"", ""file_path"": ""imap/dlist.c"", ""func_code"": ""EXPORTED const char *dlist_reserve_path(const char *part, int isarchive,\n                                        const struct message_guid *guid)\n{\n    static char buf[MAX_MAILBOX_PATH];\n\n    /* part must be a configured partition name on this server */\n    const char *base = isarchive ? config_archivepartitiondir(part)\n                                 : config_partitiondir(part);\n\n    /* we expect to have a base at this point, so let's assert that */\n    assert(base != NULL);\n\n    snprintf(buf, MAX_MAILBOX_PATH, \""%s/sync./%lu/%s\"",\n                  base, (unsigned long)getpid(),\n                  message_guid_encode(guid));\n\n    /* gotta make sure we can create files */\n    if (cyrus_mkdir(buf, 0755)) {\n        /* it's going to fail later, but at least this will help */\n        syslog(LOG_ERR, \""IOERROR: failed to create %s/sync./%lu/ for reserve: %m\"",\n                        base, (unsigned long)getpid());\n    }\n    return buf;\n}""}]","{""value"": 2, ""caller"": 3, ""function"": 1}","[{""source"": ""value_info(file:dlist.c, value:part)"", ""result"": {""value_trace"": [{""full_code"": ""part = alt_reserve_base ? alt_reserve_base : pbuf.s"", ""line"": 1077, ""func_name"": ""dlist_parse""}], ""struct_var"": ""part"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""caller_info(file:dlist.c, func:dlist_reserve_path)"", ""result"": [{""call_line"": 180, ""call_code"": ""dlist_reserve_path(part, /*isarchive*/0, guid)"", ""caller_code"": ""static int reservefile(struct protstream *in, const char *part,\n                       struct message_guid *guid, unsigned long size,\n                       const char **fname)\n{\n    FILE *file;\n    char buf[8192+1];\n    int r = 0;\n\n    /* XXX - write to a temporary file then move in to place! */\n    *fname = dlist_reserve_path(part, /*isarchive*/0, guid);\n\n    /* remove any duplicates if they're still here */\n    unlink(*fname);\n\n    file = fopen(*fname, \""w+\"");\n    if (!file) {\n        syslog(LOG_ERR,\n               \""IOERROR: failed to upload file %s\"", message_guid_encode(guid));\n        r = IMAP_IOERROR;\n        /* Note: we still read the file's data from the wire,\n         * to avoid losing protocol sync */\n    }\n\n    /* XXX - calculate sha1 on the fly? */\n    while (size) {\n        size_t n = prot_read(in, buf, size > 8192 ? 8192 : size);\n        if (!n) {\n            syslog(LOG_ERR,\n                \""IOERROR: reading message: unexpected end of file\"");\n            r = IMAP_IOERRO..."", ""caller_start"": 171, ""file_path"": ""imap/dlist.c""}, {""call_line"": 2208, ""call_code"": ""dlist_reserve_path(part, record->system_flags & FLAG_ARCHIVED, &record->guid)"", ""caller_code"": ""static void reserve_folder(const char *part, const char *mboxname,\n                    struct sync_msgid_list *part_list)\n{\n    struct mailbox *mailbox = NULL;\n    int r;\n    struct sync_msgid *item;\n    const char *mailbox_msg_path, *stage_msg_path;\n    int num_reserved;\n\nredo:\n\n    num_reserved = 0;\n\n    /* Open and lock mailbox */\n    r = mailbox_open_irl(mboxname, &mailbox);\n    if (!r) r = sync_mailbox_version_check(&mailbox);\n    if (r) return;\n\n    struct mailbox_iter *iter = mailbox_iter_init(mailbox, 0, ITER_SKIP_UNLINKED);\n    const message_t *msg;\n    while ((msg = mailbox_iter_step(iter))) {\n        const struct index_record *record = msg_record(msg);\n        /* do we need it? */\n        item = sync_msgid_lookup(part_list, &record->guid);\n        if (!item)\n            continue;\n\n        /* have we already found it? */\n        if (!item->need_upload)\n            continue;\n\n        /* Attempt to reserve this message */\n        mailbox_msg_path = mailbox_record_fname(mailb..."", ""caller_start"": 2175, ""file_path"": ""imap/sync_support.c""}]}, {""source"": ""value_info(file:dlist.c, value:pbuf.s)"", ""result"": {""value_trace"": [{""full_code"": ""pbuf.s"", ""line"": 1077, ""func_name"": ""dlist_parse""}, {""full_code"": ""pbuf.s"", ""line"": 1079, ""func_name"": ""dlist_parse""}], ""struct_var"": ""pbuf"", ""struct_type"": ""buf"", ""struct_definition"": ""struct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstatic struct buf\n\nstruct buf\n\nstatic struct buf\n\nstatic struct buf\n\nstatic struct buf\n\nstatic struct buf\n\nstatic struct buf\n\nstatic struct buf\n\nstatic struct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nconst struct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstatic struct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf {\n    char *s;\n    size_t len;\n    size_t alloc;\n    unsigned flags;\n}\n\nstruct buf\n\nstatic struct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nextern struct buf\n\nextern struct buf\n\nstruct buf\n\nextern struct buf\n\nstruct buf\n\nconst struct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf\n\nextern struct buf\n\nextern struct buf\n\nstruct buf\n\nconst struct buf\n\nextern const struct buf\n\nstruct buf\n\nstruct buf\n\nstruct buf {\n    char *s;\n    size_t len;\n    size_t alloc;\n    unsigned flags;\n}\n\nstruct buf {\n    char *s;\n    size_t len;\n    size_t alloc;\n    unsigned flags;\n}\n\nstruct buf""}}, {""source"": ""func_info(file:dlist.c, func:dlist_parse)"", ""result"": [{""code"": ""int dlist_parse(struct dlist **dlp, int parsekey,\n                          struct protstream *in, const char *alt_reserve_base)\n{\n    struct dlist *dl = NULL;\n    static struct buf kbuf;\n    static s"", ""start_line"": 1011, ""end_line"": 1112, ""full_name"": ""dlist_parse"", ""file_path"": ""imap/dlist.c""}]}, {""source"": ""caller_info(file:dlist.c, func:reservefile)"", ""result"": [{""call_line"": 1078, ""call_code"": ""reservefile(in, part, &tmp_guid, size, &fname)"", ""caller_code"": ""int dlist_parse(struct dlist **dlp, int parsekey,\n                          struct protstream *in, const char *alt_reserve_base)\n{\n    struct dlist *dl = NULL;\n    static struct buf kbuf;\n    static struct buf vbuf;\n    int c;\n\n    /* handle the key if wanted */\n    if (parsekey) {\n        c = getastring(in, NULL, &kbuf);\n        c = next_nonspace(in, c);\n    }\n    else {\n        buf_setcstr(&kbuf, \""\"");\n        c = prot_getc(in);\n    }\n\n    /* connection dropped? */\n    if (c == EOF) goto fail;\n\n    /* check what sort of value we have */\n    if (c == '(') {\n        dl = dlist_newlist(NULL, kbuf.s);\n        c = next_nonspace(in, ' ');\n        while (c != ')') {\n            struct dlist *di = NULL;\n            prot_ungetc(c, in);\n            c = dlist_parse(&di, 0, in, alt_reserve_base);\n            if (di) dlist_stitch(dl, di);\n            c = next_nonspace(in, c);\n            if (c == EOF) goto fail;\n        }\n        c = prot_getc(in);\n    }\n    else if (c == '%') {\n        /* no w..."", ""caller_start"": 1011, ""file_path"": ""imap/dlist.c""}]}, {""source"": ""caller_info(file:sync_support.c, func:reserve_folder)"", ""result"": [{""call_line"": 2295, ""call_code"": ""reserve_folder(partition, folder->name, part_list)"", ""caller_code"": ""int sync_apply_reserve(struct dlist *kl,\n                       struct sync_reserve_list *reserve_list,\n                       struct sync_state *sstate)\n{\n    struct message_guid *tmpguid;\n    struct sync_name_list *folder_names = sync_name_list_create();\n    struct sync_msgid_list *part_list;\n    struct sync_msgid *item;\n    struct sync_name *folder;\n    mbentry_t *mbentry = NULL;\n    const char *partition = NULL;\n    struct dlist *ml;\n    struct dlist *gl;\n    struct dlist *i;\n    struct dlist *kout = NULL;\n\n    if (!dlist_getatom(kl, \""PARTITION\"", &partition)) goto parse_err;\n    if (!dlist_getlist(kl, \""MBOXNAME\"", &ml)) goto parse_err;\n    if (!dlist_getlist(kl, \""GUID\"", &gl)) goto parse_err;\n\n    part_list = sync_reserve_partlist(reserve_list, partition);\n    for (i = gl->head; i; i = i->next) {\n        if (!dlist_toguid(i, &tmpguid))\n            goto parse_err;\n        sync_msgid_insert(part_list, tmpguid);\n    }\n\n    /* need a list so we can mark items */\n    for (i = ml->head;..."", ""caller_start"": 2254, ""file_path"": ""imap/sync_support.c""}, {""call_line"": 2304, ""call_code"": ""reserve_folder(partition, folder->name, part_list)"", ""caller_code"": ""int sync_apply_reserve(struct dlist *kl,\n                       struct sync_reserve_list *reserve_list,\n                       struct sync_state *sstate)\n{\n    struct message_guid *tmpguid;\n    struct sync_name_list *folder_names = sync_name_list_create();\n    struct sync_msgid_list *part_list;\n    struct sync_msgid *item;\n    struct sync_name *folder;\n    mbentry_t *mbentry = NULL;\n    const char *partition = NULL;\n    struct dlist *ml;\n    struct dlist *gl;\n    struct dlist *i;\n    struct dlist *kout = NULL;\n\n    if (!dlist_getatom(kl, \""PARTITION\"", &partition)) goto parse_err;\n    if (!dlist_getlist(kl, \""MBOXNAME\"", &ml)) goto parse_err;\n    if (!dlist_getlist(kl, \""GUID\"", &gl)) goto parse_err;\n\n    part_list = sync_reserve_partlist(reserve_list, partition);\n    for (i = gl->head; i; i = i->next) {\n        if (!dlist_toguid(i, &tmpguid))\n            goto parse_err;\n        sync_msgid_insert(part_list, tmpguid);\n    }\n\n    /* need a list so we can mark items */\n    for (i = ml->head;..."", ""caller_start"": 2254, ""file_path"": ""imap/sync_support.c""}]}]","The vulnerability arises from improper validation of the 'part' parameter in dlist_reserve_path() (imap/dlist.c:142-155), allowing arbitrary paths containing '/' to be resolved. 'part' is initialized in dlist_parse() (imap/dlist.c:1077) as either 'alt_reserve_base' (unconfirmed source) or 'pbuf.s', which is populated from user input via protstream *in (imap/dlist.c:1011-1112). 'part' is passed to dlist_reserve_path() via reservefile() (imap/dlist.c:180) and reserve_folder() (imap/sync_support.c:2208), with the latter sourcing 'partition' from parsed DLIST atoms (e.g., 'PARTITION' in sync_apply_reserve). The patch enforces partition-based resolution, closing the arbitrary path overwrite.",0.95,./github/other_context/CVE-2017-12843
80,CVE-2017-12795,CWE-20,java,OpenMRS openmrs-module-htmlformentry 3.3.2 is affected by: (Improper Input Validation).,https://github.com/openmrs/openmrs-module-htmlformentry/commit/86f35221c8a57cdd7557ce731a56b90db216c8e0,Added privilege check when previewing an uploaded html form,1,"[{""func_name"": ""handleRequest"", ""file_path"": ""omod/src/main/java/org/openmrs/module/htmlformentry/web/controller/HtmlFormFromFileController.java"", ""func_code"": ""@RequestMapping(\""/module/htmlformentry/htmlFormFromFile.form\"")\n\tpublic void handleRequest(Model model, @RequestParam(value = \""filePath\"", required = false) String filePath,\n\t                          @RequestParam(value = \""patientId\"", required = false) Integer pId,\n\t                          @RequestParam(value = \""isFileUpload\"", required = false) boolean isFileUpload,\n\t                          HttpServletRequest request) throws Exception {\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\""In reference data...\"");\n\t\t\n\t\tmodel.addAttribute(\""previewHtml\"", \""\"");\n\t\tString message = \""\"";\n\t\tFile f = null;\n\t\ttry {\n\t\t\tif (isFileUpload) {\n\t\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\t\tMultipartFile multipartFile = multipartRequest.getFile(\""htmlFormFile\"");\n\t\t\t\tif (multipartFile != null) {\n\t\t\t\t\t//use the same file for the logged in user\n\t\t\t\t\tf = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX\n\t\t\t\t\t        + Context.getAuthenticatedUser().getSystemId());\n\t\t\t\t\tif (!f.exists())\n\t\t\t\t\t\tf.createNewFile();\n\t\t\t\t\t\n\t\t\t\t\tfilePath = f.getAbsolutePath();\n\t\t\t\t\tFileOutputStream fileOut = new FileOutputStream(f);\n\t\t\t\t\tIOUtils.copy(multipartFile.getInputStream(), fileOut);\n\t\t\t\t\tfileOut.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (StringUtils.hasText(filePath)) {\n\t\t\t\t\tf = new File(filePath);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = \""You must specify a file path to preview from file\"";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f != null && f.exists() && f.canRead()) {\n\t\t\t\tmodel.addAttribute(\""filePath\"", filePath);\n\t\t\t\t\n\t\t\t\tStringWriter writer = new StringWriter();\n\t\t\t\tIOUtils.copy(new FileInputStream(f), writer, \""UTF-8\"");\n\t\t\t\tString xml = writer.toString();\n\t\t\t\t\n\t\t\t\tPatient p = null;\n\t\t\t\tif (pId != null) {\n\t\t\t\t\tp = Context.getPatientService().getPatient(pId);\n\t\t\t\t} else {\n\t\t\t\t\tp = HtmlFormEntryUtil.getFakePerson();\n\t\t\t\t}\n\t\t\t\tHtmlForm fakeForm = new HtmlForm();\n\t\t\t\tfakeForm.setXmlData(xml);\n\t\t\t\tFormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());\n\t\t\t\tString html = fes.getHtmlToDisplay();\n\t\t\t\tif (fes.getFieldAccessorJavascript() != null) {\n                \thtml += \""<script>\"" + fes.getFieldAccessorJavascript() + \""</script>\"";\n                }\n\t\t\t\tmodel.addAttribute(\""previewHtml\"", html);\n\t\t\t\t//clear the error message\n\t\t\t\tmessage = \""\"";\n\t\t\t} else {\n\t\t\t\tmessage = \""Please specify a valid file path or select a valid file.\"";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\""An error occurred while loading the html.\"", e);\n\t\t\tmessage = \""An error occurred while loading the html. \"" + e.getMessage();\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\""message\"", message);\n\t\tmodel.addAttribute(\""isFileUpload\"", isFileUpload);\n\t}"", ""target"": 0}]","[{""func_name"": ""handleRequest"", ""file_path"": ""omod/src/main/java/org/openmrs/module/htmlformentry/web/controller/HtmlFormFromFileController.java"", ""func_code"": ""@RequestMapping(\""/module/htmlformentry/htmlFormFromFile.form\"")\n\tpublic void handleRequest(Model model, @RequestParam(value = \""filePath\"", required = false) String filePath,\n\t                          @RequestParam(value = \""patientId\"", required = false) Integer pId,\n\t                          @RequestParam(value = \""isFileUpload\"", required = false) boolean isFileUpload,\n\t                          HttpServletRequest request) throws Exception {\n\n        Context.requirePrivilege(\""Manage Forms\"");\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\""In reference data...\"");\n\t\t\n\t\tmodel.addAttribute(\""previewHtml\"", \""\"");\n\t\tString message = \""\"";\n\t\tFile f = null;\n\t\ttry {\n\t\t\tif (isFileUpload) {\n\t\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\t\tMultipartFile multipartFile = multipartRequest.getFile(\""htmlFormFile\"");\n\t\t\t\tif (multipartFile != null) {\n\t\t\t\t\t//use the same file for the logged in user\n\t\t\t\t\tf = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX\n\t\t\t\t\t        + Context.getAuthenticatedUser().getSystemId());\n\t\t\t\t\tif (!f.exists())\n\t\t\t\t\t\tf.createNewFile();\n\t\t\t\t\t\n\t\t\t\t\tfilePath = f.getAbsolutePath();\n\t\t\t\t\tFileOutputStream fileOut = new FileOutputStream(f);\n\t\t\t\t\tIOUtils.copy(multipartFile.getInputStream(), fileOut);\n\t\t\t\t\tfileOut.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (StringUtils.hasText(filePath)) {\n\t\t\t\t\tf = new File(filePath);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = \""You must specify a file path to preview from file\"";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f != null && f.exists() && f.canRead()) {\n\t\t\t\tmodel.addAttribute(\""filePath\"", filePath);\n\t\t\t\t\n\t\t\t\tStringWriter writer = new StringWriter();\n\t\t\t\tIOUtils.copy(new FileInputStream(f), writer, \""UTF-8\"");\n\t\t\t\tString xml = writer.toString();\n\t\t\t\t\n\t\t\t\tPatient p = null;\n\t\t\t\tif (pId != null) {\n\t\t\t\t\tp = Context.getPatientService().getPatient(pId);\n\t\t\t\t} else {\n\t\t\t\t\tp = HtmlFormEntryUtil.getFakePerson();\n\t\t\t\t}\n\t\t\t\tHtmlForm fakeForm = new HtmlForm();\n\t\t\t\tfakeForm.setXmlData(xml);\n\t\t\t\tFormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());\n\t\t\t\tString html = fes.getHtmlToDisplay();\n\t\t\t\tif (fes.getFieldAccessorJavascript() != null) {\n                \thtml += \""<script>\"" + fes.getFieldAccessorJavascript() + \""</script>\"";\n                }\n\t\t\t\tmodel.addAttribute(\""previewHtml\"", html);\n\t\t\t\t//clear the error message\n\t\t\t\tmessage = \""\"";\n\t\t\t} else {\n\t\t\t\tmessage = \""Please specify a valid file path or select a valid file.\"";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\""An error occurred while loading the html.\"", e);\n\t\t\tmessage = \""An error occurred while loading the html. \"" + e.getMessage();\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\""message\"", message);\n\t\tmodel.addAttribute(\""isFileUpload\"", isFileUpload);\n\t}""}]","{""code"": 2, ""function"": 3}","[{""source"": ""code_info(file:HtmlFormFromFileController.java, lines:35-50)"", ""result"": ""public class HtmlFormFromFileController {\n\t\n\tprivate static final String TEMP_HTML_FORM_FILE_PREFIX = \""html_form_\"";\n\t\n\t/** Logger for this class and subclasses */\n\tprotected final Log log = LogFactory.getLog(getClass());\n\t\n\t@RequestMapping(\""/module/htmlformentry/htmlFormFromFile.form\"")\n\tpublic void handleRequest(Model model, @RequestParam(value = \""filePath\"", required = false) String filePath,\n\t                          @RequestParam(value = \""patientId\"", required = false) Integer pId,\n\t                          @RequestParam(value = \""isFileUpload\"", required = false) boolean isFileUpload,\n\t                          HttpServletRequest request) throws Exception {\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\""In reference data...\"");\n\t\t\n""}, {""source"": ""func_info(file:HtmlFormFromFileController.java, func:handleRequest)"", ""result"": [{""code"": ""\t@RequestMapping(\""/module/htmlformentry/htmlFormFromFile.form\"")\n\tpublic void handleRequest(Model model, @RequestParam(value = \""filePath\"", required = false) String filePath,\n\t                          @RequestParam(value = \""patientId\"", required = false) Integer pId,\n\t                          @RequestParam(value = \""isFileUpload\"", required = false) boolean isFileUpload,\n\t                          HttpServletRequest request) throws Exception {\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\""In reference data...\"");\n\t\t\n\t\tmodel.addAttribute(\""previewHtml\"", \""\"");\n\t\tString message = \""\"";\n\t\tFile f = null;\n\t\ttry {\n\t\t\tif (isFileUpload) {\n\t\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\t\tMultipartFile multipartFile = multipartRequest.getFile(\""htmlFormFile\"");\n\t\t\t\tif (multipartFile != null) {\n\t\t\t\t\t//use the same file for the logged in user\n\t\t\t\t\tf = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX\n\t\t\t\t\t        + Context.getAuthenticatedUser().getSystemId());\n\t\t\t\t\tif (!f.exists())\n\t\t\t\t\t\tf.createNewFile();\n\t\t\t\t\t\n\t\t\t\t\tfilePath = f.getAbsolutePath();\n\t\t\t\t\tFileOutputStream fileOut = new FileOutputStream(f);\n\t\t\t\t\tIOUtils.copy(multipartFile.getInputStream(), fileOut);\n\t\t\t\t\tfileOut.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (StringUtils.hasText(filePath)) {\n\t\t\t\t\tf = new File(filePath);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = \""You must specify a file path to preview from file\"";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f != null && f.exists() && f.canRead()) {\n\t\t\t\tmodel.addAttribute(\""filePath\"", filePath);\n\t\t\t\t\n\t\t\t\tStringWriter writer = new StringWriter();\n\t\t\t\tIOUtils.copy(new FileInputStream(f), writer, \""UTF-8\"");\n\t\t\t\tString xml = writer.toString();\n\t\t\t\t\n\t\t\t\tPatient p = null;\n\t\t\t\tif (pId != null) {\n\t\t\t\t\tp = Context.getPatientService().getPatient(pId);\n\t\t\t\t} else {\n\t\t\t\t\tp = HtmlFormEntryUtil.getFakePerson();\n\t\t\t\t}\n\t\t\t\tHtmlForm fakeForm = new HtmlForm();\n\t\t\t\tfakeForm.setXmlData(xml);\n\t\t\t\tFormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());\n\t\t\t\tString html = fes.getHtmlToDisplay();\n\t\t\t\tif (fes.getFieldAccessorJavascript() != null) {\n                \thtml += \""<script>\"" + fes.getFieldAccessorJavascript() + \""</script>\"";\n                }\n\t\t\t\tmodel.addAttribute(\""previewHtml\"", html);\n\t\t\t\t//clear the error message\n\t\t\t\tmessage = \""\"";\n\t\t\t} else {\n\t\t\t\tmessage = \""Please specify a valid file path or select a valid file.\"";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\""An error occurred while loading the html.\"", e);\n\t\t\tmessage = \""An error occurred while loading the html. \"" + e.getMessage();\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\""message\"", message);\n\t\tmodel.addAttribute(\""isFileUpload\"", isFileUpload);\n\t}\n"", ""start_line"": 42, ""end_line"": 112, ""full_name"": ""org.openmrs.module.htmlformentry.web.controller.HtmlFormFromFileController.handleRequest:void(org.springframework.ui.Model,java.lang.String,java.lang.Integer,boolean,javax.servlet.http.HttpServletRequest)"", ""file_path"": ""omod/src/main/java/org/openmrs/module/htmlformentry/web/controller/HtmlFormFromFileController.java""}]}, {""source"": ""code_info(file:HtmlFormFromFileController.java, lines:113-150)"", ""result"": ""}\n""}, {""source"": ""func_info(func:getFakePerson)"", ""result"": [{""code"": ""\tpublic static Patient getFakePerson() {\n\t\tPatient demo = new Patient(12345);\n\t\tdemo.addName(new PersonName(\""Demo\"", \""The\"", \""Person\""));\n\t\tLocation l = Context.getLocationService().getAllLocations().iterator().next();\n\t\tfor (PatientIdentifierType pit : Context.getPatientService().getAllPatientIdentifierTypes()) {\n\t\t\tif (StringUtils.isEmpty(pit.getValidator())) {\n\t\t\t\tdemo.addIdentifier(new PatientIdentifier(\""Testing\"" + pit.getName() + \""123\"", pit, l));\n\t\t\t}\n\t\t}\n\t\tdemo.setGender(\""F\"");\n\t\tdemo.setUuid(\""testing-html-form-entry\"");\n\t\t{\n\t\t\tCalendar cal = Calendar.getInstance();\n\t\t\tcal.add(Calendar.YEAR, -31);\n\t\t\tdemo.setBirthdate(cal.getTime());\n\t\t}\n\n\t\tfor (PersonAttributeType type : Context.getPersonService().getAllPersonAttributeTypes()) {\n\t\t\tif (type.getFormat() != null && type.getFormat().equals(\""java.lang.String\"")) {\n\t\t\t\tdemo.addAttribute(new PersonAttribute(type, \""Test \"" + type.getName() + \"" Attribute\""));\n\t\t\t}\n\t\t}\n\t\tPersonAddress addr = new PersonAddress();\n\t\taddr.setCityVillage(\""Rwinkwavu\"");\n\t\taddr.setCountyDistrict(\""Kayonza District\"");\n\t\taddr.setStateProvince(\""Eastern Province\"");\n\t\taddr.setCountry(\""Rwanda\"");\n\t\tdemo.addAddress(addr);\n\t\treturn demo;\n\t}\n"", ""start_line"": 453, ""end_line"": 482, ""full_name"": ""org.openmrs.module.htmlformentry.HtmlFormEntryUtil.getFakePerson:org.openmrs.Patient()"", ""file_path"": ""api/src/main/java/org/openmrs/module/htmlformentry/HtmlFormEntryUtil.java""}]}, {""source"": ""func_info(func:<init>)"", ""result"": [{""code"": ""\tpublic DrugOrderSubmissionElement1_10(FormEntryContext context, Map<String, String> parameters) {\n\t\tsuper(context, parameters);\n\t}\n"", ""start_line"": 66, ""end_line"": 68, ""full_name"": ""org.openmrs.module.htmlformentry.element.DrugOrderSubmissionElement1_10.<init>:void(org.openmrs.module.htmlformentry.FormEntryContext,java.util.Map)"", ""file_path"": ""api-1.10/src/main/java/org/openmrs/module/htmlformentry/element/DrugOrderSubmissionElement1_10.java""}, {""code"": ""\tpublic StandardRegimenElement1_10(FormEntryContext context, Map<String, String> parameters) {\n\t\tsuper(context, parameters);\n\t}\n"", ""start_line"": 30, ""end_line"": 32, ""full_name"": ""org.openmrs.module.htmlformentry.element.StandardRegimenElement1_10.<init>:void(org.openmrs.module.htmlformentry.FormEntryContext,java.util.Map)"", ""file_path"": ""api-1.10/src/main/java/org/openmrs/module/htmlformentry/element/StandardRegimenElement1_10.java""}, {""code"": ""    public BadFormDesignException() {\n        super();\n    }\n"", ""start_line"": 11, ""end_line"": 13, ""full_name"": ""org.openmrs.module.htmlformentry.BadFormDesignException.<init>:void()"", ""file_path"": ""api/src/main/java/org/openmrs/module/htmlformentry/BadFormDesignException.java""}]}]","The handleRequest method (HtmlFormFromFileController.java:42-112) processes the 'filePath' parameter without validation. The parameter is directly used to instantiate a File object (HtmlFormFromFileController.java:93) and later read (HtmlFormFromFileController.java:101), creating a vector for path traversal or file inclusion attacks. The privilege check (HtmlFormFromFileController.java:33) does not mitigate input validation flaws.",0.95,./github/other_context/CVE-2017-12795
81,CVE-2018-1000531,CWE-20,java,inversoft prime-jwt version prior to commit abb0d479389a2509f939452a6767dc424bb5e6ba contains a CWE-20 vulnerability in JWTDecoder.decode that can result in an incorrect signature validation of a JWT token. This attack can be exploitable when an attacker crafts a JWT token with a valid header using 'none' as algorithm and a body to requests it be validated. This vulnerability was fixed after commit abb0d479389a2509f939452a6767dc424bb5e6ba.,https://github.com/FusionAuth/fusionauth-jwt/commit/abb0d479389a2509f939452a6767dc424bb5e6ba,Fixing issue #3 and adding tests to confirm.,1,"[{""func_name"": ""decode"", ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java"", ""func_code"": ""private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\"".\"");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\""No Verifier has been provided for verify a signature signed using [\"" + header.algorithm.getName() + \""]\"");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }"", ""target"": 0}]","[{""func_name"": ""decode"", ""file_path"": ""src/main/java/org/primeframework/jwt/JWTDecoder.java"", ""func_code"": ""private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    // The callers of this decode will have already handled 'none' if it was deemed to be valid based upon\n    // the provided verifiers. At this point, if we have a 'none' algorithm specified in the header, it is invalid.\n    if (header.algorithm == Algorithm.none) {\n      throw new MissingVerifierException(\""No Verifier has been provided for verify a signature signed using [\"" + header.algorithm.getName() + \""]\"");\n    }\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\""No Verifier has been provided for verify a signature signed using [\"" + header.algorithm.getName() + \""]\"");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    int index = encodedJWT.lastIndexOf(\"".\"");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }""}]","{""code"": 1}","[{""source"": ""code_info(file:JWTDecoder.java, lines:1-200)"", ""result"": ""/*\n * Copyright (c) 2016-2018, Inversoft Inc., All Rights Reserved\n *\n * Licensed under the Apache License, Version 2.0 (the \""License\"");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \""AS IS\"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n */\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.Algorithm;\nimport org.primeframework.jwt.domain.Header;\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.InvalidJWTSignatureException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.json.Mapper;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\n/**\n * @author Daniel DeGroff\n */\npublic class JWTDecoder {\n\n  private static JWTDecoder instance;\n\n  public static JWTDecoder getInstance() {\n    if (instance == null) {\n      instance = new JWTDecoder();\n    }\n\n    return instance;\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. One more verifiers may be provided, the first verifier found\n   * supporting the algorithm reported by the JWT header will be utilized.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    // An unsecured JWT will not contain a signature and should only have a header and a payload.\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.length == 0) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. A JWT header value named <code>kid</code> is expected to\n   * contain the key to lookup the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT The encoded JWT in string format.\n   * @param verifiers  A map of verifiers.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\""kid\""));\n  }\n\n  /**\n   * Decode the JWT using one of they provided verifiers. The key used to lookup the correct verifier is provided by the\n   * <code>keyFunction</code>. The key function is provided the JWT header and is expected to return a string key to\n   * look up the correct verifier.\n   * <p>\n   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link\n   * JWTUnavailableForProcessingException} exception will be thrown respectively.\n   *\n   * @param encodedJWT  The encoded JWT in string format.\n   * @param verifiers   A map of verifiers.\n   * @param keyFunction A function used to lookup the verifier key from the header.\n   * @return a decoded JWT.\n   */\n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n    Objects.requireNonNull(keyFunction);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    // If parts.length == 2 we have no signature, if no verifiers were provided, decode if header says 'none', else throw an exception\n    if (parts.length == 2 && verifiers.isEmpty()) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    // If verifiers were provided, ensure it is able to verify this JWT.\n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\""The encoded JWT is not properly Base64 encoded.\"", e);\n    }\n  }\n\n  private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\"".\"");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\""No Verifier has been provided for verify a signature signed using [\"" + header.algorithm.getName() + \""]\"");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }\n\n  private String[] getParts(String encodedJWT) {\n    String[] parts = encodedJWT.split(\""\\\\.\"");\n    // Secured JWT XXXXX.YYYYY.ZZZZZ, Unsecured JWT XXXXX.YYYYY.\n    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith(\"".\""))) {\n      return parts;\n    }\n\n    throw new InvalidJWTException(\""The encoded JWT is not properly formatted. Expected a three part dot separated string.\"");\n  }\n}\n""}]","src/main/java/org/primeframework/jwt/JWTDecoder.java:62-64: Previous code allowed 'none' algorithm without enforcing a verifier. Patch adds explicit validation. The header's algorithm is parsed via `Mapper.deserialize(base64Decode(parts[0].getBytes(...)), Header.class)` in public `decode` methods (lines 19-21, 44-46). If 'none' is specified in the header and a verifier is present (e.g., parts.length == 3), the old code would attempt signature verification, while the patch throws `MissingVerifierException` before verification.",0.95,./github/other_context/CVE-2018-1000531
82,CVE-2018-9862,CWE-838,c_cpp,"util.c in runV 1.0.0 for Docker mishandles a numeric username, which allows attackers to obtain root access by leveraging the presence of an initial numeric value on an /etc/passwd line, and then issuing a ""docker exec"" command with that value in the -u argument, a similar issue to CVE-2016-3697.",https://github.com/hyperhq/hyperstart/commit/ad6e43325da7d5f8048f23451bef26fdf4c0f93d,Security: fix a issue (similar to  runc CVE-2016-3697)\n\nSigned-off-by: y00316549 <yangshukui@huawei.com>,2,"[{""func_name"": ""hyper_getpwnam"", ""file_path"": ""src/util.c"", ""func_code"": ""struct passwd *hyper_getpwnam(const char *name)\n{\n\tuid_t uid = (uid_t)id_or_max(name);\n\tFILE *file = fopen(\""/etc/passwd\"", \""r\"");\n\tif (!file) {\n\t\tperror(\""faile to open /etc/passwd\"");\n\t\treturn NULL;\n\t}\n\tfor (;;) {\n\t\tstruct passwd *pwd = fgetpwent(file);\n\t\tif (!pwd)\n\t\t\tbreak;\n\t\tif (!strcmp(pwd->pw_name, name) || pwd->pw_uid == uid) {\n\t\t\tfclose(file);\n\t\t\treturn pwd;\n\t\t}\n\t}\n\tfclose(file);\n\treturn NULL;\n}"", ""target"": 0}, {""func_name"": ""hyper_getgrnam"", ""file_path"": ""src/util.c"", ""func_code"": ""struct group *hyper_getgrnam(const char *name)\n{\n\tgid_t gid = (gid_t)id_or_max(name);\n\tFILE *file = fopen(\""/etc/group\"", \""r\"");\n\tif (!file) {\n\t\tperror(\""faile to open /etc/group\"");\n\t\treturn NULL;\n\t}\n\tfor (;;) {\n\t\tstruct group *gr = fgetgrent(file);\n\t\tif (!gr)\n\t\t\tbreak;\n\t\tif (!strcmp(gr->gr_name, name) || gr->gr_gid == gid) {\n\t\t\tfclose(file);\n\t\t\treturn gr;\n\t\t}\n\t}\n\tfclose(file);\n\treturn NULL;\n}"", ""target"": 0}]","[{""func_name"": ""hyper_getpwnam"", ""file_path"": ""src/util.c"", ""func_code"": ""struct passwd *hyper_getpwnam(const char *name)\n{\n\tuid_t uid;\n\tFILE *file;\n\tstruct passwd *pwd;\n\n\tuid = (uid_t)id_or_max(name);\n\tfile = fopen(\""/etc/passwd\"", \""r\"");\n\tif (!file) {\n\t\tperror(\""faile to open /etc/passwd\"");\n\t\treturn NULL;\n\t}\n\tfor (;;) {\n\t\tpwd = fgetpwent(file);\n\t\tif (!pwd)\n\t\t\tbreak;\n\t\tif (pwd->pw_uid == uid ||\n\t\t  (!strcmp(pwd->pw_name, name) && (uid_t)INVALID_UGID == uid)) {\n\t\t\tfclose(file);\n\t\t\treturn pwd;\n\t\t}\n\t}\n\tfclose(file);\n\treturn NULL;\n}""}, {""func_name"": ""hyper_getgrnam"", ""file_path"": ""src/util.c"", ""func_code"": ""struct group *hyper_getgrnam(const char *name)\n{\n\tgid_t gid;\n\tFILE *file;\n\tstruct group *gr = NULL;\n\n\tgid = (gid_t)id_or_max(name);\n\tfile = fopen(\""/etc/group\"", \""r\"");\n\tif (!file) {\n\t\tperror(\""faile to open /etc/group\"");\n\t\treturn NULL;\n\t}\n\tfor (;;) {\n\t\tgr = fgetgrent(file);\n\t\tif (!gr)\n\t\t\tbreak;\n\t\tif (gr->gr_gid == gid ||\n\t\t  (!strcmp(gr->gr_name, name) &&  (gid_t)INVALID_UGID == gid)) {\n\t\t\tfclose(file);\n\t\t\treturn gr;\n\t\t}\n\t}\n\tfclose(file);\n\treturn NULL;\n}""}]","{""function"": 1}","[{""source"": ""func_info(file:util.c, func:id_or_max)"", ""result"": [{""code"": ""static unsigned long id_or_max(const char *name)\n{\n\tchar *ptr;\n\terrno = 0;\n\tlong id = strtol(name, &ptr, 10);\n\tif (name == ptr || id < 0 || (errno != 0 && id == 0) || *ptr != '\\0')\n\t\treturn ~0UL;\n\treturn id;\n}"", ""start_line"": 130, ""end_line"": 138, ""full_name"": ""id_or_max"", ""file_path"": ""src/util.c""}]}]","src/util.c: In `hyper_getpwnam` and `hyper_getgrnam`, the original code allowed matches if `pwd->pw_uid == uid` OR `!strcmp(pwd->pw_name, name)`. This permitted attackers to exploit numeric usernames in `/etc/passwd` by passing a numeric string (e.g., `0`) to `-u`, which would match the username field if it matched the numeric value, even if the UID was different. The patch modifies the condition to only allow username matches when `uid` is invalid (i.e., `INVALID_UGID`), ensuring numeric inputs are treated strictly as UIDs. The `id_or_max` function (src/util.c:130-138) converts numeric strings to UIDs, returning `~0UL` for invalid inputs, which `INVALID_UGID` is defined as (implied by `~0UL` in `id_or_max`).",0.95,./github/other_context/CVE-2018-9862
83,CVE-2019-1010247,CWE-79,c_cpp,"ZmartZone IAM mod_auth_openidc 2.3.10.1 and earlier is affected by: Cross Site Scripting (XSS). The impact is: Redirecting the user to a phishing page or interacting with the application on behalf of the user. The component is: File: src/mod_auth_openidc.c, Line: 3109. The fixed version is: 2.3.10.2.",https://github.com/OpenIDC/mod_auth_openidc/commit/132a4111bf3791e76437619a66336dce2ce4c79b,release 2.3.10.2: fix XSS vulnerability for poll parameter\n\nin OIDC Session Management RP iframe; CSNC-2019-001; thanks Mischa\nBachmann\n\nSigned-off-by: Hans Zandbelt <hans.zandbelt@zmartzone.eu>,1,"[{""func_name"": ""oidc_handle_session_management_iframe_rp"", ""file_path"": ""src/mod_auth_openidc.c"", ""func_code"": ""static int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \""enter\"");\n\n\tconst char *java_script =\n\t\t\t\""    <script type=\\\""text/javascript\\\"">\\n\""\n\t\t\t\""      var targetOrigin  = '%s';\\n\""\n\t\t\t\""      var message = '%s' + ' ' + '%s';\\n\""\n\t\t\t\""\t   var timerID;\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""      function checkSession() {\\n\""\n\t\t\t\""        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\""\n\t\t\t\""        var win = window.parent.document.getElementById('%s').contentWindow;\\n\""\n\t\t\t\""        win.postMessage( message, targetOrigin);\\n\""\n\t\t\t\""      }\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""      function setTimer() {\\n\""\n\t\t\t\""        checkSession();\\n\""\n\t\t\t\""        timerID = setInterval('checkSession()', %s);\\n\""\n\t\t\t\""      }\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""      function receiveMessage(e) {\\n\""\n\t\t\t\""        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\""\n\t\t\t\""        if (e.origin !== targetOrigin ) {\\n\""\n\t\t\t\""          console.debug('receiveMessage: cross-site scripting attack?');\\n\""\n\t\t\t\""          return;\\n\""\n\t\t\t\""        }\\n\""\n\t\t\t\""        if (e.data != 'unchanged') {\\n\""\n\t\t\t\""          clearInterval(timerID);\\n\""\n\t\t\t\""          if (e.data == 'changed') {\\n\""\n\t\t\t\""\t\t     window.location.href = '%s?session=check';\\n\""\n\t\t\t\""          } else {\\n\""\n\t\t\t\""\t\t     window.location.href = '%s?session=logout';\\n\""\n\t\t\t\""          }\\n\""\n\t\t\t\""        }\\n\""\n\t\t\t\""      }\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""      window.addEventListener('message', receiveMessage, false);\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""    </script>\\n\"";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \""openidc-op\"";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = oidc_session_get_session_state(r, session);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\""no session_state found in the session; the OP does probably not support session management!?\"");\n\t\treturn DONE;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \""poll\"", &s_poll_interval);\n\tif (s_poll_interval == NULL)\n\t\ts_poll_interval = \""3000\"";\n\n\tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state, op_iframe_id, s_poll_interval, redirect_uri,\n\t\t\tredirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \""setTimer\"", NULL, DONE);\n}"", ""target"": 0}]","[{""func_name"": ""oidc_handle_session_management_iframe_rp"", ""file_path"": ""src/mod_auth_openidc.c"", ""func_code"": ""static int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \""enter\"");\n\n\tconst char *java_script =\n\t\t\t\""    <script type=\\\""text/javascript\\\"">\\n\""\n\t\t\t\""      var targetOrigin  = '%s';\\n\""\n\t\t\t\""      var message = '%s' + ' ' + '%s';\\n\""\n\t\t\t\""\t   var timerID;\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""      function checkSession() {\\n\""\n\t\t\t\""        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\""\n\t\t\t\""        var win = window.parent.document.getElementById('%s').contentWindow;\\n\""\n\t\t\t\""        win.postMessage( message, targetOrigin);\\n\""\n\t\t\t\""      }\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""      function setTimer() {\\n\""\n\t\t\t\""        checkSession();\\n\""\n\t\t\t\""        timerID = setInterval('checkSession()', %d);\\n\""\n\t\t\t\""      }\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""      function receiveMessage(e) {\\n\""\n\t\t\t\""        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\""\n\t\t\t\""        if (e.origin !== targetOrigin ) {\\n\""\n\t\t\t\""          console.debug('receiveMessage: cross-site scripting attack?');\\n\""\n\t\t\t\""          return;\\n\""\n\t\t\t\""        }\\n\""\n\t\t\t\""        if (e.data != 'unchanged') {\\n\""\n\t\t\t\""          clearInterval(timerID);\\n\""\n\t\t\t\""          if (e.data == 'changed') {\\n\""\n\t\t\t\""\t\t     window.location.href = '%s?session=check';\\n\""\n\t\t\t\""          } else {\\n\""\n\t\t\t\""\t\t     window.location.href = '%s?session=logout';\\n\""\n\t\t\t\""          }\\n\""\n\t\t\t\""        }\\n\""\n\t\t\t\""      }\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""      window.addEventListener('message', receiveMessage, false);\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""    </script>\\n\"";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \""openidc-op\"";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = oidc_session_get_session_state(r, session);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\""no session_state found in the session; the OP does probably not support session management!?\"");\n\t\treturn DONE;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \""poll\"", &s_poll_interval);\n\tint poll_interval = s_poll_interval ? strtol(s_poll_interval, NULL, 10) : 0;\n\tif ((poll_interval <= 0) || (poll_interval > 3600 * 24))\n\t\tpoll_interval = 3000;\n\n\tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state, op_iframe_id, poll_interval, redirect_uri,\n\t\t\tredirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \""setTimer\"", NULL, DONE);\n}""}]","{""code"": 2}","[{""source"": ""code_info(file:mod_auth_openidc.c, lines:3150-3160)"", ""result"": ""\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \""poll\"", &s_poll_interval);\n\tif (s_poll_interval == NULL)\n\t\ts_poll_interval = \""3000\"";\n\n\tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state, op_iframe_id, s_poll_interval, redirect_uri,\n\t\t\tredirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \""setTimer\"", NULL, DONE);\n""}, {""source"": ""code_info(file:mod_auth_openidc.c, lines:3100-3115)"", ""result"": ""\t\t\t\""\\n\""\n\t\t\t\""      function checkSession() {\\n\""\n\t\t\t\""        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\""\n\t\t\t\""        var win = window.parent.document.getElementById('%s').contentWindow;\\n\""\n\t\t\t\""        win.postMessage( message, targetOrigin);\\n\""\n\t\t\t\""      }\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""      function setTimer() {\\n\""\n\t\t\t\""        checkSession();\\n\""\n\t\t\t\""        timerID = setInterval('checkSession()', %s);\\n\""\n\t\t\t\""      }\\n\""\n\t\t\t\""\\n\""\n\t\t\t\""      function receiveMessage(e) {\\n\""\n\t\t\t\""        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\""\n\t\t\t\""        if (e.origin !== targetOrigin ) {\\n\""\n\t\t\t\""          console.debug('receiveMessage: cross-site scripting attack?');\\n\""\n""}]",src/mod_auth_openidc.c:3150-3152 (untrusted 'poll' parameter stored as string without validation) → src/mod_auth_openidc.c:3109 (unsanitized string injected into JavaScript via apr_psprintf with %s). Patch fixes by converting to integer with bounds check (src/mod_auth_openidc.c:3150-3152) and using %d (src/mod_auth_openidc.c:3109).,0.95,./github/other_context/CVE-2019-1010247
84,CVE-2019-1010295,"CWE-20, CWE-787, CWE-125",c_cpp,Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Memory corruption and disclosure of memory content. The component is: optee_os. The fixed version is: 3.4.0 and later.,https://github.com/OP-TEE/optee_os/commit/d5c5b0b77b2b589666024d219a8007b3f5b6faeb,"core: svc: always check ta parameters\n\nAlways check TA parameters from a user TA. This prevents a user TA from\npassing invalid pointers to a pseudo TA.\n\nFixes: OP-TEE-2018-0007: ""Buffer checks missing when calling pseudo\nTAs"".\n\nSigned-off-by: Jens Wiklander <jens.wiklander@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",2,"[{""func_name"": ""tee_svc_copy_param"", ""file_path"": ""core/tee/tee_svc.c"", ""func_code"": ""static TEE_Result tee_svc_copy_param(struct tee_ta_session *sess,\n\t\t\t\t     struct tee_ta_session *called_sess,\n\t\t\t\t     struct utee_params *callee_params,\n\t\t\t\t     struct tee_ta_param *param,\n\t\t\t\t     void *tmp_buf_va[TEE_NUM_PARAMS],\n\t\t\t\t     struct mobj **mobj_tmp)\n{\n\tsize_t n;\n\tTEE_Result res;\n\tsize_t req_mem = 0;\n\tsize_t s;\n\tuint8_t *dst = 0;\n\tbool ta_private_memref[TEE_NUM_PARAMS];\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tvoid *va;\n\tsize_t dst_offs;\n\n\t/* fill 'param' input struct with caller params description buffer */\n\tif (!callee_params) {\n\t\tmemset(param, 0, sizeof(*param));\n\t} else {\n\t\tres = tee_mmu_check_access_rights(utc,\n\t\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t(uaddr_t)callee_params, sizeof(struct utee_params));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tutee_param_to_param(param, callee_params);\n\t}\n\n\tif (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {\n\t\t/* pseudo TA borrows the mapping of the calling TA */\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* All mobj in param are of type MOJB_TYPE_VIRT */\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tta_private_memref[n] = false;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\ts = param->u[n].mem.size;\n\t\t\tif (!va) {\n\t\t\t\tif (s)\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* uTA cannot expose its private memory */\n\t\t\tif (tee_mmu_is_vbuf_inside_ta_private(utc, va, s)) {\n\n\t\t\t\ts = ROUNDUP(s, sizeof(uint32_t));\n\t\t\t\tif (ADD_OVERFLOW(req_mem, s, &req_mem))\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tta_private_memref[n] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tres = tee_mmu_vbuf_to_mobj_offs(utc, va, s,\n\t\t\t\t\t\t\t&param->u[n].mem.mobj,\n\t\t\t\t\t\t\t&param->u[n].mem.offs);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (req_mem == 0)\n\t\treturn TEE_SUCCESS;\n\n\tres = alloc_temp_sec_mem(req_mem, mobj_tmp, &dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdst_offs = 0;\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tif (!ta_private_memref[n])\n\t\t\tcontinue;\n\n\t\ts = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tres = tee_svc_copy_from_user(dst, va,\n\t\t\t\t\t\tparam->u[n].mem.size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""utee_param_to_param"", ""file_path"": ""core/tee/tee_svc.c"", ""func_code"": ""static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""tee_svc_copy_param"", ""file_path"": ""core/tee/tee_svc.c"", ""func_code"": ""static TEE_Result tee_svc_copy_param(struct tee_ta_session *sess,\n\t\t\t\t     struct tee_ta_session *called_sess,\n\t\t\t\t     struct utee_params *callee_params,\n\t\t\t\t     struct tee_ta_param *param,\n\t\t\t\t     void *tmp_buf_va[TEE_NUM_PARAMS],\n\t\t\t\t     struct mobj **mobj_tmp)\n{\n\tsize_t n;\n\tTEE_Result res;\n\tsize_t req_mem = 0;\n\tsize_t s;\n\tuint8_t *dst = 0;\n\tbool ta_private_memref[TEE_NUM_PARAMS];\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tvoid *va;\n\tsize_t dst_offs;\n\n\t/* fill 'param' input struct with caller params description buffer */\n\tif (!callee_params) {\n\t\tmemset(param, 0, sizeof(*param));\n\t} else {\n\t\tres = tee_mmu_check_access_rights(utc,\n\t\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t(uaddr_t)callee_params, sizeof(struct utee_params));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tres = utee_param_to_param(utc, param, callee_params);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {\n\t\t/* pseudo TA borrows the mapping of the calling TA */\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* All mobj in param are of type MOJB_TYPE_VIRT */\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tta_private_memref[n] = false;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\ts = param->u[n].mem.size;\n\t\t\tif (!va) {\n\t\t\t\tif (s)\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* uTA cannot expose its private memory */\n\t\t\tif (tee_mmu_is_vbuf_inside_ta_private(utc, va, s)) {\n\n\t\t\t\ts = ROUNDUP(s, sizeof(uint32_t));\n\t\t\t\tif (ADD_OVERFLOW(req_mem, s, &req_mem))\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tta_private_memref[n] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tres = tee_mmu_vbuf_to_mobj_offs(utc, va, s,\n\t\t\t\t\t\t\t&param->u[n].mem.mobj,\n\t\t\t\t\t\t\t&param->u[n].mem.offs);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (req_mem == 0)\n\t\treturn TEE_SUCCESS;\n\n\tres = alloc_temp_sec_mem(req_mem, mobj_tmp, &dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdst_offs = 0;\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tif (!ta_private_memref[n])\n\t\t\tcontinue;\n\n\t\ts = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tres = tee_svc_copy_from_user(dst, va,\n\t\t\t\t\t\tparam->u[n].mem.size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}""}, {""func_name"": ""utee_param_to_param"", ""file_path"": ""core/tee/tee_svc.c"", ""func_code"": ""static TEE_Result utee_param_to_param(struct user_ta_ctx *utc,\n\t\t\t\t      struct tee_ta_param *p,\n\t\t\t\t      struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\t\tuint32_t flags = TEE_MEMORY_ACCESS_READ |\n\t\t\t\t TEE_MEMORY_ACCESS_ANY_OWNER;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tflags |= TEE_MEMORY_ACCESS_WRITE;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tif (tee_mmu_check_access_rights(utc, flags, a, b))\n\t\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}""}]","{""caller"": 1, ""code"": 1, ""function"": 1}","[{""source"": ""caller_info(file:tee_svc.c, func:tee_svc_copy_param)"", ""result"": [{""call_line"": 764, ""call_code"": ""tee_svc_copy_param(sess, NULL, usr_param, param, tmp_buf_va,\n\t\t\t\t &mobj_param)"", ""caller_code"": ""TEE_Result syscall_open_ta_session(const TEE_UUID *dest,\n\t\t\tunsigned long cancel_req_to,\n\t\t\tstruct utee_params *usr_param, uint32_t *ta_sess,\n\t\t\tuint32_t *ret_orig)\n{\n\tTEE_Result res;\n\tuint32_t ret_o = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s = NULL;\n\tstruct tee_ta_session *sess;\n\tstruct mobj *mobj_param = NULL;\n\tTEE_UUID *uuid = malloc(sizeof(TEE_UUID));\n\tstruct tee_ta_param *param = malloc(sizeof(struct tee_ta_param));\n\tTEE_Identity *clnt_id = malloc(sizeof(TEE_Identity));\n\tvoid *tmp_buf_va[TEE_NUM_PARAMS] = { NULL };\n\tstruct user_ta_ctx *utc;\n\n\tif (uuid == NULL || param == NULL || clnt_id == NULL) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out_free_only;\n\t}\n\n\tmemset(param, 0, sizeof(struct tee_ta_param));\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out_free_only;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_copy_from_user(uuid, dest, sizeof(TEE_UUID));\n\tif (res != TEE_SUCCESS)\n\t\tgoto function_exit;\n\n\tclnt_id->login = TEE_LOGIN_TRUSTED_APP;\n\tmem..."", ""caller_start"": 729, ""file_path"": ""core/tee/tee_svc.c""}, {""call_line"": 838, ""call_code"": ""tee_svc_copy_param(sess, called_sess, usr_param, &param,\n\t\t\t\t tmp_buf_va, &mobj_param)"", ""caller_code"": ""TEE_Result syscall_invoke_ta_command(unsigned long ta_sess,\n\t\t\tunsigned long cancel_req_to, unsigned long cmd_id,\n\t\t\tstruct utee_params *usr_param, uint32_t *ret_orig)\n{\n\tTEE_Result res;\n\tTEE_Result res2;\n\tuint32_t ret_o = TEE_ORIGIN_TEE;\n\tstruct tee_ta_param param = { 0 };\n\tTEE_Identity clnt_id;\n\tstruct tee_ta_session *sess;\n\tstruct tee_ta_session *called_sess;\n\tstruct mobj *mobj_param = NULL;\n\tvoid *tmp_buf_va[TEE_NUM_PARAMS] = { NULL };\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tcalled_sess = tee_ta_get_session(\n\t\t\t\t(vaddr_t)tee_svc_uref_to_kaddr(ta_sess), true,\n\t\t\t\t&utc->open_sessions);\n\tif (!called_sess)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tclnt_id.login = TEE_LOGIN_TRUSTED_APP;\n\tmemcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));\n\n\tres = tee_svc_copy_param(sess, called_sess, usr_param, &param,\n\t\t\t\t tmp_buf_va, &mobj_param);\n\tif (res != TEE_SUCCESS)\n\t\tgoto function_exit;\n..."", ""caller_start"": 809, ""file_path"": ""core/tee/tee_svc.c""}]}, {""source"": ""code_info(file:tee_svc.c, lines:729-764)"", ""result"": ""TEE_Result syscall_open_ta_session(const TEE_UUID *dest,\n\t\t\tunsigned long cancel_req_to,\n\t\t\tstruct utee_params *usr_param, uint32_t *ta_sess,\n\t\t\tuint32_t *ret_orig)\n{\n\tTEE_Result res;\n\tuint32_t ret_o = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s = NULL;\n\tstruct tee_ta_session *sess;\n\tstruct mobj *mobj_param = NULL;\n\tTEE_UUID *uuid = malloc(sizeof(TEE_UUID));\n\tstruct tee_ta_param *param = malloc(sizeof(struct tee_ta_param));\n\tTEE_Identity *clnt_id = malloc(sizeof(TEE_Identity));\n\tvoid *tmp_buf_va[TEE_NUM_PARAMS] = { NULL };\n\tstruct user_ta_ctx *utc;\n\n\tif (uuid == NULL || param == NULL || clnt_id == NULL) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out_free_only;\n\t}\n\n\tmemset(param, 0, sizeof(struct tee_ta_param));\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out_free_only;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_copy_from_user(uuid, dest, sizeof(TEE_UUID));\n\tif (res != TEE_SUCCESS)\n\t\tgoto function_exit;\n\n\tclnt_id->login = TEE_LOGIN_TRUSTED_APP;\n\tmemcpy(&clnt_id->uuid, &sess->ctx->uuid, sizeof(TEE_UUID));\n\n\tres = tee_svc_copy_param(sess, NULL, usr_param, param, tmp_buf_va,\n\t\t\t\t &mobj_param);\n""}, {""source"": ""func_info(file:tee_svc.c, func:tee_svc_copy_from_user)"", ""result"": [{""code"": ""TEE_Result tee_svc_copy_from_user(void *kaddr, const void *uaddr, size_t len)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn re"", ""start_line"": 885, ""end_line"": 903, ""full_name"": ""tee_svc_copy_from_user"", ""file_path"": ""core/tee/tee_svc.c""}]}]","The vulnerability arises from missing validation of memory references in user TAs when calling pseudo TAs. The patch adds validation in `utee_param_to_param` (core/tee/tee_svc.c:506-508) for MEMREF types via `tee_mmu_check_access_rights()`, and `tee_svc_copy_param` (core/tee/tee_svc.c:578-580) now propagates errors. The trigger chain begins with user TA parameters (`usr_param`) passed to `syscall_open_ta_session` (core/tee/tee_svc.c:764) and `syscall_invoke_ta_command` (core/tee/tee_svc.c:838), which pass the parameters to `tee_svc_copy_param`. The source of `usr_param` (how it is copied from userspace) remains unconfirmed due to missing code evidence.",0.95,./github/other_context/CVE-2019-1010295
85,CVE-2019-12439,CWE-20,c_cpp,"bubblewrap.c in Bubblewrap before 0.3.3 misuses temporary directories in /tmp as a mount point. In some particular configurations (related to XDG_RUNTIME_DIR), a local attacker may abuse this flaw to prevent other users from executing bubblewrap or potentially execute code.",https://github.com/containers/bubblewrap/commit/efc89e3b939b4bde42c10f065f6b7b02958ed50e,"Don't create our own temporary mount point for pivot_root\n\nAn attacker could pre-create /tmp/.bubblewrap-$UID and make it a\nnon-directory, non-symlink (in which case mounting our tmpfs would fail,\ncausing denial of service), or make it a symlink under their control\n(potentially allowing bad things if the protected_symlinks sysctl is\nnot enabled).\n\nInstead, temporarily mount the tmpfs on a directory that we are sure\nexists and is not attacker-controlled. /tmp (the directory itself, not\na subdirectory) will do.\n\nFixes: #304\nBug-Debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=923557\nSigned-off-by: Simon McVittie <smcv@debian.org>\n\nCloses: #305\nApproved by: cgwalters",1,"[{""func_name"": ""main"", ""file_path"": ""bubblewrap.c"", ""func_code"": ""int\nmain (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  cleanup_free char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  int setup_finished_pipe[] = {-1, -1};\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n  cleanup_free char *seccomp_data = NULL;\n  size_t seccomp_len;\n  struct sock_fprog seccomp_prog;\n  cleanup_free char *args_data = NULL;\n\n  /* Handle --version early on before we try to acquire/drop\n   * any capabilities so it works in a build environment;\n   * right now flatpak's build runs bubblewrap --version.\n   * https://github.com/projectatomic/bubblewrap/issues/185\n   */\n  if (argc == 2 && (strcmp (argv[1], \""--version\"") == 0))\n    print_version_and_exit ();\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\""prctl(PR_SET_NO_NEW_CAPS) failed\"");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, (const char ***) &argv);\n\n  /* suck the args into a cleanup_free variable to control their lifecycle */\n  args_data = opt_args_data;\n  opt_args_data = NULL;\n\n  if ((requested_caps[0] || requested_caps[1]) && is_privileged)\n    die (\""--cap-add in setuid mode can be used only by root\"");\n\n  if (opt_userns_block_fd != -1 && !opt_unshare_user)\n    die (\""--userns-block-fd requires --unshare-user\"");\n\n  if (opt_userns_block_fd != -1 && opt_info_fd == -1)\n    die (\""--userns-block-fd requires --info-fd\"");\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n#ifdef ENABLE_REQUIRE_USERNS\n  /* In this build option, we require userns. */\n  if (is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n#endif\n\n  if (opt_unshare_user_try &&\n      stat (\""/proc/self/ns/user\"", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\""/sys/module/user_namespace/parameters/enable\"", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \""/sys/module/user_namespace/parameters/enable\"");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Check for max_user_namespaces */\n      if (stat (\""/proc/sys/user/max_user_namespaces\"", &sbuf) == 0)\n        {\n          cleanup_free char *max_user_ns = NULL;\n          max_user_ns = load_file_at (AT_FDCWD, \""/proc/sys/user/max_user_namespaces\"");\n          if (max_user_ns != NULL && strcmp(max_user_ns, \""0\\n\"") == 0)\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\""Creating root mount point\\n\""));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\""Specifying --uid requires --unshare-user\"");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\""Specifying --gid requires --unshare-user\"");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\""Specifying --hostname requires --unshare-uts\"");\n\n  if (opt_as_pid_1 && !opt_unshare_pid)\n    die (\""Specifying --as-pid-1 requires --unshare-pid\"");\n\n  if (opt_as_pid_1 && lock_files != NULL)\n    die (\""Specifying --as-pid-1 and --lock-file is not permitted\"");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\""/proc\"", O_PATH);\n  if (proc_fd == -1)\n    die_with_error (\""Can't open /proc\"");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n     We first try in /run, and if that fails, try in /tmp. */\n  base_path = xasprintf (\""/run/user/%d/.bubblewrap\"", real_uid);\n  if (ensure_dir (base_path, 0755))\n    {\n      free (base_path);\n      base_path = xasprintf (\""/tmp/.bubblewrap-%d\"", real_uid);\n      if (ensure_dir (base_path, 0755))\n        die_with_error (\""Creating root mountpoint failed\"");\n    }\n\n  __debug__ ((\""creating new namespace\\n\""));\n\n  if (opt_unshare_pid && !opt_as_pid_1)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\""eventfd()\"");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\""/proc/self/ns/cgroup\"", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\""Cannot create new cgroup namespace because the kernel does not support it\"");\n          else\n            die_with_error (\""stat on /proc/self/ns/cgroup failed\"");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\""/proc/self/ns/cgroup\"", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\""eventfd()\"");\n\n  /* Track whether pre-exec setup finished if we're reporting process exit */\n  if (opt_json_status_fd != -1)\n    {\n      int ret;\n      ret = pipe2 (setup_finished_pipe, O_CLOEXEC);\n      if (ret == -1)\n        die_with_error (\""pipe2()\"");\n    }\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\""Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\"");\n          else if (errno == EPERM && !is_privileged)\n            die (\""No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\"");\n        }\n\n      die_with_error (\""Creating new namespace failed\"");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs (FALSE);\n\n      /* Optionally bind our lifecycle to that of the parent */\n      handle_die_with_parent ();\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\""{\\n    \\\""child-pid\\\"": %i\\n}\\n\"", pid);\n          dump_info (opt_info_fd, output, TRUE);\n          close (opt_info_fd);\n        }\n      if (opt_json_status_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\""{ \\\""child-pid\\\"": %i }\\n\"", pid);\n          dump_info (opt_json_status_fd, output, TRUE);\n        }\n\n      if (opt_userns_block_fd != -1)\n        {\n          char b[1];\n          (void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));\n          close (opt_userns_block_fd);\n        }\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      return monitor_child (event_fd, pid, setup_finished_pipe[0]);\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  if (opt_json_status_fd != -1)\n    close (opt_json_status_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net)\n    loopback_setup (); /* Will exit if unsuccessful */\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \""/\"", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\""Failed to make / slave\"");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\""tmpfs\"", base_path, \""tmpfs\"", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\""Failed to mount tmpfs\"");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \""oldroot\"" and \""newroot\"". */\n  if (chdir (base_path) != 0)\n    die_with_error (\""chdir base_path\"");\n\n  /* We create a subdir \""$base_path/newroot\"" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \""$base_path/oldroot\"". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / */\n\n  if (mkdir (\""newroot\"", 0755))\n    die_with_error (\""Creating newroot failed\"");\n\n  if (mount (\""newroot\"", \""newroot\"", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)\n    die_with_error (\""setting up newroot bind\"");\n\n  if (mkdir (\""oldroot\"", 0755))\n    die_with_error (\""Creating oldroot failed\"");\n\n  if (pivot_root (base_path, \""oldroot\""))\n    die_with_error (\""pivot_root\"");\n\n  if (chdir (\""/\"") != 0)\n    die_with_error (\""chdir / (base path)\"");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\""Can't create privsep socket\"");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\""Can't fork unprivileged helper\"");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs (FALSE);\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\""Can't write to op_socket\"");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  close_ops_fd ();\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\""oldroot\"", \""oldroot\"", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\""Failed to make old root rprivate\"");\n\n  if (umount2 (\""oldroot\"", MNT_DETACH))\n    die_with_error (\""unmount old root\"");\n\n  /* This is our second pivot. It's like we're a Silicon Valley startup flush\n   * with cash but short on ideas!\n   *\n   * We're aiming to make /newroot the real root, and get rid of /oldroot. To do\n   * that we need a temporary place to store it before we can unmount it.\n   */\n  { cleanup_fd int oldrootfd = open (\""/\"", O_DIRECTORY | O_RDONLY);\n    if (oldrootfd < 0)\n      die_with_error (\""can't open /\"");\n    if (chdir (\""/newroot\"") != 0)\n      die_with_error (\""chdir /newroot\"");\n    /* While the documentation claims that put_old must be underneath\n     * new_root, it is perfectly fine to use the same directory as the\n     * kernel checks only if old_root is accessible from new_root.\n     *\n     * Both runc and LXC are using this \""alternative\"" method for\n     * setting up the root of the container:\n     *\n     * https://github.com/opencontainers/runc/blob/master/libcontainer/rootfs_linux.go#L671\n     * https://github.com/lxc/lxc/blob/master/src/lxc/conf.c#L1121\n     */\n    if (pivot_root (\"".\"", \"".\"") != 0)\n      die_with_error (\""pivot_root(/newroot)\"");\n    if (fchdir (oldrootfd) < 0)\n      die_with_error (\""fchdir to oldroot\"");\n    if (umount2 (\"".\"", MNT_DETACH) < 0)\n      die_with_error (\""umount old root\"");\n    if (chdir (\""/\"") != 0)\n      die_with_error (\""chdir /\"");\n  }\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&\n      opt_userns_block_fd == -1)\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\""unshare user ns\"");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* All privileged ops are done now, so drop caps we don't need */\n  drop_privs (!is_privileged);\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      (void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\""Can't read seccomp data\"");\n\n      if (seccomp_len % 8 != 0)\n        die (\""Invalid seccomp data, must be multiple of 8\"");\n\n      seccomp_prog.len = seccomp_len / 8;\n      seccomp_prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n    }\n\n  umask (old_umask);\n\n  new_cwd = \""/\"";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\""Can't chdir to %s\"", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\""HOME\"");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\""PWD\"", new_cwd, 1);\n  free (old_cwd);\n\n  if (opt_new_session &&\n      setsid () == (pid_t) -1)\n    die_with_error (\""setsid\"");\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\""label_exec %s\"", argv[0]);\n\n  __debug__ ((\""forking for child\\n\""));\n\n  if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\""Can't fork for pid 1\"");\n\n      if (pid != 0)\n        {\n          drop_all_caps (FALSE);\n\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);\n        }\n    }\n\n  __debug__ ((\""launch executable %s\\n\"", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  /* If we are using --as-pid-1 leak the sync fd into the sandbox.\n     --sync-fd will still work unless the container process doesn't close this file.  */\n  if (!opt_as_pid_1)\n    {\n      if (opt_sync_fd != -1)\n        close (opt_sync_fd);\n    }\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  /* Optionally bind our lifecycle */\n  handle_die_with_parent ();\n\n  if (!is_privileged)\n    set_ambient_capabilities ();\n\n  /* Should be the last thing before execve() so that filters don't\n   * need to handle anything above */\n  if (seccomp_data != NULL &&\n      prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)\n    die_with_error (\""prctl(PR_SET_SECCOMP)\"");\n\n  if (setup_finished_pipe[1] != -1)\n    {\n      char data = 0;\n      res = write_to_fd (setup_finished_pipe[1], &data, 1);\n      /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n         we don't want to error out here */\n    }\n\n  if (execvp (argv[0], argv) == -1)\n    {\n      if (setup_finished_pipe[1] != -1)\n        {\n          int saved_errno = errno;\n          char data = 0;\n          res = write_to_fd (setup_finished_pipe[1], &data, 1);\n          errno = saved_errno;\n          /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n             we don't want to error out here */\n        }\n      die_with_error (\""execvp %s\"", argv[0]);\n    }\n\n  return 0;\n}"", ""target"": 0}]","[{""func_name"": ""main"", ""file_path"": ""bubblewrap.c"", ""func_code"": ""int\nmain (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  const char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  int setup_finished_pipe[] = {-1, -1};\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n  cleanup_free char *seccomp_data = NULL;\n  size_t seccomp_len;\n  struct sock_fprog seccomp_prog;\n  cleanup_free char *args_data = NULL;\n\n  /* Handle --version early on before we try to acquire/drop\n   * any capabilities so it works in a build environment;\n   * right now flatpak's build runs bubblewrap --version.\n   * https://github.com/projectatomic/bubblewrap/issues/185\n   */\n  if (argc == 2 && (strcmp (argv[1], \""--version\"") == 0))\n    print_version_and_exit ();\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\""prctl(PR_SET_NO_NEW_CAPS) failed\"");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, (const char ***) &argv);\n\n  /* suck the args into a cleanup_free variable to control their lifecycle */\n  args_data = opt_args_data;\n  opt_args_data = NULL;\n\n  if ((requested_caps[0] || requested_caps[1]) && is_privileged)\n    die (\""--cap-add in setuid mode can be used only by root\"");\n\n  if (opt_userns_block_fd != -1 && !opt_unshare_user)\n    die (\""--userns-block-fd requires --unshare-user\"");\n\n  if (opt_userns_block_fd != -1 && opt_info_fd == -1)\n    die (\""--userns-block-fd requires --info-fd\"");\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n#ifdef ENABLE_REQUIRE_USERNS\n  /* In this build option, we require userns. */\n  if (is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n#endif\n\n  if (opt_unshare_user_try &&\n      stat (\""/proc/self/ns/user\"", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\""/sys/module/user_namespace/parameters/enable\"", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \""/sys/module/user_namespace/parameters/enable\"");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Check for max_user_namespaces */\n      if (stat (\""/proc/sys/user/max_user_namespaces\"", &sbuf) == 0)\n        {\n          cleanup_free char *max_user_ns = NULL;\n          max_user_ns = load_file_at (AT_FDCWD, \""/proc/sys/user/max_user_namespaces\"");\n          if (max_user_ns != NULL && strcmp(max_user_ns, \""0\\n\"") == 0)\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\""Creating root mount point\\n\""));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\""Specifying --uid requires --unshare-user\"");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\""Specifying --gid requires --unshare-user\"");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\""Specifying --hostname requires --unshare-uts\"");\n\n  if (opt_as_pid_1 && !opt_unshare_pid)\n    die (\""Specifying --as-pid-1 requires --unshare-pid\"");\n\n  if (opt_as_pid_1 && lock_files != NULL)\n    die (\""Specifying --as-pid-1 and --lock-file is not permitted\"");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\""/proc\"", O_PATH);\n  if (proc_fd == -1)\n    die_with_error (\""Can't open /proc\"");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n   * Because we use pivot_root, it won't appear to be mounted from\n   * the perspective of the sandboxed process, so we can use anywhere\n   * that is sure to exist, that is sure to not be a symlink controlled\n   * by someone malicious, and that we won't immediately need to\n   * access ourselves. */\n  base_path = \""/tmp\"";\n\n  __debug__ ((\""creating new namespace\\n\""));\n\n  if (opt_unshare_pid && !opt_as_pid_1)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\""eventfd()\"");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\""/proc/self/ns/cgroup\"", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\""Cannot create new cgroup namespace because the kernel does not support it\"");\n          else\n            die_with_error (\""stat on /proc/self/ns/cgroup failed\"");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\""/proc/self/ns/cgroup\"", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\""eventfd()\"");\n\n  /* Track whether pre-exec setup finished if we're reporting process exit */\n  if (opt_json_status_fd != -1)\n    {\n      int ret;\n      ret = pipe2 (setup_finished_pipe, O_CLOEXEC);\n      if (ret == -1)\n        die_with_error (\""pipe2()\"");\n    }\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\""Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\"");\n          else if (errno == EPERM && !is_privileged)\n            die (\""No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\"");\n        }\n\n      die_with_error (\""Creating new namespace failed\"");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs (FALSE);\n\n      /* Optionally bind our lifecycle to that of the parent */\n      handle_die_with_parent ();\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\""{\\n    \\\""child-pid\\\"": %i\\n}\\n\"", pid);\n          dump_info (opt_info_fd, output, TRUE);\n          close (opt_info_fd);\n        }\n      if (opt_json_status_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\""{ \\\""child-pid\\\"": %i }\\n\"", pid);\n          dump_info (opt_json_status_fd, output, TRUE);\n        }\n\n      if (opt_userns_block_fd != -1)\n        {\n          char b[1];\n          (void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));\n          close (opt_userns_block_fd);\n        }\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      return monitor_child (event_fd, pid, setup_finished_pipe[0]);\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  if (opt_json_status_fd != -1)\n    close (opt_json_status_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net)\n    loopback_setup (); /* Will exit if unsuccessful */\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \""/\"", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\""Failed to make / slave\"");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\""tmpfs\"", base_path, \""tmpfs\"", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\""Failed to mount tmpfs\"");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \""oldroot\"" and \""newroot\"". */\n  if (chdir (base_path) != 0)\n    die_with_error (\""chdir base_path\"");\n\n  /* We create a subdir \""$base_path/newroot\"" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \""$base_path/oldroot\"". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / (or\n   * over /tmp, now that we use that for base_path). */\n\n  if (mkdir (\""newroot\"", 0755))\n    die_with_error (\""Creating newroot failed\"");\n\n  if (mount (\""newroot\"", \""newroot\"", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)\n    die_with_error (\""setting up newroot bind\"");\n\n  if (mkdir (\""oldroot\"", 0755))\n    die_with_error (\""Creating oldroot failed\"");\n\n  if (pivot_root (base_path, \""oldroot\""))\n    die_with_error (\""pivot_root\"");\n\n  if (chdir (\""/\"") != 0)\n    die_with_error (\""chdir / (base path)\"");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\""Can't create privsep socket\"");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\""Can't fork unprivileged helper\"");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs (FALSE);\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\""Can't write to op_socket\"");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  close_ops_fd ();\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\""oldroot\"", \""oldroot\"", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\""Failed to make old root rprivate\"");\n\n  if (umount2 (\""oldroot\"", MNT_DETACH))\n    die_with_error (\""unmount old root\"");\n\n  /* This is our second pivot. It's like we're a Silicon Valley startup flush\n   * with cash but short on ideas!\n   *\n   * We're aiming to make /newroot the real root, and get rid of /oldroot. To do\n   * that we need a temporary place to store it before we can unmount it.\n   */\n  { cleanup_fd int oldrootfd = open (\""/\"", O_DIRECTORY | O_RDONLY);\n    if (oldrootfd < 0)\n      die_with_error (\""can't open /\"");\n    if (chdir (\""/newroot\"") != 0)\n      die_with_error (\""chdir /newroot\"");\n    /* While the documentation claims that put_old must be underneath\n     * new_root, it is perfectly fine to use the same directory as the\n     * kernel checks only if old_root is accessible from new_root.\n     *\n     * Both runc and LXC are using this \""alternative\"" method for\n     * setting up the root of the container:\n     *\n     * https://github.com/opencontainers/runc/blob/master/libcontainer/rootfs_linux.go#L671\n     * https://github.com/lxc/lxc/blob/master/src/lxc/conf.c#L1121\n     */\n    if (pivot_root (\"".\"", \"".\"") != 0)\n      die_with_error (\""pivot_root(/newroot)\"");\n    if (fchdir (oldrootfd) < 0)\n      die_with_error (\""fchdir to oldroot\"");\n    if (umount2 (\"".\"", MNT_DETACH) < 0)\n      die_with_error (\""umount old root\"");\n    if (chdir (\""/\"") != 0)\n      die_with_error (\""chdir /\"");\n  }\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&\n      opt_userns_block_fd == -1)\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\""unshare user ns\"");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* All privileged ops are done now, so drop caps we don't need */\n  drop_privs (!is_privileged);\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      (void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\""Can't read seccomp data\"");\n\n      if (seccomp_len % 8 != 0)\n        die (\""Invalid seccomp data, must be multiple of 8\"");\n\n      seccomp_prog.len = seccomp_len / 8;\n      seccomp_prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n    }\n\n  umask (old_umask);\n\n  new_cwd = \""/\"";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\""Can't chdir to %s\"", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\""HOME\"");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\""PWD\"", new_cwd, 1);\n  free (old_cwd);\n\n  if (opt_new_session &&\n      setsid () == (pid_t) -1)\n    die_with_error (\""setsid\"");\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\""label_exec %s\"", argv[0]);\n\n  __debug__ ((\""forking for child\\n\""));\n\n  if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\""Can't fork for pid 1\"");\n\n      if (pid != 0)\n        {\n          drop_all_caps (FALSE);\n\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);\n        }\n    }\n\n  __debug__ ((\""launch executable %s\\n\"", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  /* If we are using --as-pid-1 leak the sync fd into the sandbox.\n     --sync-fd will still work unless the container process doesn't close this file.  */\n  if (!opt_as_pid_1)\n    {\n      if (opt_sync_fd != -1)\n        close (opt_sync_fd);\n    }\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  /* Optionally bind our lifecycle */\n  handle_die_with_parent ();\n\n  if (!is_privileged)\n    set_ambient_capabilities ();\n\n  /* Should be the last thing before execve() so that filters don't\n   * need to handle anything above */\n  if (seccomp_data != NULL &&\n      prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)\n    die_with_error (\""prctl(PR_SET_SECCOMP)\"");\n\n  if (setup_finished_pipe[1] != -1)\n    {\n      char data = 0;\n      res = write_to_fd (setup_finished_pipe[1], &data, 1);\n      /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n         we don't want to error out here */\n    }\n\n  if (execvp (argv[0], argv) == -1)\n    {\n      if (setup_finished_pipe[1] != -1)\n        {\n          int saved_errno = errno;\n          char data = 0;\n          res = write_to_fd (setup_finished_pipe[1], &data, 1);\n          errno = saved_errno;\n          /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n             we don't want to error out here */\n        }\n      die_with_error (\""execvp %s\"", argv[0]);\n    }\n\n  return 0;\n}""}]","{""function"": 1, ""value"": 1, ""code"": 1}","[{""source"": ""func_info(func:ensure_dir)"", ""result"": [{""code"": ""int\nensure_dir (const char *path,\n            mode_t      mode)\n{\n  struct stat buf;\n\n  /* We check this ahead of time, otherwise\n     the mkdir call can fail in the read-only\n     case with EROFS ins"", ""start_line"": 596, ""end_line"": 621, ""full_name"": ""ensure_dir"", ""file_path"": ""utils.c""}]}, {""source"": ""value_info(file:bubblewrap.c, value:real_uid)"", ""result"": {""value_trace"": [{""full_code"": ""real_uid = getuid ()"", ""line"": 2075, ""func_name"": ""main""}], ""struct_var"": ""real_uid"", ""struct_type"": ""uid_t"", ""struct_definition"": ""uid_t""}}, {""source"": ""code_info(file:bubblewrap.c, lines:2401-2415)"", ""result"": ""   * way we can pivot_root to base_path, and put the old root at\n   * \""$base_path/oldroot\"". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / */\n\n  if (mkdir (\""newroot\"", 0755))\n    die_with_error (\""Creating newroot failed\"");\n\n  if (mount (\""newroot\"", \""newroot\"", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)\n    die_with_error (\""setting up newroot bind\"");\n\n  if (mkdir (\""oldroot\"", 0755))\n    die_with_error (\""Creating oldroot failed\"");\n\n  if (pivot_root (base_path, \""oldroot\""))\n    die_with_error (\""pivot_root\"");\n\n""}]","Original code created a predictable path in /tmp (e.g., /tmp/.bubblewrap-<UID>) using ensure_dir (bubblewrap.c:2047-2188). An attacker could pre-create this path as a non-directory or symlink, causing mount failures (DoS) or exploitation if protected_symlinks was disabled. The patch replaces this with direct use of /tmp as base_path (bubblewrap.c:2188-2398), leveraging system-managed /tmp to avoid attacker-controlled paths. The pivot_root logic (bubblewrap.c:2401-2415) now operates under /tmp, assuming its integrity is enforced by system configuration (e.g., protected_symlinks). The ensure_dir function (utils.c:596-621) confirms it would fail if the target path was non-directory or symlink. real_uid is derived from getuid() (bubblewrap.c:2075), ensuring it reflects the real user ID.",0.95,./github/other_context/CVE-2019-12439
86,CVE-2019-17346,CWE-20,c_cpp,An issue was discovered in Xen through 4.11.x allowing x86 PV guest OS users to cause a denial of service or gain privileges because of an incompatibility between Process Context Identifiers (PCID) and TLB flushes.,https://github.com/xen-project/xen/commit/6e5f22ba437d78c0a84b9673f7e2cfefdbc62f4b,"x86/mm: properly flush TLB in switch_cr3_cr4()\n\nThe CR3 values used for contexts run with PCID enabled uniformly have\nCR3.NOFLUSH set, resulting in the CR3 write itself to not cause any\nflushing at all. When the second CR4 write is skipped or doesn't do any\nflushing, there's nothing so far which would purge TLB entries which may\nhave accumulated again if the PCID doesn't change; the ""just in case""\nflush only affects the case where the PCID actually changes. (There may\nbe particularly many TLB entries re-accumulated in case of a watchdog\nNMI kicking in during the critical time window.)\n\nSuppress the no-flush behavior of the CR3 write in this particular case.\n\nSimilarly the second CR4 write may not cause any flushing of TLB entries\nestablished again while the original PCID was still in use - it may get\nperformed because of unrelated bits changing. The flush of the old PCID\nneeds to happen nevertheless.\n\nAt the same time also eliminate a possible race with lazy context\nswitch: Just like for CR4, CR3 may change at any time while interrupts\nare enabled, due to the __sync_local_execstate() invocation from the\nflush IPI handler. It is for that reason that the CR3 read, just like\nthe CR4 one, must happen only after interrupts have been turned off.\n\nThis is XSA-292.\n\nReported-by: Sergey Dyasli <sergey.dyasli@citrix.com>\nReported-by: Andrew Cooper <andrew.cooper3@citrix.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>\nTested-by: Sergey Dyasli <sergey.dyasli@citrix.com>",1,"[{""func_name"": ""switch_cr3_cr4"", ""file_path"": ""xen/arch/x86/flushtlb.c"", ""func_code"": ""void switch_cr3_cr4(unsigned long cr3, unsigned long cr4)\n{\n    unsigned long flags, old_cr4;\n    u32 t;\n    unsigned long old_pcid = cr3_pcid(read_cr3());\n\n    /* This non-reentrant function is sometimes called in interrupt context. */\n    local_irq_save(flags);\n\n    t = pre_flush();\n\n    old_cr4 = read_cr4();\n    if ( old_cr4 & X86_CR4_PGE )\n    {\n        /*\n         * X86_CR4_PGE set means PCID is inactive.\n         * We have to purge the TLB via flipping cr4.pge.\n         */\n        old_cr4 = cr4 & ~X86_CR4_PGE;\n        write_cr4(old_cr4);\n    }\n    else if ( use_invpcid )\n        /*\n         * Flushing the TLB via INVPCID is necessary only in case PCIDs are\n         * in use, which is true only with INVPCID being available.\n         * Without PCID usage the following write_cr3() will purge the TLB\n         * (we are in the cr4.pge off path) of all entries.\n         * Using invpcid_flush_all_nonglobals() seems to be faster than\n         * invpcid_flush_all(), so use that.\n         */\n        invpcid_flush_all_nonglobals();\n\n    write_cr3(cr3);\n\n    if ( old_cr4 != cr4 )\n        write_cr4(cr4);\n    else if ( old_pcid != cr3_pcid(cr3) )\n        /*\n         * Make sure no TLB entries related to the old PCID created between\n         * flushing the TLB and writing the new %cr3 value remain in the TLB.\n         */\n        invpcid_flush_single_context(old_pcid);\n\n    post_flush(t);\n\n    local_irq_restore(flags);\n}"", ""target"": 0}]","[{""func_name"": ""switch_cr3_cr4"", ""file_path"": ""xen/arch/x86/flushtlb.c"", ""func_code"": ""void switch_cr3_cr4(unsigned long cr3, unsigned long cr4)\n{\n    unsigned long flags, old_cr4, old_pcid;\n    u32 t;\n\n    /* This non-reentrant function is sometimes called in interrupt context. */\n    local_irq_save(flags);\n\n    t = pre_flush();\n\n    old_cr4 = read_cr4();\n    if ( old_cr4 & X86_CR4_PGE )\n    {\n        /*\n         * X86_CR4_PGE set means PCID is inactive.\n         * We have to purge the TLB via flipping cr4.pge.\n         */\n        old_cr4 = cr4 & ~X86_CR4_PGE;\n        write_cr4(old_cr4);\n    }\n    else if ( use_invpcid )\n        /*\n         * Flushing the TLB via INVPCID is necessary only in case PCIDs are\n         * in use, which is true only with INVPCID being available.\n         * Without PCID usage the following write_cr3() will purge the TLB\n         * (we are in the cr4.pge off path) of all entries.\n         * Using invpcid_flush_all_nonglobals() seems to be faster than\n         * invpcid_flush_all(), so use that.\n         */\n        invpcid_flush_all_nonglobals();\n\n    /*\n     * If we don't change PCIDs, the CR3 write below needs to flush this very\n     * PCID, even when a full flush was performed above, as we are currently\n     * accumulating TLB entries again from the old address space.\n     * NB: Clearing the bit when we don't use PCID is benign (as it is clear\n     * already in that case), but allows the if() to be more simple.\n     */\n    old_pcid = cr3_pcid(read_cr3());\n    if ( old_pcid == cr3_pcid(cr3) )\n        cr3 &= ~X86_CR3_NOFLUSH;\n\n    write_cr3(cr3);\n\n    if ( old_cr4 != cr4 )\n        write_cr4(cr4);\n\n    /*\n     * Make sure no TLB entries related to the old PCID created between\n     * flushing the TLB and writing the new %cr3 value remain in the TLB.\n     *\n     * The write to CR4 just above has performed a wider flush in certain\n     * cases, which therefore get excluded here. Since that write is\n     * conditional, note in particular that it won't be skipped if PCIDE\n     * transitions from 1 to 0. This is because the CR4 write further up will\n     * have been skipped in this case, as PCIDE and PGE won't both be set at\n     * the same time.\n     *\n     * Note also that PGE is always clear in old_cr4.\n     */\n    if ( old_pcid != cr3_pcid(cr3) &&\n         !(cr4 & X86_CR4_PGE) &&\n         (old_cr4 & X86_CR4_PCIDE) <= (cr4 & X86_CR4_PCIDE) )\n        invpcid_flush_single_context(old_pcid);\n\n    post_flush(t);\n\n    local_irq_restore(flags);\n}""}]","{""function"": 1, ""code"": 1, ""value"": 3}","[{""source"": ""func_info(func:cr3_pcid)"", ""result"": [{""code"": ""static inline unsigned long cr3_pcid(unsigned long cr3)\n{\n    return cr3 & X86_CR3_PCID_MASK;\n}"", ""start_line"": 295, ""end_line"": 298, ""full_name"": ""cr3_pcid"", ""file_path"": ""xen/include/asm-x86/processor.h""}]}, {""source"": ""code_info(file:flushtlb.c, lines:105-133)"", ""result"": ""{\n    unsigned long flags, old_cr4;\n    u32 t;\n    unsigned long old_pcid = cr3_pcid(read_cr3());\n\n    /* This non-reentrant function is sometimes called in interrupt context. */\n    local_irq_save(flags);\n\n    t = pre_flush();\n\n    old_cr4 = read_cr4();\n    if ( old_cr4 & X86_CR4_PGE )\n    {\n        /*\n         * X86_CR4_PGE set means PCID is inactive.\n         * We have to purge the TLB via flipping cr4.pge.\n         */\n        old_cr4 = cr4 & ~X86_CR4_PGE;\n        write_cr4(old_cr4);\n    }\n    else if ( use_invpcid )\n        /*\n         * Flushing the TLB via INVPCID is necessary only in case PCIDs are\n         * in use, which is true only with INVPCID being available.\n         * Without PCID usage the following write_cr3() will purge the TLB\n         * (we are in the cr4.pge off path) of all entries.\n         * Using invpcid_flush_all_nonglobals() seems to be faster than\n         * invpcid_flush_all(), so use that.\n         */\n""}, {""source"": ""value_info(file:processor.h, value:X86_CR3_NOFLUSH)"", ""result"": {""value_trace"": [{""full_code"": ""X86_CR3_NOFLUSH"", ""line"": 2300, ""func_name"": null}, {""full_code"": ""X86_CR3_NOFLUSH"", ""line"": 40, ""func_name"": null}, {""full_code"": ""X86_CR3_NOFLUSH"", ""line"": 53, ""func_name"": null}], ""struct_var"": ""X86_CR3_NOFLUSH"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:processor.h, value:X86_CR4_PGE)"", ""result"": {""value_trace"": [{""full_code"": ""X86_CR4_PGE"", ""line"": 308, ""func_name"": null}], ""struct_var"": ""X86_CR4_PGE"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:processor.h, value:X86_CR4_PCIDE)"", ""result"": {""value_trace"": [{""full_code"": ""X86_CR4_PCIDE"", ""line"": 308, ""func_name"": null}], ""struct_var"": ""X86_CR4_PCIDE"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}]","Original code in xen/arch/x86/flushtlb.c:133-134 read old_pcid before handling CR3/CR4 transitions. When PCID didn't change, the CR3 write retained NOFLUSH (xen/include/asm-x86/processor.h:X86_CR3_NOFLUSH), preventing TLB flush. This allowed stale entries from old address space to persist. The patch (xen/arch/x86/flushtlb.c:138-141) clears NOFLUSH if PCID is unchanged, forcing flush via CR3 write. The cr3_pcid() function (xen/include/asm-x86/processor.h:295-298) extracts PCID from CR3 using X86_CR3_PCID_MASK. The vulnerability occurs because prior code only flushed when PCID changed, missing the case where TLB entries reaccumulate under same PCID between CR4 writes.",0.95,./github/other_context/CVE-2019-17346
87,CVE-2019-19579,CWE-20,c_cpp,"An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device (and assignable-add is not used), because of an incomplete fix for CVE-2019-18424. XSA-302 relies on the use of libxl's ""assignable-add"" feature to prepare devices to be assigned to untrusted guests. Unfortunately, this is not considered a strictly required step for device assignment. The PCI passthrough documentation on the wiki describes alternate ways of preparing devices for assignment, and libvirt uses its own ways as well. Hosts where these ""alternate"" methods are used will still leave the system in a vulnerable state after the device comes back from a guest. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",https://github.com/xen-project/xen/commit/ba2ab00bbb8c74e311a252d816d68dee47c779a0,"IOMMU: default to always quarantining PCI devices\n\nXSA-302 relies on the use of libxl's ""assignable-add"" feature to prepare\ndevices to be assigned to untrusted guests.\n\nUnfortunately, this is not considered a strictly required step for\ndevice assignment. The PCI passthrough documentation on the wiki\ndescribes alternate ways of preparing devices for assignment, and\nlibvirt uses its own ways as well. Hosts where these alternate methods\nare used will still leave the system in a vulnerable state after the\ndevice comes back from a guest.\n\nDefault to always quarantining PCI devices, but provide a command line\noption to revert back to prior behavior (such that people who both\nsufficiently trust their guests and want to be able to use devices in\nDom0 again after they had been in use by a guest wouldn't need to\n""manually"" move such devices back from DomIO to Dom0).\n\nThis is XSA-306.\n\nReported-by: Marek Marczykowski-Górecki <marmarek@invisiblethingslab.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: Wei Liu <wl@xen.org>",2,"[{""func_name"": ""parse_iommu_param"", ""file_path"": ""xen/drivers/passthrough/iommu.c"", ""func_code"": ""static int __init parse_iommu_param(const char *s)\n{\n    const char *ss;\n    int val, rc = 0;\n\n    do {\n        ss = strchr(s, ',');\n        if ( !ss )\n            ss = strchr(s, '\\0');\n\n        if ( (val = parse_bool(s, ss)) >= 0 )\n            iommu_enable = val;\n        else if ( (val = parse_boolean(\""force\"", s, ss)) >= 0 ||\n                  (val = parse_boolean(\""required\"", s, ss)) >= 0 )\n            force_iommu = val;\n        else if ( (val = parse_boolean(\""igfx\"", s, ss)) >= 0 )\n            iommu_igfx = val;\n        else if ( (val = parse_boolean(\""verbose\"", s, ss)) >= 0 )\n            iommu_verbose = val;\n        else if ( (val = parse_boolean(\""snoop\"", s, ss)) >= 0 )\n            iommu_snoop = val;\n        else if ( (val = parse_boolean(\""qinval\"", s, ss)) >= 0 )\n            iommu_qinval = val;\n        else if ( (val = parse_boolean(\""intremap\"", s, ss)) >= 0 )\n            iommu_intremap = val;\n        else if ( (val = parse_boolean(\""intpost\"", s, ss)) >= 0 )\n            iommu_intpost = val;\n#ifdef CONFIG_KEXEC\n        else if ( (val = parse_boolean(\""crash-disable\"", s, ss)) >= 0 )\n            iommu_crash_disable = val;\n#endif\n        else if ( (val = parse_boolean(\""debug\"", s, ss)) >= 0 )\n        {\n            iommu_debug = val;\n            if ( val )\n                iommu_verbose = 1;\n        }\n        else if ( (val = parse_boolean(\""amd-iommu-perdev-intremap\"", s, ss)) >= 0 )\n            amd_iommu_perdev_intremap = val;\n        else if ( (val = parse_boolean(\""dom0-passthrough\"", s, ss)) >= 0 )\n            iommu_hwdom_passthrough = val;\n        else if ( (val = parse_boolean(\""dom0-strict\"", s, ss)) >= 0 )\n            iommu_hwdom_strict = val;\n#ifndef iommu_hap_pt_share\n        else if ( (val = parse_boolean(\""sharept\"", s, ss)) >= 0 )\n            iommu_hap_pt_share = val;\n#endif\n        else\n            rc = -EINVAL;\n\n        s = ss + 1;\n    } while ( *ss );\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""deassign_device"", ""file_path"": ""xen/drivers/passthrough/pci.c"", ""func_code"": ""static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus,\n                           uint8_t devfn)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    struct domain *target;\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return -EINVAL;\n\n    ASSERT(pcidevs_locked());\n    pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);\n    if ( !pdev )\n        return -ENODEV;\n\n    /* De-assignment from dom_io should de-quarantine the device */\n    target = (pdev->quarantine && pdev->domain != dom_io) ?\n        dom_io : hardware_domain;\n\n    while ( pdev->phantom_stride )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                                pci_to_dev(pdev));\n        if ( !ret )\n            continue;\n\n        printk(XENLOG_G_ERR \""%pd: deassign %04x:%02x:%02x.%u failed (%d)\\n\"",\n               d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret);\n        return ret;\n    }\n\n    devfn = pdev->devfn;\n    ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                            pci_to_dev(pdev));\n    if ( ret )\n    {\n        dprintk(XENLOG_G_ERR,\n                \""%pd: deassign device (%04x:%02x:%02x.%u) failed\\n\"",\n                d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n        return ret;\n    }\n\n    if ( pdev->domain == hardware_domain  )\n        pdev->quarantine = false;\n\n    pdev->fault.count = 0;\n\n    return ret;\n}"", ""target"": 0}]","[{""func_name"": ""parse_iommu_param"", ""file_path"": ""xen/drivers/passthrough/iommu.c"", ""func_code"": ""static int __init parse_iommu_param(const char *s)\n{\n    const char *ss;\n    int val, rc = 0;\n\n    do {\n        ss = strchr(s, ',');\n        if ( !ss )\n            ss = strchr(s, '\\0');\n\n        if ( (val = parse_bool(s, ss)) >= 0 )\n            iommu_enable = val;\n        else if ( (val = parse_boolean(\""force\"", s, ss)) >= 0 ||\n                  (val = parse_boolean(\""required\"", s, ss)) >= 0 )\n            force_iommu = val;\n        else if ( (val = parse_boolean(\""quarantine\"", s, ss)) >= 0 )\n            iommu_quarantine = val;\n        else if ( (val = parse_boolean(\""igfx\"", s, ss)) >= 0 )\n            iommu_igfx = val;\n        else if ( (val = parse_boolean(\""verbose\"", s, ss)) >= 0 )\n            iommu_verbose = val;\n        else if ( (val = parse_boolean(\""snoop\"", s, ss)) >= 0 )\n            iommu_snoop = val;\n        else if ( (val = parse_boolean(\""qinval\"", s, ss)) >= 0 )\n            iommu_qinval = val;\n        else if ( (val = parse_boolean(\""intremap\"", s, ss)) >= 0 )\n            iommu_intremap = val;\n        else if ( (val = parse_boolean(\""intpost\"", s, ss)) >= 0 )\n            iommu_intpost = val;\n#ifdef CONFIG_KEXEC\n        else if ( (val = parse_boolean(\""crash-disable\"", s, ss)) >= 0 )\n            iommu_crash_disable = val;\n#endif\n        else if ( (val = parse_boolean(\""debug\"", s, ss)) >= 0 )\n        {\n            iommu_debug = val;\n            if ( val )\n                iommu_verbose = 1;\n        }\n        else if ( (val = parse_boolean(\""amd-iommu-perdev-intremap\"", s, ss)) >= 0 )\n            amd_iommu_perdev_intremap = val;\n        else if ( (val = parse_boolean(\""dom0-passthrough\"", s, ss)) >= 0 )\n            iommu_hwdom_passthrough = val;\n        else if ( (val = parse_boolean(\""dom0-strict\"", s, ss)) >= 0 )\n            iommu_hwdom_strict = val;\n#ifndef iommu_hap_pt_share\n        else if ( (val = parse_boolean(\""sharept\"", s, ss)) >= 0 )\n            iommu_hap_pt_share = val;\n#endif\n        else\n            rc = -EINVAL;\n\n        s = ss + 1;\n    } while ( *ss );\n\n    return rc;\n}""}, {""func_name"": ""deassign_device"", ""file_path"": ""xen/drivers/passthrough/pci.c"", ""func_code"": ""static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus,\n                           uint8_t devfn)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    struct domain *target;\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return -EINVAL;\n\n    ASSERT(pcidevs_locked());\n    pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);\n    if ( !pdev )\n        return -ENODEV;\n\n    /* De-assignment from dom_io should de-quarantine the device */\n    target = ((pdev->quarantine || iommu_quarantine) &&\n              pdev->domain != dom_io) ?\n        dom_io : hardware_domain;\n\n    while ( pdev->phantom_stride )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                                pci_to_dev(pdev));\n        if ( !ret )\n            continue;\n\n        printk(XENLOG_G_ERR \""%pd: deassign %04x:%02x:%02x.%u failed (%d)\\n\"",\n               d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret);\n        return ret;\n    }\n\n    devfn = pdev->devfn;\n    ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                            pci_to_dev(pdev));\n    if ( ret )\n    {\n        dprintk(XENLOG_G_ERR,\n                \""%pd: deassign device (%04x:%02x:%02x.%u) failed\\n\"",\n                d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n        return ret;\n    }\n\n    if ( pdev->domain == hardware_domain  )\n        pdev->quarantine = false;\n\n    pdev->fault.count = 0;\n\n    return ret;\n}""}]","{""caller"": 1, ""code"": 2, ""function"": 2, ""value"": 1}","[{""source"": ""caller_info(file:pci.c, func:deassign_device)"", ""result"": [{""call_line"": 979, ""call_code"": ""deassign_device(d, pdev->seg, bus, devfn)"", ""caller_code"": ""int pci_release_devices(struct domain *d)\n{\n    struct pci_dev *pdev;\n    u8 bus, devfn;\n    int ret;\n\n    pcidevs_lock();\n    ret = pci_clean_dpci_irqs(d);\n    if ( ret )\n    {\n        pcidevs_unlock();\n        return ret;\n    }\n    while ( (pdev = pci_get_pdev_by_domain(d, -1, -1, -1)) )\n    {\n        bus = pdev->bus;\n        devfn = pdev->devfn;\n        if ( deassign_device(d, pdev->seg, bus, devfn) )\n            printk(\""domain %d: deassign device (%04x:%02x:%02x.%u) failed!\\n\"",\n                   d->domain_id, pdev->seg, bus,\n                   PCI_SLOT(devfn), PCI_FUNC(devfn));\n    }\n    pcidevs_unlock();\n\n    return 0;\n}"", ""caller_start"": 962, ""file_path"": ""xen/drivers/passthrough/pci.c""}]}, {""source"": ""code_info(file:pci.c, lines:100-150)"", ""result"": ""    INIT_LIST_HEAD(&pseg->alldevs_list);\n    spin_lock_init(&pseg->bus2bridge_lock);\n\n    if ( radix_tree_insert(&pci_segments, seg, pseg) )\n    {\n        xfree(pseg);\n        pseg = NULL;\n    }\n\n    return pseg;\n}\n\nstatic int pci_segments_iterate(\n    int (*handler)(struct pci_seg *, void *), void *arg)\n{\n    u16 seg = 0;\n    int rc = 0;\n\n    do {\n        struct pci_seg *pseg;\n\n        if ( !radix_tree_gang_lookup(&pci_segments, (void **)&pseg, seg, 1) )\n            break;\n        rc = handler(pseg, arg);\n        seg = pseg->nr + 1;\n    } while (!rc && seg);\n\n    return rc;\n}\n\nvoid __init pci_segments_init(void)\n{\n    radix_tree_init(&pci_segments);\n    if ( !alloc_pseg(0) )\n        panic(\""Could not initialize PCI segment 0\\n\"");\n}\n\nint __init pci_add_segment(u16 seg)\n{\n    return alloc_pseg(seg) ? 0 : -ENOMEM;\n}\n\nconst unsigned long *pci_get_ro_map(u16 seg)\n{\n    struct pci_seg *pseg = get_pseg(seg);\n\n    return pseg ? pseg->ro_map : NULL;\n}\n\nstatic struct phantom_dev {\n    u16 seg;\n""}, {""source"": ""func_info(file:pci.c, lines:200-300)"", ""result"": [{""code"": ""static void check_pdev(const struct pci_dev *pdev)\n{\n#define PCI_STATUS_CHECK \\\n    (PCI_STATUS_PARITY | PCI_STATUS_SIG_TARGET_ABORT | \\\n     PCI_STATUS_REC_TARGET_ABORT | PCI_STATUS_REC_MASTER_ABORT | \\\n     PCI_STATUS_SIG_SYSTEM_ERROR | PCI_STATUS_DETECTED_PARITY)\n    u16 seg = pdev->seg;\n    u8 bus = pdev->bus;\n    u8 dev = PCI_SLOT(pdev->devfn);\n    u8 func = PCI_FUNC(pdev->devfn);\n    u16 val;\n\n    if ( command_mask )\n    {\n        val = pci_conf_read16(pdev->sbdf, PCI_COMMAND);\n        if ( val & command_mask )\n            pci_conf_write16(pdev->sbdf, PCI_COMMAND, val & ~command_mask);\n        val = pci_conf_read16(pdev->sbdf, PCI_STATUS);\n        if ( val & PCI_STATUS_CHECK )\n        {\n            printk(XENLOG_INFO \""%04x:%02x:%02x.%u status %04x -> %04x\\n\"",\n                   seg, bus, dev, func, val, val & ~PCI_STATUS_CHECK);\n            pci_conf_write16(pdev->sbdf, PCI_STATUS, val & PCI_STATUS_CHECK);\n        }\n    }\n\n    switch ( pci_conf_read8(pdev->sbdf, PCI_HEADER_TYPE) & 0x7f )\n    {\n    case PCI_HEADER_TYPE_BRIDGE:\n        if ( !bridge_ctl_mask )\n            break;\n        val = pci_conf_read16(pdev->sbdf, PCI_BRIDGE_CONTROL);\n        if ( val & bridge_ctl_mask )\n            pci_conf_write16(pdev->sbdf, PCI_BRIDGE_CONTROL,\n                             val & ~bridge_ctl_mask);\n        val = pci_conf_read16(pdev->sbdf, PCI_SEC_STATUS);\n        if ( val & PCI_STATUS_CHECK )\n        {\n            printk(XENLOG_INFO\n                   \""%04x:%02x:%02x.%u secondary status %04x -> %04x\\n\"",\n                   seg, bus, dev, func, val, val & ~PCI_STATUS_CHECK);\n            pci_conf_write16(pdev->sbdf, PCI_SEC_STATUS,\n                             val & PCI_STATUS_CHECK);\n        }\n        break;\n\n    case PCI_HEADER_TYPE_CARDBUS:\n        /* TODO */\n        break;\n    }\n#undef PCI_STATUS_CHECK\n}\n"", ""start_line"": 235, ""end_line"": 286, ""full_name"": ""check_pdev"", ""file_path"": ""xen/drivers/passthrough/pci.c""}]}, {""source"": ""value_info(file:pci.c, value:pdev->quarantine)"", ""result"": {""value_trace"": [{""full_code"": ""pdev->quarantine = false"", ""line"": 955, ""func_name"": ""deassign_device""}, {""full_code"": ""pdev->quarantine = true"", ""line"": 1561, ""func_name"": ""assign_device""}], ""struct_var"": ""pdev"", ""struct_type"": ""pci_dev*"", ""struct_definition"": ""struct pci_dev {\n    uint8_t bus;\n    uint8_t devfn;\n    int vector_used[MAX_VECTOR];\n    struct pci_dev *next;\n}\n\nstruct pci_dev\n\nstruct pci_dev\n\nstruct pci_dev\n\nstruct pci_dev\n\nextern struct pci_dev\n\ntypedef struct pci_dev\n\nstruct pci_dev\n\nstruct pci_dev {\n    struct list_head alldevs_list;\n    struct list_head domain_list;\n\n    struct list_head msi_list;\n\n    struct arch_msix *msix;\n\n    struct domain *domain;\n\n    const union {\n        struct {\n            uint8_t devfn;\n            uint8_t bus;\n            uint16_t seg;\n        };\n        pci_sbdf_t sbdf;\n    };\n\n    uint8_t msi_maxvec;\n    uint8_t phantom_stride;\n\n    nodeid_t node; /* NUMA node */\n\n    /* Device to be quarantined, don't automatically re-assign to dom0 */\n    bool quarantine;\n\n    /* Device with errata, ignore the BARs. */\n    bool ignore_bars;\n\n    enum pdev_type {\n        DEV_TYPE_PCI_UNKNOWN,\n        DEV_TYPE_PCIe_ENDPOINT,\n        DEV_TYPE_PCIe_BRIDGE,       // PCIe root port, switch\n        DEV_TYPE_PCIe2PCI_BRIDGE,   // PCIe-to-PCI/PCIx bridge\n        DEV_TYPE_PCI2PCIe_BRIDGE,   // PCI/PCIx-to-PCIe bridge\n        DEV_TYPE_LEGACY_PCI_BRIDGE, // Legacy PCI bridge\n        DEV_TYPE_PCI_HOST_BRIDGE,   // PCI Host bridge\n        DEV_TYPE_PCI,\n    ...\n\nstruct pci_dev\n\nstruct pci_dev\n\nstruct pci_dev\n\nstruct pci_dev\n\nstruct pci_dev\n\nstruct pci_dev\n\nstruct pci_dev""}}, {""source"": ""func_info(file:pci.c, func:assign_device)"", ""result"": [{""code"": ""static int assign_device(struct domain *d, u16 seg, u8 bus, u8 devfn, u32 flag)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    int rc = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n    /* Prevent device assign if mem paging or mem sharing have been \n     * enabled for this domain */\n    if ( d != dom_io &&\n         unlikely((is_hvm_domain(d) &&\n                   d->arch.hvm.mem_sharing_enabled) ||\n                  vm_event_check_ring(d->vm_event_paging) ||\n                  p2m_get_hostp2m(d)->global_logdirty) )\n        return -EXDEV;\n\n    if ( !pcidevs_trylock() )\n        return -ERESTART;\n\n    pdev = pci_get_pdev(seg, bus, devfn);\n\n    rc = -ENODEV;\n    if ( !pdev )\n        goto done;\n\n    rc = 0;\n    if ( d == pdev->domain )\n        goto done;\n\n    rc = -EBUSY;\n    if ( pdev->domain != hardware_domain &&\n         pdev->domain != dom_io )\n        goto done;\n\n    if ( pdev->msix )\n    {\n        rc = pci_reset_msix_state(pdev);\n        if ( rc )\n            goto done;\n        msixtbl_init(d);\n    }\n\n    pdev->fault.count = 0;\n\n    if ( (rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag)) )\n        goto done;\n\n    for ( ; pdev->phantom_stride; rc = 0 )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag);\n        if ( rc )\n            printk(XENLOG_G_WARNING \""d%d: assign %04x:%02x:%02x.%u failed (%d)\\n\"",\n                   d->domain_id, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   rc);\n    }\n\n done:\n    /* The device is assigned to dom_io so mark it as quarantined */\n    if ( !rc && d == dom_io )\n        pdev->quarantine = true;\n\n    pcidevs_unlock();\n\n    return rc;\n}\n"", ""start_line"": 1497, ""end_line"": 1566, ""full_name"": ""assign_device"", ""file_path"": ""xen/drivers/passthrough/pci.c""}]}, {""source"": ""code_info(file:pci.c, lines:1550-1570)"", ""result"": ""            break;\n        rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag);\n        if ( rc )\n            printk(XENLOG_G_WARNING \""d%d: assign %04x:%02x:%02x.%u failed (%d)\\n\"",\n                   d->domain_id, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   rc);\n    }\n\n done:\n    /* The device is assigned to dom_io so mark it as quarantined */\n    if ( !rc && d == dom_io )\n        pdev->quarantine = true;\n\n    pcidevs_unlock();\n\n    return rc;\n}\n\nstatic int iommu_get_device_group(\n    struct domain *d, u16 seg, u8 bus, u8 devfn,\n    XEN_GUEST_HANDLE_64(uint32) buf, int max_sdevs)\n""}]","xen/drivers/passthrough/iommu.c:79-81 (introduces 'quarantine' parameter parsing) and xen/drivers/passthrough/pci.c:923-925 (modifies de-quarantine condition to include 'iommu_quarantine'). The 'pdev->quarantine' flag is set in 'assign_device' (pci.c:1561) only when a device is assigned to 'dom_io', but alternate assignment methods (e.g., libvirt) bypass this logic. Prior to the patch, 'iommu_quarantine' was not enabled by default, leaving devices assigned via non-libxl workflows unquarantined. This allowed untrusted guests to DMA into host memory after device deassignment.",0.95,./github/other_context/CVE-2019-19579
88,CVE-2020-26243,"CWE-20, CWE-119",c_cpp,"Nanopb is a small code-size Protocol Buffers implementation. In Nanopb before versions 0.4.4 and 0.3.9.7, decoding specifically formed message can leak memory if dynamic allocation is enabled and an oneof field contains a static submessage that contains a dynamic field, and the message being decoded contains the submessage multiple times. This is rare in normal messages, but it is a concern when untrusted data is parsed. This is fixed in versions 0.3.9.7 and 0.4.4. The following workarounds are available: 1) Set the option `no_unions` for the oneof field. This will generate fields as separate instead of C union, and avoids triggering the problematic code. 2) Set the type of the submessage field inside oneof to `FT_POINTER`. This way the whole submessage will be dynamically allocated and the problematic code is not executed. 3) Use an arena allocator for nanopb, to make sure all memory can be released afterwards.",https://github.com/nanopb/nanopb/commit/4fe23595732b6f1254cfc11a9b8d6da900b55b0c,"Fix memory leak with oneofs and PB_ENABLE_MALLOC (#615)\n\nNanopb would leak memory when all of the following conditions were true:\n- PB_ENABLE_MALLOC is defined at the compile time\n- Message definitions contains an oneof field,\n  the oneof contains a static submessage, and\n  the static submessage contains a pointer field.\n- Data being decoded contains two values for the submessage.\n\nThe logic in pb_release_union_field would detect that the same\nsubmessage occurs twice, and wouldn't release it because keeping\nthe old values is necessary to match the C++ library behavior\nregarding message merges.\n\nBut then decode_static_field() would go to memset() the whole\nsubmessage to zero, because it unconditionally assumed it to\nbe uninitialized memory. This would normally happen when the\ncontents of the union field is switched to a different oneof\nitem, instead of merging with the same one.\n\nThis commit changes it so that the field is memset() only when\n`which_field` contains a different tag.",1,"[{""func_name"": ""decode_static_field"", ""file_path"": ""pb_decode.c"", ""func_code"": ""static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n            \n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \""array overflow\"");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n\n                return status;\n            }\n            else\n            {\n                /* Repeated field */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \""array overflow\"");\n\n                return func(stream, iter->pos, pItem);\n            }\n\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                /* We memset to zero so that any callbacks are set to NULL.\n                 * Then set any default values. */\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n\n        default:\n            PB_RETURN_ERROR(stream, \""invalid field type\"");\n    }\n}"", ""target"": 0}]","[{""func_name"": ""decode_static_field"", ""file_path"": ""pb_decode.c"", ""func_code"": ""static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n            \n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \""array overflow\"");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n\n                return status;\n            }\n            else\n            {\n                /* Repeated field */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \""array overflow\"");\n\n                return func(stream, iter->pos, pItem);\n            }\n\n        case PB_HTYPE_ONEOF:\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&\n                *(pb_size_t*)iter->pSize != iter->pos->tag)\n            {\n                /* We memset to zero so that any callbacks are set to NULL.\n                 * This is because the callbacks might otherwise have values\n                 * from some other union field. */\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n\n            return func(stream, iter->pos, iter->pData);\n\n        default:\n            PB_RETURN_ERROR(stream, \""invalid field type\"");\n    }\n}""}]","{""caller"": 1, ""value"": 1, ""function"": 1}","[{""source"": ""caller_info(file:pb_decode.c, func:decode_static_field)"", ""result"": [{""call_line"": 746, ""call_code"": ""decode_static_field(stream, wire_type, iter)"", ""caller_code"": ""static bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n#ifdef PB_ENABLE_MALLOC\n    /* When decoding an oneof field, check if there is old data that must be\n     * released first. */\n    if (PB_HTYPE(iter->pos->type) == PB_HTYPE_ONEOF)\n    {\n        if (!pb_release_union_field(stream, iter))\n            return false;\n    }\n#endif\n\n    switch (PB_ATYPE(iter->pos->type))\n    {\n        case PB_ATYPE_STATIC:\n            return decode_static_field(stream, wire_type, iter);\n        \n        case PB_ATYPE_POINTER:\n            return decode_pointer_field(stream, wire_type, iter);\n        \n        case PB_ATYPE_CALLBACK:\n            return decode_callback_field(stream, wire_type, iter);\n        \n        default:\n            PB_RETURN_ERROR(stream, \""invalid field type\"");\n    }\n}"", ""caller_start"": 731, ""file_path"": ""pb_decode.c""}]}, {""source"": ""value_info(file:pb_decode.c, value:iter->pSize)"", ""result"": {""value_trace"": [{""full_code"": ""iter->pSize = &extension->found"", ""line"": 767, ""func_name"": ""iter_from_extension""}], ""struct_var"": ""iter"", ""struct_type"": ""pb_field_iter_t*"", ""struct_definition"": ""typedef struct pb_field_iter_s pb_field_iter_t;\n\ntypedef struct pb_field_iter_s pb_field_iter_t;""}}, {""source"": ""func_info(file:pb_decode.c, func:pb_release_union_field)"", ""result"": [{""code"": ""static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *iter)\n{\n    pb_size_t old_tag = *(pb_size_t*)iter->pSize; /* Previous which_ value */\n    pb_size_t new_tag = iter->pos->tag; /* New which_ value */\n\n    if (old_tag == 0)\n        return true; /* Ok, no old data in union */\n\n    if (old_tag == new_tag)\n        return true; /* Ok, old data is of same type => merge */\n\n    /* Release old data. The find can fail if the message struct contains\n     * invalid data. */\n    if (!pb_field_iter_find(iter, old_tag))\n        PB_RETURN_ERROR(stream, \""invalid union tag\"");\n\n    pb_release_single_field(iter);\n\n    /* Restore iterator to where it should be.\n     * This shouldn't fail unless the pb_field_t structure is corrupted. */\n    if (!pb_field_iter_find(iter, new_tag))\n        PB_RETURN_ERROR(stream, \""iterator error\"");\n    \n    return true;\n}"", ""start_line"": 1128, ""end_line"": 1152, ""full_name"": ""pb_release_union_field"", ""file_path"": ""pb_decode.c""}]}]","pb_decode.c: In decode_static_field(), an unconditional memset() (before patch) would overwrite submessage data even when pb_release_union_field retained it for merging. The vulnerability occurs when:\n1. PB_ENABLE_MALLOC is enabled (dynamic allocation active)\n2. A oneof field contains a static submessage with pointer fields\n3. The same oneof submessage is decoded twice\n\nThe trigger chain:\n- When decoding a oneof field, pb_release_union_field (pb_decode.c:1128) checks if the oneof tag changes. If the same tag is reused (for merging), it retains existing data.\n- However, decode_static_field (pb_decode.c:465) was unconditionally calling memset() on the submessage data, destroying pointers retained by pb_release_union_field.\n- The patch (pb_decode.c:465-470) adds a check: only memset() when the oneof tag changes (i.e., when switching to a different oneof item, not merging).",0.95,./github/other_context/CVE-2020-26243
89,CVE-2021-21248,CWE-94,java,"OneDev is an all-in-one devops platform. In OneDev before version 4.0.3, there is a critical vulnerability involving the build endpoint parameters. InputSpec is used to define parameters of a Build spec. It does so by using dynamically generated Groovy classes. A user able to control job parameters can run arbitrary code on OneDev's server by injecting arbitrary Groovy code. The ultimate result is in the injection of a static constructor that will run arbitrary code. For a full example refer to the referenced GHSA. This issue was addressed in 4.0.3 by escaping special characters such as quote from user input.",https://github.com/theonedev/onedev/commit/39d95ab8122c5d9ed18e69dc024870cae08d2d60,Escape pattern field of build job param to prevent security vulnerability,2,"[{""func_name"": ""getPropertyDef"", ""file_path"": ""server-core/src/main/java/io/onedev/server/model/support/inputspec/textinput/TextInput.java"", ""func_code"": ""public static String getPropertyDef(InputSpec inputSpec, Map<String, Integer> indexes, \n\t\t\tString pattern, DefaultValueProvider defaultValueProvider) {\n\t\tint index = indexes.get(inputSpec.getName());\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tinputSpec.appendField(buffer, index, \""String\"");\n\t\tinputSpec.appendCommonAnnotations(buffer, index);\n\t\tif (!inputSpec.isAllowEmpty())\n\t\t\tbuffer.append(\""    @NotEmpty\\n\"");\n\t\tif (pattern != null)\n\t\t\tbuffer.append(\""    @Pattern(regexp=\\\""\"" + pattern + \""\\\"", message=\\\""Should match regular expression: \"" + pattern + \""\\\"")\\n\"");\n\t\tinputSpec.appendMethods(buffer, index, \""String\"", null, defaultValueProvider);\n\t\t\n\t\treturn buffer.toString();\n\t}"", ""target"": 0}, {""func_name"": ""escape"", ""file_path"": ""server-core/src/main/java/io/onedev/server/model/support/inputspec/InputSpec.java"", ""func_code"": ""protected String escape(String string) {\n\t\tString escaped = JavaEscape.escapeJava(string);\n\t\t// escape $ character since it has special meaning in groovy string\n\t\tescaped = escaped.replace(\""$\"", \""\\\\$\"");\n\n\t\treturn escaped;\n\t}"", ""target"": 0}]","[{""func_name"": ""getPropertyDef"", ""file_path"": ""server-core/src/main/java/io/onedev/server/model/support/inputspec/textinput/TextInput.java"", ""func_code"": ""public static String getPropertyDef(InputSpec inputSpec, Map<String, Integer> indexes, \n\t\t\tString pattern, DefaultValueProvider defaultValueProvider) {\n\t\tpattern = InputSpec.escape(pattern);\n\t\tint index = indexes.get(inputSpec.getName());\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tinputSpec.appendField(buffer, index, \""String\"");\n\t\tinputSpec.appendCommonAnnotations(buffer, index);\n\t\tif (!inputSpec.isAllowEmpty())\n\t\t\tbuffer.append(\""    @NotEmpty\\n\"");\n\t\tif (pattern != null)\n\t\t\tbuffer.append(\""    @Pattern(regexp=\\\""\"" + pattern + \""\\\"", message=\\\""Should match regular expression: \"" + pattern + \""\\\"")\\n\"");\n\t\tinputSpec.appendMethods(buffer, index, \""String\"", null, defaultValueProvider);\n\n\t\treturn buffer.toString();\n\t}""}, {""func_name"": ""escape"", ""file_path"": ""server-core/src/main/java/io/onedev/server/model/support/inputspec/InputSpec.java"", ""func_code"": ""public static String escape(String string) {\n\t\tString escaped = JavaEscape.escapeJava(string);\n\t\t// escape $ character since it has special meaning in groovy string\n\t\tescaped = escaped.replace(\""$\"", \""\\\\$\"");\n\n\t\treturn escaped;\n\t}""}]","{""caller"": 4, ""function"": 3}","[{""source"": ""caller_info(file:TextInput.java, func:getPropertyDef)"", ""result"": [{""call_line"": 51, ""call_code"": ""BooleanInput.getPropertyDef(this, indexes, defaultValueProvider)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn BooleanInput.getPropertyDef(this, indexes, defaultValueProvider);\n\t}\n"", ""caller_start"": 49, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/BooleanParam.java""}, {""call_line"": 16, ""call_code"": ""BuildChoiceInput.getPropertyDef(this, indexes)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn BuildChoiceInput.getPropertyDef(this, indexes);\n\t}\n"", ""caller_start"": 14, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/BuildChoiceParam.java""}, {""call_line"": 83, ""call_code"": ""ChoiceInput.getPropertyDef(this, indexes, choiceProvider, defaultValueProvider, defaultMultiValueProvider)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn ChoiceInput.getPropertyDef(this, indexes, choiceProvider, defaultValueProvider, defaultMultiValueProvider);\n\t}\n"", ""caller_start"": 81, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/ChoiceParam.java""}, {""call_line"": 16, ""call_code"": ""CommitInput.getPropertyDef(this, indexes)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn CommitInput.getPropertyDef(this, indexes);\n\t}\n"", ""caller_start"": 14, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/CommitParam.java""}]}, {""source"": ""func_info(file:InputSpec.java, func:getPropertyDef)"", ""result"": [{""code"": ""\tpublic abstract String getPropertyDef(Map<String, Integer> indexes);\n"", ""start_line"": 116, ""end_line"": 116, ""full_name"": ""io.onedev.server.model.support.inputspec.InputSpec.getPropertyDef:java.lang.String(java.util.Map)"", ""file_path"": ""server-core/src/main/java/io/onedev/server/model/support/inputspec/InputSpec.java""}]}, {""source"": ""caller_info(file:TextInput.java, func:getPropertyDef)"", ""result"": [{""call_line"": 51, ""call_code"": ""BooleanInput.getPropertyDef(this, indexes, defaultValueProvider)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn BooleanInput.getPropertyDef(this, indexes, defaultValueProvider);\n\t}\n"", ""caller_start"": 49, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/BooleanParam.java""}, {""call_line"": 16, ""call_code"": ""BuildChoiceInput.getPropertyDef(this, indexes)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn BuildChoiceInput.getPropertyDef(this, indexes);\n\t}\n"", ""caller_start"": 14, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/BuildChoiceParam.java""}, {""call_line"": 83, ""call_code"": ""ChoiceInput.getPropertyDef(this, indexes, choiceProvider, defaultValueProvider, defaultMultiValueProvider)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn ChoiceInput.getPropertyDef(this, indexes, choiceProvider, defaultValueProvider, defaultMultiValueProvider);\n\t}\n"", ""caller_start"": 81, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/ChoiceParam.java""}, {""call_line"": 16, ""call_code"": ""CommitInput.getPropertyDef(this, indexes)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn CommitInput.getPropertyDef(this, indexes);\n\t}\n"", ""caller_start"": 14, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/CommitParam.java""}]}, {""source"": ""func_info(file:InputSpec.java, func:getPropertyDef)"", ""result"": [{""code"": ""\tpublic abstract String getPropertyDef(Map<String, Integer> indexes);\n"", ""start_line"": 116, ""end_line"": 116, ""full_name"": ""io.onedev.server.model.support.inputspec.InputSpec.getPropertyDef:java.lang.String(java.util.Map)"", ""file_path"": ""server-core/src/main/java/io/onedev/server/model/support/inputspec/InputSpec.java""}]}, {""source"": ""caller_info(file:TextInput.java, func:getPropertyDef)"", ""result"": [{""call_line"": 51, ""call_code"": ""BooleanInput.getPropertyDef(this, indexes, defaultValueProvider)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn BooleanInput.getPropertyDef(this, indexes, defaultValueProvider);\n\t}\n"", ""caller_start"": 49, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/BooleanParam.java""}, {""call_line"": 16, ""call_code"": ""BuildChoiceInput.getPropertyDef(this, indexes)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn BuildChoiceInput.getPropertyDef(this, indexes);\n\t}\n"", ""caller_start"": 14, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/BuildChoiceParam.java""}, {""call_line"": 83, ""call_code"": ""ChoiceInput.getPropertyDef(this, indexes, choiceProvider, defaultValueProvider, defaultMultiValueProvider)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn ChoiceInput.getPropertyDef(this, indexes, choiceProvider, defaultValueProvider, defaultMultiValueProvider);\n\t}\n"", ""caller_start"": 81, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/ChoiceParam.java""}, {""call_line"": 16, ""call_code"": ""CommitInput.getPropertyDef(this, indexes)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn CommitInput.getPropertyDef(this, indexes);\n\t}\n"", ""caller_start"": 14, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/CommitParam.java""}]}, {""source"": ""caller_info(file:InputSpec.java, func:getPropertyDef)"", ""result"": [{""call_line"": 232, ""call_code"": ""input.getPropertyDef(indexes)"", ""caller_code"": ""\tpublic static Class<?> defineClass(String className, String description, Collection<? extends InputSpec> inputs) {\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tbuffer.append(\""import org.apache.commons.lang3.SerializationUtils;\\n\"");\n\t\tbuffer.append(\""import com.google.common.base.Optional;\\n\"");\n\t\tbuffer.append(\""import io.onedev.server.web.editable.annotation.*;\\n\"");\n\t\tbuffer.append(\""import io.onedev.server.util.validation.annotation.*;\\n\"");\n\t\tbuffer.append(\""import io.onedev.util.*;\\n\"");\n\t\tbuffer.append(\""import io.onedev.server.util.*;\\n\"");\n\t\tbuffer.append(\""import io.onedev.server.util.facade.*;\\n\"");\n\t\tbuffer.append(\""import java.util.*;\\n\"");\n\t\tbuffer.append(\""import javax.validation.constraints.*;\\n\"");\n\t\tbuffer.append(\""import org.hibernate.validator.constraints.*;\\n\"");\n\t\tbuffer.append(\""\\n\"");\n\t\tbuffer.append(\""@Editable(name=\"").append(\""\\\""\"").append(description).append(\""\\\"")\\n\"");\n\t\tbuffer.append(\""class \"" + className + \"" implements java.io.Serializable {\\n\"");\n\t\tbuffer.append(\""\\n\"");\n\t\tbuffer.append(\""    private static final long serialVersionUID = 1L;\\n\"");\n\t\tbuffer.append(\""\\n\"");\n\t\tMap<String, Integer> indexes = new HashMap<>();\n\t\tint index = 1;\n\t\tfor (InputSpec input: inputs)\n\t\t\tindexes.put(input.getName(), index++);\n\t\tfor (InputSpec input: inputs)\n\t\t\tbuffer.append(input.getPropertyDef(indexes));\n\n\t\tbuffer.append(\""}\\n\"");\n\t\tbuffer.append(\""return \"" + className + \"";\\n\"");\n\t\t\n\t\tlogger.trace(\""Class definition script:\\n\"" + buffer.toString());\n\t\t\n\t\treturn (Class<?>) GroovyUtils.evalScript(buffer.toString(), new HashMap<>());\n\t}\n"", ""caller_start"": 209, ""file_path"": ""server-core/src/main/java/io/onedev/server/model/support/inputspec/InputSpec.java""}, {""call_line"": 51, ""call_code"": ""BooleanInput.getPropertyDef(this, indexes, defaultValueProvider)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn BooleanInput.getPropertyDef(this, indexes, defaultValueProvider);\n\t}\n"", ""caller_start"": 49, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/BooleanParam.java""}, {""call_line"": 16, ""call_code"": ""BuildChoiceInput.getPropertyDef(this, indexes)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn BuildChoiceInput.getPropertyDef(this, indexes);\n\t}\n"", ""caller_start"": 14, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/BuildChoiceParam.java""}, {""call_line"": 83, ""call_code"": ""ChoiceInput.getPropertyDef(this, indexes, choiceProvider, defaultValueProvider, defaultMultiValueProvider)"", ""caller_code"": ""\t@Override\n\tpublic String getPropertyDef(Map<String, Integer> indexes) {\n\t\treturn ChoiceInput.getPropertyDef(this, indexes, choiceProvider, defaultValueProvider, defaultMultiValueProvider);\n\t}\n"", ""caller_start"": 81, ""file_path"": ""server-core/src/main/java/io/onedev/server/buildspec/job/paramspec/ChoiceParam.java""}]}, {""source"": ""func_info(file:InputSpec.java, func:getPropertyDef)"", ""result"": [{""code"": ""\tpublic abstract String getPropertyDef(Map<String, Integer> indexes);\n"", ""start_line"": 116, ""end_line"": 116, ""full_name"": ""io.onedev.server.model.support.inputspec.InputSpec.getPropertyDef:java.lang.String(java.util.Map)"", ""file_path"": ""server-core/src/main/java/io/onedev/server/model/support/inputspec/InputSpec.java""}]}]","Unescaped user-controlled `pattern` input in `InputSpec` was injected into dynamically generated Groovy classes. The vulnerable flow:\n1. User input is assigned to `pattern` in `InputSpec` (e.g., via job parameters).\n2. `getPropertyDef` (TextInput.java:50) generates a string containing `@Pattern(regexp=""${pattern}"")` without escaping (pre-patch).\n3. `defineClass` (InputSpec.java:232) appends `getPropertyDef` output into a Groovy class definition string, which is evaluated via `GroovyUtils.evalScript`.\n4. Unescaped special characters (e.g., `${`, `;`) in `pattern` allowed Groovy code injection. The patch adds escaping in `getPropertyDef` (TextInput.java:50) and modifies `escape` (InputSpec.java:109) to sanitize input before Groovy evaluation.",0.95,./github/other_context/CVE-2021-21248
90,CVE-2021-20302,CWE-20,c_cpp,"A flaw was found in OpenEXR's TiledInputFile functionality. This flaw allows an attacker who can submit a crafted single-part non-image to be processed by OpenEXR, to trigger a floating-point exception error. The highest threat from this vulnerability is to system availability.",https://github.com/AcademySoftwareFoundation/openexr/commit/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea,add exrcheck binary and function in IlmImfUtil\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>,3,"[{""func_name"": ""TiledInputFile::initialize"", ""file_path"": ""OpenEXR/IlmImf/ImfTiledInputFile.cpp"", ""func_code"": ""void\nTiledInputFile::initialize ()\n{\n    // fix bad types in header (arises when a tool built against an older version of\n    // OpenEXR converts a scanline image to tiled)\n    // only applies when file is a single part, regular image, tiled file\n    //\n    if(!isMultiPart(_data->version) &&\n       !isNonImage(_data->version) && \n       isTiled(_data->version) && \n       _data->header.hasType() )\n    {\n        _data->header.setType(TILEDIMAGE);\n    }\n    \n    if (_data->partNumber == -1)\n    {\n        if (!isTiled (_data->version))\n            throw IEX_NAMESPACE::ArgExc (\""Expected a tiled file but the file is not tiled.\"");\n        \n    }\n    else\n    {\n        if(_data->header.hasType() && _data->header.type()!=TILEDIMAGE)\n        {\n            throw IEX_NAMESPACE::ArgExc (\""TiledInputFile used for non-tiledimage part.\"");\n        }\n    }\n    \n    _data->header.sanityCheck (true);\n\n    _data->tileDesc = _data->header.tileDescription();\n    _data->lineOrder = _data->header.lineOrder();\n\n    //\n    // Save the dataWindow information\n    //\n    \n    const Box2i &dataWindow = _data->header.dataWindow();\n    _data->minX = dataWindow.min.x;\n    _data->maxX = dataWindow.max.x;\n    _data->minY = dataWindow.min.y;\n    _data->maxY = dataWindow.max.y;\n\n    //\n    // Precompute level and tile information to speed up utility functions\n    //\n\n    precalculateTileInfo (_data->tileDesc,\n\t\t\t  _data->minX, _data->maxX,\n\t\t\t  _data->minY, _data->maxY,\n\t\t\t  _data->numXTiles, _data->numYTiles,\n\t\t\t  _data->numXLevels, _data->numYLevels);    \n\n    _data->bytesPerPixel = calculateBytesPerPixel (_data->header);\n\n    _data->maxBytesPerTileLine = _data->bytesPerPixel * _data->tileDesc.xSize;\n\n    _data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize;\n\n    //\n    // OpenEXR has a limit of INT_MAX compressed bytes per tile\n    // disallow uncompressed tile sizes above INT_MAX too to guarantee file is written\n    //\n    if( _data->tileBufferSize > INT_MAX )\n    {\n        throw IEX_NAMESPACE::ArgExc (\""Tile size too large for OpenEXR format\"");\n    }\n\n\n    //\n    // Create all the TileBuffers and allocate their internal buffers\n    //\n\n    for (size_t i = 0; i < _data->tileBuffers.size(); i++)\n    {\n        _data->tileBuffers[i] = new TileBuffer (newTileCompressor\n\t\t\t\t\t\t  (_data->header.compression(),\n\t\t\t\t\t\t   _data->maxBytesPerTileLine,\n\t\t\t\t\t\t   _data->tileDesc.ySize,\n\t\t\t\t\t\t   _data->header));\n\n        if (!_data->_streamData->is->isMemoryMapped ())\n            _data->tileBuffers[i]->buffer = new char [_data->tileBufferSize];\n    }\n\n    _data->tileOffsets = TileOffsets (_data->tileDesc.mode,\n\t\t\t\t      _data->numXLevels,\n\t\t\t\t      _data->numYLevels,\n\t\t\t\t      _data->numXTiles,\n\t\t\t\t      _data->numYTiles);\n}"", ""target"": 0}, {""func_name"": ""LineBufferTask::execute"", ""file_path"": ""OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp"", ""func_code"": ""void\nLineBufferTask::execute ()\n{\n    try\n    {\n        //\n        // Uncompress the data, if necessary\n        //\n\n        if (_lineBuffer->uncompressedData == 0)\n        {\n            Int64 uncompressedSize = 0;\n            int maxY = min (_lineBuffer->maxY, _ifd->maxY);\n\n            for (int i = _lineBuffer->minY - _ifd->minY;\n                 i <= maxY - _ifd->minY;\n                 ++i)\n            {\n                uncompressedSize += (int) _ifd->bytesPerLine[i];\n            }\n\n            //\n            // Create the compressor everytime when we want to use it,\n            // because we don't know maxBytesPerLine beforehand.\n            // (TODO) optimize this. don't do this every time.\n            //\n\n            if (_lineBuffer->compressor != 0)\n                delete _lineBuffer->compressor;\n            Int64 maxBytesPerLine = 0;\n            for (int i = _lineBuffer->minY - _ifd->minY;\n                 i <= maxY - _ifd->minY;\n                 ++i)\n            {\n                if (_ifd->bytesPerLine[i] > maxBytesPerLine)\n                    maxBytesPerLine = _ifd->bytesPerLine[i];\n            }\n            _lineBuffer->compressor = newCompressor(_ifd->header.compression(),\n                                                    maxBytesPerLine,\n                                                    _ifd->header);\n\n            if (_lineBuffer->compressor &&\n                _lineBuffer->packedDataSize < uncompressedSize)\n            {\n                _lineBuffer->format = _lineBuffer->compressor->format();\n\n                _lineBuffer->packedDataSize = _lineBuffer->compressor->uncompress\n                    (_lineBuffer->buffer, _lineBuffer->packedDataSize,\n                     _lineBuffer->minY, _lineBuffer->uncompressedData);\n            }\n            else\n            {\n                //\n                // If the line is uncompressed, it's in XDR format,\n                // regardless of the compressor's output format.\n                //\n\n                _lineBuffer->format = Compressor::XDR;\n                _lineBuffer->uncompressedData = _lineBuffer->buffer;\n            }\n        }\n\n        int yStart, yStop, dy;\n\n        if (_ifd->lineOrder == INCREASING_Y)\n        {\n            yStart = _scanLineMin;\n            yStop = _scanLineMax + 1;\n            dy = 1;\n        }\n        else\n        {\n            yStart = _scanLineMax;\n            yStop = _scanLineMin - 1;\n            dy = -1;\n        }\n\n        for (int y = yStart; y != yStop; y += dy)\n        {\n            //\n            // Convert one scan line's worth of pixel data back\n            // from the machine-independent representation, and\n            // store the result in the frame buffer.\n            //\n\n            const char *readPtr = _lineBuffer->uncompressedData +\n                                  _ifd->offsetInLineBuffer[y - _ifd->minY];\n\n            //\n            // Iterate over all image channels.\n            //\n\n            for (unsigned int i = 0; i < _ifd->slices.size(); ++i)\n            {\n                //\n                // Test if scan line y of this channel contains any data\n                // (the scan line contains data only if y % ySampling == 0).\n                //\n\n                InSliceInfo &slice = *_ifd->slices[i];\n\n                if (modp (y, slice.ySampling) != 0)\n                    continue;\n\n                //\n                // Find the x coordinates of the leftmost and rightmost\n                // sampled pixels (i.e. pixels within the data window\n                // for which x % xSampling == 0).\n                //\n\n                //\n                // Fill the frame buffer with pixel data.\n                //\n\n                if (slice.skip)\n                {\n                    //\n                    // The file contains data for this channel, but\n                    // the frame buffer contains no slice for this channel.\n                    //\n\n                    skipChannel (readPtr, slice.typeInFile,\n                                 _ifd->lineSampleCount[y - _ifd->minY]);\n                }\n                else\n                {\n                    //\n                    // The frame buffer contains a slice for this channel.\n                    //\n\n                    int width = (_ifd->maxX - _ifd->minX + 1);\n\n                    copyIntoDeepFrameBuffer (readPtr, slice.base,\n                                             (char*) (&_ifd->sampleCount[0][0]\n                                                      - _ifd->minX\n                                                      - _ifd->minY * width),\n                                             sizeof(unsigned int) * 1,\n                                             sizeof(unsigned int) * width,\n                                             y, _ifd->minX, _ifd->maxX,\n                                             0, 0,\n                                             0, 0,\n                                             slice.sampleStride, \n                                             slice.xPointerStride,\n                                             slice.yPointerStride,\n                                             slice.fill,\n                                             slice.fillValue, _lineBuffer->format,\n                                             slice.typeInFrameBuffer,\n                                             slice.typeInFile);\n                }\n            }\n        }\n    }\n    catch (std::exception &e)\n    {\n        if (!_lineBuffer->hasException)\n        {\n            _lineBuffer->exception = e.what();\n            _lineBuffer->hasException = true;\n        }\n    }\n    catch (...)\n    {\n        if (!_lineBuffer->hasException)\n        {\n            _lineBuffer->exception = \""unrecognized exception\"";\n            _lineBuffer->hasException = true;\n        }\n    }\n}"", ""target"": 0}, {""func_name"": ""bufferedReadPixels"", ""file_path"": ""OpenEXR/IlmImf/ImfInputFile.cpp"", ""func_code"": ""void\nbufferedReadPixels (InputFile::Data* ifd, int scanLine1, int scanLine2)\n{\n    //\n    // bufferedReadPixels reads each row of tiles that intersect the\n    // scan-line range (scanLine1 to scanLine2). The previous row of\n    // tiles is cached in order to prevent redundent tile reads when\n    // accessing scanlines sequentially.\n    //\n\n    int minY = std::min (scanLine1, scanLine2);\n    int maxY = std::max (scanLine1, scanLine2);\n\n    if (minY < ifd->minY || maxY >  ifd->maxY)\n    {\n        throw IEX_NAMESPACE::ArgExc (\""Tried to read scan line outside \""\n\t\t\t   \""the image file's data window.\"");\n    }\n\n    //\n    // The minimum and maximum y tile coordinates that intersect this\n    // scanline range\n    //\n\n    int minDy = (minY - ifd->minY) / ifd->tFile->tileYSize();\n    int maxDy = (maxY - ifd->minY) / ifd->tFile->tileYSize();\n\n    //\n    // Figure out which one is first in the file so we can read without seeking\n    //\n\n    int yStart, yEnd, yStep;\n\n    if (ifd->lineOrder == DECREASING_Y)\n    {\n        yStart = maxDy;\n        yEnd = minDy - 1;\n        yStep = -1;\n    }\n    else\n    {\n        yStart = minDy;\n        yEnd = maxDy + 1;\n        yStep = 1;\n    }\n\n    //\n    // the number of pixels in a row of tiles\n    //\n\n    Box2i levelRange = ifd->tFile->dataWindowForLevel(0);\n    \n    //\n    // Read the tiles into our temporary framebuffer and copy them into\n    // the user's buffer\n    //\n\n    for (int j = yStart; j != yEnd; j += yStep)\n    {\n        Box2i tileRange = ifd->tFile->dataWindowForTile (0, j, 0);\n\n        int minYThisRow = std::max (minY, tileRange.min.y);\n        int maxYThisRow = std::min (maxY, tileRange.max.y);\n\n        if (j != ifd->cachedTileY)\n        {\n            //\n            // We don't have any valid buffered info, so we need to read in\n            // from the file.\n            // if no channels are being read that are present in file, cachedBuffer will be empty\n            //\n\n            if (ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())\n            {\n                ifd->tFile->readTiles (0, ifd->tFile->numXTiles (0) - 1, j, j);\n            }\n\n            ifd->cachedTileY = j;\n        }\n\n        //\n        // Copy the data from our cached framebuffer into the user's\n        // framebuffer.\n        //\n\n        for (FrameBuffer::ConstIterator k = ifd->tFileBuffer.begin();\n             k != ifd->tFileBuffer.end();\n             ++k)\n        {\n\n\n            Slice toSlice = k.slice();\t\t// slice to read from\n            char* toPtr;\n\n            int xStart = levelRange.min.x;\n            int yStart = minYThisRow;\n\n            while (modp (xStart, toSlice.xSampling) != 0)\n                ++xStart;\n\n            while (modp (yStart, toSlice.ySampling) != 0)\n                ++yStart;\n\n            FrameBuffer::ConstIterator c = ifd->cachedBuffer->find(k.name());\n            intptr_t toBase = reinterpret_cast<intptr_t>(toSlice.base);\n\n\n            if( c!=ifd->cachedBuffer->end())\n            {\n                //\n                // output channel was read from source image: copy to output slice\n                //\n                Slice fromSlice = c.slice();\t// slice to write to\n                intptr_t fromBase = reinterpret_cast<intptr_t>(fromSlice.base);\n\n                int size = pixelTypeSize (toSlice.type);\n                char* fromPtr;\n\n                for (int y = yStart;\n                    y <= maxYThisRow;\n                    y += toSlice.ySampling)\n                {\n                    //\n                    // Set the pointers to the start of the y scanline in\n                    // this row of tiles\n                    //\n\n                    fromPtr = reinterpret_cast<char*> (fromBase  +\n                            (y - tileRange.min.y) * fromSlice.yStride +\n                            xStart * fromSlice.xStride);\n\n                    toPtr = reinterpret_cast<char*> (toBase +\n                            divp (y, toSlice.ySampling) * toSlice.yStride +\n                            divp (xStart, toSlice.xSampling) * toSlice.xStride);\n\n                    //\n                    // Copy all pixels for the scanline in this row of tiles\n                    //\n\n                    for (int x = xStart;\n                        x <= levelRange.max.x;\n                        x += toSlice.xSampling)\n                    {\n                        for (int i = 0; i < size; ++i)\n                            toPtr[i] = fromPtr[i];\n\n                        fromPtr += fromSlice.xStride * toSlice.xSampling;\n                        toPtr += toSlice.xStride;\n                    }\n                }\n            }\n            else\n            {\n\n                //\n                // channel wasn't present in source file: fill output slice\n                //\n                for (int y = yStart;\n                    y <= maxYThisRow;\n                    y += toSlice.ySampling)\n                {\n\n                    toPtr = reinterpret_cast<char*> (toBase+\n                            divp (y, toSlice.ySampling) * toSlice.yStride +\n                            divp (xStart, toSlice.xSampling) * toSlice.xStride);\n\n                    //\n                    // Copy all pixels for the scanline in this row of tiles\n                    //\n\n                    switch ( toSlice.type)\n                    {\n                        case UINT:\n                        {\n                            unsigned int fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<unsigned int*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case HALF :\n                        {\n                            half fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<half*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case FLOAT :\n                        {\n                            float fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<float*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case NUM_PIXELTYPES :\n                        {\n                            break;\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n}"", ""target"": 1}]","[{""func_name"": ""TiledInputFile::initialize"", ""file_path"": ""OpenEXR/IlmImf/ImfTiledInputFile.cpp"", ""func_code"": ""void\nTiledInputFile::initialize ()\n{\n    // fix bad types in header (arises when a tool built against an older version of\n    // OpenEXR converts a scanline image to tiled)\n    // only applies when file is a single part, regular image, tiled file\n    //\n    if(!isMultiPart(_data->version) &&\n       !isNonImage(_data->version) && \n       isTiled(_data->version) && \n       _data->header.hasType() )\n    {\n        _data->header.setType(TILEDIMAGE);\n    }\n    \n    if (_data->partNumber == -1)\n    {\n        if (!isTiled (_data->version))\n            throw IEX_NAMESPACE::ArgExc (\""Expected a tiled file but the file is not tiled.\"");\n\n        if (isNonImage (_data->version))\n            throw IEX_NAMESPACE::ArgExc (\""File is not a regular tiled image.\"");\n\n    }\n    else\n    {\n        if(_data->header.hasType() && _data->header.type()!=TILEDIMAGE)\n        {\n            throw IEX_NAMESPACE::ArgExc (\""TiledInputFile used for non-tiledimage part.\"");\n        }\n    }\n    \n    _data->header.sanityCheck (true);\n\n    _data->tileDesc = _data->header.tileDescription();\n    _data->lineOrder = _data->header.lineOrder();\n\n    //\n    // Save the dataWindow information\n    //\n    \n    const Box2i &dataWindow = _data->header.dataWindow();\n    _data->minX = dataWindow.min.x;\n    _data->maxX = dataWindow.max.x;\n    _data->minY = dataWindow.min.y;\n    _data->maxY = dataWindow.max.y;\n\n    //\n    // Precompute level and tile information to speed up utility functions\n    //\n\n    precalculateTileInfo (_data->tileDesc,\n\t\t\t  _data->minX, _data->maxX,\n\t\t\t  _data->minY, _data->maxY,\n\t\t\t  _data->numXTiles, _data->numYTiles,\n\t\t\t  _data->numXLevels, _data->numYLevels);    \n\n    _data->bytesPerPixel = calculateBytesPerPixel (_data->header);\n\n    _data->maxBytesPerTileLine = _data->bytesPerPixel * _data->tileDesc.xSize;\n\n    _data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize;\n\n    //\n    // OpenEXR has a limit of INT_MAX compressed bytes per tile\n    // disallow uncompressed tile sizes above INT_MAX too to guarantee file is written\n    //\n    if( _data->tileBufferSize > INT_MAX )\n    {\n        throw IEX_NAMESPACE::ArgExc (\""Tile size too large for OpenEXR format\"");\n    }\n\n\n    //\n    // Create all the TileBuffers and allocate their internal buffers\n    //\n\n    for (size_t i = 0; i < _data->tileBuffers.size(); i++)\n    {\n        _data->tileBuffers[i] = new TileBuffer (newTileCompressor\n\t\t\t\t\t\t  (_data->header.compression(),\n\t\t\t\t\t\t   _data->maxBytesPerTileLine,\n\t\t\t\t\t\t   _data->tileDesc.ySize,\n\t\t\t\t\t\t   _data->header));\n\n        if (!_data->_streamData->is->isMemoryMapped ())\n            _data->tileBuffers[i]->buffer = new char [_data->tileBufferSize];\n    }\n\n    _data->tileOffsets = TileOffsets (_data->tileDesc.mode,\n\t\t\t\t      _data->numXLevels,\n\t\t\t\t      _data->numYLevels,\n\t\t\t\t      _data->numXTiles,\n\t\t\t\t      _data->numYTiles);\n}""}, {""func_name"": ""LineBufferTask::execute"", ""file_path"": ""OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp"", ""func_code"": ""void\nLineBufferTask::execute ()\n{\n    try\n    {\n        //\n        // Uncompress the data, if necessary\n        //\n\n        if (_lineBuffer->uncompressedData == 0)\n        {\n            Int64 uncompressedSize = 0;\n            int maxY = min (_lineBuffer->maxY, _ifd->maxY);\n\n            for (int i = _lineBuffer->minY - _ifd->minY;\n                 i <= maxY - _ifd->minY;\n                 ++i)\n            {\n                uncompressedSize += (int) _ifd->bytesPerLine[i];\n            }\n\n            //\n            // Create the compressor everytime when we want to use it,\n            // because we don't know maxBytesPerLine beforehand.\n            // (TODO) optimize this. don't do this every time.\n            //\n\n            if (_lineBuffer->compressor != 0)\n                delete _lineBuffer->compressor;\n            Int64 maxBytesPerLine = 0;\n            for (int i = _lineBuffer->minY - _ifd->minY;\n                 i <= maxY - _ifd->minY;\n                 ++i)\n            {\n                if (_ifd->bytesPerLine[i] > maxBytesPerLine)\n                    maxBytesPerLine = _ifd->bytesPerLine[i];\n            }\n            _lineBuffer->compressor = newCompressor(_ifd->header.compression(),\n                                                    maxBytesPerLine,\n                                                    _ifd->header);\n\n            if (_lineBuffer->compressor &&\n                _lineBuffer->packedDataSize < uncompressedSize)\n            {\n                _lineBuffer->format = _lineBuffer->compressor->format();\n\n                _lineBuffer->packedDataSize = _lineBuffer->compressor->uncompress\n                    (_lineBuffer->buffer, _lineBuffer->packedDataSize,\n                     _lineBuffer->minY, _lineBuffer->uncompressedData);\n            }\n            else\n            {\n                //\n                // If the line is uncompressed, it's in XDR format,\n                // regardless of the compressor's output format.\n                //\n\n                _lineBuffer->format = Compressor::XDR;\n                _lineBuffer->uncompressedData = _lineBuffer->buffer;\n            }\n        }\n\n        int yStart, yStop, dy;\n\n        if (_ifd->lineOrder == INCREASING_Y)\n        {\n            yStart = _scanLineMin;\n            yStop = _scanLineMax + 1;\n            dy = 1;\n        }\n        else\n        {\n            yStart = _scanLineMax;\n            yStop = _scanLineMin - 1;\n            dy = -1;\n        }\n\n        for (int y = yStart; y != yStop; y += dy)\n        {\n            //\n            // Convert one scan line's worth of pixel data back\n            // from the machine-independent representation, and\n            // store the result in the frame buffer.\n            //\n\n            const char *readPtr = _lineBuffer->uncompressedData +\n                                  _ifd->offsetInLineBuffer[y - _ifd->minY];\n\n            //\n            // Iterate over all image channels.\n            //\n\n            for (unsigned int i = 0; i < _ifd->slices.size(); ++i)\n            {\n                //\n                // Test if scan line y of this channel contains any data\n                // (the scan line contains data only if y % ySampling == 0).\n                //\n\n                InSliceInfo &slice = *_ifd->slices[i];\n\n                if (modp (y, slice.ySampling) != 0)\n                    continue;\n\n                //\n                // Find the x coordinates of the leftmost and rightmost\n                // sampled pixels (i.e. pixels within the data window\n                // for which x % xSampling == 0).\n                //\n\n                //\n                // Fill the frame buffer with pixel data.\n                //\n\n                if (slice.skip)\n                {\n                    //\n                    // The file contains data for this channel, but\n                    // the frame buffer contains no slice for this channel.\n                    //\n\n                    skipChannel (readPtr, slice.typeInFile,\n                                 _ifd->lineSampleCount[y - _ifd->minY]);\n                }\n                else\n                {\n                    //\n                    // The frame buffer contains a slice for this channel.\n                    //\n\n                    int width = (_ifd->maxX - _ifd->minX + 1);\n\n                    ptrdiff_t base = reinterpret_cast<ptrdiff_t>(&_ifd->sampleCount[0][0]);\n                    base -= sizeof(unsigned int)*_ifd->minX;\n                    base -= sizeof(unsigned int)*static_cast<ptrdiff_t>(_ifd->minY) * static_cast<ptrdiff_t>(width);\n\n                    copyIntoDeepFrameBuffer (readPtr, slice.base,\n                                             reinterpret_cast<char*>(base),\n                                             sizeof(unsigned int) * 1,\n                                             sizeof(unsigned int) * width,\n                                             y, _ifd->minX, _ifd->maxX,\n                                             0, 0,\n                                             0, 0,\n                                             slice.sampleStride, \n                                             slice.xPointerStride,\n                                             slice.yPointerStride,\n                                             slice.fill,\n                                             slice.fillValue, _lineBuffer->format,\n                                             slice.typeInFrameBuffer,\n                                             slice.typeInFile);\n                }\n            }\n        }\n    }\n    catch (std::exception &e)\n    {\n        if (!_lineBuffer->hasException)\n        {\n            _lineBuffer->exception = e.what();\n            _lineBuffer->hasException = true;\n        }\n    }\n    catch (...)\n    {\n        if (!_lineBuffer->hasException)\n        {\n            _lineBuffer->exception = \""unrecognized exception\"";\n            _lineBuffer->hasException = true;\n        }\n    }\n}""}, {""func_name"": ""bufferedReadPixels"", ""file_path"": ""OpenEXR/IlmImf/ImfInputFile.cpp"", ""func_code"": ""void\nbufferedReadPixels (InputFile::Data* ifd, int scanLine1, int scanLine2)\n{\n    //\n    // bufferedReadPixels reads each row of tiles that intersect the\n    // scan-line range (scanLine1 to scanLine2). The previous row of\n    // tiles is cached in order to prevent redundent tile reads when\n    // accessing scanlines sequentially.\n    //\n\n    int minY = std::min (scanLine1, scanLine2);\n    int maxY = std::max (scanLine1, scanLine2);\n\n    if (minY < ifd->minY || maxY >  ifd->maxY)\n    {\n        throw IEX_NAMESPACE::ArgExc (\""Tried to read scan line outside \""\n\t\t\t   \""the image file's data window.\"");\n    }\n\n    //\n    // The minimum and maximum y tile coordinates that intersect this\n    // scanline range\n    //\n\n    int minDy = (minY - ifd->minY) / ifd->tFile->tileYSize();\n    int maxDy = (maxY - ifd->minY) / ifd->tFile->tileYSize();\n\n    //\n    // Figure out which one is first in the file so we can read without seeking\n    //\n\n    int yStart, yEnd, yStep;\n\n    if (ifd->lineOrder == DECREASING_Y)\n    {\n        yStart = maxDy;\n        yEnd = minDy - 1;\n        yStep = -1;\n    }\n    else\n    {\n        yStart = minDy;\n        yEnd = maxDy + 1;\n        yStep = 1;\n    }\n\n    //\n    // the number of pixels in a row of tiles\n    //\n\n    Box2i levelRange = ifd->tFile->dataWindowForLevel(0);\n    \n    //\n    // Read the tiles into our temporary framebuffer and copy them into\n    // the user's buffer\n    //\n\n    for (int j = yStart; j != yEnd; j += yStep)\n    {\n        Box2i tileRange = ifd->tFile->dataWindowForTile (0, j, 0);\n\n        int minYThisRow = std::max (minY, tileRange.min.y);\n        int maxYThisRow = std::min (maxY, tileRange.max.y);\n\n        if (j != ifd->cachedTileY)\n        {\n            //\n            // We don't have any valid buffered info, so we need to read in\n            // from the file.\n            // if no channels are being read that are present in file, cachedBuffer will be empty\n            //\n\n            if (ifd->cachedBuffer && ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())\n            {\n                ifd->tFile->readTiles (0, ifd->tFile->numXTiles (0) - 1, j, j);\n            }\n\n            ifd->cachedTileY = j;\n        }\n\n        //\n        // Copy the data from our cached framebuffer into the user's\n        // framebuffer.\n        //\n\n        for (FrameBuffer::ConstIterator k = ifd->tFileBuffer.begin();\n             k != ifd->tFileBuffer.end();\n             ++k)\n        {\n\n\n            Slice toSlice = k.slice();\t\t// slice to read from\n            char* toPtr;\n\n            int xStart = levelRange.min.x;\n            int yStart = minYThisRow;\n\n            while (modp (xStart, toSlice.xSampling) != 0)\n                ++xStart;\n\n            while (modp (yStart, toSlice.ySampling) != 0)\n                ++yStart;\n\n            FrameBuffer::ConstIterator c = ifd->cachedBuffer->find(k.name());\n            intptr_t toBase = reinterpret_cast<intptr_t>(toSlice.base);\n\n\n            if( c!=ifd->cachedBuffer->end())\n            {\n                //\n                // output channel was read from source image: copy to output slice\n                //\n                Slice fromSlice = c.slice();\t// slice to write to\n                intptr_t fromBase = reinterpret_cast<intptr_t>(fromSlice.base);\n\n                int size = pixelTypeSize (toSlice.type);\n                char* fromPtr;\n\n                for (int y = yStart;\n                    y <= maxYThisRow;\n                    y += toSlice.ySampling)\n                {\n                    //\n                    // Set the pointers to the start of the y scanline in\n                    // this row of tiles\n                    //\n\n                    fromPtr = reinterpret_cast<char*> (fromBase  +\n                            (y - tileRange.min.y) * fromSlice.yStride +\n                            xStart * fromSlice.xStride);\n\n                    toPtr = reinterpret_cast<char*> (toBase +\n                            divp (y, toSlice.ySampling) * toSlice.yStride +\n                            divp (xStart, toSlice.xSampling) * toSlice.xStride);\n\n                    //\n                    // Copy all pixels for the scanline in this row of tiles\n                    //\n\n                    for (int x = xStart;\n                        x <= levelRange.max.x;\n                        x += toSlice.xSampling)\n                    {\n                        for (int i = 0; i < size; ++i)\n                            toPtr[i] = fromPtr[i];\n\n                        fromPtr += fromSlice.xStride * toSlice.xSampling;\n                        toPtr += toSlice.xStride;\n                    }\n                }\n            }\n            else\n            {\n\n                //\n                // channel wasn't present in source file: fill output slice\n                //\n                for (int y = yStart;\n                    y <= maxYThisRow;\n                    y += toSlice.ySampling)\n                {\n\n                    toPtr = reinterpret_cast<char*> (toBase+\n                            divp (y, toSlice.ySampling) * toSlice.yStride +\n                            divp (xStart, toSlice.xSampling) * toSlice.xStride);\n\n                    //\n                    // Copy all pixels for the scanline in this row of tiles\n                    //\n\n                    switch ( toSlice.type)\n                    {\n                        case UINT:\n                        {\n                            unsigned int fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<unsigned int*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case HALF :\n                        {\n                            half fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<half*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case FLOAT :\n                        {\n                            float fill = toSlice.fillValue;\n                            for (int x = xStart;\n                                x <= levelRange.max.x;\n                                x += toSlice.xSampling)\n                            {\n                                * reinterpret_cast<float*>(toPtr) = fill;\n                                toPtr += toSlice.xStride;\n                            }\n                            break;\n                        }\n                        case NUM_PIXELTYPES :\n                        {\n                            break;\n                        }\n\n                    }\n                }\n            }\n        }\n    }\n}""}]","{""function"": 3, ""value"": 3, ""caller"": 2, ""code"": 3}","[{""source"": ""func_info(func:isNonImage)"", ""result"": [{""code"": ""inline bool  isNonImage(int version)    {return !!(version & NON_IMAGE_FLAG); }"", ""start_line"": 113, ""end_line"": 113, ""full_name"": ""Imf.isNonImage:bool(int)"", ""file_path"": ""OpenEXR/IlmImf/ImfVersion.h""}]}, {""source"": ""value_info(file:ImfDeepScanLineInputFile.cpp, value:_ifd)"", ""result"": {""value_trace"": [{""full_code"": ""_ifd"", ""line"": 604, ""func_name"": null}], ""struct_var"": ""_ifd"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""caller_info(file:ImfDeepScanLineInputFile.cpp, func:execute)"", ""result"": [{""call_line"": 270, ""call_code"": ""task->execute()"", ""caller_code"": ""void\nDefaultWorkerThread::run ()\n{\n    //\n    // Signal that the thread has started executing\n    //\n\n    _data->threadSemaphore.post();\n\n    while (true)\n    {\n        //\n        // Wait for a task to become available\n        //\n\n        _data->taskSemaphore.wait();\n\n        {\n            Lock taskLock (_data->taskMutex);\n    \n            //\n            // If there is a task pending, pop off the next task in the FIFO\n            //\n\n            if (!_data->tasks.empty())\n            {\n                Task* task = _data->tasks.back();\n                _data->tasks.pop_back();\n                taskLock.release();\n\n                TaskGroup* taskGroup = task->group();\n                task->execute();\n\n                delete task;\n\n                taskGroup->_data->removeTask ();\n            }\n            else if (_data->stopped())\n            {\n                break;\n            }\n        }\n    }\n}"", ""caller_start"": 239, ""file_path"": ""IlmBase/IlmThread/IlmThreadPool.cpp""}, {""call_line"": 400, ""call_code"": ""task->execute ()"", ""caller_code"": ""void\nDefaultThreadPoolProvider::addTask (Task *task)\n{\n    //\n    // Lock the threads, needed to access numThreads\n    //\n#ifdef ILMBASE_FORCE_CXX03\n    bool doPush;\n    {\n        Lock lock (_data.threadMutex);\n        doPush = !_data.threads.empty();\n    }\n#else\n    bool doPush = _data.hasThreads.load( std::memory_order_relaxed );\n#endif\n\n    if ( doPush )\n    {\n        //\n        // Get exclusive access to the tasks queue\n        //\n\n        {\n            Lock taskLock (_data.taskMutex);\n\n            //\n            // Push the new task into the FIFO\n            //\n            _data.tasks.push_back (task);\n        }\n        \n        //\n        // Signal that we have a new task to process\n        //\n        _data.taskSemaphore.post ();\n    }\n    else\n    {\n        // this path shouldn't normally happen since we have the\n        // NullThreadPoolProvider, but just in case...\n        task->execute ();\n        task->group()->_data->removeTask ();\n        delete task;\n    }\n}\n"", ""caller_start"": 360, ""file_path"": ""IlmBase/IlmThread/IlmThreadPool.cpp""}, {""call_line"": 458, ""call_code"": ""t->execute ()"", ""caller_code"": ""virtual void addTask (Task *t)\n    {\n        t->execute ();\n        t->group()->_data->removeTask ();\n        delete t;\n    }"", ""caller_start"": 456, ""file_path"": ""IlmBase/IlmThread/IlmThreadPool.cpp""}, {""call_line"": 2054, ""call_code"": ""encoder.execute()"", ""caller_code"": ""int \nDwaCompressor::compress\n    (const char             *inPtr,\n     int                    inSize,\n     IMATH_NAMESPACE::Box2i range,\n     const char             *&outPtr)\n{\n    const char *inDataPtr   = inPtr;\n    char       *packedAcEnd = 0;\n    char       *packedDcEnd = 0; \n    int         fileVersion = 2;   // Starting with 2, we write the channel\n                                   // classification rules into the file\n\n    if (fileVersion < 2) \n        initializeLegacyChannelRules();\n    else \n        initializeDefaultChannelRules();\n\n    size_t outBufferSize = 0;\n    initializeBuffers(outBufferSize);\n\n    unsigned short          channelRuleSize = 0;\n    std::vector<Classifier> channelRules;\n    if (fileVersion >= 2) \n    {\n        relevantChannelRules(channelRules);\n\n        channelRuleSize = Xdr::size<unsigned short>();\n        for (size_t i = 0; i < channelRules.size(); ++i) \n            channelRuleSize += channelRules[i].size();\n    }\n\n    //\n    // Remember to allocate _outBuffer, if we haven't done so already.\n    //\n\n    outBufferSize += channelRuleSize;\n    if (outBufferSize > _outBufferSize) \n    {\n        _outBufferSize = outBufferSize;\n        if (_outBuffer != 0)\n            delete[] _outBuffer;       \n        _outBuffer = new char[outBufferSize];\n    }\n\n    char *outDataPtr = &_outBuffer[NUM_SIZES_SINGLE * sizeof(OPENEXR_IMF_NAMESPACE::Int64) +\n                                   channelRuleSize];\n\n    //\n    // We might not be dealing with any color data, in which\n    // case the AC buffer size will be 0, and deferencing\n    // a vector will not be a good thing to do.\n    //\n\n    if (_packedAcBuffer)\n        packedAcEnd = _packedAcBuffer;\n\n    if (_packedDcBuffer)\n        packedDcEnd = _packedDcBuffer;\n\n    #define OBIDX(x) (Int64 *)&_outBuffer[x * sizeof (Int64)]\n\n    Int64 *version                 = OBIDX (VERSION);\n    Int64 *unknownUncompressedSize = OBIDX (UNKNOWN_UNCOMPRESSED_SIZE);\n    Int64 *unknownCompressedSize   = OBIDX (UNKNOWN_COMPRESSED_SIZE);\n    Int64 *acCompressedSize        = OBIDX (AC_COMPRESSED_SIZE);\n    Int64 *dcCompressedSize        = OBIDX (DC_COMPRESSED_SIZE);\n    Int64 *rleCompressedSize       = OBIDX (RLE_COMPRESSED_SIZE);\n    Int64 *rleUncompressedSize     = OBIDX (RLE_UNCOMPRESSED_SIZE);\n    Int64 *rleRawSize              = OBIDX (RLE_RAW_SIZE);\n\n    Int64 *totalAcUncompressedCount = OBIDX (AC_UNCOMPRESSED_COUNT);\n    Int64 *totalDcUncompressedCount = OBIDX (DC_UNCOMPRESSED_COUNT);\n\n    Int64 *acCompression            = OBIDX (AC_COMPRESSION);\n\n    int minX   = range.min.x;\n    int maxX   = std::min(range.max.x, _max[0]);\n    int minY   = range.min.y;\n    int maxY   = std::min(range.max.y, _max[1]);\n\n    //\n    // Zero all the numbers in the chunk header\n    //\n\n    memset (_outBuffer, 0, NUM_SIZES_SINGLE * sizeof (Int64));\n\n    //\n    // Setup the AC compression strategy and the version in the data block,\n    // then write the relevant channel classification rules if needed\n    //\n    *version       = fileVersion;  \n    *acCompression = _acCompression;\n\n    setupChannelData (minX, minY, maxX, maxY);\n\n    if (fileVersion >= 2) \n    {\n        char *writePtr = &_outBuffer[NUM_SIZES_SINGLE * sizeof(OPENEXR_IMF_NAMESPACE::Int64)];\n        Xdr::write<CharPtrIO> (writePtr, channelRuleSize);\n        \n        for (size_t i = 0; i < channelRules.size(); ++i) \n            channelRules[i].write(writePtr);\n    }\n\n    //\n    // Determine the start of each row in the input buffer\n    // Channels are interleaved by scanline\n    //\n\n    std::vector<bool> encodedChannels (_channelData.size());\n    std::vector< std::vector<const char *> > rowPtrs (_channelData.size());\n\n    for (unsigned int chan = 0; chan < _channelData.size(); ++chan)\n        encodedChannels[chan] = false;\n\n    inDataPtr =  inPtr;\n\n    for (int y = minY; y <= maxY; ++y)\n    {\n        for (unsigned int chan = 0; chan < _channelData.size(); ++chan)\n        {\n\n            ChannelData *cd = &_channelData[chan];\n\n            if (IMATH_NAMESPACE::modp(y, cd->ySampling) != 0)\n                continue;\n\n            rowPtrs[chan].push_back(inDataPtr);\n            inDataPtr += cd->width * OPENEXR_IMF_NAMESPACE::pixelTypeSize(cd->type);\n        }\n    }\n\n    inDataPtr = inPtr;\n\n    // \n    // Make a pass over all our CSC sets and try to encode them first\n    // \n\n    for (unsigned int csc = 0; csc < _cscSets.size(); ++csc)\n    {\n\n        LossyDctEncoderCsc encoder\n            (_dwaCompressionLevel / 100000.f,\n             rowPtrs[_cscSets[csc].idx[0]],\n             rowPtrs[_cscSets[csc].idx[1]],\n             rowPtrs[_cscSets[csc].idx[2]],\n             packedAcEnd,\n             packedDcEnd,\n             dwaCompressorToNonlinear,\n             _channelData[_cscSets[csc].idx[0]].width,\n             _channelData[_cscSets[csc].idx[0]].height,\n             _channelData[_cscSets[csc].idx[0]].type,\n             _channelData[_cscSets[csc].idx[1]].type,\n             _channelData[_cscSets[csc].idx[2]].type);\n\n        encoder.execute();\n\n        *totalAcUncompressedCount  += encoder.numAcValuesEncoded();\n        *totalDcUncompressedCount  += encoder.numDcValuesEncoded();\n\n        packedAcEnd += encoder.numAcValuesEncoded() * sizeof(unsigned short);\n        packedDcEnd += encoder.numDcValuesEncoded() * sizeof(unsigned short);\n\n        encodedChannels[_cscSets[csc].idx[0]] = true;\n        encodedChannels[_cscSets[csc].idx[1]] = true;\n        encodedChannels[_cscSets[csc].idx[2]] = true;\n    }\n\n    for (unsigned int chan = 0; chan < _channelData.size(); ++chan)\n    {\n        ChannelData *cd = &_channelData[chan];\n\n        if (encodedChannels[chan])\n            continue;\n\n        switch (cd->compression)\n        {\n          case LOSSY_DCT:\n\n            //\n            // For LOSSY_DCT, treat this just like the CSC'd case,\n            // but only operate on one channel\n            //\n\n            {\n                const unsigned short *nonlinearLut = 0;\n\n                if (!cd->pLinear)\n                    nonlinearLut = dwaCompressorToNonlinear; \n\n                LossyDctEncoder encoder\n                    (_dwaCompressionLevel / 100000.f,\n                     rowPtrs[chan],\n                     packedAcEnd,\n                     packedDcEnd,\n                     nonlinearLut,\n                     cd->width,\n                     cd->height,\n                     cd->type);\n\n                encoder.execute();\n\n                *totalAcUncompressedCount  += encoder.numAcValuesEncoded();\n                *totalDcUncompressedCount  += encoder.numDcValuesEncoded();\n\n                packedAcEnd +=\n                    encoder.numAcValuesEncoded() * sizeof (unsigned short);\n\n                packedDcEnd +=\n                    encoder.numDcValuesEncoded() * sizeof (unsigned short);\n            }\n\n            break;\n\n          case RLE:\n\n            //\n            // For RLE, bash the bytes up so that the first bytes of each\n            // pixel are contingous, as are the second bytes, and so on.\n            //\n\n            for (unsigned int y = 0; y < rowPtrs[chan].size(); ++y)\n            {\n                const char *row = rowPtrs[chan][y];\n\n                for (int x = 0; x < cd->width; ++x)\n                {\n                    for (int byte = 0;\n                         byte < OPENEXR_IMF_NAMESPACE::pixelTypeSize (cd->type);\n                         ++byte)\n                    {\n                            \n                        *cd->planarUncRleEnd[byte]++ = *row++;\n                    }\n                }\n\n                *rleRawSize += cd->width * OPENEXR_IMF_NAMESPACE::pixelTypeSize(cd->type);\n            }\n\n            break;\n\n          case UNKNOWN:\n           \n            //\n            // Otherwise, just copy data over verbatim\n            //\n\n            {\n                int scanlineSize = cd->width * OPENEXR_IMF_NAMESPACE::pixelTypeSize(cd->type);\n\n                for (unsigned int y = 0; y < rowPtrs[chan].size(); ++y)\n                {\n                    memcpy (cd->planarUncBufferEnd,\n                            rowPtrs[chan][y],\n                            scanlineSize);\n    \n                    cd->planarUncBufferEnd += scanlineSize;\n                }\n\n                *unknownUncompressedSize += cd->planarUncSize;\n            }\n\n            break;\n\n          default:\n\n            assert (false);\n        }\n\n        encodedChannels[chan] = true;\n    }\n\n    //\n    // Pack the Unknown data into the output buffer first. Instead of\n    // just copying it uncompressed, try zlib compression at least.\n    //\n\n    if (*unknownUncompressedSize > 0)\n    {\n        uLongf inSize  = (uLongf)(*unknownUncompressedSize);\n        uLongf outSize = compressBound (inSize);\n\n        if (Z_OK != ::compress2 ((Bytef *)outDataPtr,\n                                 &outSize,\n                                 (const Bytef *)_planarUncBuffer[UNKNOWN],\n                                 inSize,\n                                 9))\n        {\n            throw IEX_NAMESPACE::BaseExc (\""Data compression (zlib) failed.\"");\n        }\n\n        outDataPtr += outSize;\n        *unknownCompressedSize = outSize;\n    }\n\n    //\n    // Now, pack all the Lossy DCT coefficients into our output\n    // buffer, with Huffman encoding.\n    //\n    // Also, record the compressed size and the number of \n    // uncompressed componentns we have.\n    //\n\n    if (*totalAcUncompressedCount > 0)\n    { \n        switch (_acCompression)\n        {\n          case STATIC_HUFFMAN:\n\n            *acCompressedSize = (int)\n                hufCompress((unsigned short *)_packedAcBuffer,\n                            (int)*totalAcUncompressedCount,\n                            outDataPtr);                \n            break;\n\n          case DEFLATE:\n\n            {\n                uLongf destLen = compressBound (\n                    (*totalAcUncompressedCount) * sizeof (unsigned short));\n\n                if (Z_OK != ::compress2\n                                ((Bytef *)outDataPtr,\n                                 &destLen,\n                                 (Bytef *)_packedAcBuffer, \n                                 (uLong)(*totalAcUncompressedCount\n                                                * sizeof (unsigned short)),\n                                 9))\n                {\n                    throw IEX_NAMESPACE::InputExc (\""Data compression (zlib) failed.\"");\n                }\n\n                *acCompressedSize = destLen;        \n            }\n\n            break;\n\n          default:\n            \n            assert (false);\n        }\n\n        outDataPtr += *acCompressedSize;\n    }\n\n    // \n    // Handle the DC components separately\n    //\n\n    if (*totalDcUncompressedCount > 0)\n    {\n        *dcCompressedSize = _zip->compress\n            (_packedDcBuffer,\n             (int)(*totalDcUncompressedCount) * sizeof (unsigned short),\n             outDataPtr);\n\n        outDataPtr += *dcCompressedSize;\n    }\n\n    // \n    // If we have RLE data, first RLE encode it and set the uncompressed\n    // size. Then, deflate the results and set the compressed size.\n    //    \n\n    if (*rleRawSize > 0)\n    {\n        *rleUncompressedSize = rleCompress\n            ((int)(*rleRawSize),\n             _planarUncBuffer[RLE],\n             (signed char *)_rleBuffer);\n\n        uLongf dstLen = compressBound ((uLongf)*rleUncompressedSize);\n\n        if (Z_OK != ::compress2\n                        ((Bytef *)outDataPtr, \n                         &dstLen, \n                         (Bytef *)_rleBuffer, \n                         (uLong)(*rleUncompressedSize),\n                         9))\n        {\n            throw IEX_NAMESPACE::BaseExc (\""Error compressing RLE'd data.\"");\n        }\n        \n       *rleCompressedSize = dstLen;\n        outDataPtr       += *rleCompressedSize;\n    }\n\n    // \n    // Flip the counters to XDR format\n    //         \n\n    for (int i = 0; i < NUM_SIZES_SINGLE; ++i)\n    {\n        Int64  src = *(((Int64 *)_outBuffer) + i);\n        char  *dst = (char *)(((Int64 *)_outBuffer) + i);\n\n        Xdr::write<CharPtrIO> (dst, src);\n    }\n\n    //\n    // We're done - compute the number of bytes we packed\n    //\n\n    outPtr = _outBuffer;\n\n    return static_cast<int>(outDataPtr - _outBuffer + 1);\n}\n"", ""caller_start"": 1898, ""file_path"": ""OpenEXR/IlmImf/ImfDwaCompressor.cpp""}]}, {""source"": ""value_info(file:ImfDeepScanLineInputFile.cpp, value:_ifd)"", ""result"": {""value_trace"": [{""full_code"": ""_ifd"", ""line"": 604, ""func_name"": null}, {""full_code"": ""_ifd"", ""line"": 526, ""func_name"": null}, {""full_code"": ""_ifd"", ""line"": 537, ""func_name"": null}, {""full_code"": ""_ifd"", ""line"": 521, ""func_name"": null}], ""struct_var"": ""_ifd"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""func_info(func:initialize)"", ""result"": [{""code"": ""void DeepScanLineInputFile::initialize(const Header& header)\n{\n    try\n    {\n        if (header.type() != DEEPSCANLINE)\n            throw IEX_NAMESPACE::ArgExc(\""Can't build a DeepScanLineInputFile from \""\n            \""a type-mismatched part.\"");\n        \n        if(header.version()!=1)\n        {\n            THROW(IEX_NAMESPACE::ArgExc, \""Version \"" << header.version() << \"" not supported for deepscanline images in this version of the library\"");\n        }\n        \n        _data->header = header;\n\n        _data->lineOrder = _data->header.lineOrder();\n\n        const Box2i &dataWindow = _data->header.dataWindow();\n\n        _data->minX = dataWindow.min.x;\n        _data->maxX = dataWindow.max.x;\n        _data->minY = dataWindow.min.y;\n        _data->maxY = dataWindow.max.y;\n\n        _data->sampleCount.resizeErase(_data->maxY - _data->minY + 1,\n                                       _data->maxX - _data->minX + 1);\n        _data->lineSampleCount.resizeErase(_data->maxY - _data->minY + 1);\n\n        Compressor* compressor = newCompressor(_data->header.compression(),\n                                               0,\n                                               _data->header);\n\n        _data->linesInBuffer = numLinesInBuffer (compressor);\n\n        delete compressor;\n\n        _data->nextLineBufferMinY = _data->minY - 1;\n\n        int lineOffsetSize = (dataWindow.max.y - dataWindow.min.y +\n                              _data->linesInBuffer) / _data->linesInBuffer;\n\n        _data->lineOffsets.resize (lineOffsetSize);\n\n        for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n            _data->lineBuffers[i] = new LineBuffer ();\n\n        _data->gotSampleCount.resizeErase(_data->maxY - _data->minY + 1);\n        for (int i = 0; i < _data->maxY - _data->minY + 1; i++)\n            _data->gotSampleCount[i] = false;\n\n        _data->maxSampleCountTableSize = min(_data->linesInBuffer, _data->maxY - _data->minY + 1) *\n                                        (_data->maxX - _data->minX + 1) *\n                                        sizeof(unsigned int);\n\n        _data->sampleCountTableBuffer.resizeErase(_data->maxSampleCountTableSize);\n\n        _data->sampleCountTableComp = newCompressor(_data->header.compression(),\n                                                    _data->maxSampleCountTableSize,\n                                                    _data->header);\n\n        _data->bytesPerLine.resize (_data->maxY - _data->minY + 1);\n        \n        const ChannelList & c=header.channels();\n        \n        _data->combinedSampleSize=0;\n        for(ChannelList::ConstIterator i=c.begin();i!=c.end();i++)\n        {\n            switch(i.channel().type)\n            {\n                case OPENEXR_IMF_INTERNAL_NAMESPACE::HALF  :\n                    _data->combinedSampleSize+=Xdr::size<half>();\n                    break;\n                case OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT :\n                    _data->combinedSampleSize+=Xdr::size<float>();\n                    break;\n                case OPENEXR_IMF_INTERNAL_NAMESPACE::UINT  :\n                    _data->combinedSampleSize+=Xdr::size<unsigned int>();\n                    break;\n                default :\n                    THROW(IEX_NAMESPACE::ArgExc, \""Bad type for channel \"" << i.name() << \"" initializing deepscanline reader\"");\n                    \n            }\n        }\n        \n    }\n    catch (...)\n    {\n        // Don't delete _data here, leave that to caller\n        throw;\n    }\n}\n"", ""start_line"": 835, ""end_line"": 925, ""full_name"": ""DeepScanLineInputFile.initialize:void(Header&)"", ""file_path"": ""OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp""}, {""code"": ""void\nDeepScanLineOutputFile::initialize (const Header &header)\n{\n    _data->header = header;\n\n    _data->header.setType(DEEPSCANLINE);\n    \n    const Box2i &dataWindow = header.dataWindow();\n\n    _data->currentScanLine = (header.lineOrder() == INCREASING_Y)?\n                                 dataWindow.min.y: dataWindow.max.y;\n\n    _data->missingScanLines = dataWindow.max.y - dataWindow.min.y + 1;\n    _data->lineOrder = header.lineOrder();\n    _data->minX = dataWindow.min.x;\n    _data->maxX = dataWindow.max.x;\n    _data->minY = dataWindow.min.y;\n    _data->maxY = dataWindow.max.y;\n\n    _data->lineSampleCount.resizeErase(_data->maxY - _data->minY + 1);\n\n    Compressor* compressor = newCompressor (_data->header.compression(),\n                                            0,\n                                            _data->header);\n    _data->format = defaultFormat (compressor);\n    _data->linesInBuffer = numLinesInBuffer (compressor);\n    if (compressor != 0)\n        delete compressor;\n\n    int lineOffsetSize = (_data->maxY - _data->minY +\n                          _data->linesInBuffer) / _data->linesInBuffer;\n\n\n    _data->header.setChunkCount(lineOffsetSize);\n\n    _data->lineOffsets.resize (lineOffsetSize);\n\n    _data->bytesPerLine.resize (_data->maxY - _data->minY + 1);\n\n    _data->maxSampleCountTableSize = min(_data->linesInBuffer, _data->maxY - _data->minY + 1) *\n                                     (_data->maxX - _data->minX + 1) *\n                                     sizeof(unsigned int);\n\n    for (size_t i = 0; i < _data->lineBuffers.size(); ++i)\n    {\n        _data->lineBuffers[i] = new LineBuffer (_data->linesInBuffer);\n        _data->lineBuffers[i]->sampleCountTableBuffer.resizeErase(_data->maxSampleCountTableSize);\n\n        _data->lineBuffers[i]->sampleCountTableCompressor =\n        newCompressor (_data->header.compression(),\n                               _data->maxSampleCountTableSize,\n                               _data->header);\n    }\n}\n"", ""start_line"": 933, ""end_line"": 986, ""full_name"": ""DeepScanLineOutputFile.initialize:void(Header&)"", ""file_path"": ""OpenEXR/IlmImf/ImfDeepScanLineOutputFile.cpp""}, {""code"": ""void\nDeepTiledInputFile::initialize ()\n{\n    if (_data->partNumber == -1)\n        if (_data->header.type() != DEEPTILE)\n            throw IEX_NAMESPACE::ArgExc (\""Expected a deep tiled file but the file is not deep tiled.\"");\n   if(_data->header.version()!=1)\n   {\n       THROW(IEX_NAMESPACE::ArgExc, \""Version \"" << _data->header.version() << \"" not supported for deeptiled images in this version of the library\"");\n   }\n        \n    _data->header.sanityCheck (true);\n\n    _data->tileDesc = _data->header.tileDescription();\n    _data->lineOrder = _data->header.lineOrder();\n\n    //\n    // Save the dataWindow information\n    //\n\n    const Box2i &dataWindow = _data->header.dataWindow();\n    _data->minX = dataWindow.min.x;\n    _data->maxX = dataWindow.max.x;\n    _data->minY = dataWindow.min.y;\n    _data->maxY = dataWindow.max.y;\n\n    //\n    // Precompute level and tile information to speed up utility functions\n    //\n\n    precalculateTileInfo (_data->tileDesc,\n                          _data->minX, _data->maxX,\n                          _data->minY, _data->maxY,\n                          _data->numXTiles, _data->numYTiles,\n                          _data->numXLevels, _data->numYLevels);\n\n    //\n    // Create all the TileBuffers and allocate their internal buffers\n    //\n\n    _data->tileOffsets = TileOffsets (_data->tileDesc.mode,\n                                      _data->numXLevels,\n                                      _data->numYLevels,\n                                      _data->numXTiles,\n                                      _data->numYTiles);\n\n    for (size_t i = 0; i < _data->tileBuffers.size(); i++)\n        _data->tileBuffers[i] = new TileBuffer ();\n\n    _data->maxSampleCountTableSize = _data->tileDesc.ySize *\n                                     _data->tileDesc.xSize *\n                                     sizeof(int);\n\n    _data->sampleCountTableBuffer.resizeErase(_data->maxSampleCountTableSize);\n\n    _data->sampleCountTableComp = newCompressor(_data->header.compression(),\n                                                _data->maxSampleCountTableSize,\n                                                _data->header);\n                                                \n                                                \n    const ChannelList & c=_data->header.channels();\n    _data->combinedSampleSize=0;\n    for(ChannelList::ConstIterator i=c.begin();i!=c.end();i++)\n    {\n        switch( i.channel().type )\n        {\n            case OPENEXR_IMF_INTERNAL_NAMESPACE::HALF  :\n                _data->combinedSampleSize+=Xdr::size<half>();\n                break;\n            case OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT :\n                _data->combinedSampleSize+=Xdr::size<float>();\n                break;\n            case OPENEXR_IMF_INTERNAL_NAMESPACE::UINT  :\n                _data->combinedSampleSize+=Xdr::size<unsigned int>();\n                break;\n            default :\n                THROW(IEX_NAMESPACE::ArgExc, \""Bad type for channel \"" << i.name() << \"" initializing deepscanline reader\"");\n        }\n    }\n                                                  \n}\n"", ""start_line"": 944, ""end_line"": 1024, ""full_name"": ""DeepTiledInputFile.initialize:void()"", ""file_path"": ""OpenEXR/IlmImf/ImfDeepTiledInputFile.cpp""}]}, {""source"": ""caller_info(file:ImfTiledInputFile.cpp, func:initialize)"", ""result"": [{""call_line"": 940, ""call_code"": ""initialize(part->header)"", ""caller_code"": ""DeepScanLineInputFile::DeepScanLineInputFile(InputPartData* part)\n    \n{\n\n    _data = new Data(part->numThreads);\n    _data->_deleteStream=false;\n    _data->_streamData = part->mutex;\n    _data->memoryMapped = _data->_streamData->is->isMemoryMapped();\n    _data->version = part->version;\n\n    try\n    {\n       initialize(part->header);\n    }\n    catch(...)\n    {\n        delete _data;\n        throw;\n    }\n    _data->lineOffsets = part->chunkOffsets;\n\n    _data->partNumber = part->partNumber;\n}\n"", ""caller_start"": 928, ""file_path"": ""OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp""}, {""call_line"": 995, ""call_code"": ""initialize(_data->header)"", ""caller_code"": ""DeepScanLineInputFile::DeepScanLineInputFile\n    (const char fileName[], int numThreads)\n:\n     _data (new Data (numThreads))\n{\n    _data->_deleteStream = true;\n    OPENEXR_IMF_INTERNAL_NAMESPACE::IStream* is = 0;\n\n    try\n    {\n        is = new StdIFStream (fileName);\n        readMagicNumberAndVersionField(*is, _data->version);\n        //\n        // Backward compatibility to read multpart file.\n        // multiPartInitialize will create _streamData\n        if (isMultiPart(_data->version))\n        {\n            compatibilityInitialize(*is);\n            return;\n        }\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        if (is)          delete is;\n        if (_data)       delete _data;\n\n        REPLACE_EXC (e, \""Cannot read image file \""\n                     \""\\\""\"" << fileName << \""\\\"". \"" << e.what());\n        throw;\n    }\n\n    // \n    // not multiPart - allocate stream data and intialise as normal\n    //\n    try\n    { \n        _data->_streamData = new InputStreamMutex();\n        _data->_streamData->is = is;\n        _data->memoryMapped = is->isMemoryMapped();\n        _data->header.readFrom (*_data->_streamData->is, _data->version);\n        _data->header.sanityCheck (isTiled (_data->version));\n\n        initialize(_data->header);\n\n        readLineOffsets (*_data->_streamData->is,\n                         _data->lineOrder,\n                         _data->lineOffsets,\n                         _data->fileIsComplete);\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        if (is)          delete is;\n        if (_data && _data->_streamData)\n        {\n            delete _data->_streamData;\n        }\n        if (_data)       delete _data;\n\n        REPLACE_EXC (e, \""Cannot read image file \""\n                     \""\\\""\"" << fileName << \""\\\"". \"" << e.what());\n        throw;\n    }\n    catch (...)\n    {\n        if (is)          delete is;\n        if (_data && _data->_streamData)\n        {\n            delete _data->_streamData;\n        }\n        if (_data)       delete _data;\n\n        throw;\n    }\n}\n"", ""caller_start"": 953, ""file_path"": ""OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp""}, {""call_line"": 1047, ""call_code"": ""initialize (header)"", ""caller_code"": ""DeepScanLineInputFile::DeepScanLineInputFile\n    (const Header &header,\n     OPENEXR_IMF_INTERNAL_NAMESPACE::IStream *is,\n     int version,\n     int numThreads)\n:\n    _data (new Data (numThreads))\n{\n    _data->_streamData=new InputStreamMutex();\n    _data->_deleteStream=false;\n    _data->_streamData->is = is;\n    \n    _data->memoryMapped = is->isMemoryMapped();\n\n    _data->version =version;\n    \n    try\n    {\n        initialize (header);\n    }\n    catch (...)\n    {\n        if (_data && _data->_streamData)\n        {\n            delete _data->_streamData;\n        }\n        if (_data)       delete _data;\n\n        throw;\n   }\n\n    readLineOffsets (*_data->_streamData->is,\n                     _data->lineOrder,\n                     _data->lineOffsets,\n                     _data->fileIsComplete);\n}\n"", ""caller_start"": 1029, ""file_path"": ""OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp""}, {""call_line"": 1120, ""call_code"": ""initialize(part->header)"", ""caller_code"": ""void DeepScanLineInputFile::multiPartInitialize(InputPartData* part)\n{\n    \n    _data->_streamData = part->mutex;\n    _data->memoryMapped = _data->_streamData->is->isMemoryMapped();\n    _data->version = part->version;\n    \n    initialize(part->header);\n    \n    _data->lineOffsets = part->chunkOffsets;\n    \n    _data->partNumber = part->partNumber;\n    \n}"", ""caller_start"": 1113, ""file_path"": ""OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp""}]}, {""source"": ""value_info(value:dataWindow)"", ""result"": {""value_trace"": [{""full_code"": ""dataWindow = Imath.Box2i( Imath::V2i( 0, 0 ),\n                             Imath::V2i( outWidth-1, outHeight-1 ) )"", ""line"": 179, ""func_name"": ""PxDeep.ConvertDtexFile:void(std.string&,std.string&,PxDeep.Parameters&)""}, {""full_code"": ""&dataWindow = hdr.dataWindow()"", ""line"": 538, ""func_name"": ""Imf.B44Compressor.B44Compressor:ANY(Imf.Header&,size_t,size_t,bool)""}, {""full_code"": ""&dataWindow = _data->header.dataWindow()"", ""line"": 852, ""func_name"": ""DeepScanLineInputFile.initialize:void(Header&)""}, {""full_code"": ""&dataWindow = header.dataWindow()"", ""line"": 940, ""func_name"": ""DeepScanLineOutputFile.initialize:void(Header&)""}, {""full_code"": ""&dataWindow = hdr.dataWindow()"", ""line"": 1479, ""func_name"": ""DeepScanLineOutputFile.copyPixels:void(DeepScanLineInputFile&)""}], ""struct_var"": ""dataWindow"", ""struct_type"": ""Imath.Box2i"", ""struct_definition"": null}}, {""source"": ""code_info(file:ImfHeader.cpp, lines:1-200)"", ""result"": ""///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2004, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \""AS IS\"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n\n\n//-----------------------------------------------------------------------------\n//\n//\tclass Header\n//\n//-----------------------------------------------------------------------------\n\n#include <ImfHeader.h>\n#include <ImfStdIO.h>\n#include <ImfVersion.h>\n#include <ImfCompressor.h>\n#include <ImfMisc.h>\n#include <ImfBoxAttribute.h>\n#include <ImfChannelListAttribute.h>\n#include <ImfChromaticitiesAttribute.h>\n#include <ImfCompressionAttribute.h>\n#include <ImfDeepImageStateAttribute.h>\n#include <ImfDoubleAttribute.h>\n#include <ImfDwaCompressor.h>\n#include <ImfEnvmapAttribute.h>\n#include <ImfFloatAttribute.h>\n#include <ImfFloatVectorAttribute.h>\n#include <ImfIntAttribute.h>\n#include <ImfKeyCodeAttribute.h>\n#include <ImfLineOrderAttribute.h>\n#include <ImfMatrixAttribute.h>\n#include <ImfOpaqueAttribute.h>\n#include <ImfPreviewImageAttribute.h>\n#include <ImfRationalAttribute.h>\n#include <ImfStringAttribute.h>\n#include <ImfStringVectorAttribute.h>\n#include <ImfTileDescriptionAttribute.h>\n#include <ImfTimeCodeAttribute.h>\n#include <ImfVecAttribute.h>\n#include <ImfPartType.h>\n#include \""IlmThreadMutex.h\""\n#include \""Iex.h\""\n#include <sstream>\n#include <stdlib.h>\n#include <time.h>\n#include <cmath>\n#include \""ImfTiledMisc.h\""\n#include \""ImfNamespace.h\""\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\nusing namespace std;\nusing IMATH_NAMESPACE::Box2i;\nusing IMATH_NAMESPACE::V2i;\nusing IMATH_NAMESPACE::V2f;\nusing ILMTHREAD_NAMESPACE::Mutex;\nusing ILMTHREAD_NAMESPACE::Lock;\n\n\nnamespace {\n\nint maxImageWidth = 0;\nint maxImageHeight = 0;\nint maxTileWidth = 0;\nint maxTileHeight = 0;\n\n\nvoid\ninitialize (Header &header,\n\t    const Box2i &displayWindow,\n\t    const Box2i &dataWindow,\n\t    float pixelAspectRatio,\n\t    const V2f &screenWindowCenter,\n\t    float screenWindowWidth,\n\t    LineOrder lineOrder,\n\t    Compression compression)\n{\n    header.insert (\""displayWindow\"", Box2iAttribute (displayWindow));\n    header.insert (\""dataWindow\"", Box2iAttribute (dataWindow));\n    if ( !std::isnormal (pixelAspectRatio) || pixelAspectRatio < 0.f)\n        THROW (IEX_NAMESPACE::ArgExc, \""Invalid pixel aspect ratio\"");\n    header.insert (\""pixelAspectRatio\"", FloatAttribute (pixelAspectRatio));\n    header.insert (\""screenWindowCenter\"", V2fAttribute (screenWindowCenter));\n    header.insert (\""screenWindowWidth\"", FloatAttribute (screenWindowWidth));\n    header.insert (\""lineOrder\"", LineOrderAttribute (lineOrder));\n    header.insert (\""compression\"", CompressionAttribute (compression));\n    header.insert (\""channels\"", ChannelListAttribute ());\n}\n\ntemplate <size_t N>\nvoid checkIsNullTerminated (const char (&str)[N], const char *what)\n{\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tif (str[i] == '\\0')\n\t\t\treturn;\n\t}\n\tstd::stringstream s;\n\ts << \""Invalid \"" << what << \"": it is more than \"" << (N - 1) \n\t\t<< \"" characters long.\"";\n\tthrow IEX_NAMESPACE::InputExc(s);\n}\n\nvoid\nsanityCheckDisplayWindow (int width, int height)\n{\n    //\n    // Ensure a valid displayWindow.  All values for which width-1 < 0\n    // are invalid, but in particular, note that if width=-INT_MAX,\n    // width-1 will overflow.\n    //\n    \n    if (width < 1 || height < 1)\n\tthrow IEX_NAMESPACE::ArgExc (\""Invalid display window in image header.\"");\n}\n\n} // namespace\n\n\nHeader::Header (int width,\n\t\tint height,\n\t\tfloat pixelAspectRatio,\n\t\tconst V2f &screenWindowCenter,\n\t\tfloat screenWindowWidth,\n\t\tLineOrder lineOrder,\n\t\tCompression compression)\n:\n    _map()\n{\n    sanityCheckDisplayWindow (width, height);\n\n    staticInitialize();\n\n    Box2i displayWindow (V2i (0, 0), V2i (width - 1, height - 1));\n\n    initialize (*this,\n\t\tdisplayWindow,\n\t\tdisplayWindow,\n\t\tpixelAspectRatio,\n\t\tscreenWindowCenter,\n\t\tscreenWindowWidth,\n\t\tlineOrder,\n\t\tcompression);\n}\n\n\nHeader::Header (int width,\n\t\tint height,\n\t\tconst Box2i &dataWindow,\n\t\tfloat pixelAspectRatio,\n\t\tconst V2f &screenWindowCenter,\n\t\tfloat screenWindowWidth,\n\t\tLineOrder lineOrder,\n\t\tCompression compression)\n:\n    _map()\n{\n    sanityCheckDisplayWindow (width, height);\n\n    staticInitialize();\n\n    Box2i displayWindow (V2i (0, 0), V2i (width - 1, height - 1));\n\n    initialize (*this,\n\t\tdisplayWindow,\n\t\tdataWindow,\n\t\tpixelAspectRatio,\n\t\tscreenWindowCenter,\n\t\tscreenWindowWidth,\n\t\tlineOrder,\n\t\tcompression);\n""}, {""source"": ""code_info(file:ImfHeader.cpp, lines:1-200)"", ""result"": ""///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2004, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \""AS IS\"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n\n\n//-----------------------------------------------------------------------------\n//\n//\tclass Header\n//\n//-----------------------------------------------------------------------------\n\n#include <ImfHeader.h>\n#include <ImfStdIO.h>\n#include <ImfVersion.h>\n#include <ImfCompressor.h>\n#include <ImfMisc.h>\n#include <ImfBoxAttribute.h>\n#include <ImfChannelListAttribute.h>\n#include <ImfChromaticitiesAttribute.h>\n#include <ImfCompressionAttribute.h>\n#include <ImfDeepImageStateAttribute.h>\n#include <ImfDoubleAttribute.h>\n#include <ImfDwaCompressor.h>\n#include <ImfEnvmapAttribute.h>\n#include <ImfFloatAttribute.h>\n#include <ImfFloatVectorAttribute.h>\n#include <ImfIntAttribute.h>\n#include <ImfKeyCodeAttribute.h>\n#include <ImfLineOrderAttribute.h>\n#include <ImfMatrixAttribute.h>\n#include <ImfOpaqueAttribute.h>\n#include <ImfPreviewImageAttribute.h>\n#include <ImfRationalAttribute.h>\n#include <ImfStringAttribute.h>\n#include <ImfStringVectorAttribute.h>\n#include <ImfTileDescriptionAttribute.h>\n#include <ImfTimeCodeAttribute.h>\n#include <ImfVecAttribute.h>\n#include <ImfPartType.h>\n#include \""IlmThreadMutex.h\""\n#include \""Iex.h\""\n#include <sstream>\n#include <stdlib.h>\n#include <time.h>\n#include <cmath>\n#include \""ImfTiledMisc.h\""\n#include \""ImfNamespace.h\""\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\nusing namespace std;\nusing IMATH_NAMESPACE::Box2i;\nusing IMATH_NAMESPACE::V2i;\nusing IMATH_NAMESPACE::V2f;\nusing ILMTHREAD_NAMESPACE::Mutex;\nusing ILMTHREAD_NAMESPACE::Lock;\n\n\nnamespace {\n\nint maxImageWidth = 0;\nint maxImageHeight = 0;\nint maxTileWidth = 0;\nint maxTileHeight = 0;\n\n\nvoid\ninitialize (Header &header,\n\t    const Box2i &displayWindow,\n\t    const Box2i &dataWindow,\n\t    float pixelAspectRatio,\n\t    const V2f &screenWindowCenter,\n\t    float screenWindowWidth,\n\t    LineOrder lineOrder,\n\t    Compression compression)\n{\n    header.insert (\""displayWindow\"", Box2iAttribute (displayWindow));\n    header.insert (\""dataWindow\"", Box2iAttribute (dataWindow));\n    if ( !std::isnormal (pixelAspectRatio) || pixelAspectRatio < 0.f)\n        THROW (IEX_NAMESPACE::ArgExc, \""Invalid pixel aspect ratio\"");\n    header.insert (\""pixelAspectRatio\"", FloatAttribute (pixelAspectRatio));\n    header.insert (\""screenWindowCenter\"", V2fAttribute (screenWindowCenter));\n    header.insert (\""screenWindowWidth\"", FloatAttribute (screenWindowWidth));\n    header.insert (\""lineOrder\"", LineOrderAttribute (lineOrder));\n    header.insert (\""compression\"", CompressionAttribute (compression));\n    header.insert (\""channels\"", ChannelListAttribute ());\n}\n\ntemplate <size_t N>\nvoid checkIsNullTerminated (const char (&str)[N], const char *what)\n{\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tif (str[i] == '\\0')\n\t\t\treturn;\n\t}\n\tstd::stringstream s;\n\ts << \""Invalid \"" << what << \"": it is more than \"" << (N - 1) \n\t\t<< \"" characters long.\"";\n\tthrow IEX_NAMESPACE::InputExc(s);\n}\n\nvoid\nsanityCheckDisplayWindow (int width, int height)\n{\n    //\n    // Ensure a valid displayWindow.  All values for which width-1 < 0\n    // are invalid, but in particular, note that if width=-INT_MAX,\n    // width-1 will overflow.\n    //\n    \n    if (width < 1 || height < 1)\n\tthrow IEX_NAMESPACE::ArgExc (\""Invalid display window in image header.\"");\n}\n\n} // namespace\n\n\nHeader::Header (int width,\n\t\tint height,\n\t\tfloat pixelAspectRatio,\n\t\tconst V2f &screenWindowCenter,\n\t\tfloat screenWindowWidth,\n\t\tLineOrder lineOrder,\n\t\tCompression compression)\n:\n    _map()\n{\n    sanityCheckDisplayWindow (width, height);\n\n    staticInitialize();\n\n    Box2i displayWindow (V2i (0, 0), V2i (width - 1, height - 1));\n\n    initialize (*this,\n\t\tdisplayWindow,\n\t\tdisplayWindow,\n\t\tpixelAspectRatio,\n\t\tscreenWindowCenter,\n\t\tscreenWindowWidth,\n\t\tlineOrder,\n\t\tcompression);\n}\n\n\nHeader::Header (int width,\n\t\tint height,\n\t\tconst Box2i &dataWindow,\n\t\tfloat pixelAspectRatio,\n\t\tconst V2f &screenWindowCenter,\n\t\tfloat screenWindowWidth,\n\t\tLineOrder lineOrder,\n\t\tCompression compression)\n:\n    _map()\n{\n    sanityCheckDisplayWindow (width, height);\n\n    staticInitialize();\n\n    Box2i displayWindow (V2i (0, 0), V2i (width - 1, height - 1));\n\n    initialize (*this,\n\t\tdisplayWindow,\n\t\tdataWindow,\n\t\tpixelAspectRatio,\n\t\tscreenWindowCenter,\n\t\tscreenWindowWidth,\n\t\tlineOrder,\n\t\tcompression);\n""}, {""source"": ""func_info(func:readFrom)"", ""result"": [{""code"": ""void\nHeader::readFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &is, int &version)\n{\n    //\n    // Read all attributes.\n    //\n\n    int attrCount = 0;\n\n    while (true)\n    {\n\t//\n\t// Read the name of the attribute.\n\t// A zero-length attribute name indicates the end of the header.\n\t//\n\n\tchar name[Name::SIZE];\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, name);\n\n\tif (name[0] == 0)\n\t{\n\t    if (attrCount == 0) _readsNothing = true;\n\t    else                _readsNothing = false;\n\t    break;\n\t}\n\n\tattrCount++;\n\n\tcheckIsNullTerminated (name, \""attribute name\"");\n\n\t//\n\t// Read the attribute type and the size of the attribute value.\n\t//\n\n\tchar typeName[Name::SIZE];\n\tint size;\n\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, typeName);\n\tcheckIsNullTerminated (typeName, \""attribute type name\"");\n\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, size);\n\n    if( size < 0 )\n    {\n        throw IEX_NAMESPACE::InputExc(\""Invalid size field in header attribute\"");\n    }\n\n\tAttributeMap::iterator i = _map.find (name);\n\n\tif (i != _map.end())\n\t{\n\t    //\n\t    // The attribute already exists (for example,\n\t    // because it is a predefined attribute).\n\t    // Read the attribute's new value from the file.\n\t    //\n\n\t    if (strncmp (i->second->typeName(), typeName, sizeof (typeName)))\n\t\tTHROW (IEX_NAMESPACE::InputExc, \""Unexpected type for image attribute \""\n\t\t\t\t      \""\\\""\"" << name << \""\\\"".\"");\n\n\t    i->second->readValueFrom (is, size, version);\n\t}\n\telse\n\t{\n\t    //\n\t    // The new attribute does not exist yet.\n\t    // If the attribute type is of a known type,\n\t    // read the attribute value.  If the attribute\n\t    // is of an unknown type, read its value and\n\t    // store it as an OpaqueAttribute.\n\t    //\n\n\t    Attribute *attr;\n\n\t    if (Attribute::knownType (typeName))\n\t\tattr = Attribute::newAttribute (typeName);\n\t    else\n\t\tattr = new OpaqueAttribute (typeName);\n\n\t    try\n\t    {\n\t\tattr->readValueFrom (is, size, version);\n\t\t_map[name] = attr;\n\t    }\n\t    catch (...)\n\t    {\n\t\tdelete attr;\n\t\tthrow;\n\t    }\n\t}\n    }\n}\n"", ""start_line"": 1174, ""end_line"": 1265, ""full_name"": ""Imf.Header.readFrom:void(Imf.IStream&,int&)"", ""file_path"": ""OpenEXR/IlmImf/ImfHeader.cpp""}, {""code"": ""void\nTileOffsets::readFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &is, bool &complete,bool isMultiPartFile, bool isDeep)\n{\n    //\n    // Read in the tile offsets from the file's tile offset table\n    //\n\n    for (unsigned int l = 0; l < _offsets.size(); ++l)\n\tfor (unsigned int dy = 0; dy < _offsets[l].size(); ++dy)\n\t    for (unsigned int dx = 0; dx < _offsets[l][dy].size(); ++dx)\n\t\tOPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, _offsets[l][dy][dx]);\n\n    //\n    // Check if any tile offsets are invalid.\n    //\n    // Invalid offsets mean that the file is probably incomplete\n    // (the offset table is the last thing written to the file).\n    // Either some process is still busy writing the file, or\n    // writing the file was aborted.\n    //\n    // We should still be able to read the existing parts of the\n    // file.  In order to do this, we have to make a sequential\n    // scan over the scan tile to reconstruct the tile offset\n    // table.\n    //\n\n    if (anyOffsetsAreInvalid())\n    {\n\tcomplete = false;\n\treconstructFromFile (is,isMultiPartFile,isDeep);\n    }\n    else\n    {\n\tcomplete = true;\n    }\n\n}\n"", ""start_line"": 204, ""end_line"": 240, ""full_name"": ""TileOffsets.readFrom:void(Imf.IStream&,bool&,bool,bool)"", ""file_path"": ""OpenEXR/IlmImf/ImfTileOffsets.cpp""}, {""code"": ""void\nTileOffsets::readFrom (std::vector<Int64> chunkOffsets,bool &complete)\n{\n    size_t totalSize = 0;\n \n    for (unsigned int l = 0; l < _offsets.size(); ++l)\n        for (unsigned int dy = 0; dy < _offsets[l].size(); ++dy)\n            totalSize += _offsets[l][dy].size();\n\n    if (chunkOffsets.size() != totalSize)\n        throw IEX_NAMESPACE::ArgExc (\""Wrong offset count, not able to read from this array\"");\n\n\n\n    int pos = 0;\n    for (size_t l = 0; l < _offsets.size(); ++l)\n        for (size_t dy = 0; dy < _offsets[l].size(); ++dy)\n            for (size_t dx = 0; dx < _offsets[l][dy].size(); ++dx)\n            {\n                _offsets[l][dy][dx] = chunkOffsets[pos];\n                pos++;\n            }\n\n    complete = !anyOffsetsAreInvalid();\n\n}"", ""start_line"": 243, ""end_line"": 268, ""full_name"": ""TileOffsets.readFrom:void(std.vector,bool&)"", ""file_path"": ""OpenEXR/IlmImf/ImfTileOffsets.cpp""}]}, {""source"": ""code_info(file:ImfBoxAttribute.cpp, lines:1-200)"", ""result"": ""///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2004, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \""AS IS\"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n\n\n//-----------------------------------------------------------------------------\n//\n//\tclass Box2iAttribute\n//\tclass Box2fAttribute\n//\n//-----------------------------------------------------------------------------\n\n#include <ImfBoxAttribute.h>\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\nusing namespace OPENEXR_IMF_INTERNAL_NAMESPACE;\n\ntemplate <>\nconst char *\nBox2iAttribute::staticTypeName ()\n{\n    return \""box2i\"";\n}\n\n\ntemplate <>\nvoid\nBox2iAttribute::writeValueTo (OPENEXR_IMF_INTERNAL_NAMESPACE::OStream &os, int version) const\n{\n    Xdr::write <StreamIO> (os, _value.min.x);\n    Xdr::write <StreamIO> (os, _value.min.y);\n    Xdr::write <StreamIO> (os, _value.max.x);\n    Xdr::write <StreamIO> (os, _value.max.y);\n}\n\n\ntemplate <>\nvoid\nBox2iAttribute::readValueFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &is, int size, int version)\n{\n    Xdr::read <StreamIO> (is, _value.min.x);\n    Xdr::read <StreamIO> (is, _value.min.y);\n    Xdr::read <StreamIO> (is, _value.max.x);\n    Xdr::read <StreamIO> (is, _value.max.y);\n}\n\n\ntemplate <>\nconst char *\nBox2fAttribute::staticTypeName ()\n{\n    return \""box2f\"";\n}\n\n\ntemplate <>\nvoid\nBox2fAttribute::writeValueTo (OPENEXR_IMF_INTERNAL_NAMESPACE::OStream &os, int version) const\n{\n    Xdr::write <StreamIO> (os, _value.min.x);\n    Xdr::write <StreamIO> (os, _value.min.y);\n    Xdr::write <StreamIO> (os, _value.max.x);\n    Xdr::write <StreamIO> (os, _value.max.y);\n}\n\n\ntemplate <>\nvoid\nBox2fAttribute::readValueFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &is, int size, int version)\n{\n    Xdr::read <StreamIO> (is, _value.min.x);\n    Xdr::read <StreamIO> (is, _value.min.y);\n    Xdr::read <StreamIO> (is, _value.max.x);\n    Xdr::read <StreamIO> (is, _value.max.y);\n}\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT \n""}]","1. `TiledInputFile::initialize` (ImfTiledInputFile.cpp:852-855) previously lacked a check for non-image files (via `isNonImage`), allowing crafted non-image data to propagate. 2. `_ifd.minX`/`_ifd.minY` in `DeepScanLineInputFile::initialize` (ImfDeepScanLineInputFile.cpp:852) are initialized from `dataWindow` parsed via `Header::dataWindow()`, which derives from unvalidated file headers. 3. `LineBufferTask::execute` (ImfDeepScanLineInputFile.cpp:541-544) uses unsafe pointer arithmetic (`&_ifd->sampleCount[0][0] - minX - minY * width`), which underflows if `minX`/`minY` are negative (allowed in `Box2iAttribute::readValueFrom` (ImfBoxAttribute.cpp:52-55) without validation). The patch adds bounds checks and safer arithmetic.",0.95,./github/other_context/CVE-2021-20302
91,CVE-2021-32651,CWE-90,java,"OneDev is a development operations platform. If the LDAP external authentication mechanism is enabled in OneDev versions 4.4.1 and prior, an attacker can manipulate a user search filter to send forged queries to the application and explore the LDAP tree using Blind LDAP Injection techniques. The specific payload depends on how the User Search Filter property is configured in OneDev. This issue was fixed in version 4.4.2.",https://github.com/theonedev/onedev/commit/4440f0c57e440488d7e653417b2547eaae8ad19c,Fix issue #304 - Potential information leak via Ldap injection when ldap\nauthenticator is enabled,1,"[{""func_name"": ""authenticate"", ""file_path"": ""server-plugin/server-plugin-authenticator-ldap/src/main/java/io/onedev/server/plugin/authenticator/ldap/LdapAuthenticator.java"", ""func_code"": ""@Override\n\tpublic Authenticated authenticate(UsernamePasswordToken token) {\n\t\tString fullName = null;\n\t\tString email = null;\n\t\tCollection<String> groupNames = null;\n        Collection<String> sshKeys = null;\n\n        Name userSearchBase;\n\t\ttry {\n\t\t\tuserSearchBase = new CompositeName().add(getUserSearchBase());\n\t\t} catch (InvalidNameException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n        String userSearchFilter = StringUtils.replace(getUserSearchFilter(), \""{0}\"", token.getUsername());\n        userSearchFilter = StringUtils.replace(userSearchFilter, \""\\\\\"", \""\\\\\\\\\"");\n        logger.debug(\""Evaluated user search filter: \"" + userSearchFilter);\n        \n        SearchControls searchControls = new SearchControls();\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        List<String> attributeNames = new ArrayList<String>();\n        if (getUserFullNameAttribute() != null)\n            attributeNames.add(getUserFullNameAttribute());\n        \n        if (getUserSshKeyAttribute() != null)\n        \tattributeNames.add(getUserSshKeyAttribute());\n        \n        attributeNames.add(getUserEmailAttribute());\n        \n        if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) {\n        \tGetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute)getGroupRetrieval();\n            attributeNames.add(groupRetrieval.getUserGroupsAttribute());\n        }\n        searchControls.setReturningAttributes((String[]) attributeNames.toArray(new String[0]));\n        searchControls.setReturningObjFlag(true);\n\n        Hashtable<String, String> ldapEnv = new Hashtable<>();\n        ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, \""com.sun.jndi.ldap.LdapCtxFactory\"");\n        ldapEnv.put(Context.PROVIDER_URL, getLdapUrl());\n        ldapEnv.put(Context.SECURITY_AUTHENTICATION, \""simple\"");\n        ldapEnv.put(\""com.sun.jndi.ldap.connect.timeout\"", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(\""com.sun.jndi.ldap.read.timeout\"", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(Context.REFERRAL, \""follow\"");\n        \n        ldapEnv.put(Context.SECURITY_PRINCIPAL, getManagerDN());\n        ldapEnv.put(Context.SECURITY_CREDENTIALS, getManagerPassword());\n\n        DirContext ctx = null;\n        DirContext referralCtx = null;\n        try {\n            logger.debug(\""Binding to ldap url '\"" + getLdapUrl() + \""'...\"");\n            try {\n            \tctx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n        \t\tthrow new RuntimeException(\""Can not bind to ldap server '\"" + getLdapUrl() + \""': \"" + e.getMessage());\n            }\n            NamingEnumeration<SearchResult> results = ctx.search(userSearchBase, userSearchFilter, searchControls);\n            if (results == null || !results.hasMore()) \n                throw new UnknownAccountException(\""Unknown account\"");\n            \n            SearchResult searchResult = (SearchResult) results.next();\n            String userDN = searchResult.getNameInNamespace();\n            if (!searchResult.isRelative()) {\n            \tStringBuffer buffer = new StringBuffer();\n                buffer.append(StringUtils.substringBefore(searchResult.getName(), \""//\""));\n                buffer.append(\""//\"");\n                buffer.append(StringUtils.substringBefore(\n                \t\tStringUtils.substringAfter(searchResult.getName(), \""//\""), \""/\""));\n                \n                ldapEnv.put(Context.PROVIDER_URL, buffer.toString());\n                logger.debug(\""Binding to referral ldap url '\"" + buffer.toString() + \""'...\"");\n                referralCtx = new InitialDirContext(ldapEnv);\n            }\n            if (userDN.startsWith(\""ldap\"")) {\n            \tuserDN = StringUtils.substringAfter(userDN, \""//\"");\n            \tuserDN = StringUtils.substringAfter(userDN, \""/\"");\n            }\n\n            ldapEnv.put(Context.SECURITY_PRINCIPAL, userDN);\n            ldapEnv.put(Context.SECURITY_CREDENTIALS, new String(token.getPassword()));\n            DirContext userCtx = null;\n            try {\n                logger.debug(\""Authenticating user by binding as '\"" + userDN + \""'...\"");\n                userCtx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n            \tthrow new org.apache.shiro.authc.AuthenticationException(\""Unable to bind as '\"" + userDN + \""'\"", e);\n            } finally {\n                if (userCtx != null) {\n                    try {\n                        userCtx.close();\n                    } catch (NamingException e) {\n                    }\n                }\n            }\n\n            Attributes searchResultAttributes = searchResult.getAttributes();\n            \n            if (searchResultAttributes != null) {\n                if (getUserFullNameAttribute() != null) {\n                    Attribute attribute = searchResultAttributes.get(getUserFullNameAttribute());\n                    if (attribute != null && attribute.get() != null)\n                        fullName = (String) attribute.get();\n                }\n                \n                Attribute attribute = searchResultAttributes.get(getUserEmailAttribute());\n                if (attribute != null && attribute.get() != null)\n                    email = (String) attribute.get();\n                \n                if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) \n                \tgroupNames = retrieveGroupsByAttribute(ctx, referralCtx, searchResultAttributes);\n                \n                if (getUserSshKeyAttribute() != null) \n                \tsshKeys = retrieveSshKeys(searchResultAttributes);\n            }\n            \n            if (getGroupRetrieval() instanceof SearchGroupsUsingFilter) \n            \tgroupNames = retrieveGroupsByFilter(ctx, referralCtx, userDN);\n            \n            if (StringUtils.isBlank(email))\n            \tthrow new AccountException(\""Email is required but not available in ldap directory\"");\n            else\n            \treturn new Authenticated(email, fullName, groupNames, sshKeys);\n        } catch (NamingException e) {\n        \tthrow new RuntimeException(e);\n        } finally {\n            if (ctx != null) {\n                try {\n                    ctx.close();\n                } catch (NamingException e) {\n                }\n            }\n            if (referralCtx != null) {\n                try {\n                    referralCtx.close();\n                } catch (NamingException e) {\n                }\n            }\n        }\n\t}"", ""target"": 0}]","[{""func_name"": ""authenticate"", ""file_path"": ""server-plugin/server-plugin-authenticator-ldap/src/main/java/io/onedev/server/plugin/authenticator/ldap/LdapAuthenticator.java"", ""func_code"": ""@Override\n\tpublic Authenticated authenticate(UsernamePasswordToken token) {\n\t\tString fullName = null;\n\t\tString email = null;\n\t\tCollection<String> groupNames = null;\n        Collection<String> sshKeys = null;\n\n        Name userSearchBase;\n\t\ttry {\n\t\t\tuserSearchBase = new CompositeName().add(getUserSearchBase());\n\t\t} catch (InvalidNameException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n        String userSearchFilter = StringUtils.replace(getUserSearchFilter(), \""{0}\"", \n        \t\tescape(token.getUsername()));\n        userSearchFilter = StringUtils.replace(userSearchFilter, \""\\\\\"", \""\\\\\\\\\"");\n        logger.debug(\""Evaluated user search filter: \"" + userSearchFilter);\n        \n        SearchControls searchControls = new SearchControls();\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        List<String> attributeNames = new ArrayList<String>();\n        if (getUserFullNameAttribute() != null)\n            attributeNames.add(getUserFullNameAttribute());\n        \n        if (getUserSshKeyAttribute() != null)\n        \tattributeNames.add(getUserSshKeyAttribute());\n        \n        attributeNames.add(getUserEmailAttribute());\n        \n        if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) {\n        \tGetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute)getGroupRetrieval();\n            attributeNames.add(groupRetrieval.getUserGroupsAttribute());\n        }\n        searchControls.setReturningAttributes((String[]) attributeNames.toArray(new String[0]));\n        searchControls.setReturningObjFlag(true);\n\n        Hashtable<String, String> ldapEnv = new Hashtable<>();\n        ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, \""com.sun.jndi.ldap.LdapCtxFactory\"");\n        ldapEnv.put(Context.PROVIDER_URL, getLdapUrl());\n        ldapEnv.put(Context.SECURITY_AUTHENTICATION, \""simple\"");\n        ldapEnv.put(\""com.sun.jndi.ldap.connect.timeout\"", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(\""com.sun.jndi.ldap.read.timeout\"", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(Context.REFERRAL, \""follow\"");\n        \n        ldapEnv.put(Context.SECURITY_PRINCIPAL, getManagerDN());\n        ldapEnv.put(Context.SECURITY_CREDENTIALS, getManagerPassword());\n\n        DirContext ctx = null;\n        DirContext referralCtx = null;\n        try {\n            logger.debug(\""Binding to ldap url '\"" + getLdapUrl() + \""'...\"");\n            try {\n            \tctx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n        \t\tthrow new RuntimeException(\""Can not bind to ldap server '\"" + getLdapUrl() + \""': \"" + e.getMessage());\n            }\n            NamingEnumeration<SearchResult> results = ctx.search(userSearchBase, userSearchFilter, searchControls);\n            if (results == null || !results.hasMore()) \n                throw new UnknownAccountException(\""Unknown account\"");\n            \n            SearchResult searchResult = (SearchResult) results.next();\n            String userDN = searchResult.getNameInNamespace();\n            if (!searchResult.isRelative()) {\n            \tStringBuffer buffer = new StringBuffer();\n                buffer.append(StringUtils.substringBefore(searchResult.getName(), \""//\""));\n                buffer.append(\""//\"");\n                buffer.append(StringUtils.substringBefore(\n                \t\tStringUtils.substringAfter(searchResult.getName(), \""//\""), \""/\""));\n                \n                ldapEnv.put(Context.PROVIDER_URL, buffer.toString());\n                logger.debug(\""Binding to referral ldap url '\"" + buffer.toString() + \""'...\"");\n                referralCtx = new InitialDirContext(ldapEnv);\n            }\n            if (userDN.startsWith(\""ldap\"")) {\n            \tuserDN = StringUtils.substringAfter(userDN, \""//\"");\n            \tuserDN = StringUtils.substringAfter(userDN, \""/\"");\n            }\n\n            ldapEnv.put(Context.SECURITY_PRINCIPAL, userDN);\n            ldapEnv.put(Context.SECURITY_CREDENTIALS, new String(token.getPassword()));\n            DirContext userCtx = null;\n            try {\n                logger.debug(\""Authenticating user by binding as '\"" + userDN + \""'...\"");\n                userCtx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n            \tthrow new org.apache.shiro.authc.AuthenticationException(\""Unable to bind as '\"" + userDN + \""'\"", e);\n            } finally {\n                if (userCtx != null) {\n                    try {\n                        userCtx.close();\n                    } catch (NamingException e) {\n                    }\n                }\n            }\n\n            Attributes searchResultAttributes = searchResult.getAttributes();\n            \n            if (searchResultAttributes != null) {\n                if (getUserFullNameAttribute() != null) {\n                    Attribute attribute = searchResultAttributes.get(getUserFullNameAttribute());\n                    if (attribute != null && attribute.get() != null)\n                        fullName = (String) attribute.get();\n                }\n                \n                Attribute attribute = searchResultAttributes.get(getUserEmailAttribute());\n                if (attribute != null && attribute.get() != null)\n                    email = (String) attribute.get();\n                \n                if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) \n                \tgroupNames = retrieveGroupsByAttribute(ctx, referralCtx, searchResultAttributes);\n                \n                if (getUserSshKeyAttribute() != null) \n                \tsshKeys = retrieveSshKeys(searchResultAttributes);\n            }\n            \n            if (getGroupRetrieval() instanceof SearchGroupsUsingFilter) \n            \tgroupNames = retrieveGroupsByFilter(ctx, referralCtx, userDN);\n            \n            if (StringUtils.isBlank(email))\n            \tthrow new AccountException(\""Email is required but not available in ldap directory\"");\n            else\n            \treturn new Authenticated(email, fullName, groupNames, sshKeys);\n        } catch (NamingException e) {\n        \tthrow new RuntimeException(e);\n        } finally {\n            if (ctx != null) {\n                try {\n                    ctx.close();\n                } catch (NamingException e) {\n                }\n            }\n            if (referralCtx != null) {\n                try {\n                    referralCtx.close();\n                } catch (NamingException e) {\n                }\n            }\n        }\n\t}""}]","{""function"": 1}","[{""source"": ""func_info(func:escape)"", ""result"": [{""code"": ""\tpublic static String escape(String string) {\n\t\tString escaped = JavaEscape.escapeJava(string);\n\t\t// escape $ character since it has special meaning in groovy string\n\t\tescaped = escaped.replace(\""$\"", \""\\\\$\"");\n\n\t\treturn escaped;\n\t}\n"", ""start_line"": 108, ""end_line"": 114, ""full_name"": ""io.onedev.server.model.support.inputspec.InputSpec.escape:java.lang.String(java.lang.String)"", ""file_path"": ""server-core/src/main/java/io/onedev/server/model/support/inputspec/InputSpec.java""}, {""code"": ""\t@Override\n\tpublic String escape(String markdown) {\n\t\tmarkdown = StringEscapeUtils.escapeHtml4(markdown);\n\t\tmarkdown = StringUtils.replace(markdown, \""\\n\"", \""<br>\"");\n\t\treturn markdown;\n\t}\n"", ""start_line"": 77, ""end_line"": 82, ""full_name"": ""io.onedev.server.util.markdown.DefaultMarkdownManager.escape:java.lang.String(java.lang.String)"", ""file_path"": ""server-core/src/main/java/io/onedev/server/util/markdown/DefaultMarkdownManager.java""}, {""code"": ""\tString escape(String markdown);\n"", ""start_line"": 35, ""end_line"": 35, ""full_name"": ""io.onedev.server.util.markdown.MarkdownManager.escape:java.lang.String(java.lang.String)"", ""file_path"": ""server-core/src/main/java/io/onedev/server/util/markdown/MarkdownManager.java""}]}]","LdapAuthenticator.java:66-68: Username (`token.getUsername()`) was directly inserted into the LDAP search filter template without escaping special characters. The patch added `escape(token.getUsername())` (calling `InputSpec.escape()` at lines 108-114 in `InputSpec.java`), which applies Java-style string escaping and replaces `$` with `$$$`. Subsequent replacement of backslashes (`\\` → `\\\\`) ensures LDAP filter compatibility. The original lack of escaping enabled LDAP injection; the fix mitigates this via input sanitization.",0.95,./github/other_context/CVE-2021-32651
92,CVE-2021-32792,CWE-79,c_cpp,"mod_auth_openidc is an authentication/authorization module for the Apache 2.x HTTP server that functions as an OpenID Connect Relying Party, authenticating users against an OpenID Connect Provider. In mod_auth_openidc before version 2.4.9, there is an XSS vulnerability in when using `OIDCPreservePost On`.",https://github.com/OpenIDC/mod_auth_openidc/commit/55ea0a085290cd2c8cdfdd960a230cbc38ba8b56,Add a function to escape Javascript characters,4,"[{""func_name"": ""oidc_post_preserve_javascript"", ""file_path"": ""src/mod_auth_openidc.c"", ""func_code"": ""apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \""enter\"");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \""something went wrong when reading the POST parameters\"");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \""\"";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \""%s'%s': '%s'%s\"", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \"",\"" : \""\"");\n\t}\n\tjson = apr_psprintf(r->pool, \""{ %s }\"", json);\n\n\tconst char *jmethod = \""preserveOnLoad\"";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\""    <script type=\\\""text/javascript\\\"">\\n\""\n\t\t\t\t\t\""      function %s() {\\n\""\n\t\t\t\t\t\""        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\""\n\t\t\t\t\t\""        %s\""\n\t\t\t\t\t\""      }\\n\""\n\t\t\t\t\t\""    </script>\\n\"", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \""window.location='%s';\\n\"",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\""\"");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \""Preserving...\"", jscript, jmethod,\n\t\t\t\t\""<p>Preserving...</p>\"", OK);\n\t}\n\n\treturn TRUE;\n}"", ""target"": 0}, {""func_name"": ""oidc_session_redirect_parent_window_to_logout"", ""file_path"": ""src/mod_auth_openidc.c"", ""func_code"": ""static int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\n\toidc_debug(r, \""enter\"");\n\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\""    <script type=\\\""text/javascript\\\"">\\n\""\n\t\t\t\""      window.top.location.href = '%s?session=logout';\\n\""\n\t\t\t\""    </script>\\n\"", oidc_get_redirect_uri(r, c));\n\n\treturn oidc_util_html_send(r, \""Redirecting...\"", java_script, NULL, NULL,\n\t\t\tOK);\n}"", ""target"": 0}, {""func_name"": ""oidc_request_post_preserved_restore"", ""file_path"": ""src/mod_auth_openidc.c"", ""func_code"": ""static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \""enter: original_url=%s\"", original_url);\n\n\tconst char *method = \""postOnLoad\"";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\""    <script type=\\\""text/javascript\\\"">\\n\""\n\t\t\t\t\t\""      function str_decode(string) {\\n\""\n\t\t\t\t\t\""        try {\\n\""\n\t\t\t\t\t\""          result = decodeURIComponent(string);\\n\""\n\t\t\t\t\t\""        } catch (e) {\\n\""\n\t\t\t\t\t\""          result =  unescape(string);\\n\""\n\t\t\t\t\t\""        }\\n\""\n\t\t\t\t\t\""        return result;\\n\""\n\t\t\t\t\t\""      }\\n\""\n\t\t\t\t\t\""      function %s() {\\n\""\n\t\t\t\t\t\""        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\""\n\t\t\t\t\t\""\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\""\n\t\t\t\t\t\""        for (var key in mod_auth_openidc_preserve_post_params) {\\n\""\n\t\t\t\t\t\""          var input = document.createElement(\\\""input\\\"");\\n\""\n\t\t\t\t\t\""          input.name = str_decode(key);\\n\""\n\t\t\t\t\t\""          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\""\n\t\t\t\t\t\""          input.type = \\\""hidden\\\"";\\n\""\n\t\t\t\t\t\""          document.forms[0].appendChild(input);\\n\""\n\t\t\t\t\t\""        }\\n\""\n\t\t\t\t\t\""        document.forms[0].action = \\\""%s\\\"";\\n\""\n\t\t\t\t\t\""        document.forms[0].submit();\\n\""\n\t\t\t\t\t\""      }\\n\""\n\t\t\t\t\t\""    </script>\\n\"", method, original_url);\n\n\tconst char *body = \""    <p>Restoring...</p>\\n\""\n\t\t\t\""    <form method=\\\""post\\\""></form>\\n\"";\n\n\treturn oidc_util_html_send(r, \""Restoring...\"", script, method, body,\n\t\t\tOK);\n}"", ""target"": 0}, {""func_name"": ""oidc_request_post_preserved_restore"", ""file_path"": ""src/mod_auth_openidc.c"", ""func_code"": ""static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \""enter: original_url=%s\"", original_url);\n\n\tconst char *method = \""postOnLoad\"";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\""    <script type=\\\""text/javascript\\\"">\\n\""\n\t\t\t\t\t\""      function str_decode(string) {\\n\""\n\t\t\t\t\t\""        try {\\n\""\n\t\t\t\t\t\""          result = decodeURIComponent(string);\\n\""\n\t\t\t\t\t\""        } catch (e) {\\n\""\n\t\t\t\t\t\""          result =  unescape(string);\\n\""\n\t\t\t\t\t\""        }\\n\""\n\t\t\t\t\t\""        return result;\\n\""\n\t\t\t\t\t\""      }\\n\""\n\t\t\t\t\t\""      function %s() {\\n\""\n\t\t\t\t\t\""        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\""\n\t\t\t\t\t\""\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\""\n\t\t\t\t\t\""        for (var key in mod_auth_openidc_preserve_post_params) {\\n\""\n\t\t\t\t\t\""          var input = document.createElement(\\\""input\\\"");\\n\""\n\t\t\t\t\t\""          input.name = str_decode(key);\\n\""\n\t\t\t\t\t\""          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\""\n\t\t\t\t\t\""          input.type = \\\""hidden\\\"";\\n\""\n\t\t\t\t\t\""          document.forms[0].appendChild(input);\\n\""\n\t\t\t\t\t\""        }\\n\""\n\t\t\t\t\t\""        document.forms[0].action = '%s';\\n\""\n\t\t\t\t\t\""        document.forms[0].submit();\\n\""\n\t\t\t\t\t\""      }\\n\""\n\t\t\t\t\t\""    </script>\\n\"", method, original_url);\n\n\tconst char *body = \""    <p>Restoring...</p>\\n\""\n\t\t\t\""    <form method=\\\""post\\\""></form>\\n\"";\n\n\treturn oidc_util_html_send(r, \""Restoring...\"", script, method, body,\n\t\t\tOK);\n}"", ""target"": 0}]","[{""func_name"": ""oidc_post_preserve_javascript"", ""file_path"": ""src/mod_auth_openidc.c"", ""func_code"": ""apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \""enter\"");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \""something went wrong when reading the POST parameters\"");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \""\"";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \""%s'%s': '%s'%s\"", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \"",\"" : \""\"");\n\t}\n\tjson = apr_psprintf(r->pool, \""{ %s }\"", json);\n\n\tconst char *jmethod = \""preserveOnLoad\"";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\""    <script type=\\\""text/javascript\\\"">\\n\""\n\t\t\t\t\t\""      function %s() {\\n\""\n\t\t\t\t\t\""        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\""\n\t\t\t\t\t\""        %s\""\n\t\t\t\t\t\""      }\\n\""\n\t\t\t\t\t\""    </script>\\n\"", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \""window.location='%s';\\n\"",\n\t\t\t\t\t\t\t\t\toidc_util_javascript_escape(r->pool, location)) :\n\t\t\t\t\t\t\t\t\t\""\"");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \""Preserving...\"", jscript, jmethod,\n\t\t\t\t\""<p>Preserving...</p>\"", OK);\n\t}\n\n\treturn TRUE;\n}""}, {""func_name"": ""oidc_session_redirect_parent_window_to_logout"", ""file_path"": ""src/mod_auth_openidc.c"", ""func_code"": ""static int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\n\toidc_debug(r, \""enter\"");\n\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\""    <script type=\\\""text/javascript\\\"">\\n\""\n\t\t\t\""      window.top.location.href = '%s?session=logout';\\n\""\n\t\t\t\""    </script>\\n\"", oidc_util_javascript_escape(r->pool, oidc_get_redirect_uri(r, c)));\n\n\treturn oidc_util_html_send(r, \""Redirecting...\"", java_script, NULL, NULL,\n\t\t\tOK);\n}""}, {""func_name"": ""oidc_request_post_preserved_restore"", ""file_path"": ""src/mod_auth_openidc.c"", ""func_code"": ""static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \""enter: original_url=%s\"", original_url);\n\n\tconst char *method = \""postOnLoad\"";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\""    <script type=\\\""text/javascript\\\"">\\n\""\n\t\t\t\t\t\""      function str_decode(string) {\\n\""\n\t\t\t\t\t\""        try {\\n\""\n\t\t\t\t\t\""          result = decodeURIComponent(string);\\n\""\n\t\t\t\t\t\""        } catch (e) {\\n\""\n\t\t\t\t\t\""          result =  unescape(string);\\n\""\n\t\t\t\t\t\""        }\\n\""\n\t\t\t\t\t\""        return result;\\n\""\n\t\t\t\t\t\""      }\\n\""\n\t\t\t\t\t\""      function %s() {\\n\""\n\t\t\t\t\t\""        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\""\n\t\t\t\t\t\""\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\""\n\t\t\t\t\t\""        for (var key in mod_auth_openidc_preserve_post_params) {\\n\""\n\t\t\t\t\t\""          var input = document.createElement(\\\""input\\\"");\\n\""\n\t\t\t\t\t\""          input.name = str_decode(key);\\n\""\n\t\t\t\t\t\""          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\""\n\t\t\t\t\t\""          input.type = \\\""hidden\\\"";\\n\""\n\t\t\t\t\t\""          document.forms[0].appendChild(input);\\n\""\n\t\t\t\t\t\""        }\\n\""\n\t\t\t\t\t\""        document.forms[0].action = \\\""%s\\\"";\\n\""\n\t\t\t\t\t\""        document.forms[0].submit();\\n\""\n\t\t\t\t\t\""      }\\n\""\n\t\t\t\t\t\""    </script>\\n\"", method, oidc_util_javascript_escape(r->pool, original_url));\n\n\tconst char *body = \""    <p>Restoring...</p>\\n\""\n\t\t\t\""    <form method=\\\""post\\\""></form>\\n\"";\n\n\treturn oidc_util_html_send(r, \""Restoring...\"", script, method, body,\n\t\t\tOK);\n}""}, {""func_name"": ""oidc_request_post_preserved_restore"", ""file_path"": ""src/mod_auth_openidc.c"", ""func_code"": ""static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \""enter: original_url=%s\"", original_url);\n\n\tconst char *method = \""postOnLoad\"";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\""    <script type=\\\""text/javascript\\\"">\\n\""\n\t\t\t\t\t\""      function str_decode(string) {\\n\""\n\t\t\t\t\t\""        try {\\n\""\n\t\t\t\t\t\""          result = decodeURIComponent(string);\\n\""\n\t\t\t\t\t\""        } catch (e) {\\n\""\n\t\t\t\t\t\""          result =  unescape(string);\\n\""\n\t\t\t\t\t\""        }\\n\""\n\t\t\t\t\t\""        return result;\\n\""\n\t\t\t\t\t\""      }\\n\""\n\t\t\t\t\t\""      function %s() {\\n\""\n\t\t\t\t\t\""        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\""\n\t\t\t\t\t\""\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\""\n\t\t\t\t\t\""        for (var key in mod_auth_openidc_preserve_post_params) {\\n\""\n\t\t\t\t\t\""          var input = document.createElement(\\\""input\\\"");\\n\""\n\t\t\t\t\t\""          input.name = str_decode(key);\\n\""\n\t\t\t\t\t\""          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\""\n\t\t\t\t\t\""          input.type = \\\""hidden\\\"";\\n\""\n\t\t\t\t\t\""          document.forms[0].appendChild(input);\\n\""\n\t\t\t\t\t\""        }\\n\""\n\t\t\t\t\t\""        document.forms[0].action = \\\""%s\\\"";\\n\""\n\t\t\t\t\t\""        document.forms[0].submit();\\n\""\n\t\t\t\t\t\""      }\\n\""\n\t\t\t\t\t\""    </script>\\n\"", method, original_url);\n\n\tconst char *body = \""    <p>Restoring...</p>\\n\""\n\t\t\t\""    <form method=\\\""post\\\""></form>\\n\"";\n\n\treturn oidc_util_html_send(r, \""Restoring...\"", script, method, body,\n\t\t\tOK);\n}""}]","{""value"": 1, ""function"": 4, ""caller"": 1}","[{""source"": ""value_info(file:mod_auth_openidc.c, value:original_url)"", ""result"": {""value_trace"": [{""full_code"": ""*original_url = oidc_proto_state_get_original_url(proto_state)"", ""line"": 1958, ""func_name"": ""oidc_handle_authorization_response""}, {""full_code"": ""original_url = apr_pstrdup(r->pool, original_url)"", ""line"": 1960, ""func_name"": ""oidc_handle_authorization_response""}], ""struct_var"": ""original_url"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""func_info(func:oidc_proto_state_get_original_url)"", ""result"": [{""code"": ""const char* oidc_proto_state_get_original_url(oidc_proto_state_t *proto_state) {\n\treturn oidc_proto_state_get_string_value(proto_state,\n\t\t\tOIDC_PROTO_STATE_ORIGINAL_URL);\n}"", ""start_line"": 1010, ""end_line"": 1013, ""full_name"": ""oidc_proto_state_get_original_url"", ""file_path"": ""src/proto.c""}]}, {""source"": ""func_info(file:mod_auth_openidc.c, func:oidc_post_preserve_javascript)"", ""result"": [{""code"": ""apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \""enter\"");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \""something went wrong when reading the POST parameters\"");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \""\"";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \""%s'%s': '%s'%s\"", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \"",\"" : \""\"");\n\t}\n\tjson = apr_psprintf(r->pool, \""{ %s }\"", json);\n\n\tconst char *jmethod = \""preserveOnLoad\"";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\""    <script type=\\\""text/javascript\\\"">\\n\""\n\t\t\t\t\t\""      function %s() {\\n\""\n\t\t\t\t\t\""        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\""\n\t\t\t\t\t\""        %s\""\n\t\t\t\t\t\""      }\\n\""\n\t\t\t\t\t\""    </script>\\n\"", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \""window.location='%s';\\n\"",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\""\"");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \""Preserving...\"", jscript, jmethod,\n\t\t\t\t\""<p>Preserving...</p>\"", OK);\n\t}\n\n\treturn TRUE;\n}\n"", ""start_line"": 425, ""end_line"": 484, ""full_name"": ""oidc_post_preserve_javascript"", ""file_path"": ""src/mod_auth_openidc.c""}]}, {""source"": ""caller_info(file:mod_auth_openidc.c, func:oidc_post_preserve_javascript)"", ""result"": [{""call_line"": 2138, ""call_code"": ""oidc_post_preserve_javascript(r, url, NULL, NULL)"", ""caller_code"": ""static int oidc_discovery(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \""enter\"");\n\n\t/* obtain the URL we're currently accessing, to be stored in the state/session */\n\tchar *current_url = oidc_get_current_url(r);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\t/* generate CSRF token */\n\tchar *csrf = NULL;\n\tif (oidc_proto_generate_nonce(r, &csrf, 8) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *path_scopes = oidc_dir_cfg_path_scope(r);\n\tchar *path_auth_request_params = oidc_dir_cfg_path_auth_request_params(r);\n\n\tchar *discover_url = oidc_cfg_dir_discover_url(r);\n\t/* see if there's an external discovery page configured */\n\tif (discover_url != NULL) {\n\n\t\t/* yes, assemble the parameters for external discovery */\n\t\tchar *url = apr_psprintf(r->pool, \""%s%s%s=%s&%s=%s&%s=%s&%s=%s\"",\n\t\t\t\tdiscover_url,\n\t\t\t\tstrchr(discover_url, OIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\t\t\tOIDC_DISC_CB_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, oidc_get_redirect_uri(r, cfg)),\n\t\t\t\t\t\tOIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));\n\n\t\tif (path_scopes != NULL)\n\t\t\turl = apr_psprintf(r->pool, \""%s&%s=%s\"", url, OIDC_DISC_SC_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\turl = apr_psprintf(r->pool, \""%s&%s=%s\"", url, OIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\t/* log what we're about to do */\n\t\toidc_debug(r, \""redirecting to external discovery page: %s\"", url);\n\n\t\t/* set CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\t\tOIDC_COOKIE_SAMESITE_STRICT(cfg, r));\n\n\t\t/* see if we need to preserve POST parameters through Javascript/HTML5 storage */\n\t\tif (oidc_post_preserve_javascript(r, url, NULL, NULL) == TRUE)\n\t\t\treturn OK;\n\n\t\t/* do the actual redirect to an external discovery page */\n\t\toidc_util_hdr_out_location_set(r, url);\n\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\t}\n\n\t/* get a list of all providers configured in the metadata directory */\n\tapr_array_header_t *arr = NULL;\n\tif (oidc_metadata_list(r, cfg, &arr) == FALSE)\n\t\treturn oidc_util_html_send_error(r, cfg->error_template,\n\t\t\t\t\""Configuration Error\"",\n\t\t\t\t\""No configured providers found, contact your administrator\"",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\n\t/* assemble a where-are-you-from IDP discovery HTML page */\n\tconst char *s = \""\t\t\t<h3>Select your OpenID Connect Identity Provider</h3>\\n\"";\n\n\t/* list all configured providers in there */\n\tint i;\n\tfor (i = 0; i < arr->nelts; i++) {\n\n\t\tconst char *issuer = ((const char**) arr->elts)[i];\n\t\t// TODO: html escape (especially & character)\n\n\t\tchar *href = apr_psprintf(r->pool,\n\t\t\t\t\""%s?%s=%s&amp;%s=%s&amp;%s=%s&amp;%s=%s\"",\n\t\t\t\toidc_get_redirect_uri(r, cfg), OIDC_DISC_OP_PARAM,\n\t\t\t\toidc_util_escape_string(r, issuer),\n\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\tOIDC_CSRF_NAME, csrf);\n\n\t\tif (path_scopes != NULL)\n\t\t\thref = apr_psprintf(r->pool, \""%s&amp;%s=%s\"", href,\n\t\t\t\t\tOIDC_DISC_SC_PARAM, oidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\thref = apr_psprintf(r->pool, \""%s&amp;%s=%s\"", href,\n\t\t\t\t\tOIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\tchar *display =\n\t\t\t\t(strstr(issuer, \""https://\"") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\""https://\""));\n\n\t\t/* strip port number */\n\t\t//char *p = strstr(display, \"":\"");\n\t\t//if (p != NULL) *p = '\\0';\n\t\t/* point back to the redirect_uri, where the selection is handled, with an IDP selection and return_to URL */\n\t\ts = apr_psprintf(r->pool, \""%s<p><a href=\\\""%s\\\"">%s</a></p>\\n\"", s, href,\n\t\t\t\tdisplay);\n\t}\n\n\t/* add an option to enter an account or issuer name for dynamic OP discovery */\n\ts = apr_psprintf(r->pool, \""%s<form method=\\\""get\\\"" action=\\\""%s\\\"">\\n\"", s,\n\t\t\toidc_get_redirect_uri(r, cfg));\n\ts = apr_psprintf(r->pool,\n\t\t\t\""%s<p><input type=\\\""hidden\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""><p>\\n\"", s,\n\t\t\tOIDC_DISC_RT_PARAM, current_url);\n\ts = apr_psprintf(r->pool,\n\t\t\t\""%s<p><input type=\\\""hidden\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""><p>\\n\"", s,\n\t\t\tOIDC_DISC_RM_PARAM, method);\n\ts = apr_psprintf(r->pool,\n\t\t\t\""%s<p><input type=\\\""hidden\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""><p>\\n\"", s,\n\t\t\tOIDC_CSRF_NAME, csrf);\n\n\tif (path_scopes != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\""%s<p><input type=\\\""hidden\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""><p>\\n\"", s,\n\t\t\t\tOIDC_DISC_SC_PARAM, path_scopes);\n\tif (path_auth_request_params != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\""%s<p><input type=\\\""hidden\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""><p>\\n\"", s,\n\t\t\t\tOIDC_DISC_AR_PARAM, path_auth_request_params);\n\n\ts =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\""%s<p>Or enter your account name (eg. &quot;mike@seed.gluu.org&quot;, or an IDP identifier (eg. &quot;mitreid.org&quot;):</p>\\n\"",\n\t\t\t\t\ts);\n\ts = apr_psprintf(r->pool,\n\t\t\t\""%s<p><input type=\\\""text\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""></p>\\n\"", s,\n\t\t\tOIDC_DISC_OP_PARAM, \""\"");\n\ts = apr_psprintf(r->pool,\n\t\t\t\""%s<p><input type=\\\""submit\\\"" value=\\\""Submit\\\""></p>\\n\"", s);\n\ts = apr_psprintf(r->pool, \""%s</form>\\n\"", s);\n\n\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\tOIDC_COOKIE_SAMESITE_STRICT(cfg, r));\n\n\tchar *javascript = NULL, *javascript_method = NULL;\n\tchar *html_head =\n\t\t\t\""<style type=\\\""text/css\\\"">body {text-align: center}</style>\"";\n\tif (oidc_post_preserve_javascript(r, NULL, &javascript, &javascript_method)\n\t\t\t== TRUE)\n\t\thtml_head = apr_psprintf(r->pool, \""%s%s\"", html_head, javascript);\n\n\t/* now send the HTML contents to the user agent */\n\treturn oidc_util_html_send(r, \""OpenID Connect Provider Discovery\"",\n\t\t\thtml_head, javascript_method, s, OK);\n}\n"", ""caller_start"": 2091, ""file_path"": ""src/mod_auth_openidc.c""}, {""call_line"": 2233, ""call_code"": ""oidc_post_preserve_javascript(r, NULL, &javascript, &javascript_method)"", ""caller_code"": ""static int oidc_discovery(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \""enter\"");\n\n\t/* obtain the URL we're currently accessing, to be stored in the state/session */\n\tchar *current_url = oidc_get_current_url(r);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\t/* generate CSRF token */\n\tchar *csrf = NULL;\n\tif (oidc_proto_generate_nonce(r, &csrf, 8) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *path_scopes = oidc_dir_cfg_path_scope(r);\n\tchar *path_auth_request_params = oidc_dir_cfg_path_auth_request_params(r);\n\n\tchar *discover_url = oidc_cfg_dir_discover_url(r);\n\t/* see if there's an external discovery page configured */\n\tif (discover_url != NULL) {\n\n\t\t/* yes, assemble the parameters for external discovery */\n\t\tchar *url = apr_psprintf(r->pool, \""%s%s%s=%s&%s=%s&%s=%s&%s=%s\"",\n\t\t\t\tdiscover_url,\n\t\t\t\tstrchr(discover_url, OIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\t\t\tOIDC_DISC_CB_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, oidc_get_redirect_uri(r, cfg)),\n\t\t\t\t\t\tOIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));\n\n\t\tif (path_scopes != NULL)\n\t\t\turl = apr_psprintf(r->pool, \""%s&%s=%s\"", url, OIDC_DISC_SC_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\turl = apr_psprintf(r->pool, \""%s&%s=%s\"", url, OIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\t/* log what we're about to do */\n\t\toidc_debug(r, \""redirecting to external discovery page: %s\"", url);\n\n\t\t/* set CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\t\tOIDC_COOKIE_SAMESITE_STRICT(cfg, r));\n\n\t\t/* see if we need to preserve POST parameters through Javascript/HTML5 storage */\n\t\tif (oidc_post_preserve_javascript(r, url, NULL, NULL) == TRUE)\n\t\t\treturn OK;\n\n\t\t/* do the actual redirect to an external discovery page */\n\t\toidc_util_hdr_out_location_set(r, url);\n\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\t}\n\n\t/* get a list of all providers configured in the metadata directory */\n\tapr_array_header_t *arr = NULL;\n\tif (oidc_metadata_list(r, cfg, &arr) == FALSE)\n\t\treturn oidc_util_html_send_error(r, cfg->error_template,\n\t\t\t\t\""Configuration Error\"",\n\t\t\t\t\""No configured providers found, contact your administrator\"",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\n\t/* assemble a where-are-you-from IDP discovery HTML page */\n\tconst char *s = \""\t\t\t<h3>Select your OpenID Connect Identity Provider</h3>\\n\"";\n\n\t/* list all configured providers in there */\n\tint i;\n\tfor (i = 0; i < arr->nelts; i++) {\n\n\t\tconst char *issuer = ((const char**) arr->elts)[i];\n\t\t// TODO: html escape (especially & character)\n\n\t\tchar *href = apr_psprintf(r->pool,\n\t\t\t\t\""%s?%s=%s&amp;%s=%s&amp;%s=%s&amp;%s=%s\"",\n\t\t\t\toidc_get_redirect_uri(r, cfg), OIDC_DISC_OP_PARAM,\n\t\t\t\toidc_util_escape_string(r, issuer),\n\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\tOIDC_CSRF_NAME, csrf);\n\n\t\tif (path_scopes != NULL)\n\t\t\thref = apr_psprintf(r->pool, \""%s&amp;%s=%s\"", href,\n\t\t\t\t\tOIDC_DISC_SC_PARAM, oidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\thref = apr_psprintf(r->pool, \""%s&amp;%s=%s\"", href,\n\t\t\t\t\tOIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\tchar *display =\n\t\t\t\t(strstr(issuer, \""https://\"") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\""https://\""));\n\n\t\t/* strip port number */\n\t\t//char *p = strstr(display, \"":\"");\n\t\t//if (p != NULL) *p = '\\0';\n\t\t/* point back to the redirect_uri, where the selection is handled, with an IDP selection and return_to URL */\n\t\ts = apr_psprintf(r->pool, \""%s<p><a href=\\\""%s\\\"">%s</a></p>\\n\"", s, href,\n\t\t\t\tdisplay);\n\t}\n\n\t/* add an option to enter an account or issuer name for dynamic OP discovery */\n\ts = apr_psprintf(r->pool, \""%s<form method=\\\""get\\\"" action=\\\""%s\\\"">\\n\"", s,\n\t\t\toidc_get_redirect_uri(r, cfg));\n\ts = apr_psprintf(r->pool,\n\t\t\t\""%s<p><input type=\\\""hidden\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""><p>\\n\"", s,\n\t\t\tOIDC_DISC_RT_PARAM, current_url);\n\ts = apr_psprintf(r->pool,\n\t\t\t\""%s<p><input type=\\\""hidden\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""><p>\\n\"", s,\n\t\t\tOIDC_DISC_RM_PARAM, method);\n\ts = apr_psprintf(r->pool,\n\t\t\t\""%s<p><input type=\\\""hidden\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""><p>\\n\"", s,\n\t\t\tOIDC_CSRF_NAME, csrf);\n\n\tif (path_scopes != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\""%s<p><input type=\\\""hidden\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""><p>\\n\"", s,\n\t\t\t\tOIDC_DISC_SC_PARAM, path_scopes);\n\tif (path_auth_request_params != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\""%s<p><input type=\\\""hidden\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""><p>\\n\"", s,\n\t\t\t\tOIDC_DISC_AR_PARAM, path_auth_request_params);\n\n\ts =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\""%s<p>Or enter your account name (eg. &quot;mike@seed.gluu.org&quot;, or an IDP identifier (eg. &quot;mitreid.org&quot;):</p>\\n\"",\n\t\t\t\t\ts);\n\ts = apr_psprintf(r->pool,\n\t\t\t\""%s<p><input type=\\\""text\\\"" name=\\\""%s\\\"" value=\\\""%s\\\""></p>\\n\"", s,\n\t\t\tOIDC_DISC_OP_PARAM, \""\"");\n\ts = apr_psprintf(r->pool,\n\t\t\t\""%s<p><input type=\\\""submit\\\"" value=\\\""Submit\\\""></p>\\n\"", s);\n\ts = apr_psprintf(r->pool, \""%s</form>\\n\"", s);\n\n\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\tOIDC_COOKIE_SAMESITE_STRICT(cfg, r));\n\n\tchar *javascript = NULL, *javascript_method = NULL;\n\tchar *html_head =\n\t\t\t\""<style type=\\\""text/css\\\"">body {text-align: center}</style>\"";\n\tif (oidc_post_preserve_javascript(r, NULL, &javascript, &javascript_method)\n\t\t\t== TRUE)\n\t\thtml_head = apr_psprintf(r->pool, \""%s%s\"", html_head, javascript);\n\n\t/* now send the HTML contents to the user agent */\n\treturn oidc_util_html_send(r, \""OpenID Connect Provider Discovery\"",\n\t\t\thtml_head, javascript_method, s, OK);\n}\n"", ""caller_start"": 2091, ""file_path"": ""src/mod_auth_openidc.c""}, {""call_line"": 753, ""call_code"": ""oidc_post_preserve_javascript(r, authorization_request, NULL,\n\t\t\t\tNULL)"", ""caller_code"": ""int oidc_proto_authorization_request(request_rec *r,\n\t\tstruct oidc_provider_t *provider, const char *login_hint,\n\t\tconst char *redirect_uri, const char *state,\n\t\toidc_proto_state_t *proto_state, const char *id_token_hint,\n\t\tconst char *code_challenge, const char *auth_request_params,\n\t\tconst char *path_scope) {\n\n\t/* log some stuff */\n\toidc_debug(r,\n\t\t\t\""enter, issuer=%s, redirect_uri=%s, state=%s, proto_state=%s, code_challenge=%s, auth_request_params=%s, path_scope=%s\"",\n\t\t\tprovider->issuer, redirect_uri, state,\n\t\t\toidc_proto_state_to_string(r, proto_state), code_challenge,\n\t\t\tauth_request_params, path_scope);\n\n\tint rv = OK;\n\tchar *authorization_request = NULL;\n\n\t/* assemble parameters to call the token endpoint for validation */\n\tapr_table_t *params = apr_table_make(r->pool, 4);\n\n\t/* add the response type */\n\tapr_table_setn(params, OIDC_PROTO_RESPONSE_TYPE,\n\t\t\toidc_proto_state_get_response_type(proto_state));\n\n\t/* concat the per-path scopes with the per-provider scopes */\n\tconst char *scope = provider->scope;\n\tif (path_scope != NULL)\n\t\tscope = ((scope != NULL) && (apr_strnatcmp(scope, \""\"") != 0)) ?\n\t\t\t\tapr_pstrcat(r->pool, scope, OIDC_STR_SPACE, path_scope,\n\t\t\t\t\t\tNULL) :\n\t\t\t\t\t\tpath_scope;\n\n\tif (scope != NULL) {\n\t\tif (!oidc_util_spaced_string_contains(r->pool, scope,\n\t\t\t\tOIDC_PROTO_SCOPE_OPENID)) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\""the configuration for the \\\""%s\\\"" parameter does not include the \\\""%s\\\"" scope, your provider may not return an \\\""id_token\\\"": %s\"",\n\t\t\t\t\tOIDC_PROTO_SCOPE, OIDC_PROTO_SCOPE_OPENID, provider->scope);\n\t\t}\n\t\tapr_table_setn(params, OIDC_PROTO_SCOPE, scope);\n\t}\n\n\tif (provider->client_id == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\""no Client ID set for the provider: perhaps you are accessing an endpoint protected with \\\""AuthType openid-connect\\\"" instead of \\\""AuthType oauth20\\\""?)\"");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* add the client ID */\n\tapr_table_setn(params, OIDC_PROTO_CLIENT_ID, provider->client_id);\n\n\t/* add the state */\n\tapr_table_setn(params, OIDC_PROTO_STATE, state);\n\n\t/* add the redirect uri */\n\tapr_table_setn(params, OIDC_PROTO_REDIRECT_URI, redirect_uri);\n\n\t/* add the nonce if set */\n\tconst char *nonce = oidc_proto_state_get_nonce(proto_state);\n\tif (nonce != NULL)\n\t\tapr_table_setn(params, OIDC_PROTO_NONCE, nonce);\n\n\t/* add PKCE code challenge if set */\n\tif (code_challenge != NULL) {\n\t\tapr_table_setn(params, OIDC_PROTO_CODE_CHALLENGE, code_challenge);\n\t\tapr_table_setn(params, OIDC_PROTO_CODE_CHALLENGE_METHOD,\n\t\t\t\tprovider->pkce->method);\n\t}\n\n\t/* add the response_mode if explicitly set */\n\tconst char *response_mode = oidc_proto_state_get_response_mode(proto_state);\n\tif (response_mode != NULL)\n\t\tapr_table_setn(params, OIDC_PROTO_RESPONSE_MODE, response_mode);\n\n\t/* add the login_hint if provided */\n\tif (login_hint != NULL)\n\t\tapr_table_setn(params, OIDC_PROTO_LOGIN_HINT, login_hint);\n\n\t/* add the id_token_hint if provided */\n\tif (id_token_hint != NULL)\n\t\tapr_table_setn(params, OIDC_PROTO_ID_TOKEN_HINT, id_token_hint);\n\n\t/* add the prompt setting if provided (e.g. \""none\"" for no-GUI checks) */\n\tconst char *prompt = oidc_proto_state_get_prompt(proto_state);\n\tif (prompt != NULL)\n\t\tapr_table_setn(params, OIDC_PROTO_PROMPT, prompt);\n\n\t/* add any statically configured custom authorization request parameters */\n\tadd_auth_request_params(r, params, provider->auth_request_params);\n\n\t/* add any dynamically configured custom authorization request parameters */\n\tadd_auth_request_params(r, params, auth_request_params);\n\n\t/* add request parameter (request or request_uri) if set */\n\tif (provider->request_object != NULL)\n\t\toidc_proto_add_request_param(r, provider, redirect_uri, params);\n\n\t/* send the full authentication request via POST or GET */\n\tif (provider->auth_request_method == OIDC_AUTH_REQUEST_METHOD_POST) {\n\n\t\t/* construct a HTML POST auto-submit page with the authorization request parameters */\n\t\trv = oidc_proto_html_post(r, provider->authorization_endpoint_url,\n\t\t\t\tparams);\n\n\t} else if (provider->auth_request_method == OIDC_AUTH_REQUEST_METHOD_GET) {\n\n\t\t/* construct the full authorization request URL */\n\t\tauthorization_request = oidc_util_http_query_encoded_url(r,\n\t\t\t\tprovider->authorization_endpoint_url, params);\n\n\t\t// TODO: should also enable this when using the POST binding for the auth request\n\t\t/* see if we need to preserve POST parameters through Javascript/HTML5 storage */\n\t\tif (oidc_post_preserve_javascript(r, authorization_request, NULL,\n\t\t\t\tNULL) == FALSE) {\n\n\t\t\t/* add the redirect location header */\n\t\t\toidc_util_hdr_out_location_set(r, authorization_request);\n\n\t\t\t/* and tell Apache to return an HTTP Redirect (302) message */\n\t\t\trv = HTTP_MOVED_TEMPORARILY;\n\t\t}\n\t} else {\n\t\toidc_error(r, \""provider->auth_request_method set to wrong value: %d\"",\n\t\t\t\tprovider->auth_request_method);\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* add a referred token binding request for the provider if enabled */\n\tif ((provider->token_binding_policy > OIDC_TOKEN_BINDING_POLICY_DISABLED)\n\t\t\t&& (oidc_util_get_provided_token_binding_id(r) != NULL))\n\t\toidc_util_hdr_err_out_add(r,\n\t\t\t\tOIDC_HTTP_HDR_INCLUDE_REFERRED_TOKEN_BINDING_ID, \""true\"");\n\n\t/* cleanup */\n\toidc_proto_state_destroy(proto_state);\n\n\t/* no cache */\n\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_CACHE_CONTROL,\n\t\t\t\""no-cache, no-store, max-age=0\"");\n\n\t/* log our exit code */\n\toidc_debug(r, \""return: %d\"", rv);\n\n\treturn rv;\n}\n"", ""caller_start"": 641, ""file_path"": ""src/proto.c""}]}, {""source"": ""func_info(func:oidc_get_current_url)"", ""result"": [{""code"": ""char* oidc_get_current_url(request_rec *r) {\n\tchar *url = NULL, *path = NULL;\n\tapr_uri_t uri;\n\n\tpath = r->uri;\n\n\t/* check if we're dealing with a forward proxying secenario i.e. a non-relative URL */\n\tif ((path) && (path[0] != '/')) {\n\t\tmemset(&uri, 0, sizeof(apr_uri_t));\n\t\tif (apr_uri_parse(r->pool, r->uri, &uri) == APR_SUCCESS)\n\t\t\tpath = apr_pstrcat(r->pool, uri.path,\n\t\t\t\t\t(r->args != NULL && *r->args != '\\0' ? \""?\"" : \""\""), r->args,\n\t\t\t\t\tNULL);\n\t\telse\n\t\t\toidc_warn(r, \""apr_uri_parse failed on non-relative URL: %s\"",\n\t\t\t\t\tr->uri);\n\t} else {\n\t\t/* make sure we retain URL-encoded characters original URL that we send the user back to */\n\t\tpath = r->unparsed_uri;\n\t}\n\n\turl = apr_pstrcat(r->pool, oidc_get_current_url_base(r), path, NULL);\n\n\toidc_debug(r, \""current URL '%s'\"", url);\n\n\treturn url;\n}"", ""start_line"": 522, ""end_line"": 548, ""full_name"": ""oidc_get_current_url"", ""file_path"": ""src/util.c""}]}, {""source"": ""func_info(file:proto.c, func:oidc_proto_authorization_request)"", ""result"": [{""code"": ""int oidc_proto_authorization_request(request_rec *r,\n\t\tstruct oidc_provider_t *provider, const char *login_hint,\n\t\tconst char *redirect_uri, const char *state,\n\t\toidc_proto_state_t *proto_state, const char *id_token_hint,\n\t\tconst char *code_challenge, const char *auth_request_params,\n\t\tconst char *path_scope) {\n\n\t/* log some stuff */\n\toidc_debug(r,\n\t\t\t\""enter, issuer=%s, redirect_uri=%s, state=%s, proto_state=%s, code_challenge=%s, auth_request_params=%s, path_scope=%s\"",\n\t\t\tprovider->issuer, redirect_uri, state,\n\t\t\toidc_proto_state_to_string(r, proto_state), code_challenge,\n\t\t\tauth_request_params, path_scope);\n\n\tint rv = OK;\n\tchar *authorization_request = NULL;\n\n\t/* assemble parameters to call the token endpoint for validation */\n\tapr_table_t *params = apr_table_make(r->pool, 4);\n\n\t/* add the response type */\n\tapr_table_setn(params, OIDC_PROTO_RESPONSE_TYPE,\n\t\t\toidc_proto_state_get_response_type(proto_state));\n\n\t/* concat the per-path scopes with the per-provider scopes */\n\tconst char *scope = provider->scope;\n\tif (path_scope != NULL)\n\t\tscope = ((scope != NULL) && (apr_strnatcmp(scope, \""\"") != 0)) ?\n\t\t\t\tapr_pstrcat(r->pool, scope, OIDC_STR_SPACE, path_scope,\n\t\t\t\t\t\tNULL) :\n\t\t\t\t\t\tpath_scope;\n\n\tif (scope != NULL) {\n\t\tif (!oidc_util_spaced_string_contains(r->pool, scope,\n\t\t\t\tOIDC_PROTO_SCOPE_OPENID)) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\""the configuration for the \\\""%s\\\"" parameter does not include the \\\""%s\\\"" scope, your provider may not return an \\\""id_token\\\"": %s\"",\n\t\t\t\t\tOIDC_PROTO_SCOPE, OIDC_PROTO_SCOPE_OPENID, provider->scope);\n\t\t}\n\t\tapr_table_setn(params, OIDC_PROTO_SCOPE, scope);\n\t}\n\n\tif (provider->client_id == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\""no Client ID set for the provider: perhaps you are accessing an endpoint protected with \\\""AuthType openid-connect\\\"" instead of \\\""AuthType oauth20\\\""?)\"");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* add the client ID */\n\tapr_table_setn(params, OIDC_PROTO_CLIENT_ID, provider->client_id);\n\n\t/* add the state */\n\tapr_table_setn(params, OIDC_PROTO_STATE, state);\n\n\t/* add the redirect uri */\n\tapr_table_setn(params, OIDC_PROTO_REDIRECT_URI, redirect_uri);\n\n\t/* add the nonce if set */\n\tconst char *nonce = oidc_proto_state_get_nonce(proto_state);\n\tif (nonce != NULL)\n\t\tapr_table_setn(params, OIDC_PROTO_NONCE, nonce);\n\n\t/* add PKCE code challenge if set */\n\tif (code_challenge != NULL) {\n\t\tapr_table_setn(params, OIDC_PROTO_CODE_CHALLENGE, code_challenge);\n\t\tapr_table_setn(params, OIDC_PROTO_CODE_CHALLENGE_METHOD,\n\t\t\t\tprovider->pkce->method);\n\t}\n\n\t/* add the response_mode if explicitly set */\n\tconst char *response_mode = oidc_proto_state_get_response_mode(proto_state);\n\tif (response_mode != NULL)\n\t\tapr_table_setn(params, OIDC_PROTO_RESPONSE_MODE, response_mode);\n\n\t/* add the login_hint if provided */\n\tif (login_hint != NULL)\n\t\tapr_table_setn(params, OIDC_PROTO_LOGIN_HINT, login_hint);\n\n\t/* add the id_token_hint if provided */\n\tif (id_token_hint != NULL)\n\t\tapr_table_setn(params, OIDC_PROTO_ID_TOKEN_HINT, id_token_hint);\n\n\t/* add the prompt setting if provided (e.g. \""none\"" for no-GUI checks) */\n\tconst char *prompt = oidc_proto_state_get_prompt(proto_state);\n\tif (prompt != NULL)\n\t\tapr_table_setn(params, OIDC_PROTO_PROMPT, prompt);\n\n\t/* add any statically configured custom authorization request parameters */\n\tadd_auth_request_params(r, params, provider->auth_request_params);\n\n\t/* add any dynamically configured custom authorization request parameters */\n\tadd_auth_request_params(r, params, auth_request_params);\n\n\t/* add request parameter (request or request_uri) if set */\n\tif (provider->request_object != NULL)\n\t\toidc_proto_add_request_param(r, provider, redirect_uri, params);\n\n\t/* send the full authentication request via POST or GET */\n\tif (provider->auth_request_method == OIDC_AUTH_REQUEST_METHOD_POST) {\n\n\t\t/* construct a HTML POST auto-submit page with the authorization request parameters */\n\t\trv = oidc_proto_html_post(r, provider->authorization_endpoint_url,\n\t\t\t\tparams);\n\n\t} else if (provider->auth_request_method == OIDC_AUTH_REQUEST_METHOD_GET) {\n\n\t\t/* construct the full authorization request URL */\n\t\tauthorization_request = oidc_util_http_query_encoded_url(r,\n\t\t\t\tprovider->authorization_endpoint_url, params);\n\n\t\t// TODO: should also enable this when using the POST binding for the auth request\n\t\t/* see if we need to preserve POST parameters through Javascript/HTML5 storage */\n\t\tif (oidc_post_preserve_javascript(r, authorization_request, NULL,\n\t\t\t\tNULL) == FALSE) {\n\n\t\t\t/* add the redirect location header */\n\t\t\toidc_util_hdr_out_location_set(r, authorization_request);\n\n\t\t\t/* and tell Apache to return an HTTP Redirect (302) message */\n\t\t\trv = HTTP_MOVED_TEMPORARILY;\n\t\t}\n\t} else {\n\t\toidc_error(r, \""provider->auth_request_method set to wrong value: %d\"",\n\t\t\t\tprovider->auth_request_method);\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* add a referred token binding request for the provider if enabled */\n\tif ((provider->token_binding_policy > OIDC_TOKEN_BINDING_POLICY_DISABLED)\n\t\t\t&& (oidc_util_get_provided_token_binding_id(r) != NULL))\n\t\toidc_util_hdr_err_out_add(r,\n\t\t\t\tOIDC_HTTP_HDR_INCLUDE_REFERRED_TOKEN_BINDING_ID, \""true\"");\n\n\t/* cleanup */\n\toidc_proto_state_destroy(proto_state);\n\n\t/* no cache */\n\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_CACHE_CONTROL,\n\t\t\t\""no-cache, no-store, max-age=0\"");\n\n\t/* log our exit code */\n\toidc_debug(r, \""return: %d\"", rv);\n\n\treturn rv;\n}\n"", ""start_line"": 641, ""end_line"": 785, ""full_name"": ""oidc_proto_authorization_request"", ""file_path"": ""src/proto.c""}]}]","Unescaped user-controlled 'location' and 'original_url' variables were directly embedded into dynamically generated JavaScript in:\n1. `oidc_post_preserve_javascript()` (src/mod_auth_openidc.c:469) – 'location' derived from `oidc_get_current_url()` (src/util.c:522-548), which constructs URLs from `r->uri`/`r->unparsed_uri` (user-controlled request inputs).\n2. `oidc_session_redirect_parent_window_to_logout()` (src/mod_auth_openidc.c:1554) – 'original_url' from `oidc_proto_state_get_original_url()` (src/proto.c:1010-1013), populated via OpenID Connect state parameters (user-controlled).\n3. `oidc_request_post_preserved_restore()` (src/mod_auth_openidc.c:517) – 'original_url' same as above. Patches apply `oidc_util_javascript_escape()` to all instances.",0.95,./github/other_context/CVE-2021-32792
93,CVE-2021-44550,CWE-74,java,An Incorrect Access Control vulnerability exists in CoreNLP 4.3.2 via the classifier in NERServlet.java (lines 158 and 159).,https://github.com/stanfordnlp/CoreNLP/commit/5ee097dbede547023e88f60ed3f430ff09398b87,Address issue #1222: verify that classifier and outputFormat are valid values before returning them in headers.  Should sanitize malicious output,2,"[{""func_name"": ""addResults"", ""file_path"": ""src/edu/stanford/nlp/ie/ner/webapp/NERServlet.java"", ""func_code"": ""private void addResults(HttpServletRequest request,\n                          HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\""input\"");\n    if (input == null) {\n      return;\n    }\n    input = input.trim();\n    if (input.isEmpty()) {\n      return;\n    }\n\n    PrintWriter out = response.getWriter();\n    if (input.length() > MAXIMUM_QUERY_LENGTH) {\n      out.print(\""This query is too long.  If you want to run very long queries, please download and use our <a href=\\\""http://nlp.stanford.edu/software/CRF-NER.html\\\"">publicly released distribution</a>.\"");\n      return;\n    }\n\n    String outputFormat = request.getParameter(\""outputFormat\"");\n    if (outputFormat == null || outputFormat.trim().isEmpty()) {\n      outputFormat = this.format;\n    }\n\n    boolean preserveSpacing;\n    String preserveSpacingStr = request.getParameter(\""preserveSpacing\"");\n    if (preserveSpacingStr == null || preserveSpacingStr.trim().isEmpty()) {\n      preserveSpacing = this.spacing;\n    } else {\n      preserveSpacingStr = preserveSpacingStr.trim();\n      preserveSpacing = Boolean.valueOf(preserveSpacingStr);\n    }\n\n    String classifier = request.getParameter(\""classifier\"");\n    if (classifier == null || classifier.trim().isEmpty()) {\n      classifier = this.defaultClassifier;\n    }\n\n    response.addHeader(\""classifier\"", classifier);\n    response.addHeader(\""outputFormat\"", outputFormat);\n    response.addHeader(\""preserveSpacing\"", String.valueOf(preserveSpacing));\n\n    if (outputFormat.equals(\""highlighted\"")) {\n      outputHighlighting(out, ners.get(classifier), input);\n    } else {\n      out.print(StringEscapeUtils.escapeHtml4(ners.get(classifier).classifyToString(input, outputFormat, preserveSpacing)));\n    }\n  }"", ""target"": 0}, {""func_name"": ""init"", ""file_path"": ""src/edu/stanford/nlp/ie/ner/webapp/NERServlet.java"", ""func_code"": ""@Override\n  public void init() throws ServletException {\n    format = getServletConfig().getInitParameter(\""outputFormat\"");\n    if (format == null || format.trim().isEmpty()) {\n      throw new ServletException(\""Invalid outputFormat setting.\"");\n    }\n\n    String spacingStr = getServletConfig().getInitParameter(\""preserveSpacing\"");\n    if (spacingStr == null || spacingStr.trim().isEmpty()) {\n      throw new ServletException(\""Invalid preserveSpacing setting.\"");\n    }\n    //spacing = Boolean.valueOf(spacingStr).booleanValue();\n    spacingStr = spacingStr.trim().toLowerCase();\n    spacing = \""true\"".equals(spacingStr);\n\n    String path = getServletContext().getRealPath(\""/WEB-INF/data/models\"");\n    for (String classifier : new File(path).list()) {\n      classifiers.add(classifier);\n    }\n    // TODO: get this from somewhere more interesting?\n    defaultClassifier = classifiers.get(0);\n\n    for (String classifier : classifiers) {\n      log(classifier);\n    }\n\n    ners = Generics.newHashMap();\n    for (String classifier : classifiers) {\n      CRFClassifier model = null;\n      String filename = \""/WEB-INF/data/models/\"" + classifier;\n      InputStream is = getServletConfig().getServletContext().getResourceAsStream(filename);\n\n      if (is == null) {\n        throw new ServletException(\""File not found. Filename = \"" + filename);\n      }\n      try {\n        if (filename.endsWith(\"".gz\"")) {\n          is = new BufferedInputStream(new GZIPInputStream(is));\n        } else {\n          is = new BufferedInputStream(is);\n        }\n        model = CRFClassifier.getClassifier(is);\n      } catch (IOException e) {\n        throw new ServletException(\""IO problem reading classifier.\"");\n      } catch (ClassCastException e) {\n        throw new ServletException(\""Classifier class casting problem.\"");\n      } catch (ClassNotFoundException e) {\n        throw new ServletException(\""Classifier class not found problem.\"");\n      } finally {\n        IOUtils.closeIgnoringExceptions(is);\n      }\n      ners.put(classifier, model);\n    }\n  }"", ""target"": 1}]","[{""func_name"": ""addResults"", ""file_path"": ""src/edu/stanford/nlp/ie/ner/webapp/NERServlet.java"", ""func_code"": ""private void addResults(HttpServletRequest request,\n                          HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\""input\"");\n    if (input == null) {\n      return;\n    }\n    input = input.trim();\n    if (input.isEmpty()) {\n      return;\n    }\n\n    PrintWriter out = response.getWriter();\n    if (input.length() > MAXIMUM_QUERY_LENGTH) {\n      out.print(\""This query is too long.  If you want to run very long queries, please download and use our <a href=\\\""http://nlp.stanford.edu/software/CRF-NER.html\\\"">publicly released distribution</a>.\"");\n      return;\n    }\n\n    String outputFormat = request.getParameter(\""outputFormat\"");\n    if (outputFormat == null || outputFormat.trim().isEmpty()) {\n      outputFormat = this.format;\n    }\n\n    boolean preserveSpacing;\n    String preserveSpacingStr = request.getParameter(\""preserveSpacing\"");\n    if (preserveSpacingStr == null || preserveSpacingStr.trim().isEmpty()) {\n      preserveSpacing = this.spacing;\n    } else {\n      preserveSpacingStr = preserveSpacingStr.trim();\n      preserveSpacing = Boolean.valueOf(preserveSpacingStr);\n    }\n\n    String classifier = request.getParameter(\""classifier\"");\n    if (classifier == null || classifier.trim().isEmpty()) {\n      classifier = this.defaultClassifier;\n    }\n\n    CRFClassifier<CoreMap> nerModel = ners.get(classifier);\n    // check that we weren't asked for a classifier that doesn't exist\n    if (nerModel == null) {\n      out.print(StringEscapeUtils.escapeHtml4(\""Unknown model \"" + classifier));\n      return;\n    }\n\n    if (outputFormat.equals(\""highlighted\"")) {\n      outputHighlighting(out, nerModel, input);\n    } else {\n      out.print(StringEscapeUtils.escapeHtml4(nerModel.classifyToString(input, outputFormat, preserveSpacing)));\n    }\n\n    response.addHeader(\""classifier\"", classifier);\n    // a non-existent outputFormat would have just thrown an exception\n    response.addHeader(\""outputFormat\"", outputFormat);\n    response.addHeader(\""preserveSpacing\"", String.valueOf(preserveSpacing));\n  }""}, {""func_name"": ""init"", ""file_path"": ""src/edu/stanford/nlp/ie/ner/webapp/NERServlet.java"", ""func_code"": ""@Override\n  public void init() throws ServletException {\n    format = getServletConfig().getInitParameter(\""outputFormat\"");\n    if (format == null || format.trim().isEmpty()) {\n      throw new ServletException(\""Invalid outputFormat setting.\"");\n    }\n\n    String spacingStr = getServletConfig().getInitParameter(\""preserveSpacing\"");\n    if (spacingStr == null || spacingStr.trim().isEmpty()) {\n      throw new ServletException(\""Invalid preserveSpacing setting.\"");\n    }\n    //spacing = Boolean.valueOf(spacingStr).booleanValue();\n    spacingStr = spacingStr.trim().toLowerCase();\n    spacing = \""true\"".equals(spacingStr);\n\n    String path = getServletContext().getRealPath(\""/WEB-INF/data/models\"");\n    for (String classifier : new File(path).list()) {\n      classifiers.add(classifier);\n    }\n    // TODO: get this from somewhere more interesting?\n    defaultClassifier = classifiers.get(0);\n\n    for (String classifier : classifiers) {\n      log(classifier);\n    }\n\n    ners = new HashMap<>();\n    for (String classifier : classifiers) {\n      CRFClassifier<CoreMap> model = null;\n      String filename = \""/WEB-INF/data/models/\"" + classifier;\n      InputStream is = getServletConfig().getServletContext().getResourceAsStream(filename);\n\n      if (is == null) {\n        throw new ServletException(\""File not found. Filename = \"" + filename);\n      }\n      try {\n        if (filename.endsWith(\"".gz\"")) {\n          is = new BufferedInputStream(new GZIPInputStream(is));\n        } else {\n          is = new BufferedInputStream(is);\n        }\n        model = CRFClassifier.getClassifier(is);\n      } catch (IOException e) {\n        throw new ServletException(\""IO problem reading classifier.\"");\n      } catch (ClassCastException e) {\n        throw new ServletException(\""Classifier class casting problem.\"");\n      } catch (ClassNotFoundException e) {\n        throw new ServletException(\""Classifier class not found problem.\"");\n      } finally {\n        IOUtils.closeIgnoringExceptions(is);\n      }\n      ners.put(classifier, model);\n    }\n  }""}]","{""code"": 5, ""value"": 4, ""function"": 2}","[{""source"": ""code_info(file:NERServlet.java, lines:100-140)"", ""result"": ""      request.setCharacterEncoding(\""utf-8\"");\n    }\n    response.setContentType(\""text/html; charset=UTF-8\"");\n\n    this.getServletContext().getRequestDispatcher(\""/header.jsp\"").\n      include(request, response);\n    request.setAttribute(\""classifiers\"", classifiers);\n    this.getServletContext().getRequestDispatcher(\""/ner.jsp\"").\n      include(request, response);\n    addResults(request, response);\n    this.getServletContext().getRequestDispatcher(\""/footer.jsp\"").\n      include(request, response);\n  }\n\n  @Override\n  public void doPost(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException\n  {\n    doGet(request, response);\n  }\n\n  private void addResults(HttpServletRequest request,\n                          HttpServletResponse response) throws IOException {\n    String input = request.getParameter(\""input\"");\n    if (input == null) {\n      return;\n    }\n    input = input.trim();\n    if (input.isEmpty()) {\n      return;\n    }\n\n    PrintWriter out = response.getWriter();\n    if (input.length() > MAXIMUM_QUERY_LENGTH) {\n      out.print(\""This query is too long.  If you want to run very long queries, please download and use our <a href=\\\""http://nlp.stanford.edu/software/CRF-NER.html\\\"">publicly released distribution</a>.\"");\n      return;\n    }\n\n    String outputFormat = request.getParameter(\""outputFormat\"");\n    if (outputFormat == null || outputFormat.trim().isEmpty()) {\n      outputFormat = this.format;\n""}, {""source"": ""value_info(file:NERServlet.java, value:ners)"", ""result"": {""value_trace"": [{""full_code"": ""this.ners = Generics.newHashMap()"", ""line"": 66, ""func_name"": ""edu.stanford.nlp.ie.ner.webapp.NERServlet.init:void()""}], ""struct_var"": ""ners"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:NERServlet.java, lines:60-80)"", ""result"": ""    defaultClassifier = classifiers.get(0);\n\n    for (String classifier : classifiers) {\n      log(classifier);\n    }\n\n    ners = Generics.newHashMap();\n    for (String classifier : classifiers) {\n      CRFClassifier model = null;\n      String filename = \""/WEB-INF/data/models/\"" + classifier;\n      InputStream is = getServletConfig().getServletContext().getResourceAsStream(filename);\n\n      if (is == null) {\n        throw new ServletException(\""File not found. Filename = \"" + filename);\n      }\n      try {\n        if (filename.endsWith(\"".gz\"")) {\n          is = new BufferedInputStream(new GZIPInputStream(is));\n        } else {\n          is = new BufferedInputStream(is);\n        }\n""}, {""source"": ""value_info(file:NERServlet.java, value:ners)"", ""result"": {""value_trace"": [{""full_code"": ""this.ners = Generics.newHashMap()"", ""line"": 66, ""func_name"": ""edu.stanford.nlp.ie.ner.webapp.NERServlet.init:void()""}], ""struct_var"": ""ners"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:NERServlet.java, lines:160-180)"", ""result"": ""\n    if (outputFormat.equals(\""highlighted\"")) {\n      outputHighlighting(out, ners.get(classifier), input);\n    } else {\n      out.print(StringEscapeUtils.escapeHtml4(ners.get(classifier).classifyToString(input, outputFormat, preserveSpacing)));\n    }\n  }\n\n  private static void outputHighlighting(PrintWriter out,\n                                         CRFClassifier<CoreMap> classifier,\n                                         String input) {\n    Set<String> labels = classifier.labels();\n    String background = classifier.backgroundSymbol();\n    List<List<CoreMap>> sentences = classifier.classify(input);\n    Map<String, Color> tagToColorMap =\n      NERGUI.makeTagToColorMap(labels, background);\n\n    StringBuilder result = new StringBuilder();\n    int lastEndOffset = 0;\n    for (List<CoreMap> sentence : sentences) {\n      for (CoreMap word : sentence) {\n""}, {""source"": ""value_info(file:NERServlet.java, value:classifiers)"", ""result"": {""value_trace"": [{""full_code"": ""ArrayList classifiers = new ArrayList<>()"", ""line"": 97, ""func_name"": ""edu.stanford.nlp.ie.crf.TestThreadedCRFClassifier.runThreadedTest:void(java.util.Properties)""}, {""full_code"": ""Map classifiers = Generics.newHashMap()"", ""line"": 109, ""func_name"": ""edu.stanford.nlp.classify.OneVsAllClassifier.train:edu.stanford.nlp.classify.OneVsAllClassifier(edu.stanford.nlp.classify.ClassifierFactory,edu.stanford.nlp.classify.GeneralDataset,java.util.Collection)""}], ""struct_var"": ""classifiers"", ""struct_type"": ""java.util.ArrayList"", ""struct_definition"": null}}, {""source"": ""code_info(file:NERServlet.java, lines:180-200)"", ""result"": ""      for (CoreMap word : sentence) {\n        int beginOffset = word.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);\n        int endOffset = word.get(CoreAnnotations.CharacterOffsetEndAnnotation.class);\n        String answer = word.get(CoreAnnotations.AnswerAnnotation.class);\n\n        if (beginOffset > lastEndOffset) {\n          result.append(StringEscapeUtils.escapeHtml4(input.substring(lastEndOffset, beginOffset)));\n        }\n        // Add a color bar for any tagged words\n        if (!background.equals(answer)) {\n          Color color = tagToColorMap.get(answer);\n          result.append(\""<span style=\\\""color:#ffffff;background:\"" +\n                        NERGUI.colorToHTML(color) + \""\\\"">\"");\n        }\n\n        result.append(StringEscapeUtils.escapeHtml4(input.substring(beginOffset, endOffset)));\n        // Turn off the color bar\n        if (!background.equals(answer)) {\n          result.append(\""</span>\"");\n        }\n\n""}, {""source"": ""code_info(file:NERServlet.java, lines:40-60)"", ""result"": ""  @Override\n  public void init() throws ServletException {\n    format = getServletConfig().getInitParameter(\""outputFormat\"");\n    if (format == null || format.trim().isEmpty()) {\n      throw new ServletException(\""Invalid outputFormat setting.\"");\n    }\n\n    String spacingStr = getServletConfig().getInitParameter(\""preserveSpacing\"");\n    if (spacingStr == null || spacingStr.trim().isEmpty()) {\n      throw new ServletException(\""Invalid preserveSpacing setting.\"");\n    }\n    //spacing = Boolean.valueOf(spacingStr).booleanValue();\n    spacingStr = spacingStr.trim().toLowerCase();\n    spacing = \""true\"".equals(spacingStr);\n\n    String path = getServletContext().getRealPath(\""/WEB-INF/data/models\"");\n    for (String classifier : new File(path).list()) {\n      classifiers.add(classifier);\n    }\n    // TODO: get this from somewhere more interesting?\n    defaultClassifier = classifiers.get(0);\n""}, {""source"": ""value_info(file:NERServlet.java, value:classifiers)"", ""result"": {""value_trace"": [{""full_code"": ""ArrayList classifiers = new ArrayList<>()"", ""line"": 97, ""func_name"": ""edu.stanford.nlp.ie.crf.TestThreadedCRFClassifier.runThreadedTest:void(java.util.Properties)""}, {""full_code"": ""Map classifiers = Generics.newHashMap()"", ""line"": 109, ""func_name"": ""edu.stanford.nlp.classify.OneVsAllClassifier.train:edu.stanford.nlp.classify.OneVsAllClassifier(edu.stanford.nlp.classify.ClassifierFactory,edu.stanford.nlp.classify.GeneralDataset,java.util.Collection)""}], ""struct_var"": ""classifiers"", ""struct_type"": ""java.util.ArrayList"", ""struct_definition"": null}}, {""source"": ""func_info(func:classifyToString)"", ""result"": [{""code"": ""  public String classifyToString(String sentences, String outputFormat, boolean preserveSpacing) {\n    PlainTextDocumentReaderAndWriter.OutputStyle outFormat =\n      PlainTextDocumentReaderAndWriter.OutputStyle.fromShortName(outputFormat);\n    DocumentReaderAndWriter<IN> textDocumentReaderAndWriter = plainTextReaderAndWriter();\n\n    ObjectBank<List<IN>> documents = makeObjectBankFromString(sentences, textDocumentReaderAndWriter);\n\n    StringBuilder sb = new StringBuilder();\n    for (List<IN> doc : documents) {\n      List<IN> docOutput = classify(doc);\n      if (textDocumentReaderAndWriter instanceof PlainTextDocumentReaderAndWriter) {\n        // TODO: implement this particular method and its options in the other documentReaderAndWriters\n        sb.append(((PlainTextDocumentReaderAndWriter<IN>) textDocumentReaderAndWriter).getAnswers(docOutput, outFormat, preserveSpacing));\n      } else {\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n        textDocumentReaderAndWriter.printAnswers(docOutput, pw);\n        pw.flush();\n        sb.append(sw);\n        sb.append('\\n');\n      }\n    }\n    return sb.toString();\n  }\n"", ""start_line"": 540, ""end_line"": 563, ""full_name"": ""edu.stanford.nlp.ie.AbstractSequenceClassifier.classifyToString:java.lang.String(java.lang.String,java.lang.String,boolean)"", ""file_path"": ""src/edu/stanford/nlp/ie/AbstractSequenceClassifier.java""}, {""code"": ""  public String classifyToString(String sentences) {\n    return classifyToString(sentences, \""slashTags\"", true);\n  }\n"", ""start_line"": 589, ""end_line"": 591, ""full_name"": ""edu.stanford.nlp.ie.AbstractSequenceClassifier.classifyToString:java.lang.String(java.lang.String)"", ""file_path"": ""src/edu/stanford/nlp/ie/AbstractSequenceClassifier.java""}]}, {""source"": ""func_info(func:fromShortName)"", ""result"": [{""code"": ""    public static OutputStyle fromShortName(String name) {\n      OutputStyle result = shortNames.get(name);\n      if (result == null)\n        throw new IllegalArgumentException(name + \"" is not an OutputStyle\"");\n      return result;\n    }\n"", ""start_line"": 70, ""end_line"": 75, ""full_name"": ""edu.stanford.nlp.sequences.PlainTextDocumentReaderAndWriter$OutputStyle.fromShortName:edu.stanford.nlp.sequences.PlainTextDocumentReaderAndWriter$OutputStyle(java.lang.String)"", ""file_path"": ""src/edu/stanford/nlp/sequences/PlainTextDocumentReaderAndWriter.java""}]}]","NERServlet.java:158-159: User-controlled 'classifier' and 'outputFormat' parameters are used without validation. The 'classifier' is retrieved from the 'ners' map (populated in `init()` lines 40-60 by listing `/WEB-INF/data/models`), and 'outputFormat' is validated in `classifyToString` via `OutputStyle.fromShortName` (lines 70-75). The original code lacked existence checks for 'classifier' and exception handling for invalid 'outputFormat', allowing malicious input to bypass access controls or trigger errors. The patch adds null checks and header escaping.",0.95,./github/other_context/CVE-2021-44550
