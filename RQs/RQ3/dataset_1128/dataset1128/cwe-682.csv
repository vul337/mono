id,cve_id,cwe_id,language,description,commit_url,commit_msg,patch_nums,func_before,func_after,context_nums,context_data,root_cause,confidence_score,other_context_path
1,CVE-2015-8080,CWE-190,c_cpp,"Integer overflow in the getnum function in lua_struct.c in Redis 2.8.x before 2.8.24 and 3.0.x before 3.0.6 allows context-dependent attackers with permission to run Lua code in a Redis session to cause a denial of service (memory corruption and application crash) or possibly bypass intended sandbox restrictions via a large number, which triggers a stack-based buffer overflow.",https://github.com/redis/redis/commit/01173bc8097391b2e46c4d56a080709c219fda53,lua_struct.c/getnum: throw error if overflow happen\n\nFix issue #2855,3,"[{""func_name"": ""getnum"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static int getnum (const char **fmt, int df) {\n  if (!isdigit(**fmt))  /* no number? */\n    return df;  /* return default value */\n  else {\n    int a = 0;\n    do {\n      a = a*10 + *((*fmt)++) - '0';\n    } while (isdigit(**fmt));\n    return a;\n  }\n}"", ""target"": 0}, {""func_name"": ""optsize"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \""integral size %d is larger than limit of %d\"",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}"", ""target"": 1}, {""func_name"": ""controloptions"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  /* ignore white spaces */\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \""alignment %d is not a power of 2\"", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \""invalid format option '%c'\"", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}"", ""target"": 0}]","[{""func_name"": ""getnum"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static int getnum (lua_State *L, const char **fmt, int df) {\n  if (!isdigit(**fmt))  /* no number? */\n    return df;  /* return default value */\n  else {\n    int a = 0;\n    do {\n      if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))\n        luaL_error(L, \""integral size overflow\"");\n      a = a*10 + *((*fmt)++) - '0';\n    } while (isdigit(**fmt));\n    return a;\n  }\n}""}, {""func_name"": ""optsize"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(L, fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(L, fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \""integral size %d is larger than limit of %d\"",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}""}, {""func_name"": ""controloptions"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  /* ignore white spaces */\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(L, fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \""alignment %d is not a power of 2\"", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \""invalid format option '%c'\"", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}""}]","{""caller"": 2, ""value"": 1, ""code"": 2}","[{""source"": ""caller_info(file:lua_struct.c, func:getnum)"", ""result"": [{""call_line"": 118, ""call_code"": ""getnum(fmt, 1)"", ""caller_code"": ""static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \""integral size %d is larger than limit of %d\"",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}"", ""caller_start"": 109, ""file_path"": ""deps/lua/src/lua_struct.c""}, {""call_line"": 120, ""call_code"": ""getnum(fmt, sizeof(int))"", ""caller_code"": ""static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \""integral size %d is larger than limit of %d\"",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}"", ""caller_start"": 109, ""file_path"": ""deps/lua/src/lua_struct.c""}, {""call_line"": 153, ""call_code"": ""getnum(fmt, MAXALIGN)"", ""caller_code"": ""static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  /* ignore white spaces */\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \""alignment %d is not a power of 2\"", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \""invalid format option '%c'\"", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}"", ""caller_start"": 146, ""file_path"": ""deps/lua/src/lua_struct.c""}]}, {""source"": ""value_info(file:lua_struct.c, value:a)"", ""result"": {""value_trace"": [{""full_code"": ""a = 0"", ""line"": 96, ""func_name"": ""getnum""}, {""full_code"": ""a = a*10 + *((*fmt)++) - '0'"", ""line"": 98, ""func_name"": ""getnum""}, {""full_code"": ""a = getnum(fmt, MAXALIGN)"", ""line"": 153, ""func_name"": ""controloptions""}], ""struct_var"": ""a"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""caller_info(file:lua_struct.c, func:optsize)"", ""result"": [{""call_line"": 217, ""call_code"": ""optsize(L, opt, &fmt)"", ""caller_code"": ""static int b_pack (lua_State *L) {\n  luaL_Buffer b;\n  const char *fmt = luaL_checkstring(L, 1);\n  Header h;\n  int arg = 2;\n  size_t totalsize = 0;\n  defaultoptions(&h);\n  lua_pushnil(L);  /* mark to separate arguments from string buffer */\n  luaL_buffinit(L, &b);\n  while (*fmt != '\\0') {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    int toalign = gettoalign(totalsize, &h, opt, size);\n    totalsize += toalign;\n    while (toalign-- > 0) luaL_addchar(&b, '\\0');\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i': case 'I': {  /* integer types */\n        putinteger(L, &b, arg++, h.endian, size);\n        break;\n      }\n      case 'x': {\n        luaL_addchar(&b, '\\0');\n        break;\n      }\n      case 'f': {\n        float f = (float)luaL_checknumber(L, arg++);\n        correctbytes((char *)&f, size, h.endian);\n        luaL_addlstring(&b, (char *)&f, size);\n        break;\n      }\n      case 'd': {\n        double..."", ""caller_start"": 206, ""file_path"": ""deps/lua/src/lua_struct.c""}, {""call_line"": 301, ""call_code"": ""optsize(L, opt, &fmt)"", ""caller_code"": ""static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  defaultoptions(&h);\n  lua_settop(L, 2);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \""data string too short\"");\n    luaL_checkstack(L, 1, \""too many results\"");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res);\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f);\n        br..."", ""caller_start"": 291, ""file_path"": ""deps/lua/src/lua_struct.c""}, {""call_line"": 365, ""call_code"": ""optsize(L, opt, &fmt)"", ""caller_code"": ""static int b_size (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t pos = 0;\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    if (opt == 's')\n      luaL_argerror(L, 1, \""option 's' has no fixed size\"");\n    else if (opt == 'c' && size == 0)\n      luaL_argerror(L, 1, \""option 'c0' has no fixed size\"");\n    if (!isalnum(opt))\n      controloptions(L, opt, &fmt, &h);\n    pos += size;\n  }\n  lua_pushinteger(L, pos);\n  return 1;\n}"", ""caller_start"": 358, ""file_path"": ""deps/lua/src/lua_struct.c""}]}, {""source"": ""code_info(file:lua_struct.c, lines:217-250)"", ""result"": ""    size_t size = optsize(L, opt, &fmt);\n    int toalign = gettoalign(totalsize, &h, opt, size);\n    totalsize += toalign;\n    while (toalign-- > 0) luaL_addchar(&b, '\\0');\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i': case 'I': {  /* integer types */\n        putinteger(L, &b, arg++, h.endian, size);\n        break;\n      }\n      case 'x': {\n        luaL_addchar(&b, '\\0');\n        break;\n      }\n      case 'f': {\n        float f = (float)luaL_checknumber(L, arg++);\n        correctbytes((char *)&f, size, h.endian);\n        luaL_addlstring(&b, (char *)&f, size);\n        break;\n      }\n      case 'd': {\n        double d = luaL_checknumber(L, arg++);\n        correctbytes((char *)&d, size, h.endian);\n        luaL_addlstring(&b, (char *)&d, size);\n        break;\n      }\n      case 'c': case 's': {\n        size_t l;\n        const char *s = luaL_checklstring(L, arg++, &l);\n        if (size == 0) size = l;\n        luaL_argcheck(L, l >= (size_t)size, arg, \""string too short\"");\n        luaL_addlstring(&b, s, size);\n        if (opt == 's') {\n          luaL_addchar(&b, '\\0');  /* add zero at the end */\n          size++;\n""}, {""source"": ""code_info(file:lua_struct.c, lines:301-330)"", ""result"": ""    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \""data string too short\"");\n    luaL_checkstack(L, 1, \""too many results\"");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res);\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f);\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d);\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n""}]","Integer overflow in getnum (deps/lua/src/lua_struct.c:93-103) when parsing user-controlled format strings. The overflowed 'a' value is used in optsize (deps/lua/src/lua_struct.c:118) for the 'c' case size calculation. This unchecked size is passed to b_pack (deps/lua/src/lua_struct.c:217-250) and b_unpack (deps/lua/src/lua_struct.c:301-330), where it is used for buffer allocation and data parsing without validation, leading to stack-based buffer overflow.",0.95,./github/other_context/CVE-2015-8080
2,CVE-2016-10093,"CWE-190, CWE-119",c_cpp,"Integer overflow in tools/tiffcp.c in LibTIFF 4.0.7, 3.9.3, 3.9.4, 3.9.5, 3.9.6, 3.9.7, 4.0.0alpha4, 4.0.0alpha5, 4.0.0alpha6, 4.0.0beta7, 4.0.0, 4.0.1, 4.0.2, 4.0.3, 4.0.4, 4.0.4beta, 4.0.5 and 4.0.6 allows remote attackers to have unspecified impact via a crafted image, which triggers a heap-based buffer overflow.",https://github.com/vadz/libtiff/commit/787c0ee906430b772f33ca50b97b8b5ca070faec,* tools/tiffcp.c: fix uint32 underflow/overflow that can cause heap-based\nbuffer overflow.\nReported by Agostino Sarubbo.\nFixes http://bugzilla.maptools.org/show_bug.cgi?id=2610,1,"[{""func_name"": ""cpStripToTile"", ""file_path"": ""tools/tiffcp.c"", ""func_code"": ""static void\ncpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""cpStripToTile"", ""file_path"": ""tools/tiffcp.c"", ""func_code"": ""static void\ncpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int64 inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}""}]","{""code"": 2, ""caller"": 5, ""function"": 4, ""query"": 1}","[{""source"": ""code_info(file:tiffcp.c, lines:1165-1180)"", ""result"": ""cpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}\n\nstatic void\ncpContigBufToSeparateBuf(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp,\n    int bytes_per_sample )\n{\n""}, {""source"": ""caller_info(file:tiffcp.c, func:cpStripToTile)"", ""result"": [{""call_line"": 1354, ""call_code"": ""cpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew )"", ""caller_code"": ""DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n        \n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \""Error, can't read tile at %lu %lu\"",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\t..."", ""caller_start"": 1316, ""file_path"": ""tools/tiffcp.c""}, {""call_line"": 1358, ""call_code"": ""cpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0)"", ""caller_code"": ""DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n        \n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \""Error, can't read tile at %lu %lu\"",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\t..."", ""caller_start"": 1316, ""file_path"": ""tools/tiffcp.c""}, {""call_line"": 1540, ""call_code"": ""cpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew)"", ""caller_code"": ""DECLAREwriteFunc(writeBufferToContigTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\tuint32 tilew  = TIFFTileRowSize(out);\n\tint iskew = imagew - tilew;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\n\t(void) spp;\n\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\t/*\n\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t * visible portion and skewing factors.\n\t\t\t */\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else\n\t\t\t..."", ""caller_start"": 1508, ""file_path"": ""tools/tiffcp.c""}]}, {""source"": ""code_info(file:tiffcp.c, lines:1180-1200)"", ""result"": ""    int bytes_per_sample )\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t{\n\t\t\tint n = bytes_per_sample;\n\n\t\t\twhile( n-- ) {\n\t\t\t\t*out++ = *in++;\n\t\t\t}\n\t\t\tin += (spp-1) * bytes_per_sample;\n\t\t}\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}\n\nstatic void\ncpSeparateBufToContigBuf(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp,\n    int bytes_per_sample)\n""}, {""source"": ""func_info(func:TIFFScanlineSize)"", ""result"": [{""code"": ""tmsize_t\nTIFFScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \""TIFFScanlineSize\"";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFScanlineSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m) {\n\t\tTIFFErrorExt(tif->ti"", ""start_line"": 330, ""end_line"": 343, ""full_name"": ""TIFFScanlineSize"", ""file_path"": ""libtiff/tif_strip.c""}]}, {""source"": ""func_info(func:TIFFTileRowSize)"", ""result"": [{""code"": ""tmsize_t\nTIFFTileRowSize(TIFF* tif)\n{\n\tstatic const char module[] = \""TIFFTileRowSize\"";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFTileRowSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_"", ""start_line"": 181, ""end_line"": 195, ""full_name"": ""TIFFTileRowSize"", ""file_path"": ""libtiff/tif_tile.c""}]}, {""source"": ""caller_info(file:tiffcp.c, func:TIFFScanlineSize)"", ""result"": [{""call_line"": 840, ""call_code"": ""TIFFScanlineSize(in)"", ""caller_code"": ""DECLAREcpFunc(cpContig2ContigByRow)\n{\n\ttsize_t scanlinesize = TIFFScanlineSize(in);\n\ttdata_t buf;\n\tuint32 row;\n\n\tbuf = _TIFFmalloc(scanlinesize);\n\tif (!buf)\n\t\treturn 0;\n\t_TIFFmemset(buf, 0, scanlinesize);\n\t(void) imagewidth; (void) spp;\n\tfor (row = 0; row < imagelength; row++) {\n\t\tif (TIFFReadScanline(in, buf, row, 0) < 0 && !ignore) {\n\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t  \""Error, can't read scanline %lu\"",\n\t\t\t\t  (unsigned long) row);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (TIFFWriteScanline(out, buf, row, 0) < 0) {\n\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t  \""Error, can't write scanline %lu\"",\n\t\t\t\t  (unsigned long) row);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t_TIFFfree(buf);\n\treturn 1;\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}"", ""caller_start"": 838, ""file_path"": ""tools/tiffcp.c""}, {""call_line"": 904, ""call_code"": ""TIFFScanlineSize(bias)"", ""caller_code"": ""DECLAREcpFunc(cpBiasedContig2Contig)\n{\n\tif (spp == 1) {\n\t\ttsize_t biasSize = TIFFScanlineSize(bias);\n\t\ttsize_t bufSize = TIFFScanlineSize(in);\n\t\ttdata_t buf, biasBuf;\n\t\tuint32 biasWidth = 0, biasLength = 0;\n\t\tTIFFGetField(bias, TIFFTAG_IMAGEWIDTH, &biasWidth);\n\t\tTIFFGetField(bias, TIFFTAG_IMAGELENGTH, &biasLength);\n\t\tif (biasSize == bufSize &&\n\t\t    imagelength == biasLength && imagewidth == biasWidth) {\n\t\t\tuint16 sampleBits = 0;\n\t\t\tbiasFn *subtractLine;\n\t\t\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &sampleBits);\n\t\t\tsubtractLine = lineSubtractFn (sampleBits);\n\t\t\tif (subtractLine) {\n\t\t\t\tuint32 row;\n\t\t\t\tbuf = _TIFFmalloc(bufSize);\n\t\t\t\tbiasBuf = _TIFFmalloc(bufSize);\n\t\t\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\t\t\tif (TIFFReadScanline(in, buf, row, 0) < 0\n\t\t\t\t\t    && !ignore) {\n\t\t\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t\t\t    \""Error, can't read scanline %lu\"",\n\t\t\t\t\t\t    (unsigned long) row);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tif (TIFFReadScanline(bias, biasBuf, row, 0) < 0\n\t\t\t\t\t    && !ignore) {\n\t\t..."", ""caller_start"": 901, ""file_path"": ""tools/tiffcp.c""}, {""call_line"": 905, ""call_code"": ""TIFFScanlineSize(in)"", ""caller_code"": ""DECLAREcpFunc(cpBiasedContig2Contig)\n{\n\tif (spp == 1) {\n\t\ttsize_t biasSize = TIFFScanlineSize(bias);\n\t\ttsize_t bufSize = TIFFScanlineSize(in);\n\t\ttdata_t buf, biasBuf;\n\t\tuint32 biasWidth = 0, biasLength = 0;\n\t\tTIFFGetField(bias, TIFFTAG_IMAGEWIDTH, &biasWidth);\n\t\tTIFFGetField(bias, TIFFTAG_IMAGELENGTH, &biasLength);\n\t\tif (biasSize == bufSize &&\n\t\t    imagelength == biasLength && imagewidth == biasWidth) {\n\t\t\tuint16 sampleBits = 0;\n\t\t\tbiasFn *subtractLine;\n\t\t\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &sampleBits);\n\t\t\tsubtractLine = lineSubtractFn (sampleBits);\n\t\t\tif (subtractLine) {\n\t\t\t\tuint32 row;\n\t\t\t\tbuf = _TIFFmalloc(bufSize);\n\t\t\t\tbiasBuf = _TIFFmalloc(bufSize);\n\t\t\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\t\t\tif (TIFFReadScanline(in, buf, row, 0) < 0\n\t\t\t\t\t    && !ignore) {\n\t\t\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t\t\t    \""Error, can't read scanline %lu\"",\n\t\t\t\t\t\t    (unsigned long) row);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tif (TIFFReadScanline(bias, biasBuf, row, 0) < 0\n\t\t\t\t\t    && !ignore) {\n\t\t..."", ""caller_start"": 901, ""file_path"": ""tools/tiffcp.c""}]}, {""source"": ""caller_info(file:tiffcp.c, func:TIFFTileRowSize)"", ""result"": [{""call_line"": 1322, ""call_code"": ""TIFFTileRowSize(in)"", ""caller_code"": ""DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n        \n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \""Error, can't read tile at %lu %lu\"",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\t..."", ""caller_start"": 1316, ""file_path"": ""tools/tiffcp.c""}, {""call_line"": 1374, ""call_code"": ""TIFFTileRowSize(in)"", ""caller_code"": ""DECLAREreadFunc(readSeparateTilesIntoBuffer)\n{\n\tint status = 1;\n\tuint32 imagew = TIFFRasterScanlineSize(in);\n\tuint32 tilew = TIFFTileRowSize(in);\n\tint iskew  = imagew - tilew*spp;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\tuint16 bps = 0, bytes_per_sample;\n\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n        if( bps == 0 )\n        {\n            TIFFError(TIFFFileName(in), \""Error, cannot read BitsPerSample\"");\n            status = 0;\n            goto done;\n        }\n\tassert( bps % 8 == 0 );\n\tbytes_per_sample = bps/8;\n\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth; col += tw) {..."", ""caller_start"": 1370, ""file_path"": ""tools/tiffcp.c""}, {""call_line"": 1511, ""call_code"": ""TIFFTileRowSize(out)"", ""caller_code"": ""DECLAREwriteFunc(writeBufferToContigTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\tuint32 tilew  = TIFFTileRowSize(out);\n\tint iskew = imagew - tilew;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\n\t(void) spp;\n\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\t/*\n\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t * visible portion and skewing factors.\n\t\t\t */\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else\n\t\t\t..."", ""caller_start"": 1508, ""file_path"": ""tools/tiffcp.c""}]}, {""source"": ""func_info(file:tif_strip.c, func:TIFFScanlineSize64)"", ""result"": [{""code"": ""uint64\nTIFFScanlineSize64(TIFF* tif)\n{\n\tstatic const char module[] = \""TIFFScanlineSize64\"";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 scanline_size;\n\tif (td->td_planarconfig==PLANARCONFIG_CONTIG)\n\t{\n"", ""start_line"": 273, ""end_line"": 329, ""full_name"": ""TIFFScanlineSize64"", ""file_path"": ""libtiff/tif_strip.c""}]}, {""source"": ""func_info(file:tif_tile.c, func:TIFFTileRowSize64)"", ""result"": [{""code"": ""uint64\nTIFFTileRowSize64(TIFF* tif)\n{\n        static const char module[] = \""TIFFTileRowSize64\"";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 rowsize;\n\tuint64 tilerowsize;\n\n\tif (td->td_tilelength == 0)\n"", ""start_line"": 143, ""end_line"": 180, ""full_name"": ""TIFFTileRowSize64"", ""file_path"": ""libtiff/tif_tile.c""}]}, {""source"": ""caller_info(file:tif_strip.c, func:TIFFScanlineSize64)"", ""result"": [{""call_line"": 127, ""call_code"": ""TIFFScanlineSize64(tif)"", ""caller_code"": ""uint64\nTIFFVStripSize64(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \""TIFFVStripSize64\"";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tif (nrows==(uint32)(-1))\n\t\tnrows=td->td_imagelength;\n\tif ((td->td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (td->td_photometric == PHOTOMETRIC_YCBCR)&&\n\t    (!isUpSampled(tif)))\n\t{\n\t\t/*\n\t\t * Packed YCbCr data contain one Cb+Cr for every\n\t\t * HorizontalSampling*VerticalSampling Y values.\n\t\t * Must also roundup width and height when calculating\n\t\t * since images that are not a multiple of the\n\t\t * horizontal/vertical subsampling area include\n\t\t * YCbCr data for the extended image.\n\t\t */\n\t\tuint16 ycbcrsubsampling[2];\n\t\tuint16 samplingblock_samples;\n\t\tuint32 samplingblocks_hor;\n\t\tuint32 samplingblocks_ver;\n\t\tuint64 samplingrow_samples;\n\t\tuint64 samplingrow_size;\n\t\tif(td->td_samplesperpixel!=3)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t    \""Invalid td_samplesperpixel value\"");\n\t\t\treturn 0;\n\t\t}\n\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLIN..."", ""caller_start"": 77, ""file_path"": ""libtiff/tif_strip.c""}, {""call_line"": 250, ""call_code"": ""TIFFScanlineSize64(tif)"", ""caller_code"": ""uint32\n_TIFFDefaultStripSize(TIFF* tif, uint32 s)\n{\n\tif ((int32) s < 1) {\n\t\t/*\n\t\t * If RowsPerStrip is unspecified, try to break the\n\t\t * image up into strips that are approximately\n\t\t * STRIP_SIZE_DEFAULT bytes long.\n\t\t */\n\t\tuint64 scanlinesize;\n\t\tuint64 rows;\n\t\tscanlinesize=TIFFScanlineSize64(tif);\n\t\tif (scanlinesize==0)\n\t\t\tscanlinesize=1;\n\t\trows=(uint64)STRIP_SIZE_DEFAULT/scanlinesize;\n\t\tif (rows==0)\n\t\t\trows=1;\n\t\telse if (rows>0xFFFFFFFF)\n\t\t\trows=0xFFFFFFFF;\n\t\ts=(uint32)rows;\n\t}\n\treturn (s);\n}"", ""caller_start"": 239, ""file_path"": ""libtiff/tif_strip.c""}, {""call_line"": 336, ""call_code"": ""TIFFScanlineSize64(tif)"", ""caller_code"": ""tmsize_t\nTIFFScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \""TIFFScanlineSize\"";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFScanlineSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m) {\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\""Integer arithmetic overflow\"");\n\t\tn=0;\n\t}\n\treturn(n);\n}"", ""caller_start"": 330, ""file_path"": ""libtiff/tif_strip.c""}]}, {""source"": ""caller_info(file:tif_tile.c, func:TIFFTileRowSize64)"", ""result"": [{""call_line"": 187, ""call_code"": ""TIFFTileRowSize64(tif)"", ""caller_code"": ""tmsize_t\nTIFFTileRowSize(TIFF* tif)\n{\n\tstatic const char module[] = \""TIFFTileRowSize\"";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFTileRowSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\""Integer overflow\"");\n\t\tn=0;\n\t}\n\treturn(n);\n}"", ""caller_start"": 181, ""file_path"": ""libtiff/tif_tile.c""}, {""call_line"": 246, ""call_code"": ""TIFFTileRowSize64(tif)"", ""caller_code"": ""uint64\nTIFFVTileSize64(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \""TIFFVTileSize64\"";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tif (td->td_tilelength == 0 || td->td_tilewidth == 0 ||\n\t    td->td_tiledepth == 0)\n\t\treturn (0);\n\tif ((td->td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (td->td_photometric==PHOTOMETRIC_YCBCR)&&\n\t    (td->td_samplesperpixel==3)&&\n\t    (!isUpSampled(tif)))\n\t{\n\t\t/*\n\t\t * Packed YCbCr data contain one Cb+Cr for every\n\t\t * HorizontalSampling*VerticalSampling Y values.\n\t\t * Must also roundup width and height when calculating\n\t\t * since images that are not a multiple of the\n\t\t * horizontal/vertical subsampling area include\n\t\t * YCbCr data for the extended image.\n\t\t */\n\t\tuint16 ycbcrsubsampling[2];\n\t\tuint16 samplingblock_samples;\n\t\tuint32 samplingblocks_hor;\n\t\tuint32 samplingblocks_ver;\n\t\tuint64 samplingrow_samples;\n\t\tuint64 samplingrow_size;\n\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,ycbcrsubsampling+0,\n\t\t    ycbcrsubsampling+1);\n\t\tif ((ycbcrsubsa..."", ""caller_start"": 200, ""file_path"": ""libtiff/tif_tile.c""}]}, {""source"": ""query_info(query:cpg.call(\""TIFFGetField\"").where(_.argument.code(\""TI...)"", ""result"": [{""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize )"", ""typeFullName"": ""int"", ""lineNumber"": 725, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &(psCache->nXSize) )"", ""typeFullName"": ""int"", ""lineNumber"": 59, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tfFile, TIFFTAG_IMAGEWIDTH, &tfImageWidth)"", ""typeFullName"": ""ANY"", ""lineNumber"": 413, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width)"", ""typeFullName"": ""int"", ""lineNumber"": 176, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width)"", ""typeFullName"": ""int"", ""lineNumber"": 166, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": ""<unresolvedSignature>"", ""code"": ""TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth)"", ""typeFullName"": ""ANY"", ""lineNumber"": 146, ""methodFullName"": ""<unresolvedNamespace>.TIFFGetField:<unresolvedSignature>(3)"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth)"", ""typeFullName"": ""int"", ""lineNumber"": 84, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width)"", ""typeFullName"": ""int"", ""lineNumber"": 478, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w)"", ""typeFullName"": ""int"", ""lineNumber"": 208, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth)"", ""typeFullName"": ""int"", ""lineNumber"": 142, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width)"", ""typeFullName"": ""int"", ""lineNumber"": 296, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &sw)"", ""typeFullName"": ""int"", ""lineNumber"": 605, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w)"", ""typeFullName"": ""int"", ""lineNumber"": 187, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &(t2p->tiff_width))"", ""typeFullName"": ""int"", ""lineNumber"": 1276, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, pw)"", ""typeFullName"": ""int"", ""lineNumber"": 624, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width)"", ""typeFullName"": ""int"", ""lineNumber"": 152, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width)"", ""typeFullName"": ""int"", ""lineNumber"": 267, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width)"", ""typeFullName"": ""int"", ""lineNumber"": 389, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width)"", ""typeFullName"": ""int"", ""lineNumber"": 494, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tif1, TIFFTAG_IMAGEWIDTH, &imagewidth)"", ""typeFullName"": ""int"", ""lineNumber"": 174, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 9, ""argumentIndex"": 2}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(bias, TIFFTAG_IMAGEWIDTH, &biasWidth)"", ""typeFullName"": ""int"", ""lineNumber"": 908, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 3, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w)"", ""typeFullName"": ""int"", ""lineNumber"": 1785, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width)"", ""typeFullName"": ""int"", ""lineNumber"": 5841, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 9, ""argumentIndex"": 1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w)"", ""typeFullName"": ""int"", ""lineNumber"": 305, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 3, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w)"", ""typeFullName"": ""int"", ""lineNumber"": 341, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 3, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w)"", ""typeFullName"": ""int"", ""lineNumber"": 302, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 3, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w)"", ""typeFullName"": ""int"", ""lineNumber"": 331, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 3, ""argumentIndex"": -1}, {""name"": ""TIFFGetField"", ""signature"": """", ""code"": ""TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth)"", ""typeFullName"": ""int"", ""lineNumber"": 162, ""methodFullName"": ""TIFFGetField"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}]}]","The vulnerability arises from an integer overflow in the `inskew` parameter of `cpStripToTile` (tools/tiffcp.c:1165). `inskew` is calculated as `iskew = imagew - tilew` in callers (tools/tiffcp.c:1354, 1358, 1540), where `imagew` and `tilew` are derived from `TIFFScanlineSize` (libtiff/tif_strip.c:330) and `TIFFTileRowSize` (libtiff/tif_tile.c:181). These functions compute 64-bit sizes via `TIFFScanlineSize64`/`TIFFTileRowSize64` (libtiff/tif_strip.c:273, libtiff/tif_tile.c:143), which depend on the TIFF directory's `td_imagewidth` and `td_tilewidth`. These directory fields are initialized via `TIFFGetField` (e.g., `TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth)` in tools/tiffcp.c:142), confirming user-controlled input from TIFF metadata tags. The overflow occurs when `inskew` (as 32-bit `int` prior to the patch) is used in pointer arithmetic (`in += inskew`), leading to heap-based buffer overflow.",1.0,./github/other_context/CVE-2016-10093
3,CVE-2016-10166,CWE-191,c_cpp,Integer underflow in the _gdContributionsAlloc function in gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via vectors related to decrementing the u variable.,https://github.com/libgd/libgd/commit/60bfb401ad5a4a8ae995dcd36372fe15c71e1a35,"Fix potential unsigned underflow\n\nNo need to decrease `u`, so we don't do it. While we're at it, we also factor\nout the overflow check of the loop, what improves performance and readability.\n\nThis issue has been reported by Stefan Esser to security@libgd.org.",1,"[{""func_name"": ""_gdContributionsAlloc"", ""file_path"": ""src/gd_interpolation.c"", ""func_code"": ""static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}"", ""target"": 0}]","[{""func_name"": ""_gdContributionsAlloc"", ""file_path"": ""src/gd_interpolation.c"", ""func_code"": ""static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tsize_t weights_size;\n\n\tif (overflow2(windows_size, sizeof(double))) {\n\t\treturn NULL;\n\t} else {\n\t\tweights_size = windows_size * sizeof(double);\n\t}\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tres->ContribRow[u].Weights = (double *) gdMalloc(weights_size);\n\t\tif (res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i=0;i<u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}""}]","{""function"": 1, ""code"": 3, ""value"": 3, ""caller"": 4}","[{""source"": ""func_info(file:gd_interpolation.c, func:_gdContributionsAlloc)"", ""result"": [{""code"": ""static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res)..."", ""start_line"": 828, ""end_line"": 867, ""full_name"": ""_gdContributionsAlloc"", ""file_path"": ""src/gd_interpolation.c""}]}, {""source"": ""code_info(file:gd_interpolation.c, lines:830-860)"", ""result"": ""\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n""}, {""source"": ""value_info(file:gd_interpolation.c, value:windows_size)"", ""result"": {""value_trace"": [{""full_code"": ""windows_size = 2 * (int)ceil(width_d) + 1"", ""line"": 895, ""func_name"": ""_gdContributionsCalc""}], ""struct_var"": ""windows_size"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""caller_info(file:gd_interpolation.c, func:_gdContributionsAlloc)"", ""result"": [{""call_line"": 896, ""call_code"": ""_gdContributionsAlloc(line_size, windows_size)"", ""caller_code"": ""static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\tif (res == NULL) {\n\t\treturn NULL;\n\t}\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\t/* get the significant edge points affecting the pixel */\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\t\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\n\t\t/* Cut edge points to fit in filter window in case of spill-off */\n\t\tif (iRight - iLeft + 1 > windows_size)  {\n..."", ""caller_start"": 879, ""file_path"": ""src/gd_interpolation.c""}]}, {""source"": ""value_info(file:gd_interpolation.c, value:windows_size)"", ""result"": {""value_trace"": [{""full_code"": ""windows_size = 2 * (int)ceil(width_d) + 1"", ""line"": 895, ""func_name"": ""_gdContributionsCalc""}], ""struct_var"": ""windows_size"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""caller_info(file:gd_interpolation.c, func:_gdContributionsCalc)"", ""result"": [{""call_line"": 992, ""call_code"": ""_gdContributionsCalc(dst_len, src_len,\n                                   (double)dst_len / (double)src_len,\n                                   pSrc->interpolation)"", ""caller_code"": ""static inline int\n_gdScalePass(const gdImagePtr pSrc, const unsigned int src_len,\n             const gdImagePtr pDst, const unsigned int dst_len,\n             const unsigned int num_lines,\n             const gdAxis axis)\n{\n\tunsigned int line_ndx;\n\tLineContribType * contrib;\n\n    /* Same dim, just copy it. */\n    assert(dst_len != src_len); // TODO: caller should handle this.\n\n\tcontrib = _gdContributionsCalc(dst_len, src_len,\n                                   (double)dst_len / (double)src_len,\n                                   pSrc->interpolation);\n\tif (contrib == NULL) {\n\t\treturn 0;\n\t}\n\n\t/* Scale each line */\n    for (line_ndx = 0; line_ndx < num_lines; line_ndx++) {\n        _gdScaleOneAxis(pSrc, pDst, dst_len, line_ndx, contrib, axis);\n\t}\n\t_gdContributionsFree (contrib);\n    return 1;\n}"", ""caller_start"": 980, ""file_path"": ""src/gd_interpolation.c""}]}, {""source"": ""value_info(file:gd_interpolation.c, value:width_d)"", ""result"": {""value_trace"": [{""full_code"": ""width_d = filter_width_d / scale_d"", ""line"": 889, ""func_name"": ""_gdContributionsCalc""}, {""full_code"": ""width_d= filter_width_d"", ""line"": 892, ""func_name"": ""_gdContributionsCalc""}], ""struct_var"": ""width_d"", ""struct_type"": ""double"", ""struct_definition"": ""double""}}, {""source"": ""caller_info(file:gd_interpolation.c, func:_gdScalePass)"", ""result"": [{""call_line"": 1040, ""call_code"": ""_gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL)"", ""caller_code"": ""static gdImagePtr\ngdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n\tint scale_pass_res;\n\n\tassert(src != NULL);\n\n    /* First, handle the trivial case. */\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }/* if */\n\n\t/* Convert to truecolor if it isn't; this code requires it. */\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}/* if */\n\n    /* Scale horizontally unless sizes are the same. */\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\n\t\tscale_pass_res = _gdScalePass(src, src_width, tmp_im, n..."", ""caller_start"": 1008, ""file_path"": ""src/gd_interpolation.c""}, {""call_line"": 1057, ""call_code"": ""_gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL)"", ""caller_code"": ""static gdImagePtr\ngdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n\tint scale_pass_res;\n\n\tassert(src != NULL);\n\n    /* First, handle the trivial case. */\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }/* if */\n\n\t/* Convert to truecolor if it isn't; this code requires it. */\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}/* if */\n\n    /* Scale horizontally unless sizes are the same. */\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\n\t\tscale_pass_res = _gdScalePass(src, src_width, tmp_im, n..."", ""caller_start"": 1008, ""file_path"": ""src/gd_interpolation.c""}]}, {""source"": ""code_info(file:gd_interpolation.c, lines:980-1000)"", ""result"": ""static inline int\n_gdScalePass(const gdImagePtr pSrc, const unsigned int src_len,\n             const gdImagePtr pDst, const unsigned int dst_len,\n             const unsigned int num_lines,\n             const gdAxis axis)\n{\n\tunsigned int line_ndx;\n\tLineContribType * contrib;\n\n    /* Same dim, just copy it. */\n    assert(dst_len != src_len); // TODO: caller should handle this.\n\n\tcontrib = _gdContributionsCalc(dst_len, src_len,\n                                   (double)dst_len / (double)src_len,\n                                   pSrc->interpolation);\n\tif (contrib == NULL) {\n\t\treturn 0;\n\t}\n\n\t/* Scale each line */\n    for (line_ndx = 0; line_ndx < num_lines; line_ndx++) {\n        _gdScaleOneAxis(pSrc, pDst, dst_len, line_ndx, contrib, axis);\n""}, {""source"": ""code_info(file:gd_interpolation.c, lines:1008-1080)"", ""result"": ""static gdImagePtr\ngdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n\tint scale_pass_res;\n\n\tassert(src != NULL);\n\n    /* First, handle the trivial case. */\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }/* if */\n\n\t/* Convert to truecolor if it isn't; this code requires it. */\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}/* if */\n\n    /* Scale horizontally unless sizes are the same. */\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\n\t\tscale_pass_res = _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n\t\tif (scale_pass_res != 1) {\n\t\t\tgdImageDestroy(tmp_im);\n\t\t\treturn NULL;\n\t\t}\n    }/* if .. else*/\n\n    /* If vertical sizes match, we're done. */\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }/* if */\n\n    /* Otherwise, we need to scale vertically. */\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        scale_pass_res = _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n\t\tif (scale_pass_res != 1) {\n\t\t\tgdImageDestroy(dst);\n\t\t\tif (src != tmp_im) {\n\t\t\t\tgdImageDestroy(tmp_im);\n\t\t\t}\n\t\t\treturn NULL;\n\t   }\n    }/* if */\n\n\n\tif (src != tmp_im) {\n        gdImageDestroy(tmp_im);\n    }/* if */\n\n\treturn dst;\n}/* gdImageScaleTwoPass*/\n\n\n/*\n\tBilinearFixed, BicubicFixed and nearest implementations are\n\trewamped versions of the implementation in CBitmapEx\n\n\thttp://www.codeproject.com/Articles/29121/CBitmapEx-Free-C-Bitmap-Manipulation-Class\n\n""}, {""source"": ""caller_info(file:gd_interpolation.c, func:gdImageScaleTwoPass)"", ""result"": [{""call_line"": 1664, ""call_code"": ""gdImageScaleTwoPass(src, new_width, new_height)"", ""caller_code"": ""BGD_DECLARE(gdImagePtr) gdImageScale(const gdImagePtr src, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr im_scaled = NULL;\n\n\tif (src == NULL || (uintmax_t)src->interpolation_id >= GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\n\tif (new_width == 0 || new_height == 0) {\n\t\treturn NULL;\n\t}\n\tif (new_width == gdImageSX(src) && new_height == gdImageSY(src)) {\n\t\treturn gdImageClone(src);\n\t}\n\tswitch (src->interpolation_id) {\n\t\t/*Special cases, optimized implementations */\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\tim_scaled = gdImageScaleNearestNeighbour(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_LINEAR:\n\t\t\tim_scaled = gdImageScaleBilinear(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\tcase GD_BICUBIC:\n\t\t\tim_scaled = gdImageScaleBicubicFixed(src, new_width, new_height);\n\t\t\tbreak;\n\n\t\t/* generic */\n\t\tdefault:\n\t\t\tif (src->interpolation == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tim_scaled = gdImageScaleTwoPass(src, new_width, new_height);\n\t\t..."", ""caller_start"": 1629, ""file_path"": ""src/gd_interpolation.c""}]}]","src/gd_interpolation.c:848-853: Original code decrements unsigned 'u' (u--) during error handling. If u=0, this causes underflow (wrapping to 0xFFFFFFFF). The loop for freeing memory uses i<=u, leading to excessive iterations and potential out-of-bounds access. Patch removes u-- and adjusts loop to i<u, eliminating underflow. Trigger chain: user-controlled new_width/new_height (src/gd_interpolation.c:1629)  dst_len/src_len (gdImageScaleTwoPass)  line_length/windows_size (_gdContributionsCalc)  error path in _gdContributionsAlloc.",0.95,./github/other_context/CVE-2016-10166
4,CVE-2016-10168,CWE-190,c_cpp,Integer overflow in gd_io.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via vectors involving the number of horizontal and vertical chunks in an image.,https://github.com/libgd/libgd/commit/69d2fd2c597ffc0c217de1238b9bf4d4bceba8e6,"Fix #354: Signed Integer Overflow gd_io.c\n\nGD2 stores the number of horizontal and vertical chunks as words (i.e. 2\nbyte unsigned). These values are multiplied and assigned to an int when\nreading the image, what can cause integer overflows. We have to avoid\nthat, and also make sure that either chunk count is actually greater\nthan zero. If illegal chunk counts are detected, we bail out from\nreading the image.",1,"[{""func_name"": ""_gd2GetHeader"", ""file_path"": ""src/gd_gd2.c"", ""func_code"": ""static int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\""Reading gd2 header info\\n\""));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\""Got file code: %s\\n\"", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\""Not a valid gd2 file\\n\""));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""Version: %d\\n\"", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\""Bad version: %d\\n\"", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\""Could not get x-size\\n\""));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\""Could not get y-size\\n\""));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\""Image is %dx%d\\n\"", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""ChunkSize: %d\\n\"", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\""Bad chunk size: %d\\n\"", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""Format: %d\\n\"", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\""Bad data format: %d\\n\"", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""%d Chunks Wide\\n\"", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""%d Chunks vertically\\n\"", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\n\t\tGD2_DBG (printf (\""Reading %d chunk index entries\\n\"", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\""gd2 header complete\\n\""));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""_gd2GetHeader"", ""file_path"": ""src/gd_gd2.c"", ""func_code"": ""static int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\""Reading gd2 header info\\n\""));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\""Got file code: %s\\n\"", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\""Not a valid gd2 file\\n\""));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""Version: %d\\n\"", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\""Bad version: %d\\n\"", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\""Could not get x-size\\n\""));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\""Could not get y-size\\n\""));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\""Image is %dx%d\\n\"", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""ChunkSize: %d\\n\"", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\""Bad chunk size: %d\\n\"", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""Format: %d\\n\"", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\""Bad data format: %d\\n\"", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""%d Chunks Wide\\n\"", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""%d Chunks vertically\\n\"", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tif (*ncx <= 0 || *ncy <= 0 || *ncx > INT_MAX / *ncy) {\n\t\t\tGD2_DBG(printf (\""Illegal chunk counts: %d * %d\\n\"", *ncx, *ncy));\n\t\t\tgoto fail1;\n\t\t}\n\t\tnc = (*ncx) * (*ncy);\n\n\t\tGD2_DBG (printf (\""Reading %d chunk index entries\\n\"", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\""gd2 header complete\\n\""));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}""}]","{""code"": 8, ""function"": 1}","[{""source"": ""code_info(file:gd_gd2.c, lines:190-210)"", ""result"": ""\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\""Bad data format: %d\\n\"", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""%d Chunks Wide\\n\"", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""%d Chunks vertically\\n\"", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n""}, {""source"": ""func_info(func:gdGetWord)"", ""result"": [{""code"": ""int gdGetWord(int *result, gdIOCtx *ctx)\n{\n\tint r;\n\n\tr = (ctx->getC)(ctx);\n\tif(r == EOF) {\n\t\treturn 0;\n\t}\n\n\t*result = r << 8;\n\n\tr = (ctx->getC)(ctx);\n\tif(r == EOF) {\n\t\treturn 0;\n\t}\n\n\t*result += r;\n\n\treturn 1;\n}"", ""start_line"": 89, ""end_line"": 108, ""full_name"": ""gdGetWord"", ""file_path"": ""src/gd_io.c""}]}, {""source"": ""code_info(file:gd_gd2.c, lines:215-230)"", ""result"": ""\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n""}, {""source"": ""code_info(file:gd_gd2.c, lines:180-200)"", ""result"": ""\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\""Bad chunk size: %d\\n\"", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""Format: %d\\n\"", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\""Bad data format: %d\\n\"", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n""}, {""source"": ""code_info(file:gd_gd2.c, lines:180-200)"", ""result"": ""\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\""Bad chunk size: %d\\n\"", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""Format: %d\\n\"", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\""Bad data format: %d\\n\"", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n""}, {""source"": ""code_info(file:gd_gd2.c, lines:180-200)"", ""result"": ""\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\""Bad chunk size: %d\\n\"", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""Format: %d\\n\"", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\""Bad data format: %d\\n\"", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n""}, {""source"": ""code_info(file:gd_gd2.c, lines:180-200)"", ""result"": ""\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\""Bad chunk size: %d\\n\"", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""Format: %d\\n\"", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\""Bad data format: %d\\n\"", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n""}, {""source"": ""code_info(file:gd_gd2.c, lines:170-190)"", ""result"": ""\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\""Image is %dx%d\\n\"", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""ChunkSize: %d\\n\"", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\""Bad chunk size: %d\\n\"", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""Format: %d\\n\"", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n""}, {""source"": ""code_info(file:gd_gd2.c, lines:160-180)"", ""result"": ""\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\""Could not get x-size\\n\""));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\""Could not get y-size\\n\""));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\""Image is %dx%d\\n\"", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\""ChunkSize: %d\\n\"", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\""Bad chunk size: %d\\n\"", *cs));\n""}]","src/gd_gd2.c:210-214: Multiplication of *ncx (read as 2-byte unsigned via gdGetWord in src/gd_io.c:89-108) and *ncy (same) into 'nc' (signed int) without overflow checks. *ncx and *ncy are populated via gdGetWord, which reads 2-byte unsigned values into int variables. The overflowed 'nc' is used in memory allocation (src/gd_gd2.c:215-230). The patch adds checks to prevent overflow.",0.95,./github/other_context/CVE-2016-10168
5,CVE-2016-5094,CWE-190,c_cpp,Integer overflow in the php_html_entities function in ext/standard/html.c in PHP before 5.5.36 and 5.6.x before 5.6.22 allows remote attackers to cause a denial of service or possibly have unspecified other impact by triggering a large output string from the htmlspecialchars function.,https://github.com/php/php-src/commit/0da8b8b801f9276359262f1ef8274c7812d3dfda,Fix bug #72135 - don't create strings with lengths outside int range,13,"[{""func_name"": ""find_entity_for_char"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline void find_entity_for_char(\n\tunsigned int k,\n\tenum entity_charset charset,\n\tconst entity_stage1_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len,\n\tunsigned char *old,\n\tsize_t oldlen,\n\tsize_t *cursor)\n{\n\tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n\tconst entity_stage3_row *c;\n\t\n\tif (stage1_idx > 0x1D) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\n\tc = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)];\n\n\tif (!c->ambiguous) {\n\t\t*entity     = (const unsigned char *)c->data.ent.entity;\n\t\t*entity_len = c->data.ent.entity_len;\n\t} else {\n\t\t/* peek at next char */\n\t\tsize_t\t cursor_before\t= *cursor;\n\t\tint\t\t status\t\t\t= SUCCESS;\n\t\tunsigned next_char;\n\n\t\tif (!(*cursor < oldlen))\n\t\t\tgoto no_suitable_2nd;\n\n\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status); \n\n\t\tif (status == FAILURE)\n\t\t\tgoto no_suitable_2nd;\n\n\t\t{\n\t\t\tconst entity_multicodepoint_row *s, *e;\n\n\t\t\ts = &c->data.multicodepoint_table[1];\n\t\t\te = s - 1 + c->data.multicodepoint_table[0].leading_entry.size;\n\t\t\t/* we could do a binary search but it's not worth it since we have\n\t\t\t * at most two entries... */\n\t\t\tfor ( ; s <= e; s++) {\n\t\t\t\tif (s->normal_entry.second_cp == next_char) {\n\t\t\t\t\t*entity     = s->normal_entry.entity;\n\t\t\t\t\t*entity_len = s->normal_entry.entity_len;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nno_suitable_2nd:\n\t\t*cursor = cursor_before;\n\t\t*entity = (const unsigned char *)\n\t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n\t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n\t}\t\n}"", ""target"": 0}, {""func_name"": ""php_escape_html_entities_ex"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""PHPAPI char *php_escape_html_entities_ex(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset, zend_bool double_encode TSRMLS_DC)\n{\n\tsize_t cursor, maxlen, len;\n\tchar *replaced;\n\tenum entity_charset charset = determine_charset(hint_charset TSRMLS_CC);\n\tint doctype = flags & ENT_HTML_DOC_TYPE_MASK;\n\tentity_table_opt entity_table;\n\tconst enc_to_uni *to_uni_table = NULL;\n\tconst entity_ht *inv_map = NULL; /* used for !double_encode */\n\t/* only used if flags includes ENT_HTML_IGNORE_ERRORS or ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS */\n\tconst unsigned char *replacement = NULL;\n\tsize_t replacement_len = 0;\n\n\tif (all) { /* replace with all named entities */\n\t\tif (CHARSET_PARTIAL_SUPPORT(charset)) {\n\t\t\tphp_error_docref0(NULL TSRMLS_CC, E_STRICT, \""Only basic entities \""\n\t\t\t\t\""substitution is supported for multi-byte encodings other than UTF-8; \""\n\t\t\t\t\""functionality is equivalent to htmlspecialchars\"");\n\t\t}\n\t\tLIMIT_ALL(all, doctype, charset);\n\t}\n\tentity_table = determine_entity_table(all, doctype);\n\tif (all && !CHARSET_UNICODE_COMPAT(charset)) {\n\t\tto_uni_table = enc_to_uni_index[charset];\n\t}\n\n\tif (!double_encode) {\n\t\t/* first arg is 1 because we want to identify valid named entities\n\t\t * even if we are only encoding the basic ones */\n\t\tinv_map = unescape_inverse_map(1, flags);\n\t}\n\n\tif (flags & (ENT_HTML_SUBSTITUTE_ERRORS | ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS)) {\n\t\tif (charset == cs_utf_8) {\n\t\t\treplacement = (const unsigned char*)\""\\xEF\\xBF\\xBD\"";\n\t\t\treplacement_len = sizeof(\""\\xEF\\xBF\\xBD\"") - 1;\n\t\t} else {\n\t\t\treplacement = (const unsigned char*)\""&#xFFFD;\"";\n\t\t\treplacement_len = sizeof(\""&#xFFFD;\"") - 1;\n\t\t}\n\t}\n\n\t/* initial estimate */\n\tif (oldlen < 64) {\n\t\tmaxlen = 128;\t\n\t} else {\n\t\tmaxlen = 2 * oldlen;\n\t\tif (maxlen < oldlen) {\n\t\t\tzend_error_noreturn(E_ERROR, \""Input string is too long\"");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treplaced = emalloc(maxlen + 1); /* adding 1 is safe: maxlen is even */\n\tlen = 0;\n\tcursor = 0;\n\twhile (cursor < oldlen) {\n\t\tconst unsigned char *mbsequence = NULL;\n\t\tsize_t mbseqlen\t\t\t\t\t= 0,\n\t\t       cursor_before\t\t\t= cursor;\n\t\tint status\t\t\t\t\t\t= SUCCESS;\n\t\tunsigned int this_char\t\t\t= get_next_char(charset, old, oldlen, &cursor, &status);\n\n\t\t/* guarantee we have at least 40 bytes to write.\n\t\t * In HTML5, entities may take up to 33 bytes */\n\t\tif (len > maxlen - 40) { /* maxlen can never be smaller than 128 */\n\t\t\treplaced = safe_erealloc(replaced, maxlen , 1, 128 + 1);\n\t\t\tmaxlen += 128;\n\t\t}\n\n\t\tif (status == FAILURE) {\n\t\t\t/* invalid MB sequence */\n\t\t\tif (flags & ENT_HTML_IGNORE_ERRORS) {\n\t\t\t\tcontinue;\n\t\t\t} else if (flags & ENT_HTML_SUBSTITUTE_ERRORS) {\n\t\t\t\tmemcpy(&replaced[len], replacement, replacement_len);\n\t\t\t\tlen += replacement_len;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tefree(replaced);\n\t\t\t\t*newlen = 0;\n\t\t\t\treturn STR_EMPTY_ALLOC();\n\t\t\t}\n\t\t} else { /* SUCCESS */\n\t\t\tmbsequence = &old[cursor_before];\n\t\t\tmbseqlen = cursor - cursor_before;\n\t\t}\n\n\t\tif (this_char != '&') { /* no entity on this position */\n\t\t\tconst unsigned char *rep\t= NULL;\n\t\t\tsize_t\t\t\t\trep_len\t= 0;\n\n\t\t\tif (((this_char == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t(this_char == '\""' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\tgoto pass_char_through;\n\n\t\t\tif (all) { /* false that CHARSET_PARTIAL_SUPPORT(charset) */\n\t\t\t\tif (to_uni_table != NULL) {\n\t\t\t\t\t/* !CHARSET_UNICODE_COMPAT therefore not UTF-8; since UTF-8\n\t\t\t\t\t * is the only multibyte encoding with !CHARSET_PARTIAL_SUPPORT,\n\t\t\t\t\t * we're using a single byte encoding */\n\t\t\t\t\tmap_to_unicode(this_char, to_uni_table, &this_char);\n\t\t\t\t\tif (this_char == 0xFFFF) /* no mapping; pass through */\n\t\t\t\t\t\tgoto pass_char_through;\n\t\t\t\t}\n\t\t\t\t/* the cursor may advance */\n\t\t\t\tfind_entity_for_char(this_char, charset, entity_table.ms_table, &rep,\n\t\t\t\t\t&rep_len, old, oldlen, &cursor);\n\t\t\t} else {\n\t\t\t\tfind_entity_for_char_basic(this_char, entity_table.table, &rep, &rep_len);\n\t\t\t}\n\n\t\t\tif (rep != NULL) {\n\t\t\t\treplaced[len++] = '&';\n\t\t\t\tmemcpy(&replaced[len], rep, rep_len);\n\t\t\t\tlen += rep_len;\n\t\t\t\treplaced[len++] = ';';\n\t\t\t} else {\n\t\t\t\t/* we did not find an entity for this char.\n\t\t\t\t * check for its validity, if its valid pass it unchanged */\n\t\t\t\tif (flags & ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS) {\n\t\t\t\t\tif (CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\t\t\tif (!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (to_uni_table) {\n\t\t\t\t\t\tif (!all) /* otherwise we already did this */\n\t\t\t\t\t\t\tmap_to_unicode(this_char, to_uni_table, &this_char);\n\t\t\t\t\t\tif (!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* not a unicode code point, unless, coincidentally, it's in\n\t\t\t\t\t\t * the 0x20..0x7D range (except 0x5C in sjis). We know nothing\n\t\t\t\t\t\t * about other code points, because we have no tables. Since\n\t\t\t\t\t\t * Unicode code points in that range are not disallowed in any\n\t\t\t\t\t\t * document type, we could do nothing. However, conversion\n\t\t\t\t\t\t * tables frequently map 0x00-0x1F to the respective C0 code\n\t\t\t\t\t\t * points. Let's play it safe and admit that's the case */\n\t\t\t\t\t\tif (this_char <= 0x7D &&\n\t\t\t\t\t\t\t\t!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\npass_char_through:\n\t\t\t\tif (mbseqlen > 1) {\n\t\t\t\t\tmemcpy(replaced + len, mbsequence, mbseqlen);\n\t\t\t\t\tlen += mbseqlen;\n\t\t\t\t} else {\n\t\t\t\t\treplaced[len++] = mbsequence[0];\n\t\t\t\t}\n\t\t\t}\n\t\t} else { /* this_char == '&' */\n\t\t\tif (double_encode) {\nencode_amp:\n\t\t\t\tmemcpy(&replaced[len], \""&amp;\"", sizeof(\""&amp;\"") - 1);\n\t\t\t\tlen += sizeof(\""&amp;\"") - 1;\n\t\t\t} else { /* no double encode */\n\t\t\t\t/* check if entity is valid */\n\t\t\t\tsize_t ent_len; /* not counting & or ; */\n\t\t\t\t/* peek at next char */\n\t\t\t\tif (old[cursor] == '#') { /* numeric entity */\n\t\t\t\t\tunsigned code_point;\n\t\t\t\t\tint valid;\n\t\t\t\t\tchar *pos = (char*)&old[cursor+1];\n\t\t\t\t\tvalid = process_numeric_entity((const char **)&pos, &code_point);\n\t\t\t\t\tif (valid == FAILURE)\n\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\tif (flags & ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS) {\n\t\t\t\t\t\tif (!numeric_entity_is_allowed(code_point, doctype))\n\t\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\t}\n\t\t\t\t\tent_len = pos - (char*)&old[cursor];\n\t\t\t\t} else { /* named entity */\n\t\t\t\t\t/* check for vality of named entity */\n\t\t\t\t\tconst char *start = &old[cursor],\n\t\t\t\t\t\t\t   *next = start;\n\t\t\t\t\tunsigned   dummy1, dummy2;\n\n\t\t\t\t\tif (process_named_entity_html(&next, &start, &ent_len) == FAILURE)\n\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\tif (resolve_named_entity_html(start, ent_len, inv_map, &dummy1, &dummy2) == FAILURE) {\n\t\t\t\t\t\tif (!(doctype == ENT_HTML_DOC_XHTML && ent_len == 4 && start[0] == 'a'\n\t\t\t\t\t\t\t\t\t&& start[1] == 'p' && start[2] == 'o' && start[3] == 's')) {\n\t\t\t\t\t\t\t/* uses html4 inv_map, which doesn't include apos;. This is a\n\t\t\t\t\t\t\t * hack to support it */\n\t\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* checks passed; copy entity to result */\n\t\t\t\t/* entity size is unbounded, we may need more memory */\n\t\t\t\t/* at this point maxlen - len >= 40 */\n\t\t\t\tif (maxlen - len < ent_len + 2 /* & and ; */) {\n\t\t\t\t\t/* ent_len < oldlen, which is certainly <= SIZE_MAX/2 */\n\t\t\t\t\treplaced = safe_erealloc(replaced, maxlen, 1, ent_len + 128 + 1);\n\t\t\t\t\tmaxlen += ent_len + 128;\n\t\t\t\t}\n\t\t\t\treplaced[len++] = '&';\n\t\t\t\tmemcpy(&replaced[len], &old[cursor], ent_len);\n\t\t\t\tlen += ent_len;\n\t\t\t\treplaced[len++] = ';';\n\t\t\t\tcursor += ent_len + 1;\n\t\t\t}\n\t\t}\n\t}\n\treplaced[len] = '\\0';\n\t*newlen = len;\n\n\treturn replaced;\n}"", ""target"": 1}, {""func_name"": ""get_next_char"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline unsigned int get_next_char(\n\t\tenum entity_charset charset,\n\t\tconst unsigned char *str,\n\t\tsize_t str_len,\n\t\tsize_t *cursor,\n\t\tint *status)\n{\n\tsize_t pos = *cursor;\n\tunsigned int this_char = 0;\n\n\t*status = SUCCESS;\n\tassert(pos <= str_len);\n\n\tif (!CHECK_LEN(pos, 1))\n\t\tMB_FAILURE(pos, 1);\n\n\tswitch (charset) {\n\tcase cs_utf_8:\n\t\t{\n\t\t\t/* We'll follow strategy 2. from section 3.6.1 of UTR #36:\n\t\t\t * \""In a reported illegal byte sequence, do not include any\n\t\t\t *  non-initial byte that encodes a valid character or is a leading\n\t\t\t *  byte for a valid sequence.\"" */\n\t\t\tunsigned char c;\n\t\t\tc = str[pos];\n\t\t\tif (c < 0x80) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos++;\n\t\t\t} else if (c < 0xc2) {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t} else if (c < 0xe0) {\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tif (!utf8_trail(str[pos + 1])) {\n\t\t\t\t\tMB_FAILURE(pos, utf8_lead(str[pos + 1]) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tthis_char = ((c & 0x1f) << 6) | (str[pos + 1] & 0x3f);\n\t\t\t\tif (this_char < 0x80) { /* non-shortest form */\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c < 0xf0) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 3 ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 1]) || !utf8_trail(str[pos + 2])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t}\n\n\t\t\t\tthis_char = ((c & 0x0f) << 12) | ((str[pos + 1] & 0x3f) << 6) | (str[pos + 2] & 0x3f);\n\t\t\t\tif (this_char < 0x800) { /* non-shortest form */\n\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t} else if (this_char >= 0xd800 && this_char <= 0xdfff) { /* surrogate */\n\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t}\n\t\t\t\tpos += 3;\n\t\t\t} else if (c < 0xf5) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 4 ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 1]) || !utf8_trail(str[pos + 2]) ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 3])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse if (avail < 4 || utf8_lead(str[pos + 3]))\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n\t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\n\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\tpos += 4;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5:\n\t\t/* reference http://demo.icu-project.org/icu-bin/convexp?conv=big5 */\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0x81 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif ((next >= 0x40 && next <= 0x7E) ||\n\t\t\t\t\t\t(next >= 0xA1 && next <= 0xFE)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5hkscs:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0x81 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif ((next >= 0x40 && next <= 0x7E) ||\n\t\t\t\t\t\t(next >= 0xA1 && next <= 0xFE)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (next != 0x80 && next != 0xFF) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_gb2312: /* EUC-CN */\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0xA1 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (gb2312_trail(next)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (gb2312_lead(next)) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (gb2312_lead(c)) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_sjis:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif ((c >= 0x81 && c <= 0x9F) || (c >= 0xE0 && c <= 0xFC)) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (sjis_trail(next)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (sjis_lead(next)) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c < 0x80 || (c >= 0xA1 && c <= 0xDF)) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_eucjp:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\n\t\t\tif (c >= 0xA1 && c <= 0xFE) {\n\t\t\t\tunsigned next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (next >= 0xA1 && next <= 0xFE) {\n\t\t\t\t\t/* this a jis kanji char */\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, (next != 0xA0 && next != 0xFF) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c == 0x8E) {\n\t\t\t\tunsigned next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\t\t\t\tif (next >= 0xA1 && next <= 0xDF) {\n\t\t\t\t\t/* JIS X 0201 kana */\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, (next != 0xA0 && next != 0xFF) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c == 0x8F) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 3 || !(str[pos + 1] >= 0xA1 && str[pos + 1] <= 0xFE) ||\n\t\t\t\t\t\t!(str[pos + 2] >= 0xA1 && str[pos + 2] <= 0xFE)) {\n\t\t\t\t\tif (avail < 2 || (str[pos + 1] != 0xA0 && str[pos + 1] != 0xFF))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || (str[pos + 2] != 0xA0 && str[pos + 2] != 0xFF))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t} else {\n\t\t\t\t\t/* JIS X 0212 hojo-kanji */\n\t\t\t\t\tthis_char = (c << 16) | (str[pos + 1] << 8) | str[pos + 2];\n\t\t\t\t}\n\t\t\t\tpos += 3;\n\t\t\t} else if (c != 0xA0 && c != 0xFF) {\n\t\t\t\t/* character encoded in 1 code unit */\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* single-byte charsets */\n\t\tthis_char = str[pos++];\n\t\tbreak;\n\t}\n\n\t*cursor = pos;\n  \treturn this_char;\n}"", ""target"": 0}, {""func_name"": ""unimap_bsearch"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\n\t/* we have no mappings outside the BMP */\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\n\tcode_key = (unsigned short) code_key_a;\n\t\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}"", ""target"": 2}, {""func_name"": ""php_unescape_html_entities"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; /* charset shouldn't matter, use ISO-8859-1 for performance */\n\t}\n\n\t/* don't use LIMIT_ALL! */\n\n\tif (oldlen > new_size) {\n\t\t/* overflow, refuse to do anything */\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\t\n\tinverse_map = unescape_inverse_map(all, flags);\n\t\n\t/* replace numeric entities */\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\n\nempty_source:\t\n\t*newlen = retlen;\n\treturn ret;\n}"", ""target"": 1}, {""func_name"": ""unicode_cp_is_allowed"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n{\n\t/* XML 1.0\t\t\t\tHTML 4.01\t\t\tHTML 5\n\t * 0x09..0x0A\t\t\t0x09..0x0A\t\t\t0x09..0x0A\n\t * 0x0D\t\t\t\t\t0x0D\t\t\t\t0x0C..0x0D\n\t * 0x0020..0xD7FF\t\t0x20..0x7E\t\t\t0x20..0x7E\n\t *\t\t\t\t\t\t0x00A0..0xD7FF\t\t0x00A0..0xD7FF\n\t * 0xE000..0xFFFD\t\t0xE000..0x10FFFF\t0xE000..0xFDCF\n\t * 0x010000..0x10FFFF\t\t\t\t\t\t0xFDF0..0x10FFFF (*)\n\t *\n\t * (*) exclude code points where ((code & 0xFFFF) >= 0xFFFE)\n\t *\n\t * References:\n\t * XML 1.0:   <http://www.w3.org/TR/REC-xml/#charsets>\n\t * HTML 4.01: <http://www.w3.org/TR/1999/PR-html40-19990824/sgml/sgmldecl.html>\n\t * HTML 5:    <http://dev.w3.org/html5/spec/Overview.html#preprocessing-the-input-stream>\n\t *\n\t * Not sure this is the relevant part for HTML 5, though. I opted to\n\t * disallow the characters that would result in a parse error when\n\t * preprocessing of the input stream. See also section 8.1.3.\n\t * \n\t * It's unclear if XHTML 1.0 allows C1 characters. I'll opt to apply to\n\t * XHTML 1.0 the same rules as for XML 1.0.\n\t * See <http://cmsmcq.com/2007/C1.xml>.\n\t */\n\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\n\tcase ENT_HTML_DOC_HTML5:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || /* form feed U+0C allowed */\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && /* last two of each plane (nonchars) disallowed */\n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); /* U+FDD0-U+FDEF (nonchars) disallowed */\n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\n\tdefault:\n\t\treturn 1;\n\t}\n}"", ""target"": 1}, {""func_name"": ""map_from_unicode"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline int map_from_unicode(unsigned code, enum entity_charset charset, unsigned *res)\n{\n\tunsigned char found;\n\tconst uni_to_enc *table;\n\tsize_t table_size;\n\n\tswitch (charset) {\n\tcase cs_8859_1:\n\t\t/* identity mapping of code points to unicode */\n\t\tif (code > 0xFF) {\n\t\t\treturn FAILURE;\n\t\t} \n\t\t*res = code;\n\t\tbreak;\n\n\tcase cs_8859_5:\n\t\tif (code <= 0xA0 || code == 0xAD /* soft hyphen */) {\n\t\t\t*res = code;\n\t\t} else if (code == 0x2116) {\n\t\t\t*res = 0xF0; /* numero sign */\n\t\t} else if (code == 0xA7) {\n\t\t\t*res = 0xFD; /* section sign */\n\t\t} else if (code >= 0x0401 && code <= 0x044F) {\n\t\t\tif (code == 0x040D || code == 0x0450 || code == 0x045D)\n\t\t\t\treturn FAILURE;\n\t\t\t*res = code - 0x360;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\t\t\n\tcase cs_8859_15:\n\t\tif (code < 0xA4 || (code > 0xBE && code <= 0xFF)) {\n\t\t\t*res = code;\n\t\t} else { /* between A4 and 0xBE */\n\t\t\tfound = unimap_bsearch(unimap_iso885915,\n\t\t\t\tcode, sizeof(unimap_iso885915) / sizeof(*unimap_iso885915));\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_cp1252:\n\t\tif (code <= 0x7F || (code >= 0xA0 && code <= 0xFF)) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\tfound = unimap_bsearch(unimap_win1252,\n\t\t\t\tcode, sizeof(unimap_win1252) / sizeof(*unimap_win1252));\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_macroman:\n\t\tif (code == 0x7F)\n\t\t\treturn FAILURE;\n\t\ttable = unimap_macroman;\n\t\ttable_size = sizeof(unimap_macroman) / sizeof(*unimap_macroman);\n\t\tgoto table_over_7F;\n\tcase cs_cp1251:\n\t\ttable = unimap_win1251;\n\t\ttable_size = sizeof(unimap_win1251) / sizeof(*unimap_win1251);\n\t\tgoto table_over_7F;\n\tcase cs_koi8r:\n\t\ttable = unimap_koi8r;\n\t\ttable_size = sizeof(unimap_koi8r) / sizeof(*unimap_koi8r);\n\t\tgoto table_over_7F;\n\tcase cs_cp866:\n\t\ttable = unimap_cp866;\n\t\ttable_size = sizeof(unimap_cp866) / sizeof(*unimap_cp866);\n\t\t\ntable_over_7F:\n\t\tif (code <= 0x7F) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\tfound = unimap_bsearch(table, code, table_size);\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\t/* from here on, only map the possible characters in the ASCII range.\n\t * to improve support here, it's a matter of building the unicode mappings.\n\t * See <http://www.unicode.org/Public/6.0.0/ucd/Unihan.zip> */\n\tcase cs_sjis:\n\tcase cs_eucjp:\n\t\t/* we interpret 0x5C as the Yen symbol. This is not universal.\n\t\t * See <http://www.w3.org/Submission/japanese-xml/#ambiguity_of_yen> */\n\t\tif (code >= 0x20 && code <= 0x7D) {\n\t\t\tif (code == 0x5C)\n\t\t\t\treturn FAILURE;\n\t\t\t*res = code;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5:\n\tcase cs_big5hkscs:\n\tcase cs_gb2312:\n\t\tif (code >= 0x20 && code <= 0x7D) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""determine_entity_table"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\t\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}"", ""target"": 2}, {""func_name"": ""process_numeric_entity"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); /* TODO: XML apparently disallows \""X\"" */\n\tchar *endptr;\n\n\tif (hexadecimal && (**buf != '\\0'))\n\t\t(*buf)++;\n\t\t\t\n\t/* strtol allows whitespace and other stuff in the beginning\n\t\t* we're not interested */\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t/* we're guaranteed there were valid digits, so *endptr > buf */\n\t*buf = endptr;\n\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\n\t/* many more are invalid, but that depends on whether it's HTML\n\t * (and which version) or XML. */\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\n\treturn SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""traverse_for_entities"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static void traverse_for_entities(\n\tconst char *old,\n\tsize_t oldlen,\n\tchar *ret, /* should have allocated TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(olden) */\n\tsize_t *retlen,\n\tint all,\n\tint flags,\n\tconst entity_ht *inv_map,\n\tenum entity_charset charset)\n{\n\tconst char *p,\n\t\t\t   *lim;\n\tchar\t   *q;\n\tint doctype = flags & ENT_HTML_DOC_TYPE_MASK;\n\n\tlim = old + oldlen; /* terminator address */\n\tassert(*lim == '\\0');\n\n\tfor (p = old, q = ret; p < lim;) {\n\t\tunsigned code, code2 = 0;\n\t\tconst char *next = NULL; /* when set, next > p, otherwise possible inf loop */\n\n\t\t/* Shift JIS, Big5 and HKSCS use multi-byte encodings where an\n\t\t * ASCII range byte can be part of a multi-byte sequence.\n\t\t * However, they start at 0x40, therefore if we find a 0x26 byte,\n\t\t * we're sure it represents the '&' character. */\n\n\t\t/* assumes there are no single-char entities */\n\t\tif (p[0] != '&' || (p + 3 >= lim)) {\n\t\t\t*(q++) = *(p++);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* now p[3] is surely valid and is no terminator */\n\n\t\t/* numerical entity */\n\t\tif (p[1] == '#') {\n\t\t\tnext = &p[2];\n\t\t\tif (process_numeric_entity(&next, &code) == FAILURE)\n\t\t\t\tgoto invalid_code;\n\n\t\t\t/* If we're in htmlspecialchars_decode, we're only decoding entities\n\t\t\t * that represent &, <, >, \"" and '. Is this one of them? */\n\t\t\tif (!all && (code > 63U ||\n\t\t\t\t\tstage3_table_be_apos_00000[code].data.ent.entity == NULL))\n\t\t\t\tgoto invalid_code;\n\n\t\t\t/* are we allowed to decode this entity in this document type?\n\t\t\t * HTML 5 is the only that has a character that cannot be used in \n\t\t\t * a numeric entity but is allowed literally (U+000D). The\n\t\t\t * unoptimized version would be ... || !numeric_entity_is_allowed(code) */\n\t\t\tif (!unicode_cp_is_allowed(code, doctype) ||\n\t\t\t\t\t(doctype == ENT_HTML_DOC_HTML5 && code == 0x0D))\n\t\t\t\tgoto invalid_code;\n\t\t} else {\n\t\t\tconst char *start;\n\t\t\tsize_t ent_len;\n\n\t\t\tnext = &p[1];\n\t\t\tstart = next;\n\n\t\t\tif (process_named_entity_html(&next, &start, &ent_len) == FAILURE)\n\t\t\t\tgoto invalid_code;\n\n\t\t\tif (resolve_named_entity_html(start, ent_len, inv_map, &code, &code2) == FAILURE) {\n\t\t\t\tif (doctype == ENT_HTML_DOC_XHTML && ent_len == 4 && start[0] == 'a'\n\t\t\t\t\t\t\t&& start[1] == 'p' && start[2] == 'o' && start[3] == 's') {\n\t\t\t\t\t/* uses html4 inv_map, which doesn't include apos;. This is a\n\t\t\t\t\t * hack to support it */\n\t\t\t\t\tcode = (unsigned) '\\'';\n\t\t\t\t} else {\n\t\t\t\t\tgoto invalid_code;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tassert(*next == ';');\n\t\t\n\t\tif (((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t(code == '\""' && !(flags & ENT_HTML_QUOTE_DOUBLE)))\n\t\t\t\t/* && code2 == '\\0' always true for current maps */)\n\t\t\tgoto invalid_code;\n\n\t\t/* UTF-8 doesn't need mapping (ISO-8859-1 doesn't either, but\n\t\t * the call is needed to ensure the codepoint <= U+00FF)  */\n\t\tif (charset != cs_utf_8) {\n\t\t\t/* replace unicode code point */\n\t\t\tif (map_from_unicode(code, charset, &code) == FAILURE || code2 != 0)\n\t\t\t\tgoto invalid_code; /* not representable in target charset */\n\t\t}\n\n\t\tq += write_octet_sequence(q, charset, code);\n\t\tif (code2) {\n\t\t\tq += write_octet_sequence(q, charset, code2);\n\t\t}\n\n\t\t/* jump over the valid entity; may go beyond size of buffer; np */\n\t\tp = next + 1;\n\t\tcontinue;\n\ninvalid_code:\n\t\tfor (; p < next; p++) {\n\t\t\t*(q++) = *p;\n\t\t}\n\t}\n\t\n\t*q = '\\0';\n\t*retlen = (size_t)(q - ret);\n}"", ""target"": 2}, {""func_name"": ""write_s3row_data"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline void write_s3row_data(\n\tconst entity_stage3_row *r,\n\tunsigned orig_cp,\n\tenum entity_charset charset,\n\tzval *arr)\n{\n\tchar key[9] = \""\""; /* two unicode code points in UTF-8 */\n\tchar entity[LONGEST_ENTITY_LENGTH + 2] = {'&'};\n\tsize_t written_k1;\n\n\twritten_k1 = write_octet_sequence(key, charset, orig_cp);\n\n\tif (!r->ambiguous) {\n\t\tsize_t l = r->data.ent.entity_len;\n\t\tmemcpy(&entity[1], r->data.ent.entity, l);\n\t\tentity[l + 1] = ';';\n\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t} else {\n\t\tunsigned i,\n\t\t\t     num_entries;\n\t\tconst entity_multicodepoint_row *mcpr = r->data.multicodepoint_table;\n\n\t\tif (mcpr[0].leading_entry.default_entity != NULL) {\n\t\t\tsize_t l = mcpr[0].leading_entry.default_entity_len;\n\t\t\tmemcpy(&entity[1], mcpr[0].leading_entry.default_entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t\t}\n\t\tnum_entries = mcpr[0].leading_entry.size;\n\t\tfor (i = 1; i <= num_entries; i++) {\n\t\t\tsize_t   l,\n\t\t\t\t     written_k2;\n\t\t\tunsigned uni_cp,\n\t\t\t\t\t spe_cp;\n\n\t\t\tuni_cp = mcpr[i].normal_entry.second_cp;\n\t\t\tl = mcpr[i].normal_entry.entity_len;\n\n\t\t\tif (!CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\tif (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE)\n\t\t\t\t\tcontinue; /* non representable in this charset */\n\t\t\t} else {\n\t\t\t\tspe_cp = uni_cp;\n\t\t\t}\n\t\t\t\n\t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n\t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tentity[l + 1] = '\\0';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + written_k2 + 1, entity, l + 1, 1);\n\t\t}\n\t}\n}"", ""target"": 0}, {""func_name"": ""determine_charset"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static enum entity_charset determine_charset(char *charset_hint TSRMLS_DC)\n{\n\tint i;\n\tenum entity_charset charset = cs_utf_8;\n\tint len = 0;\n\tconst zend_encoding *zenc;\n\n\t/* Default is now UTF-8 */\n\tif (charset_hint == NULL)\n\t\treturn cs_utf_8;\n\n\tif ((len = strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n\n\tzenc = zend_multibyte_get_internal_encoding(TSRMLS_C);\n\tif (zenc != NULL) {\n\t\tcharset_hint = (char *)zend_multibyte_get_encoding_name(zenc);\n\t\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\t\tif ((len == 4) /* sizeof (none|auto|pass) */ &&\n\t\t\t\t\t(!memcmp(\""pass\"", charset_hint, 4) ||\n\t\t\t\t\t !memcmp(\""auto\"", charset_hint, 4) ||\n\t\t\t\t\t !memcmp(\""auto\"", charset_hint, 4))) {\n\t\t\t\tcharset_hint = NULL;\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tgoto det_charset;\n\t\t\t}\n\t\t}\n\t}\n\n\tcharset_hint = SG(default_charset);\n\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n\n\t/* try to detect the charset for the locale */\n#if HAVE_NL_LANGINFO && HAVE_LOCALE_H && defined(CODESET)\n\tcharset_hint = nl_langinfo(CODESET);\n\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n#endif\n\n#if HAVE_LOCALE_H\n\t/* try to figure out the charset from the locale */\n\t{\n\t\tchar *localename;\n\t\tchar *dot, *at;\n\n\t\t/* lang[_territory][.codeset][@modifier] */\n\t\tlocalename = setlocale(LC_CTYPE, NULL);\n\n\t\tdot = strchr(localename, '.');\n\t\tif (dot) {\n\t\t\tdot++;\n\t\t\t/* locale specifies a codeset */\n\t\t\tat = strchr(dot, '@');\n\t\t\tif (at)\n\t\t\t\tlen = at - dot;\n\t\t\telse\n\t\t\t\tlen = strlen(dot);\n\t\t\tcharset_hint = dot;\n\t\t} else {\n\t\t\t/* no explicit name; see if the name itself\n\t\t\t * is the charset */\n\t\t\tcharset_hint = localename;\n\t\t\tlen = strlen(charset_hint);\n\t\t}\n\t}\n#endif\n\ndet_charset:\n\n\tif (charset_hint) {\n\t\tint found = 0;\n\t\t\n\t\t/* now walk the charset map and look for the codeset */\n\t\tfor (i = 0; charset_map[i].codeset; i++) {\n\t\t\tif (len == strlen(charset_map[i].codeset) && strncasecmp(charset_hint, charset_map[i].codeset, len) == 0) {\n\t\t\t\tcharset = charset_map[i].charset;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""charset `%s' not supported, assuming utf-8\"",\n\t\t\t\t\tcharset_hint);\n\t\t}\n\t}\n\treturn charset;\n}"", ""target"": 1}, {""func_name"": ""php_html_entities"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""s|ls!b\"", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n\t}\n\n\treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n\tRETVAL_STRINGL(replaced, (int)new_len, 0);\n}"", ""target"": 0}]","[{""func_name"": ""find_entity_for_char"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline void find_entity_for_char(\n\tunsigned int k,\n\tenum entity_charset charset,\n\tconst entity_stage1_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len,\n\tunsigned char *old,\n\tsize_t oldlen,\n\tsize_t *cursor)\n{\n\tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n\tconst entity_stage3_row *c;\n\n\tif (stage1_idx > 0x1D) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\n\tc = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)];\n\n\tif (!c->ambiguous) {\n\t\t*entity     = (const unsigned char *)c->data.ent.entity;\n\t\t*entity_len = c->data.ent.entity_len;\n\t} else {\n\t\t/* peek at next char */\n\t\tsize_t\t cursor_before\t= *cursor;\n\t\tint\t\t status\t\t\t= SUCCESS;\n\t\tunsigned next_char;\n\n\t\tif (!(*cursor < oldlen))\n\t\t\tgoto no_suitable_2nd;\n\n\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status);\n\n\t\tif (status == FAILURE)\n\t\t\tgoto no_suitable_2nd;\n\n\t\t{\n\t\t\tconst entity_multicodepoint_row *s, *e;\n\n\t\t\ts = &c->data.multicodepoint_table[1];\n\t\t\te = s - 1 + c->data.multicodepoint_table[0].leading_entry.size;\n\t\t\t/* we could do a binary search but it's not worth it since we have\n\t\t\t * at most two entries... */\n\t\t\tfor ( ; s <= e; s++) {\n\t\t\t\tif (s->normal_entry.second_cp == next_char) {\n\t\t\t\t\t*entity     = s->normal_entry.entity;\n\t\t\t\t\t*entity_len = s->normal_entry.entity_len;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nno_suitable_2nd:\n\t\t*cursor = cursor_before;\n\t\t*entity = (const unsigned char *)\n\t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n\t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n\t}\n}""}, {""func_name"": ""php_escape_html_entities_ex"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""PHPAPI char *php_escape_html_entities_ex(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset, zend_bool double_encode TSRMLS_DC)\n{\n\tsize_t cursor, maxlen, len;\n\tchar *replaced;\n\tenum entity_charset charset = determine_charset(hint_charset TSRMLS_CC);\n\tint doctype = flags & ENT_HTML_DOC_TYPE_MASK;\n\tentity_table_opt entity_table;\n\tconst enc_to_uni *to_uni_table = NULL;\n\tconst entity_ht *inv_map = NULL; /* used for !double_encode */\n\t/* only used if flags includes ENT_HTML_IGNORE_ERRORS or ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS */\n\tconst unsigned char *replacement = NULL;\n\tsize_t replacement_len = 0;\n\n\tif (all) { /* replace with all named entities */\n\t\tif (CHARSET_PARTIAL_SUPPORT(charset)) {\n\t\t\tphp_error_docref0(NULL TSRMLS_CC, E_STRICT, \""Only basic entities \""\n\t\t\t\t\""substitution is supported for multi-byte encodings other than UTF-8; \""\n\t\t\t\t\""functionality is equivalent to htmlspecialchars\"");\n\t\t}\n\t\tLIMIT_ALL(all, doctype, charset);\n\t}\n\tentity_table = determine_entity_table(all, doctype);\n\tif (all && !CHARSET_UNICODE_COMPAT(charset)) {\n\t\tto_uni_table = enc_to_uni_index[charset];\n\t}\n\n\tif (!double_encode) {\n\t\t/* first arg is 1 because we want to identify valid named entities\n\t\t * even if we are only encoding the basic ones */\n\t\tinv_map = unescape_inverse_map(1, flags);\n\t}\n\n\tif (flags & (ENT_HTML_SUBSTITUTE_ERRORS | ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS)) {\n\t\tif (charset == cs_utf_8) {\n\t\t\treplacement = (const unsigned char*)\""\\xEF\\xBF\\xBD\"";\n\t\t\treplacement_len = sizeof(\""\\xEF\\xBF\\xBD\"") - 1;\n\t\t} else {\n\t\t\treplacement = (const unsigned char*)\""&#xFFFD;\"";\n\t\t\treplacement_len = sizeof(\""&#xFFFD;\"") - 1;\n\t\t}\n\t}\n\n\t/* initial estimate */\n\tif (oldlen < 64) {\n\t\tmaxlen = 128;\n\t} else {\n\t\tmaxlen = 2 * oldlen;\n\t\tif (maxlen < oldlen) {\n\t\t\tzend_error_noreturn(E_ERROR, \""Input string is too long\"");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treplaced = emalloc(maxlen + 1); /* adding 1 is safe: maxlen is even */\n\tlen = 0;\n\tcursor = 0;\n\twhile (cursor < oldlen) {\n\t\tconst unsigned char *mbsequence = NULL;\n\t\tsize_t mbseqlen\t\t\t\t\t= 0,\n\t\t       cursor_before\t\t\t= cursor;\n\t\tint status\t\t\t\t\t\t= SUCCESS;\n\t\tunsigned int this_char\t\t\t= get_next_char(charset, old, oldlen, &cursor, &status);\n\n\t\t/* guarantee we have at least 40 bytes to write.\n\t\t * In HTML5, entities may take up to 33 bytes */\n\t\tif (len > maxlen - 40) { /* maxlen can never be smaller than 128 */\n\t\t\treplaced = safe_erealloc(replaced, maxlen , 1, 128 + 1);\n\t\t\tmaxlen += 128;\n\t\t}\n\n\t\tif (status == FAILURE) {\n\t\t\t/* invalid MB sequence */\n\t\t\tif (flags & ENT_HTML_IGNORE_ERRORS) {\n\t\t\t\tcontinue;\n\t\t\t} else if (flags & ENT_HTML_SUBSTITUTE_ERRORS) {\n\t\t\t\tmemcpy(&replaced[len], replacement, replacement_len);\n\t\t\t\tlen += replacement_len;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tefree(replaced);\n\t\t\t\t*newlen = 0;\n\t\t\t\treturn STR_EMPTY_ALLOC();\n\t\t\t}\n\t\t} else { /* SUCCESS */\n\t\t\tmbsequence = &old[cursor_before];\n\t\t\tmbseqlen = cursor - cursor_before;\n\t\t}\n\n\t\tif (this_char != '&') { /* no entity on this position */\n\t\t\tconst unsigned char *rep\t= NULL;\n\t\t\tsize_t\t\t\t\trep_len\t= 0;\n\n\t\t\tif (((this_char == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t(this_char == '\""' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\tgoto pass_char_through;\n\n\t\t\tif (all) { /* false that CHARSET_PARTIAL_SUPPORT(charset) */\n\t\t\t\tif (to_uni_table != NULL) {\n\t\t\t\t\t/* !CHARSET_UNICODE_COMPAT therefore not UTF-8; since UTF-8\n\t\t\t\t\t * is the only multibyte encoding with !CHARSET_PARTIAL_SUPPORT,\n\t\t\t\t\t * we're using a single byte encoding */\n\t\t\t\t\tmap_to_unicode(this_char, to_uni_table, &this_char);\n\t\t\t\t\tif (this_char == 0xFFFF) /* no mapping; pass through */\n\t\t\t\t\t\tgoto pass_char_through;\n\t\t\t\t}\n\t\t\t\t/* the cursor may advance */\n\t\t\t\tfind_entity_for_char(this_char, charset, entity_table.ms_table, &rep,\n\t\t\t\t\t&rep_len, old, oldlen, &cursor);\n\t\t\t} else {\n\t\t\t\tfind_entity_for_char_basic(this_char, entity_table.table, &rep, &rep_len);\n\t\t\t}\n\n\t\t\tif (rep != NULL) {\n\t\t\t\treplaced[len++] = '&';\n\t\t\t\tmemcpy(&replaced[len], rep, rep_len);\n\t\t\t\tlen += rep_len;\n\t\t\t\treplaced[len++] = ';';\n\t\t\t} else {\n\t\t\t\t/* we did not find an entity for this char.\n\t\t\t\t * check for its validity, if its valid pass it unchanged */\n\t\t\t\tif (flags & ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS) {\n\t\t\t\t\tif (CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\t\t\tif (!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (to_uni_table) {\n\t\t\t\t\t\tif (!all) /* otherwise we already did this */\n\t\t\t\t\t\t\tmap_to_unicode(this_char, to_uni_table, &this_char);\n\t\t\t\t\t\tif (!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* not a unicode code point, unless, coincidentally, it's in\n\t\t\t\t\t\t * the 0x20..0x7D range (except 0x5C in sjis). We know nothing\n\t\t\t\t\t\t * about other code points, because we have no tables. Since\n\t\t\t\t\t\t * Unicode code points in that range are not disallowed in any\n\t\t\t\t\t\t * document type, we could do nothing. However, conversion\n\t\t\t\t\t\t * tables frequently map 0x00-0x1F to the respective C0 code\n\t\t\t\t\t\t * points. Let's play it safe and admit that's the case */\n\t\t\t\t\t\tif (this_char <= 0x7D &&\n\t\t\t\t\t\t\t\t!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\npass_char_through:\n\t\t\t\tif (mbseqlen > 1) {\n\t\t\t\t\tmemcpy(replaced + len, mbsequence, mbseqlen);\n\t\t\t\t\tlen += mbseqlen;\n\t\t\t\t} else {\n\t\t\t\t\treplaced[len++] = mbsequence[0];\n\t\t\t\t}\n\t\t\t}\n\t\t} else { /* this_char == '&' */\n\t\t\tif (double_encode) {\nencode_amp:\n\t\t\t\tmemcpy(&replaced[len], \""&amp;\"", sizeof(\""&amp;\"") - 1);\n\t\t\t\tlen += sizeof(\""&amp;\"") - 1;\n\t\t\t} else { /* no double encode */\n\t\t\t\t/* check if entity is valid */\n\t\t\t\tsize_t ent_len; /* not counting & or ; */\n\t\t\t\t/* peek at next char */\n\t\t\t\tif (old[cursor] == '#') { /* numeric entity */\n\t\t\t\t\tunsigned code_point;\n\t\t\t\t\tint valid;\n\t\t\t\t\tchar *pos = (char*)&old[cursor+1];\n\t\t\t\t\tvalid = process_numeric_entity((const char **)&pos, &code_point);\n\t\t\t\t\tif (valid == FAILURE)\n\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\tif (flags & ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS) {\n\t\t\t\t\t\tif (!numeric_entity_is_allowed(code_point, doctype))\n\t\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\t}\n\t\t\t\t\tent_len = pos - (char*)&old[cursor];\n\t\t\t\t} else { /* named entity */\n\t\t\t\t\t/* check for vality of named entity */\n\t\t\t\t\tconst char *start = &old[cursor],\n\t\t\t\t\t\t\t   *next = start;\n\t\t\t\t\tunsigned   dummy1, dummy2;\n\n\t\t\t\t\tif (process_named_entity_html(&next, &start, &ent_len) == FAILURE)\n\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\tif (resolve_named_entity_html(start, ent_len, inv_map, &dummy1, &dummy2) == FAILURE) {\n\t\t\t\t\t\tif (!(doctype == ENT_HTML_DOC_XHTML && ent_len == 4 && start[0] == 'a'\n\t\t\t\t\t\t\t\t\t&& start[1] == 'p' && start[2] == 'o' && start[3] == 's')) {\n\t\t\t\t\t\t\t/* uses html4 inv_map, which doesn't include apos;. This is a\n\t\t\t\t\t\t\t * hack to support it */\n\t\t\t\t\t\t\tgoto encode_amp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* checks passed; copy entity to result */\n\t\t\t\t/* entity size is unbounded, we may need more memory */\n\t\t\t\t/* at this point maxlen - len >= 40 */\n\t\t\t\tif (maxlen - len < ent_len + 2 /* & and ; */) {\n\t\t\t\t\t/* ent_len < oldlen, which is certainly <= SIZE_MAX/2 */\n\t\t\t\t\treplaced = safe_erealloc(replaced, maxlen, 1, ent_len + 128 + 1);\n\t\t\t\t\tmaxlen += ent_len + 128;\n\t\t\t\t}\n\t\t\t\treplaced[len++] = '&';\n\t\t\t\tmemcpy(&replaced[len], &old[cursor], ent_len);\n\t\t\t\tlen += ent_len;\n\t\t\t\treplaced[len++] = ';';\n\t\t\t\tcursor += ent_len + 1;\n\t\t\t}\n\t\t}\n\t}\n\treplaced[len] = '\\0';\n\t*newlen = len;\n\n\treturn replaced;\n}""}, {""func_name"": ""get_next_char"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline unsigned int get_next_char(\n\t\tenum entity_charset charset,\n\t\tconst unsigned char *str,\n\t\tsize_t str_len,\n\t\tsize_t *cursor,\n\t\tint *status)\n{\n\tsize_t pos = *cursor;\n\tunsigned int this_char = 0;\n\n\t*status = SUCCESS;\n\tassert(pos <= str_len);\n\n\tif (!CHECK_LEN(pos, 1))\n\t\tMB_FAILURE(pos, 1);\n\n\tswitch (charset) {\n\tcase cs_utf_8:\n\t\t{\n\t\t\t/* We'll follow strategy 2. from section 3.6.1 of UTR #36:\n\t\t\t * \""In a reported illegal byte sequence, do not include any\n\t\t\t *  non-initial byte that encodes a valid character or is a leading\n\t\t\t *  byte for a valid sequence.\"" */\n\t\t\tunsigned char c;\n\t\t\tc = str[pos];\n\t\t\tif (c < 0x80) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos++;\n\t\t\t} else if (c < 0xc2) {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t} else if (c < 0xe0) {\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tif (!utf8_trail(str[pos + 1])) {\n\t\t\t\t\tMB_FAILURE(pos, utf8_lead(str[pos + 1]) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tthis_char = ((c & 0x1f) << 6) | (str[pos + 1] & 0x3f);\n\t\t\t\tif (this_char < 0x80) { /* non-shortest form */\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c < 0xf0) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 3 ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 1]) || !utf8_trail(str[pos + 2])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t}\n\n\t\t\t\tthis_char = ((c & 0x0f) << 12) | ((str[pos + 1] & 0x3f) << 6) | (str[pos + 2] & 0x3f);\n\t\t\t\tif (this_char < 0x800) { /* non-shortest form */\n\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t} else if (this_char >= 0xd800 && this_char <= 0xdfff) { /* surrogate */\n\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t}\n\t\t\t\tpos += 3;\n\t\t\t} else if (c < 0xf5) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 4 ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 1]) || !utf8_trail(str[pos + 2]) ||\n\t\t\t\t\t\t!utf8_trail(str[pos + 3])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse if (avail < 4 || utf8_lead(str[pos + 3]))\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\n\t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n\t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\n\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\tpos += 4;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5:\n\t\t/* reference http://demo.icu-project.org/icu-bin/convexp?conv=big5 */\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0x81 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif ((next >= 0x40 && next <= 0x7E) ||\n\t\t\t\t\t\t(next >= 0xA1 && next <= 0xFE)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5hkscs:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0x81 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif ((next >= 0x40 && next <= 0x7E) ||\n\t\t\t\t\t\t(next >= 0xA1 && next <= 0xFE)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (next != 0x80 && next != 0xFF) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_gb2312: /* EUC-CN */\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif (c >= 0xA1 && c <= 0xFE) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (gb2312_trail(next)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (gb2312_lead(next)) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (gb2312_lead(c)) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_sjis:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\t\t\tif ((c >= 0x81 && c <= 0x9F) || (c >= 0xE0 && c <= 0xFC)) {\n\t\t\t\tunsigned char next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (sjis_trail(next)) {\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else if (sjis_lead(next)) {\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c < 0x80 || (c >= 0xA1 && c <= 0xDF)) {\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase cs_eucjp:\n\t\t{\n\t\t\tunsigned char c = str[pos];\n\n\t\t\tif (c >= 0xA1 && c <= 0xFE) {\n\t\t\t\tunsigned next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\tnext = str[pos + 1];\n\n\t\t\t\tif (next >= 0xA1 && next <= 0xFE) {\n\t\t\t\t\t/* this a jis kanji char */\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, (next != 0xA0 && next != 0xFF) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c == 0x8E) {\n\t\t\t\tunsigned next;\n\t\t\t\tif (!CHECK_LEN(pos, 2))\n\t\t\t\t\tMB_FAILURE(pos, 1);\n\n\t\t\t\tnext = str[pos + 1];\n\t\t\t\tif (next >= 0xA1 && next <= 0xDF) {\n\t\t\t\t\t/* JIS X 0201 kana */\n\t\t\t\t\tthis_char = (c << 8) | next;\n\t\t\t\t} else {\n\t\t\t\t\tMB_FAILURE(pos, (next != 0xA0 && next != 0xFF) ? 1 : 2);\n\t\t\t\t}\n\t\t\t\tpos += 2;\n\t\t\t} else if (c == 0x8F) {\n\t\t\t\tsize_t avail = str_len - pos;\n\n\t\t\t\tif (avail < 3 || !(str[pos + 1] >= 0xA1 && str[pos + 1] <= 0xFE) ||\n\t\t\t\t\t\t!(str[pos + 2] >= 0xA1 && str[pos + 2] <= 0xFE)) {\n\t\t\t\t\tif (avail < 2 || (str[pos + 1] != 0xA0 && str[pos + 1] != 0xFF))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || (str[pos + 2] != 0xA0 && str[pos + 2] != 0xFF))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t} else {\n\t\t\t\t\t/* JIS X 0212 hojo-kanji */\n\t\t\t\t\tthis_char = (c << 16) | (str[pos + 1] << 8) | str[pos + 2];\n\t\t\t\t}\n\t\t\t\tpos += 3;\n\t\t\t} else if (c != 0xA0 && c != 0xFF) {\n\t\t\t\t/* character encoded in 1 code unit */\n\t\t\t\tthis_char = c;\n\t\t\t\tpos += 1;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* single-byte charsets */\n\t\tthis_char = str[pos++];\n\t\tbreak;\n\t}\n\n\t*cursor = pos;\n  \treturn this_char;\n}""}, {""func_name"": ""unimap_bsearch"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\n\t/* we have no mappings outside the BMP */\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\n\tcode_key = (unsigned short) code_key_a;\n\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}""}, {""func_name"": ""php_unescape_html_entities"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; /* charset shouldn't matter, use ISO-8859-1 for performance */\n\t}\n\n\t/* don't use LIMIT_ALL! */\n\n\tif (oldlen > new_size) {\n\t\t/* overflow, refuse to do anything */\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\n\tinverse_map = unescape_inverse_map(all, flags);\n\n\t/* replace numeric entities */\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\n\nempty_source:\n\t*newlen = retlen;\n\treturn ret;\n}""}, {""func_name"": ""unicode_cp_is_allowed"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n{\n\t/* XML 1.0\t\t\t\tHTML 4.01\t\t\tHTML 5\n\t * 0x09..0x0A\t\t\t0x09..0x0A\t\t\t0x09..0x0A\n\t * 0x0D\t\t\t\t\t0x0D\t\t\t\t0x0C..0x0D\n\t * 0x0020..0xD7FF\t\t0x20..0x7E\t\t\t0x20..0x7E\n\t *\t\t\t\t\t\t0x00A0..0xD7FF\t\t0x00A0..0xD7FF\n\t * 0xE000..0xFFFD\t\t0xE000..0x10FFFF\t0xE000..0xFDCF\n\t * 0x010000..0x10FFFF\t\t\t\t\t\t0xFDF0..0x10FFFF (*)\n\t *\n\t * (*) exclude code points where ((code & 0xFFFF) >= 0xFFFE)\n\t *\n\t * References:\n\t * XML 1.0:   <http://www.w3.org/TR/REC-xml/#charsets>\n\t * HTML 4.01: <http://www.w3.org/TR/1999/PR-html40-19990824/sgml/sgmldecl.html>\n\t * HTML 5:    <http://dev.w3.org/html5/spec/Overview.html#preprocessing-the-input-stream>\n\t *\n\t * Not sure this is the relevant part for HTML 5, though. I opted to\n\t * disallow the characters that would result in a parse error when\n\t * preprocessing of the input stream. See also section 8.1.3.\n\t *\n\t * It's unclear if XHTML 1.0 allows C1 characters. I'll opt to apply to\n\t * XHTML 1.0 the same rules as for XML 1.0.\n\t * See <http://cmsmcq.com/2007/C1.xml>.\n\t */\n\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\n\tcase ENT_HTML_DOC_HTML5:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || /* form feed U+0C allowed */\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && /* last two of each plane (nonchars) disallowed */\n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); /* U+FDD0-U+FDEF (nonchars) disallowed */\n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\n\tdefault:\n\t\treturn 1;\n\t}\n}""}, {""func_name"": ""map_from_unicode"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline int map_from_unicode(unsigned code, enum entity_charset charset, unsigned *res)\n{\n\tunsigned char found;\n\tconst uni_to_enc *table;\n\tsize_t table_size;\n\n\tswitch (charset) {\n\tcase cs_8859_1:\n\t\t/* identity mapping of code points to unicode */\n\t\tif (code > 0xFF) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\t*res = code;\n\t\tbreak;\n\n\tcase cs_8859_5:\n\t\tif (code <= 0xA0 || code == 0xAD /* soft hyphen */) {\n\t\t\t*res = code;\n\t\t} else if (code == 0x2116) {\n\t\t\t*res = 0xF0; /* numero sign */\n\t\t} else if (code == 0xA7) {\n\t\t\t*res = 0xFD; /* section sign */\n\t\t} else if (code >= 0x0401 && code <= 0x044F) {\n\t\t\tif (code == 0x040D || code == 0x0450 || code == 0x045D)\n\t\t\t\treturn FAILURE;\n\t\t\t*res = code - 0x360;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_8859_15:\n\t\tif (code < 0xA4 || (code > 0xBE && code <= 0xFF)) {\n\t\t\t*res = code;\n\t\t} else { /* between A4 and 0xBE */\n\t\t\tfound = unimap_bsearch(unimap_iso885915,\n\t\t\t\tcode, sizeof(unimap_iso885915) / sizeof(*unimap_iso885915));\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_cp1252:\n\t\tif (code <= 0x7F || (code >= 0xA0 && code <= 0xFF)) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\tfound = unimap_bsearch(unimap_win1252,\n\t\t\t\tcode, sizeof(unimap_win1252) / sizeof(*unimap_win1252));\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_macroman:\n\t\tif (code == 0x7F)\n\t\t\treturn FAILURE;\n\t\ttable = unimap_macroman;\n\t\ttable_size = sizeof(unimap_macroman) / sizeof(*unimap_macroman);\n\t\tgoto table_over_7F;\n\tcase cs_cp1251:\n\t\ttable = unimap_win1251;\n\t\ttable_size = sizeof(unimap_win1251) / sizeof(*unimap_win1251);\n\t\tgoto table_over_7F;\n\tcase cs_koi8r:\n\t\ttable = unimap_koi8r;\n\t\ttable_size = sizeof(unimap_koi8r) / sizeof(*unimap_koi8r);\n\t\tgoto table_over_7F;\n\tcase cs_cp866:\n\t\ttable = unimap_cp866;\n\t\ttable_size = sizeof(unimap_cp866) / sizeof(*unimap_cp866);\n\ntable_over_7F:\n\t\tif (code <= 0x7F) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\tfound = unimap_bsearch(table, code, table_size);\n\t\t\tif (found)\n\t\t\t\t*res = found;\n\t\t\telse\n\t\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\t/* from here on, only map the possible characters in the ASCII range.\n\t * to improve support here, it's a matter of building the unicode mappings.\n\t * See <http://www.unicode.org/Public/6.0.0/ucd/Unihan.zip> */\n\tcase cs_sjis:\n\tcase cs_eucjp:\n\t\t/* we interpret 0x5C as the Yen symbol. This is not universal.\n\t\t * See <http://www.w3.org/Submission/japanese-xml/#ambiguity_of_yen> */\n\t\tif (code >= 0x20 && code <= 0x7D) {\n\t\t\tif (code == 0x5C)\n\t\t\t\treturn FAILURE;\n\t\t\t*res = code;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tcase cs_big5:\n\tcase cs_big5hkscs:\n\tcase cs_gb2312:\n\t\tif (code >= 0x20 && code <= 0x7D) {\n\t\t\t*res = code;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}""}, {""func_name"": ""determine_entity_table"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}""}, {""func_name"": ""process_numeric_entity"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); /* TODO: XML apparently disallows \""X\"" */\n\tchar *endptr;\n\n\tif (hexadecimal && (**buf != '\\0'))\n\t\t(*buf)++;\n\n\t/* strtol allows whitespace and other stuff in the beginning\n\t\t* we're not interested */\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t/* we're guaranteed there were valid digits, so *endptr > buf */\n\t*buf = endptr;\n\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\n\t/* many more are invalid, but that depends on whether it's HTML\n\t * (and which version) or XML. */\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\n\treturn SUCCESS;\n}""}, {""func_name"": ""traverse_for_entities"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static void traverse_for_entities(\n\tconst char *old,\n\tsize_t oldlen,\n\tchar *ret, /* should have allocated TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(olden) */\n\tsize_t *retlen,\n\tint all,\n\tint flags,\n\tconst entity_ht *inv_map,\n\tenum entity_charset charset)\n{\n\tconst char *p,\n\t\t\t   *lim;\n\tchar\t   *q;\n\tint doctype = flags & ENT_HTML_DOC_TYPE_MASK;\n\n\tlim = old + oldlen; /* terminator address */\n\tassert(*lim == '\\0');\n\n\tfor (p = old, q = ret; p < lim;) {\n\t\tunsigned code, code2 = 0;\n\t\tconst char *next = NULL; /* when set, next > p, otherwise possible inf loop */\n\n\t\t/* Shift JIS, Big5 and HKSCS use multi-byte encodings where an\n\t\t * ASCII range byte can be part of a multi-byte sequence.\n\t\t * However, they start at 0x40, therefore if we find a 0x26 byte,\n\t\t * we're sure it represents the '&' character. */\n\n\t\t/* assumes there are no single-char entities */\n\t\tif (p[0] != '&' || (p + 3 >= lim)) {\n\t\t\t*(q++) = *(p++);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* now p[3] is surely valid and is no terminator */\n\n\t\t/* numerical entity */\n\t\tif (p[1] == '#') {\n\t\t\tnext = &p[2];\n\t\t\tif (process_numeric_entity(&next, &code) == FAILURE)\n\t\t\t\tgoto invalid_code;\n\n\t\t\t/* If we're in htmlspecialchars_decode, we're only decoding entities\n\t\t\t * that represent &, <, >, \"" and '. Is this one of them? */\n\t\t\tif (!all && (code > 63U ||\n\t\t\t\t\tstage3_table_be_apos_00000[code].data.ent.entity == NULL))\n\t\t\t\tgoto invalid_code;\n\n\t\t\t/* are we allowed to decode this entity in this document type?\n\t\t\t * HTML 5 is the only that has a character that cannot be used in\n\t\t\t * a numeric entity but is allowed literally (U+000D). The\n\t\t\t * unoptimized version would be ... || !numeric_entity_is_allowed(code) */\n\t\t\tif (!unicode_cp_is_allowed(code, doctype) ||\n\t\t\t\t\t(doctype == ENT_HTML_DOC_HTML5 && code == 0x0D))\n\t\t\t\tgoto invalid_code;\n\t\t} else {\n\t\t\tconst char *start;\n\t\t\tsize_t ent_len;\n\n\t\t\tnext = &p[1];\n\t\t\tstart = next;\n\n\t\t\tif (process_named_entity_html(&next, &start, &ent_len) == FAILURE)\n\t\t\t\tgoto invalid_code;\n\n\t\t\tif (resolve_named_entity_html(start, ent_len, inv_map, &code, &code2) == FAILURE) {\n\t\t\t\tif (doctype == ENT_HTML_DOC_XHTML && ent_len == 4 && start[0] == 'a'\n\t\t\t\t\t\t\t&& start[1] == 'p' && start[2] == 'o' && start[3] == 's') {\n\t\t\t\t\t/* uses html4 inv_map, which doesn't include apos;. This is a\n\t\t\t\t\t * hack to support it */\n\t\t\t\t\tcode = (unsigned) '\\'';\n\t\t\t\t} else {\n\t\t\t\t\tgoto invalid_code;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassert(*next == ';');\n\n\t\tif (((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t(code == '\""' && !(flags & ENT_HTML_QUOTE_DOUBLE)))\n\t\t\t\t/* && code2 == '\\0' always true for current maps */)\n\t\t\tgoto invalid_code;\n\n\t\t/* UTF-8 doesn't need mapping (ISO-8859-1 doesn't either, but\n\t\t * the call is needed to ensure the codepoint <= U+00FF)  */\n\t\tif (charset != cs_utf_8) {\n\t\t\t/* replace unicode code point */\n\t\t\tif (map_from_unicode(code, charset, &code) == FAILURE || code2 != 0)\n\t\t\t\tgoto invalid_code; /* not representable in target charset */\n\t\t}\n\n\t\tq += write_octet_sequence(q, charset, code);\n\t\tif (code2) {\n\t\t\tq += write_octet_sequence(q, charset, code2);\n\t\t}\n\n\t\t/* jump over the valid entity; may go beyond size of buffer; np */\n\t\tp = next + 1;\n\t\tcontinue;\n\ninvalid_code:\n\t\tfor (; p < next; p++) {\n\t\t\t*(q++) = *p;\n\t\t}\n\t}\n\n\t*q = '\\0';\n\t*retlen = (size_t)(q - ret);\n}""}, {""func_name"": ""write_s3row_data"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static inline void write_s3row_data(\n\tconst entity_stage3_row *r,\n\tunsigned orig_cp,\n\tenum entity_charset charset,\n\tzval *arr)\n{\n\tchar key[9] = \""\""; /* two unicode code points in UTF-8 */\n\tchar entity[LONGEST_ENTITY_LENGTH + 2] = {'&'};\n\tsize_t written_k1;\n\n\twritten_k1 = write_octet_sequence(key, charset, orig_cp);\n\n\tif (!r->ambiguous) {\n\t\tsize_t l = r->data.ent.entity_len;\n\t\tmemcpy(&entity[1], r->data.ent.entity, l);\n\t\tentity[l + 1] = ';';\n\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t} else {\n\t\tunsigned i,\n\t\t\t     num_entries;\n\t\tconst entity_multicodepoint_row *mcpr = r->data.multicodepoint_table;\n\n\t\tif (mcpr[0].leading_entry.default_entity != NULL) {\n\t\t\tsize_t l = mcpr[0].leading_entry.default_entity_len;\n\t\t\tmemcpy(&entity[1], mcpr[0].leading_entry.default_entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t\t}\n\t\tnum_entries = mcpr[0].leading_entry.size;\n\t\tfor (i = 1; i <= num_entries; i++) {\n\t\t\tsize_t   l,\n\t\t\t\t     written_k2;\n\t\t\tunsigned uni_cp,\n\t\t\t\t\t spe_cp;\n\n\t\t\tuni_cp = mcpr[i].normal_entry.second_cp;\n\t\t\tl = mcpr[i].normal_entry.entity_len;\n\n\t\t\tif (!CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\tif (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE)\n\t\t\t\t\tcontinue; /* non representable in this charset */\n\t\t\t} else {\n\t\t\t\tspe_cp = uni_cp;\n\t\t\t}\n\n\t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n\t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tentity[l + 1] = '\\0';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + written_k2 + 1, entity, l + 1, 1);\n\t\t}\n\t}\n}""}, {""func_name"": ""determine_charset"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static enum entity_charset determine_charset(char *charset_hint TSRMLS_DC)\n{\n\tint i;\n\tenum entity_charset charset = cs_utf_8;\n\tint len = 0;\n\tconst zend_encoding *zenc;\n\n\t/* Default is now UTF-8 */\n\tif (charset_hint == NULL)\n\t\treturn cs_utf_8;\n\n\tif ((len = strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n\n\tzenc = zend_multibyte_get_internal_encoding(TSRMLS_C);\n\tif (zenc != NULL) {\n\t\tcharset_hint = (char *)zend_multibyte_get_encoding_name(zenc);\n\t\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\t\tif ((len == 4) /* sizeof (none|auto|pass) */ &&\n\t\t\t\t\t(!memcmp(\""pass\"", charset_hint, 4) ||\n\t\t\t\t\t !memcmp(\""auto\"", charset_hint, 4) ||\n\t\t\t\t\t !memcmp(\""auto\"", charset_hint, 4))) {\n\t\t\t\tcharset_hint = NULL;\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tgoto det_charset;\n\t\t\t}\n\t\t}\n\t}\n\n\tcharset_hint = SG(default_charset);\n\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n\n\t/* try to detect the charset for the locale */\n#if HAVE_NL_LANGINFO && HAVE_LOCALE_H && defined(CODESET)\n\tcharset_hint = nl_langinfo(CODESET);\n\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n#endif\n\n#if HAVE_LOCALE_H\n\t/* try to figure out the charset from the locale */\n\t{\n\t\tchar *localename;\n\t\tchar *dot, *at;\n\n\t\t/* lang[_territory][.codeset][@modifier] */\n\t\tlocalename = setlocale(LC_CTYPE, NULL);\n\n\t\tdot = strchr(localename, '.');\n\t\tif (dot) {\n\t\t\tdot++;\n\t\t\t/* locale specifies a codeset */\n\t\t\tat = strchr(dot, '@');\n\t\t\tif (at)\n\t\t\t\tlen = at - dot;\n\t\t\telse\n\t\t\t\tlen = strlen(dot);\n\t\t\tcharset_hint = dot;\n\t\t} else {\n\t\t\t/* no explicit name; see if the name itself\n\t\t\t * is the charset */\n\t\t\tcharset_hint = localename;\n\t\t\tlen = strlen(charset_hint);\n\t\t}\n\t}\n#endif\n\ndet_charset:\n\n\tif (charset_hint) {\n\t\tint found = 0;\n\n\t\t/* now walk the charset map and look for the codeset */\n\t\tfor (i = 0; charset_map[i].codeset; i++) {\n\t\t\tif (len == strlen(charset_map[i].codeset) && strncasecmp(charset_hint, charset_map[i].codeset, len) == 0) {\n\t\t\t\tcharset = charset_map[i].charset;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""charset `%s' not supported, assuming utf-8\"",\n\t\t\t\t\tcharset_hint);\n\t\t}\n\t}\n\treturn charset;\n}""}, {""func_name"": ""php_html_entities"", ""file_path"": ""ext/standard/html.c"", ""func_code"": ""static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""s|ls!b\"", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n\t}\n\n\treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n\tif (new_len > INT_MAX) {\n\t\tefree(replaced);\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(replaced, (int)new_len, 0);\n}""}]","{""function"": 2, ""code"": 2}","[{""source"": ""func_info(file:html.c, func:php_escape_html_entities_ex)"", ""result"": [{""code"": ""char *php_escape_html_entities_ex(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset, zend_bool double_encode TSRMLS_DC)\n{\n\tsize_t cursor, maxlen, len;\n\tchar *replaced;\n\tenum entity_charset charset = determine_charset(hint_charset TSRMLS_CC);\n\tint doctype = flags & ENT_HTML_DOC_TYPE_MASK;\n\tentity_table_opt entity_table;\n\tconst enc_to_uni *to_uni_table = NULL;\n\tconst entity_ht *inv_map = NULL; /* used for !double_encode */\n\t/* only used if flags includes ENT_HTML_IGNORE_ERRORS or ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS */\n\tconst unsigned char *replacement = NULL;\n\tsize_t replacement_len = 0;\n\n\tif (all) { /* replace with all named entities */\n\t\tif (CHARSET_PARTIAL_SUPPORT(charset)) {\n\t\t\tphp_error_docref0(NULL TSRMLS_CC, E_STRICT, \""Only basic entities \""\n\t\t\t\t\""substitution is supported for multi-byte encodings other than UTF-8; \""\n\t\t\t\t\""functionality is equivalent to htmlspecialchars\"");\n\t\t}\n\t\tLIMIT_ALL(all, doctype, charset);\n\t}\n\tentity_table = determine..."", ""start_line"": 1214, ""end_line"": 1428, ""full_name"": ""php_escape_html_entities_ex"", ""file_path"": ""ext/standard/html.c""}]}, {""source"": ""code_info(file:html.c, lines:1430-1450)"", ""result"": ""\n/* {{{ php_html_entities\n */\nstatic void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""s|ls!b\"", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n\t}\n\n\treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n\tRETVAL_STRINGL(replaced, (int)new_len, 0);\n}\n/* }}} */\n\n#define HTML_SPECIALCHARS \t0\n""}, {""source"": ""code_info(file:html.c, lines:1250-1350)"", ""result"": ""\t\t} else {\n\t\t\treplacement = (const unsigned char*)\""&#xFFFD;\"";\n\t\t\treplacement_len = sizeof(\""&#xFFFD;\"") - 1;\n\t\t}\n\t}\n\n\t/* initial estimate */\n\tif (oldlen < 64) {\n\t\tmaxlen = 128;\t\n\t} else {\n\t\tmaxlen = 2 * oldlen;\n\t\tif (maxlen < oldlen) {\n\t\t\tzend_error_noreturn(E_ERROR, \""Input string is too long\"");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treplaced = emalloc(maxlen + 1); /* adding 1 is safe: maxlen is even */\n\tlen = 0;\n\tcursor = 0;\n\twhile (cursor < oldlen) {\n\t\tconst unsigned char *mbsequence = NULL;\n\t\tsize_t mbseqlen\t\t\t\t\t= 0,\n\t\t       cursor_before\t\t\t= cursor;\n\t\tint status\t\t\t\t\t\t= SUCCESS;\n\t\tunsigned int this_char\t\t\t= get_next_char(charset, old, oldlen, &cursor, &status);\n\n\t\t/* guarantee we have at least 40 bytes to write.\n\t\t * In HTML5, entities may take up to 33 bytes */\n\t\tif (len > maxlen - 40) { /* maxlen can never be smaller than 128 */\n\t\t\treplaced = safe_erealloc(replaced, maxlen , 1, 128 + 1);\n\t\t\tmaxlen += 128;\n\t\t}\n\n\t\tif (status == FAILURE) {\n\t\t\t/* invalid MB sequence */\n\t\t\tif (flags & ENT_HTML_IGNORE_ERRORS) {\n\t\t\t\tcontinue;\n\t\t\t} else if (flags & ENT_HTML_SUBSTITUTE_ERRORS) {\n\t\t\t\tmemcpy(&replaced[len], replacement, replacement_len);\n\t\t\t\tlen += replacement_len;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tefree(replaced);\n\t\t\t\t*newlen = 0;\n\t\t\t\treturn STR_EMPTY_ALLOC();\n\t\t\t}\n\t\t} else { /* SUCCESS */\n\t\t\tmbsequence = &old[cursor_before];\n\t\t\tmbseqlen = cursor - cursor_before;\n\t\t}\n\n\t\tif (this_char != '&') { /* no entity on this position */\n\t\t\tconst unsigned char *rep\t= NULL;\n\t\t\tsize_t\t\t\t\trep_len\t= 0;\n\n\t\t\tif (((this_char == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t(this_char == '\""' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\tgoto pass_char_through;\n\n\t\t\tif (all) { /* false that CHARSET_PARTIAL_SUPPORT(charset) */\n\t\t\t\tif (to_uni_table != NULL) {\n\t\t\t\t\t/* !CHARSET_UNICODE_COMPAT therefore not UTF-8; since UTF-8\n\t\t\t\t\t * is the only multibyte encoding with !CHARSET_PARTIAL_SUPPORT,\n\t\t\t\t\t * we're using a single byte encoding */\n\t\t\t\t\tmap_to_unicode(this_char, to_uni_table, &this_char);\n\t\t\t\t\tif (this_char == 0xFFFF) /* no mapping; pass through */\n\t\t\t\t\t\tgoto pass_char_through;\n\t\t\t\t}\n\t\t\t\t/* the cursor may advance */\n\t\t\t\tfind_entity_for_char(this_char, charset, entity_table.ms_table, &rep,\n\t\t\t\t\t&rep_len, old, oldlen, &cursor);\n\t\t\t} else {\n\t\t\t\tfind_entity_for_char_basic(this_char, entity_table.table, &rep, &rep_len);\n\t\t\t}\n\n\t\t\tif (rep != NULL) {\n\t\t\t\treplaced[len++] = '&';\n\t\t\t\tmemcpy(&replaced[len], rep, rep_len);\n\t\t\t\tlen += rep_len;\n\t\t\t\treplaced[len++] = ';';\n\t\t\t} else {\n\t\t\t\t/* we did not find an entity for this char.\n\t\t\t\t * check for its validity, if its valid pass it unchanged */\n\t\t\t\tif (flags & ENT_HTML_SUBSTITUTE_DISALLOWED_CHARS) {\n\t\t\t\t\tif (CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\t\t\tif (!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (to_uni_table) {\n\t\t\t\t\t\tif (!all) /* otherwise we already did this */\n\t\t\t\t\t\t\tmap_to_unicode(this_char, to_uni_table, &this_char);\n\t\t\t\t\t\tif (!unicode_cp_is_allowed(this_char, doctype)) {\n\t\t\t\t\t\t\tmbsequence = replacement;\n\t\t\t\t\t\t\tmbseqlen = replacement_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* not a unicode code point, unless, coincidentally, it's in\n\t\t\t\t\t\t * the 0x20..0x7D range (except 0x5C in sjis). We know nothing\n\t\t\t\t\t\t * about other code points, because we have no tables. Since\n\t\t\t\t\t\t * Unicode code points in that range are not disallowed in any\n""}, {""source"": ""func_info(file:html.c, func:find_entity_for_char)"", ""result"": [{""code"": ""static inline void find_entity_for_char(\n\tunsigned int k,\n\tenum entity_charset charset,\n\tconst entity_stage1_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len,\n\tunsigned char *old,\n\tsize_t oldlen,\n\tsize_t *cursor)\n{\n\tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n\tconst entity_stage3_row *c;\n\t\n\tif (stage1_idx > 0x1D) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\n\tc = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)];\n\n\tif (!c->ambiguous) {\n\t\t*entity     = (const unsigned char *)c->data.ent.entity;\n\t\t*entity_len = c->data.ent.entity_len;\n\t} else {\n\t\t/* peek at next char */\n\t\tsize_t\t cursor_before\t= *cursor;\n\t\tint\t\t status\t\t\t= SUCCESS;\n\t\tunsigned next_char;\n\n\t\tif (!(*cursor < oldlen))\n\t\t\tgoto no_suitable_2nd;\n\n\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status); \n\n\t\tif (status == FAILURE)\n\t\t\tgoto no_suitable_2nd;\n\n\t\t{\n\t\t\tconst entity_multicodepoint_row *s, *e;\n\n\t\t\ts = &c->data.multicodepoint_table[1];\n\t\t\te = s - 1 + c->data.multicodepoint_..."", ""start_line"": 1132, ""end_line"": 1191, ""full_name"": ""find_entity_for_char"", ""file_path"": ""ext/standard/html.c""}]}]","ext/standard/html.c:1250-1350 (php_escape_html_entities_ex): The `len` variable is incremented without bounds checks during entity substitution (e.g., `len += rep_len + 2`). When processing a large input string with many characters requiring replacement (e.g., `&`  `&amp;`), `len` exceeds `INT_MAX`, causing overflow. The overflowed `len` is returned as `new_len` and cast to `int` in `php_html_entities` (line 1445). The `find_entity_for_char` function (lines 1132-1191) determines `rep_len` by setting `*entity_len` for entities like `&amp;` (length 3). The unchecked accumulation of `rep_len` in the loop leads to the overflow.",0.95,./github/other_context/CVE-2016-5094
6,CVE-2017-18187,CWE-190,c_cpp,"In ARM mbed TLS before 2.7.0, there is a bounds-check bypass through an integer overflow in PSK identity parsing in the ssl_parse_client_psk_identity() function in library/ssl_srv.c.",https://github.com/Mbed-TLS/mbedtls/commit/83c9f495ffe70c7dd280b41fdfd4881485a3bc28,"Prevent bounds check bypass through overflow in PSK identity parsing\n\nThe check `if( *p + n > end )` in `ssl_parse_client_psk_identity` is\nunsafe because `*p + n` might overflow, thus bypassing the check. As\n`n` is a user-specified value up to 65K, this is relevant if the\nlibrary happens to be located in the last 65K of virtual memory.\n\nThis commit replaces the check by a safe version.",1,"[{""func_name"": ""ssl_parse_client_psk_identity"", ""file_path"": ""library/ssl_srv.c"", ""func_code"": ""static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \""got no pre-shared key\"" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \""bad client key exchange message\"" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \""bad client key exchange message\"" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \""Unknown PSK identity\"", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}"", ""target"": 0}]","[{""func_name"": ""ssl_parse_client_psk_identity"", ""file_path"": ""library/ssl_srv.c"", ""func_code"": ""static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \""got no pre-shared key\"" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( end - *p < 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \""bad client key exchange message\"" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \""bad client key exchange message\"" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \""Unknown PSK identity\"", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}""}]",{},[],"The check `*p + n > end` in `library/ssl_srv.c:3446` could overflow if `*p` and `n` (user-controlled) were large, bypassing bounds validation. The patch replaces this with `n > (size_t)(end - *p)` to prevent overflow during arithmetic.",0.95,./github/other_context/CVE-2017-18187
7,CVE-2017-6838,CWE-190,c_cpp,Integer overflow in sfcommands/sfconvert.c in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.,https://github.com/antlarr/audiofile/commit/7d65f89defb092b63bcbc5d98349fb222ca73b3c,"Check for multiplication overflow in sfconvert\n\nChecks that a multiplication doesn't overflow when\ncalculating the buffer size, and if it overflows,\nreduce the buffer size instead of failing.\n\nThis fixes the 00192-audiofile-signintoverflow-sfconvert case\nin #41",1,"[{""func_name"": ""copyaudiodata"", ""file_path"": ""sfcommands/sfconvert.c"", ""func_code"": ""bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\n\tbool success = true;\n\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \""Bad read of audio track data.\\n\"");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \""Bad write of audio track data.\\n\"");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\n\tfree(buffer);\n\n\treturn success;\n}"", ""target"": 0}]","[{""func_name"": ""copyaudiodata"", ""file_path"": ""sfcommands/sfconvert.c"", ""func_code"": ""bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\n\tint kBufferFrameCount = 65536;\n\tint bufferSize;\n\twhile (multiplyCheckOverflow(kBufferFrameCount, frameSize, &bufferSize))\n\t\tkBufferFrameCount /= 2;\n\tvoid *buffer = malloc(bufferSize);\n\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\n\tbool success = true;\n\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \""Bad read of audio track data.\\n\"");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \""Bad write of audio track data.\\n\"");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\n\tfree(buffer);\n\n\treturn success;\n}""}]","{""function"": 1}","[{""source"": ""func_info(func:multiplyCheckOverflow)"", ""result"": [{""code"": ""int multiplyCheckOverflow(int a, int b, int *result)\n{\n#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))\n\treturn __builtin_mul_overflow(a, b, result);\n#else\n\tif (firstBitSet(a)+firstBitSet(b)>31) // int is signed, so we can't use 32 bits\n\t\treturn true;\n\t*result = a * b;\n\treturn false;\n#endif\n}"", ""start_line"": 119, ""end_line"": 129, ""full_name"": ""multiplyCheckOverflow:int(int,int,int*)"", ""file_path"": ""libaudiofile/modules/MSADPCM.cpp""}]}]",sfcommands/sfconvert.c:327-328: Unchecked multiplication (kBufferFrameCount * frameSize) for buffer allocation. The overflow check was added in the patch via multiplyCheckOverflow() loop. multiplyCheckOverflow() implementation in libaudiofile/modules/MSADPCM.cpp (lines 119-129) uses __builtin_mul_overflow or bit-based overflow detection.,0.95,./github/other_context/CVE-2017-6838
8,CVE-2018-12264,"CWE-190, CWE-125",c_cpp,"Exiv2 0.26 has integer overflows in LoaderTiff::getData() in preview.cpp, leading to an out-of-bounds read in Exiv2::ValueType::setDataArea in value.hpp.",https://github.com/Exiv2/exiv2/commit/fe70939f54476e99046245ca69ff27012401f759,"Fix addition overflows in range checks in LoaderTiff::getData\n\nSeveral checks for extracted values performed no overflow checks on the\naddition. They can be tricked into passing, albeit the individual summands are\ntoo large.\n=> use Safe::add() which now aborts when an overflow occurs\nThis fixes #366",1,"[{""func_name"": ""LoaderTiff::getData"", ""file_path"": ""src/preview.cpp"", ""func_code"": ""DataBuf LoaderTiff::getData() const\n    {\n        const ExifData &exifData = image_.exifData();\n\n        ExifData preview;\n\n        // copy tags\n        for (ExifData::const_iterator pos = exifData.begin(); pos != exifData.end(); ++pos) {\n            if (pos->groupName() == group_) {\n                /*\n                   Write only the necessary TIFF image tags\n                   tags that especially could cause problems are:\n                   \""NewSubfileType\"" - the result is no longer a thumbnail, it is a standalone image\n                   \""Orientation\"" - this tag typically appears only in the \""Image\"" group. Deleting it ensures\n                                   consistent result for all previews, including JPEG\n                */\n                uint16_t tag = pos->tag();\n                if (tag != 0x00fe && tag != 0x00ff && Internal::isTiffImageTag(tag, Internal::ifd0Id)) {\n                    preview.add(ExifKey(tag, \""Image\""), &pos->value());\n                }\n            }\n        }\n\n        Value &dataValue = const_cast<Value&>(preview[\""Exif.Image.\"" + offsetTag_].value());\n\n        if (dataValue.sizeDataArea() == 0) {\n            // image data are not available via exifData, read them from image_.io()\n            BasicIo &io = image_.io();\n\n            if (io.open() != 0) {\n                throw Error(kerDataSourceOpenFailed, io.path(), strError());\n            }\n            IoCloser closer(io);\n\n            const Exiv2::byte* base = io.mmap();\n\n            const Value &sizes = preview[\""Exif.Image.\"" + sizeTag_].value();\n\n            if (sizes.count() == dataValue.count()) {\n                if (sizes.count() == 1) {\n                    // this saves one copying of the buffer\n                    uint32_t offset = dataValue.toLong(0);\n                    uint32_t size = sizes.toLong(0);\n                    if (offset + size <= static_cast<uint32_t>(io.size()))\n                        dataValue.setDataArea(base + offset, size);\n                }\n                else {\n                    // FIXME: the buffer is probably copied twice, it should be optimized\n                    DataBuf buf(size_);\n                    uint32_t idxBuf = 0;\n                    for (int i = 0; i < sizes.count(); i++) {\n                        uint32_t offset = dataValue.toLong(i);\n                        uint32_t size = sizes.toLong(i);\n                        enforce(idxBuf + size < size_, kerCorruptedMetadata);\n                        if (size!=0 && offset + size <= static_cast<uint32_t>(io.size()))\n                            memcpy(&buf.pData_[idxBuf], base + offset, size);\n                        idxBuf += size;\n                    }\n                    dataValue.setDataArea(buf.pData_, buf.size_);\n                }\n            }\n        }\n\n        // Fix compression value in the CR2 IFD2 image\n        if (0 == strcmp(group_, \""Image2\"") && image_.mimeType() == \""image/x-canon-cr2\"") {\n            preview[\""Exif.Image.Compression\""] = uint16_t(1);\n        }\n\n        // write new image\n        MemIo mio;\n        IptcData emptyIptc;\n        XmpData  emptyXmp;\n        TiffParser::encode(mio, 0, 0, Exiv2::littleEndian, preview, emptyIptc, emptyXmp);\n        return DataBuf(mio.mmap(), (long) mio.size());\n    }"", ""target"": 0}]","[{""func_name"": ""LoaderTiff::getData"", ""file_path"": ""src/preview.cpp"", ""func_code"": ""DataBuf LoaderTiff::getData() const\n    {\n        const ExifData &exifData = image_.exifData();\n\n        ExifData preview;\n\n        // copy tags\n        for (ExifData::const_iterator pos = exifData.begin(); pos != exifData.end(); ++pos) {\n            if (pos->groupName() == group_) {\n                /*\n                   Write only the necessary TIFF image tags\n                   tags that especially could cause problems are:\n                   \""NewSubfileType\"" - the result is no longer a thumbnail, it is a standalone image\n                   \""Orientation\"" - this tag typically appears only in the \""Image\"" group. Deleting it ensures\n                                   consistent result for all previews, including JPEG\n                */\n                uint16_t tag = pos->tag();\n                if (tag != 0x00fe && tag != 0x00ff && Internal::isTiffImageTag(tag, Internal::ifd0Id)) {\n                    preview.add(ExifKey(tag, \""Image\""), &pos->value());\n                }\n            }\n        }\n\n        Value &dataValue = const_cast<Value&>(preview[\""Exif.Image.\"" + offsetTag_].value());\n\n        if (dataValue.sizeDataArea() == 0) {\n            // image data are not available via exifData, read them from image_.io()\n            BasicIo &io = image_.io();\n\n            if (io.open() != 0) {\n                throw Error(kerDataSourceOpenFailed, io.path(), strError());\n            }\n            IoCloser closer(io);\n\n            const Exiv2::byte* base = io.mmap();\n\n            const Value &sizes = preview[\""Exif.Image.\"" + sizeTag_].value();\n\n            if (sizes.count() == dataValue.count()) {\n                if (sizes.count() == 1) {\n                    // this saves one copying of the buffer\n                    uint32_t offset = dataValue.toLong(0);\n                    uint32_t size = sizes.toLong(0);\n                    if (Safe::add(offset, size) <= static_cast<uint32_t>(io.size()))\n                        dataValue.setDataArea(base + offset, size);\n                }\n                else {\n                    // FIXME: the buffer is probably copied twice, it should be optimized\n                    DataBuf buf(size_);\n                    uint32_t idxBuf = 0;\n                    for (int i = 0; i < sizes.count(); i++) {\n                        uint32_t offset = dataValue.toLong(i);\n                        uint32_t size = sizes.toLong(i);\n                        enforce(Safe::add(idxBuf, size) < size_, kerCorruptedMetadata);\n                        if (size!=0 && Safe::add(offset, size) <= static_cast<uint32_t>(io.size()))\n                            memcpy(&buf.pData_[idxBuf], base + offset, size);\n                        idxBuf += size;\n                    }\n                    dataValue.setDataArea(buf.pData_, buf.size_);\n                }\n            }\n        }\n\n        // Fix compression value in the CR2 IFD2 image\n        if (0 == strcmp(group_, \""Image2\"") && image_.mimeType() == \""image/x-canon-cr2\"") {\n            preview[\""Exif.Image.Compression\""] = uint16_t(1);\n        }\n\n        // write new image\n        MemIo mio;\n        IptcData emptyIptc;\n        XmpData  emptyXmp;\n        TiffParser::encode(mio, 0, 0, Exiv2::littleEndian, preview, emptyIptc, emptyXmp);\n        return DataBuf(mio.mmap(), (long) mio.size());\n    }""}]","{""function"": 2}","[{""source"": ""func_info(func:add)"", ""result"": [{""code"": ""void add(Exiv2::Internal::CiffHeader* pHead)\n{\n    uint16_t crwTag, crwDir;\n    uint32_t size;\n    std::cout << \""crwTag> 0x\"";\n    std::cin >> std::hex >> crwTag;\n    std::cout << \""crwDir> 0x\"";\n    std::cin >> std::hex >> crwDir;\n    std::cout << \""size> \"";\n    std::cin >> std::dec >> size;\n    std::cout << \""Adding tag 0x\"" << std::hex << crwTag\n              << \"" in dir 0x\"" << crwDir << \"", \"" << size << \"" bytes, ok? \"";\n    char cmd;\n    std::cin >> cmd;\n    if (cmd != 'n' && cmd != 'N') {\n        Exiv2::DataBuf buf(size);\n        std::memset(buf.pData_, 0xaa, size);\n        pHead->add(crwTag, crwDir, buf);\n    }\n    else {\n        std::cout << \""Canceled.\\n\"";\n    }\n}"", ""start_line"": 106, ""end_line"": 128, ""full_name"": ""add:void(Exiv2.Internal.CiffHeader*)"", ""file_path"": ""src/crwedit.cpp""}, {""code"": ""void CiffComponent::add(AutoPtr component)\n    {\n        doAdd(component);\n    }"", ""start_line"": 181, ""end_line"": 184, ""full_name"": ""Exiv2.Internal.CiffComponent.add:void(Exiv2.Internal.CiffComponent.AutoPtr)"", ""file_path"": ""src/crwimage_int.cpp""}, {""code"": ""void CiffHeader::add(uint16_t crwTagId, uint16_t crwDir, DataBuf buf)\n    {\n        CrwDirs crwDirs;\n        CrwMap::loadStack(crwDirs, crwDir);\n        uint16_t rootDirectory = crwDirs.top().crwDir_;\n        assert(rootDirectory == 0x0000);\n        crwDirs.pop();\n        if (!pRootDir_) pRootDir_ = new CiffDirectory;\n        if ( pRootDir_) {\n            CiffComponent* child = pRootDir_->add(crwDirs, crwTagId);\n            if ( child )   child->setValue(buf);\n        }\n    }"", ""start_line"": 616, ""end_line"": 628, ""full_name"": ""Exiv2.Internal.CiffHeader.add:void(uint16_t,uint16_t,Exiv2.DataBuf)"", ""file_path"": ""src/crwimage_int.cpp""}]}, {""source"": ""func_info(func:setDataArea)"", ""result"": [{""code"": ""int ValueType<T>::setDataArea(const byte* buf, long len)\n    {\n        byte* tmp = 0;\n        if (len > 0) {\n            tmp = new byte[len];\n            std::memcpy(tmp, buf, len);\n        }\n        delete[] pDataArea_;\n        pDataArea_ = tmp;\n        sizeDataArea_ = len;\n        return 0;\n    }"", ""start_line"": 1753, ""end_line"": 1764, ""full_name"": ""Exiv2.ValueType.setDataArea:int(Exiv2.byte*,long)"", ""file_path"": ""include/exiv2/value.hpp""}, {""code"": ""int Exifdatum::setDataArea(const byte* buf, long len)\n    {\n        return value_.get() == 0 ? -1 : value_->setDataArea(buf, len);\n    }"", ""start_line"": 306, ""end_line"": 309, ""full_name"": ""Exiv2.Exifdatum.setDataArea:int(Exiv2.byte*,long)"", ""file_path"": ""src/exif.cpp""}, {""code"": ""int Value::setDataArea(const byte* /*buf*/, long /*len*/)\n    {\n        return -1;\n    }"", ""start_line"": 138, ""end_line"": 141, ""full_name"": ""Exiv2.Value.setDataArea:int(Exiv2.byte*,long)"", ""file_path"": ""src/value.cpp""}]}]","preview.cpp:918-928: Unchecked additions (`offset + size` and `idxBuf + size`) could overflow, allowing the bounds check to pass erroneously. This would cause `setDataArea(base + offset, size)` (preview.cpp:918) to access memory beyond the allocated buffer. The overflowed check permits a size that exceeds the actual buffer capacity, leading to an out-of-bounds read in `ValueType::setDataArea` (value.hpp:1753) during `memcpy(tmp, buf, len)`, where `buf` is `base + offset`.",0.95,./github/other_context/CVE-2018-12264
9,CVE-2018-14353,CWE-191,c_cpp,An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap_quote_string in imap/util.c has an integer underflow.,https://github.com/neomutt/neomutt/commit/65d64a5b60a4a3883f2cd799d92c6091d8854f23,Check for int underflow in imap_quote_string,1,"[{""func_name"": ""imap_quote_string"", ""file_path"": ""imap/util.c"", ""func_code"": ""void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \""`\\\""\\\\\"";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\""';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\""';\n  *pt = '\\0';\n}"", ""target"": 0}]","[{""func_name"": ""imap_quote_string"", ""file_path"": ""imap/util.c"", ""func_code"": ""void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \""`\\\""\\\\\"";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\""';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\""';\n  *pt = '\\0';\n}""}]","{""code"": 1, ""value"": 1}","[{""source"": ""code_info(file:util.c, lines:800-850)"", ""result"": "" * imap_quote_string - quote string according to IMAP rules\n * @param dest Buffer for the result\n * @param dlen Length of the buffer\n * @param src  String to be quoted\n *\n * Surround string with quotes, escape \"" and \\ with backslash\n */\nvoid imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \""`\\\""\\\\\"";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\""';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\""';\n  *pt = '\\0';\n}\n\n/**\n * imap_unquote_string - equally stupid unquoting routine\n * @param s String to be unquoted\n */\nvoid imap_unquote_string(char *s)\n{\n  char *d = s;\n\n  if (*s == '\\\""')\n    s++;\n  else\n    return;\n""}, {""source"": ""value_info(file:util.c, value:dlen)"", ""result"": {""value_trace"": [{""full_code"": ""--dlen"", ""line"": 693, ""func_name"": ""imap_cachepath""}, {""full_code"": ""dlen -= 2"", ""line"": 818, ""func_name"": ""imap_quote_string""}, {""full_code"": ""dlen -= 2"", ""line"": 824, ""func_name"": ""imap_quote_string""}], ""struct_var"": ""dlen"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}]","In `imap/util.c:imap_quote_string`, `dlen` is a `size_t` parameter initialized by the caller. Before the loop, `dlen` is decremented by 2 (`dlen -= 2` at line 818). Inside the loop, if a quoted character is found, `dlen` is again decremented by 2 (`dlen -= 2` at line 824). If `dlen` is 1 before this subtraction, it underflows to a large value (due to `size_t` being unsigned). The original check `if (dlen == 0)` fails to catch this, allowing invalid buffer writes. The patch adds `if (dlen < 2)` to prevent underflow.",0.95,./github/other_context/CVE-2018-14353
10,CVE-2018-6191,CWE-190,c_cpp,The js_strtod function in jsdtoa.c in Artifex MuJS through 1.0.2 has an integer overflow because of incorrect exponent validation.,https://github.com/ArtifexSoftware/mujs/commit/25821e6d74fab5fcc200fe5e818362e03e114428,Fix 698920: Guard jsdtoa from integer overflow wreaking havoc.,1,"[{""func_name"": ""js_strtod"", ""file_path"": ""jsdtoa.c"", ""func_code"": ""double\njs_strtod(const char *string, char **endPtr)\n{\n\tint sign, expSign = FALSE;\n\tdouble fraction, dblExp, *d;\n\tregister const char *p;\n\tregister int c;\n\n\t/* Exponent read from \""EX\"" field. */\n\tint exp = 0;\n\n\t/* Exponent that derives from the fractional part. Under normal\n\t * circumstances, it is the negative of the number of digits in F.\n\t * However, if I is very long, the last digits of I get dropped\n\t * (otherwise a long I with a large negative exponent could cause an\n\t * unnecessary overflow on I alone). In this case, fracExp is\n\t * incremented one for each dropped digit.\n\t */\n\tint fracExp = 0;\n\n\t/* Number of digits in mantissa. */\n\tint mantSize;\n\n\t/* Number of mantissa digits BEFORE decimal point. */\n\tint decPt;\n\n\t/* Temporarily holds location of exponent in string. */\n\tconst char *pExp;\n\n\t/*\n\t * Strip off leading blanks and check for a sign.\n\t */\n\n\tp = string;\n\twhile (*p == ' ' || *p == '\\t' || *p == '\\n' || *p == '\\r') {\n\t\tp += 1;\n\t}\n\tif (*p == '-') {\n\t\tsign = TRUE;\n\t\tp += 1;\n\t} else {\n\t\tif (*p == '+') {\n\t\t\tp += 1;\n\t\t}\n\t\tsign = FALSE;\n\t}\n\n\t/*\n\t * Count the number of digits in the mantissa (including the decimal\n\t * point), and also locate the decimal point.\n\t */\n\n\tdecPt = -1;\n\tfor (mantSize = 0; ; mantSize += 1)\n\t{\n\t\tc = *p;\n\t\tif (!(c>='0'&&c<='9')) {\n\t\t\tif ((c != '.') || (decPt >= 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdecPt = mantSize;\n\t\t}\n\t\tp += 1;\n\t}\n\n\t/*\n\t * Now suck up the digits in the mantissa. Use two integers to\n\t * collect 9 digits each (this is faster than using floating-point).\n\t * If the mantissa has more than 18 digits, ignore the extras, since\n\t * they can't affect the value anyway.\n\t */\n\n\tpExp = p;\n\tp -= mantSize;\n\tif (decPt < 0) {\n\t\tdecPt = mantSize;\n\t} else {\n\t\tmantSize -= 1;\t\t\t/* One of the digits was the point. */\n\t}\n\tif (mantSize > 18) {\n\t\tfracExp = decPt - 18;\n\t\tmantSize = 18;\n\t} else {\n\t\tfracExp = decPt - mantSize;\n\t}\n\tif (mantSize == 0) {\n\t\tfraction = 0.0;\n\t\tp = string;\n\t\tgoto done;\n\t} else {\n\t\tint frac1, frac2;\n\t\tfrac1 = 0;\n\t\tfor ( ; mantSize > 9; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac1 = 10*frac1 + (c - '0');\n\t\t}\n\t\tfrac2 = 0;\n\t\tfor (; mantSize > 0; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac2 = 10*frac2 + (c - '0');\n\t\t}\n\t\tfraction = (1.0e9 * frac1) + frac2;\n\t}\n\n\t/*\n\t * Skim off the exponent.\n\t */\n\n\tp = pExp;\n\tif ((*p == 'E') || (*p == 'e')) {\n\t\tp += 1;\n\t\tif (*p == '-') {\n\t\t\texpSign = TRUE;\n\t\t\tp += 1;\n\t\t} else {\n\t\t\tif (*p == '+') {\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\texpSign = FALSE;\n\t\t}\n\t\twhile ((*p >= '0') && (*p <= '9')) {\n\t\t\texp = exp * 10 + (*p - '0');\n\t\t\tp += 1;\n\t\t}\n\t}\n\tif (expSign) {\n\t\texp = fracExp - exp;\n\t} else {\n\t\texp = fracExp + exp;\n\t}\n\n\t/*\n\t * Generate a floating-point number that represents the exponent.\n\t * Do this by processing the exponent one bit at a time to combine\n\t * many powers of 2 of 10. Then combine the exponent with the\n\t * fraction.\n\t */\n\n\tif (exp < 0) {\n\t\texpSign = TRUE;\n\t\texp = -exp;\n\t} else {\n\t\texpSign = FALSE;\n\t}\n\tif (exp > maxExponent) {\n\t\texp = maxExponent;\n\t\terrno = ERANGE;\n\t}\n\tdblExp = 1.0;\n\tfor (d = powersOf10; exp != 0; exp >>= 1, d += 1) {\n\t\tif (exp & 01) {\n\t\t\tdblExp *= *d;\n\t\t}\n\t}\n\tif (expSign) {\n\t\tfraction /= dblExp;\n\t} else {\n\t\tfraction *= dblExp;\n\t}\n\ndone:\n\tif (endPtr != NULL) {\n\t\t*endPtr = (char *) p;\n\t}\n\n\tif (sign) {\n\t\treturn -fraction;\n\t}\n\treturn fraction;\n}"", ""target"": 0}]","[{""func_name"": ""js_strtod"", ""file_path"": ""jsdtoa.c"", ""func_code"": ""double\njs_strtod(const char *string, char **endPtr)\n{\n\tint sign, expSign = FALSE;\n\tdouble fraction, dblExp, *d;\n\tregister const char *p;\n\tregister int c;\n\n\t/* Exponent read from \""EX\"" field. */\n\tint exp = 0;\n\n\t/* Exponent that derives from the fractional part. Under normal\n\t * circumstances, it is the negative of the number of digits in F.\n\t * However, if I is very long, the last digits of I get dropped\n\t * (otherwise a long I with a large negative exponent could cause an\n\t * unnecessary overflow on I alone). In this case, fracExp is\n\t * incremented one for each dropped digit.\n\t */\n\tint fracExp = 0;\n\n\t/* Number of digits in mantissa. */\n\tint mantSize;\n\n\t/* Number of mantissa digits BEFORE decimal point. */\n\tint decPt;\n\n\t/* Temporarily holds location of exponent in string. */\n\tconst char *pExp;\n\n\t/*\n\t * Strip off leading blanks and check for a sign.\n\t */\n\n\tp = string;\n\twhile (*p == ' ' || *p == '\\t' || *p == '\\n' || *p == '\\r') {\n\t\tp += 1;\n\t}\n\tif (*p == '-') {\n\t\tsign = TRUE;\n\t\tp += 1;\n\t} else {\n\t\tif (*p == '+') {\n\t\t\tp += 1;\n\t\t}\n\t\tsign = FALSE;\n\t}\n\n\t/*\n\t * Count the number of digits in the mantissa (including the decimal\n\t * point), and also locate the decimal point.\n\t */\n\n\tdecPt = -1;\n\tfor (mantSize = 0; ; mantSize += 1)\n\t{\n\t\tc = *p;\n\t\tif (!(c>='0'&&c<='9')) {\n\t\t\tif ((c != '.') || (decPt >= 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdecPt = mantSize;\n\t\t}\n\t\tp += 1;\n\t}\n\n\t/*\n\t * Now suck up the digits in the mantissa. Use two integers to\n\t * collect 9 digits each (this is faster than using floating-point).\n\t * If the mantissa has more than 18 digits, ignore the extras, since\n\t * they can't affect the value anyway.\n\t */\n\n\tpExp = p;\n\tp -= mantSize;\n\tif (decPt < 0) {\n\t\tdecPt = mantSize;\n\t} else {\n\t\tmantSize -= 1;\t\t\t/* One of the digits was the point. */\n\t}\n\tif (mantSize > 18) {\n\t\tfracExp = decPt - 18;\n\t\tmantSize = 18;\n\t} else {\n\t\tfracExp = decPt - mantSize;\n\t}\n\tif (mantSize == 0) {\n\t\tfraction = 0.0;\n\t\tp = string;\n\t\tgoto done;\n\t} else {\n\t\tint frac1, frac2;\n\t\tfrac1 = 0;\n\t\tfor ( ; mantSize > 9; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac1 = 10*frac1 + (c - '0');\n\t\t}\n\t\tfrac2 = 0;\n\t\tfor (; mantSize > 0; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac2 = 10*frac2 + (c - '0');\n\t\t}\n\t\tfraction = (1.0e9 * frac1) + frac2;\n\t}\n\n\t/*\n\t * Skim off the exponent.\n\t */\n\n\tp = pExp;\n\tif ((*p == 'E') || (*p == 'e')) {\n\t\tp += 1;\n\t\tif (*p == '-') {\n\t\t\texpSign = TRUE;\n\t\t\tp += 1;\n\t\t} else {\n\t\t\tif (*p == '+') {\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\texpSign = FALSE;\n\t\t}\n\t\twhile ((*p >= '0') && (*p <= '9')) {\n\t\t\texp = exp * 10 + (*p - '0');\n\t\t\tp += 1;\n\t\t}\n\t}\n\tif (expSign) {\n\t\texp = fracExp - exp;\n\t} else {\n\t\texp = fracExp + exp;\n\t}\n\n\t/*\n\t * Generate a floating-point number that represents the exponent.\n\t * Do this by processing the exponent one bit at a time to combine\n\t * many powers of 2 of 10. Then combine the exponent with the\n\t * fraction.\n\t */\n\n\tif (exp < -maxExponent) {\n\t\texp = maxExponent;\n\t\texpSign = TRUE;\n\t\terrno = ERANGE;\n\t} else if (exp > maxExponent) {\n\t\texp = maxExponent;\n\t\texpSign = FALSE;\n\t\terrno = ERANGE;\n\t} else if (exp < 0) {\n\t\texpSign = TRUE;\n\t\texp = -exp;\n\t} else {\n\t\texpSign = FALSE;\n\t}\n\tdblExp = 1.0;\n\tfor (d = powersOf10; exp != 0; exp >>= 1, d += 1) {\n\t\tif (exp & 01) {\n\t\t\tdblExp *= *d;\n\t\t}\n\t}\n\tif (expSign) {\n\t\tfraction /= dblExp;\n\t} else {\n\t\tfraction *= dblExp;\n\t}\n\ndone:\n\tif (endPtr != NULL) {\n\t\t*endPtr = (char *) p;\n\t}\n\n\tif (sign) {\n\t\treturn -fraction;\n\t}\n\treturn fraction;\n}""}]","{""value"": 2}","[{""source"": ""value_info(file:jsdtoa.c, value:exp)"", ""result"": {""value_trace"": [{""full_code"": ""exp = 0"", ""line"": 571, ""func_name"": ""js_strtod""}, {""full_code"": ""exp = exp * 10 + (*p - '0')"", ""line"": 695, ""func_name"": ""js_strtod""}, {""full_code"": ""exp = fracExp - exp"", ""line"": 700, ""func_name"": ""js_strtod""}, {""full_code"": ""exp = fracExp + exp"", ""line"": 702, ""func_name"": ""js_strtod""}, {""full_code"": ""exp = -exp"", ""line"": 714, ""func_name"": ""js_strtod""}], ""struct_var"": ""exp"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""value_info(file:jsdtoa.c, value:maxExponent)"", ""result"": {""value_trace"": [{""full_code"": ""maxExponent = 511"", ""line"": 536, ""func_name"": ""jsdtoa.c:<global>""}], ""struct_var"": ""maxExponent"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}]","The vulnerability arises from unbounded exponent (`exp`) validation in `js_strtod` (jsdtoa.c:710-715). The original code checked `exp < 0` and `exp > maxExponent` sequentially, but failed to validate the absolute value of `exp` before negation. This allowed `exp` (built via `exp = exp * 10 + (*p - '0')` (jsdtoa.c:695) and `exp = fracExp  exp` (jsdtoa.c:700-702)) to exceed `maxExponent` (jsdtoa.c:536) after negation, causing overflow in the `powersOf10` loop. The patch clamps `exp` to `maxExponent` (jsdtoa.c:710-719) before negation, preventing overflow.",1.0,./github/other_context/CVE-2018-6191
11,CVE-2018-6315,"CWE-190, CWE-125",c_cpp,"The outputSWF_TEXT_RECORD function (util/outputscript.c) in libming through 0.4.8 is vulnerable to an integer overflow and resultant out-of-bounds read, which may allow attackers to cause a denial of service or unspecified other impact via a crafted SWF file.",https://github.com/libming/libming/commit/3120f1cdae0c5232a4fb15e5ce42b8c455b43379,"Fix NULL pointer deref in outputSWF_TEXT_RECORD\n\nIn outputSWF_TEXT_RECORD, the array offset is stored in a\nsigned int, while (&(trec->GlyphEntries[i]))->GlyphIndex[0]\nreturns an unsigned 32 bit number.\n\nThis may lead to an integer overflow when reading the offset\nfrom the GlyphIndex array, and further to a buffer overflow\nwhen doing buffer[i]=fi->fontcodeptr[off] with negative off.\n\nIn this commit, we change the type of off to unsigned long so\nwe are guaranteed to be able to store 32 unsigned integers.\n\nThis commit fixes CVE-2018-6315 (fixes #101).",1,"[{""func_name"": ""outputSWF_TEXT_RECORD"", ""file_path"": ""util/outputscript.c"", ""func_code"": ""static void\noutputSWF_TEXT_RECORD (SWF_TEXTRECORD *trec, int level,char *tname,char *buffer,int bsize,int id)\n{\n  int i=0;\n  struct FONTINFO *fi=fip;\n  if ( trec->TextRecordType == 0 )\n    return;\n  if (trec->StyleFlagHasFont)\n  {\n   printf(\""%s(\"" VAR \""f%d);\\n\"", methodcall (tname, \""setFont\""), trec->FontID);\n   printf(\""%s(%d);\\n\"",methodcall(tname,\""setHeight\""),trec->TextHeight);\n  }\n  if( trec->StyleFlagHasColor )\n  {\n   if (level==2)\n    printf (\""%s(0x%02x, 0x%02x, 0x%02x, 0x%02x);\\n\"",methodcall (tname, \""setColor\""),\n      trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue, trec->TextColor.alpha);\n   else\n    printf (\""%s(0x%02x, 0x%02x, 0x%02x);\\n\"",methodcall (tname, \""setColor\""),\n      trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue);\n  }\n  if( trec->StyleFlagHasYOffset || trec->StyleFlagHasXOffset ) \n  {\n    printf (\""%s(%d, %d);\\n\"", methodcall (tname, \""moveTo\""),trec->XOffset,trec->YOffset);\n  }\n  if (trec->FontID) \n  {\n    id=trec->FontID;\n  }\n  if (!trec->StyleFlagHasFont)\t\t\t\t/* always check flag before use data */\n  {\n   fi = fip_current;\t\t\t\t\t/* so cont w current font */\n\n   if (!fi)\n      SWF_warn(\""outputSWF_TEXT_RECORD: can't process text record: fonts information list is NULL\\n\"");\n   else\n      id = fi->fontcodeID;\t\t\t\t\t/* trigger next if */\n  }\n  while (fi)\n  {\n   if (fi->fontcodeID==id)\n   {\n    fip_current=fi;\t\t\t\t\t/* set current font */\n    for(i=0;i<trec->GlyphCount && i<bsize-1 ;i++)\t/* byte n-1 will be terminator '\\0' */\n    {\n     int off=(&(trec->GlyphEntries[i]))->GlyphIndex[0];\n     if (off<fi->fontcodearrsize)\n      buffer[i]=fi->fontcodeptr[off];\n     else\n      buffer[i]='?';\t\t/* fallback to dummy A */\n     /* printf ( COMMSTART \""GlyphIndex[0] = %d  char = %d \"" COMMEND\""\\n\"",off,fi->fontcodeptr[off] ); */\n    } \n    buffer[i]='\\0'; \n    return;\n   }\n   else\n    fi=fi->next;\n  }\n  buffer[0]='X';\t\t/* fallback to dummy B */\n  buffer[1]='\\0'; \n}"", ""target"": 0}]","[{""func_name"": ""outputSWF_TEXT_RECORD"", ""file_path"": ""util/outputscript.c"", ""func_code"": ""static void\noutputSWF_TEXT_RECORD (SWF_TEXTRECORD *trec, int level,char *tname,char *buffer,int bsize,int id)\n{\n  int i=0;\n  struct FONTINFO *fi=fip;\n  if ( trec->TextRecordType == 0 )\n    return;\n  if (trec->StyleFlagHasFont)\n  {\n   printf(\""%s(\"" VAR \""f%d);\\n\"", methodcall (tname, \""setFont\""), trec->FontID);\n   printf(\""%s(%d);\\n\"",methodcall(tname,\""setHeight\""),trec->TextHeight);\n  }\n  if( trec->StyleFlagHasColor )\n  {\n   if (level==2)\n    printf (\""%s(0x%02x, 0x%02x, 0x%02x, 0x%02x);\\n\"",methodcall (tname, \""setColor\""),\n      trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue, trec->TextColor.alpha);\n   else\n    printf (\""%s(0x%02x, 0x%02x, 0x%02x);\\n\"",methodcall (tname, \""setColor\""),\n      trec->TextColor.red,trec->TextColor.green,trec->TextColor.blue);\n  }\n  if( trec->StyleFlagHasYOffset || trec->StyleFlagHasXOffset ) \n  {\n    printf (\""%s(%d, %d);\\n\"", methodcall (tname, \""moveTo\""),trec->XOffset,trec->YOffset);\n  }\n  if (trec->FontID) \n  {\n    id=trec->FontID;\n  }\n  if (!trec->StyleFlagHasFont)\t\t\t\t/* always check flag before use data */\n  {\n   fi = fip_current;\t\t\t\t\t/* so cont w current font */\n\n   if (!fi)\n      SWF_warn(\""outputSWF_TEXT_RECORD: can't process text record: fonts information list is NULL\\n\"");\n   else\n      id = fi->fontcodeID;\t\t\t\t\t/* trigger next if */\n  }\n  while (fi)\n  {\n   if (fi->fontcodeID==id)\n   {\n    fip_current=fi;\t\t\t\t\t/* set current font */\n    for(i=0;i<trec->GlyphCount && i<bsize-1 ;i++)\t/* byte n-1 will be terminator '\\0' */\n    {\n     unsigned long off=(&(trec->GlyphEntries[i]))->GlyphIndex[0];\n     if (off<fi->fontcodearrsize)\n      buffer[i]=fi->fontcodeptr[off];\n     else\n      buffer[i]='?';\t\t/* fallback to dummy A */\n     /* printf ( COMMSTART \""GlyphIndex[0] = %d  char = %d \"" COMMEND\""\\n\"",off,fi->fontcodeptr[off] ); */\n    } \n    buffer[i]='\\0'; \n    return;\n   }\n   else\n    fi=fi->next;\n  }\n  buffer[0]='X';\t\t/* fallback to dummy B */\n  buffer[1]='\\0'; \n}""}]","{""value"": 3, ""function"": 1}","[{""source"": ""value_info(file:outputscript.c, value:fi->fontcodearrsize)"", ""result"": {""value_trace"": [{""full_code"": ""fi->fontcodearrsize=numglyph"", ""line"": 1188, ""func_name"": ""saveFontInfo""}], ""struct_var"": ""fi"", ""struct_type"": ""FONTINFO*"", ""struct_definition"": ""struct FONTINFO {\t\t/* a linked list for all our font code info: */\n int *fontcodeptr;\t\t/* built in several outputSWF_DEFINEFONTxxxx(), used in outputSWF_TEXT_RECORD() */\n int fontcodearrsize;\n int fontcodeID;\n struct FONTINFO *next;\n}\n\nstruct FONTINFO\n\nstatic struct FONTINFO\n\nstatic struct FONTINFO""}}, {""source"": ""value_info(file:outputscript.c, value:GlyphIndex)"", ""result"": {""value_trace"": [{""full_code"": ""gerec->GlyphIndex = malloc(nmalloc)"", ""line"": 247, ""func_name"": ""parseSWF_GLYPHENTRY""}, {""full_code"": ""gerec->GlyphIndex[0] = 0"", ""line"": 248, ""func_name"": ""parseSWF_GLYPHENTRY""}, {""full_code"": ""gerec->GlyphIndex[i] = readBits(f, 32)"", ""line"": 252, ""func_name"": ""parseSWF_GLYPHENTRY""}, {""full_code"": ""gerec->GlyphIndex[i] = readBits(f, glyphbits)"", ""line"": 255, ""func_name"": ""parseSWF_GLYPHENTRY""}], ""struct_var"": ""GlyphIndex"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:readBits)"", ""result"": [{""code"": ""int readBits(FILE *f, int number)\n{\n  int ret = buffer;\n\n  if(number == bufbits)\n  {\n    bufbits = 0;\n    buffer = 0;\n    return ret;\n  }\n\n  if(number > bufbits)\n  {\n    number -= bufbits;\n\n    while(number>8)\n    {\n      ret <<= 8;\n      ret += fgetc(f);\n      if (feof(f))\n      {\n        fprintf(stderr, \""truncated file\\n\"");\n        exit(-1);\n      }\n\n      ++fileOffset;\n      number -= 8;\n    }\n\n    ++fileOffset;\n    buffer = fgetc(f);\n    if (feof(f))\n    {\n      fprintf(stderr, \""truncated file\\n\"");\n      exit(-1);\n    }\n\n\n    if(number>0)\n    {\n      ret <<= number;\n      bufbits = 8-number;\n      ret += buffer >> (8-number);\n      buffer &= (1<<bufbits)-1;\n    }\n\n    return ret;\n  }\n\n  ret = buffer >> (bufbits-number);\n  bufbits -= number;\n  buffer &= (1<<bufbits)-1;\n\n  return ret;\n}"", ""start_line"": 55, ""end_line"": 109, ""full_name"": ""readBits"", ""file_path"": ""util/listfdb.c""}, {""code"": ""int readBits(FILE *f, int number)\n{\n  int ret = buffer;\n  int tmp_char;\n\n  if(number == bufbits)\n  {\n    bufbits = 0;\n    buffer = 0;\n    return ret;\n  }\n\n  if(number > bufbits)\n  {\n    number -= bufbits;\n\n    while(number>8)\n    {\n      tmp_char = fgetc(f);\n      if (tmp_char == EOF)\n      {\n        // exit here instead of crashing elswhere\n        fprintf(stderr, \""truncated file\\n\"");\n        exit(-1);\n      }\n\n      ret <<= 8;\n      ret += tmp_char;\n      ++fileOffset;\n      number -= 8;\n    }\n\n    ++fileOffset;\n    tmp_char = fgetc(f);\n    if (tmp_char == EOF)\n    {\n      // exit here instead of crashing elswhere\n      fprintf(stderr, \""truncated file\\n\"");\n      exit(-1);\n    }\n\n    buffer = tmp_char;\n\n    if(number>0)\n    {\n      ret <<= number;\n      bufbits = 8-number;\n      ret += buffer >> (8-number);\n      buffer &= (1<<bufbits)-1;\n    }\n\n    return ret;\n  }\n\n  ret = buffer >> (bufbits-number);\n  bufbits -= number;\n  buffer &= (1<<bufbits)-1;\n\n  return ret;\n}"", ""start_line"": 45, ""end_line"": 104, ""full_name"": ""readBits<duplicate>0"", ""file_path"": ""util/read.c""}]}, {""source"": ""value_info(file:outputscript.c, value:GlyphEntries)"", ""result"": {""value_trace"": [{""full_code"": ""brec->GlyphEntries = malloc(brec->GlyphCount * sizeof(SWF_GLYPHENTRY) )"", ""line"": 316, ""func_name"": ""parseSWF_TEXTRECORD""}], ""struct_var"": ""GlyphEntries"", ""struct_type"": null, ""struct_definition"": null}}]","util/outputscript.c:1440: 'int off' stores GlyphIndex[0] (a 32-bit unsigned value from readBits(f, 32), util/outputscript.c:252-255). When GlyphIndex[0] exceeds 0x7FFFFFFF (max signed int), 'off' becomes negative. The check 'off < fi->fontcodearrsize' (util/outputscript.c:1442) is bypassed (since 'fontcodearrsize' is an int), enabling out-of-bounds access in 'fi->fontcodeptr[off]'.",0.95,./github/other_context/CVE-2018-6315
12,CVE-2019-10878,"CWE-787, CWE-190",c_cpp,"In Teeworlds 0.7.2, there is a failed bounds check in CDataFileReader::GetData() and CDataFileReader::ReplaceData() and related functions in engine/shared/datafile.cpp that can lead to an arbitrary free and out-of-bounds pointer write, possibly resulting in remote code execution.",https://github.com/teeworlds/teeworlds/commit/e086f4b35b1adf7edc35b4ad332dc7ed1edc5988,Add bound check in datafile.cpp anywhere m_ppDataPtrs is accessed as an array. Should fix #2073,3,"[{""func_name"": ""CDataFileReader::UnloadData"", ""file_path"": ""src/engine/shared/datafile.cpp"", ""func_code"": ""void CDataFileReader::UnloadData(int Index)\n{\n\tif(Index < 0)\n\t\treturn;\n\n\t//\n\tmem_free(m_pDataFile->m_ppDataPtrs[Index]);\n\tm_pDataFile->m_ppDataPtrs[Index] = 0x0;\n}"", ""target"": 0}, {""func_name"": ""CDataFileReader::ReplaceData"", ""file_path"": ""src/engine/shared/datafile.cpp"", ""func_code"": ""void CDataFileReader::ReplaceData(int Index, char *pData)\n{\n\t// make sure the data has been loaded\n\tGetDataImpl(Index, 0);\n\n\tUnloadData(Index);\n\tm_pDataFile->m_ppDataPtrs[Index] = pData;\n}"", ""target"": 0}, {""func_name"": ""CDataFileReader::GetDataImpl"", ""file_path"": ""src/engine/shared/datafile.cpp"", ""func_code"": ""void *CDataFileReader::GetDataImpl(int Index, int Swap)\n{\n\tif(!m_pDataFile) { return 0; }\n\n\t// load it if needed\n\tif(!m_pDataFile->m_ppDataPtrs[Index])\n\t{\n\t\t// fetch the data size\n\t\tint DataSize = GetDataSize(Index);\n#if defined(CONF_ARCH_ENDIAN_BIG)\n\t\tint SwapSize = DataSize;\n#endif\n\n\t\tif(m_pDataFile->m_Header.m_Version == 4)\n\t\t{\n\t\t\t// v4 has compressed data\n\t\t\tvoid *pTemp = (char *)mem_alloc(DataSize, 1);\n\t\t\tunsigned long UncompressedSize = m_pDataFile->m_Info.m_pDataSizes[Index];\n\t\t\tunsigned long s;\n\n\t\t\tdbg_msg(\""datafile\"", \""loading data index=%d size=%d uncompressed=%lu\"", Index, DataSize, UncompressedSize);\n\t\t\tm_pDataFile->m_ppDataPtrs[Index] = (char *)mem_alloc(UncompressedSize, 1);\n\n\t\t\t// read the compressed data\n\t\t\tio_seek(m_pDataFile->m_File, m_pDataFile->m_DataStartOffset+m_pDataFile->m_Info.m_pDataOffsets[Index], IOSEEK_START);\n\t\t\tio_read(m_pDataFile->m_File, pTemp, DataSize);\n\n\t\t\t// decompress the data, TODO: check for errors\n\t\t\ts = UncompressedSize;\n\t\t\tuncompress((Bytef*)m_pDataFile->m_ppDataPtrs[Index], &s, (Bytef*)pTemp, DataSize); // ignore_convention\n#if defined(CONF_ARCH_ENDIAN_BIG)\n\t\t\tSwapSize = s;\n#endif\n\n\t\t\t// clean up the temporary buffers\n\t\t\tmem_free(pTemp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// load the data\n\t\t\tdbg_msg(\""datafile\"", \""loading data index=%d size=%d\"", Index, DataSize);\n\t\t\tm_pDataFile->m_ppDataPtrs[Index] = (char *)mem_alloc(DataSize, 1);\n\t\t\tio_seek(m_pDataFile->m_File, m_pDataFile->m_DataStartOffset+m_pDataFile->m_Info.m_pDataOffsets[Index], IOSEEK_START);\n\t\t\tio_read(m_pDataFile->m_File, m_pDataFile->m_ppDataPtrs[Index], DataSize);\n\t\t}\n\n#if defined(CONF_ARCH_ENDIAN_BIG)\n\t\tif(Swap && SwapSize)\n\t\t\tswap_endian(m_pDataFile->m_ppDataPtrs[Index], sizeof(int), SwapSize/sizeof(int));\n#endif\n\t}\n\n\treturn m_pDataFile->m_ppDataPtrs[Index];\n}"", ""target"": 0}]","[{""func_name"": ""CDataFileReader::UnloadData"", ""file_path"": ""src/engine/shared/datafile.cpp"", ""func_code"": ""void CDataFileReader::UnloadData(int Index)\n{\n\tif(Index < 0 || Index >= m_pDataFile->m_Header.m_NumRawData)\n\t\treturn;\n\n\tmem_free(m_pDataFile->m_ppDataPtrs[Index]);\n\tm_pDataFile->m_ppDataPtrs[Index] = 0x0;\n}""}, {""func_name"": ""CDataFileReader::ReplaceData"", ""file_path"": ""src/engine/shared/datafile.cpp"", ""func_code"": ""void CDataFileReader::ReplaceData(int Index, char *pData)\n{\n\tif(Index < 0 || Index >= m_pDataFile->m_Header.m_NumRawData)\n\t\treturn;\n\n\t// make sure the data has been loaded\n\tGetDataImpl(Index, 0);\n\n\tUnloadData(Index);\n\tm_pDataFile->m_ppDataPtrs[Index] = pData;\n}""}, {""func_name"": ""CDataFileReader::GetDataImpl"", ""file_path"": ""src/engine/shared/datafile.cpp"", ""func_code"": ""void *CDataFileReader::GetDataImpl(int Index, int Swap)\n{\n\tif(!m_pDataFile) { return 0; }\n\n\tif(Index < 0 || Index >= m_pDataFile->m_Header.m_NumRawData)\n\t\treturn 0;\n\n\t// load it if needed\n\tif(!m_pDataFile->m_ppDataPtrs[Index])\n\t{\n\t\t// fetch the data size\n\t\tint DataSize = GetDataSize(Index);\n#if defined(CONF_ARCH_ENDIAN_BIG)\n\t\tint SwapSize = DataSize;\n#endif\n\n\t\tif(m_pDataFile->m_Header.m_Version == 4)\n\t\t{\n\t\t\t// v4 has compressed data\n\t\t\tvoid *pTemp = (char *)mem_alloc(DataSize, 1);\n\t\t\tunsigned long UncompressedSize = m_pDataFile->m_Info.m_pDataSizes[Index];\n\t\t\tunsigned long s;\n\n\t\t\tdbg_msg(\""datafile\"", \""loading data index=%d size=%d uncompressed=%lu\"", Index, DataSize, UncompressedSize);\n\t\t\tm_pDataFile->m_ppDataPtrs[Index] = (char *)mem_alloc(UncompressedSize, 1);\n\n\t\t\t// read the compressed data\n\t\t\tio_seek(m_pDataFile->m_File, m_pDataFile->m_DataStartOffset+m_pDataFile->m_Info.m_pDataOffsets[Index], IOSEEK_START);\n\t\t\tio_read(m_pDataFile->m_File, pTemp, DataSize);\n\n\t\t\t// decompress the data, TODO: check for errors\n\t\t\ts = UncompressedSize;\n\t\t\tuncompress((Bytef*)m_pDataFile->m_ppDataPtrs[Index], &s, (Bytef*)pTemp, DataSize); // ignore_convention\n#if defined(CONF_ARCH_ENDIAN_BIG)\n\t\t\tSwapSize = s;\n#endif\n\n\t\t\t// clean up the temporary buffers\n\t\t\tmem_free(pTemp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// load the data\n\t\t\tdbg_msg(\""datafile\"", \""loading data index=%d size=%d\"", Index, DataSize);\n\t\t\tm_pDataFile->m_ppDataPtrs[Index] = (char *)mem_alloc(DataSize, 1);\n\t\t\tio_seek(m_pDataFile->m_File, m_pDataFile->m_DataStartOffset+m_pDataFile->m_Info.m_pDataOffsets[Index], IOSEEK_START);\n\t\t\tio_read(m_pDataFile->m_File, m_pDataFile->m_ppDataPtrs[Index], DataSize);\n\t\t}\n\n#if defined(CONF_ARCH_ENDIAN_BIG)\n\t\tif(Swap && SwapSize)\n\t\t\tswap_endian(m_pDataFile->m_ppDataPtrs[Index], sizeof(int), SwapSize/sizeof(int));\n#endif\n\t}\n\n\treturn m_pDataFile->m_ppDataPtrs[Index];\n}""}]","{""function"": 1, ""code"": 1, ""value"": 1}","[{""source"": ""func_info(file:datafile.cpp, func:GetData)"", ""result"": [{""code"": ""void *CDataFileReader::GetData(int Index)\n{\n\treturn GetDataImpl(Index, 0);\n}"", ""start_line"": 303, ""end_line"": 306, ""full_name"": ""CDataFileReader.GetData:void*(int)"", ""file_path"": ""src/engine/shared/datafile.cpp""}]}, {""source"": ""code_info(file:datafile.cpp, lines:1-500)"", ""result"": ""/* (c) Magnus Auvinen. See licence.txt in the root of the distribution for more information. */\n/* If you are missing that file, acquire a complete release at teeworlds.com.                */\n#include <base/hash_ctxt.h>\n#include <base/math.h>\n#include <base/system.h>\n#include <engine/storage.h>\n#include \""datafile.h\""\n#include <zlib.h>\n\nstatic const int DEBUG=0;\n\nstruct CDatafileItemType\n{\n\tint m_Type;\n\tint m_Start;\n\tint m_Num;\n} ;\n\nstruct CDatafileItem\n{\n\tint m_TypeAndID;\n\tint m_Size;\n};\n\nstruct CDatafileHeader\n{\n\tchar m_aID[4];\n\tint m_Version;\n\tint m_Size;\n\tint m_Swaplen;\n\tint m_NumItemTypes;\n\tint m_NumItems;\n\tint m_NumRawData;\n\tint m_ItemSize;\n\tint m_DataSize;\n};\n\nstruct CDatafileData\n{\n\tint m_NumItemTypes;\n\tint m_NumItems;\n\tint m_NumRawData;\n\tint m_ItemSize;\n\tint m_DataSize;\n\tchar m_aStart[4];\n};\n\nstruct CDatafileInfo\n{\n\tCDatafileItemType *m_pItemTypes;\n\tint *m_pItemOffsets;\n\tint *m_pDataOffsets;\n\tint *m_pDataSizes;\n\n\tchar *m_pItemStart;\n\tchar *m_pDataStart;\n};\n\nstruct CDatafile\n{\n\tIOHANDLE m_File;\n\tSHA256_DIGEST m_Sha256;\n\tunsigned m_Crc;\n\tCDatafileInfo m_Info;\n\tCDatafileHeader m_Header;\n\tint m_DataStartOffset;\n\tchar **m_ppDataPtrs;\n\tchar *m_pData;\n};\n\nbool CDataFileReader::Open(class IStorage *pStorage, const char *pFilename, int StorageType)\n{\n\tdbg_msg(\""datafile\"", \""loading. filename='%s'\"", pFilename);\n\n\tIOHANDLE File = pStorage->OpenFile(pFilename, IOFLAG_READ, StorageType);\n\tif(!File)\n\t{\n\t\tdbg_msg(\""datafile\"", \""could not open '%s'\"", pFilename);\n\t\treturn false;\n\t}\n\n\n\t// take the hashes of the file and store them\n\tSHA256_CTX Sha256Ctx;\n\tsha256_init(&Sha256Ctx);\n\tunsigned Crc = crc32(0L, 0x0, 0);\n\t{\n\t\tenum\n\t\t{\n\t\t\tBUFFER_SIZE = 64*1024\n\t\t};\n\n\t\tunsigned char aBuffer[BUFFER_SIZE];\n\n\t\twhile(1)\n\t\t{\n\t\t\tunsigned Bytes = io_read(File, aBuffer, BUFFER_SIZE);\n\t\t\tif(Bytes == 0)\n\t\t\t\tbreak;\n\t\t\tsha256_update(&Sha256Ctx, aBuffer, Bytes);\n\t\t\tCrc = crc32(Crc, aBuffer, Bytes); // ignore_convention\n\t\t}\n\n\t\tio_seek(File, 0, IOSEEK_START);\n\t}\n\n\t// TODO: change this header\n\tCDatafileHeader Header;\n\tio_read(File, &Header, sizeof(Header));\n\tif(Header.m_aID[0] != 'A' || Header.m_aID[1] != 'T' || Header.m_aID[2] != 'A' || Header.m_aID[3] != 'D')\n\t{\n\t\tif(Header.m_aID[0] != 'D' || Header.m_aID[1] != 'A' || Header.m_aID[2] != 'T' || Header.m_aID[3] != 'A')\n\t\t{\n\t\t\tdbg_msg(\""datafile\"", \""wrong signature. %x %x %x %x\"", Header.m_aID[0], Header.m_aID[1], Header.m_aID[2], Header.m_aID[3]);\n\t\t\tio_close(File);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n#if defined(CONF_ARCH_ENDIAN_BIG)\n\tswap_endian(&Header, sizeof(int), sizeof(Header)/sizeof(int));\n#endif\n\tif(Header.m_Version != 3 && Header.m_Version != 4)\n\t{\n\t\tdbg_msg(\""datafile\"", \""wrong version. version=%x\"", Header.m_Version);\n\t\tio_close(File);\n\t\treturn 0;\n\t}\n\n\t// read in the rest except the data\n\tunsigned Size = 0;\n\tSize += Header.m_NumItemTypes*sizeof(CDatafileItemType);\n\tSize += (Header.m_NumItems+Header.m_NumRawData)*sizeof(int);\n\tif(Header.m_Version == 4)\n\t\tSize += Header.m_NumRawData*sizeof(int); // v4 has uncompressed data sizes aswell\n\tSize += Header.m_ItemSize;\n\n\tunsigned AllocSize = Size;\n\tAllocSize += sizeof(CDatafile); // add space for info structure\n\tAllocSize += Header.m_NumRawData*sizeof(void*); // add space for data pointers\n\n\tCDatafile *pTmpDataFile = (CDatafile*)mem_alloc(AllocSize, 1);\n\tpTmpDataFile->m_Header = Header;\n\tpTmpDataFile->m_DataStartOffset = sizeof(CDatafileHeader) + Size;\n\tpTmpDataFile->m_ppDataPtrs = (char**)(pTmpDataFile+1);\n\tpTmpDataFile->m_pData = (char *)(pTmpDataFile+1)+Header.m_NumRawData*sizeof(char *);\n\tpTmpDataFile->m_File = File;\n\tpTmpDataFile->m_Sha256 = sha256_finish(&Sha256Ctx);\n\tpTmpDataFile->m_Crc = Crc;\n\n\t// clear the data pointers\n\tmem_zero(pTmpDataFile->m_ppDataPtrs, Header.m_NumRawData*sizeof(void*));\n\n\t// read types, offsets, sizes and item data\n\tunsigned ReadSize = io_read(File, pTmpDataFile->m_pData, Size);\n\tif(ReadSize != Size)\n\t{\n\t\tio_close(pTmpDataFile->m_File);\n\t\tmem_free(pTmpDataFile);\n\t\tpTmpDataFile = 0;\n\t\tdbg_msg(\""datafile\"", \""couldn't load the whole thing, wanted=%d got=%d\"", Size, ReadSize);\n\t\treturn false;\n\t}\n\n\tClose();\n\tm_pDataFile = pTmpDataFile;\n\n#if defined(CONF_ARCH_ENDIAN_BIG)\n\tswap_endian(m_pDataFile->m_pData, sizeof(int), min(static_cast<unsigned>(Header.m_Swaplen), Size) / sizeof(int));\n#endif\n\n\t//if(DEBUG)\n\t{\n\t\tdbg_msg(\""datafile\"", \""allocsize=%d\"", AllocSize);\n\t\tdbg_msg(\""datafile\"", \""readsize=%d\"", ReadSize);\n\t\tdbg_msg(\""datafile\"", \""swaplen=%d\"", Header.m_Swaplen);\n\t\tdbg_msg(\""datafile\"", \""item_size=%d\"", m_pDataFile->m_Header.m_ItemSize);\n\t}\n\n\tm_pDataFile->m_Info.m_pItemTypes = (CDatafileItemType *)m_pDataFile->m_pData;\n\tm_pDataFile->m_Info.m_pItemOffsets = (int *)&m_pDataFile->m_Info.m_pItemTypes[m_pDataFile->m_Header.m_NumItemTypes];\n\tm_pDataFile->m_Info.m_pDataOffsets = (int *)&m_pDataFile->m_Info.m_pItemOffsets[m_pDataFile->m_Header.m_NumItems];\n\tm_pDataFile->m_Info.m_pDataSizes = (int *)&m_pDataFile->m_Info.m_pDataOffsets[m_pDataFile->m_Header.m_NumRawData];\n\n\tif(Header.m_Version == 4)\n\t\tm_pDataFile->m_Info.m_pItemStart = (char *)&m_pDataFile->m_Info.m_pDataSizes[m_pDataFile->m_Header.m_NumRawData];\n\telse\n\t\tm_pDataFile->m_Info.m_pItemStart = (char *)&m_pDataFile->m_Info.m_pDataOffsets[m_pDataFile->m_Header.m_NumRawData];\n\tm_pDataFile->m_Info.m_pDataStart = m_pDataFile->m_Info.m_pItemStart + m_pDataFile->m_Header.m_ItemSize;\n\n\tdbg_msg(\""datafile\"", \""loading done. datafile='%s'\"", pFilename);\n\n\tif(DEBUG)\n\t{\n\t\t/*\n\t\tfor(int i = 0; i < m_pDataFile->data.num_raw_data; i++)\n\t\t{\n\t\t\tvoid *p = datafile_get_data(df, i);\n\t\t\tdbg_msg(\""datafile\"", \""%d %d\"", (int)((char*)p - (char*)(&m_pDataFile->data)), size);\n\t\t}\n\n\t\tfor(int i = 0; i < datafile_num_items(df); i++)\n\t\t{\n\t\t\tint type, id;\n\t\t\tvoid *data = datafile_get_item(df, i, &type, &id);\n\t\t\tdbg_msg(\""map\"", \""\\t%d: type=%x id=%x p=%p offset=%d\"", i, type, id, data, m_pDataFile->info.item_offsets[i]);\n\t\t\tint *idata = (int*)data;\n\t\t\tfor(int k = 0; k < 3; k++)\n\t\t\t\tdbg_msg(\""datafile\"", \""\\t\\t%d=%d (%x)\"", k, idata[k], idata[k]);\n\t\t}\n\n\t\tfor(int i = 0; i < m_pDataFile->data.num_m_aItemTypes; i++)\n\t\t{\n\t\t\tdbg_msg(\""map\"", \""\\t%d: type=%x start=%d num=%d\"", i,\n\t\t\t\tm_pDataFile->info.m_aItemTypes[i].type,\n\t\t\t\tm_pDataFile->info.m_aItemTypes[i].start,\n\t\t\t\tm_pDataFile->info.m_aItemTypes[i].num);\n\t\t\tfor(int k = 0; k < m_pDataFile->info.m_aItemTypes[i].num; k++)\n\t\t\t{\n\t\t\t\tint type, id;\n\t\t\t\tdatafile_get_item(df, m_pDataFile->info.m_aItemTypes[i].start+k, &type, &id);\n\t\t\t\tif(type != m_pDataFile->info.m_aItemTypes[i].type)\n\t\t\t\t\tdbg_msg(\""map\"", \""\\tERROR\"");\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n\n\treturn true;\n}\n\nint CDataFileReader::NumData() const\n{\n\tif(!m_pDataFile) { return 0; }\n\treturn m_pDataFile->m_Header.m_NumRawData;\n}\n\n// always returns the size in the file\nint CDataFileReader::GetDataSize(int Index) const\n{\n\tif(!m_pDataFile) { return 0; }\n\n\tif(Index == m_pDataFile->m_Header.m_NumRawData-1)\n\t\treturn m_pDataFile->m_Header.m_DataSize-m_pDataFile->m_Info.m_pDataOffsets[Index];\n\treturn m_pDataFile->m_Info.m_pDataOffsets[Index+1]-m_pDataFile->m_Info.m_pDataOffsets[Index];\n}\n\nvoid *CDataFileReader::GetDataImpl(int Index, int Swap)\n{\n\tif(!m_pDataFile) { return 0; }\n\n\t// load it if needed\n\tif(!m_pDataFile->m_ppDataPtrs[Index])\n\t{\n\t\t// fetch the data size\n\t\tint DataSize = GetDataSize(Index);\n#if defined(CONF_ARCH_ENDIAN_BIG)\n\t\tint SwapSize = DataSize;\n#endif\n\n\t\tif(m_pDataFile->m_Header.m_Version == 4)\n\t\t{\n\t\t\t// v4 has compressed data\n\t\t\tvoid *pTemp = (char *)mem_alloc(DataSize, 1);\n\t\t\tunsigned long UncompressedSize = m_pDataFile->m_Info.m_pDataSizes[Index];\n\t\t\tunsigned long s;\n\n\t\t\tdbg_msg(\""datafile\"", \""loading data index=%d size=%d uncompressed=%lu\"", Index, DataSize, UncompressedSize);\n\t\t\tm_pDataFile->m_ppDataPtrs[Index] = (char *)mem_alloc(UncompressedSize, 1);\n\n\t\t\t// read the compressed data\n\t\t\tio_seek(m_pDataFile->m_File, m_pDataFile->m_DataStartOffset+m_pDataFile->m_Info.m_pDataOffsets[Index], IOSEEK_START);\n\t\t\tio_read(m_pDataFile->m_File, pTemp, DataSize);\n\n\t\t\t// decompress the data, TODO: check for errors\n\t\t\ts = UncompressedSize;\n\t\t\tuncompress((Bytef*)m_pDataFile->m_ppDataPtrs[Index], &s, (Bytef*)pTemp, DataSize); // ignore_convention\n#if defined(CONF_ARCH_ENDIAN_BIG)\n\t\t\tSwapSize = s;\n#endif\n\n\t\t\t// clean up the temporary buffers\n\t\t\tmem_free(pTemp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// load the data\n\t\t\tdbg_msg(\""datafile\"", \""loading data index=%d size=%d\"", Index, DataSize);\n\t\t\tm_pDataFile->m_ppDataPtrs[Index] = (char *)mem_alloc(DataSize, 1);\n\t\t\tio_seek(m_pDataFile->m_File, m_pDataFile->m_DataStartOffset+m_pDataFile->m_Info.m_pDataOffsets[Index], IOSEEK_START);\n\t\t\tio_read(m_pDataFile->m_File, m_pDataFile->m_ppDataPtrs[Index], DataSize);\n\t\t}\n\n#if defined(CONF_ARCH_ENDIAN_BIG)\n\t\tif(Swap && SwapSize)\n\t\t\tswap_endian(m_pDataFile->m_ppDataPtrs[Index], sizeof(int), SwapSize/sizeof(int));\n#endif\n\t}\n\n\treturn m_pDataFile->m_ppDataPtrs[Index];\n}\n\nvoid *CDataFileReader::GetData(int Index)\n{\n\treturn GetDataImpl(Index, 0);\n}\n\nvoid *CDataFileReader::GetDataSwapped(int Index)\n{\n\treturn GetDataImpl(Index, 1);\n}\n\nvoid CDataFileReader::ReplaceData(int Index, char *pData)\n{\n\t// make sure the data has been loaded\n\tGetDataImpl(Index, 0);\n\n\tUnloadData(Index);\n\tm_pDataFile->m_ppDataPtrs[Index] = pData;\n}\n\nvoid CDataFileReader::UnloadData(int Index)\n{\n\tif(Index < 0)\n\t\treturn;\n\n\t//\n\tmem_free(m_pDataFile->m_ppDataPtrs[Index]);\n\tm_pDataFile->m_ppDataPtrs[Index] = 0x0;\n}\n\nint CDataFileReader::GetItemSize(int Index) const\n{\n\tif(!m_pDataFile) { return 0; }\n\tif(Index == m_pDataFile->m_Header.m_NumItems-1)\n\t\treturn m_pDataFile->m_Header.m_ItemSize-m_pDataFile->m_Info.m_pItemOffsets[Index];\n\treturn m_pDataFile->m_Info.m_pItemOffsets[Index+1]-m_pDataFile->m_Info.m_pItemOffsets[Index];\n}\n\nvoid *CDataFileReader::GetItem(int Index, int *pType, int *pID)\n{\n\tif(!m_pDataFile) { if(pType) *pType = 0; if(pID) *pID = 0; return 0; }\n\n\tCDatafileItem *i = (CDatafileItem *)(m_pDataFile->m_Info.m_pItemStart+m_pDataFile->m_Info.m_pItemOffsets[Index]);\n\tif(pType)\n\t\t*pType = (i->m_TypeAndID>>16)&0xffff; // remove sign extention\n\tif(pID)\n\t\t*pID = i->m_TypeAndID&0xffff;\n\treturn (void *)(i+1);\n}\n\nvoid CDataFileReader::GetType(int Type, int *pStart, int *pNum)\n{\n\t*pStart = 0;\n\t*pNum = 0;\n\n\tif(!m_pDataFile)\n\t\treturn;\n\n\tfor(int i = 0; i < m_pDataFile->m_Header.m_NumItemTypes; i++)\n\t{\n\t\tif(m_pDataFile->m_Info.m_pItemTypes[i].m_Type == Type)\n\t\t{\n\t\t\t*pStart = m_pDataFile->m_Info.m_pItemTypes[i].m_Start;\n\t\t\t*pNum = m_pDataFile->m_Info.m_pItemTypes[i].m_Num;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid *CDataFileReader::FindItem(int Type, int ID)\n{\n\tif(!m_pDataFile) return 0;\n\n\tint Start, Num;\n\tGetType(Type, &Start, &Num);\n\tfor(int i = 0; i < Num; i++)\n\t{\n\t\tint ItemID;\n\t\tvoid *pItem = GetItem(Start+i,0, &ItemID);\n\t\tif(ID == ItemID)\n\t\t\treturn pItem;\n\t}\n\treturn 0;\n}\n\nint CDataFileReader::NumItems() const\n{\n\tif(!m_pDataFile) return 0;\n\treturn m_pDataFile->m_Header.m_NumItems;\n}\n\nbool CDataFileReader::Close()\n{\n\tif(!m_pDataFile)\n\t\treturn true;\n\n\t// free the data that is loaded\n\tint i;\n\tfor(i = 0; i < m_pDataFile->m_Header.m_NumRawData; i++)\n\t\tmem_free(m_pDataFile->m_ppDataPtrs[i]);\n\n\tio_close(m_pDataFile->m_File);\n\tmem_free(m_pDataFile);\n\tm_pDataFile = 0;\n\treturn true;\n}\n\nSHA256_DIGEST CDataFileReader::Sha256() const\n{\n\tif(!m_pDataFile) return SHA256_ZEROED;\n\treturn m_pDataFile->m_Sha256;\n}\n\nunsigned CDataFileReader::Crc() const\n{\n\tif(!m_pDataFile) return 0xFFFFFFFF;\n\treturn m_pDataFile->m_Crc;\n}\n\n\nCDataFileWriter::CDataFileWriter()\n{\n\tm_File = 0;\n\tm_pItemTypes = static_cast<CItemTypeInfo *>(mem_alloc(sizeof(CItemTypeInfo) * MAX_ITEM_TYPES, 1));\n\tm_pItems = static_cast<CItemInfo *>(mem_alloc(sizeof(CItemInfo) * MAX_ITEMS, 1));\n\tm_pDatas = static_cast<CDataInfo *>(mem_alloc(sizeof(CDataInfo) * MAX_DATAS, 1));\n}\n\nCDataFileWriter::~CDataFileWriter()\n{\n\tmem_free(m_pItemTypes);\n\tm_pItemTypes = 0;\n\tmem_free(m_pItems);\n\tm_pItems = 0;\n\tmem_free(m_pDatas);\n\tm_pDatas = 0;\n}\n\nbool CDataFileWriter::Open(class IStorage *pStorage, const char *pFilename)\n{\n\tdbg_assert(!m_File, \""a file already exists\"");\n\tm_File = pStorage->OpenFile(pFilename, IOFLAG_WRITE, IStorage::TYPE_SAVE);\n\tif(!m_File)\n\t\treturn false;\n\n\tm_NumItems = 0;\n\tm_NumDatas = 0;\n\tm_NumItemTypes = 0;\n\tmem_zero(m_pItemTypes, sizeof(CItemTypeInfo) * MAX_ITEM_TYPES);\n\n\tfor(int i = 0; i < MAX_ITEM_TYPES; i++)\n\t{\n\t\tm_pItemTypes[i].m_First = -1;\n\t\tm_pItemTypes[i].m_Last = -1;\n\t}\n\n\treturn true;\n}\n\nint CDataFileWriter::AddItem(int Type, int ID, int Size, void *pData)\n{\n\tif(!m_File) return 0;\n\n\tdbg_assert(Type >= 0 && Type < 0xFFFF, \""incorrect type\"");\n\tdbg_assert(m_NumItems < 1024, \""too many items\"");\n\tdbg_assert(Size%sizeof(int) == 0, \""incorrect boundary\"");\n\n\tm_pItems[m_NumItems].m_Type = Type;\n\tm_pItems[m_NumItems].m_ID = ID;\n\tm_pItems[m_NumItems].m_Size = Size;\n\n\t// copy data\n\tm_pItems[m_NumItems].m_pData = mem_alloc(Size, 1);\n\tmem_copy(m_pItems[m_NumItems].m_pData, pData, Size);\n\n\tif(!m_pItemTypes[Type].m_Num) // count item types\n\t\tm_NumItemTypes++;\n\n\t// link\n\tm_pItems[m_NumItems].m_Prev = m_pItemTypes[Type].m_Last;\n\tm_pItems[m_NumItems].m_Next = -1;\n\n\tif(m_pItemTypes[Type].m_Last != -1)\n\t\tm_pItems[m_pItemTypes[Type].m_Last].m_Next = m_NumItems;\n\tm_pItemTypes[Type].m_Last = m_NumItems;\n\n\tif(m_pItemTypes[Type].m_First == -1)\n\t\tm_pItemTypes[Type].m_First = m_NumItems;\n\n\tm_pItemTypes[Type].m_Num++;\n\n\tm_NumItems++;\n\treturn m_NumItems-1;\n}\n\nint CDataFileWriter::AddData(int Size, void *pData)\n{\n\tif(!m_File) return 0;\n\n\tdbg_assert(m_NumDatas < 1024, \""too much data\"");\n""}, {""source"": ""value_info(file:datafile.cpp, value:m_ppDataPtrs)"", ""result"": {""value_trace"": [{""full_code"": ""pTmpDataFile->m_ppDataPtrs = (char**)(pTmpDataFile+1)"", ""line"": 145, ""func_name"": ""CDataFileReader.Open:bool(IStorage*,char*,int)""}, {""full_code"": ""m_pDataFile->m_ppDataPtrs[Index] = (char *)mem_alloc(UncompressedSize, 1)"", ""line"": 269, ""func_name"": ""CDataFileReader.GetDataImpl:void*(int,int)""}, {""full_code"": ""m_pDataFile->m_ppDataPtrs[Index] = (char *)mem_alloc(DataSize, 1)"", ""line"": 289, ""func_name"": ""CDataFileReader.GetDataImpl:void*(int,int)""}, {""full_code"": ""m_pDataFile->m_ppDataPtrs[Index] = pData"", ""line"": 319, ""func_name"": ""CDataFileReader.ReplaceData:void(int,char*)""}, {""full_code"": ""m_pDataFile->m_ppDataPtrs[Index] = 0x0"", ""line"": 329, ""func_name"": ""CDataFileReader.UnloadData:void(int)""}], ""struct_var"": ""m_ppDataPtrs"", ""struct_type"": null, ""struct_definition"": null}}]","Unbounded access to m_ppDataPtrs in CDataFileReader::UnloadData (src/engine/shared/datafile.cpp:323), CDataFileReader::ReplaceData (src/engine/shared/datafile.cpp:314), and CDataFileReader::GetDataImpl (src/engine/shared/datafile.cpp:249) prior to the patch. These functions allowed an out-of-bounds Index to access m_ppDataPtrs, leading to arbitrary free/write operations. The patch added bounds checks against m_pDataFile->m_Header.m_NumRawData in all three functions.",0.95,./github/other_context/CVE-2019-10878
13,CVE-2019-13445,CWE-190,c_cpp,An issue was discovered in the ROS communications-related packages (aka ros_comm or ros-melodic-ros-comm) through 1.14.3. parseOptions() in tools/rosbag/src/record.cpp has an integer overflow when a crafted split option can be entered on the command line.,https://github.com/ros/ros_comm/commit/8f572f8648d3bab99283aa72fcdbf6bd71c86fa4,rosbag/record: fix signed int overflow,1,"[{""func_name"": ""parseOptions"", ""file_path"": ""tools/rosbag/src/record.cpp"", ""func_code"": ""rosbag::RecorderOptions parseOptions(int argc, char** argv) {\n    rosbag::RecorderOptions opts;\n\n    po::options_description desc(\""Allowed options\"");\n\n    desc.add_options()\n      (\""help,h\"", \""produce help message\"")\n      (\""all,a\"", \""record all topics\"")\n      (\""regex,e\"", \""match topics using regular expressions\"")\n      (\""exclude,x\"", po::value<std::string>(), \""exclude topics matching regular expressions\"")\n      (\""quiet,q\"", \""suppress console output\"")\n      (\""publish,p\"", \""Publish a msg when the record begin\"")\n      (\""output-prefix,o\"", po::value<std::string>(), \""prepend PREFIX to beginning of bag name\"")\n      (\""output-name,O\"", po::value<std::string>(), \""record bagnamed NAME.bag\"")\n      (\""buffsize,b\"", po::value<int>()->default_value(256), \""Use an internal buffer of SIZE MB (Default: 256)\"")\n      (\""chunksize\"", po::value<int>()->default_value(768), \""Set chunk size of message data, in KB (Default: 768. Advanced)\"")\n      (\""limit,l\"", po::value<int>()->default_value(0), \""Only record NUM messages on each topic\"")\n      (\""min-space,L\"", po::value<std::string>()->default_value(\""1G\""), \""Minimum allowed space on recording device (use G,M,k multipliers)\"")\n      (\""bz2,j\"", \""use BZ2 compression\"")\n      (\""lz4\"", \""use LZ4 compression\"")\n      (\""split\"", po::value<int>()->implicit_value(0), \""Split the bag file and continue recording when maximum size or maximum duration reached.\"")\n      (\""max-splits\"", po::value<int>(), \""Keep a maximum of N bag files, when reaching the maximum erase the oldest one to keep a constant number of files.\"")\n      (\""topic\"", po::value< std::vector<std::string> >(), \""topic to record\"")\n      (\""size\"", po::value<uint64_t>(), \""The maximum size of the bag to record in MB.\"")\n      (\""duration\"", po::value<std::string>(), \""Record a bag of maximum duration in seconds, unless 'm', or 'h' is appended.\"")\n      (\""node\"", po::value<std::string>(), \""Record all topics subscribed to by a specific node.\"")\n      (\""tcpnodelay\"", \""Use the TCP_NODELAY transport hint when subscribing to topics.\"")\n      (\""udp\"", \""Use the UDP transport hint when subscribing to topics.\"");\n\n  \n    po::positional_options_description p;\n    p.add(\""topic\"", -1);\n    \n    po::variables_map vm;\n    \n    try \n    {\n      po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);\n    } catch (boost::program_options::invalid_command_line_syntax& e)\n    {\n      throw ros::Exception(e.what());\n    }  catch (boost::program_options::unknown_option& e)\n    {\n      throw ros::Exception(e.what());\n    }\n\n    if (vm.count(\""help\"")) {\n      std::cout << desc << std::endl;\n      exit(0);\n    }\n\n    if (vm.count(\""all\""))\n      opts.record_all = true;\n    if (vm.count(\""regex\""))\n      opts.regex = true;\n    if (vm.count(\""exclude\""))\n    {\n      opts.do_exclude = true;\n      opts.exclude_regex = vm[\""exclude\""].as<std::string>();\n    }\n    if (vm.count(\""quiet\""))\n      opts.quiet = true;\n    if (vm.count(\""publish\""))\n      opts.publish = true;\n    if (vm.count(\""output-prefix\""))\n    {\n      opts.prefix = vm[\""output-prefix\""].as<std::string>();\n      opts.append_date = true;\n    }\n    if (vm.count(\""output-name\""))\n    {\n      opts.prefix = vm[\""output-name\""].as<std::string>();\n      opts.append_date = false;\n    }\n    if (vm.count(\""split\""))\n    {\n      opts.split = true;\n\n      int S = vm[\""split\""].as<int>();\n      if (S != 0)\n      {\n        ROS_WARN(\""Use of \\\""--split <MAX_SIZE>\\\"" has been deprecated.  Please use --split --size <MAX_SIZE> or --split --duration <MAX_DURATION>\"");\n        if (S < 0)\n          throw ros::Exception(\""Split size must be 0 or positive\"");\n        opts.max_size = 1048576 * S;\n      }\n    }\n    if(vm.count(\""max-splits\""))\n    {\n        if(!opts.split)\n        {\n            ROS_WARN(\""--max-splits is ignored without --split\"");\n        }\n        else\n        {\n            opts.max_splits = vm[\""max-splits\""].as<int>();\n        }\n    }\n    if (vm.count(\""buffsize\""))\n    {\n      int m = vm[\""buffsize\""].as<int>();\n      if (m < 0)\n        throw ros::Exception(\""Buffer size must be 0 or positive\"");\n      opts.buffer_size = 1048576 * m;\n    }\n    if (vm.count(\""chunksize\""))\n    {\n      int chnk_sz = vm[\""chunksize\""].as<int>();\n      if (chnk_sz < 0)\n        throw ros::Exception(\""Chunk size must be 0 or positive\"");\n      opts.chunk_size = 1024 * chnk_sz;\n    }\n    if (vm.count(\""limit\""))\n    {\n      opts.limit = vm[\""limit\""].as<int>();\n    }\n    if (vm.count(\""min-space\""))\n    {\n        std::string ms = vm[\""min-space\""].as<std::string>();\n        long long int value = 1073741824ull;\n        char mul = 0;\n        // Sane default values, just in case\n        opts.min_space_str = \""1G\"";\n        opts.min_space = value;\n        if (sscanf(ms.c_str(), \"" %lld%c\"", &value, &mul) > 0) {\n            opts.min_space_str = ms;\n            switch (mul) {\n                case 'G':\n                case 'g':\n                    opts.min_space = value * 1073741824ull;\n                    break;\n                case 'M':\n                case 'm':\n                    opts.min_space = value * 1048576ull;\n                    break;\n                case 'K':\n                case 'k':\n                    opts.min_space = value * 1024ull;\n                    break;\n                default:\n                    opts.min_space = value;\n                    break;\n            }\n        }\n        ROS_DEBUG(\""Rosbag using minimum space of %lld bytes, or %s\"", opts.min_space, opts.min_space_str.c_str());\n    }\n    if (vm.count(\""bz2\"") && vm.count(\""lz4\""))\n    {\n      throw ros::Exception(\""Can only use one type of compression\"");\n    }\n    if (vm.count(\""bz2\""))\n    {\n      opts.compression = rosbag::compression::BZ2;\n    }\n    if (vm.count(\""lz4\""))\n    {\n      opts.compression = rosbag::compression::LZ4;\n    }\n    if (vm.count(\""duration\""))\n    {\n      std::string duration_str = vm[\""duration\""].as<std::string>();\n\n      double duration;\n      double multiplier = 1.0;\n      std::string unit(\""\"");\n\n      std::istringstream iss(duration_str);\n      if ((iss >> duration).fail())\n        throw ros::Exception(\""Duration must start with a floating point number.\"");\n\n      if ( (!iss.eof() && ((iss >> unit).fail())) )\n      {\n        throw ros::Exception(\""Duration unit must be s, m, or h\"");\n      }\n      if (unit == std::string(\""\""))\n        multiplier = 1.0;\n      else if (unit == std::string(\""s\""))\n        multiplier = 1.0;\n      else if (unit == std::string(\""m\""))\n        multiplier = 60.0;\n      else if (unit == std::string(\""h\""))\n        multiplier = 3600.0;\n      else\n        throw ros::Exception(\""Duration unit must be s, m, or h\"");\n\n      \n      opts.max_duration = ros::Duration(duration * multiplier);\n      if (opts.max_duration <= ros::Duration(0))\n        throw ros::Exception(\""Duration must be positive.\"");\n    }\n    if (vm.count(\""size\""))\n    {\n      opts.max_size = vm[\""size\""].as<uint64_t>() * 1048576;\n      if (opts.max_size <= 0)\n        throw ros::Exception(\""Split size must be 0 or positive\"");\n    }\n    if (vm.count(\""node\""))\n    {\n      opts.node = vm[\""node\""].as<std::string>();\n      std::cout << \""Recording from: \"" << opts.node << std::endl;\n    }\n    if (vm.count(\""tcpnodelay\""))\n    {\n      opts.transport_hints.tcpNoDelay();\n    }\n    if (vm.count(\""udp\""))\n    {\n      opts.transport_hints.udp();\n    }\n\n    // Every non-option argument is assumed to be a topic\n    if (vm.count(\""topic\""))\n    {\n      std::vector<std::string> bags = vm[\""topic\""].as< std::vector<std::string> >();\n      std::sort(bags.begin(), bags.end());\n      bags.erase(std::unique(bags.begin(), bags.end()), bags.end());\n      for (std::vector<std::string>::iterator i = bags.begin();\n           i != bags.end();\n           i++)\n        opts.topics.push_back(*i);\n    }\n\n\n    // check that argument combinations make sense\n    if(opts.exclude_regex.size() > 0 &&\n            !(opts.record_all || opts.regex)) {\n        fprintf(stderr, \""Warning: Exclusion regex given, but no topics to subscribe to.\\n\""\n                \""Adding implicit 'record all'.\"");\n        opts.record_all = true;\n    }\n\n    return opts;\n}"", ""target"": 0}]","[{""func_name"": ""parseOptions"", ""file_path"": ""tools/rosbag/src/record.cpp"", ""func_code"": ""rosbag::RecorderOptions parseOptions(int argc, char** argv) {\n    rosbag::RecorderOptions opts;\n\n    po::options_description desc(\""Allowed options\"");\n\n    desc.add_options()\n      (\""help,h\"", \""produce help message\"")\n      (\""all,a\"", \""record all topics\"")\n      (\""regex,e\"", \""match topics using regular expressions\"")\n      (\""exclude,x\"", po::value<std::string>(), \""exclude topics matching regular expressions\"")\n      (\""quiet,q\"", \""suppress console output\"")\n      (\""publish,p\"", \""Publish a msg when the record begin\"")\n      (\""output-prefix,o\"", po::value<std::string>(), \""prepend PREFIX to beginning of bag name\"")\n      (\""output-name,O\"", po::value<std::string>(), \""record bagnamed NAME.bag\"")\n      (\""buffsize,b\"", po::value<int>()->default_value(256), \""Use an internal buffer of SIZE MB (Default: 256)\"")\n      (\""chunksize\"", po::value<int>()->default_value(768), \""Set chunk size of message data, in KB (Default: 768. Advanced)\"")\n      (\""limit,l\"", po::value<int>()->default_value(0), \""Only record NUM messages on each topic\"")\n      (\""min-space,L\"", po::value<std::string>()->default_value(\""1G\""), \""Minimum allowed space on recording device (use G,M,k multipliers)\"")\n      (\""bz2,j\"", \""use BZ2 compression\"")\n      (\""lz4\"", \""use LZ4 compression\"")\n      (\""split\"", po::value<int>()->implicit_value(0), \""Split the bag file and continue recording when maximum size or maximum duration reached.\"")\n      (\""max-splits\"", po::value<int>(), \""Keep a maximum of N bag files, when reaching the maximum erase the oldest one to keep a constant number of files.\"")\n      (\""topic\"", po::value< std::vector<std::string> >(), \""topic to record\"")\n      (\""size\"", po::value<uint64_t>(), \""The maximum size of the bag to record in MB.\"")\n      (\""duration\"", po::value<std::string>(), \""Record a bag of maximum duration in seconds, unless 'm', or 'h' is appended.\"")\n      (\""node\"", po::value<std::string>(), \""Record all topics subscribed to by a specific node.\"")\n      (\""tcpnodelay\"", \""Use the TCP_NODELAY transport hint when subscribing to topics.\"")\n      (\""udp\"", \""Use the UDP transport hint when subscribing to topics.\"");\n\n  \n    po::positional_options_description p;\n    p.add(\""topic\"", -1);\n    \n    po::variables_map vm;\n    \n    try \n    {\n      po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);\n    } catch (boost::program_options::invalid_command_line_syntax& e)\n    {\n      throw ros::Exception(e.what());\n    }  catch (boost::program_options::unknown_option& e)\n    {\n      throw ros::Exception(e.what());\n    }\n\n    if (vm.count(\""help\"")) {\n      std::cout << desc << std::endl;\n      exit(0);\n    }\n\n    if (vm.count(\""all\""))\n      opts.record_all = true;\n    if (vm.count(\""regex\""))\n      opts.regex = true;\n    if (vm.count(\""exclude\""))\n    {\n      opts.do_exclude = true;\n      opts.exclude_regex = vm[\""exclude\""].as<std::string>();\n    }\n    if (vm.count(\""quiet\""))\n      opts.quiet = true;\n    if (vm.count(\""publish\""))\n      opts.publish = true;\n    if (vm.count(\""output-prefix\""))\n    {\n      opts.prefix = vm[\""output-prefix\""].as<std::string>();\n      opts.append_date = true;\n    }\n    if (vm.count(\""output-name\""))\n    {\n      opts.prefix = vm[\""output-name\""].as<std::string>();\n      opts.append_date = false;\n    }\n    if (vm.count(\""split\""))\n    {\n      opts.split = true;\n\n      int S = vm[\""split\""].as<int>();\n      if (S != 0)\n      {\n        ROS_WARN(\""Use of \\\""--split <MAX_SIZE>\\\"" has been deprecated.  Please use --split --size <MAX_SIZE> or --split --duration <MAX_DURATION>\"");\n        if (S < 0)\n          throw ros::Exception(\""Split size must be 0 or positive\"");\n        opts.max_size = 1048576 * static_cast<uint64_t>(S);\n      }\n    }\n    if(vm.count(\""max-splits\""))\n    {\n        if(!opts.split)\n        {\n            ROS_WARN(\""--max-splits is ignored without --split\"");\n        }\n        else\n        {\n            opts.max_splits = vm[\""max-splits\""].as<int>();\n        }\n    }\n    if (vm.count(\""buffsize\""))\n    {\n      int m = vm[\""buffsize\""].as<int>();\n      if (m < 0)\n        throw ros::Exception(\""Buffer size must be 0 or positive\"");\n      opts.buffer_size = 1048576 * m;\n    }\n    if (vm.count(\""chunksize\""))\n    {\n      int chnk_sz = vm[\""chunksize\""].as<int>();\n      if (chnk_sz < 0)\n        throw ros::Exception(\""Chunk size must be 0 or positive\"");\n      opts.chunk_size = 1024 * chnk_sz;\n    }\n    if (vm.count(\""limit\""))\n    {\n      opts.limit = vm[\""limit\""].as<int>();\n    }\n    if (vm.count(\""min-space\""))\n    {\n        std::string ms = vm[\""min-space\""].as<std::string>();\n        long long int value = 1073741824ull;\n        char mul = 0;\n        // Sane default values, just in case\n        opts.min_space_str = \""1G\"";\n        opts.min_space = value;\n        if (sscanf(ms.c_str(), \"" %lld%c\"", &value, &mul) > 0) {\n            opts.min_space_str = ms;\n            switch (mul) {\n                case 'G':\n                case 'g':\n                    opts.min_space = value * 1073741824ull;\n                    break;\n                case 'M':\n                case 'm':\n                    opts.min_space = value * 1048576ull;\n                    break;\n                case 'K':\n                case 'k':\n                    opts.min_space = value * 1024ull;\n                    break;\n                default:\n                    opts.min_space = value;\n                    break;\n            }\n        }\n        ROS_DEBUG(\""Rosbag using minimum space of %lld bytes, or %s\"", opts.min_space, opts.min_space_str.c_str());\n    }\n    if (vm.count(\""bz2\"") && vm.count(\""lz4\""))\n    {\n      throw ros::Exception(\""Can only use one type of compression\"");\n    }\n    if (vm.count(\""bz2\""))\n    {\n      opts.compression = rosbag::compression::BZ2;\n    }\n    if (vm.count(\""lz4\""))\n    {\n      opts.compression = rosbag::compression::LZ4;\n    }\n    if (vm.count(\""duration\""))\n    {\n      std::string duration_str = vm[\""duration\""].as<std::string>();\n\n      double duration;\n      double multiplier = 1.0;\n      std::string unit(\""\"");\n\n      std::istringstream iss(duration_str);\n      if ((iss >> duration).fail())\n        throw ros::Exception(\""Duration must start with a floating point number.\"");\n\n      if ( (!iss.eof() && ((iss >> unit).fail())) )\n      {\n        throw ros::Exception(\""Duration unit must be s, m, or h\"");\n      }\n      if (unit == std::string(\""\""))\n        multiplier = 1.0;\n      else if (unit == std::string(\""s\""))\n        multiplier = 1.0;\n      else if (unit == std::string(\""m\""))\n        multiplier = 60.0;\n      else if (unit == std::string(\""h\""))\n        multiplier = 3600.0;\n      else\n        throw ros::Exception(\""Duration unit must be s, m, or h\"");\n\n      \n      opts.max_duration = ros::Duration(duration * multiplier);\n      if (opts.max_duration <= ros::Duration(0))\n        throw ros::Exception(\""Duration must be positive.\"");\n    }\n    if (vm.count(\""size\""))\n    {\n      opts.max_size = vm[\""size\""].as<uint64_t>() * 1048576;\n      if (opts.max_size <= 0)\n        throw ros::Exception(\""Split size must be 0 or positive\"");\n    }\n    if (vm.count(\""node\""))\n    {\n      opts.node = vm[\""node\""].as<std::string>();\n      std::cout << \""Recording from: \"" << opts.node << std::endl;\n    }\n    if (vm.count(\""tcpnodelay\""))\n    {\n      opts.transport_hints.tcpNoDelay();\n    }\n    if (vm.count(\""udp\""))\n    {\n      opts.transport_hints.udp();\n    }\n\n    // Every non-option argument is assumed to be a topic\n    if (vm.count(\""topic\""))\n    {\n      std::vector<std::string> bags = vm[\""topic\""].as< std::vector<std::string> >();\n      std::sort(bags.begin(), bags.end());\n      bags.erase(std::unique(bags.begin(), bags.end()), bags.end());\n      for (std::vector<std::string>::iterator i = bags.begin();\n           i != bags.end();\n           i++)\n        opts.topics.push_back(*i);\n    }\n\n\n    // check that argument combinations make sense\n    if(opts.exclude_regex.size() > 0 &&\n            !(opts.record_all || opts.regex)) {\n        fprintf(stderr, \""Warning: Exclusion regex given, but no topics to subscribe to.\\n\""\n                \""Adding implicit 'record all'.\"");\n        opts.record_all = true;\n    }\n\n    return opts;\n}""}]","{""value"": 1}","[{""source"": ""value_info(file:record.cpp, value:S)"", ""result"": {""value_trace"": [{""full_code"": ""S = vm[\""split\""].as<int>()"", ""line"": 123, ""func_name"": ""parseOptions:rosbag.RecorderOptions(int,char**)""}], ""struct_var"": ""S"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}]","tools/rosbag/src/record.cpp:158: opts.max_size = 1048576 * S; uses a signed int (S) from tools/rosbag/src/record.cpp:123 (S = vm[""split""].as<int>()). Multiplying 1048576 (a large constant) by a user-controlled signed int (S) can exceed INT_MAX, causing overflow. The cast to uint64_t in the patch promotes the operation to 64-bit arithmetic, preventing overflow.",0.95,./github/other_context/CVE-2019-13445
14,CVE-2019-13115,"CWE-190, CWE-125",c_cpp,"In libssh2 before 1.9.0, kex_method_diffie_hellman_group_exchange_sha256_key_exchange in kex.c has an integer overflow that could lead to an out-of-bounds read in the way packets are read from the server. A remote attacker who compromises a SSH server may be able to disclose sensitive information or cause a denial of service condition on the client system when a user connects to the server. This is related to an _libssh2_check_length mistake, and is different from the various issues fixed in 1.8.1, such as CVE-2019-3855.",https://github.com/libssh2/libssh2/commit/b4289eeb84057d3d5e041af72af000a80b4f40d6,Updated _libssh2_check_length()\n\nUpdated suggested patch to protect against incorrect usage which could cause a wrap-around value to return success.,2,"[{""func_name"": ""_libssh2_check_length"", ""file_path"": ""src/misc.c"", ""func_code"": ""int _libssh2_check_length(struct string_buf *buf, size_t len)\n{\n    return (len <= (size_t)((buf->data + buf->len) - buf->dataptr));\n}"", ""target"": 0}, {""func_name"": ""_libssh2_check_length"", ""file_path"": ""src/misc.c"", ""func_code"": ""int _libssh2_check_length(struct string_buf *buf, size_t len)\n{\n    if(len > buf->len)\n        return 0;\n\n    return ((int)(buf->dataptr - buf->data) <= (int)(buf->len - len)) ? 1 : 0;\n}"", ""target"": 1}]","[{""func_name"": ""_libssh2_check_length"", ""file_path"": ""src/misc.c"", ""func_code"": ""int _libssh2_check_length(struct string_buf *buf, size_t len)\n{\n    unsigned char *endp = &buf->data[buf->len];\n    size_t left = endp - buf->dataptr;\n    return ((len <= left) && (left <= buf->len));\n}""}, {""func_name"": ""_libssh2_check_length"", ""file_path"": ""src/misc.c"", ""func_code"": ""int _libssh2_check_length(struct string_buf *buf, size_t len)\n{\n    return (len <= (size_t)((buf->data + buf->len) - buf->dataptr));\n}""}]","{""caller"": 10, ""function"": 4, ""code"": 1}","[{""source"": ""caller_info(file:kex.c, func:_libssh2_check_length)"", ""result"": [{""call_line"": 739, ""call_code"": ""_libssh2_check_length(buf, 4)"", ""caller_code"": ""int _libssh2_get_u32(struct string_buf *buf, uint32_t *out)\n{\n    if(!_libssh2_check_length(buf, 4)) {\n        return -1;\n    }\n\n    *out = _libssh2_ntohu32(buf->dataptr);\n    buf->dataptr += 4;\n    return 0;\n}"", ""caller_start"": 737, ""file_path"": ""src/misc.c""}, {""call_line"": 750, ""call_code"": ""_libssh2_check_length(buf, 8)"", ""caller_code"": ""int _libssh2_get_u64(struct string_buf *buf, libssh2_uint64_t *out)\n{\n    if(!_libssh2_check_length(buf, 8)) {\n        return -1;\n    }\n\n    *out = _libssh2_ntohu64(buf->dataptr);\n    buf->dataptr += 8;\n    return 0;\n}"", ""caller_start"": 748, ""file_path"": ""src/misc.c""}, {""call_line"": 775, ""call_code"": ""_libssh2_check_length(buf, data_len)"", ""caller_code"": ""int _libssh2_get_c_string(struct string_buf *buf, unsigned char **outbuf)\n{\n    uint32_t data_len;\n    if(_libssh2_get_u32(buf, &data_len) != 0) {\n        return -1;\n    }\n    if(!_libssh2_check_length(buf, data_len)) {\n        return -1;\n    }\n    *outbuf = buf->dataptr;\n    buf->dataptr += data_len;\n    return data_len;\n}"", ""caller_start"": 769, ""file_path"": ""src/misc.c""}, {""call_line"": 792, ""call_code"": ""_libssh2_check_length(buf, data_len)"", ""caller_code"": ""int _libssh2_get_bignum_bytes(struct string_buf *buf, unsigned char **outbuf)\n{\n    uint32_t data_len;\n    uint32_t bn_len;\n    unsigned char *bnptr;\n\n    if(_libssh2_get_u32(buf, &data_len) != 0) {\n        return -1;\n    }\n    if(!_libssh2_check_length(buf, data_len)) {\n        return -1;\n    }\n\n    bn_len = data_len;\n    bnptr = buf->dataptr;\n\n    /* trim leading zeros */\n    while(bn_len > 0 && *bnptr == 0x00) {\n        bn_len--;\n        bnptr++;\n    }\n\n    *outbuf = bnptr;\n\n    buf->dataptr += data_len;\n\n    return bn_len;\n}"", ""caller_start"": 783, ""file_path"": ""src/misc.c""}]}, {""source"": ""caller_info(file:kex.c, func:_libssh2_check_length)"", ""result"": [{""call_line"": 739, ""call_code"": ""_libssh2_check_length(buf, 4)"", ""caller_code"": ""int _libssh2_get_u32(struct string_buf *buf, uint32_t *out)\n{\n    if(!_libssh2_check_length(buf, 4)) {\n        return -1;\n    }\n\n    *out = _libssh2_ntohu32(buf->dataptr);\n    buf->dataptr += 4;\n    return 0;\n}"", ""caller_start"": 737, ""file_path"": ""src/misc.c""}, {""call_line"": 750, ""call_code"": ""_libssh2_check_length(buf, 8)"", ""caller_code"": ""int _libssh2_get_u64(struct string_buf *buf, libssh2_uint64_t *out)\n{\n    if(!_libssh2_check_length(buf, 8)) {\n        return -1;\n    }\n\n    *out = _libssh2_ntohu64(buf->dataptr);\n    buf->dataptr += 8;\n    return 0;\n}"", ""caller_start"": 748, ""file_path"": ""src/misc.c""}, {""call_line"": 775, ""call_code"": ""_libssh2_check_length(buf, data_len)"", ""caller_code"": ""int _libssh2_get_c_string(struct string_buf *buf, unsigned char **outbuf)\n{\n    uint32_t data_len;\n    if(_libssh2_get_u32(buf, &data_len) != 0) {\n        return -1;\n    }\n    if(!_libssh2_check_length(buf, data_len)) {\n        return -1;\n    }\n    *outbuf = buf->dataptr;\n    buf->dataptr += data_len;\n    return data_len;\n}"", ""caller_start"": 769, ""file_path"": ""src/misc.c""}, {""call_line"": 792, ""call_code"": ""_libssh2_check_length(buf, data_len)"", ""caller_code"": ""int _libssh2_get_bignum_bytes(struct string_buf *buf, unsigned char **outbuf)\n{\n    uint32_t data_len;\n    uint32_t bn_len;\n    unsigned char *bnptr;\n\n    if(_libssh2_get_u32(buf, &data_len) != 0) {\n        return -1;\n    }\n    if(!_libssh2_check_length(buf, data_len)) {\n        return -1;\n    }\n\n    bn_len = data_len;\n    bnptr = buf->dataptr;\n\n    /* trim leading zeros */\n    while(bn_len > 0 && *bnptr == 0x00) {\n        bn_len--;\n        bnptr++;\n    }\n\n    *outbuf = bnptr;\n\n    buf->dataptr += data_len;\n\n    return bn_len;\n}"", ""caller_start"": 783, ""file_path"": ""src/misc.c""}]}, {""source"": ""caller_info(file:kex.c, func:_libssh2_get_u32)"", ""result"": [{""call_line"": 772, ""call_code"": ""_libssh2_get_u32(buf, &data_len)"", ""caller_code"": ""int _libssh2_get_c_string(struct string_buf *buf, unsigned char **outbuf)\n{\n    uint32_t data_len;\n    if(_libssh2_get_u32(buf, &data_len) != 0) {\n        return -1;\n    }\n    if(!_libssh2_check_length(buf, data_len)) {\n        return -1;\n    }\n    *outbuf = buf->dataptr;\n    buf->dataptr += data_len;\n    return data_len;\n}"", ""caller_start"": 769, ""file_path"": ""src/misc.c""}, {""call_line"": 789, ""call_code"": ""_libssh2_get_u32(buf, &data_len)"", ""caller_code"": ""int _libssh2_get_bignum_bytes(struct string_buf *buf, unsigned char **outbuf)\n{\n    uint32_t data_len;\n    uint32_t bn_len;\n    unsigned char *bnptr;\n\n    if(_libssh2_get_u32(buf, &data_len) != 0) {\n        return -1;\n    }\n    if(!_libssh2_check_length(buf, data_len)) {\n        return -1;\n    }\n\n    bn_len = data_len;\n    bnptr = buf->dataptr;\n\n    /* trim leading zeros */\n    while(bn_len > 0 && *bnptr == 0x00) {\n        bn_len--;\n        bnptr++;\n    }\n\n    *outbuf = bnptr;\n\n    buf->dataptr += data_len;\n\n    return bn_len;\n}"", ""caller_start"": 783, ""file_path"": ""src/misc.c""}, {""call_line"": 458, ""call_code"": ""_libssh2_get_u32(&decoded, &nkeys)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}, {""call_line"": 525, ""call_code"": ""_libssh2_get_u32(&kdf_buf, &rounds)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}]}, {""source"": ""caller_info(file:kex.c, func:_libssh2_get_u64)"", ""result"": [{""call_line"": 689, ""call_code"": ""_libssh2_get_u64(&buf, &(attrs->filesize))"", ""caller_code"": ""static int\nsftp_bin2attr(LIBSSH2_SFTP_ATTRIBUTES *attrs, const unsigned char *p,\n              size_t data_len)\n{\n    struct string_buf buf;\n    uint32_t flags = 0;\n    buf.data = (unsigned char *)p;\n    buf.dataptr = buf.data;\n    buf.len = data_len;\n\n    if(_libssh2_get_u32(&buf, &flags) != 0) {\n        return LIBSSH2_ERROR_BUFFER_TOO_SMALL;\n    }\n    attrs->flags = flags;\n\n    if(attrs->flags & LIBSSH2_SFTP_ATTR_SIZE) {\n        if(_libssh2_get_u64(&buf, &(attrs->filesize)) != 0) {\n            return LIBSSH2_ERROR_BUFFER_TOO_SMALL;\n        }\n    }\n\n    if(attrs->flags & LIBSSH2_SFTP_ATTR_UIDGID) {\n        uint32_t uid = 0;\n        uint32_t gid = 0;\n        if(_libssh2_get_u32(&buf, &uid) != 0 ||\n           _libssh2_get_u32(&buf, &gid) != 0) {\n            return LIBSSH2_ERROR_BUFFER_TOO_SMALL;\n        }\n        attrs->uid = uid;\n        attrs->uid = gid;\n    }\n\n    if(attrs->flags & LIBSSH2_SFTP_ATTR_PERMISSIONS) {\n        uint32_t permissions;\n        if(_libssh2_get_u32(&buf, &pe..."", ""caller_start"": 673, ""file_path"": ""src/sftp.c""}]}, {""source"": ""caller_info(file:kex.c, func:_libssh2_get_c_string)"", ""result"": [{""call_line"": 762, ""call_code"": ""_libssh2_get_c_string(buf, &out)"", ""caller_code"": ""int _libssh2_match_string(struct string_buf *buf, const char *match)\n{\n    unsigned char *out;\n    if((size_t)_libssh2_get_c_string(buf, &out) != strlen(match) ||\n       strncmp((char *)out, match, strlen(match)) != 0) {\n        return -1;\n    }\n    return 0;\n}"", ""caller_start"": 759, ""file_path"": ""src/misc.c""}, {""call_line"": 413, ""call_code"": ""_libssh2_get_c_string(&decoded, &ciphername)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}, {""call_line"": 419, ""call_code"": ""_libssh2_get_c_string(&decoded, &kdfname)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}, {""call_line"": 425, ""call_code"": ""_libssh2_get_c_string(&decoded, &kdf)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}]}, {""source"": ""func_info(func:kex_method_diffie_hellman_group_exchange_sha256_key_exchange)"", ""result"": [{""code"": ""static int\nkex_method_diffie_hellman_group_exchange_sha256_key_exchange\n(LIBSSH2_SESSION * session, key_exchange_state_low_t * key_state)\n{\n    int ret = 0;\n    int rc;\n\n    if(key_state->state == libssh2_NB_state_idle) {\n        key_state->p = _libssh2_bn_init();\n        key_state->g = _libssh2_bn_init();\n        /* Ask for a P and G pair */\n#ifdef LIBSSH2_DH_GEX_NEW\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_MINGROUP);\n        _libssh2_htonu32(key_state->request + 5, LIBSSH2_DH_GEX_OPTGROUP);\n        _libssh2_htonu32(key_state->request + 9, LIBSSH2_DH_GEX_MAXGROUP);\n        key_state->request_len = 13;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \""Initiating Diffie-Hellman Group-Exchange \""\n                       \""(New Method SHA256)\"");\n#else\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST_OLD;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_OPTGR..."", ""start_line"": 1770, ""end_line"": 1889, ""full_name"": ""kex_method_diffie_hellman_group_exchange_sha256_key_exchange"", ""file_path"": ""src/kex.c""}]}, {""source"": ""caller_info(file:kex.c, func:_libssh2_get_u32)"", ""result"": [{""call_line"": 772, ""call_code"": ""_libssh2_get_u32(buf, &data_len)"", ""caller_code"": ""int _libssh2_get_c_string(struct string_buf *buf, unsigned char **outbuf)\n{\n    uint32_t data_len;\n    if(_libssh2_get_u32(buf, &data_len) != 0) {\n        return -1;\n    }\n    if(!_libssh2_check_length(buf, data_len)) {\n        return -1;\n    }\n    *outbuf = buf->dataptr;\n    buf->dataptr += data_len;\n    return data_len;\n}"", ""caller_start"": 769, ""file_path"": ""src/misc.c""}, {""call_line"": 789, ""call_code"": ""_libssh2_get_u32(buf, &data_len)"", ""caller_code"": ""int _libssh2_get_bignum_bytes(struct string_buf *buf, unsigned char **outbuf)\n{\n    uint32_t data_len;\n    uint32_t bn_len;\n    unsigned char *bnptr;\n\n    if(_libssh2_get_u32(buf, &data_len) != 0) {\n        return -1;\n    }\n    if(!_libssh2_check_length(buf, data_len)) {\n        return -1;\n    }\n\n    bn_len = data_len;\n    bnptr = buf->dataptr;\n\n    /* trim leading zeros */\n    while(bn_len > 0 && *bnptr == 0x00) {\n        bn_len--;\n        bnptr++;\n    }\n\n    *outbuf = bnptr;\n\n    buf->dataptr += data_len;\n\n    return bn_len;\n}"", ""caller_start"": 783, ""file_path"": ""src/misc.c""}, {""call_line"": 458, ""call_code"": ""_libssh2_get_u32(&decoded, &nkeys)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}, {""call_line"": 525, ""call_code"": ""_libssh2_get_u32(&kdf_buf, &rounds)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}]}, {""source"": ""caller_info(file:kex.c, func:_libssh2_get_u64)"", ""result"": [{""call_line"": 689, ""call_code"": ""_libssh2_get_u64(&buf, &(attrs->filesize))"", ""caller_code"": ""static int\nsftp_bin2attr(LIBSSH2_SFTP_ATTRIBUTES *attrs, const unsigned char *p,\n              size_t data_len)\n{\n    struct string_buf buf;\n    uint32_t flags = 0;\n    buf.data = (unsigned char *)p;\n    buf.dataptr = buf.data;\n    buf.len = data_len;\n\n    if(_libssh2_get_u32(&buf, &flags) != 0) {\n        return LIBSSH2_ERROR_BUFFER_TOO_SMALL;\n    }\n    attrs->flags = flags;\n\n    if(attrs->flags & LIBSSH2_SFTP_ATTR_SIZE) {\n        if(_libssh2_get_u64(&buf, &(attrs->filesize)) != 0) {\n            return LIBSSH2_ERROR_BUFFER_TOO_SMALL;\n        }\n    }\n\n    if(attrs->flags & LIBSSH2_SFTP_ATTR_UIDGID) {\n        uint32_t uid = 0;\n        uint32_t gid = 0;\n        if(_libssh2_get_u32(&buf, &uid) != 0 ||\n           _libssh2_get_u32(&buf, &gid) != 0) {\n            return LIBSSH2_ERROR_BUFFER_TOO_SMALL;\n        }\n        attrs->uid = uid;\n        attrs->uid = gid;\n    }\n\n    if(attrs->flags & LIBSSH2_SFTP_ATTR_PERMISSIONS) {\n        uint32_t permissions;\n        if(_libssh2_get_u32(&buf, &pe..."", ""caller_start"": 673, ""file_path"": ""src/sftp.c""}]}, {""source"": ""caller_info(file:kex.c, func:_libssh2_get_c_string)"", ""result"": [{""call_line"": 762, ""call_code"": ""_libssh2_get_c_string(buf, &out)"", ""caller_code"": ""int _libssh2_match_string(struct string_buf *buf, const char *match)\n{\n    unsigned char *out;\n    if((size_t)_libssh2_get_c_string(buf, &out) != strlen(match) ||\n       strncmp((char *)out, match, strlen(match)) != 0) {\n        return -1;\n    }\n    return 0;\n}"", ""caller_start"": 759, ""file_path"": ""src/misc.c""}, {""call_line"": 413, ""call_code"": ""_libssh2_get_c_string(&decoded, &ciphername)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}, {""call_line"": 419, ""call_code"": ""_libssh2_get_c_string(&decoded, &kdfname)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}, {""call_line"": 425, ""call_code"": ""_libssh2_get_c_string(&decoded, &kdf)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}]}, {""source"": ""func_info(file:kex.c, func:kex_method_diffie_hellman_group_exchange_sha256_key_exchange)"", ""result"": [{""code"": ""static int\nkex_method_diffie_hellman_group_exchange_sha256_key_exchange\n(LIBSSH2_SESSION * session, key_exchange_state_low_t * key_state)\n{\n    int ret = 0;\n    int rc;\n\n    if(key_state->state == libssh2_NB_state_idle) {\n        key_state->p = _libssh2_bn_init();\n        key_state->g = _libssh2_bn_init();\n        /* Ask for a P and G pair */\n#ifdef LIBSSH2_DH_GEX_NEW\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_MINGROUP);\n        _libssh2_htonu32(key_state->request + 5, LIBSSH2_DH_GEX_OPTGROUP);\n        _libssh2_htonu32(key_state->request + 9, LIBSSH2_DH_GEX_MAXGROUP);\n        key_state->request_len = 13;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \""Initiating Diffie-Hellman Group-Exchange \""\n                       \""(New Method SHA256)\"");\n#else\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST_OLD;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_OPTGR..."", ""start_line"": 1770, ""end_line"": 1889, ""full_name"": ""kex_method_diffie_hellman_group_exchange_sha256_key_exchange"", ""file_path"": ""src/kex.c""}]}, {""source"": ""func_info(file:kex.c, func:kex_method_diffie_hellman_group_exchange_sha256_key_exchange)"", ""result"": [{""code"": ""static int\nkex_method_diffie_hellman_group_exchange_sha256_key_exchange\n(LIBSSH2_SESSION * session, key_exchange_state_low_t * key_state)\n{\n    int ret = 0;\n    int rc;\n\n    if(key_state->state == libssh2_NB_state_idle) {\n        key_state->p = _libssh2_bn_init();\n        key_state->g = _libssh2_bn_init();\n        /* Ask for a P and G pair */\n#ifdef LIBSSH2_DH_GEX_NEW\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_MINGROUP);\n        _libssh2_htonu32(key_state->request + 5, LIBSSH2_DH_GEX_OPTGROUP);\n        _libssh2_htonu32(key_state->request + 9, LIBSSH2_DH_GEX_MAXGROUP);\n        key_state->request_len = 13;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \""Initiating Diffie-Hellman Group-Exchange \""\n                       \""(New Method SHA256)\"");\n#else\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST_OLD;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_OPTGR..."", ""start_line"": 1770, ""end_line"": 1889, ""full_name"": ""kex_method_diffie_hellman_group_exchange_sha256_key_exchange"", ""file_path"": ""src/kex.c""}]}, {""source"": ""code_info(file:kex.c, lines:100-120)"", ""result"": ""        while(len < (unsigned long)reqlen) {                            \\\n            libssh2_sha##digest_type##_init(&hash);                     \\\n            libssh2_sha##digest_type##_update(hash,                     \\\n                                              exchange_state->k_value,  \\\n                                              exchange_state->k_value_len); \\\n            libssh2_sha##digest_type##_update(hash,                     \\\n                                              exchange_state->h_sig_comp, \\\n                                         SHA##digest_type##_DIGEST_LENGTH); \\\n            if(len > 0) {                                               \\\n                libssh2_sha##digest_type##_update(hash, value, len);    \\\n            }                                                           \\\n            else {                                                      \\\n                libssh2_sha##digest_type##_update(hash, (version), 1);  \\\n                libssh2_sha##digest_type##_update(hash, session->session_id, \\\n                                                  session->session_id_len); \\\n            }                                                           \\\n            libssh2_sha##digest_type##_final(hash, (value) + len);      \\\n            len += SHA##digest_type##_DIGEST_LENGTH;                    \\\n        }                                                               \\\n}\n\n\n""}, {""source"": ""caller_info(file:kex.c, func:_libssh2_get_u32)"", ""result"": [{""call_line"": 772, ""call_code"": ""_libssh2_get_u32(buf, &data_len)"", ""caller_code"": ""int _libssh2_get_c_string(struct string_buf *buf, unsigned char **outbuf)\n{\n    uint32_t data_len;\n    if(_libssh2_get_u32(buf, &data_len) != 0) {\n        return -1;\n    }\n    if(!_libssh2_check_length(buf, data_len)) {\n        return -1;\n    }\n    *outbuf = buf->dataptr;\n    buf->dataptr += data_len;\n    return data_len;\n}"", ""caller_start"": 769, ""file_path"": ""src/misc.c""}, {""call_line"": 789, ""call_code"": ""_libssh2_get_u32(buf, &data_len)"", ""caller_code"": ""int _libssh2_get_bignum_bytes(struct string_buf *buf, unsigned char **outbuf)\n{\n    uint32_t data_len;\n    uint32_t bn_len;\n    unsigned char *bnptr;\n\n    if(_libssh2_get_u32(buf, &data_len) != 0) {\n        return -1;\n    }\n    if(!_libssh2_check_length(buf, data_len)) {\n        return -1;\n    }\n\n    bn_len = data_len;\n    bnptr = buf->dataptr;\n\n    /* trim leading zeros */\n    while(bn_len > 0 && *bnptr == 0x00) {\n        bn_len--;\n        bnptr++;\n    }\n\n    *outbuf = bnptr;\n\n    buf->dataptr += data_len;\n\n    return bn_len;\n}"", ""caller_start"": 783, ""file_path"": ""src/misc.c""}, {""call_line"": 458, ""call_code"": ""_libssh2_get_u32(&decoded, &nkeys)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}, {""call_line"": 525, ""call_code"": ""_libssh2_get_u32(&kdf_buf, &rounds)"", ""caller_code"": ""static int\n_libssh2_openssh_pem_parse_data(LIBSSH2_SESSION * session,\n                                const unsigned char *passphrase,\n                                const char *b64data, size_t b64datalen,\n                                struct string_buf **decrypted_buf)\n{\n    const LIBSSH2_CRYPT_METHOD *method = NULL;\n    struct string_buf decoded, decrypted, kdf_buf;\n    unsigned char *ciphername = NULL;\n    unsigned char *kdfname = NULL;\n    unsigned char *kdf = NULL;\n    unsigned char *buf = NULL;\n    unsigned char *salt = NULL;\n    uint32_t nkeys, check1, check2, salt_len;\n    uint32_t rounds = 0;\n    unsigned char *key = NULL;\n    unsigned char *key_part = NULL;\n    unsigned char *iv_part = NULL;\n    unsigned char *f = NULL;\n    unsigned int f_len = 0;\n    int ret = 0, rc = 0, kdf_len = 0, keylen = 0, ivlen = 0, total_len = 0;\n\n    if(decrypted_buf)\n        *decrypted_buf = NULL;\n\n    /* decode file */\n    if(libssh2_base64_decode(session, (char **)&f, &f_len,\n              ..."", ""caller_start"": 362, ""file_path"": ""src/pem.c""}]}, {""source"": ""func_info(file:kex.c, func:kex_method_diffie_hellman_group_exchange_sha256_key_exchange)"", ""result"": [{""code"": ""static int\nkex_method_diffie_hellman_group_exchange_sha256_key_exchange\n(LIBSSH2_SESSION * session, key_exchange_state_low_t * key_state)\n{\n    int ret = 0;\n    int rc;\n\n    if(key_state->state == libssh2_NB_state_idle) {\n        key_state->p = _libssh2_bn_init();\n        key_state->g = _libssh2_bn_init();\n        /* Ask for a P and G pair */\n#ifdef LIBSSH2_DH_GEX_NEW\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_MINGROUP);\n        _libssh2_htonu32(key_state->request + 5, LIBSSH2_DH_GEX_OPTGROUP);\n        _libssh2_htonu32(key_state->request + 9, LIBSSH2_DH_GEX_MAXGROUP);\n        key_state->request_len = 13;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \""Initiating Diffie-Hellman Group-Exchange \""\n                       \""(New Method SHA256)\"");\n#else\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST_OLD;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_OPTGR..."", ""start_line"": 1770, ""end_line"": 1889, ""full_name"": ""kex_method_diffie_hellman_group_exchange_sha256_key_exchange"", ""file_path"": ""src/kex.c""}]}, {""source"": ""caller_info(file:kex.c, func:_libssh2_get_bignum_bytes)"", ""result"": [{""call_line"": 1724, ""call_code"": ""_libssh2_get_bignum_bytes(&buf, &p)"", ""caller_code"": ""static int\nkex_method_diffie_hellman_group_exchange_sha1_key_exchange\n(LIBSSH2_SESSION * session, key_exchange_state_low_t * key_state)\n{\n    int ret = 0;\n    int rc;\n\n    if(key_state->state == libssh2_NB_state_idle) {\n        key_state->p = _libssh2_bn_init_from_bin();\n        key_state->g = _libssh2_bn_init_from_bin();\n        /* Ask for a P and G pair */\n#ifdef LIBSSH2_DH_GEX_NEW\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_MINGROUP);\n        _libssh2_htonu32(key_state->request + 5, LIBSSH2_DH_GEX_OPTGROUP);\n        _libssh2_htonu32(key_state->request + 9, LIBSSH2_DH_GEX_MAXGROUP);\n        key_state->request_len = 13;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \""Initiating Diffie-Hellman Group-Exchange \""\n                       \""(New Method)\"");\n#else\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST_OLD;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_..."", ""caller_start"": 1644, ""file_path"": ""src/kex.c""}, {""call_line"": 1731, ""call_code"": ""_libssh2_get_bignum_bytes(&buf, &g)"", ""caller_code"": ""static int\nkex_method_diffie_hellman_group_exchange_sha1_key_exchange\n(LIBSSH2_SESSION * session, key_exchange_state_low_t * key_state)\n{\n    int ret = 0;\n    int rc;\n\n    if(key_state->state == libssh2_NB_state_idle) {\n        key_state->p = _libssh2_bn_init_from_bin();\n        key_state->g = _libssh2_bn_init_from_bin();\n        /* Ask for a P and G pair */\n#ifdef LIBSSH2_DH_GEX_NEW\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_MINGROUP);\n        _libssh2_htonu32(key_state->request + 5, LIBSSH2_DH_GEX_OPTGROUP);\n        _libssh2_htonu32(key_state->request + 9, LIBSSH2_DH_GEX_MAXGROUP);\n        key_state->request_len = 13;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \""Initiating Diffie-Hellman Group-Exchange \""\n                       \""(New Method)\"");\n#else\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST_OLD;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_..."", ""caller_start"": 1644, ""file_path"": ""src/kex.c""}, {""call_line"": 1851, ""call_code"": ""_libssh2_get_bignum_bytes(&buf, &p)"", ""caller_code"": ""static int\nkex_method_diffie_hellman_group_exchange_sha256_key_exchange\n(LIBSSH2_SESSION * session, key_exchange_state_low_t * key_state)\n{\n    int ret = 0;\n    int rc;\n\n    if(key_state->state == libssh2_NB_state_idle) {\n        key_state->p = _libssh2_bn_init();\n        key_state->g = _libssh2_bn_init();\n        /* Ask for a P and G pair */\n#ifdef LIBSSH2_DH_GEX_NEW\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_MINGROUP);\n        _libssh2_htonu32(key_state->request + 5, LIBSSH2_DH_GEX_OPTGROUP);\n        _libssh2_htonu32(key_state->request + 9, LIBSSH2_DH_GEX_MAXGROUP);\n        key_state->request_len = 13;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \""Initiating Diffie-Hellman Group-Exchange \""\n                       \""(New Method SHA256)\"");\n#else\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST_OLD;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_OPTGR..."", ""caller_start"": 1770, ""file_path"": ""src/kex.c""}, {""call_line"": 1858, ""call_code"": ""_libssh2_get_bignum_bytes(&buf, &g)"", ""caller_code"": ""static int\nkex_method_diffie_hellman_group_exchange_sha256_key_exchange\n(LIBSSH2_SESSION * session, key_exchange_state_low_t * key_state)\n{\n    int ret = 0;\n    int rc;\n\n    if(key_state->state == libssh2_NB_state_idle) {\n        key_state->p = _libssh2_bn_init();\n        key_state->g = _libssh2_bn_init();\n        /* Ask for a P and G pair */\n#ifdef LIBSSH2_DH_GEX_NEW\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_MINGROUP);\n        _libssh2_htonu32(key_state->request + 5, LIBSSH2_DH_GEX_OPTGROUP);\n        _libssh2_htonu32(key_state->request + 9, LIBSSH2_DH_GEX_MAXGROUP);\n        key_state->request_len = 13;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \""Initiating Diffie-Hellman Group-Exchange \""\n                       \""(New Method SHA256)\"");\n#else\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST_OLD;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_OPTGR..."", ""caller_start"": 1770, ""file_path"": ""src/kex.c""}]}]","src/misc.c:813-815: Original code calculated `len <= (size_t)((buf->data + buf->len) - buf->dataptr)`, which could overflow if `buf->data + buf->len` wraps. Patch replaces this with `left = endp - buf->dataptr` (where `endp = &buf->data[buf->len]`) and checks `len <= left` and `left <= buf->len`. Vulnerable usage occurs in `kex_method_diffie_hellman_group_exchange_sha256_key_exchange` (src/kex.c:1851, 1858), which calls `_libssh2_get_bignum_bytes` to parse server-provided Diffie-Hellman parameters (P and G). `_libssh2_get_bignum_bytes` (src/misc.c:783-792) uses `_libssh2_check_length` to validate data lengths, making it susceptible to the overflow during key exchange.",0.95,./github/other_context/CVE-2019-13115
15,CVE-2019-14323,"CWE-787, CWE-193",c_cpp,"SSDP Responder 1.x through 1.5 mishandles incoming network messages, leading to a stack-based buffer overflow by 1 byte. This results in a crash of the server, but only when strict stack checking is enabled. This is caused by an off-by-one error in ssdp_recv in ssdpd.c.",https://github.com/troglobit/ssdp-responder/commit/ce04b1f29a137198182f60bbb628d5ceb8171765,Fix #1: Ensure recv buf is always NUL terminated\n\nSigned-off-by: Joachim Nilsson <troglobit@gmail.com>,1,"[{""func_name"": ""ssdp_recv"", ""file_path"": ""ssdpd.c"", ""func_code"": ""static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tbuf[len] = 0;\n\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \""M-SEARCH *\"")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \""No matching socket for client %s\"", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \""Matching socket for client %s\"", inet_ntoa(sin->sin_addr));\n\n\t\t\ttype = strcasestr(buf, \""\\r\\nST:\"");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \""No Search Type (ST:) found in M-SEARCH *, assuming \"" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\n\t\t\tptr = strstr(type, \""\\r\\n\"");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \""M-SEARCH * ST: %s from %s port %d\"", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogit(LOG_DEBUG, \""M-SEARCH * for unsupported ST: %s from %s\"", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""ssdp_recv"", ""file_path"": ""ssdpd.c"", ""func_code"": ""static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE + 1];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf) - 1, MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \""M-SEARCH *\"")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \""No matching socket for client %s\"", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \""Matching socket for client %s\"", inet_ntoa(sin->sin_addr));\n\n\t\t\ttype = strcasestr(buf, \""\\r\\nST:\"");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \""No Search Type (ST:) found in M-SEARCH *, assuming \"" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\n\t\t\tptr = strstr(type, \""\\r\\n\"");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \""M-SEARCH * ST: %s from %s port %d\"", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogit(LOG_DEBUG, \""M-SEARCH * for unsupported ST: %s from %s\"", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}""}]","{""function"": 2, ""code"": 2}","[{""source"": ""func_info(file:ssdpd.c, func:ssdp_recv)"", ""result"": [{""code"": ""static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tbuf[len] = 0;\n\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \""M-SEARCH *\"")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \""No matching socket for client %s\"", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \""Matching socket for client %s\"", inet_ntoa(sin->sin_addr));\n\n\t\t\ttype = strcasestr(buf, \""\\r\\nST:\"");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \""No Search Type (ST:) found in M-SEARCH *, assuming \"" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\n\t\t\tptr = strstr..."", ""start_line"": 430, ""end_line"": 491, ""full_name"": ""ssdp_recv"", ""file_path"": ""ssdpd.c""}]}, {""source"": ""code_info(file:ssdpd.c, lines:441-491)"", ""result"": ""\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \""M-SEARCH *\"")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \""No matching socket for client %s\"", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \""Matching socket for client %s\"", inet_ntoa(sin->sin_addr));\n\n\t\t\ttype = strcasestr(buf, \""\\r\\nST:\"");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \""No Search Type (ST:) found in M-SEARCH *, assuming \"" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\n\t\t\tptr = strstr(type, \""\\r\\n\"");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \""M-SEARCH * ST: %s from %s port %d\"", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogit(LOG_DEBUG, \""M-SEARCH * for unsupported ST: %s from %s\"", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}\n\n""}, {""source"": ""func_info(file:ssdpd.c, func:ssdp_recv)"", ""result"": [{""code"": ""static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tbuf[len] = 0;\n\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \""M-SEARCH *\"")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \""No matching socket for client %s\"", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \""Matching socket for client %s\"", inet_ntoa(sin->sin_addr));\n\n\t\t\ttype = strcasestr(buf, \""\\r\\nST:\"");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \""No Search Type (ST:) found in M-SEARCH *, assuming \"" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\n\t\t\tptr = strstr..."", ""start_line"": 430, ""end_line"": 491, ""full_name"": ""ssdp_recv"", ""file_path"": ""ssdpd.c""}]}, {""source"": ""code_info(file:ssdpd.c, lines:492-510)"", ""result"": ""\nstatic int multicast_init(void)\n{\n\tint sd;\n\tstruct sockaddr sa;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\tsd = socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);\n\tif (sd < 0) {\n\t\tlogit(LOG_ERR, \""Failed opening multicast socket: %s\"", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsin->sin_family = AF_INET;\n\tsin->sin_addr.s_addr = inet_addr(MC_SSDP_GROUP);\n\tsin->sin_port = htons(MC_SSDP_PORT);\n\n\tif (bind(sd, &sa, sizeof(*sin)) < 0) {\n\t\tclose(sd);\n""}]","ssdpd.c:433-441: Original code used `char buf[MAX_PKT_SIZE]`, called `recvfrom(sd, buf, sizeof(buf), ...)` (allowing up to `MAX_PKT_SIZE` bytes), and added `buf[len] = 0;` to NUL-terminate. This caused a 1-byte overflow when `len == MAX_PKT_SIZE`. The patch increases buffer to `MAX_PKT_SIZE + 1`, sets `recvfrom` limit to `sizeof(buf) - 1` (i.e., `MAX_PKT_SIZE`), and removes the `buf[len] = 0;` line. The buffer is NUL-terminated via `memset(buf, 0, sizeof(buf))` (line 435), ensuring the last byte remains zero even after `recvfrom` fills `MAX_PKT_SIZE` bytes. This eliminates the overflow while maintaining string safety for subsequent operations like `strstr(buf, ""M-SEARCH *"")`.",0.95,./github/other_context/CVE-2019-14323
16,CVE-2017-6308,CWE-190,c_cpp,"An issue was discovered in tnef before 1.4.13. Several Integer Overflows, which can lead to Heap Overflows, have been identified in the functions that wrap memory allocation.",https://github.com/verdammelt/tnef/commit/c5044689e50039635e7700fe2472fd632ac77176,Fix integer overflows and harden memory allocator.,6,"[{""func_name"": ""xmalloc"", ""file_path"": ""src/alloc.c"", ""func_code"": ""void*\nxmalloc (size_t size)\n{\n    void *ptr = malloc (size);\n    if (!ptr \n        && (size != 0))         /* some libc don't like size == 0 */\n    {\n        perror (\""xmalloc: Memory allocation failure\"");\n        abort();\n    }\n    return ptr;\n}"", ""target"": 0}, {""func_name"": ""alloc_limit_failure"", ""file_path"": ""src/alloc.c"", ""func_code"": ""static void\nalloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr, \n             \""%s: Maximum allocation size exceeded \""\n             \""(maxsize = %lu; size = %lu).\\n\"",\n             fn_name,\n             (unsigned long)alloc_limit, \n             (unsigned long)size);\n}"", ""target"": 0}, {""func_name"": ""checked_xcalloc"", ""file_path"": ""src/alloc.c"", ""func_code"": ""void*\nchecked_xcalloc (size_t num, size_t size)\n{\n    alloc_limit_assert (\""checked_xcalloc\"", (num *size));\n    return xcalloc (num, size);\n}"", ""target"": 0}, {""func_name"": ""xcalloc"", ""file_path"": ""src/alloc.c"", ""func_code"": ""void*\nxcalloc (size_t num, size_t size)\n{\n    void *ptr = malloc(num * size);\n    if (ptr)\n    {\n        memset (ptr, '\\0', (num * size));\n    }\n    return ptr;\n}"", ""target"": 0}, {""func_name"": ""checked_xmalloc"", ""file_path"": ""src/alloc.c"", ""func_code"": ""void*\nchecked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\""checked_xmalloc\"", size);\n    return xmalloc (size);\n}"", ""target"": 0}, {""func_name"": ""alloc_limit_assert"", ""file_path"": ""src/alloc.c"", ""func_code"": ""void\nalloc_limit_assert (char *fn_name, size_t size)\n{\n    if (alloc_limit && size > alloc_limit)\n    {\n\talloc_limit_failure (fn_name, size);\n\texit (-1);\n    }\n}"", ""target"": 0}]","[{""func_name"": ""xmalloc"", ""file_path"": ""src/alloc.c"", ""func_code"": ""void*\nxmalloc (size_t num, size_t size)\n{\n    size_t res;\n    if (check_mul_overflow(num, size, &res))\n        abort();\n\n    void *ptr = malloc (res);\n    if (!ptr\n        && (size != 0))         /* some libc don't like size == 0 */\n    {\n        perror (\""xmalloc: Memory allocation failure\"");\n        abort();\n    }\n    return ptr;\n}""}, {""func_name"": ""alloc_limit_failure"", ""file_path"": ""src/alloc.c"", ""func_code"": ""static void\nalloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr,\n             \""%s: Maximum allocation size exceeded \""\n             \""(maxsize = %lu; size = %lu).\\n\"",\n             fn_name,\n             (unsigned long)alloc_limit,\n             (unsigned long)size);\n}""}, {""func_name"": ""checked_xcalloc"", ""file_path"": ""src/alloc.c"", ""func_code"": ""void*\nchecked_xcalloc (size_t num, size_t size)\n{\n    size_t res;\n    if (check_mul_overflow(num, size, &res))\n        abort();\n\n    alloc_limit_assert (\""checked_xcalloc\"", (res));\n    return xcalloc (num, size);\n}""}, {""func_name"": ""xcalloc"", ""file_path"": ""src/alloc.c"", ""func_code"": ""void*\nxcalloc (size_t num, size_t size)\n{\n    size_t res;\n    if (check_mul_overflow(num, size, &res))\n        abort();\n\n    void *ptr;\n    ptr = malloc(res);\n    if (ptr)\n    {\n        memset (ptr, '\\0', (res));\n    }\n    return ptr;\n}""}, {""func_name"": ""checked_xmalloc"", ""file_path"": ""src/alloc.c"", ""func_code"": ""void*\nchecked_xmalloc (size_t num, size_t size)\n{\n    size_t res;\n    if (check_mul_overflow(num, size, &res))\n        abort();\n\n    alloc_limit_assert (\""checked_xmalloc\"", res);\n    return xmalloc (num, size);\n}""}, {""func_name"": ""alloc_limit_assert"", ""file_path"": ""src/alloc.c"", ""func_code"": ""void\nalloc_limit_assert (char *fn_name, size_t size)\n{\n    if (alloc_limit && size > alloc_limit)\n    {\n        alloc_limit_failure (fn_name, size);\n        exit (-1);\n    }\n}""}]","{""caller"": 5, ""function"": 1}","[{""source"": ""caller_info(file:alloc.c, func:xmalloc)"", ""result"": [{""call_line"": 83, ""call_code"": ""xmalloc (size)"", ""caller_code"": ""void*\nchecked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\""checked_xmalloc\"", size);\n    return xmalloc (size);\n}"", ""caller_start"": 79, ""file_path"": ""src/alloc.c""}, {""call_line"": 353, ""call_code"": ""xmalloc((1) * sizeof (VarLenData))"", ""caller_code"": ""VarLenData**\nget_rtf_data (MAPI_Attr *a)\n{\n    VarLenData** body \n\t= (VarLenData**)CHECKED_XCALLOC(VarLenData*, a->num_values + 1);\n\n    int j;\n    for (j = 0; j < a->num_values; j++)\n    {\n\tif (is_rtf_data (a->values[j].data.buf))\n\t{\n\t    body[j] = (VarLenData*)XMALLOC(VarLenData, 1);\n\n\t    get_rtf_data_from_buf (a->values[j].len,\n\t\t\t\t   a->values[j].data.buf,\n\t\t\t\t   &body[j]->len, &body[j]->data);\n\t}\n    }\n    return body;\n}"", ""caller_start"": 342, ""file_path"": ""src/rtf.c""}, {""call_line"": 168, ""call_code"": ""xmalloc((1) * sizeof (VarLenData))"", ""caller_code"": ""static VarLenData**\nget_html_data (MAPI_Attr *a)\n{\n    VarLenData **body = XCALLOC(VarLenData*, a->num_values + 1);\n\n    int j;\n    for (j = 0; j < a->num_values; j++)\n    {\n\tbody[j] = XMALLOC(VarLenData, 1);\n\tbody[j]->len = a->values[j].len;\n\tbody[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n\tmemmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n    }\n    return body;\n}"", ""caller_start"": 160, ""file_path"": ""src/tnef.c""}]}, {""source"": ""caller_info(file:alloc.c, func:xcalloc)"", ""result"": [{""call_line"": 103, ""call_code"": ""xcalloc (num, size)"", ""caller_code"": ""void*\nchecked_xcalloc (size_t num, size_t size)\n{\n    alloc_limit_assert (\""checked_xcalloc\"", (num *size));\n    return xcalloc (num, size);\n}"", ""caller_start"": 99, ""file_path"": ""src/alloc.c""}, {""call_line"": 133, ""call_code"": ""xcalloc((count + 1), sizeof (File *))"", ""caller_code"": ""static File**\nget_body_files (const char* filename,\n\t\tconst char pref,\n\t\tconst MessageBody* body)\n{\n    File **files = NULL;\n    VarLenData **data;\n    char *ext = \""\"";\n    char *type = \""unknown\"";\n    int i;\n\n    switch (pref)\n    {\n    case 'r':\n\tdata = body->rtf_bodies;\n\text = \"".rtf\"";\n            type = \""text/rtf\"";\n\tbreak;\n    case 'h':\n\tdata = body->html_bodies;\n\text = \"".html\"";\n            type = \""text/html\"";\n\tbreak;\n    case 't':\n\tdata = body->text_body;\n\text = \"".txt\"";\n            type = \""text/plain\"";\n\tbreak;\n    default:\n\tdata = NULL;\n\tbreak;\n    }\n\n    if (data)\n    {\n\tint count = 0;\n\tchar *tmp \n\t    = CHECKED_XCALLOC(char, \n\t\t\t      strlen(filename) + strlen(ext) + 1);\n\tstrcpy (tmp, filename);\n\tstrcat (tmp, ext);\n\n        char *mime = CHECKED_XCALLOC(char, strlen(type) + 1);\n        strcpy (mime, type);\n\n\t/* first get a count */\n\twhile (data[count++]);\n\n\tfiles = (File**)XCALLOC(File*, count + 1);\n\tfor (i = 0; data[i]; i++)\n\t{\n\t    files[i] = (File*)XCALLOC(File, 1);\n\t    files..."", ""caller_start"": 85, ""file_path"": ""src/tnef.c""}, {""call_line"": 136, ""call_code"": ""xcalloc((1), sizeof (File))"", ""caller_code"": ""static File**\nget_body_files (const char* filename,\n\t\tconst char pref,\n\t\tconst MessageBody* body)\n{\n    File **files = NULL;\n    VarLenData **data;\n    char *ext = \""\"";\n    char *type = \""unknown\"";\n    int i;\n\n    switch (pref)\n    {\n    case 'r':\n\tdata = body->rtf_bodies;\n\text = \"".rtf\"";\n            type = \""text/rtf\"";\n\tbreak;\n    case 'h':\n\tdata = body->html_bodies;\n\text = \"".html\"";\n            type = \""text/html\"";\n\tbreak;\n    case 't':\n\tdata = body->text_body;\n\text = \"".txt\"";\n            type = \""text/plain\"";\n\tbreak;\n    default:\n\tdata = NULL;\n\tbreak;\n    }\n\n    if (data)\n    {\n\tint count = 0;\n\tchar *tmp \n\t    = CHECKED_XCALLOC(char, \n\t\t\t      strlen(filename) + strlen(ext) + 1);\n\tstrcpy (tmp, filename);\n\tstrcat (tmp, ext);\n\n        char *mime = CHECKED_XCALLOC(char, strlen(type) + 1);\n        strcpy (mime, type);\n\n\t/* first get a count */\n\twhile (data[count++]);\n\n\tfiles = (File**)XCALLOC(File*, count + 1);\n\tfor (i = 0; data[i]; i++)\n\t{\n\t    files[i] = (File*)XCALLOC(File, 1);\n\t    files..."", ""caller_start"": 85, ""file_path"": ""src/tnef.c""}, {""call_line"": 151, ""call_code"": ""xcalloc((2), sizeof (VarLenData *))"", ""caller_code"": ""static VarLenData**\nget_text_data (Attr *attr)\n{\n    VarLenData **body = XCALLOC(VarLenData*, 2);\n\n    body[0] = XCALLOC(VarLenData, 1);\n    body[0]->len = attr->len;\n    body[0]->data = CHECKED_XCALLOC(unsigned char, attr->len);\n    memmove (body[0]->data, attr->buf, attr->len);\n    return body;\n}"", ""caller_start"": 148, ""file_path"": ""src/tnef.c""}]}, {""source"": ""caller_info(file:alloc.c, func:checked_xmalloc)"", ""result"": [{""call_line"": 158, ""call_code"": ""checked_xmalloc(((attr->len + 1)) * sizeof (char))"", ""caller_code"": ""void\nattr_dump (Attr* attr)\n{\n    char *name = get_tnef_name_str (attr->name);\n    char *type = get_tnef_type_str (attr->type);\n    size_t i;\n\n    fprintf (stdout, \""(%s) %s [type: %s] [len: %lu] =\"",\n\t     ((attr->lvl_type == LVL_MESSAGE) ? \""MESS\"" : \""ATTA\""),\n\t     name, type, (unsigned long)attr->len);\n\n    switch (attr->type)\n    {\n    case szBYTE:\n\tfor (i=0; i < attr->len; i++)\n\t{\n\t    fputc (' ', stdout);\n\t    write_byte(stdout, (uint8)attr->buf[i]);\n\t}\n\tbreak;\n\n    case szSHORT:\n\tif (attr->len < sizeof(uint16))\n\t{\n\t    fprintf (stdout, \""Not enough data for szSHORT\"");\n\t    abort();\n\t}\n\tfputc (' ', stdout);\n\twrite_uint16 (stdout, GETINT16(attr->buf));\n\tif (attr->len > sizeof(uint16))\n\t{\n\t    fprintf (stdout, \"" [extra data:\"");\n\t    for (i = sizeof(uint16); i < attr->len; i++)\n\t    {\n\t\tfputc (' ', stdout);\n\t\twrite_uint8 (stdout, (uint8)attr->buf[i]);\n\t    }\n\t    fprintf (stdout, \"" ]\"");\n\t}\n\tbreak;\n\n    case szLONG:\n\tif (attr->len < sizeof(uint32))\n\t{\n\t    fprintf (stdout, \""Not enough ..."", ""caller_start"": 68, ""file_path"": ""src/attr.c""}, {""call_line"": 183, ""call_code"": ""checked_xmalloc((file->len) * sizeof (unsigned char))"", ""caller_code"": ""static void\nfile_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\n\tif (a->num_values)\n\t{\n\n\t    switch (a->name)\n\t    {\n\t    case MAPI_ATTACH_LONG_FILENAME:\n\t\tif (file->name) XFREE(file->name);\n\t\tfile->name = strdup( (char*)a->values[0].data.buf );\n\t\tbreak;\n\n\t    case MAPI_ATTACH_DATA_OBJ:\n\t\tfile->len = a->values[0].len;\n\t\tif (file->data) XFREE (file->data);\n\t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n\t\tmemmove (file->data, a->values[0].data.buf, file->len);\n\t\tbreak;\n\n             case MAPI_ATTACH_MIME_TAG:\n\t\tif (file->mime_type) XFREE (file->mime_type);\n\t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n\t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n\t\tbreak;\n\n                case MAPI_ATTACH_CONTENT_ID:\n                    if (file->content_id) XFREE(file->content_id);\n                    file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n            ..."", ""caller_start"": 162, ""file_path"": ""src/file.c""}, {""call_line"": 189, ""call_code"": ""checked_xmalloc((a->values[0].len) * sizeof (char))"", ""caller_code"": ""static void\nfile_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\n\tif (a->num_values)\n\t{\n\n\t    switch (a->name)\n\t    {\n\t    case MAPI_ATTACH_LONG_FILENAME:\n\t\tif (file->name) XFREE(file->name);\n\t\tfile->name = strdup( (char*)a->values[0].data.buf );\n\t\tbreak;\n\n\t    case MAPI_ATTACH_DATA_OBJ:\n\t\tfile->len = a->values[0].len;\n\t\tif (file->data) XFREE (file->data);\n\t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n\t\tmemmove (file->data, a->values[0].data.buf, file->len);\n\t\tbreak;\n\n             case MAPI_ATTACH_MIME_TAG:\n\t\tif (file->mime_type) XFREE (file->mime_type);\n\t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n\t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n\t\tbreak;\n\n                case MAPI_ATTACH_CONTENT_ID:\n                    if (file->content_id) XFREE(file->content_id);\n                    file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n            ..."", ""caller_start"": 162, ""file_path"": ""src/file.c""}, {""call_line"": 195, ""call_code"": ""checked_xmalloc((a->values[0].len) * sizeof (char))"", ""caller_code"": ""static void\nfile_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\n\tif (a->num_values)\n\t{\n\n\t    switch (a->name)\n\t    {\n\t    case MAPI_ATTACH_LONG_FILENAME:\n\t\tif (file->name) XFREE(file->name);\n\t\tfile->name = strdup( (char*)a->values[0].data.buf );\n\t\tbreak;\n\n\t    case MAPI_ATTACH_DATA_OBJ:\n\t\tfile->len = a->values[0].len;\n\t\tif (file->data) XFREE (file->data);\n\t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n\t\tmemmove (file->data, a->values[0].data.buf, file->len);\n\t\tbreak;\n\n             case MAPI_ATTACH_MIME_TAG:\n\t\tif (file->mime_type) XFREE (file->mime_type);\n\t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n\t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n\t\tbreak;\n\n                case MAPI_ATTACH_CONTENT_ID:\n                    if (file->content_id) XFREE(file->content_id);\n                    file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n            ..."", ""caller_start"": 162, ""file_path"": ""src/file.c""}]}, {""source"": ""caller_info(file:alloc.c, func:checked_xcalloc)"", ""result"": [{""call_line"": 235, ""call_code"": ""checked_xcalloc((1), sizeof (Attr))"", ""caller_code"": ""Attr*\nattr_read (FILE* in)\n{\n    uint32 type_and_name;\n    uint16 checksum;\n\n    Attr *attr = CHECKED_XCALLOC (Attr, 1);\n    \n    attr->lvl_type = geti8(in);\n    \n    assert ((attr->lvl_type == LVL_MESSAGE)\n\t    || (attr->lvl_type == LVL_ATTACHMENT));\n    \n    type_and_name = geti32(in);\n    \n    attr->type = (type_and_name >> 16);\n    attr->name = ((type_and_name << 16) >> 16);\n    attr->len = geti32(in);\n    attr->buf = CHECKED_XCALLOC (unsigned char, attr->len);\n    \n    (void)getbuf(in, attr->buf, attr->len);\n    \n    checksum = geti16(in);\n    if (!check_checksum(attr, checksum))\n    {\n\tif ( CHECKSUM_SKIP )\n\t{\n\t    fprintf (stderr,\n\t\t \""WARNING: invalid checksum, input file may be corrupted\\n\"");\n\t}\n\telse\n\t{\n\t    fprintf (stderr,\n\t\t \""ERROR: invalid checksum, input file may be corrupted\\n\"");\n\t    exit( 1 );\n\t}\n    }\n    \n    if (DEBUG_ON) attr_dump (attr);\n\n    return attr;\n}"", ""caller_start"": 229, ""file_path"": ""src/attr.c""}, {""call_line"": 247, ""call_code"": ""checked_xcalloc((attr->len), sizeof (unsigned char))"", ""caller_code"": ""Attr*\nattr_read (FILE* in)\n{\n    uint32 type_and_name;\n    uint16 checksum;\n\n    Attr *attr = CHECKED_XCALLOC (Attr, 1);\n    \n    attr->lvl_type = geti8(in);\n    \n    assert ((attr->lvl_type == LVL_MESSAGE)\n\t    || (attr->lvl_type == LVL_ATTACHMENT));\n    \n    type_and_name = geti32(in);\n    \n    attr->type = (type_and_name >> 16);\n    attr->name = ((type_and_name << 16) >> 16);\n    attr->len = geti32(in);\n    attr->buf = CHECKED_XCALLOC (unsigned char, attr->len);\n    \n    (void)getbuf(in, attr->buf, attr->len);\n    \n    checksum = geti16(in);\n    if (!check_checksum(attr, checksum))\n    {\n\tif ( CHECKSUM_SKIP )\n\t{\n\t    fprintf (stderr,\n\t\t \""WARNING: invalid checksum, input file may be corrupted\\n\"");\n\t}\n\telse\n\t{\n\t    fprintf (stderr,\n\t\t \""ERROR: invalid checksum, input file may be corrupted\\n\"");\n\t    exit( 1 );\n\t}\n    }\n    \n    if (DEBUG_ON) attr_dump (attr);\n\n    return attr;\n}"", ""caller_start"": 229, ""file_path"": ""src/attr.c""}, {""call_line"": 155, ""call_code"": ""checked_xcalloc((a->num_values), sizeof (MAPI_Value))"", ""caller_code"": ""static MAPI_Value*\nalloc_mapi_values (MAPI_Attr* a)\n{\n    if (a && a->num_values)\n    {\n\ta->values = CHECKED_XCALLOC (MAPI_Value, a->num_values);\n\treturn a->values;\n    }\n    return NULL;\n}"", ""caller_start"": 150, ""file_path"": ""src/mapi_attr.c""}, {""call_line"": 183, ""call_code"": ""checked_xcalloc((1), sizeof (MAPI_Attr))"", ""caller_code"": ""MAPI_Attr**\nmapi_attr_read (size_t len, unsigned char *buf)\n{\n    size_t idx = 0;\n    uint32 i,j;\n    uint32 num_properties = GETINT32(buf+idx);\n    MAPI_Attr** attrs = CHECKED_XMALLOC (MAPI_Attr*, (num_properties + 1));\n\n    idx += 4;\n\n    if (!attrs) return NULL;\n    for (i = 0; i < num_properties; i++)\n    {\n\tMAPI_Attr* a = attrs[i] = CHECKED_XCALLOC(MAPI_Attr, 1);\n\tMAPI_Value* v = NULL;\n\n\ta->type = GETINT16(buf+idx); idx += 2;\n\ta->name = GETINT16(buf+idx); idx += 2;\n\n\t/* handle special case of GUID prefixed properties */\n\tif (a->name & GUID_EXISTS_FLAG)\n\t{\n\t    /* copy GUID */\n\t    a->guid = CHECKED_XMALLOC(GUID, 1);\n\t    copy_guid_from_buf(a->guid, buf+idx);\n\t    idx += sizeof (GUID);\n\n\t    a->num_names = GETINT32(buf+idx); idx += 4;\n\t    if (a->num_names > 0)\n\t    {\n\t\t/* FIXME: do something useful here! */\n\t\tsize_t i;\n\n\t\ta->names = CHECKED_XCALLOC(VarLenData, a->num_names);\n\n\t\tfor (i = 0; i < a->num_names; i++)\n\t\t{\n\t\t    size_t j;\n\n\t\t    a->names[i].len = GETINT32(buf+idx); id..."", ""caller_start"": 170, ""file_path"": ""src/mapi_attr.c""}]}, {""source"": ""func_info(func:geti32)"", ""result"": [{""code"": ""uint32\ngeti32 (FILE *fp)\n{\n    unsigned char buf[4];\n    return (uint32)GETINT32(getbuf(fp, buf, 4));\n}"", ""start_line"": 61, ""end_line"": 66, ""full_name"": ""geti32"", ""file_path"": ""src/util.c""}]}, {""source"": ""caller_info(file:mapi_attr.c, func:mapi_attr_read)"", ""result"": [{""call_line"": 221, ""call_code"": ""mapi_attr_read (attr->len, attr->buf)"", ""caller_code"": ""void\nfile_add_attr (File* file, Attr* attr)\n{\n    assert (file && attr);\n    if (!(file && attr)) return;\n\n    /* we only care about some things... we will skip most attributes */\n    switch (attr->name)\n    {\n    case attATTACHMODIFYDATE:\n\tcopy_date_from_attr (attr, &file->dt);\n\tbreak;\n\n    case attATTACHMENT:\n    {\n\tMAPI_Attr **mapi_attrs = mapi_attr_read (attr->len, attr->buf);\n\tif (mapi_attrs)\n\t{\n\t    file_add_mapi_attrs (file, mapi_attrs);\n\t    mapi_attr_free_list (mapi_attrs);\n\t    XFREE (mapi_attrs);\n\t}\n    }\n    break;\n\n    case attATTACHTITLE:\n\tfile->name = strdup( (char*)attr->buf );\n\tbreak;\n\n    case attATTACHDATA:\n\tfile->len = attr->len;\n\tfile->data = CHECKED_XMALLOC(unsigned char, attr->len);\n\tmemmove (file->data, attr->buf, attr->len);\n\tbreak;\n\n    default:\n\tbreak;\n    }\n}"", ""caller_start"": 206, ""file_path"": ""src/file.c""}, {""call_line"": 302, ""call_code"": ""mapi_attr_read (attr->len, attr->buf)"", ""caller_code"": ""int\nparse_file (FILE* input_file, char* directory, \n\t    char *body_filename, char *body_pref,\n\t    int flags)\n{\n    uint32 d;\n    uint16 key;\n    Attr *attr = NULL;\n    File *file = NULL;\n    int rtf_size = 0, html_size = 0;\n    MessageBody body;\n    memset (&body, '\\0', sizeof (MessageBody));\n\n    /* store the program options in our file global variables */\n    g_flags = flags;\n\n    /* check that this is in fact a TNEF file */\n    d = geti32(input_file);\n    if (d != TNEF_SIGNATURE)\n    {\n\tfprintf (stdout, \""Seems not to be a TNEF file\\n\"");\n\treturn 1;\n    }\n\n    /* Get the key */\n    key = geti16(input_file);\n    debug_print (\""TNEF Key: %hx\\n\"", key);\n\n    /* The rest of the file is a series of 'messages' and 'attachments' */\n    while ( data_left( input_file ) )\n    {\n\tattr = read_object( input_file );\n\n\tif ( attr == NULL ) break;\n\n\t/* This signals the beginning of a file */\n\tif (attr->name == attATTACHRENDDATA)\n\t{\n\t    if (file)\n\t    {\n\t\tfile_write (file, directory);\n\t\tfile_free (..."", ""caller_start"": 242, ""file_path"": ""src/tnef.c""}]}]","Integer overflow in `num * size` calculations during memory allocation (src/alloc.c:66, 88, 100, 80). Parameters `num`/`size` are sourced from user-controlled MAPI attributes (e.g., `attr->len` in src/attr.c:158, `a->num_values` in src/mapi_attr.c:155). These values are populated via `geti32` (src/util.c:61-66), which reads directly from input files. Lack of overflow checks allows attackers to trigger undersized allocations, leading to heap overflows when writing to these buffers.",0.95,./github/other_context/CVE-2017-6308
17,CVE-2018-10887,"CWE-681, CWE-190, CWE-125",c_cpp,"A flaw was found in libgit2 before version 0.27.3. It has been discovered that an unexpected sign extension in git_delta_apply function in delta.c file may lead to an integer overflow which in turn leads to an out of bound read, allowing to read before the base object. An attacker may use this flaw to leak memory addresses or cause a Denial of Service.",https://github.com/libgit2/libgit2/commit/3f461902dc1072acb8b7607ee65d0a0458ffac2a,"delta: fix sign-extension of big left-shift\n\nOur delta code was originally adapted from JGit, which itself adapted it\nfrom git itself. Due to this heritage, we inherited a bug from git.git\nin how we compute the delta offset, which was fixed upstream in\n48fb7deb5 (Fix big left-shifts of unsigned char, 2009-06-17). As\nexplained by Linus:\n\n    Shifting 'unsigned char' or 'unsigned short' left can result in sign\n    extension errors, since the C integer promotion rules means that the\n    unsigned char/short will get implicitly promoted to a signed 'int' due to\n    the shift (or due to other operations).\n\n    This normally doesn't matter, but if you shift things up sufficiently, it\n    will now set the sign bit in 'int', and a subsequent cast to a bigger type\n    (eg 'long' or 'unsigned long') will now sign-extend the value despite the\n    original expression being unsigned.\n\n    One example of this would be something like\n\n            unsigned long size;\n            unsigned char c;\n\n            size += c << 24;\n\n    where despite all the variables being unsigned, 'c << 24' ends up being a\n    signed entity, and will get sign-extended when then doing the addition in\n    an 'unsigned long' type.\n\n    Since git uses 'unsigned char' pointers extensively, we actually have this\n    bug in a couple of places.\n\nIn our delta code, we inherited such a bogus shift when computing the\noffset at which the delta base is to be found. Due to the sign extension\nwe can end up with an offset where all the bits are set. This can allow\nan arbitrary memory read, as the addition in `base_len < off + len` can\nnow overflow if `off` has all its bits set.\n\nFix the issue by casting the result of `*delta++ << 24UL` to an unsigned\ninteger again. Add a test with a crafted delta that would actually\nsucceed with an out-of-bounds read in case where the cast wouldn't\nexist.\n\nReported-by: Riccardo Schirone <rschiron@redhat.com>\nTest-provided-by: Riccardo Schirone <rschiron@redhat.com>",2,"[{""func_name"": ""git_delta_apply"", ""file_path"": ""src/delta.c"", ""func_code"": ""int git_delta_apply(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\t/* Check that the base size matches the data we were given;\n\t* if not we would underflow while accessing data from the\n\t* base object, resulting in data corruption or segfault.\n\t*/\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \""failed to apply delta: base size does not match given data\"");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \""failed to apply delta: base size does not match given data\"");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\t*out = res_dp;\n\t*out_len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n\t\t\t/* cmd is a copy instruction; copy from the base.\n\t\t\t*/\n\t\t\tsize_t off = 0, len = 0;\n\n\t\t\tif (cmd & 0x01) off = *delta++;\n\t\t\tif (cmd & 0x02) off |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x04) off |= *delta++ << 16UL;\n\t\t\tif (cmd & 0x08) off |= *delta++ << 24UL;\n\n\t\t\tif (cmd & 0x10) len = *delta++;\n\t\t\tif (cmd & 0x20) len |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x40) len |= *delta++ << 16UL;\n\t\t\tif (!len)\t\tlen = 0x10000;\n\n\t\t\tif (base_len < off + len || res_sz < len)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t}\n\t\telse if (cmd) {\n\t\t\t/* cmd is a literal insert instruction; copy from\n\t\t\t* the delta stream itself.\n\t\t\t*/\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t}\n\t\telse {\n\t\t\t/* cmd == 0 is reserved for future encodings.\n\t\t\t*/\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(*out);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tgiterr_set(GITERR_INVALID, \""failed to apply delta\"");\n\treturn -1;\n}"", ""target"": 0}, {""func_name"": ""git_delta_apply"", ""file_path"": ""src/delta.c"", ""func_code"": ""int git_delta_apply(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\t/*\n\t * Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \""failed to apply delta: base size does not match given data\"");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \""failed to apply delta: base size does not match given data\"");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\t*out = res_dp;\n\t*out_len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n\t\t\t/* cmd is a copy instruction; copy from the base. */\n\t\t\tsize_t off = 0, len = 0;\n\n#define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }\n\t\t\tif (cmd & 0x01) ADD_DELTA(off, 0UL);\n\t\t\tif (cmd & 0x02) ADD_DELTA(off, 8UL);\n\t\t\tif (cmd & 0x04) ADD_DELTA(off, 16UL);\n\t\t\tif (cmd & 0x08) ADD_DELTA(off, 24UL);\n\n\t\t\tif (cmd & 0x10) ADD_DELTA(len, 0UL);\n\t\t\tif (cmd & 0x20) ADD_DELTA(len, 8UL);\n\t\t\tif (cmd & 0x40) ADD_DELTA(len, 16UL);\n\t\t\tif (!len)       len = 0x10000;\n#undef ADD_DELTA\n\n\t\t\tif (base_len < off + len || res_sz < len)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/*\n\t\t\t * cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings. */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(*out);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tgiterr_set(GITERR_INVALID, \""failed to apply delta\"");\n\treturn -1;\n}"", ""target"": 0}]","[{""func_name"": ""git_delta_apply"", ""file_path"": ""src/delta.c"", ""func_code"": ""int git_delta_apply(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\t/*\n\t * Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \""failed to apply delta: base size does not match given data\"");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \""failed to apply delta: base size does not match given data\"");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\t*out = res_dp;\n\t*out_len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n\t\t\t/* cmd is a copy instruction; copy from the base. */\n\t\t\tsize_t off = 0, len = 0;\n\n\t\t\tif (cmd & 0x01) off = *delta++;\n\t\t\tif (cmd & 0x02) off |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x04) off |= *delta++ << 16UL;\n\t\t\tif (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);\n\n\t\t\tif (cmd & 0x10) len = *delta++;\n\t\t\tif (cmd & 0x20) len |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x40) len |= *delta++ << 16UL;\n\t\t\tif (!len)       len = 0x10000;\n\n\t\t\tif (base_len < off + len || res_sz < len)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/*\n\t\t\t * cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings. */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(*out);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tgiterr_set(GITERR_INVALID, \""failed to apply delta\"");\n\treturn -1;\n}""}, {""func_name"": ""git_delta_apply"", ""file_path"": ""src/delta.c"", ""func_code"": ""int git_delta_apply(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\t/*\n\t * Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \""failed to apply delta: base size does not match given data\"");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \""failed to apply delta: base size does not match given data\"");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\t*out = res_dp;\n\t*out_len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n\t\t\t/* cmd is a copy instruction; copy from the base. */\n\t\t\tsize_t off = 0, len = 0, end;\n\n#define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }\n\t\t\tif (cmd & 0x01) ADD_DELTA(off, 0UL);\n\t\t\tif (cmd & 0x02) ADD_DELTA(off, 8UL);\n\t\t\tif (cmd & 0x04) ADD_DELTA(off, 16UL);\n\t\t\tif (cmd & 0x08) ADD_DELTA(off, 24UL);\n\n\t\t\tif (cmd & 0x10) ADD_DELTA(len, 0UL);\n\t\t\tif (cmd & 0x20) ADD_DELTA(len, 8UL);\n\t\t\tif (cmd & 0x40) ADD_DELTA(len, 16UL);\n\t\t\tif (!len)       len = 0x10000;\n#undef ADD_DELTA\n\n\t\t\tif (GIT_ADD_SIZET_OVERFLOW(&end, off, len) ||\n\t\t\t    base_len < end || res_sz < len)\n\t\t\t\tgoto fail;\n\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/*\n\t\t\t * cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings. */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(*out);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tgiterr_set(GITERR_INVALID, \""failed to apply delta\"");\n\treturn -1;\n}""}]","{""value"": 1, ""function"": 1}","[{""source"": ""value_info(file:delta.c, value:delta)"", ""result"": {""value_trace"": [{""full_code"": ""delta = buffer"", ""line"": 518, ""func_name"": ""git_delta_read_header_fromstream""}, {""full_code"": ""delta++"", ""line"": 565, ""func_name"": ""git_delta_apply""}, {""full_code"": ""delta++"", ""line"": 571, ""func_name"": ""git_delta_apply""}], ""struct_var"": ""delta"", ""struct_type"": ""unsigned char*"", ""struct_definition"": ""unsigned char""}}, {""source"": ""func_info(file:delta.c, func:git_delta_apply)"", ""result"": [{""code"": ""int git_delta_apply(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\t/* Check that the base size matches the data we were given;\n\t* if not we would underflow while accessing data from the\n\t* base object, resulting in data corruption or segfault.\n\t*/\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \""failed to apply delta: base size does not match given data\"");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \""failed to apply delta: base size does not match given data\"");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\t*out = res_dp;\n\t*out_len = res_sz;\n\n\twhile (delta..."", ""start_line"": 527, ""end_line"": 619, ""full_name"": ""git_delta_apply"", ""file_path"": ""src/delta.c""}]}]","src/delta.c:566: Left shift of *delta (unsigned char) by 24 bits promoted to signed int (due to C integer promotion rules), leading to sign extension when cast to size_t. This creates an invalid 'off' value. src/delta.c:582: Unchecked 'off + len' could overflow, allowing out-of-bounds read from 'base' (const unsigned char*). The fix adds explicit cast to 'unsigned' before shifting and uses overflow-checked arithmetic.",0.95,./github/other_context/CVE-2018-10887
18,CVE-2018-14679,"CWE-193, CWE-20",c_cpp,"An issue was discovered in mspack/chmd.c in libmspack before 0.7alpha. There is an off-by-one error in the CHM PMGI/PMGL chunk number validity checks, which could lead to denial of service (uninitialized data dereference and application crash).",https://github.com/kyz/libmspack/commit/72e70a921f0f07fee748aec2274b30784e1d312a,Fix off-by-one bounds check on CHM PMGI/PMGL chunk numbers and\nreject empty filenames. Thanks to Hanno Bck for reporting,2,"[{""func_name"": ""read_chunk"", ""file_path"": ""libmspack/mspack/chmd.c"", ""func_code"": ""static unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *buf;\n\n    /* check arguments - most are already checked by chmd_fast_find */\n    if (chunk_num > chm->num_chunks) return NULL;\n    \n    /* ensure chunk cache is available */\n    if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    /* try to answer out of chunk cache */\n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    /* need to read chunk - allocate memory for it */\n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    /* seek to block and read it */\n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* check the signature. Is is PMGL or PMGI? */\n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* all OK. Store chunk in cache and return it */\n    return chm->chunk_cache[chunk_num] = buf;\n}"", ""target"": 0}, {""func_name"": ""chmd_read_headers"", ""file_path"": ""libmspack/mspack/chmd.c"", ""func_code"": ""static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\""incorrect GUIDs\""))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \""WARNING; CHM version > 3\"");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\""content section begins after file has ended\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\""chunk size not large enough\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\""no chunks\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\""more than 100,000 chunks\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\""chunks larger than entire file\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \""WARNING; chunk size is not a power of two\"");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \""WARNING; first PMGL chunk is not zero\"");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\""first pmgl chunk is after last pmgl chunk\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root > chm->num_chunks) {\n    D((\""index_root outside valid range\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \""WARNING; PMGL quickref area is too small\"");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \""WARNING; PMGL quickref area is too large\"");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      name = p; p += name_len;\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \""/\"" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \""invalid section number '%u'.\"", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\""chunk ended before all entries could be read\""))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}"", ""target"": 0}]","[{""func_name"": ""read_chunk"", ""file_path"": ""libmspack/mspack/chmd.c"", ""func_code"": ""static unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *buf;\n\n    /* check arguments - most are already checked by chmd_fast_find */\n    if (chunk_num >= chm->num_chunks) return NULL;\n    \n    /* ensure chunk cache is available */\n    if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    /* try to answer out of chunk cache */\n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    /* need to read chunk - allocate memory for it */\n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    /* seek to block and read it */\n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* check the signature. Is is PMGL or PMGI? */\n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* all OK. Store chunk in cache and return it */\n    return chm->chunk_cache[chunk_num] = buf;\n}""}, {""func_name"": ""chmd_read_headers"", ""file_path"": ""libmspack/mspack/chmd.c"", ""func_code"": ""static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\""incorrect GUIDs\""))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \""WARNING; CHM version > 3\"");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\""content section begins after file has ended\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\""chunk size not large enough\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\""no chunks\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\""more than 100,000 chunks\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\""chunks larger than entire file\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \""WARNING; chunk size is not a power of two\"");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \""WARNING; first PMGL chunk is not zero\"");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\""first pmgl chunk is after last pmgl chunk\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\""index_root outside valid range\""))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \""WARNING; PMGL quickref area is too small\"");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \""WARNING; PMGL quickref area is too large\"");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      /* consider blank filenames to be an error */\n      if (name_len == 0) goto chunk_end;\n      name = p; p += name_len;\n\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \""/\"" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \""invalid section number '%u'.\"", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\""chunk ended before all entries could be read\""))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}""}]","{""caller"": 1, ""value"": 1}","[{""source"": ""caller_info(file:chmd.c, func:read_chunk)"", ""result"": [{""call_line"": 556, ""call_code"": ""read_chunk(self, chm, fh, n)"", ""caller_code"": ""static int chmd_fast_find(struct mschm_decompressor *base,\n\t\t\t  struct mschmd_header *chm, const char *filename,\n\t\t\t  struct mschmd_file *f_ptr, int f_size)\n{\n    struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n    struct mspack_system *sys;\n    struct mspack_file *fh;\n    const unsigned char *chunk, *p, *end;\n    int err = MSPACK_ERR_OK, result = -1;\n    unsigned int n, sec;\n\n    if (!self || !chm || !f_ptr || (f_size != sizeof(struct mschmd_file))) {\n\treturn MSPACK_ERR_ARGS;\n    }\n    sys = self->system;\n\n    /* clear the results structure */\n    memset(f_ptr, 0, f_size);\n\n    if (!(fh = sys->open(sys, chm->filename, MSPACK_SYS_OPEN_READ))) {\n\treturn MSPACK_ERR_OPEN;\n    }\n\n    /* go through PMGI chunk hierarchy to reach PMGL chunk */\n    if (chm->index_root < chm->num_chunks) {\n\tn = chm->index_root;\n\tfor (;;) {\n\t    if (!(chunk = read_chunk(self, chm, fh, n))) {\n\t\tsys->close(fh);\n\t\treturn self->error;\n\t    }\n\n\t    /* search PMGI/PMGL chunk. exit early if..."", ""caller_start"": 529, ""file_path"": ""libmspack/mspack/chmd.c""}, {""call_line"": 575, ""call_code"": ""read_chunk(self, chm, fh, n)"", ""caller_code"": ""static int chmd_fast_find(struct mschm_decompressor *base,\n\t\t\t  struct mschmd_header *chm, const char *filename,\n\t\t\t  struct mschmd_file *f_ptr, int f_size)\n{\n    struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n    struct mspack_system *sys;\n    struct mspack_file *fh;\n    const unsigned char *chunk, *p, *end;\n    int err = MSPACK_ERR_OK, result = -1;\n    unsigned int n, sec;\n\n    if (!self || !chm || !f_ptr || (f_size != sizeof(struct mschmd_file))) {\n\treturn MSPACK_ERR_ARGS;\n    }\n    sys = self->system;\n\n    /* clear the results structure */\n    memset(f_ptr, 0, f_size);\n\n    if (!(fh = sys->open(sys, chm->filename, MSPACK_SYS_OPEN_READ))) {\n\treturn MSPACK_ERR_OPEN;\n    }\n\n    /* go through PMGI chunk hierarchy to reach PMGL chunk */\n    if (chm->index_root < chm->num_chunks) {\n\tn = chm->index_root;\n\tfor (;;) {\n\t    if (!(chunk = read_chunk(self, chm, fh, n))) {\n\t\tsys->close(fh);\n\t\treturn self->error;\n\t    }\n\n\t    /* search PMGI/PMGL chunk. exit early if..."", ""caller_start"": 529, ""file_path"": ""libmspack/mspack/chmd.c""}]}, {""source"": ""value_info(file:chmd.c, value:chm->num_chunks)"", ""result"": {""value_trace"": [{""full_code"": ""chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks])"", ""line"": 350, ""func_name"": ""chmd_read_headers""}], ""struct_var"": ""chm"", ""struct_type"": ""mschmd_header*"", ""struct_definition"": ""static struct mschmd_header\n\nstatic struct mschmd_header\n\nstatic struct mschmd_header\n\nstruct mschmd_header\n\nstruct mschmd_header {\n  /** The version of the CHM file format used in this file. */\n  unsigned int version;\n\n  /**\n   * The \""timestamp\"" of the CHM helpfile. \n   *\n   * It is the lower 32 bits of a 64-bit value representing the number of\n   * centiseconds since 1601-01-01 00:00:00 UTC, plus 42. It is not useful\n   * as a timestamp, but it is useful as a semi-unique ID.\n   */\n  unsigned int timestamp;\n      \n  /**\n   * The default Language and Country ID (LCID) of the user who ran the\n   * HTMLHelp Compiler. This is not the language of the CHM file itself.\n   */\n  unsigned int language;\n\n  /**\n   * The filename of the CHM helpfile. This is given by the library user\n   * and may be in any format.\n   */\n  const char *filename;\n\n  /** The length of the CHM helpfile, in bytes. */\n  off_t length;\n\n  /** A list of all non-system files in the CHM helpfile. */\n  struct mschmd_file *files;\n\n  /**\n   * A list of all system files in the CHM helpfile.\n   *\n   * System files are files which begi...\n\nstruct mschmd_header\n\nstruct mschmd_header\n\nstruct mschmd_header\n\nstruct mschmd_header\n\nstruct mschmd_header {\n  /** The version of the CHM file format used in this file. */\n  unsigned int version;\n\n  /**\n   * The \""timestamp\"" of the CHM helpfile. \n   *\n   * It is the lower 32 bits of a 64-bit value representing the number of\n   * centiseconds since 1601-01-01 00:00:00 UTC, plus 42. It is not useful\n   * as a timestamp, but it is useful as a semi-unique ID.\n   */\n  unsigned int timestamp;\n      \n  /**\n   * The default Language and Country ID (LCID) of the user who ran the\n   * HTMLHelp Compiler. This is not the language of the CHM file itself.\n   */\n  unsigned int language;\n\n  /**\n   * The filename of the CHM helpfile. This is given by the library user\n   * and may be in any format.\n   */\n  const char *filename;\n\n  /** The length of the CHM helpfile, in bytes. */\n  off_t length;\n\n  /** A list of all non-system files in the CHM helpfile. */\n  struct mschmd_file *files;\n\n  /**\n   * A list of all system files in the CHM helpfile.\n   *\n   * System files are files which begi...\n\nstruct mschmd_header\n\nstruct mschmd_header""}}]","libmspack/mspack/chmd.c:623 (original off-by-one check allowed chunk_num == num_chunks)  libmspack/mspack/chmd.c:350 (chm->num_chunks initialized from CHM file header data)  libmspack/mspack/chmd.c:556/575 (read_chunk called with chunk_num derived from chm->index_root or other CHM file-parsed values). Untrusted input in CHM files bypasses bounds checks, leading to invalid chunk reads and uninitialized data dereference.",0.95,./github/other_context/CVE-2018-14679
19,CVE-2018-16435,"CWE-190, CWE-787",c_cpp,"Little CMS (aka Little Color Management System) 2.9 has an integer overflow in the AllocateDataSet function in cmscgats.c, leading to a heap-based buffer overflow in the SetData function via a crafted file in the second argument to cmsIT8LoadFromFile.",https://github.com/mm2/Little-CMS/commit/768f70ca405cd3159d990e962d54456773bb8cf8,Upgrade Visual studio 2017 15.8\n\n- Upgrade to 15.8\n- Add check on CGATS memory allocation (thanks to Quang Nguyen for\npointing out this),1,"[{""func_name"": ""AllocateDataSet"", ""file_path"": ""src/cmscgats.c"", ""func_code"": ""static\nvoid AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t -> Data) return;    // Already allocated\n\n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \""NUMBER_OF_FIELDS\""));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \""NUMBER_OF_SETS\""));\n\n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n\n        SynError(it8, \""AllocateDataSet: Unable to allocate data array\"");\n    }\n\n}"", ""target"": 0}]","[{""func_name"": ""AllocateDataSet"", ""file_path"": ""src/cmscgats.c"", ""func_code"": ""static\nvoid AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t -> Data) return;    // Already allocated\n\n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \""NUMBER_OF_FIELDS\""));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \""NUMBER_OF_SETS\""));\n\n    if (t -> nSamples < 0 || t->nSamples > 0x7ffe || t->nPatches < 0 || t->nPatches > 0x7ffe)\n    {\n        SynError(it8, \""AllocateDataSet: too much data\"");\n    }\n    else {\n        t->Data = (char**)AllocChunk(it8, ((cmsUInt32Number)t->nSamples + 1) * ((cmsUInt32Number)t->nPatches + 1) * sizeof(char*));\n        if (t->Data == NULL) {\n\n            SynError(it8, \""AllocateDataSet: Unable to allocate data array\"");\n        }\n    }\n\n}""}]","{""function"": 1, ""code"": 1, ""caller"": 1}","[{""source"": ""func_info(file:cmscgats.c, func:SetData)"", ""result"": [{""code"": ""static\ncmsBool SetData(cmsIT8* it8, int nSet, int nField, const char *Val)\n{\n    TABLE* t = GetTable(it8);\n\n    if (!t->Data)\n        AllocateDataSet(it8);\n\n    if (!t->Data) return FALSE;\n\n    if (nSet > t -> nPatches || nSet < 0) {\n\n            return SynError(it8, \""Patch %d out of range, there are %d patches\"", nSet, t -> nPatches);\n    }\n\n    if (nField > t ->nSamples || nField < 0) {\n            return SynError(it8, \""Sample %d out of range, there are %d samples\"", nField, t ->nSamples);\n\n    }\n\n    t->Data [nSet * t -> nSamples + nField] = AllocString(it8, Val);\n    return TRUE;\n}"", ""start_line"": 1531, ""end_line"": 1553, ""full_name"": ""SetData"", ""file_path"": ""src/cmscgats.c""}]}, {""source"": ""code_info(file:cmscgats.c, lines:155-175)"", ""result"": ""\n        char           id[MAXID];             // identifier\n        char           str[MAXSTR];           // string\n\n        // Allowed keywords & datasets. They have visibility on whole stream\n        KEYVALUE*      ValidKeywords;\n        KEYVALUE*      ValidSampleID;\n\n        char*          Source;                // Points to loc. being parsed\n        cmsInt32Number lineno;                // line counter for error reporting\n\n        FILECTX*       FileStack[MAXINCLUDE]; // Stack of files being parsed\n        cmsInt32Number IncludeSP;             // Include Stack Pointer\n\n        char*          MemoryBlock;           // The stream if holded in memory\n\n        char           DoubleFormatter[MAXID];// Printf-like 'cmsFloat64Number' formatter\n\n        cmsContext    ContextID;              // The threading context\n\n   } cmsIT8;\n\n""}, {""source"": ""caller_info(file:cmscgats.c, func:AllocateDataSet)"", ""result"": [{""call_line"": 1537, ""call_code"": ""AllocateDataSet(it8)"", ""caller_code"": ""static\ncmsBool SetData(cmsIT8* it8, int nSet, int nField, const char *Val)\n{\n    TABLE* t = GetTable(it8);\n\n    if (!t->Data)\n        AllocateDataSet(it8);\n\n    if (!t->Data) return FALSE;\n\n    if (nSet > t -> nPatches || nSet < 0) {\n\n            return SynError(it8, \""Patch %d out of range, there are %d patches\"", nSet, t -> nPatches);\n    }\n\n    if (nField > t ->nSamples || nField < 0) {\n            return SynError(it8, \""Sample %d out of range, there are %d samples\"", nField, t ->nSamples);\n\n    }\n\n    t->Data [nSet * t -> nSamples + nField] = AllocString(it8, Val);\n    return TRUE;\n}"", ""caller_start"": 1531, ""file_path"": ""src/cmscgats.c""}, {""call_line"": 1881, ""call_code"": ""AllocateDataSet(it8)"", ""caller_code"": ""static\ncmsBool DataSection (cmsIT8* it8)\n{\n    int  iField = 0;\n    int  iSet   = 0;\n    char Buffer[256];\n    TABLE* t = GetTable(it8);\n\n    InSymbol(it8);   // Eats \""BEGIN_DATA\""\n    CheckEOLN(it8);\n\n    if (!t->Data)\n        AllocateDataSet(it8);\n\n    while (it8->sy != SEND_DATA && it8->sy != SEOF)\n    {\n        if (iField >= t -> nSamples) {\n            iField = 0;\n            iSet++;\n\n        }\n\n        if (it8->sy != SEND_DATA && it8->sy != SEOF) {\n\n            if (!GetVal(it8, Buffer, 255, \""Sample data expected\""))\n                return FALSE;\n\n            if (!SetData(it8, iSet, iField, Buffer))\n                return FALSE;\n\n            iField++;\n\n            InSymbol(it8);\n            SkipEOLN(it8);\n        }\n    }\n\n    SkipEOLN(it8);\n    Skip(it8, SEND_DATA);\n    SkipEOLN(it8);\n\n    // Check for data completion.\n\n    if ((iSet+1) != t -> nPatches)\n        return SynError(it8, \""Count mismatch. NUMBER_OF_SETS was %d, found %d\\n\"", t ->nPatches, iSet+1);\n\n    return TRUE;\n}"", ""caller_start"": 1869, ""file_path"": ""src/cmscgats.c""}, {""call_line"": 2651, ""call_code"": ""AllocateDataSet(it8)"", ""caller_code"": ""cmsBool CMSEXPORT cmsIT8SetData(cmsHANDLE hIT8, const char* cPatch, const char* cSample, const char *Val)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n    int iField, iSet;\n    TABLE* t;\n\n    _cmsAssert(hIT8 != NULL);\n\n    t = GetTable(it8);\n\n    iField = LocateSample(it8, cSample);\n\n    if (iField < 0)\n        return FALSE;\n\n    if (t-> nPatches == 0) {\n\n        AllocateDataFormat(it8);\n        AllocateDataSet(it8);\n        CookPointers(it8);\n    }\n\n    if (cmsstrcasecmp(cSample, \""SAMPLE_ID\"") == 0) {\n\n        iSet   = LocateEmptyPatch(it8);\n        if (iSet < 0) {\n            return SynError(it8, \""Couldn't add more patches '%s'\\n\"", cPatch);\n        }\n\n        iField = t -> SampleID;\n    }\n    else {\n        iSet = LocatePatch(it8, cPatch);\n        if (iSet < 0) {\n            return FALSE;\n        }\n    }\n\n    return SetData(it8, iSet, iField, Val);\n}"", ""caller_start"": 2633, ""file_path"": ""src/cmscgats.c""}]}]","cmscgats.c:1507-1515: Untrusted input values (nSamples, nPatches) are multiplied without bounds checks during memory allocation for t->Data. This allows integer overflow, resulting in an undersized heap allocation. cmscgats.c:1531-1553: Subsequent writes to t->Data in SetData use indices based on the original (correct) allocation size, but the actual allocated buffer is smaller due to overflow, causing a heap-based buffer overflow.",0.95,./github/other_context/CVE-2018-16435
20,CVE-2018-20845,CWE-369,c_cpp,"Division-by-zero vulnerabilities in the functions pi_next_pcrl, pi_next_cprl, and pi_next_rpcl in openmj2/pi.c in OpenJPEG through 2.3.0 allow remote attackers to cause a denial of service (application crash).",https://github.com/uclouvain/openjpeg/commit/c5bd64ea146162967c29bd2af0cbb845ba3eaaaf,[MJ2] To avoid divisions by zero / undefined behaviour on shift\n\nSigned-off-by: Young_X <YangX92@hotmail.com>,3,"[{""func_name"": ""pi_next_pcrl"", ""file_path"": ""src/lib/openmj2/pi.c"", ""func_code"": ""static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        int compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                int dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n            pi->y += pi->dy - (pi->y % pi->dy)) {\n        for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                pi->x += pi->dx - (pi->x % pi->dx)) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}"", ""target"": 0}, {""func_name"": ""pi_next_rpcl"", ""file_path"": ""src/lib/openmj2/pi.c"", ""func_code"": ""static opj_bool pi_next_rpcl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        goto LABEL_SKIP;\n    } else {\n        int compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                int dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += pi->dy - (pi->y % pi->dy)) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += pi->dx - (pi->x % pi->dx)) {\n                for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    comp = &pi->comps[pi->compno];\n                    if (pi->resno >= comp->numresolutions) {\n                        continue;\n                    }\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}"", ""target"": 0}, {""func_name"": ""pi_next_cprl"", ""file_path"": ""src/lib/openmj2/pi.c"", ""func_code"": ""static opj_bool pi_next_cprl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n        int resno;\n        comp = &pi->comps[pi->compno];\n        pi->dx = 0;\n        pi->dy = 0;\n        for (resno = 0; resno < comp->numresolutions; resno++) {\n            int dx, dy;\n            res = &comp->resolutions[resno];\n            dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n            dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n            pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n            pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n        }\n        if (!pi->tp_on) {\n            pi->poc.ty0 = pi->ty0;\n            pi->poc.tx0 = pi->tx0;\n            pi->poc.ty1 = pi->ty1;\n            pi->poc.tx1 = pi->tx1;\n        }\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += pi->dy - (pi->y % pi->dy)) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += pi->dx - (pi->x % pi->dx)) {\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}"", ""target"": 1}]","[{""func_name"": ""pi_next_pcrl"", ""file_path"": ""src/lib/openmj2/pi.c"", ""func_code"": ""static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        int compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                int dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n            pi->y += pi->dy - (pi->y % pi->dy)) {\n        for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                pi->x += pi->dx - (pi->x % pi->dx)) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}""}, {""func_name"": ""pi_next_rpcl"", ""file_path"": ""src/lib/openmj2/pi.c"", ""func_code"": ""static opj_bool pi_next_rpcl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        goto LABEL_SKIP;\n    } else {\n        int compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                int dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += pi->dy - (pi->y % pi->dy)) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += pi->dx - (pi->x % pi->dx)) {\n                for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    comp = &pi->comps[pi->compno];\n                    if (pi->resno >= comp->numresolutions) {\n                        continue;\n                    }\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}""}, {""func_name"": ""pi_next_cprl"", ""file_path"": ""src/lib/openmj2/pi.c"", ""func_code"": ""static opj_bool pi_next_cprl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n        int resno;\n        comp = &pi->comps[pi->compno];\n        pi->dx = 0;\n        pi->dy = 0;\n        for (resno = 0; resno < comp->numresolutions; resno++) {\n            int dx, dy;\n            res = &comp->resolutions[resno];\n            dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));\n            dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));\n            pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);\n            pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);\n        }\n        if (!pi->tp_on) {\n            pi->poc.ty0 = pi->ty0;\n            pi->poc.tx0 = pi->tx0;\n            pi->poc.ty1 = pi->ty1;\n            pi->poc.tx1 = pi->tx1;\n        }\n        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n                pi->y += pi->dy - (pi->y % pi->dy)) {\n            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                    pi->x += pi->dx - (pi->x % pi->dx)) {\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    int levelno;\n                    int trx0, try0;\n                    int trx1, try1;\n                    int rpx, rpy;\n                    int prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);\n                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);\n                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);\n                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);\n                    rpx = res->pdx + levelno;\n                    rpy = res->pdy + levelno;\n\n                    /* To avoid divisions by zero / undefined behaviour on shift */\n                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||\n                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {\n                        continue;\n                    }\n\n                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                            ((try0 << levelno) % (1 << rpy))))) {\n                        continue;\n                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}""}]","{""value"": 5, ""code"": 2}","[{""source"": ""value_info(file:pi.c, value:comp->dx)"", ""result"": {""value_trace"": [{""full_code"": ""comp->dx = image->comps[compno].dx"", ""line"": 499, ""func_name"": ""pi_create_decode""}, {""full_code"": ""comp->dx = image->comps[compno].dx"", ""line"": 636, ""func_name"": ""pi_initialise_encode""}], ""struct_var"": ""comp"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:pi.c, value:comp->dy)"", ""result"": {""value_trace"": [{""full_code"": ""comp->dy = image->comps[compno].dy"", ""line"": 500, ""func_name"": ""pi_create_decode""}, {""full_code"": ""comp->dy = image->comps[compno].dy"", ""line"": 637, ""func_name"": ""pi_initialise_encode""}], ""struct_var"": ""comp"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:pi.c, value:res->pdx)"", ""result"": {""value_trace"": [{""full_code"": ""res->pdx = tccp->prcw[resno]"", ""line"": 525, ""func_name"": ""pi_create_decode""}, {""full_code"": ""res->pdx = 15"", ""line"": 528, ""func_name"": ""pi_create_decode""}, {""full_code"": ""res->pdx = tccp->prcw[resno]"", ""line"": 661, ""func_name"": ""pi_initialise_encode""}, {""full_code"": ""res->pdx = 15"", ""line"": 664, ""func_name"": ""pi_initialise_encode""}], ""struct_var"": ""res"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:pi.c, value:res->pdy)"", ""result"": {""value_trace"": [{""full_code"": ""res->pdy = tccp->prch[resno]"", ""line"": 526, ""func_name"": ""pi_create_decode""}, {""full_code"": ""res->pdy = 15"", ""line"": 529, ""func_name"": ""pi_create_decode""}, {""full_code"": ""res->pdy = tccp->prch[resno]"", ""line"": 662, ""func_name"": ""pi_initialise_encode""}, {""full_code"": ""res->pdy = 15"", ""line"": 665, ""func_name"": ""pi_initialise_encode""}], ""struct_var"": ""res"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:pi.c, value:levelno)"", ""result"": {""value_trace"": [{""full_code"": ""levelno = comp->numresolutions - 1 - pi->resno"", ""line"": 220, ""func_name"": ""pi_next_rpcl<duplicate>0""}, {""full_code"": ""levelno = comp->numresolutions - 1 - pi->resno"", ""line"": 313, ""func_name"": ""pi_next_pcrl<duplicate>0""}, {""full_code"": ""levelno = comp->numresolutions - 1 - pi->resno"", ""line"": 404, ""func_name"": ""pi_next_cprl<duplicate>0""}, {""full_code"": ""levelno = comp->numresolutions - 1 - resno"", ""line"": 531, ""func_name"": ""pi_create_decode""}, {""full_code"": ""levelno = comp->numresolutions - 1 - resno"", ""line"": 667, ""func_name"": ""pi_initialise_encode""}], ""struct_var"": ""levelno"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""code_info(file:pi.c, lines:331-350)"", ""result"": ""                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n""}, {""source"": ""code_info(file:pi.c, lines:230-250)"", ""result"": ""                    }\n                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)\n                           - int_floordivpow2(trx0, res->pdx);\n                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)\n                           - int_floordivpow2(try0, res->pdy);\n                    pi->precno = prci + prcj * res->pw;\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n""}]","In `pi_next_pcrl` (src/lib/openmj2/pi.c:324-331) and `pi_next_rpcl` (src/lib/openmj2/pi.c:223-230), unsafe shifts `comp->dx << rpx` and `comp->dy << rpy` could overflow, producing zero or invalid values. These shifted values are later used as divisors in `int_ceildiv(pi->x, comp->dx << levelno)` and `int_floordivpow2(..., comp->dy << levelno)` (src/lib/openmj2/pi.c:331-350 and 230-250). The patch adds checks to skip cases where shifts would overflow, preventing division-by-zero.",0.95,./github/other_context/CVE-2018-20845
21,CVE-2019-11039,"CWE-190, CWE-125",c_cpp,"Function iconv_mime_decode_headers() in PHP versions 7.1.x below 7.1.30, 7.2.x below 7.2.19 and 7.3.x below 7.3.6 may perform out-of-buffer read due to integer overflow when parsing MIME headers. This may lead to information disclosure or crash.",https://github.com/php/php-src/commit/70523ce41ff400ea00343a03f297332cb1f1b77b,Fix bug #78069 - Out-of-bounds read in iconv.c:_php_iconv_mime_decode() due to integer overflow\n\n(cherry picked from commit 7cf7148a8f8f4f55fb04de2a517d740bb6253eac),1,"[{""func_name"": ""_php_iconv_mime_decode"", ""file_path"": ""ext/iconv/iconv.c"", ""func_code"": ""static php_iconv_err_t _php_iconv_mime_decode(smart_str *pretval, const char *str, size_t str_nbytes, const char *enc, const char **next_pos, int mode)\n{\n\tphp_iconv_err_t err = PHP_ICONV_ERR_SUCCESS;\n\n\ticonv_t cd = (iconv_t)(-1), cd_pl = (iconv_t)(-1);\n\n\tconst char *p1;\n\tsize_t str_left;\n\tunsigned int scan_stat = 0;\n\tconst char *csname = NULL;\n\tsize_t csname_len;\n\tconst char *encoded_text = NULL;\n\tsize_t encoded_text_len = 0;\n\tconst char *encoded_word = NULL;\n\tconst char *spaces = NULL;\n\n\tphp_iconv_enc_scheme_t enc_scheme = PHP_ICONV_ENC_SCHEME_BASE64;\n\n\tif (next_pos != NULL) {\n\t\t*next_pos = NULL;\n\t}\n\n\tcd_pl = iconv_open(enc, ICONV_ASCII_ENCODING);\n\n\tif (cd_pl == (iconv_t)(-1)) {\n#if ICONV_SUPPORTS_ERRNO\n\t\tif (errno == EINVAL) {\n\t\t\terr = PHP_ICONV_ERR_WRONG_CHARSET;\n\t\t} else {\n\t\t\terr = PHP_ICONV_ERR_CONVERTER;\n\t\t}\n#else\n\t\terr = PHP_ICONV_ERR_UNKNOWN;\n#endif\n\t\tgoto out;\n\t}\n\n\tp1 = str;\n\tfor (str_left = str_nbytes; str_left > 0; str_left--, p1++) {\n\t\tint eos = 0;\n\n\t\tswitch (scan_stat) {\n\t\t\tcase 0: /* expecting any character */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\tencoded_word = p1;\n\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ' ': case '\\t': /* a chunk of whitespaces */\n\t\t\t\t\t\tspaces = p1;\n\t\t\t\t\t\tscan_stat = 11;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: /* first letter of a non-encoded word */\n\t\t\t\t\t\terr = _php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tif (mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR) {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_SUCCESS;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 1: /* expecting a delimiter */\n\t\t\t\tif (*p1 != '?') {\n\t\t\t\t\tif (*p1 == '\\r' || *p1 == '\\n') {\n\t\t\t\t\t\t--p1;\n\t\t\t\t\t}\n\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcsname = p1 + 1;\n\t\t\t\tscan_stat = 2;\n\t\t\t\tbreak;\n\n\t\t\tcase 2: /* expecting a charset name */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '?': /* normal delimiter: encoding scheme follows */\n\t\t\t\t\t\tscan_stat = 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '*': /* new style delimiter: locale id follows */\n\t\t\t\t\t\tscan_stat = 10;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\r': case '\\n': /* not an encoded-word */\n\t\t\t\t\t\t--p1;\n\t\t\t\t\t\t_php_iconv_appendc(pretval, '=', cd_pl);\n\t\t\t\t\t\t_php_iconv_appendc(pretval, '?', cd_pl);\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, csname, (size_t)((p1 + 1) - csname), cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsname = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (scan_stat != 2) {\n\t\t\t\t\tchar tmpbuf[80];\n\n\t\t\t\t\tif (csname == NULL) {\n\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tcsname_len = (size_t)(p1 - csname);\n\n\t\t\t\t\tif (csname_len > sizeof(tmpbuf) - 1) {\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmemcpy(tmpbuf, csname, csname_len);\n\t\t\t\t\ttmpbuf[csname_len] = '\\0';\n\n\t\t\t\t\tif (cd != (iconv_t)(-1)) {\n\t\t\t\t\t\ticonv_close(cd);\n\t\t\t\t\t}\n\n\t\t\t\t\tcd = iconv_open(enc, tmpbuf);\n\n\t\t\t\t\tif (cd == (iconv_t)(-1)) {\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\t/* Bad character set, but the user wants us to\n\t\t\t\t\t\t\t * press on. In this case, we'll just insert the\n\t\t\t\t\t\t\t * undecoded encoded word, since there isn't really\n\t\t\t\t\t\t\t * a more sensible behaviour available; the only\n\t\t\t\t\t\t\t * other options are to swallow the encoded word\n\t\t\t\t\t\t\t * entirely or decode it with an arbitrarily chosen\n\t\t\t\t\t\t\t * single byte encoding, both of which seem to have\n\t\t\t\t\t\t\t * a higher WTF factor than leaving it undecoded.\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t * Given this approach, we need to skip ahead to\n\t\t\t\t\t\t\t * the end of the encoded word. */\n\t\t\t\t\t\t\tint qmarks = 2;\n\t\t\t\t\t\t\twhile (qmarks > 0 && str_left > 1) {\n\t\t\t\t\t\t\t\tif (*(++p1) == '?') {\n\t\t\t\t\t\t\t\t\t--qmarks;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t--str_left;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Look ahead to check for the terminating = that\n\t\t\t\t\t\t\t * should be there as well; if it's there, we'll\n\t\t\t\t\t\t\t * also include that. If it's not, there isn't much\n\t\t\t\t\t\t\t * we can do at this point. */\n\t\t\t\t\t\t\tif (*(p1 + 1) == '=') {\n\t\t\t\t\t\t\t\t++p1;\n\t\t\t\t\t\t\t\t--str_left;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Let's go back and see if there are further\n\t\t\t\t\t\t\t * encoded words or bare content, and hope they\n\t\t\t\t\t\t\t * might actually have a valid character set. */\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n#if ICONV_SUPPORTS_ERRNO\n\t\t\t\t\t\t\tif (errno == EINVAL) {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_WRONG_CHARSET;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_CONVERTER;\n\t\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\t\terr = PHP_ICONV_ERR_UNKNOWN;\n#endif\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3: /* expecting a encoding scheme specifier */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\tenc_scheme = PHP_ICONV_ENC_SCHEME_BASE64;\n\t\t\t\t\t\tscan_stat = 4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tenc_scheme = PHP_ICONV_ENC_SCHEME_QPRINT;\n\t\t\t\t\t\tscan_stat = 4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 4: /* expecting a delimiter */\n\t\t\t\tif (*p1 != '?') {\n\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tencoded_text = p1 + 1;\n\t\t\t\tscan_stat = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 5: /* expecting an encoded portion */\n\t\t\t\tif (*p1 == '?') {\n\t\t\t\t\tencoded_text_len = (size_t)(p1 - encoded_text);\n\t\t\t\t\tscan_stat = 6;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 7: /* expecting a \""\\n\"" character */\n\t\t\t\tif (*p1 == '\\n') {\n\t\t\t\t\tscan_stat = 8;\n\t\t\t\t} else {\n\t\t\t\t\t/* bare CR */\n\t\t\t\t\t_php_iconv_appendc(pretval, '\\r', cd_pl);\n\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\tscan_stat = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 8: /* checking whether the following line is part of a\n\t\t\t\t\t   folded header */\n\t\t\t\tif (*p1 != ' ' && *p1 != '\\t') {\n\t\t\t\t\t--p1;\n\t\t\t\t\tstr_left = 1; /* quit_loop */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (encoded_word == NULL) {\n\t\t\t\t\t_php_iconv_appendc(pretval, ' ', cd_pl);\n\t\t\t\t}\n\t\t\t\tspaces = NULL;\n\t\t\t\tscan_stat = 11;\n\t\t\t\tbreak;\n\n\t\t\tcase 6: /* expecting a End-Of-Chunk character \""=\"" */\n\t\t\t\tif (*p1 != '=') {\n\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tscan_stat = 9;\n\t\t\t\tif (str_left == 1) {\n\t\t\t\t\teos = 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 9: /* choice point, seeing what to do next.*/\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Handle non-RFC-compliant formats\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * RFC2047 requires the character that comes right\n\t\t\t\t\t\t * after an encoded word (chunk) to be a whitespace,\n\t\t\t\t\t\t * while there are lots of broken implementations that\n\t\t\t\t\t\t * generate such malformed headers that don't fulfill\n\t\t\t\t\t\t * that requirement.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!eos) {\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* break is omitted intentionally */\n\n\t\t\t\t\tcase '\\r': case '\\n': case ' ': case '\\t': {\n\t\t\t\t\t\tzend_string *decoded_text;\n\n\t\t\t\t\t\tswitch (enc_scheme) {\n\t\t\t\t\t\t\tcase PHP_ICONV_ENC_SCHEME_BASE64:\n\t\t\t\t\t\t\t\tdecoded_text = php_base64_decode((unsigned char*)encoded_text, encoded_text_len);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PHP_ICONV_ENC_SCHEME_QPRINT:\n\t\t\t\t\t\t\t\tdecoded_text = php_quot_print_decode((unsigned char*)encoded_text, encoded_text_len, 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tdecoded_text = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (decoded_text == NULL) {\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_UNKNOWN;\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, ZSTR_VAL(decoded_text), ZSTR_LEN(decoded_text), cd);\n\t\t\t\t\t\tzend_string_release_ex(decoded_text, 0);\n\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)(p1 - encoded_word), cd_pl);\n\t\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (eos) { /* reached end-of-string. done. */\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch (*p1) {\n\t\t\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase ' ': case '\\t': /* medial whitespaces */\n\t\t\t\t\t\t\t\tspaces = p1;\n\t\t\t\t\t\t\t\tscan_stat = 11;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault: /* first letter of a non-encoded word */\n\t\t\t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 10: /* expects a language specifier. dismiss it for now */\n\t\t\t\tif (*p1 == '?') {\n\t\t\t\t\tscan_stat = 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 11: /* expecting a chunk of whitespaces */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\tif (spaces != NULL && encoded_word == NULL) {\n\t\t\t\t\t\t\t_php_iconv_appendl(pretval, spaces, (size_t)(p1 - spaces), cd_pl);\n\t\t\t\t\t\t\tspaces = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = p1;\n\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ' ': case '\\t':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: /* first letter of a non-encoded word */\n\t\t\t\t\t\tif (spaces != NULL) {\n\t\t\t\t\t\t\t_php_iconv_appendl(pretval, spaces, (size_t)(p1 - spaces), cd_pl);\n\t\t\t\t\t\t\tspaces = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 12: /* expecting a non-encoded word */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ' ': case '\\t':\n\t\t\t\t\t\tspaces = p1;\n\t\t\t\t\t\tscan_stat = 11;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\tif (!(mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tencoded_word = p1;\n\t\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* break is omitted intentionally */\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (scan_stat) {\n\t\tcase 0: case 8: case 11: case 12:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\tif (scan_stat == 1) {\n\t\t\t\t\t_php_iconv_appendc(pretval, '=', cd_pl);\n\t\t\t\t}\n\t\t\t\terr = PHP_ICONV_ERR_SUCCESS;\n\t\t\t} else {\n\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\n\n\tif (next_pos != NULL) {\n\t\t*next_pos = p1;\n\t}\n\n\tsmart_str_0(pretval);\nout:\n\tif (cd != (iconv_t)(-1)) {\n\t\ticonv_close(cd);\n\t}\n\tif (cd_pl != (iconv_t)(-1)) {\n\t\ticonv_close(cd_pl);\n\t}\n\treturn err;\n}"", ""target"": 0}]","[{""func_name"": ""_php_iconv_mime_decode"", ""file_path"": ""ext/iconv/iconv.c"", ""func_code"": ""static php_iconv_err_t _php_iconv_mime_decode(smart_str *pretval, const char *str, size_t str_nbytes, const char *enc, const char **next_pos, int mode)\n{\n\tphp_iconv_err_t err = PHP_ICONV_ERR_SUCCESS;\n\n\ticonv_t cd = (iconv_t)(-1), cd_pl = (iconv_t)(-1);\n\n\tconst char *p1;\n\tsize_t str_left;\n\tunsigned int scan_stat = 0;\n\tconst char *csname = NULL;\n\tsize_t csname_len;\n\tconst char *encoded_text = NULL;\n\tsize_t encoded_text_len = 0;\n\tconst char *encoded_word = NULL;\n\tconst char *spaces = NULL;\n\n\tphp_iconv_enc_scheme_t enc_scheme = PHP_ICONV_ENC_SCHEME_BASE64;\n\n\tif (next_pos != NULL) {\n\t\t*next_pos = NULL;\n\t}\n\n\tcd_pl = iconv_open(enc, ICONV_ASCII_ENCODING);\n\n\tif (cd_pl == (iconv_t)(-1)) {\n#if ICONV_SUPPORTS_ERRNO\n\t\tif (errno == EINVAL) {\n\t\t\terr = PHP_ICONV_ERR_WRONG_CHARSET;\n\t\t} else {\n\t\t\terr = PHP_ICONV_ERR_CONVERTER;\n\t\t}\n#else\n\t\terr = PHP_ICONV_ERR_UNKNOWN;\n#endif\n\t\tgoto out;\n\t}\n\n\tp1 = str;\n\tfor (str_left = str_nbytes; str_left > 0; str_left--, p1++) {\n\t\tint eos = 0;\n\n\t\tswitch (scan_stat) {\n\t\t\tcase 0: /* expecting any character */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\tencoded_word = p1;\n\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ' ': case '\\t': /* a chunk of whitespaces */\n\t\t\t\t\t\tspaces = p1;\n\t\t\t\t\t\tscan_stat = 11;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: /* first letter of a non-encoded word */\n\t\t\t\t\t\terr = _php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tif (mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR) {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_SUCCESS;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 1: /* expecting a delimiter */\n\t\t\t\tif (*p1 != '?') {\n\t\t\t\t\tif (*p1 == '\\r' || *p1 == '\\n') {\n\t\t\t\t\t\t--p1;\n\t\t\t\t\t}\n\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcsname = p1 + 1;\n\t\t\t\tscan_stat = 2;\n\t\t\t\tbreak;\n\n\t\t\tcase 2: /* expecting a charset name */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '?': /* normal delimiter: encoding scheme follows */\n\t\t\t\t\t\tscan_stat = 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '*': /* new style delimiter: locale id follows */\n\t\t\t\t\t\tscan_stat = 10;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\r': case '\\n': /* not an encoded-word */\n\t\t\t\t\t\t--p1;\n\t\t\t\t\t\t_php_iconv_appendc(pretval, '=', cd_pl);\n\t\t\t\t\t\t_php_iconv_appendc(pretval, '?', cd_pl);\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, csname, (size_t)((p1 + 1) - csname), cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsname = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (scan_stat != 2) {\n\t\t\t\t\tchar tmpbuf[80];\n\n\t\t\t\t\tif (csname == NULL) {\n\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tcsname_len = (size_t)(p1 - csname);\n\n\t\t\t\t\tif (csname_len > sizeof(tmpbuf) - 1) {\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmemcpy(tmpbuf, csname, csname_len);\n\t\t\t\t\ttmpbuf[csname_len] = '\\0';\n\n\t\t\t\t\tif (cd != (iconv_t)(-1)) {\n\t\t\t\t\t\ticonv_close(cd);\n\t\t\t\t\t}\n\n\t\t\t\t\tcd = iconv_open(enc, tmpbuf);\n\n\t\t\t\t\tif (cd == (iconv_t)(-1)) {\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\t/* Bad character set, but the user wants us to\n\t\t\t\t\t\t\t * press on. In this case, we'll just insert the\n\t\t\t\t\t\t\t * undecoded encoded word, since there isn't really\n\t\t\t\t\t\t\t * a more sensible behaviour available; the only\n\t\t\t\t\t\t\t * other options are to swallow the encoded word\n\t\t\t\t\t\t\t * entirely or decode it with an arbitrarily chosen\n\t\t\t\t\t\t\t * single byte encoding, both of which seem to have\n\t\t\t\t\t\t\t * a higher WTF factor than leaving it undecoded.\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t * Given this approach, we need to skip ahead to\n\t\t\t\t\t\t\t * the end of the encoded word. */\n\t\t\t\t\t\t\tint qmarks = 2;\n\t\t\t\t\t\t\twhile (qmarks > 0 && str_left > 1) {\n\t\t\t\t\t\t\t\tif (*(++p1) == '?') {\n\t\t\t\t\t\t\t\t\t--qmarks;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t--str_left;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Look ahead to check for the terminating = that\n\t\t\t\t\t\t\t * should be there as well; if it's there, we'll\n\t\t\t\t\t\t\t * also include that. If it's not, there isn't much\n\t\t\t\t\t\t\t * we can do at this point. */\n\t\t\t\t\t\t\tif (*(p1 + 1) == '=') {\n\t\t\t\t\t\t\t\t++p1;\n\t\t\t\t\t\t\t\tif (str_left > 1) {\n\t\t\t\t\t\t\t\t\t--str_left;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Let's go back and see if there are further\n\t\t\t\t\t\t\t * encoded words or bare content, and hope they\n\t\t\t\t\t\t\t * might actually have a valid character set. */\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n#if ICONV_SUPPORTS_ERRNO\n\t\t\t\t\t\t\tif (errno == EINVAL) {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_WRONG_CHARSET;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_CONVERTER;\n\t\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\t\terr = PHP_ICONV_ERR_UNKNOWN;\n#endif\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3: /* expecting a encoding scheme specifier */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\tenc_scheme = PHP_ICONV_ENC_SCHEME_BASE64;\n\t\t\t\t\t\tscan_stat = 4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tenc_scheme = PHP_ICONV_ENC_SCHEME_QPRINT;\n\t\t\t\t\t\tscan_stat = 4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 4: /* expecting a delimiter */\n\t\t\t\tif (*p1 != '?') {\n\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tencoded_text = p1 + 1;\n\t\t\t\tscan_stat = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 5: /* expecting an encoded portion */\n\t\t\t\tif (*p1 == '?') {\n\t\t\t\t\tencoded_text_len = (size_t)(p1 - encoded_text);\n\t\t\t\t\tscan_stat = 6;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 7: /* expecting a \""\\n\"" character */\n\t\t\t\tif (*p1 == '\\n') {\n\t\t\t\t\tscan_stat = 8;\n\t\t\t\t} else {\n\t\t\t\t\t/* bare CR */\n\t\t\t\t\t_php_iconv_appendc(pretval, '\\r', cd_pl);\n\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\tscan_stat = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 8: /* checking whether the following line is part of a\n\t\t\t\t\t   folded header */\n\t\t\t\tif (*p1 != ' ' && *p1 != '\\t') {\n\t\t\t\t\t--p1;\n\t\t\t\t\tstr_left = 1; /* quit_loop */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (encoded_word == NULL) {\n\t\t\t\t\t_php_iconv_appendc(pretval, ' ', cd_pl);\n\t\t\t\t}\n\t\t\t\tspaces = NULL;\n\t\t\t\tscan_stat = 11;\n\t\t\t\tbreak;\n\n\t\t\tcase 6: /* expecting a End-Of-Chunk character \""=\"" */\n\t\t\t\tif (*p1 != '=') {\n\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tscan_stat = 9;\n\t\t\t\tif (str_left == 1) {\n\t\t\t\t\teos = 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 9: /* choice point, seeing what to do next.*/\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Handle non-RFC-compliant formats\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * RFC2047 requires the character that comes right\n\t\t\t\t\t\t * after an encoded word (chunk) to be a whitespace,\n\t\t\t\t\t\t * while there are lots of broken implementations that\n\t\t\t\t\t\t * generate such malformed headers that don't fulfill\n\t\t\t\t\t\t * that requirement.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!eos) {\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* break is omitted intentionally */\n\n\t\t\t\t\tcase '\\r': case '\\n': case ' ': case '\\t': {\n\t\t\t\t\t\tzend_string *decoded_text;\n\n\t\t\t\t\t\tswitch (enc_scheme) {\n\t\t\t\t\t\t\tcase PHP_ICONV_ENC_SCHEME_BASE64:\n\t\t\t\t\t\t\t\tdecoded_text = php_base64_decode((unsigned char*)encoded_text, encoded_text_len);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PHP_ICONV_ENC_SCHEME_QPRINT:\n\t\t\t\t\t\t\t\tdecoded_text = php_quot_print_decode((unsigned char*)encoded_text, encoded_text_len, 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tdecoded_text = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (decoded_text == NULL) {\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_UNKNOWN;\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, ZSTR_VAL(decoded_text), ZSTR_LEN(decoded_text), cd);\n\t\t\t\t\t\tzend_string_release_ex(decoded_text, 0);\n\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)(p1 - encoded_word), cd_pl);\n\t\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (eos) { /* reached end-of-string. done. */\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch (*p1) {\n\t\t\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase ' ': case '\\t': /* medial whitespaces */\n\t\t\t\t\t\t\t\tspaces = p1;\n\t\t\t\t\t\t\t\tscan_stat = 11;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault: /* first letter of a non-encoded word */\n\t\t\t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 10: /* expects a language specifier. dismiss it for now */\n\t\t\t\tif (*p1 == '?') {\n\t\t\t\t\tscan_stat = 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 11: /* expecting a chunk of whitespaces */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\tif (spaces != NULL && encoded_word == NULL) {\n\t\t\t\t\t\t\t_php_iconv_appendl(pretval, spaces, (size_t)(p1 - spaces), cd_pl);\n\t\t\t\t\t\t\tspaces = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = p1;\n\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ' ': case '\\t':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: /* first letter of a non-encoded word */\n\t\t\t\t\t\tif (spaces != NULL) {\n\t\t\t\t\t\t\t_php_iconv_appendl(pretval, spaces, (size_t)(p1 - spaces), cd_pl);\n\t\t\t\t\t\t\tspaces = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 12: /* expecting a non-encoded word */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ' ': case '\\t':\n\t\t\t\t\t\tspaces = p1;\n\t\t\t\t\t\tscan_stat = 11;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\tif (!(mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tencoded_word = p1;\n\t\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* break is omitted intentionally */\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (scan_stat) {\n\t\tcase 0: case 8: case 11: case 12:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\tif (scan_stat == 1) {\n\t\t\t\t\t_php_iconv_appendc(pretval, '=', cd_pl);\n\t\t\t\t}\n\t\t\t\terr = PHP_ICONV_ERR_SUCCESS;\n\t\t\t} else {\n\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\n\n\tif (next_pos != NULL) {\n\t\t*next_pos = p1;\n\t}\n\n\tsmart_str_0(pretval);\nout:\n\tif (cd != (iconv_t)(-1)) {\n\t\ticonv_close(cd);\n\t}\n\tif (cd_pl != (iconv_t)(-1)) {\n\t\ticonv_close(cd_pl);\n\t}\n\treturn err;\n}""}]","{""function"": 1, ""code"": 2}","[{""source"": ""func_info(file:iconv.c, func:_php_iconv_mime_decode)"", ""result"": [{""code"": ""static php_iconv_err_t _php_iconv_mime_decode(smart_str *pretval, const char *str, size_t str_nbytes, const char *enc, const char **next_pos, int mode)\n{\n\tphp_iconv_err_t err = PHP_ICONV_ERR_SUCCESS;\n\n\ticonv_t cd = (iconv_t)(-1), cd_pl = (iconv_t)(-1);\n\n\tconst char *p1;\n\tsize_t str_left;\n\tunsigned int scan_stat = 0;\n\tconst char *csname = NULL;\n\tsize_t csname_len;\n\tconst char *encoded_text = NULL;\n\tsize_t encoded_text_len = 0;\n\tconst char *encoded_word = NULL;\n\tconst char *spaces = NULL;\n\n\tphp_iconv_enc_scheme_t enc_scheme = PHP_ICONV_ENC_SCHEME_BASE64;\n\n\tif (next_pos != NULL) {\n\t\t*next_pos = NULL;\n\t}\n\n\tcd_pl = iconv_open(enc, ICONV_ASCII_ENCODING);\n\n\tif (cd_pl == (iconv_t)(-1)) {\n#if ICONV_SUPPORTS_ERRNO\n\t\tif (errno == EINVAL) {\n\t\t\terr = PHP_ICONV_ERR_WRONG_CHARSET;\n\t\t} else {\n\t\t\terr = PHP_ICONV_ERR_CONVERTER;\n\t\t}\n#else\n\t\terr = PHP_ICONV_ERR_UNKNOWN;\n#endif\n\t\tgoto out;\n\t}\n\n\tp1 = str;\n\tfor (str_left = str_nbytes; str_left > 0; str_left--, p1++) {\n\t\tint eos = 0;\n\n\t\tswitch (scan_stat) ..."", ""start_line"": 1474, ""end_line"": 2022, ""full_name"": ""_php_iconv_mime_decode"", ""file_path"": ""ext/iconv/iconv.c""}]}, {""source"": ""code_info(file:iconv.c, lines:1650-1670)"", ""result"": ""\t\t\t\t\t\t\t * Given this approach, we need to skip ahead to\n\t\t\t\t\t\t\t * the end of the encoded word. */\n\t\t\t\t\t\t\tint qmarks = 2;\n\t\t\t\t\t\t\twhile (qmarks > 0 && str_left > 1) {\n\t\t\t\t\t\t\t\tif (*(++p1) == '?') {\n\t\t\t\t\t\t\t\t\t--qmarks;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t--str_left;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Look ahead to check for the terminating = that\n\t\t\t\t\t\t\t * should be there as well; if it's there, we'll\n\t\t\t\t\t\t\t * also include that. If it's not, there isn't much\n\t\t\t\t\t\t\t * we can do at this point. */\n\t\t\t\t\t\t\tif (*(p1 + 1) == '=') {\n\t\t\t\t\t\t\t\t++p1;\n\t\t\t\t\t\t\t\t--str_left;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\tgoto out;\n""}, {""source"": ""code_info(file:iconv.c, lines:1474-2022)"", ""result"": ""static php_iconv_err_t _php_iconv_mime_decode(smart_str *pretval, const char *str, size_t str_nbytes, const char *enc, const char **next_pos, int mode)\n{\n\tphp_iconv_err_t err = PHP_ICONV_ERR_SUCCESS;\n\n\ticonv_t cd = (iconv_t)(-1), cd_pl = (iconv_t)(-1);\n\n\tconst char *p1;\n\tsize_t str_left;\n\tunsigned int scan_stat = 0;\n\tconst char *csname = NULL;\n\tsize_t csname_len;\n\tconst char *encoded_text = NULL;\n\tsize_t encoded_text_len = 0;\n\tconst char *encoded_word = NULL;\n\tconst char *spaces = NULL;\n\n\tphp_iconv_enc_scheme_t enc_scheme = PHP_ICONV_ENC_SCHEME_BASE64;\n\n\tif (next_pos != NULL) {\n\t\t*next_pos = NULL;\n\t}\n\n\tcd_pl = iconv_open(enc, ICONV_ASCII_ENCODING);\n\n\tif (cd_pl == (iconv_t)(-1)) {\n#if ICONV_SUPPORTS_ERRNO\n\t\tif (errno == EINVAL) {\n\t\t\terr = PHP_ICONV_ERR_WRONG_CHARSET;\n\t\t} else {\n\t\t\terr = PHP_ICONV_ERR_CONVERTER;\n\t\t}\n#else\n\t\terr = PHP_ICONV_ERR_UNKNOWN;\n#endif\n\t\tgoto out;\n\t}\n\n\tp1 = str;\n\tfor (str_left = str_nbytes; str_left > 0; str_left--, p1++) {\n\t\tint eos = 0;\n\n\t\tswitch (scan_stat) {\n\t\t\tcase 0: /* expecting any character */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\tencoded_word = p1;\n\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ' ': case '\\t': /* a chunk of whitespaces */\n\t\t\t\t\t\tspaces = p1;\n\t\t\t\t\t\tscan_stat = 11;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: /* first letter of a non-encoded word */\n\t\t\t\t\t\terr = _php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tif (mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR) {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_SUCCESS;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 1: /* expecting a delimiter */\n\t\t\t\tif (*p1 != '?') {\n\t\t\t\t\tif (*p1 == '\\r' || *p1 == '\\n') {\n\t\t\t\t\t\t--p1;\n\t\t\t\t\t}\n\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcsname = p1 + 1;\n\t\t\t\tscan_stat = 2;\n\t\t\t\tbreak;\n\n\t\t\tcase 2: /* expecting a charset name */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '?': /* normal delimiter: encoding scheme follows */\n\t\t\t\t\t\tscan_stat = 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '*': /* new style delimiter: locale id follows */\n\t\t\t\t\t\tscan_stat = 10;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\r': case '\\n': /* not an encoded-word */\n\t\t\t\t\t\t--p1;\n\t\t\t\t\t\t_php_iconv_appendc(pretval, '=', cd_pl);\n\t\t\t\t\t\t_php_iconv_appendc(pretval, '?', cd_pl);\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, csname, (size_t)((p1 + 1) - csname), cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcsname = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (scan_stat != 2) {\n\t\t\t\t\tchar tmpbuf[80];\n\n\t\t\t\t\tif (csname == NULL) {\n\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tcsname_len = (size_t)(p1 - csname);\n\n\t\t\t\t\tif (csname_len > sizeof(tmpbuf) - 1) {\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmemcpy(tmpbuf, csname, csname_len);\n\t\t\t\t\ttmpbuf[csname_len] = '\\0';\n\n\t\t\t\t\tif (cd != (iconv_t)(-1)) {\n\t\t\t\t\t\ticonv_close(cd);\n\t\t\t\t\t}\n\n\t\t\t\t\tcd = iconv_open(enc, tmpbuf);\n\n\t\t\t\t\tif (cd == (iconv_t)(-1)) {\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\t/* Bad character set, but the user wants us to\n\t\t\t\t\t\t\t * press on. In this case, we'll just insert the\n\t\t\t\t\t\t\t * undecoded encoded word, since there isn't really\n\t\t\t\t\t\t\t * a more sensible behaviour available; the only\n\t\t\t\t\t\t\t * other options are to swallow the encoded word\n\t\t\t\t\t\t\t * entirely or decode it with an arbitrarily chosen\n\t\t\t\t\t\t\t * single byte encoding, both of which seem to have\n\t\t\t\t\t\t\t * a higher WTF factor than leaving it undecoded.\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t * Given this approach, we need to skip ahead to\n\t\t\t\t\t\t\t * the end of the encoded word. */\n\t\t\t\t\t\t\tint qmarks = 2;\n\t\t\t\t\t\t\twhile (qmarks > 0 && str_left > 1) {\n\t\t\t\t\t\t\t\tif (*(++p1) == '?') {\n\t\t\t\t\t\t\t\t\t--qmarks;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t--str_left;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Look ahead to check for the terminating = that\n\t\t\t\t\t\t\t * should be there as well; if it's there, we'll\n\t\t\t\t\t\t\t * also include that. If it's not, there isn't much\n\t\t\t\t\t\t\t * we can do at this point. */\n\t\t\t\t\t\t\tif (*(p1 + 1) == '=') {\n\t\t\t\t\t\t\t\t++p1;\n\t\t\t\t\t\t\t\t--str_left;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Let's go back and see if there are further\n\t\t\t\t\t\t\t * encoded words or bare content, and hope they\n\t\t\t\t\t\t\t * might actually have a valid character set. */\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n#if ICONV_SUPPORTS_ERRNO\n\t\t\t\t\t\t\tif (errno == EINVAL) {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_WRONG_CHARSET;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_CONVERTER;\n\t\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\t\terr = PHP_ICONV_ERR_UNKNOWN;\n#endif\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 3: /* expecting a encoding scheme specifier */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\tenc_scheme = PHP_ICONV_ENC_SCHEME_BASE64;\n\t\t\t\t\t\tscan_stat = 4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tenc_scheme = PHP_ICONV_ENC_SCHEME_QPRINT;\n\t\t\t\t\t\tscan_stat = 4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 4: /* expecting a delimiter */\n\t\t\t\tif (*p1 != '?') {\n\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tencoded_text = p1 + 1;\n\t\t\t\tscan_stat = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 5: /* expecting an encoded portion */\n\t\t\t\tif (*p1 == '?') {\n\t\t\t\t\tencoded_text_len = (size_t)(p1 - encoded_text);\n\t\t\t\t\tscan_stat = 6;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 7: /* expecting a \""\\n\"" character */\n\t\t\t\tif (*p1 == '\\n') {\n\t\t\t\t\tscan_stat = 8;\n\t\t\t\t} else {\n\t\t\t\t\t/* bare CR */\n\t\t\t\t\t_php_iconv_appendc(pretval, '\\r', cd_pl);\n\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\tscan_stat = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 8: /* checking whether the following line is part of a\n\t\t\t\t\t   folded header */\n\t\t\t\tif (*p1 != ' ' && *p1 != '\\t') {\n\t\t\t\t\t--p1;\n\t\t\t\t\tstr_left = 1; /* quit_loop */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (encoded_word == NULL) {\n\t\t\t\t\t_php_iconv_appendc(pretval, ' ', cd_pl);\n\t\t\t\t}\n\t\t\t\tspaces = NULL;\n\t\t\t\tscan_stat = 11;\n\t\t\t\tbreak;\n\n\t\t\tcase 6: /* expecting a End-Of-Chunk character \""=\"" */\n\t\t\t\tif (*p1 != '=') {\n\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tscan_stat = 9;\n\t\t\t\tif (str_left == 1) {\n\t\t\t\t\teos = 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase 9: /* choice point, seeing what to do next.*/\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Handle non-RFC-compliant formats\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * RFC2047 requires the character that comes right\n\t\t\t\t\t\t * after an encoded word (chunk) to be a whitespace,\n\t\t\t\t\t\t * while there are lots of broken implementations that\n\t\t\t\t\t\t * generate such malformed headers that don't fulfill\n\t\t\t\t\t\t * that requirement.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!eos) {\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* break is omitted intentionally */\n\n\t\t\t\t\tcase '\\r': case '\\n': case ' ': case '\\t': {\n\t\t\t\t\t\tzend_string *decoded_text;\n\n\t\t\t\t\t\tswitch (enc_scheme) {\n\t\t\t\t\t\t\tcase PHP_ICONV_ENC_SCHEME_BASE64:\n\t\t\t\t\t\t\t\tdecoded_text = php_base64_decode((unsigned char*)encoded_text, encoded_text_len);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PHP_ICONV_ENC_SCHEME_QPRINT:\n\t\t\t\t\t\t\t\tdecoded_text = php_quot_print_decode((unsigned char*)encoded_text, encoded_text_len, 1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tdecoded_text = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (decoded_text == NULL) {\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n\t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_UNKNOWN;\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terr = _php_iconv_appendl(pretval, ZSTR_VAL(decoded_text), ZSTR_LEN(decoded_text), cd);\n\t\t\t\t\t\tzend_string_release_ex(decoded_text, 0);\n\n\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\t\t\t\t\t/* pass the entire chunk through the converter */\n\t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)(p1 - encoded_word), cd_pl);\n\t\t\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (eos) { /* reached end-of-string. done. */\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch (*p1) {\n\t\t\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase ' ': case '\\t': /* medial whitespaces */\n\t\t\t\t\t\t\t\tspaces = p1;\n\t\t\t\t\t\t\t\tscan_stat = 11;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault: /* first letter of a non-encoded word */\n\t\t\t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 10: /* expects a language specifier. dismiss it for now */\n\t\t\t\tif (*p1 == '?') {\n\t\t\t\t\tscan_stat = 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 11: /* expecting a chunk of whitespaces */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\tif (spaces != NULL && encoded_word == NULL) {\n\t\t\t\t\t\t\t_php_iconv_appendl(pretval, spaces, (size_t)(p1 - spaces), cd_pl);\n\t\t\t\t\t\t\tspaces = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencoded_word = p1;\n\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ' ': case '\\t':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: /* first letter of a non-encoded word */\n\t\t\t\t\t\tif (spaces != NULL) {\n\t\t\t\t\t\t\t_php_iconv_appendl(pretval, spaces, (size_t)(p1 - spaces), cd_pl);\n\t\t\t\t\t\t\tspaces = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\tencoded_word = NULL;\n\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tscan_stat = 12;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscan_stat = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 12: /* expecting a non-encoded word */\n\t\t\t\tswitch (*p1) {\n\t\t\t\t\tcase '\\r': /* part of an EOL sequence? */\n\t\t\t\t\t\tscan_stat = 7;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tscan_stat = 8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ' ': case '\\t':\n\t\t\t\t\t\tspaces = p1;\n\t\t\t\t\t\tscan_stat = 11;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '=': /* first letter of an encoded chunk */\n\t\t\t\t\t\tif (!(mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n\t\t\t\t\t\t\tencoded_word = p1;\n\t\t\t\t\t\t\tscan_stat = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* break is omitted intentionally */\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (scan_stat) {\n\t\tcase 0: case 8: case 11: case 12:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n\t\t\t\tif (scan_stat == 1) {\n\t\t\t\t\t_php_iconv_appendc(pretval, '=', cd_pl);\n\t\t\t\t}\n\t\t\t\terr = PHP_ICONV_ERR_SUCCESS;\n\t\t\t} else {\n\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\n\n\tif (next_pos != NULL) {\n\t\t*next_pos = p1;\n\t}\n\n\tsmart_str_0(pretval);\nout:\n\tif (cd != (iconv_t)(-1)) {\n\t\ticonv_close(cd);\n\t}\n\tif (cd_pl != (iconv_t)(-1)) {\n\t\ticonv_close(cd_pl);\n\t}\n\treturn err;\n}\n/* }}} */\n""}]","Out-of-bounds read in `_php_iconv_mime_decode()` (ext/iconv/iconv.c:1664) due to integer underflow in `str_left` (size_t). When parsing MIME headers, the code decrements `str_left` without bounds checks in the `if (*(p1 + 1) == '=')` block (line 1664). Since `str_left` is unsigned, decrementing it from 0 causes underflow (wrapping to `SIZE_MAX`), invalidating the length calculation `(p1 + 1) - encoded_word` in `_php_iconv_appendl()`, which reads beyond the input buffer. The patch adds `if (str_left > 1)` to prevent underflow.",0.95,./github/other_context/CVE-2019-11039
22,CVE-2020-14147,"CWE-190, CWE-787",c_cpp,"An integer overflow in the getnum function in lua_struct.c in Redis before 6.0.3 allows context-dependent attackers with permission to run Lua code in a Redis session to cause a denial of service (memory corruption and application crash) or possibly bypass intended sandbox restrictions via a large number, which triggers a stack-based buffer overflow. NOTE: this issue exists because of a CVE-2015-8080 regression.",https://github.com/redis/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571,[FIX] revisit CVE-2015-8080 vulnerability,3,"[{""func_name"": ""getnum"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static int getnum (const char **fmt, int df) {\n  if (!isdigit(**fmt))  /* no number? */\n    return df;  /* return default value */\n  else {\n    int a = 0;\n    do {\n      a = a*10 + *((*fmt)++) - '0';\n    } while (isdigit(**fmt));\n    return a;\n  }\n}"", ""target"": 0}, {""func_name"": ""optsize"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \""integral size %d is larger than limit of %d\"",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}"", ""target"": 0}, {""func_name"": ""controloptions"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  /* ignore white spaces */\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \""alignment %d is not a power of 2\"", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \""invalid format option '%c'\"", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}"", ""target"": 0}]","[{""func_name"": ""getnum"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static int getnum (lua_State *L, const char **fmt, int df) {\n  if (!isdigit(**fmt))  /* no number? */\n    return df;  /* return default value */\n  else {\n    int a = 0;\n    do {\n      if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))\n        luaL_error(L, \""integral size overflow\"");\n      a = a*10 + *((*fmt)++) - '0';\n    } while (isdigit(**fmt));\n    return a;\n  }\n}""}, {""func_name"": ""optsize"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(L, fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(L, fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \""integral size %d is larger than limit of %d\"",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}""}, {""func_name"": ""controloptions"", ""file_path"": ""deps/lua/src/lua_struct.c"", ""func_code"": ""static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  /* ignore white spaces */\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(L, fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \""alignment %d is not a power of 2\"", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \""invalid format option '%c'\"", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}""}]","{""caller"": 1}","[{""source"": ""caller_info(file:lua_struct.c, func:getnum)"", ""result"": [{""call_line"": 118, ""call_code"": ""getnum(fmt, 1)"", ""caller_code"": ""static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \""integral size %d is larger than limit of %d\"",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}"", ""caller_start"": 109, ""file_path"": ""deps/lua/src/lua_struct.c""}, {""call_line"": 120, ""call_code"": ""getnum(fmt, sizeof(int))"", ""caller_code"": ""static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \""integral size %d is larger than limit of %d\"",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}"", ""caller_start"": 109, ""file_path"": ""deps/lua/src/lua_struct.c""}, {""call_line"": 153, ""call_code"": ""getnum(fmt, MAXALIGN)"", ""caller_code"": ""static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  /* ignore white spaces */\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \""alignment %d is not a power of 2\"", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \""invalid format option '%c'\"", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}"", ""caller_start"": 146, ""file_path"": ""deps/lua/src/lua_struct.c""}]}]","Integer overflow in `getnum` (deps/lua/src/lua_struct.c:93-105) occurs when accumulating digits without overflow checks. The vulnerable code: `a = a*10 + *((*fmt)++) - '0';` allows values exceeding INT_MAX to wrap around, causing memory corruption. The patch adds checks before arithmetic: `if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))`. Callers `optsize` (line 118, 120) and `controloptions` (line 153) in `lua_struct.c` pass user-controlled format strings to `getnum`, enabling exploitation via crafted Lua scripts.",0.95,./github/other_context/CVE-2020-14147
23,CVE-2020-15350,"CWE-119, CWE-131",c_cpp,"RIOT 2020.04 has a buffer overflow in the base64 decoder. The decoding function base64_decode() uses an output buffer estimation function to compute the required buffer capacity and validate against the provided buffer size. The base64_estimate_decode_size() function calculates the expected decoded size with an arithmetic round-off error and does not take into account possible padding bytes. Due to this underestimation, it may be possible to craft base64 input that causes a buffer overflow.",https://github.com/RIOT-OS/RIOT/commit/f8ac003bbfe11956578dd2189827686c27374d06,base64: Fixed decode buffer size estimation\n\nFixed required result buffer size underestimation in base64_estimate_decode_size() function.,7,"[{""func_name"": ""base64_estimate_decode_size"", ""file_path"": ""sys/include/base64.h"", ""func_code"": ""static inline size_t base64_estimate_decode_size(size_t base64_in_size)\n{\n    return ((base64_in_size / 4) * 3);\n}"", ""target"": 0}, {""func_name"": ""base64_encode"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""int base64_encode(const void *data_in, size_t data_in_size,\n                  unsigned char *base64_out, size_t *base64_out_size)\n{\n    return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, false);\n}"", ""target"": 0}, {""func_name"": ""base64_encode_base"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""static int base64_encode_base(const void *data_in, size_t data_in_size,\n                              unsigned char *base64_out, size_t *base64_out_size,\n                              bool urlsafe)\n{\n    const unsigned char *in = data_in;\n    size_t required_size = base64_estimate_encode_size(data_in_size);\n\n    if (data_in == NULL) {\n        return BASE64_ERROR_DATA_IN;\n    }\n\n    if (data_in_size == 0) {\n        *base64_out_size = 0;\n        return BASE64_SUCCESS;\n    }\n\n    if (*base64_out_size < required_size) {\n        *base64_out_size = required_size;\n        return BASE64_ERROR_BUFFER_OUT_SIZE;\n    }\n\n    if (base64_out == NULL) {\n        return BASE64_ERROR_BUFFER_OUT;\n    }\n\n    int iterate_base64_buffer = 0;\n    unsigned char nNum = 0;\n    int nLst = 0;\n    int njump = 0;\n\n    for (int i = 0; i < (int)(data_in_size); ++i) {\n        unsigned char tmpval;\n        njump++;\n        tmpval = *(in + i);\n\n        nNum = (tmpval >> (2 * njump));\n\n        if (njump == 4) {\n            nNum = nLst << (8 - 2 * njump);\n            njump = 0;\n            nLst = 0;\n            --i;\n        }\n        else {\n            nNum += nLst << (8 - 2 * njump);\n            nLst =  tmpval & ((1 << njump * 2) - 1);\n        }\n\n        base64_out[iterate_base64_buffer++] = getsymbol(nNum, urlsafe);\n    }\n\n    /* The last character is not finished yet */\n    njump++;\n\n    nNum = nLst << (8 - 2 * njump);\n    base64_out[iterate_base64_buffer++] = getsymbol(nNum, urlsafe);\n\n    /* if required we append '=' for the required dividability */\n    while (iterate_base64_buffer % 4) {\n        base64_out[iterate_base64_buffer++] = '=';\n    }\n\n    *base64_out_size = iterate_base64_buffer;\n\n    return BASE64_SUCCESS;\n}"", ""target"": 1}, {""func_name"": ""base64_decode"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""int base64_decode(const unsigned char *base64_in, size_t base64_in_size,\n                  void *data_out, size_t *data_out_size)\n{\n    unsigned char *out = data_out;\n    size_t required_size = base64_estimate_decode_size(base64_in_size);\n\n    if (base64_in == NULL) {\n        return BASE64_ERROR_DATA_IN;\n    }\n\n    if (base64_in_size == 0) {\n        *data_out_size = 0;\n        return BASE64_SUCCESS;\n    }\n\n    if (base64_in_size < 4) {\n        return BASE64_ERROR_DATA_IN_SIZE;\n    }\n\n    if (*data_out_size < required_size) {\n        *data_out_size = required_size;\n        return BASE64_ERROR_BUFFER_OUT_SIZE;\n    }\n\n    if (data_out == NULL) {\n        return BASE64_ERROR_BUFFER_OUT;\n    }\n\n    int iterate_data_buffer = 0;\n    unsigned char nNum = 0;\n    int nLst = getcode(base64_in[0]) << 2;\n    int code = 0;\n\n    int mask = 2;\n\n    for (int i = 1; i < (int)(base64_in_size); i++) {\n        code = getcode(base64_in[i]);\n\n        if (code == BASE64_NOT_DEFINED || code == BASE64_EQUALS) {\n            continue;\n        }\n\n        int nm = (0xFF << (2 * mask));\n\n        nNum = nLst + ((code & (0xFF & nm)) >> (2 * mask));\n        nLst = (code & (0xFF & ~nm)) << (8 - (2 * mask));\n\n        (mask != 3) ? out[iterate_data_buffer++] = nNum : nNum;\n        (mask == 0) ? mask = 3 : mask--;\n    }\n\n    if (code == BASE64_EQUALS) {\n        /* add the last character to the data_out buffer */\n        out[iterate_data_buffer] = nNum;\n    }\n\n    *data_out_size = iterate_data_buffer;\n    return BASE64_SUCCESS;\n}"", ""target"": 1}, {""func_name"": ""getcode"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""static int getcode(char symbol)\n{\n    if (symbol == '/') {\n        return BASE64_SLASH;\n    }\n\n    if (symbol == '_') {\n        return BASE64_UNDERLINE;\n    }\n\n    if (symbol == '+') {\n        return BASE64_PLUS;\n    }\n\n    if (symbol == '-') {\n        return BASE64_MINUS;\n    }\n\n    if (symbol == '=') {\n        /* indicates a padded base64 end */\n        return BASE64_EQUALS;\n    }\n\n    if (symbol < '0') {\n        /* indicates that the given symbol is not base64 and should be ignored */\n        return BASE64_NOT_DEFINED;\n    }\n\n    if (symbol <= '9' && symbol >= '0') {\n        return (symbol + (BASE64_NUMBER_UPPER_BOUND - '9'));\n    }\n\n    if (symbol <= 'Z' && symbol >= 'A') {\n        return (symbol - 'A');\n    }\n\n    if (symbol <= 'z' && symbol >= 'a') {\n        return (symbol + (BASE64_SMALL_UPPER_BOUND - 'z'));\n    }\n\n    /* indicates that the given symbol is not base64 and should be ignored */\n    return BASE64_NOT_DEFINED;\n}"", ""target"": 0}, {""func_name"": ""base64url_encode"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""int base64url_encode(const void *data_in, size_t data_in_size,\n                     unsigned char *base64_out, size_t *base64_out_size)\n{\n    return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, true);\n}"", ""target"": 1}, {""func_name"": ""getsymbol"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""static char getsymbol(unsigned char code, bool urlsafe)\n{\n    if (!IS_ACTIVE(MODULE_BASE64URL)) {\n        urlsafe = false;\n    }\n\n    if (urlsafe && code == BASE64_UNDERLINE) {\n        return '_';\n    }\n\n    if (urlsafe && code == BASE64_MINUS) {\n        return '-';\n    }\n\n    if (!urlsafe && code == BASE64_SLASH) {\n        return '/';\n    }\n\n    if (!urlsafe && code == BASE64_PLUS) {\n        return '+';\n    }\n\n    if (code <= BASE64_CAPITAL_UPPER_BOUND) {\n        return (code + 'A');\n    }\n\n    if (code <= BASE64_SMALL_UPPER_BOUND) {\n        return (code + ('z' - BASE64_SMALL_UPPER_BOUND));\n    }\n\n    if (code <= BASE64_NUMBER_UPPER_BOUND) {\n        return (code + ('9' - BASE64_NUMBER_UPPER_BOUND));\n    }\n\n    return (char)BASE64_NOT_DEFINED;\n}"", ""target"": 0}]","[{""func_name"": ""base64_estimate_decode_size"", ""file_path"": ""sys/include/base64.h"", ""func_code"": ""static inline size_t base64_estimate_decode_size(size_t base64_in_size)\n{\n    return (((base64_in_size + 3) / 4) * 3);\n}""}, {""func_name"": ""base64_encode"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""int base64_encode(const void *data_in, size_t data_in_size,\n                  void *base64_out, size_t *base64_out_size)\n{\n    return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, false);\n}""}, {""func_name"": ""base64_encode_base"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""static int base64_encode_base(const void *data_in, size_t data_in_size,\n                              void *base64_out, size_t *base64_out_size,\n                              bool urlsafe)\n{\n    const uint8_t *in = data_in;\n    uint8_t *out = base64_out;\n    size_t required_size = base64_estimate_encode_size(data_in_size);\n\n    if (data_in == NULL) {\n        return BASE64_ERROR_DATA_IN;\n    }\n\n    if (data_in_size == 0) {\n        *base64_out_size = 0;\n        return BASE64_SUCCESS;\n    }\n\n    if (*base64_out_size < required_size) {\n        *base64_out_size = required_size;\n        return BASE64_ERROR_BUFFER_OUT_SIZE;\n    }\n\n    if (out == NULL) {\n        return BASE64_ERROR_BUFFER_OUT;\n    }\n\n    int iterate_base64_buffer = 0;\n    uint8_t n_num = 0;\n    int nLst = 0;\n    int njump = 0;\n\n    for (int i = 0; i < (int)(data_in_size); ++i) {\n        uint8_t tmpval;\n        njump++;\n        tmpval = *(in + i);\n\n        n_num = (tmpval >> (2 * njump));\n\n        if (njump == 4) {\n            n_num = nLst << (8 - 2 * njump);\n            njump = 0;\n            nLst = 0;\n            --i;\n        }\n        else {\n            n_num += nLst << (8 - 2 * njump);\n            nLst =  tmpval & ((1 << njump * 2) - 1);\n        }\n\n        out[iterate_base64_buffer++] = getsymbol(n_num, urlsafe);\n    }\n\n    /* The last character is not finished yet */\n    njump++;\n\n    n_num = nLst << (8 - 2 * njump);\n    out[iterate_base64_buffer++] = getsymbol(n_num, urlsafe);\n\n    /* if required we append '=' for the required dividability */\n    while (iterate_base64_buffer % 4) {\n        out[iterate_base64_buffer++] = '=';\n    }\n\n    *base64_out_size = iterate_base64_buffer;\n\n    return BASE64_SUCCESS;\n}""}, {""func_name"": ""base64_decode"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""int base64_decode(const void *base64_in, size_t base64_in_size,\n                  void *data_out, size_t *data_out_size)\n{\n    uint8_t *out = data_out;\n    const uint8_t *in = base64_in;\n    size_t required_size = base64_estimate_decode_size(base64_in_size);\n\n    if (in == NULL) {\n        return BASE64_ERROR_DATA_IN;\n    }\n\n    if (base64_in_size == 0) {\n        *data_out_size = 0;\n        return BASE64_SUCCESS;\n    }\n\n    if (base64_in_size < 4) {\n        return BASE64_ERROR_DATA_IN_SIZE;\n    }\n\n    if (*data_out_size < required_size) {\n        *data_out_size = required_size;\n        return BASE64_ERROR_BUFFER_OUT_SIZE;\n    }\n\n    if (data_out == NULL) {\n        return BASE64_ERROR_BUFFER_OUT;\n    }\n\n    int iterate_data_buffer = 0;\n    uint8_t n_num = 0;\n    int nLst = getcode(in[0]) << 2;\n    int code = 0;\n\n    int mask = 2;\n\n    for (int i = 1; i < (int)(base64_in_size); i++) {\n        code = getcode(in[i]);\n\n        if (code == BASE64_NOT_DEFINED || code == BASE64_EQUALS) {\n            continue;\n        }\n\n        int nm = (0xFF << (2 * mask));\n\n        n_num = nLst + ((code & (0xFF & nm)) >> (2 * mask));\n        nLst = (code & (0xFF & ~nm)) << (8 - (2 * mask));\n\n        (mask != 3) ? out[iterate_data_buffer++] = n_num : n_num;\n        (mask == 0) ? mask = 3 : mask--;\n    }\n\n    if (code == BASE64_EQUALS) {\n        /* add the last character to the data_out buffer */\n        out[iterate_data_buffer] = n_num;\n    }\n\n    *data_out_size = iterate_data_buffer;\n    return BASE64_SUCCESS;\n}""}, {""func_name"": ""getcode"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""static uint8_t getcode(char symbol)\n{\n    if (symbol == '/') {\n        return BASE64_SLASH;\n    }\n\n    if (symbol == '_') {\n        return BASE64_UNDERLINE;\n    }\n\n    if (symbol == '+') {\n        return BASE64_PLUS;\n    }\n\n    if (symbol == '-') {\n        return BASE64_MINUS;\n    }\n\n    if (symbol == '=') {\n        /* indicates a padded base64 end */\n        return BASE64_EQUALS;\n    }\n\n    if (symbol < '0') {\n        /* indicates that the given symbol is not base64 and should be ignored */\n        return BASE64_NOT_DEFINED;\n    }\n\n    if (symbol <= '9' && symbol >= '0') {\n        return (symbol + (BASE64_NUMBER_UPPER_BOUND - '9'));\n    }\n\n    if (symbol <= 'Z' && symbol >= 'A') {\n        return (symbol - 'A');\n    }\n\n    if (symbol <= 'z' && symbol >= 'a') {\n        return (symbol + (BASE64_SMALL_UPPER_BOUND - 'z'));\n    }\n\n    /* indicates that the given symbol is not base64 and should be ignored */\n    return BASE64_NOT_DEFINED;\n}""}, {""func_name"": ""base64url_encode"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""int base64url_encode(const void *data_in, size_t data_in_size,\n                     void *base64_out, size_t *base64_out_size)\n{\n    return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, true);\n}""}, {""func_name"": ""getsymbol"", ""file_path"": ""sys/base64/base64.c"", ""func_code"": ""static char getsymbol(uint8_t code, bool urlsafe)\n{\n    if (!IS_ACTIVE(MODULE_BASE64URL)) {\n        urlsafe = false;\n    }\n\n    if (urlsafe && code == BASE64_UNDERLINE) {\n        return '_';\n    }\n\n    if (urlsafe && code == BASE64_MINUS) {\n        return '-';\n    }\n\n    if (!urlsafe && code == BASE64_SLASH) {\n        return '/';\n    }\n\n    if (!urlsafe && code == BASE64_PLUS) {\n        return '+';\n    }\n\n    if (code <= BASE64_CAPITAL_UPPER_BOUND) {\n        return (code + 'A');\n    }\n\n    if (code <= BASE64_SMALL_UPPER_BOUND) {\n        return (code + ('z' - BASE64_SMALL_UPPER_BOUND));\n    }\n\n    if (code <= BASE64_NUMBER_UPPER_BOUND) {\n        return (code + ('9' - BASE64_NUMBER_UPPER_BOUND));\n    }\n\n    return (char)BASE64_NOT_DEFINED;\n}""}]","{""code"": 1, ""function"": 1}","[{""source"": ""code_info(file:base64.c, lines:1-50)"", ""result"": ""/*\n * Copyright (C) 2014 Hochschule f\u00fcr Angewandte Wissenschaften Hamburg (HAW)\n * Copyright (C) 2014 Martin Landsmann <Martin.Landsmann@HAW-Hamburg.de>\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @ingroup sys_base64\n * @{\n * @file\n * @brief   Functions to encode and decode base64\n *\n * @author  Martin Landsmann <Martin.Landsmann@HAW-Hamburg.de>\n * @}\n *\n */\n\n#include <stdbool.h>\n#include \""base64.h\""\n#include \""kernel_defines.h\""\n\n#define BASE64_CAPITAL_UPPER_BOUND     (25)     /**< base64 'Z'           */\n#define BASE64_SMALL_UPPER_BOUND       (51)     /**< base64 'z'           */\n#define BASE64_NUMBER_UPPER_BOUND      (61)     /**< base64 '9'           */\n#define BASE64_PLUS                    (62)     /**< base64 '+'           */\n#define BASE64_MINUS                   (62)     /**< base64 '-'           */\n#define BASE64_SLASH                   (63)     /**< base64 '/'           */\n#define BASE64_UNDERLINE               (63)     /**< base64 '_'           */\n#define BASE64_EQUALS                  (0xFE)   /**< no base64 symbol '=' */\n#define BASE64_NOT_DEFINED             (0xFF)   /**< no base64 symbol     */\n\n/*\n * returns the corresponding ascii symbol value for the given base64 code\n */\nstatic char getsymbol(unsigned char code, bool urlsafe)\n{\n    if (!IS_ACTIVE(MODULE_BASE64URL)) {\n        urlsafe = false;\n    }\n\n    if (urlsafe && code == BASE64_UNDERLINE) {\n        return '_';\n    }\n\n    if (urlsafe && code == BASE64_MINUS) {\n        return '-';\n    }\n\n""}, {""source"": ""func_info(file:base64.c, func:base64_decode)"", ""result"": [{""code"": ""int base64_decode(const unsigned char *base64_in, size_t base64_in_size,\n                  void *data_out, size_t *data_out_size)\n{\n    unsigned char *out = data_out;\n    size_t required_size = base64_estimate_decode_size(base64_in_size);\n\n    if (base64_in == NULL) {\n        return BASE64_ERROR_DATA_IN;\n    }\n\n    if (base64_in_size == 0) {\n        *data_out_size = 0;\n        return BASE64_SUCCESS;\n    }\n\n    if (base64_in_size < 4) {\n        return BASE64_ERROR_DATA_IN_SIZE;\n    }\n\n    if (*data_out_size < required_size) {\n        *data_out_size = required_size;\n        return BASE64_ERROR_BUFFER_OUT_SIZE;\n    }\n\n    if (data_out == NULL) {\n        return BASE64_ERROR_BUFFER_OUT;\n    }\n\n    int iterate_data_buffer = 0;\n    unsigned char nNum = 0;\n    int nLst = getcode(base64_in[0]) << 2;\n    int code = 0;\n\n    int mask = 2;\n\n    for (int i = 1; i < (int)(base64_in_size); i++) {\n        code = getcode(base64_in[i]);\n\n        if (code == BASE64_NOT_DEFINED || code == BASE64_EQUALS) {\n            continue;\n        }\n\n        int nm = (0xFF << (2 * mask));\n\n        nNum = nLst + ((code & (0xFF & nm)) >> (2 * mask));\n        nLst = (code & (0xFF & ~nm)) << (8 - (2 * mask));\n\n        (mask != 3) ? out[iterate_data_buffer++] = nNum : nNum;\n        (mask == 0) ? mask = 3 : mask--;\n    }\n\n    if (code == BASE64_EQUALS) {\n        /* add the last character to the data_out buffer */\n        out[iterate_data_buffer] = nNum;\n    }\n\n    *data_out_size = iterate_data_buffer;\n    return BASE64_SUCCESS;\n}\n"", ""start_line"": 203, ""end_line"": 261, ""full_name"": ""base64_decode<duplicate>0"", ""file_path"": ""sys/base64/base64.c""}]}]","sys/include/base64.h:43: Underestimated decoded size via truncated division (base64_in_size / 4 * 3), ignoring padding. Patch uses ((base64_in_size + 3) / 4 * 3) to round up. base64_decode() in sys/base64/base64.c:203-261 uses base64_estimate_decode_size() to compute required_size and validates against *data_out_size. If required_size is underestimated, the check (*data_out_size < required_size) fails to catch insufficient buffer size, leading to overflow during decoding.",0.95,./github/other_context/CVE-2020-15350
24,CVE-2020-20335,"CWE-787, CWE-190",c_cpp,Buffer Overflow vulnerability in Antirez Kilo before commit 7709a04ae8520c5b04d261616098cebf742f5a23 allows a remote attacker to cause a denial of service via the editorUpdateRow function in kilo.c.,https://github.com/antirez/kilo/commit/7709a04ae8520c5b04d261616098cebf742f5a23,Fix integer overflow in row allocation. #60.,1,"[{""func_name"": ""editorUpdateRow"", ""file_path"": ""kilo.c"", ""func_code"": ""void editorUpdateRow(erow *row) {\n    int tabs = 0, nonprint = 0, j, idx;\n\n   /* Create a version of the row we can directly print on the screen,\n     * respecting tabs, substituting non printable characters with '?'. */\n    free(row->render);\n    for (j = 0; j < row->size; j++)\n        if (row->chars[j] == TAB) tabs++;\n\n    row->render = malloc(row->size + tabs*8 + nonprint*9 + 1);\n    idx = 0;\n    for (j = 0; j < row->size; j++) {\n        if (row->chars[j] == TAB) {\n            row->render[idx++] = ' ';\n            while((idx+1) % 8 != 0) row->render[idx++] = ' ';\n        } else {\n            row->render[idx++] = row->chars[j];\n        }\n    }\n    row->rsize = idx;\n    row->render[idx] = '\\0';\n\n    /* Update the syntax highlighting attributes of the row. */\n    editorUpdateSyntax(row);\n}"", ""target"": 0}]","[{""func_name"": ""editorUpdateRow"", ""file_path"": ""kilo.c"", ""func_code"": ""void editorUpdateRow(erow *row) {\n    unsigned int tabs = 0, nonprint = 0;\n    int j, idx;\n\n   /* Create a version of the row we can directly print on the screen,\n     * respecting tabs, substituting non printable characters with '?'. */\n    free(row->render);\n    for (j = 0; j < row->size; j++)\n        if (row->chars[j] == TAB) tabs++;\n\n    unsigned long long allocsize =\n        (unsigned long long) row->size + tabs*8 + nonprint*9 + 1;\n    if (allocsize > UINT32_MAX) {\n        printf(\""Some line of the edited file is too long for kilo\\n\"");\n        exit(1);\n    }\n\n    row->render = malloc(row->size + tabs*8 + nonprint*9 + 1);\n    idx = 0;\n    for (j = 0; j < row->size; j++) {\n        if (row->chars[j] == TAB) {\n            row->render[idx++] = ' ';\n            while((idx+1) % 8 != 0) row->render[idx++] = ' ';\n        } else {\n            row->render[idx++] = row->chars[j];\n        }\n    }\n    row->rsize = idx;\n    row->render[idx] = '\\0';\n\n    /* Update the syntax highlighting attributes of the row. */\n    editorUpdateSyntax(row);\n}""}]","{""value"": 1}","[{""source"": ""value_info(file:kilo.c, value:row->size)"", ""result"": {""value_trace"": [{""full_code"": ""row->size += padlen+1"", ""line"": 661, ""func_name"": ""editorRowInsertChar""}, {""full_code"": ""row->size++"", ""line"": 667, ""func_name"": ""editorRowInsertChar""}, {""full_code"": ""row->size += len"", ""line"": 678, ""func_name"": ""editorRowAppendString""}, {""full_code"": ""row->size = filecol"", ""line"": 738, ""func_name"": ""editorInsertNewline""}], ""struct_var"": ""row"", ""struct_type"": ""erow*"", ""struct_definition"": ""typedef struct erow {\n    int idx;            /* Row index in the file, zero-based. */\n    int size;           /* Size of the row, excluding the null term. */\n    int rsize;          /* Size of the rendered row. */\n    char *chars;        /* Row content. */\n    char *render;       /* Row content \""rendered\"" for screen (for TABs). */\n    unsigned char *hl;  /* Syntax highlight type for each character in render.*/\n    int hl_oc;          /* Row had open comment at end in last syntax highlight\n                           check. */\n}\n\ntypedef struct erow {\n    int idx;            /* Row index in the file, zero-based. */\n    int size;           /* Size of the row, excluding the null term. */\n    int rsize;          /* Size of the rendered row. */\n    char *chars;        /* Row content. */\n    char *render;       /* Row content \""rendered\"" for screen (for TABs). */\n    unsigned char *hl;  /* Syntax highlight type for each character in render.*/\n    int hl_oc;          /* Row had open comment at end in last syntax highlight\n                           check. */\n} erow;""}}]","kilo.c:556-564: Integer overflow in allocation size calculation (row->size + tabs*8 + nonprint*9 + 1) due to signed integer arithmetic. row->size is declared as 'int' in struct erow (kilo.c:line in struct definition), and tabs/nonprint were originally signed (kilo.c:556). Overflow results in undersized buffer allocated via malloc(), leading to buffer overflow during render.",0.95,./github/other_context/CVE-2020-20335
25,CVE-2020-23903,CWE-369,c_cpp,A Divide by Zero vulnerability in the function static int read_samples of Speex v1.2 allows attackers to cause a denial of service (DoS) via a crafted WAV file.,https://github.com/xiph/speex/commit/870ff845b32f314aec0036641ffe18aba4916887,wav_io: guard against invalid channel numbers\n\nFixes #13,1,"[{""func_name"": ""read_wav_header"", ""file_path"": ""src/wav_io.c"", ""func_code"": ""int read_wav_header(FILE *file, int *rate, int *channels, int *format, spx_int32_t *size)\n{\n   char ch[5];\n   spx_int32_t itmp;\n   spx_int16_t stmp;\n   spx_int32_t bpersec;\n   spx_int16_t balign;\n   int skip_bytes;\n   int i;\n\n   ch[4]=0;\n#if 0\n   fread(ch, 1, 4, file);\n   if (strcmp(ch, \""RIFF\"")!=0)\n   {\n      fseek(file, 0, SEEK_SET);\n      return 0;\n   }\n\n   fread(&itmp, 4, 1, file);\n   *size = le_int(itmp-36);\n\n   fread(ch, 1, 4, file);\n   if (strcmp(ch, \""WAVE\"")!=0)\n   {\n      fprintf (stderr, \""RIFF file is not a WAVE file\\n\"");\n      return -1;\n   }\n#endif\n   fread(ch, 1, 4, file);\n   while (strcmp(ch, \""fmt \"")!=0)\n   {\n      fread(&itmp, 4, 1, file);\n      itmp = le_int(itmp);\n      /*fprintf (stderr, \""skip=%d\\n\"", itmp);*/\n      /*strange way of seeking, but it works even for pipes*/\n      for (i=0;i<itmp;i++) {\n        if (fgetc(file) == EOF) {\n          break;\n        }\n      }\n      /*fseek(file, itmp, SEEK_CUR);*/\n      fread(ch, 1, 4, file);\n      if (feof(file))\n      {\n         fprintf (stderr, \""Corrupted WAVE file: no \\\""fmt \\\""\\n\"");\n         return -1;\n      }\n   }\n   /*if (strcmp(ch, \""fmt \"")!=0)\n   {\n      fprintf (stderr, \""Corrupted WAVE file: no \\\""fmt \\\""\\n\"");\n      return -1;\n      }*/\n\n   fread(&itmp, 4, 1, file);\n   itmp = le_int(itmp);\n   skip_bytes=itmp-16;\n   /*fprintf (stderr, \""skip=%d\\n\"", skip_bytes);*/\n\n   fread(&stmp, 2, 1, file);\n   stmp = le_short(stmp);\n   if (stmp!=1)\n   {\n      fprintf (stderr, \""Only PCM encoding is supported\\n\"");\n      return -1;\n   }\n\n   fread(&stmp, 2, 1, file);\n   stmp = le_short(stmp);\n   *channels = stmp;\n\n   if (stmp>2)\n   {\n      fprintf (stderr, \""Only mono and (intensity) stereo supported\\n\"");\n      return -1;\n   }\n\n   fread(&itmp, 4, 1, file);\n   itmp = le_int(itmp);\n   *rate = itmp;\n   if (*rate != 8000 && *rate != 16000 && *rate != 11025 && *rate != 22050 && *rate != 32000 && *rate != 44100 && *rate != 48000)\n   {\n      fprintf (stderr, \""Only 8 kHz (narrowband) and 16 kHz (wideband) supported (plus 11.025 kHz and 22.05 kHz, but your mileage may vary)\\n\"");\n      return -1;\n   }\n\n   fread(&itmp, 4, 1, file);\n   bpersec = le_int(itmp);\n\n   fread(&stmp, 2, 1, file);\n   balign = le_short(stmp);\n\n   fread(&stmp, 2, 1, file);\n   stmp = le_short(stmp);\n   if (stmp!=16 && stmp!=8)\n   {\n      fprintf (stderr, \""Only 8/16-bit linear supported\\n\"");\n      return -1;\n   }\n   *format=stmp;\n\n   if (bpersec!=*rate**channels*stmp/8)\n   {\n      fprintf (stderr, \""Corrupted header: ByteRate mismatch\\n\"");\n      return -1;\n   }\n\n   if (balign!=*channels*stmp/8)\n   {\n      fprintf (stderr, \""Corrupted header: BlockAlign mismatch\\n\"");\n      return -1;\n   }\n\n\n   /*strange way of seeking, but it works even for pipes*/\n   if (skip_bytes>0) {\n      for (i=0;i<skip_bytes;i++) {\n        if (fgetc(file) == EOF) {\n          break;\n        }\n      }\n   }\n\n   /*fseek(file, skip_bytes, SEEK_CUR);*/\n\n   fread(ch, 1, 4, file);\n   while (strcmp(ch, \""data\"")!=0)\n   {\n      fread(&itmp, 4, 1, file);\n      itmp = le_int(itmp);\n      /*strange way of seeking, but it works even for pipes*/\n      for (i=0;i<itmp;i++) {\n        if (fgetc(file) == EOF) {\n          break;\n        }\n      }\n      /*fseek(file, itmp, SEEK_CUR);*/\n      fread(ch, 1, 4, file);\n      if (feof(file))\n      {\n         fprintf (stderr, \""Corrupted WAVE file: no \\\""data\\\""\\n\"");\n         return -1;\n      }\n   }\n\n   /*Ignore this for now*/\n   fread(&itmp, 4, 1, file);\n   itmp = le_int(itmp);\n\n   *size=itmp;\n\n   return 1;\n}"", ""target"": 0}]","[{""func_name"": ""read_wav_header"", ""file_path"": ""src/wav_io.c"", ""func_code"": ""int read_wav_header(FILE *file, int *rate, int *channels, int *format, spx_int32_t *size)\n{\n   char ch[5];\n   spx_int32_t itmp;\n   spx_int16_t stmp;\n   spx_int32_t bpersec;\n   spx_int16_t balign;\n   int skip_bytes;\n   int i;\n\n   ch[4]=0;\n#if 0\n   fread(ch, 1, 4, file);\n   if (strcmp(ch, \""RIFF\"")!=0)\n   {\n      fseek(file, 0, SEEK_SET);\n      return 0;\n   }\n\n   fread(&itmp, 4, 1, file);\n   *size = le_int(itmp-36);\n\n   fread(ch, 1, 4, file);\n   if (strcmp(ch, \""WAVE\"")!=0)\n   {\n      fprintf (stderr, \""RIFF file is not a WAVE file\\n\"");\n      return -1;\n   }\n#endif\n   fread(ch, 1, 4, file);\n   while (strcmp(ch, \""fmt \"")!=0)\n   {\n      fread(&itmp, 4, 1, file);\n      itmp = le_int(itmp);\n      /*fprintf (stderr, \""skip=%d\\n\"", itmp);*/\n      /*strange way of seeking, but it works even for pipes*/\n      for (i=0;i<itmp;i++) {\n        if (fgetc(file) == EOF) {\n          break;\n        }\n      }\n      /*fseek(file, itmp, SEEK_CUR);*/\n      fread(ch, 1, 4, file);\n      if (feof(file))\n      {\n         fprintf (stderr, \""Corrupted WAVE file: no \\\""fmt \\\""\\n\"");\n         return -1;\n      }\n   }\n   /*if (strcmp(ch, \""fmt \"")!=0)\n   {\n      fprintf (stderr, \""Corrupted WAVE file: no \\\""fmt \\\""\\n\"");\n      return -1;\n      }*/\n\n   fread(&itmp, 4, 1, file);\n   itmp = le_int(itmp);\n   skip_bytes=itmp-16;\n   /*fprintf (stderr, \""skip=%d\\n\"", skip_bytes);*/\n\n   fread(&stmp, 2, 1, file);\n   stmp = le_short(stmp);\n   if (stmp!=1)\n   {\n      fprintf (stderr, \""Only PCM encoding is supported\\n\"");\n      return -1;\n   }\n\n   fread(&stmp, 2, 1, file);\n   stmp = le_short(stmp);\n   *channels = stmp;\n\n   if (stmp>2 || stmp<1)\n   {\n      fprintf (stderr, \""Only mono and (intensity) stereo supported\\n\"");\n      return -1;\n   }\n\n   fread(&itmp, 4, 1, file);\n   itmp = le_int(itmp);\n   *rate = itmp;\n   if (*rate != 8000 && *rate != 16000 && *rate != 11025 && *rate != 22050 && *rate != 32000 && *rate != 44100 && *rate != 48000)\n   {\n      fprintf (stderr, \""Only 8 kHz (narrowband) and 16 kHz (wideband) supported (plus 11.025 kHz and 22.05 kHz, but your mileage may vary)\\n\"");\n      return -1;\n   }\n\n   fread(&itmp, 4, 1, file);\n   bpersec = le_int(itmp);\n\n   fread(&stmp, 2, 1, file);\n   balign = le_short(stmp);\n\n   fread(&stmp, 2, 1, file);\n   stmp = le_short(stmp);\n   if (stmp!=16 && stmp!=8)\n   {\n      fprintf (stderr, \""Only 8/16-bit linear supported\\n\"");\n      return -1;\n   }\n   *format=stmp;\n\n   if (bpersec!=*rate**channels*stmp/8)\n   {\n      fprintf (stderr, \""Corrupted header: ByteRate mismatch\\n\"");\n      return -1;\n   }\n\n   if (balign!=*channels*stmp/8)\n   {\n      fprintf (stderr, \""Corrupted header: BlockAlign mismatch\\n\"");\n      return -1;\n   }\n\n\n   /*strange way of seeking, but it works even for pipes*/\n   if (skip_bytes>0) {\n      for (i=0;i<skip_bytes;i++) {\n        if (fgetc(file) == EOF) {\n          break;\n        }\n      }\n   }\n\n   /*fseek(file, skip_bytes, SEEK_CUR);*/\n\n   fread(ch, 1, 4, file);\n   while (strcmp(ch, \""data\"")!=0)\n   {\n      fread(&itmp, 4, 1, file);\n      itmp = le_int(itmp);\n      /*strange way of seeking, but it works even for pipes*/\n      for (i=0;i<itmp;i++) {\n        if (fgetc(file) == EOF) {\n          break;\n        }\n      }\n      /*fseek(file, itmp, SEEK_CUR);*/\n      fread(ch, 1, 4, file);\n      if (feof(file))\n      {\n         fprintf (stderr, \""Corrupted WAVE file: no \\\""data\\\""\\n\"");\n         return -1;\n      }\n   }\n\n   /*Ignore this for now*/\n   fread(&itmp, 4, 1, file);\n   itmp = le_int(itmp);\n\n   *size=itmp;\n\n   return 1;\n}""}]","{""function"": 1, ""value"": 1}","[{""source"": ""func_info(func:read_samples)"", ""result"": [{""code"": ""static int read_samples(FILE *fin,int frame_size, int bits, int channels, int lsb, short * input, char *buff, spx_int32_t *size)\n{\n   unsigned char in[MAX_FRAME_BYTES*2];\n   int i;\n   short *s;\n   int nb_read;\n   size_t to_read;\n\n   if (size && *size<=0)\n   {\n      return 0;\n   }\n\n   to_read = bits/8*channels*frame_size;\n\n   /*Read input audio*/\n   if (size)\n   {\n      if (*size >= to_read)\n      {\n         *size -= to_read;\n      }\n      else\n      {\n         to_read = *size;\n         *size = 0;\n      }\n   }\n\n   if (buff)\n   {\n      for (i=0;i<12;i++)\n         in[i]=buff[i];\n      nb_read = fread(in+12,1,to_read-12,fin) + 12;\n      if (size)\n         *size += 12;\n   } else {\n      nb_read = fread(in,1,to_read,fin);\n   }\n\n   nb_read /= bits/8*channels;\n\n   /*fprintf (stderr, \""%d\\n\"", nb_read);*/\n   if (nb_read==0)\n      return 0;\n\n   s=(short*)in;\n   if(bits==8)\n   {\n      /* Convert 8->16 bits */\n      for(i=frame_size*channels-1;i>=0;i--)\n      {\n         s[i]=(in[i]<<8)^0x8000;\n      }\n   } else\n   {\n      /* convert to our endian format */\n      for(i=0;i<frame_size*channels;i++)\n      {\n         if(lsb)\n            s[i]=le_short(s[i]);\n         else\n            s[i]=be_short(s[i]);\n      }\n   }\n\n   /* FIXME: This is probably redundent now */\n   /* copy to float input buffer */\n   for (i=0;i<frame_size*channels;i++)\n   {\n      input[i]=(short)s[i];\n   }\n\n   for (i=nb_read*channels;i<frame_size*channels;i++)\n   {\n      input[i]=0;\n   }\n\n\n   return nb_read;\n}\n"", ""start_line"": 86, ""end_line"": 166, ""full_name"": ""read_samples"", ""file_path"": ""src/speexenc.c""}]}, {""source"": ""value_info(file:wav_io.c, value:stmp)"", ""result"": {""value_trace"": [{""full_code"": ""stmp = le_short(stmp)"", ""line"": 103, ""func_name"": ""read_wav_header""}, {""full_code"": ""stmp = le_short(stmp)"", ""line"": 111, ""func_name"": ""read_wav_header""}, {""full_code"": ""stmp = le_short(stmp)"", ""line"": 136, ""func_name"": ""read_wav_header""}, {""full_code"": ""stmp = le_short(1)"", ""line"": 214, ""func_name"": ""write_wav_header""}, {""full_code"": ""stmp = le_short(channels)"", ""line"": 217, ""func_name"": ""write_wav_header""}], ""struct_var"": ""stmp"", ""struct_type"": ""spx_int16_t"", ""struct_definition"": ""typedef _G_int16_t spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef __int16 spx_int16_t;\n\ntypedef SInt16 spx_int16_t;\n\ntypedef int16_t spx_int16_t;\n\ntypedef int16_t spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef signed short spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef _G_int16_t spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef __int16 spx_int16_t;\n\ntypedef SInt16 spx_int16_t;\n\ntypedef int16_t spx_int16_t;\n\ntypedef int16_t spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef signed short spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef short spx_int16_t;\n\ntypedef Int16\t\t\tspx_int16_t;\n\ntypedef Int16\t\t\tspx_int16_t;""}}]",read_wav_header (src/wav_io.c:112): *channels = stmp; (no lower bound check in original code) read_samples (src/speexenc.c:130): nb_read /= bits/8*channels; (division using channels value) Original code allowed stmp=0 (invalid channel count)  channels=0  division by zero in nb_read /= ... Patch added check if (stmp>2 || stmp<1) to reject invalid values before assignment to *channels,0.95,./github/other_context/CVE-2020-23903
26,CVE-2020-24370,CWE-191,c_cpp,"ldebug.c in Lua 5.4.0 allows a negation overflow and segmentation fault in getlocal and setlocal, as demonstrated by getlocal(3,2^31).",https://github.com/lua/lua/commit/a585eae6e7ada1ca9271607a4f48dfb17868ab7b,Fixed bug: Negation overflow in getlocal/setlocal,2,"[{""func_name"": ""luaG_findlocal"", ""file_path"": ""ldebug.c"", ""func_code"": ""const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \""(temporary)\"" : \""(C temporary)\"";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}"", ""target"": 1}, {""func_name"": ""findvararg"", ""file_path"": ""ldebug.c"", ""func_code"": ""static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \""(vararg)\"";  /* generic name for any vararg */\n    }\n  }\n  return NULL;  /* no such vararg */\n}"", ""target"": 0}]","[{""func_name"": ""luaG_findlocal"", ""file_path"": ""ldebug.c"", ""func_code"": ""const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \""(temporary)\"" : \""(C temporary)\"";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}""}, {""func_name"": ""findvararg"", ""file_path"": ""ldebug.c"", ""func_code"": ""static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n >= -nextra) {  /* 'n' is negative */\n      *pos = ci->func - nextra - (n + 1);\n      return \""(vararg)\"";  /* generic name for any vararg */\n    }\n  }\n  return NULL;  /* no such vararg */\n}""}]","{""caller"": 2, ""function"": 2, ""value"": 2}","[{""source"": ""caller_info(file:ldebug.c, func:findvararg)"", ""result"": [{""call_line"": 205, ""call_code"": ""findvararg(ci, -n, pos)"", ""caller_code"": ""const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \""(temporary)\"" : \""(C temporary)\"";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}"", ""caller_start"": 200, ""file_path"": ""ldebug.c""}]}, {""source"": ""caller_info(file:ldebug.c, func:luaG_findlocal)"", ""result"": [{""call_line"": 235, ""call_code"": ""luaG_findlocal(L, ar->i_ci, n, &pos)"", ""caller_code"": ""LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {\n  const char *name;\n  lua_lock(L);\n  if (ar == NULL) {  /* information about non-active function? */\n    if (!isLfunction(s2v(L->top - 1)))  /* not a Lua function? */\n      name = NULL;\n    else  /* consider live variables at function start (parameters) */\n      name = luaF_getlocalname(clLvalue(s2v(L->top - 1))->p, n, 0);\n  }\n  else {  /* active function; get information through 'ar' */\n    StkId pos = NULL;  /* to avoid warnings */\n    name = luaG_findlocal(L, ar->i_ci, n, &pos);\n    if (name) {\n      setobjs2s(L, L->top, pos);\n      api_incr_top(L);\n    }\n  }\n  lua_unlock(L);\n  return name;\n}"", ""caller_start"": 224, ""file_path"": ""ldebug.c""}, {""call_line"": 250, ""call_code"": ""luaG_findlocal(L, ar->i_ci, n, &pos)"", ""caller_code"": ""LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n  StkId pos = NULL;  /* to avoid warnings */\n  const char *name;\n  lua_lock(L);\n  name = luaG_findlocal(L, ar->i_ci, n, &pos);\n  if (name) {\n    setobjs2s(L, pos, L->top - 1);\n    L->top--;  /* pop value */\n  }\n  lua_unlock(L);\n  return name;\n}"", ""caller_start"": 246, ""file_path"": ""ldebug.c""}, {""call_line"": 132, ""call_code"": ""luaG_findlocal(L, L->ci, idx, NULL)"", ""caller_code"": ""static void varerror (lua_State *L, StkId level, const char *msg) {\n  int idx = cast_int(level - L->ci->func);\n  const char *vname = luaG_findlocal(L, L->ci, idx, NULL);\n  if (vname == NULL) vname = \""?\"";\n  luaG_runerror(L, msg, vname);\n}"", ""caller_start"": 130, ""file_path"": ""lfunc.c""}]}, {""source"": ""func_info(func:lua_getlocal)"", ""result"": [{""code"": ""LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {\n  const char *name;\n  lua_lock(L);\n  if (ar == NULL) {  /* information about non-active function? */\n    if (!isLfunction(s2v(L->top - 1)))  /* not a Lua function? */\n      name = NULL;\n    else  /* consider live variables at function start (parameters) */\n      name = luaF_getlocalname(clLvalue(s2v(L->top - 1))->p, n, 0);\n  }\n  else {  /* active function; get information through 'ar' */\n    StkId pos = NULL;  /* to avoid warnings */\n    name = luaG_findlocal(L, ar->i_ci, n, &pos);\n    if (name) {\n      setobjs2s(L, L->top, pos);\n      api_incr_top(L);\n    }\n  }\n  lua_unlock(L);\n  return name;\n}"", ""start_line"": 224, ""end_line"": 243, ""full_name"": ""lua_getlocal"", ""file_path"": ""ldebug.c""}, {""code"": ""extern const char extern const char * ()(lua_State *, const lua_Debug *, int);"", ""start_line"": 453, ""end_line"": 453, ""full_name"": ""<unresolvedNamespace>.lua_getlocal"", ""file_path"": ""lua.h""}]}, {""source"": ""func_info(func:lua_setlocal)"", ""result"": [{""code"": ""LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n  StkId pos = NULL;  /* to avoid warnings */\n  const char *name;\n  lua_lock(L);\n  name = luaG_findlocal(L, ar->i_ci, n, &pos);\n  if (name) {\n    setobjs2s(L, pos, L->top - 1);\n    L->top--;  /* pop value */\n  }\n  lua_unlock(L);\n  return name;\n}"", ""start_line"": 246, ""end_line"": 257, ""full_name"": ""lua_setlocal"", ""file_path"": ""ldebug.c""}, {""code"": ""extern const char extern const char * ()(lua_State *, const lua_Debug *, int);"", ""start_line"": 454, ""end_line"": 454, ""full_name"": ""<unresolvedNamespace>.lua_setlocal"", ""file_path"": ""lua.h""}]}, {""source"": ""value_info(file:lua_getlocal, value:n)"", ""result"": {""value_trace"": [{""full_code"": ""n = 0"", ""line"": 356, ""func_name"": ""lua_tonumberx""}, {""full_code"": ""n = last - level - LEVELS2 + 1"", ""line"": 145, ""func_name"": ""luaL_traceback""}, {""full_code"": ""n = lua_gettop(L)"", ""line"": 25, ""func_name"": ""luaB_print""}, {""full_code"": ""n = lua_gettop(L)"", ""line"": 46, ""func_name"": ""luaB_warn""}, {""full_code"": ""n = 0"", ""line"": 61, ""func_name"": ""b_str2int""}], ""struct_var"": ""n"", ""struct_type"": ""lua_Number"", ""struct_definition"": ""typedef LUA_NUMBER lua_Number;""}}, {""source"": ""value_info(file:lua_setlocal, value:n)"", ""result"": {""value_trace"": [{""full_code"": ""n = 0"", ""line"": 356, ""func_name"": ""lua_tonumberx""}, {""full_code"": ""n = last - level - LEVELS2 + 1"", ""line"": 145, ""func_name"": ""luaL_traceback""}, {""full_code"": ""n = lua_gettop(L)"", ""line"": 25, ""func_name"": ""luaB_print""}, {""full_code"": ""n = lua_gettop(L)"", ""line"": 46, ""func_name"": ""luaB_warn""}, {""full_code"": ""n = 0"", ""line"": 61, ""func_name"": ""b_str2int""}], ""struct_var"": ""n"", ""struct_type"": ""lua_Number"", ""struct_definition"": ""typedef LUA_NUMBER lua_Number;""}}]","ldebug.c:189-193: The original `n <= nextra` condition in `findvararg` failed to reject large negative `n` values (e.g., -2^31). When `n` was passed as a large negative via `luaG_findlocal` (called by `lua_getlocal`/`lua_setlocal`, ldebug.c:235/250), the negation `-n` overflowed in 32-bit signed integers (e.g., -2^31  2^31), corrupting `*pos = ci->func - nextra + (n - 1)`. The patch enforces `n >= -nextra` and adjusts the formula to avoid overflow. Attack vector: User-provided `n` in `lua_getlocal`/`lua_setlocal` (ldebug.c:224/246) bypasses validation, triggering the overflow.",0.95,./github/other_context/CVE-2020-24370
27,CVE-2020-8443,"CWE-787, CWE-193",c_cpp,"In OSSEC-HIDS 2.7 through 3.5.0, the server component responsible for log analysis (ossec-analysisd) is vulnerable to an off-by-one heap-based buffer overflow during the cleaning of crafted syslog msgs (received from authenticated remote agents and delivered to the analysisd processing queue by ossec-remoted).",https://github.com/ossec/ossec-hids/commit/353ef15e4d3c5dfa8f1cc100651656cf7013c6a9,analysisd: fix off-by-one in OS_CleanMSG.\n\nWhen removing the '[ID xx facility.severity]' substring of a syslog\nmessage in `OS_CleanMSG` care needs to be taken to stay within the\nbounds of the msg buffer when advancing past the `] ` in the msg.\n\nPrev. to this commit the `pieces` pointer is incremented by 2 when there\nmay be only 1 character remaining before the null terminator.,1,"[{""func_name"": ""OS_CleanMSG"", ""file_path"": ""src/analysisd/cleanevent.c"", ""func_code"": ""int OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n        merror(FORMAT_ERROR, ARGV0);\n        return (-1);\n    }\n\n    /* Is this from an agent? */\n    if ( *msg == '(' )\n    {   /* look past '->' for the first ':' */\n        pieces = strchr(strstr(msg, \""->\""), ':');\n        if(!pieces)\n        {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n    }\n\n    *pieces = '\\0';\n    pieces++;\n\n    os_strdup(msg, lf->location);\n\n    /* Get the log length */\n    loglen = strlen(pieces) + 1;\n\n    /* Assign the values in the structure (lf->full_log) */\n    os_malloc((2 * loglen) + 1, lf->full_log);\n\n    /* Set the whole message at full_log */\n    strncpy(lf->full_log, pieces, loglen);\n\n    /* Log is the one used for parsing in the decoders and rules */\n    lf->log = lf->full_log + loglen;\n    strncpy(lf->log, pieces, loglen);\n\n    /* check if month contains an umlaut and repair\n     * umlauts are non-ASCII and use 2 slots in the char array\n     * repair to only one slot so we can detect the correct date format in the next step\n     * ex: M\u00e4r 02 17:30:52\n     */\n    if (pieces[1] == (char) 195) {\n        if (pieces[2] == (char) 164) {\n            pieces[0] = '\\0';\n            pieces[1] = 'M';\n            pieces[2] = 'a';\n            pieces++;\n        }\n    }\n\n    /* Check for the syslog date format\n     * ( ex: Dec 29 10:00:01\n     *   or  2015-04-16 21:51:02,805 for proftpd 1.3.5\n     *   or  2007-06-14T15:48:55-04:00 for syslog-ng isodate\n     *   or  2007-06-14T15:48:55.3352-04:00 for syslog-ng isodate with up to 6 optional fraction of a second\n     *   or  2009-05-22T09:36:46.214994-07:00 for rsyslog\n     *   or  2015 Dec 29 10:00:01 )\n     */\n    if (\n        (   /* ex: Dec 29 10:00:01 */\n            (loglen > 17) &&\n            (pieces[3] == ' ') &&\n            (pieces[6] == ' ') &&\n            (pieces[9] == ':') &&\n            (pieces[12] == ':') &&\n            (pieces[15] == ' ') && (lf->log += 16)\n        )\n        ||\n        (   /* ex: 2015-04-16 21:51:02,805 */\n            (loglen > 24) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == ' ') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (pieces[19] == ',') &&\n            (lf->log += 23)\n        )\n        ||\n        (\n            (loglen > 33) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == 'T') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (   /* ex: 2007-06-14T15:48:55-04:00 */\n                (\n                    (pieces[22] == ':') &&\n                    (pieces[25] == ' ') && (lf->log += 26)\n                )\n                ||\n                /* ex: 2007-06-14T15:48:55.3-04:00 or 2009-05-22T09:36:46,214994-07:00 */\n                (\n                    (\n                        (pieces[19] == '.') || (pieces[19] == ',')\n                    )\n                    &&\n                    (\n                        ( (pieces[24] == ':') && (lf->log += 27) ) ||\n                        ( (pieces[25] == ':') && (lf->log += 28) ) ||\n                        ( (pieces[26] == ':') && (lf->log += 29) ) ||\n                        ( (pieces[27] == ':') && (lf->log += 30) ) ||\n                        ( (pieces[28] == ':') && (lf->log += 31) ) ||\n                        ( (pieces[29] == ':') && (lf->log += 32) )\n                    )\n                )\n            )\n        )\n        ||\n        (   /* ex: 2015 Dec 29 10:00:01 */\n            (loglen > 21) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ' ') &&\n            (pieces[8] == ' ') &&\n            (pieces[11] == ' ') &&\n            (pieces[14] == ':') &&\n            (pieces[17] == ':') &&\n            (pieces[20] == ' ') && (lf->log += 21)\n        )\n        ||\n        (\n            /* ex: 2019:11:06-00:08:03 */\n            (loglen > 20) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ':') &&\n            (pieces[7] == ':') &&\n            (pieces[10] == '-') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') && (lf->log += 20)\n        )\n    ) {\n        /* Check for an extra space in here */\n        if (*lf->log == ' ') {\n            lf->log++;\n        }\n\n\n        /* Hostname */\n        pieces = lf->hostname = lf->log;\n\n\n        /* Check for a valid hostname */\n        while (isValidChar(*pieces) == 1) {\n            pieces++;\n        }\n\n        /* Check if it is a syslog without hostname (common on Solaris) */\n        if (*pieces == ':' && pieces[1] == ' ') {\n            /* Getting solaris 8/9 messages without hostname.\n             * In these cases, the process_name should be there.\n             * http://www.ossec.net/wiki/index.php/Log_Samples_Solaris\n             */\n            lf->program_name = lf->hostname;\n            lf->hostname = NULL;\n\n            /* End the program name string */\n            *pieces = '\\0';\n\n            pieces += 2;\n            lf->log = pieces;\n        }\n\n        /* Extract the hostname */\n        else if (*pieces != ' ') {\n            /* Invalid hostname */\n            lf->hostname = NULL;\n            pieces = NULL;\n        } else {\n            /* End the hostname string */\n            *pieces = '\\0';\n\n            /* Move pieces to the beginning of the log message */\n            pieces++;\n            lf->log = pieces;\n\n            /* Get program_name */\n            lf->program_name = pieces;\n\n            /* Extract program_name */\n            /* Valid names:\n             * p_name:\n             * p_name[pid]:\n             * p_name[pid]: [ID xx facility.severity]\n             * auth|security:info p_name:\n             */\n            while (isValidChar(*pieces) == 1) {\n                pieces++;\n            }\n\n            /* Check for the first format: p_name: */\n            if ((*pieces == ':') && (pieces[1] == ' ')) {\n                *pieces = '\\0';\n                pieces += 2;\n            }\n\n            /* Check for the second format: p_name[pid]: */\n            else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                *pieces = '\\0';\n                pieces += 2;\n                while (isdigit((int)*pieces)) {\n                    pieces++;\n                }\n\n                if ((*pieces == ']') && (pieces[1] == ':') && (pieces[2] == ' ')) {\n                    pieces += 3;\n                }\n                /* Some systems are not terminating the program name with\n                 * a ':'. Working around this in here...\n                 */\n                else if ((*pieces == ']') && (pieces[1] == ' ')) {\n                    pieces += 2;\n                } else {\n                    /* Fix for some weird log formats */\n                    pieces--;\n                    while (isdigit((int)*pieces)) {\n                        pieces--;\n                    }\n\n                    if (*pieces == '\\0') {\n                        *pieces = '[';\n                    }\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            }\n            /* AIX syslog */\n            else if ((*pieces == '|') && islower((int)pieces[1])) {\n                pieces += 2;\n\n                /* Remove facility */\n                while (isalnum((int)*pieces)) {\n                    pieces++;\n                }\n\n                if (*pieces == ':') {\n                    /* Remove severity */\n                    pieces++;\n                    while (isalnum((int)*pieces)) {\n                        pieces++;\n                    }\n\n                    if (*pieces == ' ') {\n                        pieces++;\n                        lf->program_name = pieces;\n\n\n                        /* Get program name again */\n                        while (isValidChar(*pieces) == 1) {\n                            pieces++;\n                        }\n\n                        /* Check for the first format: p_name: */\n                        if ((*pieces == ':') && (pieces[1] == ' ')) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                        }\n\n                        /* Check for the second format: p_name[pid]: */\n                        else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                            while (isdigit((int)*pieces)) {\n                                pieces++;\n                            }\n\n                            if ((*pieces == ']') && (pieces[1] == ':') &&\n                                    (pieces[2] == ' ')) {\n                                pieces += 3;\n                            } else {\n                                pieces = NULL;\n                            }\n                        }\n                    } else {\n                        pieces = NULL;\n                        lf->program_name = NULL;\n                    }\n                }\n                /* Invalid AIX */\n                else {\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            } else {\n                pieces = NULL;\n                lf->program_name = NULL;\n            }\n        }\n\n        /* Remove [ID xx facility.severity] */\n        if (pieces) {\n            /* Set log after program name */\n            lf->log = pieces;\n\n            if ((pieces[0] == '[') &&\n                    (pieces[1] == 'I') &&\n                    (pieces[2] == 'D') &&\n                    (pieces[3] == ' ')) {\n                pieces += 4;\n\n                /* Going after the ] */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    pieces += 2;\n                    lf->log = pieces;\n                }\n            }\n        }\n\n        /* Get program name size */\n        if (lf->program_name) {\n            lf->p_name_size = strlen(lf->program_name);\n        }\n    }\n\n    /* xferlog date format\n     * Mon Apr 17 18:27:14 2006 1 64.160.42.130\n     */\n    else if ((loglen > 28) &&\n             (pieces[3] == ' ') &&\n             (pieces[7] == ' ') &&\n             (pieces[10] == ' ') &&\n             (pieces[13] == ':') &&\n             (pieces[16] == ':') &&\n             (pieces[19] == ' ') &&\n             (pieces[24] == ' ') &&\n             (pieces[26] == ' ')) {\n        /* Move log to the beginning of the message */\n        lf->log += 24;\n    }\n\n    /* Check for snort date format\n     * ex: 01/28-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 24) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '-') &&\n              (pieces[8] == ':') &&\n              (pieces[11] == ':') &&\n              (pieces[14] == '.') &&\n              (pieces[21] == ' ') ) {\n        lf->log += 23;\n    }\n\n    /* Check for suricata (new) date format\n     * ex: 01/28/1979-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 26) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '/') &&\n              (pieces[10] == '-') &&\n              (pieces[13] == ':') &&\n              (pieces[16] == ':') &&\n              (pieces[19] == '.') &&\n              (pieces[26] == ' ') ) {\n        lf->log += 28;\n    }\n\n\n    /* Check for apache log format */\n    /* [Fri Feb 11 18:06:35 2004] [warn] */\n    else if ( (loglen > 27) &&\n              (pieces[0] == '[') &&\n              (pieces[4] == ' ') &&\n              (pieces[8] == ' ') &&\n              (pieces[11] == ' ') &&\n              (pieces[14] == ':') &&\n              (pieces[17] == ':') &&\n              (pieces[20] == ' ') &&\n              (pieces[25] == ']') ) {\n        lf->log += 27;\n    }\n\n    /* Check for the osx asl log format.\n     * Examples:\n     * [Time 2006.12.28 15:53:55 UTC] [Facility auth] [Sender sshd] [PID 483] [Message error: PAM: Authentication failure for username from 192.168.0.2] [Level 3] [UID -2] [GID -2] [Host Hostname]\n     * [Time 2006.11.02 14:02:11 UTC] [Facility auth] [Sender sshd] [PID 856]\n     [Message refused connect from 59.124.44.34] [Level 4] [UID -2] [GID -2]\n     [Host robert-wyatts-emac]\n     */\n    else if ((loglen > 26) &&\n             (pieces[0] == '[')  &&\n             (pieces[1] == 'T')  &&\n             (pieces[5] == ' ')  &&\n             (pieces[10] == '.') &&\n             (pieces[13] == '.') &&\n             (pieces[16] == ' ') &&\n             (pieces[19] == ':')) {\n        /* Do not read more than 1 message entry -> log tampering */\n        short unsigned int done_message = 0;\n\n        /* Remove the date */\n        lf->log += 25;\n\n        /* Get the desired values */\n        pieces = strchr(lf->log, '[');\n        while (pieces) {\n            pieces++;\n\n            /* Get the sender (set to program name) */\n            if ((strncmp(pieces, \""Sender \"", 7) == 0) &&\n                    (lf->program_name == NULL)) {\n                pieces += 7;\n                lf->program_name = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n\n                    /* Set program_name size */\n                    lf->p_name_size = strlen(lf->program_name);\n\n                    pieces++;\n                }\n                /* Invalid program name */\n                else {\n                    lf->program_name = NULL;\n                    break;\n                }\n            }\n\n            /* Get message */\n            else if ((strncmp(pieces, \""Message \"", 8) == 0) &&\n                     (done_message == 0)) {\n                pieces += 8;\n                done_message = 1;\n\n                lf->log = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n                /* Invalid log closure */\n                else {\n                    break;\n                }\n            }\n\n            /* Get hostname */\n            else if (strncmp(pieces, \""Host \"", 5) == 0) {\n                pieces += 5;\n                lf->hostname = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n\n                /* Invalid hostname */\n                else {\n                    lf->hostname = NULL;\n                }\n                break;\n            }\n\n            /* Get next entry */\n            pieces = strchr(pieces, '[');\n        }\n    }\n\n    /* Check for squid date format\n     * 1140804070.368  11623\n     * seconds from 00:00:00 1970-01-01 UTC\n     */\n    else if ((loglen > 32) &&\n             (pieces[0] == '1') &&\n             (isdigit((int)pieces[1])) &&\n             (isdigit((int)pieces[2])) &&\n             (isdigit((int)pieces[3])) &&\n             (pieces[10] == '.') &&\n             (isdigit((int)pieces[13])) &&\n             (pieces[14] == ' ') &&\n             ((pieces[21] == ' ') || (pieces[22] == ' '))) {\n        lf->log += 14;\n\n        /* We need to start at the size of the event */\n        while (*lf->log == ' ') {\n            lf->log++;\n        }\n    }\n\n    /* Every message must be in the format\n     * hostname->location or\n     * (agent) ip->location.\n     */\n\n    /* Set hostname for local messages */\n    if (lf->location[0] == '(') {\n        /* Messages from an agent */\n        lf->hostname = lf->location;\n    } else if (lf->hostname == NULL) {\n        lf->hostname = __shost;\n    }\n\n    /* Set up the event data */\n    lf->time = c_time;\n    p = localtime(&c_time);\n\n    /* Assign hour, day, year and month values */\n    lf->day = p->tm_mday;\n    lf->year = p->tm_year + 1900;\n    strncpy(lf->mon, month[p->tm_mon], 3);\n    snprintf(lf->hour, 9, \""%02d:%02d:%02d\"",\n             p->tm_hour,\n             p->tm_min,\n             p->tm_sec);\n\n    /* Set the global hour/weekday */\n    __crt_hour = p->tm_hour;\n    __crt_wday = p->tm_wday;\n\n#ifdef TESTRULE\n    if (!alert_only) {\n        print_out(\""**Phase 1: Completed pre-decoding.\"");\n        print_out(\""       full event: '%s'\"", lf->full_log);\n        print_out(\""       hostname: '%s'\"", lf->hostname);\n        print_out(\""       program_name: '%s'\"", lf->program_name);\n        print_out(\""       log: '%s'\"", lf->log);\n    }\n#endif\n    return (0);\n}"", ""target"": 0}]","[{""func_name"": ""OS_CleanMSG"", ""file_path"": ""src/analysisd/cleanevent.c"", ""func_code"": ""int OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n        merror(FORMAT_ERROR, ARGV0);\n        return (-1);\n    }\n\n    /* Is this from an agent? */\n    if ( *msg == '(' )\n    {   /* look past '->' for the first ':' */\n        pieces = strchr(strstr(msg, \""->\""), ':');\n        if(!pieces)\n        {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n    }\n\n    *pieces = '\\0';\n    pieces++;\n\n    os_strdup(msg, lf->location);\n\n    /* Get the log length */\n    loglen = strlen(pieces) + 1;\n\n    /* Assign the values in the structure (lf->full_log) */\n    os_malloc((2 * loglen) + 1, lf->full_log);\n\n    /* Set the whole message at full_log */\n    strncpy(lf->full_log, pieces, loglen);\n\n    /* Log is the one used for parsing in the decoders and rules */\n    lf->log = lf->full_log + loglen;\n    strncpy(lf->log, pieces, loglen);\n\n    /* check if month contains an umlaut and repair\n     * umlauts are non-ASCII and use 2 slots in the char array\n     * repair to only one slot so we can detect the correct date format in the next step\n     * ex: M\u00e4r 02 17:30:52\n     */\n    if (pieces[1] == (char) 195) {\n        if (pieces[2] == (char) 164) {\n            pieces[0] = '\\0';\n            pieces[1] = 'M';\n            pieces[2] = 'a';\n            pieces++;\n        }\n    }\n\n    /* Check for the syslog date format\n     * ( ex: Dec 29 10:00:01\n     *   or  2015-04-16 21:51:02,805 for proftpd 1.3.5\n     *   or  2007-06-14T15:48:55-04:00 for syslog-ng isodate\n     *   or  2007-06-14T15:48:55.3352-04:00 for syslog-ng isodate with up to 6 optional fraction of a second\n     *   or  2009-05-22T09:36:46.214994-07:00 for rsyslog\n     *   or  2015 Dec 29 10:00:01 )\n     */\n    if (\n        (   /* ex: Dec 29 10:00:01 */\n            (loglen > 17) &&\n            (pieces[3] == ' ') &&\n            (pieces[6] == ' ') &&\n            (pieces[9] == ':') &&\n            (pieces[12] == ':') &&\n            (pieces[15] == ' ') && (lf->log += 16)\n        )\n        ||\n        (   /* ex: 2015-04-16 21:51:02,805 */\n            (loglen > 24) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == ' ') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (pieces[19] == ',') &&\n            (lf->log += 23)\n        )\n        ||\n        (\n            (loglen > 33) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == 'T') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (   /* ex: 2007-06-14T15:48:55-04:00 */\n                (\n                    (pieces[22] == ':') &&\n                    (pieces[25] == ' ') && (lf->log += 26)\n                )\n                ||\n                /* ex: 2007-06-14T15:48:55.3-04:00 or 2009-05-22T09:36:46,214994-07:00 */\n                (\n                    (\n                        (pieces[19] == '.') || (pieces[19] == ',')\n                    )\n                    &&\n                    (\n                        ( (pieces[24] == ':') && (lf->log += 27) ) ||\n                        ( (pieces[25] == ':') && (lf->log += 28) ) ||\n                        ( (pieces[26] == ':') && (lf->log += 29) ) ||\n                        ( (pieces[27] == ':') && (lf->log += 30) ) ||\n                        ( (pieces[28] == ':') && (lf->log += 31) ) ||\n                        ( (pieces[29] == ':') && (lf->log += 32) )\n                    )\n                )\n            )\n        )\n        ||\n        (   /* ex: 2015 Dec 29 10:00:01 */\n            (loglen > 21) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ' ') &&\n            (pieces[8] == ' ') &&\n            (pieces[11] == ' ') &&\n            (pieces[14] == ':') &&\n            (pieces[17] == ':') &&\n            (pieces[20] == ' ') && (lf->log += 21)\n        )\n        ||\n        (\n            /* ex: 2019:11:06-00:08:03 */\n            (loglen > 20) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ':') &&\n            (pieces[7] == ':') &&\n            (pieces[10] == '-') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') && (lf->log += 20)\n        )\n    ) {\n        /* Check for an extra space in here */\n        if (*lf->log == ' ') {\n            lf->log++;\n        }\n\n\n        /* Hostname */\n        pieces = lf->hostname = lf->log;\n\n\n        /* Check for a valid hostname */\n        while (isValidChar(*pieces) == 1) {\n            pieces++;\n        }\n\n        /* Check if it is a syslog without hostname (common on Solaris) */\n        if (*pieces == ':' && pieces[1] == ' ') {\n            /* Getting solaris 8/9 messages without hostname.\n             * In these cases, the process_name should be there.\n             * http://www.ossec.net/wiki/index.php/Log_Samples_Solaris\n             */\n            lf->program_name = lf->hostname;\n            lf->hostname = NULL;\n\n            /* End the program name string */\n            *pieces = '\\0';\n\n            pieces += 2;\n            lf->log = pieces;\n        }\n\n        /* Extract the hostname */\n        else if (*pieces != ' ') {\n            /* Invalid hostname */\n            lf->hostname = NULL;\n            pieces = NULL;\n        } else {\n            /* End the hostname string */\n            *pieces = '\\0';\n\n            /* Move pieces to the beginning of the log message */\n            pieces++;\n            lf->log = pieces;\n\n            /* Get program_name */\n            lf->program_name = pieces;\n\n            /* Extract program_name */\n            /* Valid names:\n             * p_name:\n             * p_name[pid]:\n             * p_name[pid]: [ID xx facility.severity]\n             * auth|security:info p_name:\n             */\n            while (isValidChar(*pieces) == 1) {\n                pieces++;\n            }\n\n            /* Check for the first format: p_name: */\n            if ((*pieces == ':') && (pieces[1] == ' ')) {\n                *pieces = '\\0';\n                pieces += 2;\n            }\n\n            /* Check for the second format: p_name[pid]: */\n            else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                *pieces = '\\0';\n                pieces += 2;\n                while (isdigit((int)*pieces)) {\n                    pieces++;\n                }\n\n                if ((*pieces == ']') && (pieces[1] == ':') && (pieces[2] == ' ')) {\n                    pieces += 3;\n                }\n                /* Some systems are not terminating the program name with\n                 * a ':'. Working around this in here...\n                 */\n                else if ((*pieces == ']') && (pieces[1] == ' ')) {\n                    pieces += 2;\n                } else {\n                    /* Fix for some weird log formats */\n                    pieces--;\n                    while (isdigit((int)*pieces)) {\n                        pieces--;\n                    }\n\n                    if (*pieces == '\\0') {\n                        *pieces = '[';\n                    }\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            }\n            /* AIX syslog */\n            else if ((*pieces == '|') && islower((int)pieces[1])) {\n                pieces += 2;\n\n                /* Remove facility */\n                while (isalnum((int)*pieces)) {\n                    pieces++;\n                }\n\n                if (*pieces == ':') {\n                    /* Remove severity */\n                    pieces++;\n                    while (isalnum((int)*pieces)) {\n                        pieces++;\n                    }\n\n                    if (*pieces == ' ') {\n                        pieces++;\n                        lf->program_name = pieces;\n\n\n                        /* Get program name again */\n                        while (isValidChar(*pieces) == 1) {\n                            pieces++;\n                        }\n\n                        /* Check for the first format: p_name: */\n                        if ((*pieces == ':') && (pieces[1] == ' ')) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                        }\n\n                        /* Check for the second format: p_name[pid]: */\n                        else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                            while (isdigit((int)*pieces)) {\n                                pieces++;\n                            }\n\n                            if ((*pieces == ']') && (pieces[1] == ':') &&\n                                    (pieces[2] == ' ')) {\n                                pieces += 3;\n                            } else {\n                                pieces = NULL;\n                            }\n                        }\n                    } else {\n                        pieces = NULL;\n                        lf->program_name = NULL;\n                    }\n                }\n                /* Invalid AIX */\n                else {\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            } else {\n                pieces = NULL;\n                lf->program_name = NULL;\n            }\n        }\n\n        /* Remove [ID xx facility.severity] */\n        if (pieces) {\n            /* Set log after program name */\n            lf->log = pieces;\n\n            if ((pieces[0] == '[') &&\n                    (pieces[1] == 'I') &&\n                    (pieces[2] == 'D') &&\n                    (pieces[3] == ' ')) {\n                pieces += 4;\n\n                /* Going after the \""] \"" */\n                pieces = strstr(pieces, \""] \"");\n                if (pieces) {\n                    pieces += 2;\n                    lf->log = pieces;\n                }\n            }\n        }\n\n        /* Get program name size */\n        if (lf->program_name) {\n            lf->p_name_size = strlen(lf->program_name);\n        }\n    }\n\n    /* xferlog date format\n     * Mon Apr 17 18:27:14 2006 1 64.160.42.130\n     */\n    else if ((loglen > 28) &&\n             (pieces[3] == ' ') &&\n             (pieces[7] == ' ') &&\n             (pieces[10] == ' ') &&\n             (pieces[13] == ':') &&\n             (pieces[16] == ':') &&\n             (pieces[19] == ' ') &&\n             (pieces[24] == ' ') &&\n             (pieces[26] == ' ')) {\n        /* Move log to the beginning of the message */\n        lf->log += 24;\n    }\n\n    /* Check for snort date format\n     * ex: 01/28-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 24) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '-') &&\n              (pieces[8] == ':') &&\n              (pieces[11] == ':') &&\n              (pieces[14] == '.') &&\n              (pieces[21] == ' ') ) {\n        lf->log += 23;\n    }\n\n    /* Check for suricata (new) date format\n     * ex: 01/28/1979-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 26) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '/') &&\n              (pieces[10] == '-') &&\n              (pieces[13] == ':') &&\n              (pieces[16] == ':') &&\n              (pieces[19] == '.') &&\n              (pieces[26] == ' ') ) {\n        lf->log += 28;\n    }\n\n\n    /* Check for apache log format */\n    /* [Fri Feb 11 18:06:35 2004] [warn] */\n    else if ( (loglen > 27) &&\n              (pieces[0] == '[') &&\n              (pieces[4] == ' ') &&\n              (pieces[8] == ' ') &&\n              (pieces[11] == ' ') &&\n              (pieces[14] == ':') &&\n              (pieces[17] == ':') &&\n              (pieces[20] == ' ') &&\n              (pieces[25] == ']') ) {\n        lf->log += 27;\n    }\n\n    /* Check for the osx asl log format.\n     * Examples:\n     * [Time 2006.12.28 15:53:55 UTC] [Facility auth] [Sender sshd] [PID 483] [Message error: PAM: Authentication failure for username from 192.168.0.2] [Level 3] [UID -2] [GID -2] [Host Hostname]\n     * [Time 2006.11.02 14:02:11 UTC] [Facility auth] [Sender sshd] [PID 856]\n     [Message refused connect from 59.124.44.34] [Level 4] [UID -2] [GID -2]\n     [Host robert-wyatts-emac]\n     */\n    else if ((loglen > 26) &&\n             (pieces[0] == '[')  &&\n             (pieces[1] == 'T')  &&\n             (pieces[5] == ' ')  &&\n             (pieces[10] == '.') &&\n             (pieces[13] == '.') &&\n             (pieces[16] == ' ') &&\n             (pieces[19] == ':')) {\n        /* Do not read more than 1 message entry -> log tampering */\n        short unsigned int done_message = 0;\n\n        /* Remove the date */\n        lf->log += 25;\n\n        /* Get the desired values */\n        pieces = strchr(lf->log, '[');\n        while (pieces) {\n            pieces++;\n\n            /* Get the sender (set to program name) */\n            if ((strncmp(pieces, \""Sender \"", 7) == 0) &&\n                    (lf->program_name == NULL)) {\n                pieces += 7;\n                lf->program_name = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n\n                    /* Set program_name size */\n                    lf->p_name_size = strlen(lf->program_name);\n\n                    pieces++;\n                }\n                /* Invalid program name */\n                else {\n                    lf->program_name = NULL;\n                    break;\n                }\n            }\n\n            /* Get message */\n            else if ((strncmp(pieces, \""Message \"", 8) == 0) &&\n                     (done_message == 0)) {\n                pieces += 8;\n                done_message = 1;\n\n                lf->log = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n                /* Invalid log closure */\n                else {\n                    break;\n                }\n            }\n\n            /* Get hostname */\n            else if (strncmp(pieces, \""Host \"", 5) == 0) {\n                pieces += 5;\n                lf->hostname = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n\n                /* Invalid hostname */\n                else {\n                    lf->hostname = NULL;\n                }\n                break;\n            }\n\n            /* Get next entry */\n            pieces = strchr(pieces, '[');\n        }\n    }\n\n    /* Check for squid date format\n     * 1140804070.368  11623\n     * seconds from 00:00:00 1970-01-01 UTC\n     */\n    else if ((loglen > 32) &&\n             (pieces[0] == '1') &&\n             (isdigit((int)pieces[1])) &&\n             (isdigit((int)pieces[2])) &&\n             (isdigit((int)pieces[3])) &&\n             (pieces[10] == '.') &&\n             (isdigit((int)pieces[13])) &&\n             (pieces[14] == ' ') &&\n             ((pieces[21] == ' ') || (pieces[22] == ' '))) {\n        lf->log += 14;\n\n        /* We need to start at the size of the event */\n        while (*lf->log == ' ') {\n            lf->log++;\n        }\n    }\n\n    /* Every message must be in the format\n     * hostname->location or\n     * (agent) ip->location.\n     */\n\n    /* Set hostname for local messages */\n    if (lf->location[0] == '(') {\n        /* Messages from an agent */\n        lf->hostname = lf->location;\n    } else if (lf->hostname == NULL) {\n        lf->hostname = __shost;\n    }\n\n    /* Set up the event data */\n    lf->time = c_time;\n    p = localtime(&c_time);\n\n    /* Assign hour, day, year and month values */\n    lf->day = p->tm_mday;\n    lf->year = p->tm_year + 1900;\n    strncpy(lf->mon, month[p->tm_mon], 3);\n    snprintf(lf->hour, 9, \""%02d:%02d:%02d\"",\n             p->tm_hour,\n             p->tm_min,\n             p->tm_sec);\n\n    /* Set the global hour/weekday */\n    __crt_hour = p->tm_hour;\n    __crt_wday = p->tm_wday;\n\n#ifdef TESTRULE\n    if (!alert_only) {\n        print_out(\""**Phase 1: Completed pre-decoding.\"");\n        print_out(\""       full event: '%s'\"", lf->full_log);\n        print_out(\""       hostname: '%s'\"", lf->hostname);\n        print_out(\""       program_name: '%s'\"", lf->program_name);\n        print_out(\""       log: '%s'\"", lf->log);\n    }\n#endif\n    return (0);\n}""}]","{""code"": 5, ""value"": 5, ""function"": 2}","[{""source"": ""code_info(file:cleanevent.c, lines:320-350)"", ""result"": ""                }\n            } else {\n                pieces = NULL;\n                lf->program_name = NULL;\n            }\n        }\n\n        /* Remove [ID xx facility.severity] */\n        if (pieces) {\n            /* Set log after program name */\n            lf->log = pieces;\n\n            if ((pieces[0] == '[') &&\n                    (pieces[1] == 'I') &&\n                    (pieces[2] == 'D') &&\n                    (pieces[3] == ' ')) {\n                pieces += 4;\n\n                /* Going after the ] */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    pieces += 2;\n                    lf->log = pieces;\n                }\n            }\n        }\n\n        /* Get program name size */\n        if (lf->program_name) {\n            lf->p_name_size = strlen(lf->program_name);\n        }\n    }\n""}, {""source"": ""value_info(file:cleanevent.c, value:pieces)"", ""result"": {""value_trace"": [{""full_code"": ""pieces = strchr(msg, ':')"", ""line"": 39, ""func_name"": ""OS_CleanMSG""}, {""full_code"": ""pieces = strchr(strstr(msg, \""->\""), ':')"", ""line"": 48, ""func_name"": ""OS_CleanMSG""}, {""full_code"": ""pieces++"", ""line"": 57, ""func_name"": ""OS_CleanMSG""}, {""full_code"": ""pieces++"", ""line"": 84, ""func_name"": ""OS_CleanMSG""}, {""full_code"": ""pieces = lf->hostname = lf->log"", ""line"": 177, ""func_name"": ""OS_CleanMSG""}], ""struct_var"": ""pieces"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""code_info(file:cleanevent.c, lines:10-39)"", ""result"": ""#include \""cleanevent.h\""\n\n#include \""shared.h\""\n#include \""os_regex/os_regex.h\""\n#include \""analysisd.h\""\n#include \""fts.h\""\n#include \""config.h\""\n\n/* To translate between month (int) to month (char) */\nstatic const char *(month[]) = {\""Jan\"", \""Feb\"", \""Mar\"", \""Apr\"", \""May\"", \""Jun\"",\n                   \""Jul\"", \""Aug\"", \""Sep\"", \""Oct\"", \""Nov\"", \""Dec\""\n                  };\n\n\n/* Format a received message in the Eventinfo structure */\nint OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n""}, {""source"": ""value_info(file:cleanevent.c, value:msg)"", ""result"": {""value_trace"": [{""full_code"": ""msg += 2"", ""line"": 36, ""func_name"": ""OS_CleanMSG""}], ""struct_var"": ""msg"", ""struct_type"": ""char[OS_MAXSTR+1]"", ""struct_definition"": null}}, {""source"": ""code_info(file:cleanevent.c, lines:1-10)"", ""result"": ""/* Copyright (C) 2009 Trend Micro Inc.\n * All rights reserved.\n *\n * This program is a free software; you can redistribute it\n * and/or modify it under the terms of the GNU General Public\n * License (version 2) as published by the FSF - Free Software\n * Foundation.\n */\n\n#include \""cleanevent.h\""\n\n""}, {""source"": ""value_info(file:cleanevent.h, value:msg)"", ""result"": {""value_trace"": [{""full_code"": ""msg[OS_MAXSTR + 1]"", ""line"": 535, ""func_name"": ""OS_ReadMSG""}, {""full_code"": ""msg += 2"", ""line"": 36, ""func_name"": ""OS_CleanMSG""}, {""full_code"": ""msg[OS_MAXSTR + 1]"", ""line"": 334, ""func_name"": ""OS_ReadMSG<duplicate>0""}, {""full_code"": ""msg[OS_MAXSTR + 1]"", ""line"": 23, ""func_name"": ""EventForward""}, {""full_code"": ""msg[OS_MAXSTR + 2]"", ""line"": 137, ""func_name"": ""start_agent""}], ""struct_var"": ""msg"", ""struct_type"": ""char[OS_MAXSTR+1]"", ""struct_definition"": null}}, {""source"": ""func_info(file:cleanevent.c, func:OS_CleanMSG)"", ""result"": [{""code"": ""int OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n        merror(FORMAT_ERROR, ARGV0);\n        return (-1);\n    }\n\n    /* Is this from an agent? */\n    if ( *msg == '(' )\n    {   /* look past '->' for the first ':' */\n        pieces = strchr(strstr(msg, \""->\""), ':');\n        if(!pieces)\n        {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n    }\n\n    *pieces = '\\0';\n    pieces++;\n\n    os_strdup(msg, lf->location);\n\n    /* Get the log length */\n    loglen = strlen(pieces) + 1;\n\n    /* Assign the values in the structure (lf->full_log) */\n    os_malloc((2 * loglen) + 1, lf->full_log);\n\n    /* Set the whole message at full_log */\n    strncpy(lf->full_log, pieces, loglen);\n\n    /* Log is the one used for parsing in the decoders and rules */\n    lf->log = lf->full_log + loglen;\n    strncpy(lf->log, pieces, loglen);\n\n    /* check if month contains an umlaut and repair\n     * umlauts are non-ASCII and use 2 slots in the char array\n     * repair to only one slot so we can detect the correct date format in the next step\n     * ex: M\u00e4r 02 17:30:52\n     */\n    if (pieces[1] == (char) 195) {\n        if (pieces[2] == (char) 164) {\n            pieces[0] = '\\0';\n            pieces[1] = 'M';\n            pieces[2] = 'a';\n            pieces++;\n        }\n    }\n\n    /* Check for the syslog date format\n     * ( ex: Dec 29 10:00:01\n     *   or  2015-04-16 21:51:02,805 for proftpd 1.3.5\n     *   or  2007-06-14T15:48:55-04:00 for syslog-ng isodate\n     *   or  2007-06-14T15:48:55.3352-04:00 for syslog-ng isodate with up to 6 optional fraction of a second\n     *   or  2009-05-22T09:36:46.214994-07:00 for rsyslog\n     *   or  2015 Dec 29 10:00:01 )\n     */\n    if (\n        (   /* ex: Dec 29 10:00:01 */\n            (loglen > 17) &&\n            (pieces[3] == ' ') &&\n            (pieces[6] == ' ') &&\n            (pieces[9] == ':') &&\n            (pieces[12] == ':') &&\n            (pieces[15] == ' ') && (lf->log += 16)\n        )\n        ||\n        (   /* ex: 2015-04-16 21:51:02,805 */\n            (loglen > 24) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == ' ') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (pieces[19] == ',') &&\n            (lf->log += 23)\n        )\n        ||\n        (\n            (loglen > 33) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == 'T') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (   /* ex: 2007-06-14T15:48:55-04:00 */\n                (\n                    (pieces[22] == ':') &&\n                    (pieces[25] == ' ') && (lf->log += 26)\n                )\n                ||\n                /* ex: 2007-06-14T15:48:55.3-04:00 or 2009-05-22T09:36:46,214994-07:00 */\n                (\n                    (\n                        (pieces[19] == '.') || (pieces[19] == ',')\n                    )\n                    &&\n                    (\n                        ( (pieces[24] == ':') && (lf->log += 27) ) ||\n                        ( (pieces[25] == ':') && (lf->log += 28) ) ||\n                        ( (pieces[26] == ':') && (lf->log += 29) ) ||\n                        ( (pieces[27] == ':') && (lf->log += 30) ) ||\n                        ( (pieces[28] == ':') && (lf->log += 31) ) ||\n                        ( (pieces[29] == ':') && (lf->log += 32) )\n                    )\n                )\n            )\n        )\n        ||\n        (   /* ex: 2015 Dec 29 10:00:01 */\n            (loglen > 21) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ' ') &&\n            (pieces[8] == ' ') &&\n            (pieces[11] == ' ') &&\n            (pieces[14] == ':') &&\n            (pieces[17] == ':') &&\n            (pieces[20] == ' ') && (lf->log += 21)\n        )\n        ||\n        (\n            /* ex: 2019:11:06-00:08:03 */\n            (loglen > 20) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ':') &&\n            (pieces[7] == ':') &&\n            (pieces[10] == '-') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') && (lf->log += 20)\n        )\n    ) {\n        /* Check for an extra space in here */\n        if (*lf->log == ' ') {\n            lf->log++;\n        }\n\n\n        /* Hostname */\n        pieces = lf->hostname = lf->log;\n\n\n        /* Check for a valid hostname */\n        while (isValidChar(*pieces) == 1) {\n            pieces++;\n        }\n\n        /* Check if it is a syslog without hostname (common on Solaris) */\n        if (*pieces == ':' && pieces[1] == ' ') {\n            /* Getting solaris 8/9 messages without hostname.\n             * In these cases, the process_name should be there.\n             * http://www.ossec.net/wiki/index.php/Log_Samples_Solaris\n             */\n            lf->program_name = lf->hostname;\n            lf->hostname = NULL;\n\n            /* End the program name string */\n            *pieces = '\\0';\n\n            pieces += 2;\n            lf->log = pieces;\n        }\n\n        /* Extract the hostname */\n        else if (*pieces != ' ') {\n            /* Invalid hostname */\n            lf->hostname = NULL;\n            pieces = NULL;\n        } else {\n            /* End the hostname string */\n            *pieces = '\\0';\n\n            /* Move pieces to the beginning of the log message */\n            pieces++;\n            lf->log = pieces;\n\n            /* Get program_name */\n            lf->program_name = pieces;\n\n            /* Extract program_name */\n            /* Valid names:\n             * p_name:\n             * p_name[pid]:\n             * p_name[pid]: [ID xx facility.severity]\n             * auth|security:info p_name:\n             */\n            while (isValidChar(*pieces) == 1) {\n                pieces++;\n            }\n\n            /* Check for the first format: p_name: */\n            if ((*pieces == ':') && (pieces[1] == ' ')) {\n                *pieces = '\\0';\n                pieces += 2;\n            }\n\n            /* Check for the second format: p_name[pid]: */\n            else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                *pieces = '\\0';\n                pieces += 2;\n                while (isdigit((int)*pieces)) {\n                    pieces++;\n                }\n\n                if ((*pieces == ']') && (pieces[1] == ':') && (pieces[2] == ' ')) {\n                    pieces += 3;\n                }\n                /* Some systems are not terminating the program name with\n                 * a ':'. Working around this in here...\n                 */\n                else if ((*pieces == ']') && (pieces[1] == ' ')) {\n                    pieces += 2;\n                } else {\n                    /* Fix for some weird log formats */\n                    pieces--;\n                    while (isdigit((int)*pieces)) {\n                        pieces--;\n                    }\n\n                    if (*pieces == '\\0') {\n                        *pieces = '[';\n                    }\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            }\n            /* AIX syslog */\n            else if ((*pieces == '|') && islower((int)pieces[1])) {\n                pieces += 2;\n\n                /* Remove facility */\n                while (isalnum((int)*pieces)) {\n                    pieces++;\n                }\n\n                if (*pieces == ':') {\n                    /* Remove severity */\n                    pieces++;\n                    while (isalnum((int)*pieces)) {\n                        pieces++;\n                    }\n\n                    if (*pieces == ' ') {\n                        pieces++;\n                        lf->program_name = pieces;\n\n\n                        /* Get program name again */\n                        while (isValidChar(*pieces) == 1) {\n                            pieces++;\n                        }\n\n                        /* Check for the first format: p_name: */\n                        if ((*pieces == ':') && (pieces[1] == ' ')) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                        }\n\n                        /* Check for the second format: p_name[pid]: */\n                        else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                            while (isdigit((int)*pieces)) {\n                                pieces++;\n                            }\n\n                            if ((*pieces == ']') && (pieces[1] == ':') &&\n                                    (pieces[2] == ' ')) {\n                                pieces += 3;\n                            } else {\n                                pieces = NULL;\n                            }\n                        }\n                    } else {\n                        pieces = NULL;\n                        lf->program_name = NULL;\n                    }\n                }\n                /* Invalid AIX */\n                else {\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            } else {\n                pieces = NULL;\n                lf->program_name = NULL;\n            }\n        }\n\n        /* Remove [ID xx facility.severity] */\n        if (pieces) {\n            /* Set log after program name */\n            lf->log = pieces;\n\n            if ((pieces[0] == '[') &&\n                    (pieces[1] == 'I') &&\n                    (pieces[2] == 'D') &&\n                    (pieces[3] == ' ')) {\n                pieces += 4;\n\n                /* Going after the ] */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    pieces += 2;\n                    lf->log = pieces;\n                }\n            }\n        }\n\n        /* Get program name size */\n        if (lf->program_name) {\n            lf->p_name_size = strlen(lf->program_name);\n        }\n    }\n\n    /* xferlog date format\n     * Mon Apr 17 18:27:14 2006 1 64.160.42.130\n     */\n    else if ((loglen > 28) &&\n             (pieces[3] == ' ') &&\n             (pieces[7] == ' ') &&\n             (pieces[10] == ' ') &&\n             (pieces[13] == ':') &&\n             (pieces[16] == ':') &&\n             (pieces[19] == ' ') &&\n             (pieces[24] == ' ') &&\n             (pieces[26] == ' ')) {\n        /* Move log to the beginning of the message */\n        lf->log += 24;\n    }\n\n    /* Check for snort date format\n     * ex: 01/28-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 24) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '-') &&\n              (pieces[8] == ':') &&\n              (pieces[11] == ':') &&\n              (pieces[14] == '.') &&\n              (pieces[21] == ' ') ) {\n        lf->log += 23;\n    }\n\n    /* Check for suricata (new) date format\n     * ex: 01/28/1979-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 26) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '/') &&\n              (pieces[10] == '-') &&\n              (pieces[13] == ':') &&\n              (pieces[16] == ':') &&\n              (pieces[19] == '.') &&\n              (pieces[26] == ' ') ) {\n        lf->log += 28;\n    }\n\n\n    /* Check for apache log format */\n    /* [Fri Feb 11 18:06:35 2004] [warn] */\n    else if ( (loglen > 27) &&\n              (pieces[0] == '[') &&\n              (pieces[4] == ' ') &&\n              (pieces[8] == ' ') &&\n              (pieces[11] == ' ') &&\n              (pieces[14] == ':') &&\n              (pieces[17] == ':') &&\n              (pieces[20] == ' ') &&\n              (pieces[25] == ']') ) {\n        lf->log += 27;\n    }\n\n    /* Check for the osx asl log format.\n     * Examples:\n     * [Time 2006.12.28 15:53:55 UTC] [Facility auth] [Sender sshd] [PID 483] [Message error: PAM: Authentication failure for username from 192.168.0.2] [Level 3] [UID -2] [GID -2] [Host Hostname]\n     * [Time 2006.11.02 14:02:11 UTC] [Facility auth] [Sender sshd] [PID 856]\n     [Message refused connect from 59.124.44.34] [Level 4] [UID -2] [GID -2]\n     [Host robert-wyatts-emac]\n     */\n    else if ((loglen > 26) &&\n             (pieces[0] == '[')  &&\n             (pieces[1] == 'T')  &&\n             (pieces[5] == ' ')  &&\n             (pieces[10] == '.') &&\n             (pieces[13] == '.') &&\n             (pieces[16] == ' ') &&\n             (pieces[19] == ':')) {\n        /* Do not read more than 1 message entry -> log tampering */\n        short unsigned int done_message = 0;\n\n        /* Remove the date */\n        lf->log += 25;\n\n        /* Get the desired values */\n        pieces = strchr(lf->log, '[');\n        while (pieces) {\n            pieces++;\n\n            /* Get the sender (set to program name) */\n            if ((strncmp(pieces, \""Sender \"", 7) == 0) &&\n                    (lf->program_name == NULL)) {\n                pieces += 7;\n                lf->program_name = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n\n                    /* Set program_name size */\n                    lf->p_name_size = strlen(lf->program_name);\n\n                    pieces++;\n                }\n                /* Invalid program name */\n                else {\n                    lf->program_name = NULL;\n                    break;\n                }\n            }\n\n            /* Get message */\n            else if ((strncmp(pieces, \""Message \"", 8) == 0) &&\n                     (done_message == 0)) {\n                pieces += 8;\n                done_message = 1;\n\n                lf->log = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n                /* Invalid log closure */\n                else {\n                    break;\n                }\n            }\n\n            /* Get hostname */\n            else if (strncmp(pieces, \""Host \"", 5) == 0) {\n                pieces += 5;\n                lf->hostname = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n\n                /* Invalid hostname */\n                else {\n                    lf->hostname = NULL;\n                }\n                break;\n            }\n\n            /* Get next entry */\n            pieces = strchr(pieces, '[');\n        }\n    }\n\n    /* Check for squid date format\n     * 1140804070.368  11623\n     * seconds from 00:00:00 1970-01-01 UTC\n     */\n    else if ((loglen > 32) &&\n             (pieces[0] == '1') &&\n             (isdigit((int)pieces[1])) &&\n             (isdigit((int)pieces[2])) &&\n             (isdigit((int)pieces[3])) &&\n             (pieces[10] == '.') &&\n             (isdigit((int)pieces[13])) &&\n             (pieces[14] == ' ') &&\n             ((pieces[21] == ' ') || (pieces[22] == ' '))) {\n        lf->log += 14;\n\n        /* We need to start at the size of the event */\n        while (*lf->log == ' ') {\n            lf->log++;\n        }\n    }\n\n    /* Every message must be in the format\n     * hostname->location or\n     * (agent) ip->location.\n     */\n\n    /* Set hostname for local messages */\n    if (lf->location[0] == '(') {\n        /* Messages from an agent */\n        lf->hostname = lf->location;\n    } else if (lf->hostname == NULL) {\n        lf->hostname = __shost;\n    }\n\n    /* Set up the event data */\n    lf->time = c_time;\n    p = localtime(&c_time);\n\n    /* Assign hour, day, year and month values */\n    lf->day = p->tm_mday;\n    lf->year = p->tm_year + 1900;\n    strncpy(lf->mon, month[p->tm_mon], 3);\n    snprintf(lf->hour, 9, \""%02d:%02d:%02d\"",\n             p->tm_hour,\n             p->tm_min,\n             p->tm_sec);\n\n    /* Set the global hour/weekday */\n    __crt_hour = p->tm_hour;\n    __crt_wday = p->tm_wday;\n\n#ifdef TESTRULE\n    if (!alert_only) {\n        print_out(\""**Phase 1: Completed pre-decoding.\"");\n        print_out(\""       full event: '%s'\"", lf->full_log);\n        print_out(\""       hostname: '%s'\"", lf->hostname);\n        print_out(\""       program_name: '%s'\"", lf->program_name);\n        print_out(\""       log: '%s'\"", lf->log);\n    }\n#endif\n    return (0);\n}\n"", ""start_line"": 25, ""end_line"": 565, ""full_name"": ""OS_CleanMSG"", ""file_path"": ""src/analysisd/cleanevent.c""}]}, {""source"": ""code_info(file:cleanevent.c, lines:10-39)"", ""result"": ""#include \""cleanevent.h\""\n\n#include \""shared.h\""\n#include \""os_regex/os_regex.h\""\n#include \""analysisd.h\""\n#include \""fts.h\""\n#include \""config.h\""\n\n/* To translate between month (int) to month (char) */\nstatic const char *(month[]) = {\""Jan\"", \""Feb\"", \""Mar\"", \""Apr\"", \""May\"", \""Jun\"",\n                   \""Jul\"", \""Aug\"", \""Sep\"", \""Oct\"", \""Nov\"", \""Dec\""\n                  };\n\n\n/* Format a received message in the Eventinfo structure */\nint OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n""}, {""source"": ""value_info(file:cleanevent.c, value:msg)"", ""result"": {""value_trace"": [{""full_code"": ""msg += 2"", ""line"": 36, ""func_name"": ""OS_CleanMSG""}], ""struct_var"": ""msg"", ""struct_type"": ""char[OS_MAXSTR+1]"", ""struct_definition"": null}}, {""source"": ""code_info(file:cleanevent.c, lines:1-39)"", ""result"": ""/* Copyright (C) 2009 Trend Micro Inc.\n * All rights reserved.\n *\n * This program is a free software; you can redistribute it\n * and/or modify it under the terms of the GNU General Public\n * License (version 2) as published by the FSF - Free Software\n * Foundation.\n */\n\n#include \""cleanevent.h\""\n\n#include \""shared.h\""\n#include \""os_regex/os_regex.h\""\n#include \""analysisd.h\""\n#include \""fts.h\""\n#include \""config.h\""\n\n/* To translate between month (int) to month (char) */\nstatic const char *(month[]) = {\""Jan\"", \""Feb\"", \""Mar\"", \""Apr\"", \""May\"", \""Jun\"",\n                   \""Jul\"", \""Aug\"", \""Sep\"", \""Oct\"", \""Nov\"", \""Dec\""\n                  };\n\n\n/* Format a received message in the Eventinfo structure */\nint OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n""}, {""source"": ""value_info(file:cleanevent.c, value:msg)"", ""result"": {""value_trace"": [{""full_code"": ""msg += 2"", ""line"": 36, ""func_name"": ""OS_CleanMSG""}], ""struct_var"": ""msg"", ""struct_type"": ""char[OS_MAXSTR+1]"", ""struct_definition"": null}}, {""source"": ""func_info(func:OS_ReadMSG)"", ""result"": [{""code"": ""void OS_ReadMSG(int m_queue)\n#else\n__attribute__((noreturn))\nvoid OS_ReadMSG_analysisd(int m_queue)\n#endif\n{\n    int i;\n    char msg[OS_MAXSTR + 1];\n    Eventinfo *lf;\n\n    RuleInfo *stats_rule = NULL;\n\n    /* Null to global currently pointers */\n    currently_rule = NULL;\n\n    /* Initialize the logs */\n    OS_InitLog();\n\n    /* Initialize the integrity database */\n    SyscheckInit();\n\n    /* Initialize Rootcheck */\n    RootcheckInit();\n\n    /* Initialize host info */\n    HostinfoInit();\n\n    /* Create the event list */\n    OS_CreateEventList(Config.memorysize);\n\n    /* Initiate the FTS list */\n    if (!FTS_Init()) {\n        ErrorExit(FTS_LIST_ERROR, ARGV0);\n    }\n\n    /* Initialize the Accumulator */\n    if (!Accumulate_Init()) {\n        merror(\""accumulator: ERROR: Initialization failed\"");\n        exit(1);\n    }\n\n    /* Start the active response queues */\n    if (Config.ar) {\n        /* Waiting the ARQ to settle */\n        sleep(3);\n\n#ifndef LOCAL\n        if (Config.ar & REMOTE_AR) {\n            if ((arq = StartMQ(ARQUEUE, WRITE)) < 0) {\n                merror(ARQ_ERROR, ARGV0);\n\n                /* If LOCAL_AR is set, keep it there */\n                if (Config.ar & LOCAL_AR) {\n                    Config.ar = 0;\n                    Config.ar |= LOCAL_AR;\n                } else {\n                    Config.ar = 0;\n                }\n            } else {\n                verbose(CONN_TO, ARGV0, ARQUEUE, \""active-response\"");\n            }\n        }\n#else\n        /* Only for LOCAL_ONLY installs */\n        if (Config.ar & REMOTE_AR) {\n            if (Config.ar & LOCAL_AR) {\n                Config.ar = 0;\n                Config.ar |= LOCAL_AR;\n            } else {\n                Config.ar = 0;\n            }\n        }\n#endif\n\n        if (Config.ar & LOCAL_AR) {\n            if ((execdq = StartMQ(EXECQUEUE, WRITE)) < 0) {\n                merror(ARQ_ERROR, ARGV0);\n\n                /* If REMOTE_AR is set, keep it there */\n                if (Config.ar & REMOTE_AR) {\n                    Config.ar = 0;\n                    Config.ar |= REMOTE_AR;\n                } else {\n                    Config.ar = 0;\n                }\n            } else {\n                verbose(CONN_TO, ARGV0, EXECQUEUE, \""exec\"");\n            }\n        }\n    }\n    debug1(\""%s: DEBUG: Active response Init completed.\"", ARGV0);\n\n    /* Get current time before starting */\n    c_time = time(NULL);\n\n    /* Start the hourly/weekly stats */\n    if (Start_Hour() < 0) {\n        Config.stats = 0;\n    } else {\n        /* Initialize stats rules */\n        stats_rule = zerorulemember(\n                         STATS_MODULE,\n                         Config.stats,\n                         0, 0, 0, 0, 0, 0);\n\n        if (!stats_rule) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n        stats_rule->group = \""stats,\"";\n        stats_rule->comment = \""Excessive number of events (above normal).\"";\n    }\n\n    /* Do some cleanup */\n    memset(msg, '\\0', OS_MAXSTR + 1);\n\n    /* Initialize the logs */\n    {\n        lf = (Eventinfo *)calloc(1, sizeof(Eventinfo));\n        if (!lf) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n        os_calloc(Config.decoder_order_size, sizeof(char*), lf->fields);\n        lf->year = prev_year;\n        strncpy(lf->mon, prev_month, 3);\n        lf->day = today;\n\n        if (OS_GetLogLocation(lf) < 0) {\n            ErrorExit(\""%s: Error allocating log files\"", ARGV0);\n        }\n\n        Free_Eventinfo(lf);\n    }\n\n#ifdef SQLITE_ENABLED\n    /* Open the sqlite db */\n    extern sqlite3 *conn;\n    int s_error = 0;\n    if (Config.md5_allowlist) {\n        debug2(\""Opening md5_allowlist: %s\"", Config.md5_allowlist);\n        if((s_error = sqlite3_open(Config.md5_allowlist, &conn))) {\n            merror(INVALID_IGNORE_MD5DB, ARGV0, Config.md5_allowlist);\n        }\n\n    }\n#endif\n\n    debug1(\""%s: DEBUG: Startup completed. Waiting for new messages..\"", ARGV0);\n\n    if (Config.custom_alert_output) {\n        debug1(\""%s: INFO: Custom output found.!\"", ARGV0);\n    }\n\n    /* Daemon loop */\n    while (1) {\n        lf = (Eventinfo *)calloc(1, sizeof(Eventinfo));\n        os_calloc(Config.decoder_order_size, sizeof(char*), lf->fields);\n\n        /* This shouldn't happen */\n        if (lf == NULL) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n\n        DEBUG_MSG(\""%s: DEBUG: Waiting for msgs - %d \"", ARGV0, (int)time(0));\n\n        /* Receive message from queue */\n        if ((i = OS_RecvUnix(m_queue, OS_MAXSTR, msg))) {\n            RuleNode *rulenode_pt;\n\n            /* Get the time we received the event */\n            c_time = time(NULL);\n\n            /* Default values for the log info */\n            Zero_Eventinfo(lf);\n\n            /* Check for a valid message */\n            if (i < 4) {\n                merror(IMSG_ERROR, ARGV0, msg);\n                Free_Eventinfo(lf);\n                continue;\n            }\n\n            /* Message before extracting header */\n            DEBUG_MSG(\""%s: DEBUG: Received msg: %s \"", ARGV0, msg);\n\n            /* Clean the msg appropriately */\n            if (OS_CleanMSG(msg, lf) < 0) {\n                merror(IMSG_ERROR, ARGV0, msg);\n                Free_Eventinfo(lf);\n                continue;\n            }\n\n            /* Msg cleaned */\n            DEBUG_MSG(\""%s: DEBUG: Msg cleanup: %s \"", ARGV0, lf->log);\n\n            /* Current rule must be null in here */\n            currently_rule = NULL;\n\n            /** Check the date/hour changes **/\n\n            /* Update the hour */\n            if (thishour != __crt_hour) {\n                /* Search all the rules and print the number\n                 * of alerts that each one fired\n                 */\n                DumpLogstats();\n                thishour = __crt_hour;\n\n                /* Check if the date has changed */\n                if (today != lf->day) {\n                    if (Config.stats) {\n                        /* Update the hourly stats (done daily) */\n                        Update_Hour();\n                    }\n\n                    if (OS_GetLogLocation(lf) < 0) {\n                        ErrorExit(\""%s: Error allocating log files\"", ARGV0);\n                    }\n\n                    today = lf->day;\n                    strncpy(prev_month, lf->mon, 3);\n                    prev_year = lf->year;\n                }\n            }\n\n\n            /* Increment number of events received */\n            hourly_events++;\n\n            /***  Run decoders ***/\n\n            /* Integrity check from syscheck */\n            if (msg[0] == SYSCHECK_MQ) {\n                hourly_syscheck++;\n\n                if (!DecodeSyscheck(lf)) {\n                    /* We don't process syscheck events further */\n                    goto CLMEM;\n                }\n\n                /* Get log size */\n                lf->size = strlen(lf->log);\n            }\n\n            /* Rootcheck decoding */\n            else if (msg[0] == ROOTCHECK_MQ) {\n                if (!DecodeRootcheck(lf)) {\n                    /* We don't process rootcheck events further */\n                    goto CLMEM;\n                }\n                lf->size = strlen(lf->log);\n            }\n\n            /* Host information special decoder */\n            else if (msg[0] == HOSTINFO_MQ) {\n                if (!DecodeHostinfo(lf)) {\n                    /* We don't process hostinfo events further */\n                    goto CLMEM;\n                }\n                lf->size = strlen(lf->log);\n            }\n\n            /* Run the general Decoders */\n            else {\n                /* Get log size */\n                lf->size = strlen(lf->log);\n\n                DecodeEvent(lf);\n            }\n\n            /* Run accumulator */\n            if ( lf->decoder_info->accumulate == 1 ) {\n                lf = Accumulate(lf);\n            }\n\n            /* Firewall event */\n            if (lf->decoder_info->type == FIREWALL) {\n                /* If we could not get any information from\n                 * the log, just ignore it\n                 */\n                hourly_firewall++;\n                if (Config.logfw) {\n                    if (!FW_Log(lf)) {\n                        goto CLMEM;\n                    }\n                }\n            }\n\n            /* We only check if the last message is\n             * duplicated on syslog\n             */\n            else if (lf->decoder_info->type == SYSLOG) {\n                /* Check if the message is duplicated */\n                if (LastMsg_Stats(lf->full_log) == 1) {\n                    goto CLMEM;\n                } else {\n                    LastMsg_Change(lf->full_log);\n                }\n            }\n\n            /* Stats checking */\n            if (Config.stats) {\n                if (Check_Hour() == 1) {\n                    RuleInfo *saved_rule = lf->generated_rule;\n                    char *saved_log;\n\n                    /* Save previous log */\n                    saved_log = lf->full_log;\n\n                    lf->generated_rule = stats_rule;\n                    lf->full_log = __stats_comment;\n\n                    /* Alert for statistical analysis */\n                    if (stats_rule->alert_opts & DO_LOGALERT) {\n                        __crt_ftell = ftell(_aflog);\n                        if (Config.custom_alert_output) {\n                            OS_CustomLog(lf, Config.custom_alert_output_format);\n                        } else {\n                            OS_Log(lf);\n                        }\n                        /* Log to json file */\n                        if (Config.jsonout_output) {\n                            jsonout_output_event(lf);\n                        }\n\n                    }\n\n                    /* Set lf to the old values */\n                    lf->generated_rule = saved_rule;\n                    lf->full_log = saved_log;\n                }\n            }\n\n            /* Check the rules */\n            DEBUG_MSG(\""%s: DEBUG: Checking the rules - %d \"",\n                      ARGV0, lf->decoder_info->type);\n\n            /* Loop over all the rules */\n            rulenode_pt = OS_GetFirstRule();\n            if (!rulenode_pt) {\n                ErrorExit(\""%s: Rules in an inconsistent state. Exiting.\"",\n                          ARGV0);\n            }\n\n            do {\n                if (lf->decoder_info->type == OSSEC_ALERT) {\n                    if (!lf->generated_rule) {\n                        goto CLMEM;\n                    }\n\n                    /* Process the alert */\n                    currently_rule = lf->generated_rule;\n                }\n\n                /* Categories must match */\n                else if (rulenode_pt->ruleinfo->category !=\n                         lf->decoder_info->type) {\n                    continue;\n                }\n\n                /* Check each rule */\n                else if ((currently_rule = OS_CheckIfRuleMatch(lf, rulenode_pt))\n                         == NULL) {\n                    continue;\n                }\n\n                /* Ignore level 0 */\n                if (currently_rule->level == 0) {\n                    break;\n                }\n\n                /* Check ignore time */\n                if (currently_rule->ignore_time) {\n                    if (currently_rule->time_ignored == 0) {\n                        currently_rule->time_ignored = lf->time;\n                    }\n                    /* If the current time - the time the rule was ignored\n                     * is less than the time it should be ignored,\n                     * leave (do not alert again)\n                     */\n                    else if ((lf->time - currently_rule->time_ignored)\n                             < currently_rule->ignore_time) {\n                        break;\n                    } else {\n                        currently_rule->time_ignored = lf->time;\n                    }\n                }\n\n                /* Pointer to the rule that generated it */\n                lf->generated_rule = currently_rule;\n\n                /* Check if we should ignore it */\n                if (currently_rule->ckignore && IGnore(lf)) {\n                    /* Ignore rule */\n                    lf->generated_rule = NULL;\n                    break;\n                }\n\n                /* Check if we need to add to ignore list */\n                if (currently_rule->ignore) {\n                    AddtoIGnore(lf);\n                }\n\n                /* Log the alert if configured to */\n                if (currently_rule->alert_opts & DO_LOGALERT) {\n                    __crt_ftell = ftell(_aflog);\n\n                    if (Config.custom_alert_output) {\n                        OS_CustomLog(lf, Config.custom_alert_output_format);\n                    } else {\n                        OS_Log(lf);\n                    }\n                    /* Log to json file */\n                    if (Config.jsonout_output) {\n                        jsonout_output_event(lf);\n                    }\n                }\n\n#ifdef PRELUDE_OUTPUT_ENABLED\n                /* Log to prelude */\n                if (Config.prelude) {\n                    if (Config.prelude_log_level <= currently_rule->level) {\n                        OS_PreludeLog(lf);\n                    }\n                }\n#endif\n\n#ifdef ZEROMQ_OUTPUT_ENABLED\n                /* Log to zeromq */\n                if (Config.zeromq_output) {\n                    zeromq_output_event(lf);\n                }\n#endif\n\n\n                /* Execute an active response */\n                if (currently_rule->ar) {\n                    int do_ar;\n                    active_response **rule_ar;\n\n                    rule_ar = currently_rule->ar;\n\n                    while (*rule_ar) {\n                        do_ar = 1;\n                        if ((*rule_ar)->ar_cmd->expect & USERNAME) {\n                            if (!lf->dstuser ||\n                                    !OS_PRegex(lf->dstuser, \""^[a-zA-Z._0-9@?-]*$\"")) {\n                                if (lf->dstuser) {\n                                    merror(CRAFTED_USER, ARGV0, lf->dstuser);\n                                }\n                                do_ar = 0;\n                            }\n                        }\n                        if ((*rule_ar)->ar_cmd->expect & SRCIP) {\n                            if (!lf->srcip ||\n                                    !OS_PRegex(lf->srcip, \""^[a-zA-Z.:_0-9-]*$\"")) {\n                                if (lf->srcip) {\n                                    merror(CRAFTED_IP, ARGV0, lf->srcip);\n                                }\n                                do_ar = 0;\n                            }\n                        }\n                        if ((*rule_ar)->ar_cmd->expect & FILENAME) {\n                            if (!lf->filename) {\n                                do_ar = 0;\n                            }\n                        }\n\n                        if (do_ar && execdq > 0) {\n                            OS_Exec(execdq, arq, lf, *rule_ar);\n                        }\n                        rule_ar++;\n                    }\n                }\n\n                /* Copy the structure to the state memory of if_matched_sid */\n                if (currently_rule->sid_prev_matched) {\n                    if (!OSList_AddData(currently_rule->sid_prev_matched, lf)) {\n                        merror(\""%s: Unable to add data to sig list.\"", ARGV0);\n                    } else {\n                        lf->sid_node_to_delete =\n                            currently_rule->sid_prev_matched->last_node;\n                    }\n                }\n                /* Group list */\n                else if (currently_rule->group_prev_matched) {\n                    unsigned int j = 0;\n\n                    while (j < currently_rule->group_prev_matched_sz) {\n                        if (!OSList_AddData(\n                                    currently_rule->group_prev_matched[j],\n                                    lf)) {\n                            merror(\""%s: Unable to add data to grp list.\"", ARGV0);\n                        }\n                        j++;\n                    }\n                }\n\n                OS_AddEvent(lf);\n\n                break;\n\n            } while ((rulenode_pt = rulenode_pt->next) != NULL);\n\n            /* If configured to log all, do it */\n            if (Config.logall)\n                OS_Store(lf);\n            if (Config.logall_json)\n                jsonout_output_archive(lf);\n\nCLMEM:\n            /** Cleaning the memory **/\n\n            /* Only clear the memory if the eventinfo was not\n             * added to the stateful memory\n             * -- message is free inside clean event --\n             */\n            if (lf->generated_rule == NULL) {\n                Free_Eventinfo(lf);\n            }\n        } else {\n            free(lf);\n        }\n    }\n}\n"", ""start_line"": 528, ""end_line"": 1051, ""full_name"": ""OS_ReadMSG"", ""file_path"": ""src/analysisd/analysisd.c""}, {""code"": ""void OS_ReadMSG(char *ut_str)\n{\n    char msg[OS_MAXSTR + 1];\n    int exit_code = 0;\n    char *ut_alertlevel = NULL;\n    char *ut_rulelevel = NULL;\n    char *ut_decoder_name = NULL;\n\n    if (ut_str) {\n        /* XXX Break apart string */\n        ut_rulelevel = ut_str;\n        ut_alertlevel =  strchr(ut_rulelevel, ':');\n        if (!ut_alertlevel) {\n            ErrorExit(\""%s: -U requires the matching format to be \""\n                      \""\\\""<rule_id>:<alert_level>:<decoder_name>\\\""\"", ARGV0);\n        } else {\n            *ut_alertlevel = '\\0';\n            ut_alertlevel++;\n        }\n        ut_decoder_name = strchr(ut_alertlevel, ':');\n        if (!ut_decoder_name) {\n            ErrorExit(\""%s: -U requires the matching format to be \""\n                      \""\\\""<rule_id>:<alert_level>:<decoder_name>\\\""\"", ARGV0);\n        } else {\n            *ut_decoder_name = '\\0';\n            ut_decoder_name++;\n        }\n    }\n\n    RuleInfoDetail *last_info_detail;\n    Eventinfo *lf;\n\n    /* Null global pointer to current rule */\n    currently_rule = NULL;\n\n    /* Create the event list */\n    OS_CreateEventList(Config.memorysize);\n\n    /* Initiate the FTS list */\n    if (!FTS_Init()) {\n        ErrorExit(FTS_LIST_ERROR, ARGV0);\n    }\n\n    /* Initialize the Accumulator */\n    if (!Accumulate_Init()) {\n        merror(\""accumulator: ERROR: Initialization failed\"");\n        exit(1);\n    }\n\n    __crt_ftell = 1;\n\n    /* Get current time before starting */\n    c_time = time(NULL);\n\n    /* Do some cleanup */\n    memset(msg, '\\0', OS_MAXSTR + 1);\n\n    if (!alert_only) {\n        print_out(\""%s: Type one log per line.\\n\"", ARGV0);\n    }\n\n    /* Daemon loop */\n    while (1) {\n        lf = (Eventinfo *)calloc(1, sizeof(Eventinfo));\n        os_calloc(Config.decoder_order_size, sizeof(char*), lf->fields);\n\n\n        /* This shouldn't happen */\n        if (lf == NULL) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n\n        /* Fix the msg */\n        snprintf(msg, 15, \""1:stdin:\"");\n\n        /* Receive message from queue */\n        if (fgets(msg + 8, OS_MAXSTR - 8, stdin)) {\n            RuleNode *rulenode_pt;\n\n            /* Get the time we received the event */\n            c_time = time(NULL);\n\n            /* Remov newline */\n            if (msg[strlen(msg) - 1] == '\\n') {\n                msg[strlen(msg) - 1] = '\\0';\n            }\n\n            /* Make sure we ignore blank lines */\n            if (strlen(msg) < 10) {\n                continue;\n            }\n\n            if (!alert_only) {\n                print_out(\""\\n\"");\n            }\n\n            /* Default values for the log info */\n            Zero_Eventinfo(lf);\n\n            /* Clean the msg appropriately */\n            if (OS_CleanMSG(msg, lf) < 0) {\n                merror(IMSG_ERROR, ARGV0, msg);\n\n                Free_Eventinfo(lf);\n\n                continue;\n            }\n\n            /* Current rule must be null in here */\n            currently_rule = NULL;\n\n            /***  Run decoders ***/\n            /* Get log size */\n            lf->size = strlen(lf->log);\n\n            /* Decode event */\n            DecodeEvent(lf);\n\n            /* Run accumulator */\n            if ( lf->decoder_info->accumulate == 1 ) {\n                print_out(\""\\n**ACCUMULATOR: LEVEL UP!!**\\n\"");\n                lf = Accumulate(lf);\n            }\n\n            /* Loop over all the rules */\n            rulenode_pt = OS_GetFirstRule();\n            if (!rulenode_pt) {\n                ErrorExit(\""%s: Rules in an inconsistent state. Exiting.\"",\n                          ARGV0);\n            }\n\n#ifdef TESTRULE\n            if (full_output && !alert_only) {\n                print_out(\""\\n**Rule debugging:\"");\n            }\n#endif\n\n            do {\n                if (lf->decoder_info->type == OSSEC_ALERT) {\n                    if (!lf->generated_rule) {\n                        break;\n                    }\n\n                    /* Process the alert */\n                    currently_rule = lf->generated_rule;\n                }\n\n                /* The categories must match */\n                else if (rulenode_pt->ruleinfo->category !=\n                         lf->decoder_info->type) {\n                    continue;\n                }\n\n                /* Check each rule */\n                else if ((currently_rule = OS_CheckIfRuleMatch(lf, rulenode_pt))\n                         == NULL) {\n                    continue;\n                }\n\n#ifdef TESTRULE\n                if (!alert_only) {\n                    const char *(ruleinfodetail_text[]) = {\""Text\"", \""Link\"", \""CVE\"", \""OSVDB\"", \""BUGTRACKID\""};\n                    print_out(\""\\n**Phase 3: Completed filtering (rules).\"");\n                    print_out(\""       Rule id: '%d'\"", currently_rule->sigid);\n                    print_out(\""       Level: '%d'\"", currently_rule->level);\n                    print_out(\""       Description: '%s'\"", currently_rule->comment);\n                    for (last_info_detail = currently_rule->info_details; last_info_detail != NULL; last_info_detail = last_info_detail->next) {\n                        print_out(\""       Info - %s: '%s'\"", ruleinfodetail_text[last_info_detail->type], last_info_detail->data);\n                    }\n                }\n#endif\n\n                /* Ignore level 0 */\n                if (currently_rule->level == 0) {\n                    break;\n                }\n\n                /* Check ignore time */\n                if (currently_rule->ignore_time) {\n                    if (currently_rule->time_ignored == 0) {\n                        currently_rule->time_ignored = lf->time;\n                    }\n                    /* If the current time - the time the rule was ignored\n                     * is less than the time it should be ignored,\n                     * do not alert again\n                     */\n                    else if ((lf->time - currently_rule->time_ignored)\n                             < currently_rule->ignore_time) {\n                        break;\n                    } else {\n                        currently_rule->time_ignored = 0;\n                    }\n                }\n\n                /* Pointer to the rule that generated it */\n                lf->generated_rule = currently_rule;\n\n\n                /* Check if we should ignore it */\n                if (currently_rule->ckignore && IGnore(lf)) {\n                    lf->generated_rule = NULL;\n                    break;\n                }\n\n                /* Check if we need to add to ignore list */\n                if (currently_rule->ignore) {\n                    AddtoIGnore(lf);\n                }\n\n                /* Log the alert if configured to */\n                if (currently_rule->alert_opts & DO_LOGALERT) {\n                    if (alert_only) {\n                        OS_LogOutput(lf);\n                        __crt_ftell++;\n                    } else {\n                        print_out(\""**Alert to be generated.\\n\\n\"");\n                    }\n                }\n\n                /* Copy the structure to the state memory of if_matched_sid */\n                if (currently_rule->sid_prev_matched) {\n                    if (!OSList_AddData(currently_rule->sid_prev_matched, lf)) {\n                        merror(\""%s: Unable to add data to sig list.\"", ARGV0);\n                    } else {\n                        lf->sid_node_to_delete =\n                            currently_rule->sid_prev_matched->last_node;\n                    }\n                }\n\n                /* Group list */\n                else if (currently_rule->group_prev_matched) {\n                    unsigned int i = 0;\n\n                    while (i < currently_rule->group_prev_matched_sz) {\n                        if (!OSList_AddData(\n                                    currently_rule->group_prev_matched[i],\n                                    lf)) {\n                            merror(\""%s: Unable to add data to grp list.\"", ARGV0);\n                        }\n                        i++;\n                    }\n                }\n\n                OS_AddEvent(lf);\n                break;\n\n            } while ((rulenode_pt = rulenode_pt->next) != NULL);\n\n            if (ut_str) {\n                /* Set up exit code if we are doing unit testing */\n                char holder[1024];\n                holder[1] = '\\0';\n                exit_code = 3;\n                print_out(\""lf->decoder_info->name: '%s'\"", lf->decoder_info->name);\n                print_out(\""ut_decoder_name       : '%s'\"", ut_decoder_name);\n                if (lf->decoder_info->name != NULL && strcasecmp(ut_decoder_name, lf->decoder_info->name) == 0) {\n                    exit_code--;\n\n                    if (!currently_rule) {\n                        merror(\""%s: currently_rule not set!\"", ARGV0);\n                        exit(-1);\n                    }\n                    snprintf(holder, 1023, \""%d\"", currently_rule->sigid);\n                    if (strcasecmp(ut_rulelevel, holder) == 0) {\n                        exit_code--;\n                        snprintf(holder, 1023, \""%d\"", currently_rule->level);\n                        if (strcasecmp(ut_alertlevel, holder) == 0) {\n                            exit_code--;\n                            printf(\""%d\\n\"", exit_code);\n                        }\n                    }\n                } else if (lf->decoder_info->name != NULL) {\n                    print_out(\""decoder matched : '%s'\"", lf->decoder_info->name);\n                    print_out(\""decoder expected: '%s'\"", ut_decoder_name);\n                } else {\n                    print_out(\""decoder matched : 'NULL'\"");\n                }\n            }\n\n            /* Only clear the memory if the eventinfo was not\n             * added to the stateful memory\n             * -- message is free inside clean event --\n             */\n            if (lf->generated_rule == NULL) {\n                Free_Eventinfo(lf);\n            }\n\n        } else {\n            exit(exit_code);\n        }\n    }\n    exit(exit_code);\n}\n"", ""start_line"": 332, ""end_line"": 624, ""full_name"": ""OS_ReadMSG<duplicate>0"", ""file_path"": ""src/analysisd/testrule.c""}]}]","src/analysisd/cleanevent.c:336-345: 'pieces' is advanced by 2 after 'pieces = strchr(pieces, ']')' without verifying sufficient buffer space. If the ']' is at the final character position, 'pieces += 2' causes an off-by-one overflow. The patch uses 'strstr(pieces, ""] "")' to ensure two characters are present before advancing. 'pieces' is initialized as 'pieces = strchr(msg, ':')' (line 39), and 'msg' is declared as char[OS_MAXSTR+1] in OS_ReadMSG (line 535).",0.95,./github/other_context/CVE-2020-8443
28,CVE-2021-20300,CWE-190,c_cpp,"A flaw was found in OpenEXR's hufUncompress functionality in OpenEXR/IlmImf/ImfHuf.cpp. This flaw allows an attacker who can submit a crafted file that is processed by OpenEXR, to trigger an integer overflow. The highest threat from this vulnerability is to system availability.",https://github.com/AcademySoftwareFoundation/openexr/commit/653176c8d147a34395cb24fb9cfadde83219b643,prevent overflow in hufUncompress if nBits is large\n\nSigned-off-by: Peter Hillman <peterh@wetafx.co.nz>,1,"[{""func_name"": ""hufUncompress"", ""file_path"": ""OpenEXR/IlmImf/ImfHuf.cpp"", ""func_code"": ""void\nhufUncompress (const char compressed[],\n\t       int nCompressed,\n\t       unsigned short raw[],\n\t       int nRaw)\n{\n    //\n    // need at least 20 bytes for header\n    //\n    if (nCompressed < 20 )\n    {\n\tif (nRaw != 0)\n\t    notEnoughData();\n\n\treturn;\n    }\n\n    int im = readUInt (compressed);\n    int iM = readUInt (compressed + 4);\n    // int tableLength = readUInt (compressed + 8);\n    int nBits = readUInt (compressed + 12);\n\n    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)\n\tinvalidTableSize();\n\n    const char *ptr = compressed + 20;\n\n    if ( ptr + (nBits+7 )/8 > compressed+nCompressed)\n    {\n        notEnoughData();\n        return;\n    }\n\n    // \n    // Fast decoder needs at least 2x64-bits of compressed data, and\n    // needs to be run-able on this platform. Otherwise, fall back\n    // to the original decoder\n    //\n\n    if (FastHufDecoder::enabled() && nBits > 128)\n    {\n        FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);\n        fhd.decode ((unsigned char*)ptr, nBits, raw, nRaw);\n    }\n    else\n    {\n        AutoArray <Int64, HUF_ENCSIZE> freq;\n        AutoArray <HufDec, HUF_DECSIZE> hdec;\n\n        hufClearDecTable (hdec);\n\n        hufUnpackEncTable (&ptr,\n                           nCompressed - (ptr - compressed),\n                           im,\n                           iM,\n                           freq);\n\n        try\n        {\n            if (nBits > 8 * (nCompressed - (ptr - compressed)))\n                invalidNBits();\n\n            hufBuildDecTable (freq, im, iM, hdec);\n            hufDecode (freq, hdec, ptr, nBits, iM, nRaw, raw);\n        }\n        catch (...)\n        {\n            hufFreeDecTable (hdec);\n            throw;\n        }\n\n        hufFreeDecTable (hdec);\n    }\n}"", ""target"": 0}]","[{""func_name"": ""hufUncompress"", ""file_path"": ""OpenEXR/IlmImf/ImfHuf.cpp"", ""func_code"": ""void\nhufUncompress (const char compressed[],\n\t       int nCompressed,\n\t       unsigned short raw[],\n\t       int nRaw)\n{\n    //\n    // need at least 20 bytes for header\n    //\n    if (nCompressed < 20 )\n    {\n\tif (nRaw != 0)\n\t    notEnoughData();\n\n\treturn;\n    }\n\n    int im = readUInt (compressed);\n    int iM = readUInt (compressed + 4);\n    // int tableLength = readUInt (compressed + 8);\n    int nBits = readUInt (compressed + 12);\n\n    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)\n\tinvalidTableSize();\n\n    const char *ptr = compressed + 20;\n\n    uint64_t nBytes = (static_cast<uint64_t>(nBits)+7) / 8 ;\n\n    if ( ptr + nBytes > compressed+nCompressed)\n    {\n        notEnoughData();\n        return;\n    }\n\n    // \n    // Fast decoder needs at least 2x64-bits of compressed data, and\n    // needs to be run-able on this platform. Otherwise, fall back\n    // to the original decoder\n    //\n\n    if (FastHufDecoder::enabled() && nBits > 128)\n    {\n        FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);\n        fhd.decode ((unsigned char*)ptr, nBits, raw, nRaw);\n    }\n    else\n    {\n        AutoArray <Int64, HUF_ENCSIZE> freq;\n        AutoArray <HufDec, HUF_DECSIZE> hdec;\n\n        hufClearDecTable (hdec);\n\n        hufUnpackEncTable (&ptr,\n                           nCompressed - (ptr - compressed),\n                           im,\n                           iM,\n                           freq);\n\n        try\n        {\n            if (nBits > 8 * (nCompressed - (ptr - compressed)))\n                invalidNBits();\n\n            hufBuildDecTable (freq, im, iM, hdec);\n            hufDecode (freq, hdec, ptr, nBits, iM, nRaw, raw);\n        }\n        catch (...)\n        {\n            hufFreeDecTable (hdec);\n            throw;\n        }\n\n        hufFreeDecTable (hdec);\n    }\n}""}]","{""value"": 2, ""function"": 1}","[{""source"": ""value_info(file:ImfHuf.cpp, value:nBits)"", ""result"": {""value_trace"": [{""full_code"": ""nBits = hufEncode (freq, raw, nRaw, iM, dataStart)"", ""line"": 1056, ""func_name"": ""Imf.hufCompress:int(shortunsigned[],int,char[])""}, {""full_code"": ""nBits = readUInt (compressed + 12)"", ""line"": 1089, ""func_name"": ""Imf.hufUncompress:void(char[],int,shortunsigned[],int)""}], ""struct_var"": ""nBits"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""func_info(file:ImfHuf.cpp, func:readUInt)"", ""result"": [{""code"": ""unsigned int\nreadUInt (const char buf[4])\n{\n    const unsigned char *b = (const unsigned char *) buf;\n\n    return ( b[0]        & 0x000000ff) |\n\t   ((b[1] <<  8) & 0x0000ff00) |\n\t   ((b[2] << 16) & 0x00ff0000) |\n\t   ((b[3] << 24) & 0xff000000);\n}"", ""start_line"": 1015, ""end_line"": 1024, ""full_name"": ""Imf.readUInt:unsigned int(char[4])"", ""file_path"": ""OpenEXR/IlmImf/ImfHuf.cpp""}]}, {""source"": ""value_info(file:ImfHuf.cpp, value:nBits)"", ""result"": {""value_trace"": [{""full_code"": ""nBits = hufEncode (freq, raw, nRaw, iM, dataStart)"", ""line"": 1056, ""func_name"": ""Imf.hufCompress:int(shortunsigned[],int,char[])""}, {""full_code"": ""nBits = readUInt (compressed + 12)"", ""line"": 1089, ""func_name"": ""Imf.hufUncompress:void(char[],int,shortunsigned[],int)""}], ""struct_var"": ""nBits"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}]","OpenEXR/IlmImf/ImfHuf.cpp:1094-1096: `nBits` is declared as `int` but assigned from `readUInt` (returning `unsigned int`). For values exceeding `INT_MAX`, converting to `int` leads to undefined behavior. Adding 7 to such `nBits` causes overflow during `(nBits + 7)/8`, resulting in incorrect buffer size calculation. The patch introduces `uint64_t` to prevent overflow during arithmetic.",0.95,./github/other_context/CVE-2021-20300
29,CVE-2021-31571,CWE-190,c_cpp,The kernel in Amazon Web Services FreeRTOS before 10.4.3 has an integer overflow in queue.c for queue creation.,https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/47338393f1f79558f6144213409f09f81d7c4837,add assert for addition overflow on queue creation (#225),1,"[{""func_name"": ""xQueueGenericCreate"", ""file_path"": ""queue.c"", ""func_code"": ""QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\n                                       const UBaseType_t uxItemSize,\n                                       const uint8_t ucQueueType )\n    {\n        Queue_t * pxNewQueue;\n        size_t xQueueSizeInBytes;\n        uint8_t * pucQueueStorage;\n\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\n\n        /* Allocate enough space to hold the maximum number of items that\n         * can be in the queue at any time.  It is valid for uxItemSize to be\n         * zero in the case the queue is used as a semaphore. */\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n\n        /* Check for multiplication overflow. */\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\n\n        /* Allocate the queue and storage area.  Justification for MISRA\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\n         * blocks are aligned per the requirements of the MCU stack.  In this case\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\n         * alignment requirements of the Queue_t structure - which in this case\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\n         * are greater than or equal to the pointer to char requirements the cast\n         * is safe.  In other cases alignment requirements are not strict (one or\n         * two bytes). */\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\n\n        if( pxNewQueue != NULL )\n        {\n            /* Jump past the queue structure to find the location of the queue\n             * storage area. */\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\n            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\n\n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\n                {\n                    /* Queues can be created either statically or dynamically, so\n                     * note this task was created dynamically in case it is later\n                     * deleted. */\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\n                }\n            #endif /* configSUPPORT_STATIC_ALLOCATION */\n\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\n        }\n        else\n        {\n            traceQUEUE_CREATE_FAILED( ucQueueType );\n            mtCOVERAGE_TEST_MARKER();\n        }\n\n        return pxNewQueue;\n    }"", ""target"": 0}]","[{""func_name"": ""xQueueGenericCreate"", ""file_path"": ""queue.c"", ""func_code"": ""QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\n                                       const UBaseType_t uxItemSize,\n                                       const uint8_t ucQueueType )\n    {\n        Queue_t * pxNewQueue;\n        size_t xQueueSizeInBytes;\n        uint8_t * pucQueueStorage;\n\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\n\n        /* Allocate enough space to hold the maximum number of items that\n         * can be in the queue at any time.  It is valid for uxItemSize to be\n         * zero in the case the queue is used as a semaphore. */\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n\n        /* Check for multiplication overflow. */\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\n\n        /* Check for addition overflow. */\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\n\n        /* Allocate the queue and storage area.  Justification for MISRA\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\n         * blocks are aligned per the requirements of the MCU stack.  In this case\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\n         * alignment requirements of the Queue_t structure - which in this case\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\n         * are greater than or equal to the pointer to char requirements the cast\n         * is safe.  In other cases alignment requirements are not strict (one or\n         * two bytes). */\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\n\n        if( pxNewQueue != NULL )\n        {\n            /* Jump past the queue structure to find the location of the queue\n             * storage area. */\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\n            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\n\n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\n                {\n                    /* Queues can be created either statically or dynamically, so\n                     * note this task was created dynamically in case it is later\n                     * deleted. */\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\n                }\n            #endif /* configSUPPORT_STATIC_ALLOCATION */\n\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\n        }\n        else\n        {\n            traceQUEUE_CREATE_FAILED( ucQueueType );\n            mtCOVERAGE_TEST_MARKER();\n        }\n\n        return pxNewQueue;\n    }""}]","{""code"": 1, ""value"": 1}","[{""source"": ""code_info(file:queue.c, lines:380-410)"", ""result"": ""#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\n    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\n                                       const UBaseType_t uxItemSize,\n                                       const uint8_t ucQueueType )\n    {\n        Queue_t * pxNewQueue;\n        size_t xQueueSizeInBytes;\n        uint8_t * pucQueueStorage;\n\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\n\n        /* Allocate enough space to hold the maximum number of items that\n         * can be in the queue at any time.  It is valid for uxItemSize to be\n         * zero in the case the queue is used as a semaphore. */\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n\n        /* Check for multiplication overflow. */\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\n\n        /* Allocate the queue and storage area.  Justification for MISRA\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\n         * blocks are aligned per the requirements of the MCU stack.  In this case\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\n         * alignment requirements of the Queue_t structure - which in this case\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\n         * are greater than or equal to the pointer to char requirements the cast\n         * is safe.  In other cases alignment requirements are not strict (one or\n         * two bytes). */\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\n\n        if( pxNewQueue != NULL )\n""}, {""source"": ""value_info(file:queue.c, value:xQueueSizeInBytes)"", ""result"": {""value_trace"": [{""full_code"": ""xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize )"", ""line"": 395, ""func_name"": ""xQueueGenericCreate""}], ""struct_var"": ""xQueueSizeInBytes"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}]","queue.c:399: Unchecked addition overflow in `sizeof(Queue_t) + xQueueSizeInBytes` during memory allocation. `xQueueSizeInBytes` is computed as `uxQueueLength * uxItemSize` (queue.c:395), with a prior multiplication overflow check (queue.c:397). The patch added an assertion (queue.c:399) to detect addition overflow, confirming the vulnerability was caused by insufficient validation of this sum before `pvPortMalloc` (queue.c:406).",0.95,./github/other_context/CVE-2021-31571
30,CVE-2021-32559,CWE-190,c_cpp,An integer overflow exists in pywin32 prior to version b301 when adding an access control entry (ACE) to an access control list (ACL) that would cause the size to be greater than 65535 bytes. An attacker who successfully exploited this vulnerability could crash the vulnerable process.,https://github.com/mhammond/pywin32/commit/b860822ad233304fceefc4644bd353087a5309ec,PyACL - Fixing integer overflows that occur when resizing ACLs\n\nFixes #1700\nCVE-2021-32559,6,"[{""func_name"": ""addobjectace"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *addobjectace(addobjectacefunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags,\n                       DWORD access, PyObject *obObjectTypeGuid, PyObject *obInheritedObjectTypeGuid, PyObject *obSID)\n{\n    /* AddAccessAllowedObjectAce and AddAccessDeniedObjectAce have same parameters */\n    BOOL bsuccess;\n    PACL pdacl = This->GetACL();\n    PACL pdacl_padded = NULL;\n    PSID psid;\n    GUID ObjectTypeGuid, InheritedObjectTypeGuid;\n    GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL;\n\n    if (addfunc == NULL)\n        return PyErr_Format(PyExc_NotImplementedError, \""%s not supported by this version of Windows\"", funcname);\n    if (obObjectTypeGuid != Py_None) {\n        if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid))\n            return NULL;\n        pObjectTypeGuid = &ObjectTypeGuid;\n    }\n    if (obInheritedObjectTypeGuid != Py_None) {\n        if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid))\n            return NULL;\n        pInheritedObjectTypeGuid = &InheritedObjectTypeGuid;\n    }\n\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n\n    bsuccess = (*addfunc)(pdacl, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid);\n    if (bsuccess)\n        bsuccess = _ReorderACL(pdacl);\n    else {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(funcname, err);\n        // resize if dacl too small\n        unsigned short required_size =\n            pdacl->AclSize + sizeof(ACCESS_ALLOWED_OBJECT_ACE) + (unsigned short)GetLengthSid(psid);\n        pdacl_padded = (ACL *)malloc(required_size);\n        if (pdacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \""%s: unable to allocated %d bytes\"", funcname, required_size);\n\n        ZeroMemory(pdacl_padded, required_size);\n        memcpy(pdacl_padded, pdacl, pdacl->AclSize);\n        pdacl_padded->AclSize = required_size;\n        bsuccess =\n            (*addfunc)(pdacl_padded, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid);\n        if (bsuccess) {\n            bsuccess = _ReorderACL(pdacl_padded);\n            if (bsuccess)\n                bsuccess = This->SetACL(pdacl_padded);\n        }\n        else\n            PyWin_SetAPIError(funcname);\n    }\n    if (pdacl_padded)\n        free(pdacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}"", ""target"": 0}, {""func_name"": ""PyACL::AddAuditAccessAce"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *PyACL::AddAuditAccessAce(PyObject *self, PyObject *args)\n{\n    DWORD accessmask, acerevision;\n    BOOL bAuditSuccess, bAuditFailure;\n    PyObject *obSID;\n    PSID psid;\n    PACL psacl;\n    PyACL *This = (PyACL *)self;\n    psacl = This->GetACL();\n    PACL psacl_padded = NULL;\n    BOOL bsuccess;\n    // @pyparm int|dwAceRevision||Revision of ACL: Pre-Win2k, must be ACL_REVISION. Win2K on up, can also be\n    // ACL_REVISION_DS\n    // @pyparm int|dwAccessMask||Bitmask of access types to be audited\n    // @pyparm <o PySID>|sid||SID for whom system audit messages will be generated\n    // @pyparm int|bAuditSuccess||Set to 1 if access success should be audited, else 0\n    // @pyparm int|bAuditFailure||Set to 1 if access failure should be audited, else 0\n\n    if (!PyArg_ParseTuple(args, \""llOii:AddAuditAccessAce\"", &acerevision, &accessmask, &obSID, &bAuditSuccess,\n                          &bAuditFailure))\n        return NULL;\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n    bsuccess = ::AddAuditAccessAce(psacl, acerevision, accessmask, psid, bAuditSuccess, bAuditFailure);\n    if (!bsuccess) {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(\""AddAuditAccessAce\"", err);\n        // resize if acl too small\n        unsigned short required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + (unsigned short)GetLengthSid(psid);\n        psacl_padded = (ACL *)malloc(required_size);\n        if (psacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \""AddAuditAccessAce: unable to allocated %d bytes\"", required_size);\n\n        ZeroMemory(psacl_padded, required_size);\n        memcpy(psacl_padded, psacl, psacl->AclSize);\n        psacl_padded->AclSize = required_size;\n        bsuccess = ::AddAuditAccessAce(psacl_padded, acerevision, accessmask, psid, bAuditSuccess, bAuditFailure);\n        if (bsuccess)\n            bsuccess = This->SetACL(psacl_padded);\n        else\n            PyWin_SetAPIError(\""AddAuditAccessAce\"");\n    }\n\n    if (psacl_padded)\n        free(psacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}"", ""target"": 0}, {""func_name"": ""addaceex"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *addaceex(addaceexfunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags, DWORD access,\n                   PyObject *obSID)\n{\n    /* AddAccessAllowedAceEx and AddAccessDeniedAceEx have the same signature and semantics */\n    if (addfunc == NULL)\n        return PyErr_Format(PyExc_NotImplementedError, \""%s not supported by this version of Windows\"", funcname);\n    PSID psid;\n    BOOL bsuccess;\n    PACL pacl = This->GetACL();\n    PACL pacl_padded = NULL;\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n\n    bsuccess = (*addfunc)(pacl, revision, aceflags, access, psid);\n    if (bsuccess)\n        bsuccess = _ReorderACL(pacl);\n    else {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(funcname, err);\n        // resize if dacl too small\n        unsigned short required_size = pacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + (unsigned short)GetLengthSid(psid);\n        pacl_padded = (ACL *)malloc(required_size);\n        if (pacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \""%s: unable to allocated %d bytes\"", funcname, required_size);\n\n        ZeroMemory(pacl_padded, required_size);\n        memcpy(pacl_padded, pacl, pacl->AclSize);\n        pacl_padded->AclSize = required_size;\n        bsuccess = (*addfunc)(pacl_padded, revision, aceflags, access, psid);\n        if (bsuccess) {\n            bsuccess = _ReorderACL(pacl_padded);\n            if (bsuccess)\n                bsuccess = This->SetACL(pacl_padded);\n        }\n        else\n            PyWin_SetAPIError(funcname);\n    }\n    if (pacl_padded)\n        free(pacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}"", ""target"": 0}, {""func_name"": ""PyACL::AddAuditAccessAceEx"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *PyACL::AddAuditAccessAceEx(PyObject *self, PyObject *args)\n{\n    DWORD accessmask, acerevision, aceflags;\n    BOOL bAuditSuccess, bAuditFailure;\n    PyObject *obSID;\n    PSID psid;\n    PACL psacl;\n    PyACL *This = (PyACL *)self;\n    psacl = This->GetACL();\n    PACL psacl_padded = NULL;\n    BOOL bsuccess;\n    if (addauditaccessaceex == NULL)\n        return PyErr_Format(PyExc_NotImplementedError, \""AddAuditAccessAceEx not supported by this version of Windows\"");\n\n    // @pyparm int|dwAceRevision||Revision of ACL: Must be at least ACL_REVISION_DS\n    // @pyparm int|AceFlags||Combination of\n    // FAILED_ACCESS_ACE_FLAG,SUCCESSFUL_ACCESS_ACE_FLAG,CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE\n    // and OBJECT_INHERIT_ACE\n    // @pyparm int|dwAccessMask||Bitmask of access types to be audited\n    // @pyparm <o PySID>|sid||SID for whom system audit messages will be generated\n    // @pyparm int|bAuditSuccess||Set to 1 if access success should be audited, else 0\n    // @pyparm int|bAuditFailure||Set to 1 if access failure should be audited, else 0\n\n    if (!PyArg_ParseTuple(args, \""lllOii:AddAuditAccessAceEx\"", &acerevision, &aceflags, &accessmask, &obSID,\n                          &bAuditSuccess, &bAuditFailure))\n        return NULL;\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n    bsuccess = (*addauditaccessaceex)(psacl, acerevision, aceflags, accessmask, psid, bAuditSuccess, bAuditFailure);\n    if (!bsuccess) {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(\""AddAuditAccessAceEx\"", err);\n        // resize if acl too small\n        unsigned short required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + (unsigned short)GetLengthSid(psid);\n        psacl_padded = (ACL *)malloc(required_size);\n        if (psacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \""AddAuditAccessAceEx: unable to allocated %d bytes\"", required_size);\n\n        ZeroMemory(psacl_padded, required_size);\n        memcpy(psacl_padded, psacl, psacl->AclSize);\n        psacl_padded->AclSize = required_size;\n        bsuccess =\n            (*addauditaccessaceex)(psacl_padded, acerevision, aceflags, accessmask, psid, bAuditSuccess, bAuditFailure);\n        if (bsuccess)\n            bsuccess = This->SetACL(psacl_padded);\n        else\n            PyWin_SetAPIError(\""AddAuditAccessAceEx\"");\n    }\n\n    if (psacl_padded)\n        free(psacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}"", ""target"": 0}, {""func_name"": ""addaceorig"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *addaceorig(addacefunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD access, PyObject *obSID)\n{\n    /* AddAccessAllowedAce and AddAccessDeniedAce operate exactly the same */\n    PACL pdacl = This->GetACL();\n    PACL pdacl_padded = NULL;\n    BOOL bsuccess;\n    PSID psid;\n    if (addfunc == NULL)\n        return PyErr_Format(PyExc_NotImplementedError, \""%s not supported by this version of Windows\"", funcname);\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n\n    bsuccess = (*addfunc)(pdacl, revision, access, psid);\n    if (bsuccess)\n        bsuccess = _ReorderACL(pdacl);\n    else {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(funcname, err);\n        // resize if dacl too small\n        unsigned short required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + (unsigned short)GetLengthSid(psid);\n        pdacl_padded = (ACL *)malloc(required_size);\n        if (pdacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \""%s: unable to allocated %d bytes\"", funcname, required_size);\n\n        ZeroMemory(pdacl_padded, required_size);\n        memcpy(pdacl_padded, pdacl, pdacl->AclSize);\n        pdacl_padded->AclSize = required_size;\n        bsuccess = (*addfunc)(pdacl_padded, revision, access, psid);\n        if (bsuccess) {\n            bsuccess = _ReorderACL(pdacl_padded);\n            if (bsuccess)\n                bsuccess = This->SetACL(pdacl_padded);\n        }\n        else\n            PyWin_SetAPIError(funcname);\n    }\n\n    if (pdacl_padded)\n        free(pdacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}"", ""target"": 0}, {""func_name"": ""PyACL::AddAuditAccessObjectAce"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *PyACL::AddAuditAccessObjectAce(PyObject *self, PyObject *args)\n{\n    DWORD accessmask, acerevision, aceflags;\n    BOOL bAuditSuccess, bAuditFailure;\n    PyObject *obSID;\n    GUID ObjectTypeGuid, InheritedObjectTypeGuid;\n    GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL;\n    PyObject *obObjectTypeGuid, *obInheritedObjectTypeGuid;\n    BOOL bsuccess;\n    PSID psid;\n    PACL psacl;\n    PyACL *This = (PyACL *)self;\n    psacl = This->GetACL();\n    PACL psacl_padded = NULL;\n    if (addauditaccessobjectace == NULL)\n        return PyErr_Format(PyExc_NotImplementedError,\n                            \""AddAuditAccessObjectAce not supported by this version of Windows\"");\n\n    // @pyparm int|dwAceRevision||Revision of ACL: Must be at least ACL_REVISION_DS\n    // @pyparm int|AceFlags||Combination of\n    // FAILED_ACCESS_ACE_FLAG,SUCCESSFUL_ACCESS_ACE_FLAG,CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE\n    // and OBJECT_INHERIT_ACE\n    // @pyparm int|dwAccessMask||Bitmask of access types to be audited\n    // @pyparm <o PyIID>|ObjectTypeGuid||GUID of object type or property set to which ace applies, can be None\n    // @pyparm <o PyIID>|InheritedObjectTypeGuid||GUID of object type or property that will inherit ACE, can be None\n    // @pyparm <o PySID>|sid||SID for whom system audit messages will be generated\n    // @pyparm int|bAuditSuccess||Set to 1 if access success should be audited, else 0\n    // @pyparm int|bAuditFailure||Set to 1 if access failure should be audited, else 0\n\n    if (!PyArg_ParseTuple(args, \""lllOOOii:AddAuditAccessObjectAce\"", &acerevision, &aceflags, &accessmask,\n                          &obObjectTypeGuid, &obInheritedObjectTypeGuid, &obSID, &bAuditSuccess, &bAuditFailure))\n        return NULL;\n    if (obObjectTypeGuid != Py_None) {\n        if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid))\n            return NULL;\n        pObjectTypeGuid = &ObjectTypeGuid;\n    }\n    if (obInheritedObjectTypeGuid != Py_None) {\n        if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid))\n            return NULL;\n        pInheritedObjectTypeGuid = &InheritedObjectTypeGuid;\n    }\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n\n    bsuccess = (*addauditaccessobjectace)(psacl, acerevision, aceflags, accessmask, pObjectTypeGuid,\n                                          pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure);\n    if (!bsuccess) {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(\""AddAuditAccessObjectAce\"", err);\n        // resize if acl too small\n        unsigned short required_size =\n            psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + (unsigned short)GetLengthSid(psid);\n        psacl_padded = (ACL *)malloc(required_size);\n        if (psacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \""AddAuditAccessObjectAce: unable to allocated %d bytes\"",\n                                required_size);\n\n        ZeroMemory(psacl_padded, required_size);\n        memcpy(psacl_padded, psacl, psacl->AclSize);\n        psacl_padded->AclSize = required_size;\n        bsuccess = (*addauditaccessobjectace)(psacl_padded, acerevision, aceflags, accessmask, pObjectTypeGuid,\n                                              pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure);\n        if (bsuccess)\n            bsuccess = This->SetACL(psacl_padded);\n        else\n            PyWin_SetAPIError(\""AddAuditAccessObjectAce\"");\n    }\n    if (psacl_padded)\n        free(psacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}"", ""target"": 0}]","[{""func_name"": ""addobjectace"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *addobjectace(addobjectacefunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags,\n                       DWORD access, PyObject *obObjectTypeGuid, PyObject *obInheritedObjectTypeGuid, PyObject *obSID)\n{\n    /* AddAccessAllowedObjectAce and AddAccessDeniedObjectAce have same parameters */\n    BOOL bsuccess;\n    PACL pdacl = This->GetACL();\n    PACL pdacl_padded = NULL;\n    PSID psid;\n    GUID ObjectTypeGuid, InheritedObjectTypeGuid;\n    GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL;\n\n    if (addfunc == NULL)\n        return PyErr_Format(PyExc_NotImplementedError, \""%s not supported by this version of Windows\"", funcname);\n    if (obObjectTypeGuid != Py_None) {\n        if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid))\n            return NULL;\n        pObjectTypeGuid = &ObjectTypeGuid;\n    }\n    if (obInheritedObjectTypeGuid != Py_None) {\n        if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid))\n            return NULL;\n        pInheritedObjectTypeGuid = &InheritedObjectTypeGuid;\n    }\n\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n\n    bsuccess = (*addfunc)(pdacl, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid);\n    if (bsuccess)\n        bsuccess = _ReorderACL(pdacl);\n    else {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(funcname, err);\n        // resize if dacl too small\n        unsigned int required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_OBJECT_ACE) + GetLengthSid(psid);\n        // max ACL size is USHRT_MAX\n        if (required_size > USHRT_MAX)\n            return PyErr_Format(PyExc_OverflowError, \""%s: adding ACE would put ACL over size limit\"", funcname);\n        pdacl_padded = (ACL *)malloc(required_size);\n        if (pdacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \""%s: unable to allocated %d bytes\"", funcname, required_size);\n\n        ZeroMemory(pdacl_padded, required_size);\n        memcpy(pdacl_padded, pdacl, pdacl->AclSize);\n        pdacl_padded->AclSize = (unsigned short)required_size;\n        bsuccess =\n            (*addfunc)(pdacl_padded, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid);\n        if (bsuccess) {\n            bsuccess = _ReorderACL(pdacl_padded);\n            if (bsuccess)\n                bsuccess = This->SetACL(pdacl_padded);\n        }\n        else\n            PyWin_SetAPIError(funcname);\n    }\n    if (pdacl_padded)\n        free(pdacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}""}, {""func_name"": ""PyACL::AddAuditAccessAce"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *PyACL::AddAuditAccessAce(PyObject *self, PyObject *args)\n{\n    DWORD accessmask, acerevision;\n    BOOL bAuditSuccess, bAuditFailure;\n    PyObject *obSID;\n    PSID psid;\n    PACL psacl;\n    PyACL *This = (PyACL *)self;\n    psacl = This->GetACL();\n    PACL psacl_padded = NULL;\n    BOOL bsuccess;\n    // @pyparm int|dwAceRevision||Revision of ACL: Pre-Win2k, must be ACL_REVISION. Win2K on up, can also be\n    // ACL_REVISION_DS\n    // @pyparm int|dwAccessMask||Bitmask of access types to be audited\n    // @pyparm <o PySID>|sid||SID for whom system audit messages will be generated\n    // @pyparm int|bAuditSuccess||Set to 1 if access success should be audited, else 0\n    // @pyparm int|bAuditFailure||Set to 1 if access failure should be audited, else 0\n\n    if (!PyArg_ParseTuple(args, \""llOii:AddAuditAccessAce\"", &acerevision, &accessmask, &obSID, &bAuditSuccess,\n                          &bAuditFailure))\n        return NULL;\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n    bsuccess = ::AddAuditAccessAce(psacl, acerevision, accessmask, psid, bAuditSuccess, bAuditFailure);\n    if (!bsuccess) {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(\""AddAuditAccessAce\"", err);\n        // resize if acl too small\n        unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + GetLengthSid(psid);\n        // max ACL size is USHRT_MAX\n        if (required_size > USHRT_MAX)\n            return PyErr_Format(PyExc_OverflowError, \""%s: adding ACE would put ACL over size limit\"", __FUNCTION__ );\n        ZeroMemory(psacl_padded, required_size);\n        memcpy(psacl_padded, psacl, psacl->AclSize);\n        psacl_padded->AclSize = (unsigned short)required_size;\n        bsuccess = ::AddAuditAccessAce(psacl_padded, acerevision, accessmask, psid, bAuditSuccess, bAuditFailure);\n        if (bsuccess)\n            bsuccess = This->SetACL(psacl_padded);\n        else\n            PyWin_SetAPIError(\""AddAuditAccessAce\"");\n    }\n\n    if (psacl_padded)\n        free(psacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}""}, {""func_name"": ""addaceex"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *addaceex(addaceexfunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags, DWORD access,\n                   PyObject *obSID)\n{\n    /* AddAccessAllowedAceEx and AddAccessDeniedAceEx have the same signature and semantics */\n    if (addfunc == NULL)\n        return PyErr_Format(PyExc_NotImplementedError, \""%s not supported by this version of Windows\"", funcname);\n    PSID psid;\n    BOOL bsuccess;\n    PACL pacl = This->GetACL();\n    PACL pacl_padded = NULL;\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n\n    bsuccess = (*addfunc)(pacl, revision, aceflags, access, psid);\n    if (bsuccess)\n        bsuccess = _ReorderACL(pacl);\n    else {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(funcname, err);\n        // resize if dacl too small\n        unsigned int required_size = pacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid);\n        // max ACL size is USHRT_MAX\n        if (required_size > USHRT_MAX)\n            return PyErr_Format(PyExc_OverflowError, \""%s: adding ACE would put ACL over size limit\"", funcname);\n        pacl_padded = (ACL *)malloc(required_size);\n        if (pacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \""%s: unable to allocated %d bytes\"", funcname, required_size);\n\n        ZeroMemory(pacl_padded, required_size);\n        memcpy(pacl_padded, pacl, pacl->AclSize);\n        pacl_padded->AclSize = (unsigned short)required_size;\n        bsuccess = (*addfunc)(pacl_padded, revision, aceflags, access, psid);\n        if (bsuccess) {\n            bsuccess = _ReorderACL(pacl_padded);\n            if (bsuccess)\n                bsuccess = This->SetACL(pacl_padded);\n        }\n        else\n            PyWin_SetAPIError(funcname);\n    }\n    if (pacl_padded)\n        free(pacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}""}, {""func_name"": ""PyACL::AddAuditAccessAceEx"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *PyACL::AddAuditAccessAceEx(PyObject *self, PyObject *args)\n{\n    DWORD accessmask, acerevision, aceflags;\n    BOOL bAuditSuccess, bAuditFailure;\n    PyObject *obSID;\n    PSID psid;\n    PACL psacl;\n    PyACL *This = (PyACL *)self;\n    psacl = This->GetACL();\n    PACL psacl_padded = NULL;\n    BOOL bsuccess;\n    if (addauditaccessaceex == NULL)\n        return PyErr_Format(PyExc_NotImplementedError, \""AddAuditAccessAceEx not supported by this version of Windows\"");\n\n    // @pyparm int|dwAceRevision||Revision of ACL: Must be at least ACL_REVISION_DS\n    // @pyparm int|AceFlags||Combination of\n    // FAILED_ACCESS_ACE_FLAG,SUCCESSFUL_ACCESS_ACE_FLAG,CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE\n    // and OBJECT_INHERIT_ACE\n    // @pyparm int|dwAccessMask||Bitmask of access types to be audited\n    // @pyparm <o PySID>|sid||SID for whom system audit messages will be generated\n    // @pyparm int|bAuditSuccess||Set to 1 if access success should be audited, else 0\n    // @pyparm int|bAuditFailure||Set to 1 if access failure should be audited, else 0\n\n    if (!PyArg_ParseTuple(args, \""lllOii:AddAuditAccessAceEx\"", &acerevision, &aceflags, &accessmask, &obSID,\n                          &bAuditSuccess, &bAuditFailure))\n        return NULL;\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n    bsuccess = (*addauditaccessaceex)(psacl, acerevision, aceflags, accessmask, psid, bAuditSuccess, bAuditFailure);\n    if (!bsuccess) {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(\""AddAuditAccessAceEx\"", err);\n        // resize if acl too small\n        unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_ACE) + GetLengthSid(psid);\n        // max ACL size is USHRT_MAX\n        if (required_size > USHRT_MAX)\n            return PyErr_Format(PyExc_OverflowError, \""%s: adding ACE would put ACL over size limit\"", __FUNCTION__ );\n        psacl_padded = (ACL *)malloc(required_size);\n        if (psacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \""AddAuditAccessAceEx: unable to allocated %d bytes\"", required_size);\n\n        ZeroMemory(psacl_padded, required_size);\n        memcpy(psacl_padded, psacl, psacl->AclSize);\n        psacl_padded->AclSize = (unsigned short)required_size;\n        bsuccess =\n            (*addauditaccessaceex)(psacl_padded, acerevision, aceflags, accessmask, psid, bAuditSuccess, bAuditFailure);\n        if (bsuccess)\n            bsuccess = This->SetACL(psacl_padded);\n        else\n            PyWin_SetAPIError(\""AddAuditAccessAceEx\"");\n    }\n\n    if (psacl_padded)\n        free(psacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}""}, {""func_name"": ""addaceorig"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *addaceorig(addacefunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD access, PyObject *obSID)\n{\n    /* AddAccessAllowedAce and AddAccessDeniedAce operate exactly the same */\n    PACL pdacl = This->GetACL();\n    PACL pdacl_padded = NULL;\n    BOOL bsuccess;\n    PSID psid;\n    if (addfunc == NULL)\n        return PyErr_Format(PyExc_NotImplementedError, \""%s not supported by this version of Windows\"", funcname);\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n\n    bsuccess = (*addfunc)(pdacl, revision, access, psid);\n    if (bsuccess)\n        bsuccess = _ReorderACL(pdacl);\n    else {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(funcname, err);\n        // resize if dacl too small\n        unsigned int required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid);\n        // max ACL size is USHRT_MAX\n        if (required_size > USHRT_MAX)\n            return PyErr_Format(PyExc_OverflowError, \""%s: adding ACE would put ACL over size limit\"", funcname);\n        pdacl_padded = (ACL *)malloc(required_size);\n        if (pdacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \""%s: unable to allocated %d bytes\"", funcname, required_size);\n\n        ZeroMemory(pdacl_padded, required_size);\n        memcpy(pdacl_padded, pdacl, pdacl->AclSize);\n        pdacl_padded->AclSize = (unsigned short)required_size;\n        bsuccess = (*addfunc)(pdacl_padded, revision, access, psid);\n        if (bsuccess) {\n            bsuccess = _ReorderACL(pdacl_padded);\n            if (bsuccess)\n                bsuccess = This->SetACL(pdacl_padded);\n        }\n        else\n            PyWin_SetAPIError(funcname);\n    }\n\n    if (pdacl_padded)\n        free(pdacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}""}, {""func_name"": ""PyACL::AddAuditAccessObjectAce"", ""file_path"": ""win32/src/PyACL.cpp"", ""func_code"": ""PyObject *PyACL::AddAuditAccessObjectAce(PyObject *self, PyObject *args)\n{\n    DWORD accessmask, acerevision, aceflags;\n    BOOL bAuditSuccess, bAuditFailure;\n    PyObject *obSID;\n    GUID ObjectTypeGuid, InheritedObjectTypeGuid;\n    GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL;\n    PyObject *obObjectTypeGuid, *obInheritedObjectTypeGuid;\n    BOOL bsuccess;\n    PSID psid;\n    PACL psacl;\n    PyACL *This = (PyACL *)self;\n    psacl = This->GetACL();\n    PACL psacl_padded = NULL;\n    if (addauditaccessobjectace == NULL)\n        return PyErr_Format(PyExc_NotImplementedError,\n                            \""AddAuditAccessObjectAce not supported by this version of Windows\"");\n\n    // @pyparm int|dwAceRevision||Revision of ACL: Must be at least ACL_REVISION_DS\n    // @pyparm int|AceFlags||Combination of\n    // FAILED_ACCESS_ACE_FLAG,SUCCESSFUL_ACCESS_ACE_FLAG,CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE\n    // and OBJECT_INHERIT_ACE\n    // @pyparm int|dwAccessMask||Bitmask of access types to be audited\n    // @pyparm <o PyIID>|ObjectTypeGuid||GUID of object type or property set to which ace applies, can be None\n    // @pyparm <o PyIID>|InheritedObjectTypeGuid||GUID of object type or property that will inherit ACE, can be None\n    // @pyparm <o PySID>|sid||SID for whom system audit messages will be generated\n    // @pyparm int|bAuditSuccess||Set to 1 if access success should be audited, else 0\n    // @pyparm int|bAuditFailure||Set to 1 if access failure should be audited, else 0\n\n    if (!PyArg_ParseTuple(args, \""lllOOOii:AddAuditAccessObjectAce\"", &acerevision, &aceflags, &accessmask,\n                          &obObjectTypeGuid, &obInheritedObjectTypeGuid, &obSID, &bAuditSuccess, &bAuditFailure))\n        return NULL;\n    if (obObjectTypeGuid != Py_None) {\n        if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid))\n            return NULL;\n        pObjectTypeGuid = &ObjectTypeGuid;\n    }\n    if (obInheritedObjectTypeGuid != Py_None) {\n        if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid))\n            return NULL;\n        pInheritedObjectTypeGuid = &InheritedObjectTypeGuid;\n    }\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n\n    bsuccess = (*addauditaccessobjectace)(psacl, acerevision, aceflags, accessmask, pObjectTypeGuid,\n                                          pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure);\n    if (!bsuccess) {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(\""AddAuditAccessObjectAce\"", err);\n        // resize if acl too small\n       unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + GetLengthSid(psid);\n        // max ACL size is USHRT_MAX\n        if (required_size > USHRT_MAX)\n            return PyErr_Format(PyExc_OverflowError, \""%s: adding ACE would put ACL over size limit\"", __FUNCTION__ );\n        psacl_padded = (ACL *)malloc(required_size);\n        if (psacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \""AddAuditAccessObjectAce: unable to allocated %d bytes\"",\n                                required_size);\n\n        ZeroMemory(psacl_padded, required_size);\n        memcpy(psacl_padded, psacl, psacl->AclSize);\n        psacl_padded->AclSize = (unsigned short)required_size;\n        bsuccess = (*addauditaccessobjectace)(psacl_padded, acerevision, aceflags, accessmask, pObjectTypeGuid,\n                                              pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure);\n        if (bsuccess)\n            bsuccess = This->SetACL(psacl_padded);\n        else\n            PyWin_SetAPIError(\""AddAuditAccessObjectAce\"");\n    }\n    if (psacl_padded)\n        free(psacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}""}]",{},[],"Original code used unsigned short for required_size calculations (win32/src/PyACL.cpp:619, 719, etc.), allowing integer overflow when ACE/SID size exceeded 65535 bytes. Patch replaces this with unsigned int and adds explicit overflow check against USHRT_MAX before allocation.",0.95,./github/other_context/CVE-2021-32559
31,CVE-2021-3410,CWE-190,c_cpp,A flaw was found in libcaca v0.99.beta19. A buffer overflow issue in caca_resize function in libcaca/caca/canvas.c may lead to local execution of arbitrary code in the user context.,https://github.com/cacalabs/libcaca/commit/a5b732fca8dbb499d9bd27cf3083509a4f27acf1,canvas: fix an integer overflow in caca_resize().\n\nFixes: #52 (CVE-2021-3410),3,"[{""func_name"": ""_import_text"", ""file_path"": ""caca/codec/text.c"", ""func_code"": ""ssize_t _import_text(caca_canvas_t *cv, void const *data, size_t size)\n{\n    char const *text = (char const *)data;\n    unsigned int width = 0, height = 0, x = 0, y = 0, i;\n\n    caca_set_canvas_size(cv, width, height);\n\n    for(i = 0; i < size; i++)\n    {\n        unsigned char ch = *text++;\n\n        if(ch == '\\r')\n            continue;\n\n        if(ch == '\\n')\n        {\n            x = 0;\n            y++;\n            continue;\n        }\n\n        if(x >= width || y >= height)\n        {\n            if(x >= width)\n                width = x + 1;\n\n            if(y >= height)\n                height = y + 1;\n\n            caca_set_canvas_size(cv, width, height);\n        }\n\n        caca_put_char(cv, x, y, ch);\n        x++;\n    }\n\n    if(y > height)\n        caca_set_canvas_size(cv, width, height = y);\n\n    return (ssize_t)size;\n}"", ""target"": 0}, {""func_name"": ""_import_ansi"", ""file_path"": ""caca/codec/text.c"", ""func_code"": ""ssize_t _import_ansi(caca_canvas_t *cv, void const *data, size_t size, int utf8)\n{\n    struct import im;\n    unsigned char const *buffer = (unsigned char const*)data;\n    unsigned int i, j, skip, growx = 0, growy = 0, dummy = 0;\n    unsigned int width, height;\n    uint32_t savedattr;\n    int x = 0, y = 0, save_x = 0, save_y = 0;\n\n    if(utf8)\n    {\n        width = cv->width;\n        height = cv->height;\n        growx = !width;\n        growy = !height;\n        x = cv->frames[cv->frame].x;\n        y = cv->frames[cv->frame].y;\n    }\n    else\n    {\n        caca_set_canvas_size(cv, width = 80, height = 0);\n        growx = 0;\n        growy = 1;\n    }\n\n    if(utf8)\n    {\n        im.dfg = CACA_DEFAULT;\n        im.dbg = CACA_TRANSPARENT;\n    }\n    else\n    {\n        im.dfg = CACA_LIGHTGRAY;\n        im.dbg = CACA_BLACK;\n    }\n\n    caca_set_color_ansi(cv, im.dfg, im.dbg);\n    im.clearattr = caca_get_attr(cv, -1, -1);\n\n    ansi_parse_grcm(cv, &im, 1, &dummy);\n\n    for(i = 0; i < size; i += skip)\n    {\n        uint32_t ch = 0;\n        int wch = 0;\n\n        skip = 1;\n\n        if(!utf8 && buffer[i] == '\\x1a' && i + 7 < size\n           && !memcmp(buffer + i + 1, \""SAUCE00\"", 7))\n            break; /* End before SAUCE data */\n\n        else if(buffer[i] == '\\r')\n        {\n            x = 0;\n        }\n\n        else if(buffer[i] == '\\n')\n        {\n            x = 0;\n            y++;\n        }\n\n        else if(buffer[i] == '\\t')\n        {\n            x = (x + 8) & ~7;\n        }\n\n        else if(buffer[i] == '\\x08')\n        {\n            if(x > 0)\n                x--;\n        }\n\n        /* If there are not enough characters to parse the escape sequence,\n         * wait until the next try. We require 3. */\n        else if(buffer[i] == '\\033' && i + 2 >= size)\n            break;\n\n        /* XXX: What the fuck is this shit? */\n        else if(buffer[i] == '\\033' && buffer[i + 1] == '('\n                 && buffer[i + 2] == 'B')\n        {\n            skip += 2;\n        }\n\n        /* Interpret escape commands, as per Standard ECMA-48 \""Control\n         * Functions for Coded Character Sets\"", 5.4. Control sequences. */\n        else if(buffer[i] == '\\033' && buffer[i + 1] == '[')\n        {\n            unsigned int argc = 0, argv[101];\n            unsigned int param, inter, final;\n\n        /* Compute offsets to parameter bytes, intermediate bytes and\n         * to the final byte. Only the final byte is mandatory, there\n         * can be zero of the others.\n         * 0  param=2             inter                 final           final+1\n         * +-----+------------------+---------------------+-----------------+\n         * | CSI | parameter bytes  | intermediate bytes  |   final byte    |\n         * |     |   0x30 - 0x3f    |    0x20 - 0x2f      |   0x40 - 0x7e   |\n         * | ^[[ | 0123456789:;<=>? | SPC !\""#$%&'()*+,-./ | azAZ@[\\]^_`{|}~ |\n         * +-----+------------------+---------------------+-----------------+\n         */\n            param = 2;\n\n            for(inter = param; i + inter < size; inter++)\n                if(buffer[i + inter] < 0x30 || buffer[i + inter] > 0x3f)\n                    break;\n\n            for(final = inter; i + final < size; final++)\n                if(buffer[i + final] < 0x20 || buffer[i + final] > 0x2f)\n                    break;\n\n            if(i + final >= size\n                || buffer[i + final] < 0x40 || buffer[i + final] > 0x7e)\n                break; /* Invalid Final Byte */\n\n            skip += final;\n\n            /* Sanity checks */\n            if(param < inter && buffer[i + param] >= 0x3c)\n            {\n                /* Private sequence, only parse what we know */\n                debug(\""ansi import: private sequence \\\""^[[%.*s\\\""\"",\n                      final - param + 1, buffer + i + param);\n                continue; /* Private sequence, skip it entirely */\n            }\n\n            if(final - param > 100)\n                continue; /* Suspiciously long sequence, skip it */\n\n            /* Parse parameter bytes as per ECMA-48 5.4.2: Parameter string\n             * format */\n            if(param < inter)\n            {\n                argv[0] = 0;\n                for(j = param; j < inter; j++)\n                {\n                    if(buffer[i + j] == ';')\n                        argv[++argc] = 0;\n                    else if(buffer[i + j] >= '0' && buffer[i + j] <= '9')\n                        argv[argc] = 10 * argv[argc] + (buffer[i + j] - '0');\n                }\n                argc++;\n            }\n\n            /* Interpret final byte. The code representations are given in\n             * ECMA-48 5.4: Control sequences, and the code definitions are\n             * given in ECMA-48 8.3: Definition of control functions. */\n            switch(buffer[i + final])\n            {\n            case 'H': /* CUP (0x48) - Cursor Position */\n                x = (argc > 1 && argv[1] > 0) ? argv[1] - 1 : 0;\n                y = (argc > 0 && argv[0] > 0) ? argv[0] - 1 : 0;\n                break;\n            case 'A': /* CUU (0x41) - Cursor Up */\n                y -= argc ? argv[0] : 1;\n                if(y < 0)\n                    y = 0;\n                break;\n            case 'B': /* CUD (0x42) - Cursor Down */\n                y += argc ? argv[0] : 1;\n                break;\n            case 'C': /* CUF (0x43) - Cursor Right */\n                x += argc ? argv[0] : 1;\n                break;\n            case 'D': /* CUB (0x44) - Cursor Left */\n                x -= argc ? argv[0] : 1;\n                if(x < 0)\n                    x = 0;\n                break;\n            case 'G': /* CHA (0x47) - Cursor Character Absolute */\n                x = (argc && argv[0] > 0) ? argv[0] - 1 : 0;\n                break;\n            case 'J': /* ED (0x4a) - Erase In Page */\n                savedattr = caca_get_attr(cv, -1, -1);\n                caca_set_attr(cv, im.clearattr);\n                if(!argc || argv[0] == 0)\n                {\n                    caca_draw_line(cv, x, y, width, y, ' ');\n                    caca_fill_box(cv, 0, y + 1, width - 1, height - 1, ' ');\n                }\n                else if(argv[0] == 1)\n                {\n                    caca_fill_box(cv, 0, 0, width - 1, y - 1, ' ');\n                    caca_draw_line(cv, 0, y, x, y, ' ');\n                }\n                else if(argv[0] == 2)\n                    //x = y = 0;\n                    caca_fill_box(cv, 0, 0, width - 1, height - 1, ' ');\n                caca_set_attr(cv, savedattr);\n                break;\n            case 'K': /* EL (0x4b) - Erase In Line */\n                if(!argc || argv[0] == 0)\n                    caca_draw_line(cv, x, y, width, y, ' ');\n                else if(argv[0] == 1)\n                    caca_draw_line(cv, 0, y, x, y, ' ');\n                else if(argv[0] == 2)\n                    if((unsigned int)x < width)\n                        caca_draw_line(cv, x, y, width - 1, y, ' ');\n                //x = width;\n                break;\n            case 'P': /* DCH (0x50) - Delete Character */\n                if(!argc || argv[0] == 0)\n                    argv[0] = 1; /* echo -ne 'foobar\\r\\e[0P\\n' */\n                for(j = 0; (unsigned int)(j + argv[0]) < width; j++)\n                {\n                    caca_put_char(cv, j, y,\n                                   caca_get_char(cv, j + argv[0], y));\n                    caca_put_attr(cv, j, y,\n                                   caca_get_attr(cv, j + argv[0], y));\n                }\n#if 0\n                savedattr = caca_get_attr(cv, -1, -1);\n                caca_set_attr(cv, im.clearattr);\n                for( ; (unsigned int)j < width; j++)\n                    caca_put_char(cv, j, y, ' ');\n                caca_set_attr(cv, savedattr);\n#endif\n                break;\n            case 'X': /* ECH (0x58) - Erase Character */\n                if(argc && argv[0])\n                {\n                    savedattr = caca_get_attr(cv, -1, -1);\n                    caca_set_attr(cv, im.clearattr);\n                    caca_draw_line(cv, x, y, x + argv[0] - 1, y, ' ');\n                    caca_set_attr(cv, savedattr);\n                }\n                break;\n            case 'd': /* VPA (0x64) - Line Position Absolute */\n                y = (argc && argv[0] > 0) ? argv[0] - 1 : 0;\n                break;\n            case 'f': /* HVP (0x66) - Character And Line Position */\n                x = (argc > 1 && argv[1] > 0) ? argv[1] - 1 : 0;\n                y = (argc > 0 && argv[0] > 0) ? argv[0] - 1 : 0;\n                break;\n            case 'h': /* SM (0x68) - FIXME */\n                debug(\""ansi import: set mode %i\"", argc ? (int)argv[0] : -1);\n                break;\n            case 'l': /* RM (0x6c) - FIXME */\n                debug(\""ansi import: reset mode %i\"", argc ? (int)argv[0] : -1);\n                break;\n            case 'm': /* SGR (0x6d) - Select Graphic Rendition */\n                if(argc)\n                    ansi_parse_grcm(cv, &im, argc, argv);\n                else\n                    ansi_parse_grcm(cv, &im, 1, &dummy);\n                break;\n            case 's': /* Private (save cursor position) */\n                save_x = x;\n                save_y = y;\n                break;\n            case 'u': /* Private (reload cursor position) */\n                x = save_x;\n                y = save_y;\n                break;\n            default:\n                debug(\""ansi import: unknown command \\\""^[[%.*s\\\""\"",\n                      final - param + 1, buffer + i + param);\n                break;\n            }\n        }\n\n        /* Parse OSC stuff. */\n        else if(buffer[i] == '\\033' && buffer[i + 1] == ']')\n        {\n            char *string;\n            unsigned int command = 0;\n            unsigned int mode = 2, semicolon, final;\n\n            for(semicolon = mode; i + semicolon < size; semicolon++)\n            {\n                if(buffer[i + semicolon] < '0' || buffer[i + semicolon] > '9')\n                    break;\n                command = 10 * command + (buffer[i + semicolon] - '0');\n            }\n\n            if(i + semicolon >= size || buffer[i + semicolon] != ';')\n                break; /* Invalid Mode */\n\n            for(final = semicolon + 1; i + final < size; final++)\n                if(buffer[i + final] < 0x20)\n                    break;\n\n            if(i + final >= size || buffer[i + final] != '\\a')\n                break; /* Not enough data or no bell found */\n                /* FIXME: XTerm also reacts to <ESC><backslash> and <ST> */\n                /* FIXME: differenciate between not enough data (try again)\n                 *        and invalid data (print shit) */\n\n            skip += final;\n\n            string = malloc(final - (semicolon + 1) + 1);\n            memcpy(string, buffer + (semicolon + 1), final - (semicolon + 1));\n            string[final - (semicolon + 1)] = '\\0';\n            debug(\""ansi import: got OSC command %i string '%s'\"", command,\n                  string);\n            free(string);\n        }\n\n        /* Form feed means a new frame */\n        else if(buffer[i] == '\\f' && buffer[i + 1] == '\\n')\n        {\n            int f = caca_get_frame_count(cv);\n            caca_create_frame(cv, f);\n            caca_set_frame(cv, f);\n            x = y = 0;\n            skip++;\n        }\n\n        /* Get the character we\u2019re going to paste */\n        else if(utf8)\n        {\n            size_t bytes;\n\n            if(i + 6 < size)\n                ch = caca_utf8_to_utf32((char const *)(buffer + i), &bytes);\n            else\n            {\n                /* Add a trailing zero to what we're going to read */\n                char tmp[7];\n                memcpy(tmp, buffer + i, size - i);\n                tmp[size - i] = '\\0';\n                ch = caca_utf8_to_utf32(tmp, &bytes);\n            }\n\n            if(!bytes)\n            {\n                /* If the Unicode is invalid, assume it was latin1. */\n                ch = buffer[i];\n                bytes = 1;\n            }\n            wch = caca_utf32_is_fullwidth(ch) ? 2 : 1;\n            skip += (int)(bytes - 1);\n        }\n        else\n        {\n            ch = caca_cp437_to_utf32(buffer[i]);\n            wch = 1;\n        }\n\n        /* Wrap long lines or grow horizontally */\n        while((unsigned int)x + wch > width)\n        {\n            if(growx)\n            {\n                savedattr = caca_get_attr(cv, -1, -1);\n                caca_set_attr(cv, im.clearattr);\n                caca_set_canvas_size(cv, width = x + wch, height);\n                caca_set_attr(cv, savedattr);\n            }\n            else\n            {\n                x -= width;\n                y++;\n            }\n        }\n\n        /* Scroll or grow vertically */\n        if((unsigned int)y >= height)\n        {\n            savedattr = caca_get_attr(cv, -1, -1);\n            caca_set_attr(cv, im.clearattr);\n            if(growy)\n            {\n                caca_set_canvas_size(cv, width, height = y + 1);\n            }\n            else\n            {\n                int lines = (y - height) + 1;\n\n                for(j = 0; j + lines < height; j++)\n                {\n                    memcpy(cv->attrs + j * cv->width,\n                           cv->attrs + (j + lines) * cv->width, cv->width * 4);\n                    memcpy(cv->chars + j * cv->width,\n                           cv->chars + (j + lines) * cv->width, cv->width * 4);\n                }\n                caca_fill_box(cv, 0, height - lines,\n                                   cv->width - 1, height - 1, ' ');\n                y -= lines;\n            }\n            caca_set_attr(cv, savedattr);\n        }\n\n        /* Now paste our character, if any */\n        if(wch)\n        {\n            caca_put_char(cv, x, y, ch);\n            x += wch;\n        }\n    }\n\n    if(growy && (unsigned int)y > height)\n    {\n        savedattr = caca_get_attr(cv, -1, -1);\n        caca_set_attr(cv, im.clearattr);\n        caca_set_canvas_size(cv, width, height = y);\n        caca_set_attr(cv, savedattr);\n    }\n\n    cv->frames[cv->frame].x = x;\n    cv->frames[cv->frame].y = y;\n\n//    if(utf8)\n//        caca_set_attr(cv, savedattr);\n\n    return i;\n}"", ""target"": 0}, {""func_name"": ""caca_resize"", ""file_path"": ""caca/canvas.c"", ""func_code"": ""int caca_resize(caca_canvas_t *cv, int width, int height)\n{\n    int x, y, f, old_width, old_height, new_size, old_size;\n\n    old_width = cv->width;\n    old_height = cv->height;\n    old_size = old_width * old_height;\n\n    _caca_save_frame_info(cv);\n\n    /* Preload new width and height values into the canvas to optimise\n     * dirty rectangle handling */\n    cv->width = width;\n    cv->height = height;\n    new_size = width * height;\n\n    /* If width or height is smaller (or both), we have the opportunity to\n     * reduce or even remove dirty rectangles */\n    if(width < old_width || height < old_height)\n        _caca_clip_dirty_rect_list(cv);\n\n    /* Step 1: if new area is bigger, resize the memory area now. */\n    if(new_size > old_size)\n    {\n        for(f = 0; f < cv->framecount; f++)\n        {\n            cv->frames[f].chars = realloc(cv->frames[f].chars,\n                                          new_size * sizeof(uint32_t));\n            cv->frames[f].attrs = realloc(cv->frames[f].attrs,\n                                          new_size * sizeof(uint32_t));\n            if(new_size && (!cv->frames[f].chars || !cv->frames[f].attrs))\n            {\n                seterrno(ENOMEM);\n                return -1;\n            }\n        }\n    }\n\n    /* Step 2: move line data if necessary. */\n    if(width == old_width)\n    {\n        /* Width did not change, which means we do not need to move data. */\n        ;\n    }\n    else if(width > old_width)\n    {\n        /* New width is bigger than old width, which means we need to\n         * copy lines starting from the bottom of the screen otherwise\n         * we will overwrite information. */\n        for(f = 0; f < cv->framecount; f++)\n        {\n            uint32_t *chars = cv->frames[f].chars;\n            uint32_t *attrs = cv->frames[f].attrs;\n\n            for(y = height < old_height ? height : old_height; y--; )\n            {\n                uint32_t attr = cv->frames[f].curattr;\n\n                for(x = old_width; x--; )\n                {\n                    chars[y * width + x] = chars[y * old_width + x];\n                    attrs[y * width + x] = attrs[y * old_width + x];\n                }\n\n                /* Zero the end of the line */\n                for(x = width - old_width; x--; )\n                {\n                    chars[y * width + old_width + x] = (uint32_t)' ';\n                    attrs[y * width + old_width + x] = attr;\n                }\n            }\n        }\n\n        if(!cv->dirty_disabled)\n            caca_add_dirty_rect(cv, old_width, 0,\n                                width - old_width, old_height);\n    }\n    else\n    {\n        /* New width is smaller. Copy as many lines as possible. Ignore\n         * the first line, it is already in place. */\n        int lines = height < old_height ? height : old_height;\n\n        for(f = 0; f < cv->framecount; f++)\n        {\n            uint32_t *chars = cv->frames[f].chars;\n            uint32_t *attrs = cv->frames[f].attrs;\n\n            for(y = 1; y < lines; y++)\n            {\n                for(x = 0; x < width; x++)\n                {\n                    chars[y * width + x] = chars[y * old_width + x];\n                    attrs[y * width + x] = attrs[y * old_width + x];\n                }\n            }\n        }\n    }\n\n    /* Step 3: fill the bottom of the new screen if necessary. */\n    if(height > old_height)\n    {\n        for(f = 0; f < cv->framecount; f++)\n        {\n            uint32_t *chars = cv->frames[f].chars;\n            uint32_t *attrs = cv->frames[f].attrs;\n            uint32_t attr = cv->frames[f].curattr;\n\n            /* Zero the bottom of the screen */\n            for(x = (height - old_height) * width; x--; )\n            {\n                chars[old_height * width + x] = (uint32_t)' ';\n                attrs[old_height * width + x] = attr;\n            }\n        }\n\n        if(!cv->dirty_disabled)\n            caca_add_dirty_rect(cv, 0, old_height,\n                                old_width, height - old_height);\n    }\n\n    /* If both width and height are larger, there is a new dirty rectangle\n     * that needs to be created in the lower right corner. */\n    if(!cv->dirty_disabled &&\n        width > old_width && height > old_height)\n        caca_add_dirty_rect(cv, old_width, old_height,\n                            width - old_width, height - old_height);\n\n    /* Step 4: if new area is smaller, resize memory area now. */\n    if(new_size < old_size)\n    {\n        for(f = 0; f < cv->framecount; f++)\n        {\n            cv->frames[f].chars = realloc(cv->frames[f].chars,\n                                          new_size * sizeof(uint32_t));\n            cv->frames[f].attrs = realloc(cv->frames[f].attrs,\n                                          new_size * sizeof(uint32_t));\n            if(new_size && (!cv->frames[f].chars || !cv->frames[f].attrs))\n            {\n                seterrno(ENOMEM);\n                return -1;\n            }\n        }\n    }\n\n    /* Set new size */\n    for(f = 0; f < cv->framecount; f++)\n    {\n        if(cv->frames[f].x > (int)width)\n            cv->frames[f].x = width;\n        if(cv->frames[f].y > (int)height)\n            cv->frames[f].y = height;\n\n        cv->frames[f].width = width;\n        cv->frames[f].height = height;\n    }\n\n    /* Reset the current frame shortcuts */\n    _caca_load_frame_info(cv);\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""_import_text"", ""file_path"": ""caca/codec/text.c"", ""func_code"": ""ssize_t _import_text(caca_canvas_t *cv, void const *data, size_t size)\n{\n    char const *text = (char const *)data;\n    unsigned int width = 0, height = 0, x = 0, y = 0, i;\n\n    caca_set_canvas_size(cv, 0, 0);\n\n    for(i = 0; i < size; i++)\n    {\n        unsigned char ch = *text++;\n\n        if(ch == '\\r')\n            continue;\n\n        if(ch == '\\n')\n        {\n            x = 0;\n            y++;\n            continue;\n        }\n\n        if(x >= width || y >= height)\n        {\n            if(x >= width)\n                width = x + 1;\n\n            if(y >= height)\n                height = y + 1;\n\n            if (caca_set_canvas_size(cv, width, height) < 0)\n                return -1;\n        }\n\n        caca_put_char(cv, x, y, ch);\n        x++;\n    }\n\n    if (y > height)\n    {\n        if (caca_set_canvas_size(cv, width, height = y) < 0)\n            return -1;\n    }\n\n    return (ssize_t)size;\n}""}, {""func_name"": ""_import_ansi"", ""file_path"": ""caca/codec/text.c"", ""func_code"": ""ssize_t _import_ansi(caca_canvas_t *cv, void const *data, size_t size, int utf8)\n{\n    struct import im;\n    unsigned char const *buffer = (unsigned char const*)data;\n    unsigned int i, j, skip, growx = 0, growy = 0, dummy = 0;\n    unsigned int width, height;\n    uint32_t savedattr;\n    int x = 0, y = 0, save_x = 0, save_y = 0;\n\n    if(utf8)\n    {\n        width = cv->width;\n        height = cv->height;\n        growx = !width;\n        growy = !height;\n        x = cv->frames[cv->frame].x;\n        y = cv->frames[cv->frame].y;\n    }\n    else\n    {\n        caca_set_canvas_size(cv, width = 80, height = 0);\n        growx = 0;\n        growy = 1;\n    }\n\n    if(utf8)\n    {\n        im.dfg = CACA_DEFAULT;\n        im.dbg = CACA_TRANSPARENT;\n    }\n    else\n    {\n        im.dfg = CACA_LIGHTGRAY;\n        im.dbg = CACA_BLACK;\n    }\n\n    caca_set_color_ansi(cv, im.dfg, im.dbg);\n    im.clearattr = caca_get_attr(cv, -1, -1);\n\n    ansi_parse_grcm(cv, &im, 1, &dummy);\n\n    for(i = 0; i < size; i += skip)\n    {\n        uint32_t ch = 0;\n        int wch = 0;\n\n        skip = 1;\n\n        if(!utf8 && buffer[i] == '\\x1a' && i + 7 < size\n           && !memcmp(buffer + i + 1, \""SAUCE00\"", 7))\n            break; /* End before SAUCE data */\n\n        else if(buffer[i] == '\\r')\n        {\n            x = 0;\n        }\n\n        else if(buffer[i] == '\\n')\n        {\n            x = 0;\n            y++;\n        }\n\n        else if(buffer[i] == '\\t')\n        {\n            x = (x + 8) & ~7;\n        }\n\n        else if(buffer[i] == '\\x08')\n        {\n            if(x > 0)\n                x--;\n        }\n\n        /* If there are not enough characters to parse the escape sequence,\n         * wait until the next try. We require 3. */\n        else if(buffer[i] == '\\033' && i + 2 >= size)\n            break;\n\n        /* XXX: What the fuck is this shit? */\n        else if(buffer[i] == '\\033' && buffer[i + 1] == '('\n                 && buffer[i + 2] == 'B')\n        {\n            skip += 2;\n        }\n\n        /* Interpret escape commands, as per Standard ECMA-48 \""Control\n         * Functions for Coded Character Sets\"", 5.4. Control sequences. */\n        else if(buffer[i] == '\\033' && buffer[i + 1] == '[')\n        {\n            unsigned int argc = 0, argv[101];\n            unsigned int param, inter, final;\n\n        /* Compute offsets to parameter bytes, intermediate bytes and\n         * to the final byte. Only the final byte is mandatory, there\n         * can be zero of the others.\n         * 0  param=2             inter                 final           final+1\n         * +-----+------------------+---------------------+-----------------+\n         * | CSI | parameter bytes  | intermediate bytes  |   final byte    |\n         * |     |   0x30 - 0x3f    |    0x20 - 0x2f      |   0x40 - 0x7e   |\n         * | ^[[ | 0123456789:;<=>? | SPC !\""#$%&'()*+,-./ | azAZ@[\\]^_`{|}~ |\n         * +-----+------------------+---------------------+-----------------+\n         */\n            param = 2;\n\n            for(inter = param; i + inter < size; inter++)\n                if(buffer[i + inter] < 0x30 || buffer[i + inter] > 0x3f)\n                    break;\n\n            for(final = inter; i + final < size; final++)\n                if(buffer[i + final] < 0x20 || buffer[i + final] > 0x2f)\n                    break;\n\n            if(i + final >= size\n                || buffer[i + final] < 0x40 || buffer[i + final] > 0x7e)\n                break; /* Invalid Final Byte */\n\n            skip += final;\n\n            /* Sanity checks */\n            if(param < inter && buffer[i + param] >= 0x3c)\n            {\n                /* Private sequence, only parse what we know */\n                debug(\""ansi import: private sequence \\\""^[[%.*s\\\""\"",\n                      final - param + 1, buffer + i + param);\n                continue; /* Private sequence, skip it entirely */\n            }\n\n            if(final - param > 100)\n                continue; /* Suspiciously long sequence, skip it */\n\n            /* Parse parameter bytes as per ECMA-48 5.4.2: Parameter string\n             * format */\n            if(param < inter)\n            {\n                argv[0] = 0;\n                for(j = param; j < inter; j++)\n                {\n                    if(buffer[i + j] == ';')\n                        argv[++argc] = 0;\n                    else if(buffer[i + j] >= '0' && buffer[i + j] <= '9')\n                        argv[argc] = 10 * argv[argc] + (buffer[i + j] - '0');\n                }\n                argc++;\n            }\n\n            /* Interpret final byte. The code representations are given in\n             * ECMA-48 5.4: Control sequences, and the code definitions are\n             * given in ECMA-48 8.3: Definition of control functions. */\n            switch(buffer[i + final])\n            {\n            case 'H': /* CUP (0x48) - Cursor Position */\n                x = (argc > 1 && argv[1] > 0) ? argv[1] - 1 : 0;\n                y = (argc > 0 && argv[0] > 0) ? argv[0] - 1 : 0;\n                break;\n            case 'A': /* CUU (0x41) - Cursor Up */\n                y -= argc ? argv[0] : 1;\n                if(y < 0)\n                    y = 0;\n                break;\n            case 'B': /* CUD (0x42) - Cursor Down */\n                y += argc ? argv[0] : 1;\n                break;\n            case 'C': /* CUF (0x43) - Cursor Right */\n                x += argc ? argv[0] : 1;\n                break;\n            case 'D': /* CUB (0x44) - Cursor Left */\n                x -= argc ? argv[0] : 1;\n                if(x < 0)\n                    x = 0;\n                break;\n            case 'G': /* CHA (0x47) - Cursor Character Absolute */\n                x = (argc && argv[0] > 0) ? argv[0] - 1 : 0;\n                break;\n            case 'J': /* ED (0x4a) - Erase In Page */\n                savedattr = caca_get_attr(cv, -1, -1);\n                caca_set_attr(cv, im.clearattr);\n                if(!argc || argv[0] == 0)\n                {\n                    caca_draw_line(cv, x, y, width, y, ' ');\n                    caca_fill_box(cv, 0, y + 1, width - 1, height - 1, ' ');\n                }\n                else if(argv[0] == 1)\n                {\n                    caca_fill_box(cv, 0, 0, width - 1, y - 1, ' ');\n                    caca_draw_line(cv, 0, y, x, y, ' ');\n                }\n                else if(argv[0] == 2)\n                    //x = y = 0;\n                    caca_fill_box(cv, 0, 0, width - 1, height - 1, ' ');\n                caca_set_attr(cv, savedattr);\n                break;\n            case 'K': /* EL (0x4b) - Erase In Line */\n                if(!argc || argv[0] == 0)\n                    caca_draw_line(cv, x, y, width, y, ' ');\n                else if(argv[0] == 1)\n                    caca_draw_line(cv, 0, y, x, y, ' ');\n                else if(argv[0] == 2)\n                    if((unsigned int)x < width)\n                        caca_draw_line(cv, x, y, width - 1, y, ' ');\n                //x = width;\n                break;\n            case 'P': /* DCH (0x50) - Delete Character */\n                if(!argc || argv[0] == 0)\n                    argv[0] = 1; /* echo -ne 'foobar\\r\\e[0P\\n' */\n                for(j = 0; (unsigned int)(j + argv[0]) < width; j++)\n                {\n                    caca_put_char(cv, j, y,\n                                   caca_get_char(cv, j + argv[0], y));\n                    caca_put_attr(cv, j, y,\n                                   caca_get_attr(cv, j + argv[0], y));\n                }\n#if 0\n                savedattr = caca_get_attr(cv, -1, -1);\n                caca_set_attr(cv, im.clearattr);\n                for( ; (unsigned int)j < width; j++)\n                    caca_put_char(cv, j, y, ' ');\n                caca_set_attr(cv, savedattr);\n#endif\n                break;\n            case 'X': /* ECH (0x58) - Erase Character */\n                if(argc && argv[0])\n                {\n                    savedattr = caca_get_attr(cv, -1, -1);\n                    caca_set_attr(cv, im.clearattr);\n                    caca_draw_line(cv, x, y, x + argv[0] - 1, y, ' ');\n                    caca_set_attr(cv, savedattr);\n                }\n                break;\n            case 'd': /* VPA (0x64) - Line Position Absolute */\n                y = (argc && argv[0] > 0) ? argv[0] - 1 : 0;\n                break;\n            case 'f': /* HVP (0x66) - Character And Line Position */\n                x = (argc > 1 && argv[1] > 0) ? argv[1] - 1 : 0;\n                y = (argc > 0 && argv[0] > 0) ? argv[0] - 1 : 0;\n                break;\n            case 'h': /* SM (0x68) - FIXME */\n                debug(\""ansi import: set mode %i\"", argc ? (int)argv[0] : -1);\n                break;\n            case 'l': /* RM (0x6c) - FIXME */\n                debug(\""ansi import: reset mode %i\"", argc ? (int)argv[0] : -1);\n                break;\n            case 'm': /* SGR (0x6d) - Select Graphic Rendition */\n                if(argc)\n                    ansi_parse_grcm(cv, &im, argc, argv);\n                else\n                    ansi_parse_grcm(cv, &im, 1, &dummy);\n                break;\n            case 's': /* Private (save cursor position) */\n                save_x = x;\n                save_y = y;\n                break;\n            case 'u': /* Private (reload cursor position) */\n                x = save_x;\n                y = save_y;\n                break;\n            default:\n                debug(\""ansi import: unknown command \\\""^[[%.*s\\\""\"",\n                      final - param + 1, buffer + i + param);\n                break;\n            }\n        }\n\n        /* Parse OSC stuff. */\n        else if(buffer[i] == '\\033' && buffer[i + 1] == ']')\n        {\n            char *string;\n            unsigned int command = 0;\n            unsigned int mode = 2, semicolon, final;\n\n            for(semicolon = mode; i + semicolon < size; semicolon++)\n            {\n                if(buffer[i + semicolon] < '0' || buffer[i + semicolon] > '9')\n                    break;\n                command = 10 * command + (buffer[i + semicolon] - '0');\n            }\n\n            if(i + semicolon >= size || buffer[i + semicolon] != ';')\n                break; /* Invalid Mode */\n\n            for(final = semicolon + 1; i + final < size; final++)\n                if(buffer[i + final] < 0x20)\n                    break;\n\n            if(i + final >= size || buffer[i + final] != '\\a')\n                break; /* Not enough data or no bell found */\n                /* FIXME: XTerm also reacts to <ESC><backslash> and <ST> */\n                /* FIXME: differenciate between not enough data (try again)\n                 *        and invalid data (print shit) */\n\n            skip += final;\n\n            string = malloc(final - (semicolon + 1) + 1);\n            memcpy(string, buffer + (semicolon + 1), final - (semicolon + 1));\n            string[final - (semicolon + 1)] = '\\0';\n            debug(\""ansi import: got OSC command %i string '%s'\"", command,\n                  string);\n            free(string);\n        }\n\n        /* Form feed means a new frame */\n        else if(buffer[i] == '\\f' && buffer[i + 1] == '\\n')\n        {\n            int f = caca_get_frame_count(cv);\n            caca_create_frame(cv, f);\n            caca_set_frame(cv, f);\n            x = y = 0;\n            skip++;\n        }\n\n        /* Get the character we\u2019re going to paste */\n        else if(utf8)\n        {\n            size_t bytes;\n\n            if(i + 6 < size)\n                ch = caca_utf8_to_utf32((char const *)(buffer + i), &bytes);\n            else\n            {\n                /* Add a trailing zero to what we're going to read */\n                char tmp[7];\n                memcpy(tmp, buffer + i, size - i);\n                tmp[size - i] = '\\0';\n                ch = caca_utf8_to_utf32(tmp, &bytes);\n            }\n\n            if(!bytes)\n            {\n                /* If the Unicode is invalid, assume it was latin1. */\n                ch = buffer[i];\n                bytes = 1;\n            }\n            wch = caca_utf32_is_fullwidth(ch) ? 2 : 1;\n            skip += (int)(bytes - 1);\n        }\n        else\n        {\n            ch = caca_cp437_to_utf32(buffer[i]);\n            wch = 1;\n        }\n\n        /* Wrap long lines or grow horizontally */\n        while((unsigned int)x + wch > width)\n        {\n            if(growx)\n            {\n                savedattr = caca_get_attr(cv, -1, -1);\n                caca_set_attr(cv, im.clearattr);\n                if (caca_set_canvas_size(cv, width = x + wch, height) < 0)\n                    return -1;\n                caca_set_attr(cv, savedattr);\n            }\n            else\n            {\n                x -= width;\n                y++;\n            }\n        }\n\n        /* Scroll or grow vertically */\n        if((unsigned int)y >= height)\n        {\n            savedattr = caca_get_attr(cv, -1, -1);\n            caca_set_attr(cv, im.clearattr);\n            if(growy)\n            {\n                if (caca_set_canvas_size(cv, width, height = y + 1) < 0)\n                    return -1;\n            }\n            else\n            {\n                int lines = (y - height) + 1;\n\n                for(j = 0; j + lines < height; j++)\n                {\n                    memcpy(cv->attrs + j * cv->width,\n                           cv->attrs + (j + lines) * cv->width, cv->width * 4);\n                    memcpy(cv->chars + j * cv->width,\n                           cv->chars + (j + lines) * cv->width, cv->width * 4);\n                }\n                caca_fill_box(cv, 0, height - lines,\n                                   cv->width - 1, height - 1, ' ');\n                y -= lines;\n            }\n            caca_set_attr(cv, savedattr);\n        }\n\n        /* Now paste our character, if any */\n        if(wch)\n        {\n            caca_put_char(cv, x, y, ch);\n            x += wch;\n        }\n    }\n\n    if(growy && (unsigned int)y > height)\n    {\n        savedattr = caca_get_attr(cv, -1, -1);\n        caca_set_attr(cv, im.clearattr);\n        if (caca_set_canvas_size(cv, width, height = y))\n            return -1;\n        caca_set_attr(cv, savedattr);\n    }\n\n    cv->frames[cv->frame].x = x;\n    cv->frames[cv->frame].y = y;\n\n//    if(utf8)\n//        caca_set_attr(cv, savedattr);\n\n    return i;\n}""}, {""func_name"": ""caca_resize"", ""file_path"": ""caca/canvas.c"", ""func_code"": ""int caca_resize(caca_canvas_t *cv, int width, int height)\n{\n    int x, y, f, old_width, old_height, new_size, old_size;\n\n    old_width = cv->width;\n    old_height = cv->height;\n    old_size = old_width * old_height;\n\n    _caca_save_frame_info(cv);\n\n    /* Preload new width and height values into the canvas to optimise\n     * dirty rectangle handling */\n    cv->width = width;\n    cv->height = height;\n    int new_size = width * height;\n\n    /* Check for overflow */\n    if (new_size / width != height)\n    {\n        seterrno(EOVERFLOW);\n        return -1;\n    }\n\n    /* If width or height is smaller (or both), we have the opportunity to\n     * reduce or even remove dirty rectangles */\n    if(width < old_width || height < old_height)\n        _caca_clip_dirty_rect_list(cv);\n\n    /* Step 1: if new area is bigger, resize the memory area now. */\n    if(new_size > old_size)\n    {\n        for(f = 0; f < cv->framecount; f++)\n        {\n            cv->frames[f].chars = realloc(cv->frames[f].chars,\n                                          new_size * sizeof(uint32_t));\n            cv->frames[f].attrs = realloc(cv->frames[f].attrs,\n                                          new_size * sizeof(uint32_t));\n            if(new_size && (!cv->frames[f].chars || !cv->frames[f].attrs))\n            {\n                seterrno(ENOMEM);\n                return -1;\n            }\n        }\n    }\n\n    /* Step 2: move line data if necessary. */\n    if(width == old_width)\n    {\n        /* Width did not change, which means we do not need to move data. */\n        ;\n    }\n    else if(width > old_width)\n    {\n        /* New width is bigger than old width, which means we need to\n         * copy lines starting from the bottom of the screen otherwise\n         * we will overwrite information. */\n        for(f = 0; f < cv->framecount; f++)\n        {\n            uint32_t *chars = cv->frames[f].chars;\n            uint32_t *attrs = cv->frames[f].attrs;\n\n            for(y = height < old_height ? height : old_height; y--; )\n            {\n                uint32_t attr = cv->frames[f].curattr;\n\n                for(x = old_width; x--; )\n                {\n                    chars[y * width + x] = chars[y * old_width + x];\n                    attrs[y * width + x] = attrs[y * old_width + x];\n                }\n\n                /* Zero the end of the line */\n                for(x = width - old_width; x--; )\n                {\n                    chars[y * width + old_width + x] = (uint32_t)' ';\n                    attrs[y * width + old_width + x] = attr;\n                }\n            }\n        }\n\n        if(!cv->dirty_disabled)\n            caca_add_dirty_rect(cv, old_width, 0,\n                                width - old_width, old_height);\n    }\n    else\n    {\n        /* New width is smaller. Copy as many lines as possible. Ignore\n         * the first line, it is already in place. */\n        int lines = height < old_height ? height : old_height;\n\n        for(f = 0; f < cv->framecount; f++)\n        {\n            uint32_t *chars = cv->frames[f].chars;\n            uint32_t *attrs = cv->frames[f].attrs;\n\n            for(y = 1; y < lines; y++)\n            {\n                for(x = 0; x < width; x++)\n                {\n                    chars[y * width + x] = chars[y * old_width + x];\n                    attrs[y * width + x] = attrs[y * old_width + x];\n                }\n            }\n        }\n    }\n\n    /* Step 3: fill the bottom of the new screen if necessary. */\n    if(height > old_height)\n    {\n        for(f = 0; f < cv->framecount; f++)\n        {\n            uint32_t *chars = cv->frames[f].chars;\n            uint32_t *attrs = cv->frames[f].attrs;\n            uint32_t attr = cv->frames[f].curattr;\n\n            /* Zero the bottom of the screen */\n            for(x = (height - old_height) * width; x--; )\n            {\n                chars[old_height * width + x] = (uint32_t)' ';\n                attrs[old_height * width + x] = attr;\n            }\n        }\n\n        if(!cv->dirty_disabled)\n            caca_add_dirty_rect(cv, 0, old_height,\n                                old_width, height - old_height);\n    }\n\n    /* If both width and height are larger, there is a new dirty rectangle\n     * that needs to be created in the lower right corner. */\n    if(!cv->dirty_disabled &&\n        width > old_width && height > old_height)\n        caca_add_dirty_rect(cv, old_width, old_height,\n                            width - old_width, height - old_height);\n\n    /* Step 4: if new area is smaller, resize memory area now. */\n    if(new_size < old_size)\n    {\n        for(f = 0; f < cv->framecount; f++)\n        {\n            cv->frames[f].chars = realloc(cv->frames[f].chars,\n                                          new_size * sizeof(uint32_t));\n            cv->frames[f].attrs = realloc(cv->frames[f].attrs,\n                                          new_size * sizeof(uint32_t));\n            if(new_size && (!cv->frames[f].chars || !cv->frames[f].attrs))\n            {\n                seterrno(ENOMEM);\n                return -1;\n            }\n        }\n    }\n\n    /* Set new size */\n    for(f = 0; f < cv->framecount; f++)\n    {\n        if(cv->frames[f].x > (int)width)\n            cv->frames[f].x = width;\n        if(cv->frames[f].y > (int)height)\n            cv->frames[f].y = height;\n\n        cv->frames[f].width = width;\n        cv->frames[f].height = height;\n    }\n\n    /* Reset the current frame shortcuts */\n    _caca_load_frame_info(cv);\n\n    return 0;\n}""}]","{""function"": 2, ""caller"": 3, ""value"": 2}","[{""source"": ""func_info(file:canvas.c, func:caca_set_canvas_size)"", ""result"": [{""code"": ""int caca_set_canvas_size(caca_canvas_t *cv, int width, int height)\n{\n    if(width < 0 || height < 0)\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    if(cv->refcount && cv->resize_callback\n        && !cv->resize_callback(cv->resize_data))\n    {\n        seterrno(EBUSY);\n        return -1;\n    }\n\n    return caca_resize(cv, width, height);\n}"", ""start_line"": 212, ""end_line"": 228, ""full_name"": ""caca_set_canvas_size"", ""file_path"": ""caca/canvas.c""}]}, {""source"": ""caller_info(file:canvas.c, func:caca_set_canvas_size)"", ""result"": [{""call_line"": 442, ""call_code"": ""caca_set_canvas_size(canvas, width, height)"", ""caller_code"": ""PHP_FUNCTION(caca_set_canvas_size) {\n    zval *_zval;\n    long width, height = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""rll\"", &_zval, &width, &height) == FAILURE) {\n        RETURN_FALSE;\n    }\n    caca_canvas_t *canvas;\n    ZEND_FETCH_RESOURCE(canvas, caca_canvas_t*, &_zval, -1, PHP_CACA_CANVAS_RES_NAME, le_caca_canvas);\n    RETURN_SUCCESS(caca_set_canvas_size(canvas, width, height));\n}"", ""caller_start"": 434, ""file_path"": ""caca-php/php_caca.c""}, {""call_line"": 361, ""call_code"": ""caca_set_canvas_size(cv, 0, 0)"", ""caller_code"": ""static ssize_t import_caca(caca_canvas_t *cv, void const *data, size_t size)\n{\n    uint8_t const *buf = (uint8_t const *)data;\n    size_t control_size, data_size, expected_size;\n    unsigned int frames, f, n, offset;\n    uint16_t version, flags;\n    int32_t xmin = 0, ymin = 0, xmax = 0, ymax = 0;\n\n    if(size < 20)\n        return 0;\n\n    if(buf[0] != 0xca || buf[1] != 0xca || buf[2] != 'C' || buf[3] != 'V')\n    {\n        debug(\""caca import error: expected \\\\xca\\\\xcaCV header\"");\n        goto invalid_caca;\n    }\n\n    control_size = sscanu32(buf + 4);\n    data_size = sscanu32(buf + 8);\n    version = sscanu16(buf + 12);\n    frames = sscanu32(buf + 14);\n    flags = sscanu16(buf + 18);\n\n    if(size < 4 + control_size + data_size)\n        return 0;\n\n    if(control_size < 16 + frames * 32)\n    {\n        debug(\""caca import error: control size %u < expected %u\"",\n              (unsigned int)control_size, 16 + frames * 32);\n        goto invalid_caca;\n    }\n\n    for(expected_size = 0, f = 0; f < frames; f++)\n    {\n        unsigned int width, height, duration;\n        uint32_t attr;\n        int x, y, handlex, handley;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        duration = sscanu32(buf + 4 + 16 + f * 32 + 8);\n        attr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n        expected_size += width * height * 8;\n        if(-handlex < xmin)\n            xmin = -handlex;\n        if(-handley < ymin)\n            ymin = -handley;\n        if((((int32_t) width) - handlex) > xmax)\n            xmax = ((int32_t) width) - handlex;\n        if((((int32_t) height) - handley) > ymax)\n            ymax = ((int32_t) height) - handley;\n    }\n\n    if(expected_size != data_size)\n    {\n        debug(\""caca import error: data size %u < expected %u\"",\n              (unsigned int)data_size, (unsigned int)expected_size);\n        goto invalid_caca;\n    }\n\n    caca_set_canvas_size(cv, 0, 0);\n    caca_set_canvas_size(cv, xmax - xmin, ymax - ymin);\n\n    for (f = caca_get_frame_count(cv); f--; )\n    {\n        caca_free_frame(cv, f);\n    }\n\n    for (offset = 0, f = 0; f < frames; f ++)\n    {\n        unsigned int width, height;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        caca_create_frame(cv, f);\n        caca_set_frame(cv, f);\n\n        cv->curattr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        cv->frames[f].x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        cv->frames[f].y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        cv->frames[f].handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        cv->frames[f].handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n\n        /* FIXME: check for return value */\n\n        for(n = width * height; n--; )\n        {\n            int x = (n % width) - cv->frames[f].handlex - xmin;\n            int y = (n / width) - cv->frames[f].handley - ymin;\n\n            caca_put_char(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n));\n            caca_put_attr(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n + 4));\n        }\n        offset += width * height * 8;\n\n        cv->frames[f].x -= cv->frames[f].handlex;\n        cv->frames[f].y -= cv->frames[f].handley;\n        cv->frames[f].handlex = -xmin;\n        cv->frames[f].handley = -ymin;\n    }\n\n    caca_set_frame(cv, 0);\n\n    return (ssize_t)(4 + control_size + data_size);\n\ninvalid_caca:\n    seterrno(EINVAL);\n    return -1;\n}\n"", ""caller_start"": 296, ""file_path"": ""caca/codec/import.c""}, {""call_line"": 362, ""call_code"": ""caca_set_canvas_size(cv, xmax - xmin, ymax - ymin)"", ""caller_code"": ""static ssize_t import_caca(caca_canvas_t *cv, void const *data, size_t size)\n{\n    uint8_t const *buf = (uint8_t const *)data;\n    size_t control_size, data_size, expected_size;\n    unsigned int frames, f, n, offset;\n    uint16_t version, flags;\n    int32_t xmin = 0, ymin = 0, xmax = 0, ymax = 0;\n\n    if(size < 20)\n        return 0;\n\n    if(buf[0] != 0xca || buf[1] != 0xca || buf[2] != 'C' || buf[3] != 'V')\n    {\n        debug(\""caca import error: expected \\\\xca\\\\xcaCV header\"");\n        goto invalid_caca;\n    }\n\n    control_size = sscanu32(buf + 4);\n    data_size = sscanu32(buf + 8);\n    version = sscanu16(buf + 12);\n    frames = sscanu32(buf + 14);\n    flags = sscanu16(buf + 18);\n\n    if(size < 4 + control_size + data_size)\n        return 0;\n\n    if(control_size < 16 + frames * 32)\n    {\n        debug(\""caca import error: control size %u < expected %u\"",\n              (unsigned int)control_size, 16 + frames * 32);\n        goto invalid_caca;\n    }\n\n    for(expected_size = 0, f = 0; f < frames; f++)\n    {\n        unsigned int width, height, duration;\n        uint32_t attr;\n        int x, y, handlex, handley;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        duration = sscanu32(buf + 4 + 16 + f * 32 + 8);\n        attr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n        expected_size += width * height * 8;\n        if(-handlex < xmin)\n            xmin = -handlex;\n        if(-handley < ymin)\n            ymin = -handley;\n        if((((int32_t) width) - handlex) > xmax)\n            xmax = ((int32_t) width) - handlex;\n        if((((int32_t) height) - handley) > ymax)\n            ymax = ((int32_t) height) - handley;\n    }\n\n    if(expected_size != data_size)\n    {\n        debug(\""caca import error: data size %u < expected %u\"",\n              (unsigned int)data_size, (unsigned int)expected_size);\n        goto invalid_caca;\n    }\n\n    caca_set_canvas_size(cv, 0, 0);\n    caca_set_canvas_size(cv, xmax - xmin, ymax - ymin);\n\n    for (f = caca_get_frame_count(cv); f--; )\n    {\n        caca_free_frame(cv, f);\n    }\n\n    for (offset = 0, f = 0; f < frames; f ++)\n    {\n        unsigned int width, height;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        caca_create_frame(cv, f);\n        caca_set_frame(cv, f);\n\n        cv->curattr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        cv->frames[f].x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        cv->frames[f].y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        cv->frames[f].handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        cv->frames[f].handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n\n        /* FIXME: check for return value */\n\n        for(n = width * height; n--; )\n        {\n            int x = (n % width) - cv->frames[f].handlex - xmin;\n            int y = (n / width) - cv->frames[f].handley - ymin;\n\n            caca_put_char(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n));\n            caca_put_attr(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n + 4));\n        }\n        offset += width * height * 8;\n\n        cv->frames[f].x -= cv->frames[f].handlex;\n        cv->frames[f].y -= cv->frames[f].handley;\n        cv->frames[f].handlex = -xmin;\n        cv->frames[f].handley = -ymin;\n    }\n\n    caca_set_frame(cv, 0);\n\n    return (ssize_t)(4 + control_size + data_size);\n\ninvalid_caca:\n    seterrno(EINVAL);\n    return -1;\n}\n"", ""caller_start"": 296, ""file_path"": ""caca/codec/import.c""}, {""call_line"": 419, ""call_code"": ""caca_set_canvas_size(cv, 0, 0)"", ""caller_code"": ""ssize_t _import_bin(caca_canvas_t *cv, void const *data, size_t len)\n{\n    uint8_t const *buf = (uint8_t const *)data;\n    size_t i;\n    int x = 0, y = 0;\n\n    caca_set_canvas_size(cv, 0, 0);\n    caca_set_canvas_size(cv, 160, len / 160);\n\n    for (i = 0; i < len; i += 2)\n    {\n        caca_set_color_ansi(cv, buf[i + 1] & 0xf, buf[i + 1] >> 4);\n        caca_put_char(cv, x, y, caca_cp437_to_utf32(buf[i]));\n\n        ++x;\n        if (x >= 160)\n        {\n            ++y;\n            x = 0;\n        }\n    }\n\n    return len & ~(size_t)1;\n}"", ""caller_start"": 413, ""file_path"": ""caca/codec/import.c""}]}, {""source"": ""value_info(file:text.c, value:width)"", ""result"": {""value_trace"": [{""full_code"": ""width = 0"", ""line"": 47, ""func_name"": ""_import_text""}, {""full_code"": ""width = x + 1"", ""line"": 68, ""func_name"": ""_import_text""}, {""full_code"": ""width = cv->width"", ""line"": 97, ""func_name"": ""_import_ansi""}, {""full_code"": ""width = 80"", ""line"": 106, ""func_name"": ""_import_ansi""}], ""struct_var"": ""width"", ""struct_type"": ""unsigned int"", ""struct_definition"": ""unsigned int""}}, {""source"": ""value_info(file:text.c, value:height)"", ""result"": {""value_trace"": [{""full_code"": ""height = 0"", ""line"": 47, ""func_name"": ""_import_text""}, {""full_code"": ""height = y + 1"", ""line"": 71, ""func_name"": ""_import_text""}, {""full_code"": ""height = y"", ""line"": 81, ""func_name"": ""_import_text""}, {""full_code"": ""height = cv->height"", ""line"": 98, ""func_name"": ""_import_ansi""}], ""struct_var"": ""height"", ""struct_type"": ""unsigned int"", ""struct_definition"": ""unsigned int""}}, {""source"": ""caller_info(file:canvas.c, func:caca_set_canvas_size)"", ""result"": [{""call_line"": 442, ""call_code"": ""caca_set_canvas_size(canvas, width, height)"", ""caller_code"": ""PHP_FUNCTION(caca_set_canvas_size) {\n    zval *_zval;\n    long width, height = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""rll\"", &_zval, &width, &height) == FAILURE) {\n        RETURN_FALSE;\n    }\n    caca_canvas_t *canvas;\n    ZEND_FETCH_RESOURCE(canvas, caca_canvas_t*, &_zval, -1, PHP_CACA_CANVAS_RES_NAME, le_caca_canvas);\n    RETURN_SUCCESS(caca_set_canvas_size(canvas, width, height));\n}"", ""caller_start"": 434, ""file_path"": ""caca-php/php_caca.c""}, {""call_line"": 361, ""call_code"": ""caca_set_canvas_size(cv, 0, 0)"", ""caller_code"": ""static ssize_t import_caca(caca_canvas_t *cv, void const *data, size_t size)\n{\n    uint8_t const *buf = (uint8_t const *)data;\n    size_t control_size, data_size, expected_size;\n    unsigned int frames, f, n, offset;\n    uint16_t version, flags;\n    int32_t xmin = 0, ymin = 0, xmax = 0, ymax = 0;\n\n    if(size < 20)\n        return 0;\n\n    if(buf[0] != 0xca || buf[1] != 0xca || buf[2] != 'C' || buf[3] != 'V')\n    {\n        debug(\""caca import error: expected \\\\xca\\\\xcaCV header\"");\n        goto invalid_caca;\n    }\n\n    control_size = sscanu32(buf + 4);\n    data_size = sscanu32(buf + 8);\n    version = sscanu16(buf + 12);\n    frames = sscanu32(buf + 14);\n    flags = sscanu16(buf + 18);\n\n    if(size < 4 + control_size + data_size)\n        return 0;\n\n    if(control_size < 16 + frames * 32)\n    {\n        debug(\""caca import error: control size %u < expected %u\"",\n              (unsigned int)control_size, 16 + frames * 32);\n        goto invalid_caca;\n    }\n\n    for(expected_size = 0, f = 0; f < frames; f++)\n    {\n        unsigned int width, height, duration;\n        uint32_t attr;\n        int x, y, handlex, handley;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        duration = sscanu32(buf + 4 + 16 + f * 32 + 8);\n        attr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n        expected_size += width * height * 8;\n        if(-handlex < xmin)\n            xmin = -handlex;\n        if(-handley < ymin)\n            ymin = -handley;\n        if((((int32_t) width) - handlex) > xmax)\n            xmax = ((int32_t) width) - handlex;\n        if((((int32_t) height) - handley) > ymax)\n            ymax = ((int32_t) height) - handley;\n    }\n\n    if(expected_size != data_size)\n    {\n        debug(\""caca import error: data size %u < expected %u\"",\n              (unsigned int)data_size, (unsigned int)expected_size);\n        goto invalid_caca;\n    }\n\n    caca_set_canvas_size(cv, 0, 0);\n    caca_set_canvas_size(cv, xmax - xmin, ymax - ymin);\n\n    for (f = caca_get_frame_count(cv); f--; )\n    {\n        caca_free_frame(cv, f);\n    }\n\n    for (offset = 0, f = 0; f < frames; f ++)\n    {\n        unsigned int width, height;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        caca_create_frame(cv, f);\n        caca_set_frame(cv, f);\n\n        cv->curattr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        cv->frames[f].x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        cv->frames[f].y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        cv->frames[f].handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        cv->frames[f].handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n\n        /* FIXME: check for return value */\n\n        for(n = width * height; n--; )\n        {\n            int x = (n % width) - cv->frames[f].handlex - xmin;\n            int y = (n / width) - cv->frames[f].handley - ymin;\n\n            caca_put_char(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n));\n            caca_put_attr(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n + 4));\n        }\n        offset += width * height * 8;\n\n        cv->frames[f].x -= cv->frames[f].handlex;\n        cv->frames[f].y -= cv->frames[f].handley;\n        cv->frames[f].handlex = -xmin;\n        cv->frames[f].handley = -ymin;\n    }\n\n    caca_set_frame(cv, 0);\n\n    return (ssize_t)(4 + control_size + data_size);\n\ninvalid_caca:\n    seterrno(EINVAL);\n    return -1;\n}\n"", ""caller_start"": 296, ""file_path"": ""caca/codec/import.c""}, {""call_line"": 362, ""call_code"": ""caca_set_canvas_size(cv, xmax - xmin, ymax - ymin)"", ""caller_code"": ""static ssize_t import_caca(caca_canvas_t *cv, void const *data, size_t size)\n{\n    uint8_t const *buf = (uint8_t const *)data;\n    size_t control_size, data_size, expected_size;\n    unsigned int frames, f, n, offset;\n    uint16_t version, flags;\n    int32_t xmin = 0, ymin = 0, xmax = 0, ymax = 0;\n\n    if(size < 20)\n        return 0;\n\n    if(buf[0] != 0xca || buf[1] != 0xca || buf[2] != 'C' || buf[3] != 'V')\n    {\n        debug(\""caca import error: expected \\\\xca\\\\xcaCV header\"");\n        goto invalid_caca;\n    }\n\n    control_size = sscanu32(buf + 4);\n    data_size = sscanu32(buf + 8);\n    version = sscanu16(buf + 12);\n    frames = sscanu32(buf + 14);\n    flags = sscanu16(buf + 18);\n\n    if(size < 4 + control_size + data_size)\n        return 0;\n\n    if(control_size < 16 + frames * 32)\n    {\n        debug(\""caca import error: control size %u < expected %u\"",\n              (unsigned int)control_size, 16 + frames * 32);\n        goto invalid_caca;\n    }\n\n    for(expected_size = 0, f = 0; f < frames; f++)\n    {\n        unsigned int width, height, duration;\n        uint32_t attr;\n        int x, y, handlex, handley;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        duration = sscanu32(buf + 4 + 16 + f * 32 + 8);\n        attr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n        expected_size += width * height * 8;\n        if(-handlex < xmin)\n            xmin = -handlex;\n        if(-handley < ymin)\n            ymin = -handley;\n        if((((int32_t) width) - handlex) > xmax)\n            xmax = ((int32_t) width) - handlex;\n        if((((int32_t) height) - handley) > ymax)\n            ymax = ((int32_t) height) - handley;\n    }\n\n    if(expected_size != data_size)\n    {\n        debug(\""caca import error: data size %u < expected %u\"",\n              (unsigned int)data_size, (unsigned int)expected_size);\n        goto invalid_caca;\n    }\n\n    caca_set_canvas_size(cv, 0, 0);\n    caca_set_canvas_size(cv, xmax - xmin, ymax - ymin);\n\n    for (f = caca_get_frame_count(cv); f--; )\n    {\n        caca_free_frame(cv, f);\n    }\n\n    for (offset = 0, f = 0; f < frames; f ++)\n    {\n        unsigned int width, height;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        caca_create_frame(cv, f);\n        caca_set_frame(cv, f);\n\n        cv->curattr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        cv->frames[f].x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        cv->frames[f].y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        cv->frames[f].handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        cv->frames[f].handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n\n        /* FIXME: check for return value */\n\n        for(n = width * height; n--; )\n        {\n            int x = (n % width) - cv->frames[f].handlex - xmin;\n            int y = (n / width) - cv->frames[f].handley - ymin;\n\n            caca_put_char(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n));\n            caca_put_attr(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n + 4));\n        }\n        offset += width * height * 8;\n\n        cv->frames[f].x -= cv->frames[f].handlex;\n        cv->frames[f].y -= cv->frames[f].handley;\n        cv->frames[f].handlex = -xmin;\n        cv->frames[f].handley = -ymin;\n    }\n\n    caca_set_frame(cv, 0);\n\n    return (ssize_t)(4 + control_size + data_size);\n\ninvalid_caca:\n    seterrno(EINVAL);\n    return -1;\n}\n"", ""caller_start"": 296, ""file_path"": ""caca/codec/import.c""}, {""call_line"": 419, ""call_code"": ""caca_set_canvas_size(cv, 0, 0)"", ""caller_code"": ""ssize_t _import_bin(caca_canvas_t *cv, void const *data, size_t len)\n{\n    uint8_t const *buf = (uint8_t const *)data;\n    size_t i;\n    int x = 0, y = 0;\n\n    caca_set_canvas_size(cv, 0, 0);\n    caca_set_canvas_size(cv, 160, len / 160);\n\n    for (i = 0; i < len; i += 2)\n    {\n        caca_set_color_ansi(cv, buf[i + 1] & 0xf, buf[i + 1] >> 4);\n        caca_put_char(cv, x, y, caca_cp437_to_utf32(buf[i]));\n\n        ++x;\n        if (x >= 160)\n        {\n            ++y;\n            x = 0;\n        }\n    }\n\n    return len & ~(size_t)1;\n}"", ""caller_start"": 413, ""file_path"": ""caca/codec/import.c""}]}, {""source"": ""caller_info(file:php_caca.c, func:caca_set_canvas_size)"", ""result"": [{""call_line"": 442, ""call_code"": ""caca_set_canvas_size(canvas, width, height)"", ""caller_code"": ""PHP_FUNCTION(caca_set_canvas_size) {\n    zval *_zval;\n    long width, height = 0;\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""rll\"", &_zval, &width, &height) == FAILURE) {\n        RETURN_FALSE;\n    }\n    caca_canvas_t *canvas;\n    ZEND_FETCH_RESOURCE(canvas, caca_canvas_t*, &_zval, -1, PHP_CACA_CANVAS_RES_NAME, le_caca_canvas);\n    RETURN_SUCCESS(caca_set_canvas_size(canvas, width, height));\n}"", ""caller_start"": 434, ""file_path"": ""caca-php/php_caca.c""}, {""call_line"": 361, ""call_code"": ""caca_set_canvas_size(cv, 0, 0)"", ""caller_code"": ""static ssize_t import_caca(caca_canvas_t *cv, void const *data, size_t size)\n{\n    uint8_t const *buf = (uint8_t const *)data;\n    size_t control_size, data_size, expected_size;\n    unsigned int frames, f, n, offset;\n    uint16_t version, flags;\n    int32_t xmin = 0, ymin = 0, xmax = 0, ymax = 0;\n\n    if(size < 20)\n        return 0;\n\n    if(buf[0] != 0xca || buf[1] != 0xca || buf[2] != 'C' || buf[3] != 'V')\n    {\n        debug(\""caca import error: expected \\\\xca\\\\xcaCV header\"");\n        goto invalid_caca;\n    }\n\n    control_size = sscanu32(buf + 4);\n    data_size = sscanu32(buf + 8);\n    version = sscanu16(buf + 12);\n    frames = sscanu32(buf + 14);\n    flags = sscanu16(buf + 18);\n\n    if(size < 4 + control_size + data_size)\n        return 0;\n\n    if(control_size < 16 + frames * 32)\n    {\n        debug(\""caca import error: control size %u < expected %u\"",\n              (unsigned int)control_size, 16 + frames * 32);\n        goto invalid_caca;\n    }\n\n    for(expected_size = 0, f = 0; f < frames; f++)\n    {\n        unsigned int width, height, duration;\n        uint32_t attr;\n        int x, y, handlex, handley;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        duration = sscanu32(buf + 4 + 16 + f * 32 + 8);\n        attr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n        expected_size += width * height * 8;\n        if(-handlex < xmin)\n            xmin = -handlex;\n        if(-handley < ymin)\n            ymin = -handley;\n        if((((int32_t) width) - handlex) > xmax)\n            xmax = ((int32_t) width) - handlex;\n        if((((int32_t) height) - handley) > ymax)\n            ymax = ((int32_t) height) - handley;\n    }\n\n    if(expected_size != data_size)\n    {\n        debug(\""caca import error: data size %u < expected %u\"",\n              (unsigned int)data_size, (unsigned int)expected_size);\n        goto invalid_caca;\n    }\n\n    caca_set_canvas_size(cv, 0, 0);\n    caca_set_canvas_size(cv, xmax - xmin, ymax - ymin);\n\n    for (f = caca_get_frame_count(cv); f--; )\n    {\n        caca_free_frame(cv, f);\n    }\n\n    for (offset = 0, f = 0; f < frames; f ++)\n    {\n        unsigned int width, height;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        caca_create_frame(cv, f);\n        caca_set_frame(cv, f);\n\n        cv->curattr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        cv->frames[f].x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        cv->frames[f].y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        cv->frames[f].handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        cv->frames[f].handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n\n        /* FIXME: check for return value */\n\n        for(n = width * height; n--; )\n        {\n            int x = (n % width) - cv->frames[f].handlex - xmin;\n            int y = (n / width) - cv->frames[f].handley - ymin;\n\n            caca_put_char(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n));\n            caca_put_attr(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n + 4));\n        }\n        offset += width * height * 8;\n\n        cv->frames[f].x -= cv->frames[f].handlex;\n        cv->frames[f].y -= cv->frames[f].handley;\n        cv->frames[f].handlex = -xmin;\n        cv->frames[f].handley = -ymin;\n    }\n\n    caca_set_frame(cv, 0);\n\n    return (ssize_t)(4 + control_size + data_size);\n\ninvalid_caca:\n    seterrno(EINVAL);\n    return -1;\n}\n"", ""caller_start"": 296, ""file_path"": ""caca/codec/import.c""}, {""call_line"": 362, ""call_code"": ""caca_set_canvas_size(cv, xmax - xmin, ymax - ymin)"", ""caller_code"": ""static ssize_t import_caca(caca_canvas_t *cv, void const *data, size_t size)\n{\n    uint8_t const *buf = (uint8_t const *)data;\n    size_t control_size, data_size, expected_size;\n    unsigned int frames, f, n, offset;\n    uint16_t version, flags;\n    int32_t xmin = 0, ymin = 0, xmax = 0, ymax = 0;\n\n    if(size < 20)\n        return 0;\n\n    if(buf[0] != 0xca || buf[1] != 0xca || buf[2] != 'C' || buf[3] != 'V')\n    {\n        debug(\""caca import error: expected \\\\xca\\\\xcaCV header\"");\n        goto invalid_caca;\n    }\n\n    control_size = sscanu32(buf + 4);\n    data_size = sscanu32(buf + 8);\n    version = sscanu16(buf + 12);\n    frames = sscanu32(buf + 14);\n    flags = sscanu16(buf + 18);\n\n    if(size < 4 + control_size + data_size)\n        return 0;\n\n    if(control_size < 16 + frames * 32)\n    {\n        debug(\""caca import error: control size %u < expected %u\"",\n              (unsigned int)control_size, 16 + frames * 32);\n        goto invalid_caca;\n    }\n\n    for(expected_size = 0, f = 0; f < frames; f++)\n    {\n        unsigned int width, height, duration;\n        uint32_t attr;\n        int x, y, handlex, handley;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        duration = sscanu32(buf + 4 + 16 + f * 32 + 8);\n        attr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n        expected_size += width * height * 8;\n        if(-handlex < xmin)\n            xmin = -handlex;\n        if(-handley < ymin)\n            ymin = -handley;\n        if((((int32_t) width) - handlex) > xmax)\n            xmax = ((int32_t) width) - handlex;\n        if((((int32_t) height) - handley) > ymax)\n            ymax = ((int32_t) height) - handley;\n    }\n\n    if(expected_size != data_size)\n    {\n        debug(\""caca import error: data size %u < expected %u\"",\n              (unsigned int)data_size, (unsigned int)expected_size);\n        goto invalid_caca;\n    }\n\n    caca_set_canvas_size(cv, 0, 0);\n    caca_set_canvas_size(cv, xmax - xmin, ymax - ymin);\n\n    for (f = caca_get_frame_count(cv); f--; )\n    {\n        caca_free_frame(cv, f);\n    }\n\n    for (offset = 0, f = 0; f < frames; f ++)\n    {\n        unsigned int width, height;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        caca_create_frame(cv, f);\n        caca_set_frame(cv, f);\n\n        cv->curattr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        cv->frames[f].x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        cv->frames[f].y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        cv->frames[f].handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        cv->frames[f].handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n\n        /* FIXME: check for return value */\n\n        for(n = width * height; n--; )\n        {\n            int x = (n % width) - cv->frames[f].handlex - xmin;\n            int y = (n / width) - cv->frames[f].handley - ymin;\n\n            caca_put_char(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n));\n            caca_put_attr(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n + 4));\n        }\n        offset += width * height * 8;\n\n        cv->frames[f].x -= cv->frames[f].handlex;\n        cv->frames[f].y -= cv->frames[f].handley;\n        cv->frames[f].handlex = -xmin;\n        cv->frames[f].handley = -ymin;\n    }\n\n    caca_set_frame(cv, 0);\n\n    return (ssize_t)(4 + control_size + data_size);\n\ninvalid_caca:\n    seterrno(EINVAL);\n    return -1;\n}\n"", ""caller_start"": 296, ""file_path"": ""caca/codec/import.c""}, {""call_line"": 419, ""call_code"": ""caca_set_canvas_size(cv, 0, 0)"", ""caller_code"": ""ssize_t _import_bin(caca_canvas_t *cv, void const *data, size_t len)\n{\n    uint8_t const *buf = (uint8_t const *)data;\n    size_t i;\n    int x = 0, y = 0;\n\n    caca_set_canvas_size(cv, 0, 0);\n    caca_set_canvas_size(cv, 160, len / 160);\n\n    for (i = 0; i < len; i += 2)\n    {\n        caca_set_color_ansi(cv, buf[i + 1] & 0xf, buf[i + 1] >> 4);\n        caca_put_char(cv, x, y, caca_cp437_to_utf32(buf[i]));\n\n        ++x;\n        if (x >= 160)\n        {\n            ++y;\n            x = 0;\n        }\n    }\n\n    return len & ~(size_t)1;\n}"", ""caller_start"": 413, ""file_path"": ""caca/codec/import.c""}]}, {""source"": ""func_info(file:import.c, func:import_caca)"", ""result"": [{""code"": ""static ssize_t import_caca(caca_canvas_t *cv, void const *data, size_t size)\n{\n    uint8_t const *buf = (uint8_t const *)data;\n    size_t control_size, data_size, expected_size;\n    unsigned int frames, f, n, offset;\n    uint16_t version, flags;\n    int32_t xmin = 0, ymin = 0, xmax = 0, ymax = 0;\n\n    if(size < 20)\n        return 0;\n\n    if(buf[0] != 0xca || buf[1] != 0xca || buf[2] != 'C' || buf[3] != 'V')\n    {\n        debug(\""caca import error: expected \\\\xca\\\\xcaCV header\"");\n        goto invalid_caca;\n    }\n\n    control_size = sscanu32(buf + 4);\n    data_size = sscanu32(buf + 8);\n    version = sscanu16(buf + 12);\n    frames = sscanu32(buf + 14);\n    flags = sscanu16(buf + 18);\n\n    if(size < 4 + control_size + data_size)\n        return 0;\n\n    if(control_size < 16 + frames * 32)\n    {\n        debug(\""caca import error: control size %u < expected %u\"",\n              (unsigned int)control_size, 16 + frames * 32);\n        goto invalid_caca;\n    }\n\n    for(expected_size = 0, f = 0; f < frames; f++)\n    {\n        unsigned int width, height, duration;\n        uint32_t attr;\n        int x, y, handlex, handley;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        duration = sscanu32(buf + 4 + 16 + f * 32 + 8);\n        attr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n        expected_size += width * height * 8;\n        if(-handlex < xmin)\n            xmin = -handlex;\n        if(-handley < ymin)\n            ymin = -handley;\n        if((((int32_t) width) - handlex) > xmax)\n            xmax = ((int32_t) width) - handlex;\n        if((((int32_t) height) - handley) > ymax)\n            ymax = ((int32_t) height) - handley;\n    }\n\n    if(expected_size != data_size)\n    {\n        debug(\""caca import error: data size %u < expected %u\"",\n              (unsigned int)data_size, (unsigned int)expected_size);\n        goto invalid_caca;\n    }\n\n    caca_set_canvas_size(cv, 0, 0);\n    caca_set_canvas_size(cv, xmax - xmin, ymax - ymin);\n\n    for (f = caca_get_frame_count(cv); f--; )\n    {\n        caca_free_frame(cv, f);\n    }\n\n    for (offset = 0, f = 0; f < frames; f ++)\n    {\n        unsigned int width, height;\n\n        width = sscanu32(buf + 4 + 16 + f * 32);\n        height = sscanu32(buf + 4 + 16 + f * 32 + 4);\n        caca_create_frame(cv, f);\n        caca_set_frame(cv, f);\n\n        cv->curattr = sscanu32(buf + 4 + 16 + f * 32 + 12);\n        cv->frames[f].x = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 16);\n        cv->frames[f].y = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 20);\n        cv->frames[f].handlex = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 24);\n        cv->frames[f].handley = (int32_t)sscanu32(buf + 4 + 16 + f * 32 + 28);\n\n        /* FIXME: check for return value */\n\n        for(n = width * height; n--; )\n        {\n            int x = (n % width) - cv->frames[f].handlex - xmin;\n            int y = (n / width) - cv->frames[f].handley - ymin;\n\n            caca_put_char(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n));\n            caca_put_attr(cv, x, y, sscanu32(buf + 4 + control_size\n                                               + offset + 8 * n + 4));\n        }\n        offset += width * height * 8;\n\n        cv->frames[f].x -= cv->frames[f].handlex;\n        cv->frames[f].y -= cv->frames[f].handley;\n        cv->frames[f].handlex = -xmin;\n        cv->frames[f].handley = -ymin;\n    }\n\n    caca_set_frame(cv, 0);\n\n    return (ssize_t)(4 + control_size + data_size);\n\ninvalid_caca:\n    seterrno(EINVAL);\n    return -1;\n}\n"", ""start_line"": 296, ""end_line"": 411, ""full_name"": ""import_caca"", ""file_path"": ""caca/codec/import.c""}]}]","Integer overflow in `caca_resize()` (caca/canvas.c:376) during `new_size = width * height` calculation. This occurs when user-controlled `width` and `height` values (e.g., from `_import_text` (caca/codec/text.c:68,71), `_import_ansi` (caca/codec/text.c:432,449), or `import_caca` (caca/codec/import.c:361,362)) are large enough to overflow the multiplication. The overflow results in an undersized buffer allocation, leading to a buffer overflow during subsequent writes. The patch (caca/canvas.c:378-383) checks for overflow via `new_size / width != height`, preventing invalid allocations. Pre-patch, functions like `_import_text` and `_import_ansi` did not validate `caca_set_canvas_size()` return values, allowing unchecked inputs.",0.95,./github/other_context/CVE-2021-3410
32,CVE-2021-40346,CWE-190,c_cpp,"An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs.",https://github.com/haproxy/haproxy/commit/3b69886f7dcc3cfb3d166309018e6cfec9ce2c95,"BUG/MAJOR: htx: fix missing header name length check in htx_add_header/trailer\n\nOri Hollander of JFrog Security reported that htx_add_header() and\nhtx_add_trailer() were missing a length check on the header name. While\nthis does not allow to overwrite any memory area, it results in bits of\nthe header name length to slip into the header value length and may\nresult in forging certain header names on the input. The sad thing here\nis that a FIXME comment was present suggesting to add the required length\nchecks :-(\n\nThe injected headers are visible to the HTTP internals and to the config\nrules, so haproxy will generally stay synchronized with the server. But\nthere is one exception which is the content-length header field, because\nit is already deduplicated on the input, but before being indexed. As\nsuch, injecting a content-length header after the deduplication stage\nmay be abused to present a different, shorter one on the other side and\nhelp build a request smuggling attack, or even maybe a response splitting\nattack. CVE-2021-40346 was assigned to this problem.\n\nAs a mitigation measure, it is sufficient to verify that no more than\none such header is present in any message, which is normally the case\nthanks to the duplicate checks:\n\n   http-request  deny if { req.hdr_cnt(content-length) gt 1 }\n   http-response deny if { res.hdr_cnt(content-length) gt 1 }\n\nThis must be backported to all HTX-enabled versions, hence as far as 2.0.\nIn 2.3 and earlier, the functions are in src/htx.c instead.\n\nMany thanks to Ori for his work and his responsible report!",2,"[{""func_name"": ""htx_add_header"", ""file_path"": ""include/haproxy/htx.h"", ""func_code"": ""static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}"", ""target"": 0}, {""func_name"": ""htx_add_trailer"", ""file_path"": ""include/haproxy/htx.h"", ""func_code"": ""static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}"", ""target"": 0}]","[{""func_name"": ""htx_add_header"", ""file_path"": ""include/haproxy/htx.h"", ""func_code"": ""static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\tif (name.len > 255 || value.len > 1048575)\n\t\treturn NULL;\n\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}""}, {""func_name"": ""htx_add_trailer"", ""file_path"": ""include/haproxy/htx.h"", ""func_code"": ""static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\tif (name.len > 255 || value.len > 1048575)\n\t\treturn NULL;\n\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}""}]","{""caller"": 4, ""value"": 1, ""function"": 3, ""code"": 1}","[{""source"": ""caller_info(file:htx.h, func:htx_add_header)"", ""result"": [{""call_line"": 522, ""call_code"": ""htx_add_header(htx, hdrs[i].n, hdrs[i].v)"", ""caller_code"": ""static inline struct htx_blk *htx_add_all_headers(struct htx *htx, const struct http_hdr *hdrs)\n{\n\tint i;\n\n\tfor (i = 0; hdrs[i].n.len; i++) {\n\t\tif (!htx_add_header(htx, hdrs[i].n, hdrs[i].v))\n\t\t\treturn NULL;\n\t}\n\treturn htx_add_endof(htx, HTX_BLK_EOH);\n}"", ""caller_start"": 517, ""file_path"": ""include/haproxy/htx.h""}, {""call_line"": 1415, ""call_code"": ""htx_add_header(htx, ist(\""Cache-Control\""), ist(\""no-cache\""))"", ""caller_code"": ""static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\n{\n\tstruct channel *chn = si_ic(appctx->owner);\n\tstruct htx_sl *sl;\n\tunsigned int flags;\n\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\""HTTP/1.1\""), ist(\""200\""), ist(\""OK\""));\n\tif (!sl)\n\t\tgoto full;\n\tsl->info.res.status = 200;\n\tif (!htx_add_header(htx, ist(\""Cache-Control\""), ist(\""no-cache\"")) ||\n\t    !htx_add_header(htx, ist(\""Content-Type\""), ist(\""text/plain; version=0.0.4\"")) ||\n\t    !htx_add_header(htx, ist(\""Transfer-Encoding\""), ist(\""chunked\"")) ||\n\t    !htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto full;\n\n\tchannel_add_input(chn, htx->data);\n\treturn 1;\n  full:\n\thtx_reset(htx);\n\tsi_rx_room_blk(si);\n\treturn 0;\n}"", ""caller_start"": 1404, ""file_path"": ""addons/promex/service-prometheus.c""}, {""call_line"": 1416, ""call_code"": ""htx_add_header(htx, ist(\""Content-Type\""), ist(\""text/plain; version=0.0.4\""))"", ""caller_code"": ""static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\n{\n\tstruct channel *chn = si_ic(appctx->owner);\n\tstruct htx_sl *sl;\n\tunsigned int flags;\n\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\""HTTP/1.1\""), ist(\""200\""), ist(\""OK\""));\n\tif (!sl)\n\t\tgoto full;\n\tsl->info.res.status = 200;\n\tif (!htx_add_header(htx, ist(\""Cache-Control\""), ist(\""no-cache\"")) ||\n\t    !htx_add_header(htx, ist(\""Content-Type\""), ist(\""text/plain; version=0.0.4\"")) ||\n\t    !htx_add_header(htx, ist(\""Transfer-Encoding\""), ist(\""chunked\"")) ||\n\t    !htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto full;\n\n\tchannel_add_input(chn, htx->data);\n\treturn 1;\n  full:\n\thtx_reset(htx);\n\tsi_rx_room_blk(si);\n\treturn 0;\n}"", ""caller_start"": 1404, ""file_path"": ""addons/promex/service-prometheus.c""}, {""call_line"": 1417, ""call_code"": ""htx_add_header(htx, ist(\""Transfer-Encoding\""), ist(\""chunked\""))"", ""caller_code"": ""static int promex_send_headers(struct appctx *appctx, struct stream_interface *si, struct htx *htx)\n{\n\tstruct channel *chn = si_ic(appctx->owner);\n\tstruct htx_sl *sl;\n\tunsigned int flags;\n\n\tflags = (HTX_SL_F_IS_RESP|HTX_SL_F_VER_11|HTX_SL_F_XFER_ENC|HTX_SL_F_XFER_LEN|HTX_SL_F_CHNK);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, ist(\""HTTP/1.1\""), ist(\""200\""), ist(\""OK\""));\n\tif (!sl)\n\t\tgoto full;\n\tsl->info.res.status = 200;\n\tif (!htx_add_header(htx, ist(\""Cache-Control\""), ist(\""no-cache\"")) ||\n\t    !htx_add_header(htx, ist(\""Content-Type\""), ist(\""text/plain; version=0.0.4\"")) ||\n\t    !htx_add_header(htx, ist(\""Transfer-Encoding\""), ist(\""chunked\"")) ||\n\t    !htx_add_endof(htx, HTX_BLK_EOH))\n\t\tgoto full;\n\n\tchannel_add_input(chn, htx->data);\n\treturn 1;\n  full:\n\thtx_reset(htx);\n\tsi_rx_room_blk(si);\n\treturn 0;\n}"", ""caller_start"": 1404, ""file_path"": ""addons/promex/service-prometheus.c""}]}, {""source"": ""caller_info(file:htx.h, func:htx_add_trailer)"", ""result"": [{""call_line"": 536, ""call_code"": ""htx_add_trailer(htx, hdrs[i].n, hdrs[i].v)"", ""caller_code"": ""static inline struct htx_blk *htx_add_all_trailers(struct htx *htx, const struct http_hdr *hdrs)\n{\n\tint i;\n\n\tfor (i = 0; hdrs[i].n.len; i++) {\n\t\tif (!htx_add_trailer(htx, hdrs[i].n, hdrs[i].v))\n\t\t\treturn NULL;\n\t}\n\treturn htx_add_endof(htx, HTX_BLK_EOT);\n}"", ""caller_start"": 531, ""file_path"": ""include/haproxy/htx.h""}, {""call_line"": 907, ""call_code"": ""htx_add_trailer(htx, list[idx].n, list[idx].v)"", ""caller_code"": ""int h2_make_htx_trailers(struct http_hdr *list, struct htx *htx)\n{\n\tconst char *ctl;\n\tuint32_t idx;\n\tint i;\n\n\tfor (idx = 0; list[idx].n.len != 0; idx++) {\n\t\tif (!list[idx].n.ptr) {\n\t\t\t/* This is an indexed pseudo-header (RFC7540#8.1.2.1) */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* RFC7540#8.1.2: upper case not allowed in header field names.\n\t\t * #10.3: header names must be valid (i.e. match a token). This\n\t\t * also catches pseudo-headers which are forbidden in trailers.\n\t\t */\n\t\tfor (i = 0; i < list[idx].n.len; i++)\n\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n\t\t\t\tgoto fail;\n\n\t\t/* these ones are forbidden in trailers (RFC7540#8.1.2.2) */\n\t\tif (isteq(list[idx].n, ist(\""host\"")) ||\n\t\t    isteq(list[idx].n, ist(\""content-length\"")) ||\n\t\t    isteq(list[idx].n, ist(\""connection\"")) ||\n\t\t    isteq(list[idx].n, ist(\""proxy-connection\"")) ||\n\t\t    isteq(list[idx].n, ist(\""keep-alive\"")) ||\n\t\t    isteq(list[idx].n, ist(\""upgrade\"")) ||\n\t\t    isteq(list[idx].n, ist(\""te\"")) ||\n\t\t    isteq(list[idx].n, ist(\""transfer-encoding\"")))\n\t\t\tgoto fail;\n\n\t\t/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of\n\t\t * rejecting NUL, CR and LF characters.\n\t\t */\n\t\tctl = ist_find_ctl(list[idx].v);\n\t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n\t\t\tgoto fail;\n\n\t\tif (!htx_add_trailer(htx, list[idx].n, list[idx].v))\n\t\t\tgoto fail;\n\t}\n\n\tif (!htx_add_endof(htx, HTX_BLK_EOT))\n\t\tgoto fail;\n\n\treturn 1;\n\n fail:\n\treturn -1;\n}\n"", ""caller_start"": 869, ""file_path"": ""src/h2.c""}]}, {""source"": ""caller_info(file:htx.h, func:htx_add_all_headers)"", ""result"": [{""call_line"": 183, ""call_code"": ""htx_add_all_headers(htx, hdrs)"", ""caller_code"": ""static int h1_postparse_req_hdrs(struct h1m *h1m, union h1_sl *h1sl, struct htx *htx,\n\t\t\t\t struct http_hdr *hdrs, size_t max)\n{\n\tstruct htx_sl *sl;\n\tstruct ist meth, uri, vsn;\n\tunsigned int flags;\n\n\t/* <h1sl> is always defined for a request */\n\tmeth = h1sl->rq.m;\n\turi  = h1sl->rq.u;\n\tvsn  = h1sl->rq.v;\n\n\t/* Be sure the message, once converted into HTX, will not exceed the max\n\t * size allowed.\n\t */\n\tif (h1_eval_htx_size(meth, uri, vsn, hdrs) > max) {\n\t\tif (htx_is_empty(htx))\n\t\t\tgoto error;\n\t\th1m_init_res(h1m);\n\t\th1m->flags |= (H1_MF_NO_PHDR|H1_MF_CLEAN_CONN_HDR);\n\t\treturn 0;\n\t}\n\n\t/* By default, request have always a known length */\n\th1m->flags |= H1_MF_XFER_LEN;\n\n\tif (h1sl->rq.meth == HTTP_METH_CONNECT) {\n\t\th1m->flags &= ~(H1_MF_CLEN|H1_MF_CHNK);\n\t\th1m->curr_len = h1m->body_len = 0;\n\t}\n\n\tflags = h1m_htx_sl_flags(h1m);\n\tsl = htx_add_stline(htx, HTX_BLK_REQ_SL, flags, meth, uri, vsn);\n\tif (!sl || !htx_add_all_headers(htx, hdrs))\n\t\tgoto error;\n\tsl->info.req.meth = h1sl->rq.meth;\n\n\t/* Check if the uri contains an authority. Also check if it contains an\n\t * explicit scheme and if it is \""http\"" or \""https\"". */\n\tif (h1sl->rq.meth == HTTP_METH_CONNECT)\n\t\tsl->flags |= HTX_SL_F_HAS_AUTHORITY;\n\telse if (uri.len && uri.ptr[0] != '/' && uri.ptr[0] != '*') {\n\t\tsl->flags |= (HTX_SL_F_HAS_AUTHORITY|HTX_SL_F_HAS_SCHM);\n\t\tif (uri.len > 4 && (uri.ptr[0] | 0x20) == 'h')\n\t\t\tsl->flags |= ((uri.ptr[4] == ':') ? HTX_SL_F_SCHM_HTTP : HTX_SL_F_SCHM_HTTPS);\n\n\t\t/* absolute-form target URI present, proceed to scheme-based\n\t\t * normalization */\n\t\thttp_scheme_based_normalize(htx);\n\t}\n\n\t/* If body length cannot be determined, set htx->extra to\n\t * ULLONG_MAX. This value is impossible in other cases.\n\t */\n\thtx->extra = ((h1m->flags & H1_MF_XFER_LEN) ? h1m->curr_len : ULLONG_MAX);\n\n  end:\n\treturn 1;\n  error:\n\th1m->err_pos = h1m->next;\n\th1m->err_state = h1m->state;\n\thtx->flags |= HTX_FL_PARSING_ERROR;\n\treturn 0;\n}\n"", ""caller_start"": 150, ""file_path"": ""src/h1_htx.c""}, {""call_line"": 290, ""call_code"": ""htx_add_all_headers(htx, hdrs)"", ""caller_code"": ""static int h1_postparse_res_hdrs(struct h1m *h1m, union h1_sl *h1sl, struct htx *htx,\n\t\t\t\t struct http_hdr *hdrs, size_t max)\n{\n\tstruct htx_sl *sl;\n\tstruct ist vsn, status, reason;\n\tunsigned int flags;\n\tuint16_t code = 0;\n\n\tif (h1sl) {\n\t\t/* For HTTP responses, the start-line was parsed */\n\t\tcode   = h1sl->st.status;\n\t\tvsn    = h1sl->st.v;\n\t\tstatus = h1sl->st.c;\n\t\treason = h1sl->st.r;\n\t}\n\telse {\n\t\t/* For FCGI responses, there is no start(-line but the \""Status\""\n\t\t * header must be parsed, if found.\n\t\t */\n\t\tint hdr;\n\n\t\tvsn = ((h1m->flags & H1_MF_VER_11) ? ist(\""HTTP/1.1\"") : ist(\""HTTP/1.0\""));\n\t\tfor (hdr = 0; hdrs[hdr].n.len; hdr++) {\n\t\t\tif (isteqi(hdrs[hdr].n, ist(\""status\""))) {\n\t\t\t\tcode = http_parse_status_val(hdrs[hdr].v, &status, &reason);\n\t\t\t}\n\t\t\telse if (isteqi(hdrs[hdr].n, ist(\""location\""))) {\n\t\t\t\tcode = 302;\n\t\t\t\tstatus = ist(\""302\"");\n\t\t\t\treason = ist(\""Moved Temporarily\"");\n\t\t\t}\n\t\t}\n\t\tif (!code) {\n\t\t\tcode = 200;\n\t\t\tstatus = ist(\""200\"");\n\t\t\treason = ist(\""OK\"");\n\t\t}\n\t\t/* FIXME: Check the codes 1xx ? */\n\t}\n\n\t/* Be sure the message, once converted into HTX, will not exceed the max\n\t * size allowed.\n\t */\n\tif (h1_eval_htx_size(vsn, status, reason, hdrs) > max) {\n\t\tif (htx_is_empty(htx))\n\t\t\tgoto error;\n\t\th1m_init_res(h1m);\n\t\th1m->flags |= (H1_MF_NO_PHDR|H1_MF_CLEAN_CONN_HDR);\n\t\treturn 0;\n\t}\n\n\tif (((h1m->flags & H1_MF_METH_CONNECT) && code >= 200 && code < 300) || code == 101) {\n\t\th1m->flags &= ~(H1_MF_CLEN|H1_MF_CHNK);\n\t\th1m->flags |= H1_MF_XFER_LEN;\n\t\th1m->curr_len = h1m->body_len = 0;\n\t}\n\telse if ((h1m->flags & H1_MF_METH_HEAD) || (code >= 100 && code < 200) ||\n\t\t (code == 204) || (code == 304)) {\n\t\t/* Responses known to have no body. */\n\t\th1m->flags &= ~(H1_MF_CLEN|H1_MF_CHNK);\n\t\th1m->flags |= H1_MF_XFER_LEN;\n\t\th1m->curr_len = h1m->body_len = 0;\n\t}\n\telse if (h1m->flags & (H1_MF_CLEN|H1_MF_CHNK)) {\n\t\t/* Responses with a known body length. */\n\t\th1m->flags |= H1_MF_XFER_LEN;\n\t}\n\n\tflags = h1m_htx_sl_flags(h1m);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, vsn, status, reason);\n\tif (!sl || !htx_add_all_headers(htx, hdrs))\n\t\tgoto error;\n\tsl->info.res.status = code;\n\n\t/* If body length cannot be determined, set htx->extra to\n\t * ULLONG_MAX. This value is impossible in other cases.\n\t */\n\thtx->extra = ((h1m->flags & H1_MF_XFER_LEN) ? h1m->curr_len : ULLONG_MAX);\n\n  end:\n\treturn 1;\n  error:\n\th1m->err_pos = h1m->next;\n\th1m->err_state = h1m->state;\n\thtx->flags |= HTX_FL_PARSING_ERROR;\n\treturn 0;\n}\n"", ""caller_start"": 220, ""file_path"": ""src/h1_htx.c""}, {""call_line"": 286, ""call_code"": ""htx_add_all_headers(htx, hdrs)"", ""caller_code"": ""int httpclient_req_gen(struct httpclient *hc, const struct ist url, enum http_meth_t meth, const struct http_hdr *hdrs)\n{\n\tstruct htx_sl *sl;\n\tstruct htx *htx;\n\tint err_code = 0;\n\tstruct ist meth_ist, vsn;\n\tunsigned int flags = HTX_SL_F_VER_11 | HTX_SL_F_BODYLESS | HTX_SL_F_XFER_LEN | HTX_SL_F_NORMALIZED_URI | HTX_SL_F_HAS_SCHM;\n\n\tif (meth >= HTTP_METH_OTHER)\n\t\tgoto error;\n\n\tmeth_ist = http_known_methods[meth];\n\n\tvsn = ist(\""HTTP/1.1\"");\n\n\thtx = htx_from_buf(&hc->req.buf);\n\tif (!htx)\n\t\tgoto error;\n\tsl = htx_add_stline(htx, HTX_BLK_REQ_SL, flags, meth_ist, url, vsn);\n\tif (!sl) {\n\t\tgoto error;\n\t}\n\tsl->info.req.meth = meth;\n\n\t/* Add Host Header from URL */\n\tif (!htx_add_header(htx, ist(\""Host\""), IST_NULL))\n\t\tgoto error;\n\tif (!http_update_host(htx, sl, url))\n\t\tgoto error;\n\n\t/* add the headers and EOH */\n\tif (hdrs && !htx_add_all_headers(htx, hdrs))\n\t\tgoto error;\n\n\thtx->flags |= HTX_FL_EOM;\n\n\thtx_to_buf(htx, &hc->req.buf);\n\n\treturn 0;\nerror:\n\terr_code |= ERR_ALERT | ERR_ABORT;\n\treturn err_code;\n}\n"", ""caller_start"": 255, ""file_path"": ""src/http_client.c""}, {""call_line"": 289, ""call_code"": ""htx_add_all_headers(htx, hdrs)"", ""caller_code"": ""struct htx *smp_prefetch_htx(struct sample *smp, struct channel *chn, struct check *check, int vol)\n{\n\tstruct stream *s = smp->strm;\n\tstruct http_txn *txn = NULL;\n\tstruct htx *htx = NULL;\n\tstruct http_msg *msg;\n\tstruct htx_sl *sl;\n\n\tif (chn &&\n\t    (((smp->opt & SMP_OPT_DIR) == SMP_OPT_DIR_REQ && (chn->flags & CF_ISRESP)) ||\n\t     ((smp->opt & SMP_OPT_DIR) == SMP_OPT_DIR_RES && !(chn->flags & CF_ISRESP))))\n\t\treturn 0;\n\n\t/* Note: it is possible that <s> is NULL when called before stream\n\t * initialization (eg: tcp-request connection), so this function is the\n\t * one responsible for guarding against this case for all HTTP users.\n\t *\n\t * In the health check context, the stream and the channel must be NULL\n\t * and <check> must be set. In this case, only the input buffer,\n\t * corresponding to the response, is considered. It is the caller\n\t * responsibility to provide <check>.\n\t */\n\tBUG_ON(check && (s || chn));\n\tif (!s || !chn) {\n\t\tif (check) {\n\t\t\thtx = htxbuf(&check->bi);\n\n\t\t\t/* Analyse not yet started */\n\t\t\tif (htx_is_empty(htx) || htx->first == -1)\n\t\t\t\treturn NULL;\n\n\t\t\tsl = http_get_stline(htx);\n\t\t\tif (vol && !sl) {\n\t\t\t\t/* The start-line was already forwarded, it is too late to fetch anything */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgoto end;\n\t\t}\n\n\t\treturn NULL;\n\t}\n\n\tif (!s->txn && !http_create_txn(s))\n\t\treturn NULL;\n\ttxn = s->txn;\n\tmsg = (!(chn->flags & CF_ISRESP) ? &txn->req : &txn->rsp);\n\n\tif (IS_HTX_STRM(s)) {\n\t\thtx = htxbuf(&chn->buf);\n\n\t\tif (msg->msg_state == HTTP_MSG_ERROR || (htx->flags & HTX_FL_PARSING_ERROR))\n\t\t\treturn NULL;\n\n\t\tif (msg->msg_state < HTTP_MSG_BODY) {\n\t\t\t/* Analyse not yet started */\n\t\t\tif (htx_is_empty(htx) || htx->first == -1) {\n\t\t\t\t/* Parsing is done by the mux, just wait */\n\t\t\t\tsmp->flags |= SMP_F_MAY_CHANGE;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsl = http_get_stline(htx);\n\t\tif (vol && !sl) {\n\t\t\t/* The start-line was already forwarded, it is too late to fetch anything */\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse { /* RAW mode */\n\t\tstruct buffer *buf;\n\t\tstruct h1m h1m;\n\t\tstruct http_hdr hdrs[global.tune.max_http_hdr];\n\t\tunion h1_sl h1sl;\n\t\tunsigned int flags = HTX_FL_NONE;\n\t\tint ret;\n\n\t\t/* no HTTP fetch on the response in TCP mode */\n\t\tif (chn->flags & CF_ISRESP)\n\t\t\treturn NULL;\n\n\t\t/* Now we are working on the request only */\n\t\tbuf = &chn->buf;\n\t\tif (b_head(buf) + b_data(buf) > b_wrap(buf))\n\t\t\tb_slow_realign(buf, trash.area, 0);\n\n\t\th1m_init_req(&h1m);\n\t\tret = h1_headers_to_hdr_list(b_head(buf), b_stop(buf),\n\t\t\t\t\t     hdrs, sizeof(hdrs)/sizeof(hdrs[0]), &h1m, &h1sl);\n\t\tif (ret <= 0) {\n\t\t\t/* Invalid or too big*/\n\t\t\tif (ret < 0 || channel_full(&s->req, global.tune.maxrewrite))\n\t\t\t\treturn NULL;\n\n\t\t\t/* wait for a full request */\n\t\t\tsmp->flags |= SMP_F_MAY_CHANGE;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* OK we just got a valid HTTP message. We have to convert it\n\t\t * into an HTX message.\n\t\t */\n\t\tif (unlikely(h1sl.rq.v.len == 0)) {\n\t\t\t/* try to convert HTTP/0.9 requests to HTTP/1.0 */\n\t\t\tif (h1sl.rq.meth != HTTP_METH_GET || !h1sl.rq.u.len)\n\t\t\t\treturn NULL;\n\t\t\th1sl.rq.v = ist(\""HTTP/1.0\"");\n\t\t}\n\n\t\t/* Set HTX start-line flags */\n\t\tif (h1m.flags & H1_MF_VER_11)\n\t\t\tflags |= HTX_SL_F_VER_11;\n\t\tif (h1m.flags & H1_MF_XFER_ENC)\n\t\t\tflags |= HTX_SL_F_XFER_ENC;\n\t\tflags |= HTX_SL_F_XFER_LEN;\n\t\tif (h1m.flags & H1_MF_CHNK)\n\t\t\tflags |= HTX_SL_F_CHNK;\n\t\telse if (h1m.flags & H1_MF_CLEN)\n\t\t\tflags |= HTX_SL_F_CLEN;\n\n\t\thtx = htx_from_buf(get_raw_htx_chunk());\n\t\tsl = htx_add_stline(htx, HTX_BLK_REQ_SL, flags, h1sl.rq.m, h1sl.rq.u, h1sl.rq.v);\n\t\tif (!sl || !htx_add_all_headers(htx, hdrs))\n\t\t\treturn NULL;\n\t\tsl->info.req.meth = h1sl.rq.meth;\n\t}\n\n\t/* OK we just got a valid HTTP message. If not already done by\n\t * HTTP analyzers, we have some minor preparation to perform so\n\t * that further checks can rely on HTTP tests.\n\t */\n\tif (sl && msg->msg_state < HTTP_MSG_BODY) {\n\t\tif (!(chn->flags & CF_ISRESP)) {\n\t\t\ttxn->meth = sl->info.req.meth;\n\t\t\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\t\t\ts->flags |= SF_REDIRECTABLE;\n\t\t}\n\t\telse\n\t\t\ttxn->status = sl->info.res.status;\n\t\tif (sl->flags & HTX_SL_F_VER_11)\n\t\t\tmsg->flags |= HTTP_MSGF_VER_11;\n\t}\n\n\t/* everything's OK */\n  end:\n\treturn htx;\n}\n"", ""caller_start"": 169, ""file_path"": ""src/http_fetch.c""}]}, {""source"": ""value_info(value:http_hdr)"", ""result"": {""value_trace"": [{""full_code"": ""global.tune.max_http_hdr = atoi(args[1])"", ""line"": 448, ""func_name"": ""cfg_parse_global""}, {""full_code"": ""global.tune.max_http_hdr = MAX_HTTP_HDR"", ""line"": 2409, ""func_name"": ""check_config_validity""}, {""full_code"": "".max_http_hdr = MAX_HTTP_HDR"", ""line"": 194, ""func_name"": ""src/haproxy.c:<global>""}], ""struct_var"": ""http_hdr"", ""struct_type"": ""http_hdr"", ""struct_definition"": ""const struct http_hdr\n\nstatic struct http_hdr\n\nconst struct http_hdr\n\nextern const struct http_hdr\n\nstruct http_hdr {\n\tstruct ist n; /* name */\n\tstruct ist v; /* value */\n}\n\nstruct http_hdr""}}, {""source"": ""func_info(func:h1_headers_to_hdr_list)"", ""result"": [{""code"": ""int h1_headers_to_hdr_list(char *start, const char *stop,\n                           struct http_hdr *hdr, unsigned int hdr_num,\n                           struct h1m *h1m, union h1_sl *slp)\n{\n\tenum h1m_state state;\n\tregister char *ptr;\n\tregister const char *end;\n\tunsigned int hdr_count;\n\tunsigned int skip; /* number of bytes skipped at the beginning */\n\tunsigned int sol;  /* start of line */\n\tunsigned int col;  /* position of the colon */\n\tunsigned int eol;  /* end of line */\n\tunsigned int sov;  /* start of value */\n\tunion h1_sl sl;\n\tint skip_update;\n\tint restarting;\n\tint host_idx;\n\tstruct ist n, v;       /* header name and value during parsing */\n\n\tskip = 0; // do it only once to keep track of the leading CRLF.\n\n try_again:\n\thdr_count = sol = col = eol = sov = 0;\n\tsl.st.status = 0;\n\tskip_update = restarting = 0;\n\thost_idx = -1;\n\n\tif (h1m->flags & H1_MF_HDRS_ONLY) {\n\t\tstate = H1_MSG_HDR_FIRST;\n\t\th1m->next = 0;\n\t}\n\telse {\n\t\tstate = h1m->state;\n\t\tif (h1m->state != H1_MSG_RQBEFORE && h1m->state != H1_MSG_RPBEFORE)\n\t\t\trestarting = 1;\n\t}\n\n\tptr   = start + h1m->next;\n\tend   = stop;\n\n\tif (unlikely(ptr >= end))\n\t\tgoto http_msg_ood;\n\n\t/* don't update output if hdr is NULL or if we're restarting */\n\tif (!hdr || restarting)\n\t\tskip_update = 1;\n\n\tswitch (state)\t{\n\tcase H1_MSG_RQBEFORE:\n\thttp_msg_rqbefore:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\t/* we have a start of message, we may have skipped some\n\t\t\t * heading CRLF. Skip them now.\n\t\t\t */\n\t\t\tskip += ptr - start;\n\t\t\tstart = ptr;\n\n\t\t\tsol = 0;\n\t\t\tsl.rq.m.ptr = ptr;\n\t\t\thdr_count = 0;\n\t\t\tstate = H1_MSG_RQMETH;\n\t\t\tgoto http_msg_rqmeth;\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tstate = H1_MSG_RQBEFORE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (unlikely(*ptr == '\\n'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore, http_msg_ood, state, H1_MSG_RQBEFORE);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore_cr, http_msg_ood, state, H1_MSG_RQBEFORE_CR);\n\t\t/* stop here */\n\n\tcase H1_MSG_RQBEFORE_CR:\n\thttp_msg_rqbefore_cr:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RQBEFORE_CR);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore, http_msg_ood, state, H1_MSG_RQBEFORE);\n\t\t/* stop here */\n\n\tcase H1_MSG_RQMETH:\n\thttp_msg_rqmeth:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth, http_msg_ood, state, H1_MSG_RQMETH);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.rq.m.len = ptr - sl.rq.m.ptr;\n\t\t\tsl.rq.meth = find_http_meth(start, sl.rq.m.len);\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth_sp, http_msg_ood, state, H1_MSG_RQMETH_SP);\n\t\t}\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\t/* HTTP 0.9 request */\n\t\t\tsl.rq.m.len = ptr - sl.rq.m.ptr;\n\t\t\tsl.rq.meth = find_http_meth(sl.rq.m.ptr, sl.rq.m.len);\n\t\thttp_msg_req09_uri:\n\t\t\tsl.rq.u.ptr = ptr;\n\t\thttp_msg_req09_uri_e:\n\t\t\tsl.rq.u.len = ptr - sl.rq.u.ptr;\n\t\thttp_msg_req09_ver:\n\t\t\tsl.rq.v.ptr = ptr;\n\t\t\tsl.rq.v.len = 0;\n\t\t\tgoto http_msg_rqline_eol;\n\t\t}\n\t\tstate = H1_MSG_RQMETH;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQMETH_SP:\n\thttp_msg_rqmeth_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.rq.u.ptr = ptr;\n\t\t\tgoto http_msg_rquri;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth_sp, http_msg_ood, state, H1_MSG_RQMETH_SP);\n\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\tgoto http_msg_req09_uri;\n\n\tcase H1_MSG_RQURI:\n\thttp_msg_rquri:\n#ifdef HA_UNALIGNED_LE\n\t\t/* speedup: skip bytes not between 0x21 and 0x7e inclusive */\n\t\twhile (ptr <= end - sizeof(int)) {\n\t\t\tint x = *(int *)ptr - 0x21212121;\n\t\t\tif (x & 0x80808080)\n\t\t\t\tbreak;\n\n\t\t\tx -= 0x5e5e5e5e;\n\t\t\tif (!(x & 0x80808080))\n\t\t\t\tbreak;\n\n\t\t\tptr += sizeof(int);\n\t\t}\n#endif\n\t\tif (ptr >= end) {\n\t\t\tstate = H1_MSG_RQURI;\n\t\t\tgoto http_msg_ood;\n\t\t}\n\thttp_msg_rquri2:\n\t\tif (likely((unsigned char)(*ptr - 33) <= 93)) /* 33 to 126 included */\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri2, http_msg_ood, state, H1_MSG_RQURI);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.rq.u.len = ptr - sl.rq.u.ptr;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri_sp, http_msg_ood, state, H1_MSG_RQURI_SP);\n\t\t}\n\t\tif (likely((unsigned char)*ptr >= 128)) {\n\t\t\t/* non-ASCII chars are forbidden unless option\n\t\t\t * accept-invalid-http-request is enabled in the frontend.\n\t\t\t * In any case, we capture the faulty char.\n\t\t\t */\n\t\t\tif (h1m->err_pos < -1)\n\t\t\t\tgoto invalid_char;\n\t\t\tif (h1m->err_pos == -1)\n\t\t\t\th1m->err_pos = ptr - start + skip;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri, http_msg_ood, state, H1_MSG_RQURI);\n\t\t}\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\t\tgoto http_msg_req09_uri_e;\n\t\t}\n\n\t\t/* OK forbidden chars, 0..31 or 127 */\n\tinvalid_char:\n\t\tstate = H1_MSG_RQURI;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQURI_SP:\n\thttp_msg_rquri_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.rq.v.ptr = ptr;\n\t\t\tgoto http_msg_rqver;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri_sp, http_msg_ood, state, H1_MSG_RQURI_SP);\n\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\tgoto http_msg_req09_ver;\n\n\n\tcase H1_MSG_RQVER:\n\thttp_msg_rqver:\n\t\tif (likely(HTTP_IS_VER_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqver, http_msg_ood, state, H1_MSG_RQVER);\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\tsl.rq.v.len = ptr - sl.rq.v.ptr;\n\t\thttp_msg_rqline_eol:\n\t\t\t/* We have seen the end of line. Note that we do not\n\t\t\t * necessarily have the \\n yet, but at least we know that we\n\t\t\t * have EITHER \\r OR \\n, otherwise the request would not be\n\t\t\t * complete. We can then record the request length and return\n\t\t\t * to the caller which will be able to register it.\n\t\t\t */\n\n\t\t\tif (likely(!skip_update)) {\n\t\t\t\tif ((sl.rq.v.len == 8) &&\n\t\t\t\t    (*(sl.rq.v.ptr + 5) > '1' ||\n\t\t\t\t     (*(sl.rq.v.ptr + 5) == '1' && *(sl.rq.v.ptr + 7) >= '1')))\n\t\t\t\t\th1m->flags |= H1_MF_VER_11;\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_RQVER;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\t\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\"":method\""), sl.rq.m);\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_RQVER;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\t\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\"":path\""), sl.rq.u);\n\t\t\t}\n\n\t\t\tsol = ptr - start;\n\t\t\tif (likely(*ptr == '\\r'))\n\t\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqline_end, http_msg_ood, state, H1_MSG_RQLINE_END);\n\t\t\tgoto http_msg_rqline_end;\n\t\t}\n\n\t\t/* neither an HTTP_VER token nor a CRLF */\n\t\tstate = H1_MSG_RQVER;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQLINE_END:\n\thttp_msg_rqline_end:\n\t\t/* check for HTTP/0.9 request : no version information\n\t\t * available. sol must point to the first of CR or LF. However\n\t\t * since we don't save these elements between calls, if we come\n\t\t * here from a restart, we don't necessarily know. Thus in this\n\t\t * case we simply start over.\n\t\t */\n\t\tif (restarting)\n\t\t\tgoto restart;\n\n\t\tif (unlikely(sl.rq.v.len == 0))\n\t\t\tgoto http_msg_last_lf;\n\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RQLINE_END);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_first, http_msg_ood, state, H1_MSG_HDR_FIRST);\n\t\t/* stop here */\n\n\t/*\n\t * Common states below\n\t */\n\tcase H1_MSG_RPBEFORE:\n\thttp_msg_rpbefore:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\t/* we have a start of message, we may have skipped some\n\t\t\t * heading CRLF. Skip them now.\n\t\t\t */\n\t\t\tskip += ptr - start;\n\t\t\tstart = ptr;\n\n\t\t\tsol = 0;\n\t\t\tsl.st.v.ptr = ptr;\n\t\t\thdr_count = 0;\n\t\t\tstate = H1_MSG_RPVER;\n\t\t\tgoto http_msg_rpver;\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tstate = H1_MSG_RPBEFORE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (unlikely(*ptr == '\\n'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore, http_msg_ood, state, H1_MSG_RPBEFORE);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore_cr, http_msg_ood, state, H1_MSG_RPBEFORE_CR);\n\t\t/* stop here */\n\n\tcase H1_MSG_RPBEFORE_CR:\n\thttp_msg_rpbefore_cr:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RPBEFORE_CR);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore, http_msg_ood, state, H1_MSG_RPBEFORE);\n\t\t/* stop here */\n\n\tcase H1_MSG_RPVER:\n\thttp_msg_rpver:\n\t\tif (likely(HTTP_IS_VER_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver, http_msg_ood, state, H1_MSG_RPVER);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.st.v.len = ptr - sl.st.v.ptr;\n\n\t\t\tif ((sl.st.v.len == 8) &&\n\t\t\t    (*(sl.st.v.ptr + 5) > '1' ||\n\t\t\t     (*(sl.st.v.ptr + 5) == '1' && *(sl.st.v.ptr + 7) >= '1')))\n\t\t\t\th1m->flags |= H1_MF_VER_11;\n\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver_sp, http_msg_ood, state, H1_MSG_RPVER_SP);\n\t\t}\n\t\tstate = H1_MSG_RPVER;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RPVER_SP:\n\thttp_msg_rpver_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.st.status = 0;\n\t\t\tsl.st.c.ptr = ptr;\n\t\t\tgoto http_msg_rpcode;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver_sp, http_msg_ood, state, H1_MSG_RPVER_SP);\n\t\t/* so it's a CR/LF, this is invalid */\n\t\tstate = H1_MSG_RPVER_SP;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RPCODE:\n\thttp_msg_rpcode:\n\t\tif (likely(HTTP_IS_DIGIT(*ptr))) {\n\t\t\tsl.st.status = sl.st.status * 10 + *ptr - '0';\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode, http_msg_ood, state, H1_MSG_RPCODE);\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tstate = H1_MSG_RPCODE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.st.c.len = ptr - sl.st.c.ptr;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode_sp, http_msg_ood, state, H1_MSG_RPCODE_SP);\n\t\t}\n\n\t\t/* so it's a CR/LF, so there is no reason phrase */\n\t\tsl.st.c.len = ptr - sl.st.c.ptr;\n\n\thttp_msg_rsp_reason:\n\t\tsl.st.r.ptr = ptr;\n\t\tsl.st.r.len = 0;\n\t\tgoto http_msg_rpline_eol;\n\n\tcase H1_MSG_RPCODE_SP:\n\thttp_msg_rpcode_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.st.r.ptr = ptr;\n\t\t\tgoto http_msg_rpreason;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode_sp, http_msg_ood, state, H1_MSG_RPCODE_SP);\n\t\t/* so it's a CR/LF, so there is no reason phrase */\n\t\tgoto http_msg_rsp_reason;\n\n\tcase H1_MSG_RPREASON:\n\thttp_msg_rpreason:\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpreason, http_msg_ood, state, H1_MSG_RPREASON);\n\t\tsl.st.r.len = ptr - sl.st.r.ptr;\n\thttp_msg_rpline_eol:\n\t\t/* We have seen the end of line. Note that we do not\n\t\t * necessarily have the \\n yet, but at least we know that we\n\t\t * have EITHER \\r OR \\n, otherwise the response would not be\n\t\t * complete. We can then record the response length and return\n\t\t * to the caller which will be able to register it.\n\t\t */\n\n\t\tif (likely(!skip_update)) {\n\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\tstate = H1_MSG_RPREASON;\n\t\t\t\tgoto http_output_full;\n\t\t\t}\n\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\"":status\""), sl.st.c);\n\t\t}\n\n\t\tsol = ptr - start;\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpline_end, http_msg_ood, state, H1_MSG_RPLINE_END);\n\t\tgoto http_msg_rpline_end;\n\n\tcase H1_MSG_RPLINE_END:\n\thttp_msg_rpline_end:\n\t\t/* sol must point to the first of CR or LF. */\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RPLINE_END);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_first, http_msg_ood, state, H1_MSG_HDR_FIRST);\n\t\t/* stop here */\n\n\tcase H1_MSG_HDR_FIRST:\n\thttp_msg_hdr_first:\n\t\tsol = ptr - start;\n\t\tif (likely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tgoto http_msg_hdr_name;\n\t\t}\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_last_lf, http_msg_ood, state, H1_MSG_LAST_LF);\n\t\tgoto http_msg_last_lf;\n\n\tcase H1_MSG_HDR_NAME:\n\thttp_msg_hdr_name:\n\t\t/* assumes sol points to the first char */\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* turn it to lower case if needed */\n\t\t\t\tif (isupper((unsigned char)*ptr) && h1m->flags & H1_MF_TOLOWER)\n\t\t\t\t\t*ptr = tolower((unsigned char)*ptr);\n\t\t\t}\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_name, http_msg_ood, state, H1_MSG_HDR_NAME);\n\t\t}\n\n\t\tif (likely(*ptr == ':')) {\n\t\t\tcol = ptr - start;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_sp, http_msg_ood, state, H1_MSG_HDR_L1_SP);\n\t\t}\n\n\t\tif (likely(h1m->err_pos < -1) || *ptr == '\\n') {\n\t\t\tstate = H1_MSG_HDR_NAME;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\th1m->err_pos = ptr - start + skip; /* >= 0 now */\n\n\t\t/* and we still accept this non-token character */\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_name, http_msg_ood, state, H1_MSG_HDR_NAME);\n\n\tcase H1_MSG_HDR_L1_SP:\n\thttp_msg_hdr_l1_sp:\n\t\t/* assumes sol points to the first char */\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_sp, http_msg_ood, state, H1_MSG_HDR_L1_SP);\n\n\t\t/* header value can be basically anything except CR/LF */\n\t\tsov = ptr - start;\n\n\t\tif (likely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tgoto http_msg_hdr_val;\n\t\t}\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_lf, http_msg_ood, state, H1_MSG_HDR_L1_LF);\n\t\tgoto http_msg_hdr_l1_lf;\n\n\tcase H1_MSG_HDR_L1_LF:\n\thttp_msg_hdr_l1_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_HDR_L1_LF);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_lws, http_msg_ood, state, H1_MSG_HDR_L1_LWS);\n\n\tcase H1_MSG_HDR_L1_LWS:\n\thttp_msg_hdr_l1_lws:\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* replace HT,CR,LF with spaces */\n\t\t\t\tfor (; start + sov < ptr; sov++)\n\t\t\t\t\tstart[sov] = ' ';\n\t\t\t}\n\t\t\tgoto http_msg_hdr_l1_sp;\n\t\t}\n\t\t/* we had a header consisting only in spaces ! */\n\t\teol = sov;\n\t\tgoto http_msg_complete_header;\n\n\tcase H1_MSG_HDR_VAL:\n\thttp_msg_hdr_val:\n\t\t/* assumes sol points to the first char, and sov\n\t\t * points to the first character of the value.\n\t\t */\n\n\t\t/* speedup: we'll skip packs of 4 or 8 bytes not containing bytes 0x0D\n\t\t * and lower. In fact since most of the time is spent in the loop, we\n\t\t * also remove the sign bit test so that bytes 0x8e..0x0d break the\n\t\t * loop, but we don't care since they're very rare in header values.\n\t\t */\n#ifdef HA_UNALIGNED_LE64\n\t\twhile (ptr <= end - sizeof(long)) {\n\t\t\tif ((*(long *)ptr - 0x0e0e0e0e0e0e0e0eULL) & 0x8080808080808080ULL)\n\t\t\t\tgoto http_msg_hdr_val2;\n\t\t\tptr += sizeof(long);\n\t\t}\n#endif\n#ifdef HA_UNALIGNED_LE\n\t\twhile (ptr <= end - sizeof(int)) {\n\t\t\tif ((*(int*)ptr - 0x0e0e0e0e) & 0x80808080)\n\t\t\t\tgoto http_msg_hdr_val2;\n\t\t\tptr += sizeof(int);\n\t\t}\n#endif\n\t\tif (ptr >= end) {\n\t\t\tstate = H1_MSG_HDR_VAL;\n\t\t\tgoto http_msg_ood;\n\t\t}\n\thttp_msg_hdr_val2:\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_val2, http_msg_ood, state, H1_MSG_HDR_VAL);\n\n\t\teol = ptr - start;\n\t\t/* Note: we could also copy eol into ->eoh so that we have the\n\t\t * real header end in case it ends with lots of LWS, but is this\n\t\t * really needed ?\n\t\t */\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l2_lf, http_msg_ood, state, H1_MSG_HDR_L2_LF);\n\t\tgoto http_msg_hdr_l2_lf;\n\n\tcase H1_MSG_HDR_L2_LF:\n\thttp_msg_hdr_l2_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_HDR_L2_LF);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l2_lws, http_msg_ood, state, H1_MSG_HDR_L2_LWS);\n\n\tcase H1_MSG_HDR_L2_LWS:\n\thttp_msg_hdr_l2_lws:\n\t\tif (unlikely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* LWS: replace HT,CR,LF with spaces */\n\t\t\t\tfor (; start + eol < ptr; eol++)\n\t\t\t\t\tstart[eol] = ' ';\n\t\t\t}\n\t\t\tgoto http_msg_hdr_val;\n\t\t}\n\thttp_msg_complete_header:\n\t\t/*\n\t\t * It was a new header, so the last one is finished. Assumes\n\t\t * <sol> points to the first char of the name, <col> to the\n\t\t * colon, <sov> points to the first character of the value and\n\t\t * <eol> to the first CR or LF so we know how the line ends. We\n\t\t * will trim spaces around the value. It's possible to do it by\n\t\t * adjusting <eol> and <sov> which are no more used after this.\n\t\t * We can add the header field to the list.\n\t\t */\n\t\tif (likely(!skip_update)) {\n\t\t\twhile (sov < eol && HTTP_IS_LWS(start[sov]))\n\t\t\t\tsov++;\n\n\t\t\twhile (eol - 1 > sov && HTTP_IS_LWS(start[eol - 1]))\n\t\t\t\teol--;\n\n\n\t\t\tn = ist2(start + sol, col - sol);\n\t\t\tv = ist2(start + sov, eol - sov);\n\n\t\t\tdo {\n\t\t\t\tint ret;\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\n\t\t\t\tif (isteqi(n, ist(\""transfer-encoding\""))) {\n\t\t\t\t\th1_parse_xfer_enc_header(h1m, v);\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\""content-length\""))) {\n\t\t\t\t\tret = h1_parse_cont_len_header(h1m, &v);\n\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ret == 0) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\""connection\""))) {\n\t\t\t\t\th1_parse_connection_header(h1m, &v);\n\t\t\t\t\tif (!v.len) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\""upgrade\""))) {\n\t\t\t\t\th1_parse_upgrade_header(h1m, v);\n\t\t\t\t}\n\t\t\t\telse if (!(h1m->flags & (H1_MF_HDRS_ONLY|H1_MF_RESP)) && isteqi(n, ist(\""host\""))) {\n\t\t\t\t\tif (host_idx == -1) {\n\t\t\t\t\t\tstruct ist authority;\n\t\t\t\t\t\tstruct http_uri_parser parser = http_uri_parser_init(sl.rq.u);\n\n\t\t\t\t\t\tauthority = http_parse_authority(&parser, 1);\n\t\t\t\t\t\tif (authority.len && !isteqi(v, authority)) {\n\t\t\t\t\t\t\tif (h1m->err_pos < -1) {\n\t\t\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\t\t\t\t\t\th1m->err_pos = v.ptr - start + skip; /* >= 0 now */\n\t\t\t\t\t\t}\n\t\t\t\t\t\thost_idx = hdr_count;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!isteqi(v, hdr[host_idx].v)) {\n\t\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* if the same host, skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thttp_set_hdr(&hdr[hdr_count++], n, v);\n\t\t\t} while (0);\n\t\t}\n\n\t\tsol = ptr - start;\n\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tgoto http_msg_hdr_name;\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_last_lf, http_msg_ood, state, H1_MSG_LAST_LF);\n\t\tgoto http_msg_last_lf;\n\n\tcase H1_MSG_LAST_LF:\n\thttp_msg_last_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_LAST_LF);\n\t\tptr++;\n\t\t/* <ptr> now points to the first byte of payload. If needed sol\n\t\t * still points to the first of either CR or LF of the empty\n\t\t * line ending the headers block.\n\t\t */\n\t\tif (likely(!skip_update)) {\n\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\tstate = H1_MSG_LAST_LF;\n\t\t\t\tgoto http_output_full;\n\t\t\t}\n\t\t\thttp_set_hdr(&hdr[hdr_count++], ist2(start+sol, 0), ist(\""\""));\n\t\t}\n\n\t\t/* reaching here we've parsed the whole message. We may detect\n\t\t * that we were already continuing an interrupted parsing pass\n\t\t * so we were silently looking for the end of message not\n\t\t * updating anything before deciding to parse it fully at once.\n\t\t * It's guaranteed that we won't match this test twice in a row\n\t\t * since restarting will turn zero.\n\t\t */\n\t\tif (restarting)\n\t\t\tgoto restart;\n\n\t\tstate = H1_MSG_DATA;\n\t\tif (h1m->flags & H1_MF_XFER_ENC) {\n\t\t\tif (h1m->flags & H1_MF_CLEN) {\n\t\t\t\th1m->flags &= ~H1_MF_CLEN;\n\t\t\t\thdr_count = http_del_hdr(hdr, ist(\""content-length\""));\n\t\t\t}\n\n\t\t\tif (h1m->flags & H1_MF_CHNK)\n\t\t\t\tstate = H1_MSG_CHUNK_SIZE;\n\t\t\telse if (!(h1m->flags & H1_MF_RESP)) {\n\t\t\t\t/* cf RFC7230#3.3.3 : transfer-encoding in\n\t\t\t\t * request without chunked encoding is invalid.\n\t\t\t\t */\n\t\t\t\tgoto http_msg_invalid;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\t/* impossible states */\n\t\tgoto http_msg_invalid;\n\t}\n\n\t/* Now we've left the headers state and are either in H1_MSG_DATA or\n\t * H1_MSG_CHUNK_SIZE.\n\t */\n\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->state = state;\n\th1m->next  = ptr - start + skip;\n\treturn h1m->next;\n\n http_msg_ood:\n\t/* out of data at <ptr> during state <state> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->state = state;\n\th1m->next  = ptr - start + skip;\n\treturn 0;\n\n http_msg_invalid:\n\t/* invalid message, error at <ptr> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->err_state = h1m->state = state;\n\th1m->err_pos   = h1m->next  = ptr - start + skip;\n\treturn -1;\n\n http_output_full:\n\t/* no more room to store the current header, error at <ptr> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->err_state = h1m->state = state;\n\th1m->err_pos   = h1m->next  = ptr - start + skip;\n\treturn -2;\n\n restart:\n\th1m->flags &= ~(H1_MF_VER_11|H1_MF_CLEN|H1_MF_XFER_ENC|H1_MF_CHNK|H1_MF_CONN_KAL|H1_MF_CONN_CLO|H1_MF_CONN_UPG);\n\th1m->curr_len = h1m->body_len = h1m->next  = 0;\n\tif (h1m->flags & H1_MF_RESP)\n\t\th1m->state = H1_MSG_RPBEFORE;\n\telse\n\t\th1m->state = H1_MSG_RQBEFORE;\n\tgoto try_again;\n}\n"", ""start_line"": 304, ""end_line"": 1008, ""full_name"": ""h1_headers_to_hdr_list"", ""file_path"": ""src/h1.c""}]}, {""source"": ""func_info(file:h1.c, func:h1_headers_to_hdr_list)"", ""result"": [{""code"": ""int h1_headers_to_hdr_list(char *start, const char *stop,\n                           struct http_hdr *hdr, unsigned int hdr_num,\n                           struct h1m *h1m, union h1_sl *slp)\n{\n\tenum h1m_state state;\n\tregister char *ptr;\n\tregister const char *end;\n\tunsigned int hdr_count;\n\tunsigned int skip; /* number of bytes skipped at the beginning */\n\tunsigned int sol;  /* start of line */\n\tunsigned int col;  /* position of the colon */\n\tunsigned int eol;  /* end of line */\n\tunsigned int sov;  /* start of value */\n\tunion h1_sl sl;\n\tint skip_update;\n\tint restarting;\n\tint host_idx;\n\tstruct ist n, v;       /* header name and value during parsing */\n\n\tskip = 0; // do it only once to keep track of the leading CRLF.\n\n try_again:\n\thdr_count = sol = col = eol = sov = 0;\n\tsl.st.status = 0;\n\tskip_update = restarting = 0;\n\thost_idx = -1;\n\n\tif (h1m->flags & H1_MF_HDRS_ONLY) {\n\t\tstate = H1_MSG_HDR_FIRST;\n\t\th1m->next = 0;\n\t}\n\telse {\n\t\tstate = h1m->state;\n\t\tif (h1m->state != H1_MSG_RQBEFORE && h1m->state != H1_MSG_RPBEFORE)\n\t\t\trestarting = 1;\n\t}\n\n\tptr   = start + h1m->next;\n\tend   = stop;\n\n\tif (unlikely(ptr >= end))\n\t\tgoto http_msg_ood;\n\n\t/* don't update output if hdr is NULL or if we're restarting */\n\tif (!hdr || restarting)\n\t\tskip_update = 1;\n\n\tswitch (state)\t{\n\tcase H1_MSG_RQBEFORE:\n\thttp_msg_rqbefore:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\t/* we have a start of message, we may have skipped some\n\t\t\t * heading CRLF. Skip them now.\n\t\t\t */\n\t\t\tskip += ptr - start;\n\t\t\tstart = ptr;\n\n\t\t\tsol = 0;\n\t\t\tsl.rq.m.ptr = ptr;\n\t\t\thdr_count = 0;\n\t\t\tstate = H1_MSG_RQMETH;\n\t\t\tgoto http_msg_rqmeth;\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tstate = H1_MSG_RQBEFORE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (unlikely(*ptr == '\\n'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore, http_msg_ood, state, H1_MSG_RQBEFORE);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore_cr, http_msg_ood, state, H1_MSG_RQBEFORE_CR);\n\t\t/* stop here */\n\n\tcase H1_MSG_RQBEFORE_CR:\n\thttp_msg_rqbefore_cr:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RQBEFORE_CR);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore, http_msg_ood, state, H1_MSG_RQBEFORE);\n\t\t/* stop here */\n\n\tcase H1_MSG_RQMETH:\n\thttp_msg_rqmeth:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth, http_msg_ood, state, H1_MSG_RQMETH);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.rq.m.len = ptr - sl.rq.m.ptr;\n\t\t\tsl.rq.meth = find_http_meth(start, sl.rq.m.len);\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth_sp, http_msg_ood, state, H1_MSG_RQMETH_SP);\n\t\t}\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\t/* HTTP 0.9 request */\n\t\t\tsl.rq.m.len = ptr - sl.rq.m.ptr;\n\t\t\tsl.rq.meth = find_http_meth(sl.rq.m.ptr, sl.rq.m.len);\n\t\thttp_msg_req09_uri:\n\t\t\tsl.rq.u.ptr = ptr;\n\t\thttp_msg_req09_uri_e:\n\t\t\tsl.rq.u.len = ptr - sl.rq.u.ptr;\n\t\thttp_msg_req09_ver:\n\t\t\tsl.rq.v.ptr = ptr;\n\t\t\tsl.rq.v.len = 0;\n\t\t\tgoto http_msg_rqline_eol;\n\t\t}\n\t\tstate = H1_MSG_RQMETH;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQMETH_SP:\n\thttp_msg_rqmeth_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.rq.u.ptr = ptr;\n\t\t\tgoto http_msg_rquri;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth_sp, http_msg_ood, state, H1_MSG_RQMETH_SP);\n\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\tgoto http_msg_req09_uri;\n\n\tcase H1_MSG_RQURI:\n\thttp_msg_rquri:\n#ifdef HA_UNALIGNED_LE\n\t\t/* speedup: skip bytes not between 0x21 and 0x7e inclusive */\n\t\twhile (ptr <= end - sizeof(int)) {\n\t\t\tint x = *(int *)ptr - 0x21212121;\n\t\t\tif (x & 0x80808080)\n\t\t\t\tbreak;\n\n\t\t\tx -= 0x5e5e5e5e;\n\t\t\tif (!(x & 0x80808080))\n\t\t\t\tbreak;\n\n\t\t\tptr += sizeof(int);\n\t\t}\n#endif\n\t\tif (ptr >= end) {\n\t\t\tstate = H1_MSG_RQURI;\n\t\t\tgoto http_msg_ood;\n\t\t}\n\thttp_msg_rquri2:\n\t\tif (likely((unsigned char)(*ptr - 33) <= 93)) /* 33 to 126 included */\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri2, http_msg_ood, state, H1_MSG_RQURI);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.rq.u.len = ptr - sl.rq.u.ptr;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri_sp, http_msg_ood, state, H1_MSG_RQURI_SP);\n\t\t}\n\t\tif (likely((unsigned char)*ptr >= 128)) {\n\t\t\t/* non-ASCII chars are forbidden unless option\n\t\t\t * accept-invalid-http-request is enabled in the frontend.\n\t\t\t * In any case, we capture the faulty char.\n\t\t\t */\n\t\t\tif (h1m->err_pos < -1)\n\t\t\t\tgoto invalid_char;\n\t\t\tif (h1m->err_pos == -1)\n\t\t\t\th1m->err_pos = ptr - start + skip;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri, http_msg_ood, state, H1_MSG_RQURI);\n\t\t}\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\t\tgoto http_msg_req09_uri_e;\n\t\t}\n\n\t\t/* OK forbidden chars, 0..31 or 127 */\n\tinvalid_char:\n\t\tstate = H1_MSG_RQURI;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQURI_SP:\n\thttp_msg_rquri_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.rq.v.ptr = ptr;\n\t\t\tgoto http_msg_rqver;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri_sp, http_msg_ood, state, H1_MSG_RQURI_SP);\n\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\tgoto http_msg_req09_ver;\n\n\n\tcase H1_MSG_RQVER:\n\thttp_msg_rqver:\n\t\tif (likely(HTTP_IS_VER_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqver, http_msg_ood, state, H1_MSG_RQVER);\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\tsl.rq.v.len = ptr - sl.rq.v.ptr;\n\t\thttp_msg_rqline_eol:\n\t\t\t/* We have seen the end of line. Note that we do not\n\t\t\t * necessarily have the \\n yet, but at least we know that we\n\t\t\t * have EITHER \\r OR \\n, otherwise the request would not be\n\t\t\t * complete. We can then record the request length and return\n\t\t\t * to the caller which will be able to register it.\n\t\t\t */\n\n\t\t\tif (likely(!skip_update)) {\n\t\t\t\tif ((sl.rq.v.len == 8) &&\n\t\t\t\t    (*(sl.rq.v.ptr + 5) > '1' ||\n\t\t\t\t     (*(sl.rq.v.ptr + 5) == '1' && *(sl.rq.v.ptr + 7) >= '1')))\n\t\t\t\t\th1m->flags |= H1_MF_VER_11;\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_RQVER;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\t\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\"":method\""), sl.rq.m);\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_RQVER;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\t\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\"":path\""), sl.rq.u);\n\t\t\t}\n\n\t\t\tsol = ptr - start;\n\t\t\tif (likely(*ptr == '\\r'))\n\t\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqline_end, http_msg_ood, state, H1_MSG_RQLINE_END);\n\t\t\tgoto http_msg_rqline_end;\n\t\t}\n\n\t\t/* neither an HTTP_VER token nor a CRLF */\n\t\tstate = H1_MSG_RQVER;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQLINE_END:\n\thttp_msg_rqline_end:\n\t\t/* check for HTTP/0.9 request : no version information\n\t\t * available. sol must point to the first of CR or LF. However\n\t\t * since we don't save these elements between calls, if we come\n\t\t * here from a restart, we don't necessarily know. Thus in this\n\t\t * case we simply start over.\n\t\t */\n\t\tif (restarting)\n\t\t\tgoto restart;\n\n\t\tif (unlikely(sl.rq.v.len == 0))\n\t\t\tgoto http_msg_last_lf;\n\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RQLINE_END);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_first, http_msg_ood, state, H1_MSG_HDR_FIRST);\n\t\t/* stop here */\n\n\t/*\n\t * Common states below\n\t */\n\tcase H1_MSG_RPBEFORE:\n\thttp_msg_rpbefore:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\t/* we have a start of message, we may have skipped some\n\t\t\t * heading CRLF. Skip them now.\n\t\t\t */\n\t\t\tskip += ptr - start;\n\t\t\tstart = ptr;\n\n\t\t\tsol = 0;\n\t\t\tsl.st.v.ptr = ptr;\n\t\t\thdr_count = 0;\n\t\t\tstate = H1_MSG_RPVER;\n\t\t\tgoto http_msg_rpver;\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tstate = H1_MSG_RPBEFORE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (unlikely(*ptr == '\\n'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore, http_msg_ood, state, H1_MSG_RPBEFORE);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore_cr, http_msg_ood, state, H1_MSG_RPBEFORE_CR);\n\t\t/* stop here */\n\n\tcase H1_MSG_RPBEFORE_CR:\n\thttp_msg_rpbefore_cr:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RPBEFORE_CR);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore, http_msg_ood, state, H1_MSG_RPBEFORE);\n\t\t/* stop here */\n\n\tcase H1_MSG_RPVER:\n\thttp_msg_rpver:\n\t\tif (likely(HTTP_IS_VER_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver, http_msg_ood, state, H1_MSG_RPVER);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.st.v.len = ptr - sl.st.v.ptr;\n\n\t\t\tif ((sl.st.v.len == 8) &&\n\t\t\t    (*(sl.st.v.ptr + 5) > '1' ||\n\t\t\t     (*(sl.st.v.ptr + 5) == '1' && *(sl.st.v.ptr + 7) >= '1')))\n\t\t\t\th1m->flags |= H1_MF_VER_11;\n\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver_sp, http_msg_ood, state, H1_MSG_RPVER_SP);\n\t\t}\n\t\tstate = H1_MSG_RPVER;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RPVER_SP:\n\thttp_msg_rpver_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.st.status = 0;\n\t\t\tsl.st.c.ptr = ptr;\n\t\t\tgoto http_msg_rpcode;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver_sp, http_msg_ood, state, H1_MSG_RPVER_SP);\n\t\t/* so it's a CR/LF, this is invalid */\n\t\tstate = H1_MSG_RPVER_SP;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RPCODE:\n\thttp_msg_rpcode:\n\t\tif (likely(HTTP_IS_DIGIT(*ptr))) {\n\t\t\tsl.st.status = sl.st.status * 10 + *ptr - '0';\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode, http_msg_ood, state, H1_MSG_RPCODE);\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tstate = H1_MSG_RPCODE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.st.c.len = ptr - sl.st.c.ptr;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode_sp, http_msg_ood, state, H1_MSG_RPCODE_SP);\n\t\t}\n\n\t\t/* so it's a CR/LF, so there is no reason phrase */\n\t\tsl.st.c.len = ptr - sl.st.c.ptr;\n\n\thttp_msg_rsp_reason:\n\t\tsl.st.r.ptr = ptr;\n\t\tsl.st.r.len = 0;\n\t\tgoto http_msg_rpline_eol;\n\n\tcase H1_MSG_RPCODE_SP:\n\thttp_msg_rpcode_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.st.r.ptr = ptr;\n\t\t\tgoto http_msg_rpreason;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode_sp, http_msg_ood, state, H1_MSG_RPCODE_SP);\n\t\t/* so it's a CR/LF, so there is no reason phrase */\n\t\tgoto http_msg_rsp_reason;\n\n\tcase H1_MSG_RPREASON:\n\thttp_msg_rpreason:\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpreason, http_msg_ood, state, H1_MSG_RPREASON);\n\t\tsl.st.r.len = ptr - sl.st.r.ptr;\n\thttp_msg_rpline_eol:\n\t\t/* We have seen the end of line. Note that we do not\n\t\t * necessarily have the \\n yet, but at least we know that we\n\t\t * have EITHER \\r OR \\n, otherwise the response would not be\n\t\t * complete. We can then record the response length and return\n\t\t * to the caller which will be able to register it.\n\t\t */\n\n\t\tif (likely(!skip_update)) {\n\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\tstate = H1_MSG_RPREASON;\n\t\t\t\tgoto http_output_full;\n\t\t\t}\n\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\"":status\""), sl.st.c);\n\t\t}\n\n\t\tsol = ptr - start;\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpline_end, http_msg_ood, state, H1_MSG_RPLINE_END);\n\t\tgoto http_msg_rpline_end;\n\n\tcase H1_MSG_RPLINE_END:\n\thttp_msg_rpline_end:\n\t\t/* sol must point to the first of CR or LF. */\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RPLINE_END);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_first, http_msg_ood, state, H1_MSG_HDR_FIRST);\n\t\t/* stop here */\n\n\tcase H1_MSG_HDR_FIRST:\n\thttp_msg_hdr_first:\n\t\tsol = ptr - start;\n\t\tif (likely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tgoto http_msg_hdr_name;\n\t\t}\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_last_lf, http_msg_ood, state, H1_MSG_LAST_LF);\n\t\tgoto http_msg_last_lf;\n\n\tcase H1_MSG_HDR_NAME:\n\thttp_msg_hdr_name:\n\t\t/* assumes sol points to the first char */\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* turn it to lower case if needed */\n\t\t\t\tif (isupper((unsigned char)*ptr) && h1m->flags & H1_MF_TOLOWER)\n\t\t\t\t\t*ptr = tolower((unsigned char)*ptr);\n\t\t\t}\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_name, http_msg_ood, state, H1_MSG_HDR_NAME);\n\t\t}\n\n\t\tif (likely(*ptr == ':')) {\n\t\t\tcol = ptr - start;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_sp, http_msg_ood, state, H1_MSG_HDR_L1_SP);\n\t\t}\n\n\t\tif (likely(h1m->err_pos < -1) || *ptr == '\\n') {\n\t\t\tstate = H1_MSG_HDR_NAME;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\th1m->err_pos = ptr - start + skip; /* >= 0 now */\n\n\t\t/* and we still accept this non-token character */\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_name, http_msg_ood, state, H1_MSG_HDR_NAME);\n\n\tcase H1_MSG_HDR_L1_SP:\n\thttp_msg_hdr_l1_sp:\n\t\t/* assumes sol points to the first char */\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_sp, http_msg_ood, state, H1_MSG_HDR_L1_SP);\n\n\t\t/* header value can be basically anything except CR/LF */\n\t\tsov = ptr - start;\n\n\t\tif (likely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tgoto http_msg_hdr_val;\n\t\t}\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_lf, http_msg_ood, state, H1_MSG_HDR_L1_LF);\n\t\tgoto http_msg_hdr_l1_lf;\n\n\tcase H1_MSG_HDR_L1_LF:\n\thttp_msg_hdr_l1_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_HDR_L1_LF);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_lws, http_msg_ood, state, H1_MSG_HDR_L1_LWS);\n\n\tcase H1_MSG_HDR_L1_LWS:\n\thttp_msg_hdr_l1_lws:\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* replace HT,CR,LF with spaces */\n\t\t\t\tfor (; start + sov < ptr; sov++)\n\t\t\t\t\tstart[sov] = ' ';\n\t\t\t}\n\t\t\tgoto http_msg_hdr_l1_sp;\n\t\t}\n\t\t/* we had a header consisting only in spaces ! */\n\t\teol = sov;\n\t\tgoto http_msg_complete_header;\n\n\tcase H1_MSG_HDR_VAL:\n\thttp_msg_hdr_val:\n\t\t/* assumes sol points to the first char, and sov\n\t\t * points to the first character of the value.\n\t\t */\n\n\t\t/* speedup: we'll skip packs of 4 or 8 bytes not containing bytes 0x0D\n\t\t * and lower. In fact since most of the time is spent in the loop, we\n\t\t * also remove the sign bit test so that bytes 0x8e..0x0d break the\n\t\t * loop, but we don't care since they're very rare in header values.\n\t\t */\n#ifdef HA_UNALIGNED_LE64\n\t\twhile (ptr <= end - sizeof(long)) {\n\t\t\tif ((*(long *)ptr - 0x0e0e0e0e0e0e0e0eULL) & 0x8080808080808080ULL)\n\t\t\t\tgoto http_msg_hdr_val2;\n\t\t\tptr += sizeof(long);\n\t\t}\n#endif\n#ifdef HA_UNALIGNED_LE\n\t\twhile (ptr <= end - sizeof(int)) {\n\t\t\tif ((*(int*)ptr - 0x0e0e0e0e) & 0x80808080)\n\t\t\t\tgoto http_msg_hdr_val2;\n\t\t\tptr += sizeof(int);\n\t\t}\n#endif\n\t\tif (ptr >= end) {\n\t\t\tstate = H1_MSG_HDR_VAL;\n\t\t\tgoto http_msg_ood;\n\t\t}\n\thttp_msg_hdr_val2:\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_val2, http_msg_ood, state, H1_MSG_HDR_VAL);\n\n\t\teol = ptr - start;\n\t\t/* Note: we could also copy eol into ->eoh so that we have the\n\t\t * real header end in case it ends with lots of LWS, but is this\n\t\t * really needed ?\n\t\t */\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l2_lf, http_msg_ood, state, H1_MSG_HDR_L2_LF);\n\t\tgoto http_msg_hdr_l2_lf;\n\n\tcase H1_MSG_HDR_L2_LF:\n\thttp_msg_hdr_l2_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_HDR_L2_LF);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l2_lws, http_msg_ood, state, H1_MSG_HDR_L2_LWS);\n\n\tcase H1_MSG_HDR_L2_LWS:\n\thttp_msg_hdr_l2_lws:\n\t\tif (unlikely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* LWS: replace HT,CR,LF with spaces */\n\t\t\t\tfor (; start + eol < ptr; eol++)\n\t\t\t\t\tstart[eol] = ' ';\n\t\t\t}\n\t\t\tgoto http_msg_hdr_val;\n\t\t}\n\thttp_msg_complete_header:\n\t\t/*\n\t\t * It was a new header, so the last one is finished. Assumes\n\t\t * <sol> points to the first char of the name, <col> to the\n\t\t * colon, <sov> points to the first character of the value and\n\t\t * <eol> to the first CR or LF so we know how the line ends. We\n\t\t * will trim spaces around the value. It's possible to do it by\n\t\t * adjusting <eol> and <sov> which are no more used after this.\n\t\t * We can add the header field to the list.\n\t\t */\n\t\tif (likely(!skip_update)) {\n\t\t\twhile (sov < eol && HTTP_IS_LWS(start[sov]))\n\t\t\t\tsov++;\n\n\t\t\twhile (eol - 1 > sov && HTTP_IS_LWS(start[eol - 1]))\n\t\t\t\teol--;\n\n\n\t\t\tn = ist2(start + sol, col - sol);\n\t\t\tv = ist2(start + sov, eol - sov);\n\n\t\t\tdo {\n\t\t\t\tint ret;\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\n\t\t\t\tif (isteqi(n, ist(\""transfer-encoding\""))) {\n\t\t\t\t\th1_parse_xfer_enc_header(h1m, v);\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\""content-length\""))) {\n\t\t\t\t\tret = h1_parse_cont_len_header(h1m, &v);\n\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ret == 0) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\""connection\""))) {\n\t\t\t\t\th1_parse_connection_header(h1m, &v);\n\t\t\t\t\tif (!v.len) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\""upgrade\""))) {\n\t\t\t\t\th1_parse_upgrade_header(h1m, v);\n\t\t\t\t}\n\t\t\t\telse if (!(h1m->flags & (H1_MF_HDRS_ONLY|H1_MF_RESP)) && isteqi(n, ist(\""host\""))) {\n\t\t\t\t\tif (host_idx == -1) {\n\t\t\t\t\t\tstruct ist authority;\n\t\t\t\t\t\tstruct http_uri_parser parser = http_uri_parser_init(sl.rq.u);\n\n\t\t\t\t\t\tauthority = http_parse_authority(&parser, 1);\n\t\t\t\t\t\tif (authority.len && !isteqi(v, authority)) {\n\t\t\t\t\t\t\tif (h1m->err_pos < -1) {\n\t\t\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\t\t\t\t\t\th1m->err_pos = v.ptr - start + skip; /* >= 0 now */\n\t\t\t\t\t\t}\n\t\t\t\t\t\thost_idx = hdr_count;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!isteqi(v, hdr[host_idx].v)) {\n\t\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* if the same host, skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thttp_set_hdr(&hdr[hdr_count++], n, v);\n\t\t\t} while (0);\n\t\t}\n\n\t\tsol = ptr - start;\n\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tgoto http_msg_hdr_name;\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_last_lf, http_msg_ood, state, H1_MSG_LAST_LF);\n\t\tgoto http_msg_last_lf;\n\n\tcase H1_MSG_LAST_LF:\n\thttp_msg_last_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_LAST_LF);\n\t\tptr++;\n\t\t/* <ptr> now points to the first byte of payload. If needed sol\n\t\t * still points to the first of either CR or LF of the empty\n\t\t * line ending the headers block.\n\t\t */\n\t\tif (likely(!skip_update)) {\n\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\tstate = H1_MSG_LAST_LF;\n\t\t\t\tgoto http_output_full;\n\t\t\t}\n\t\t\thttp_set_hdr(&hdr[hdr_count++], ist2(start+sol, 0), ist(\""\""));\n\t\t}\n\n\t\t/* reaching here we've parsed the whole message. We may detect\n\t\t * that we were already continuing an interrupted parsing pass\n\t\t * so we were silently looking for the end of message not\n\t\t * updating anything before deciding to parse it fully at once.\n\t\t * It's guaranteed that we won't match this test twice in a row\n\t\t * since restarting will turn zero.\n\t\t */\n\t\tif (restarting)\n\t\t\tgoto restart;\n\n\t\tstate = H1_MSG_DATA;\n\t\tif (h1m->flags & H1_MF_XFER_ENC) {\n\t\t\tif (h1m->flags & H1_MF_CLEN) {\n\t\t\t\th1m->flags &= ~H1_MF_CLEN;\n\t\t\t\thdr_count = http_del_hdr(hdr, ist(\""content-length\""));\n\t\t\t}\n\n\t\t\tif (h1m->flags & H1_MF_CHNK)\n\t\t\t\tstate = H1_MSG_CHUNK_SIZE;\n\t\t\telse if (!(h1m->flags & H1_MF_RESP)) {\n\t\t\t\t/* cf RFC7230#3.3.3 : transfer-encoding in\n\t\t\t\t * request without chunked encoding is invalid.\n\t\t\t\t */\n\t\t\t\tgoto http_msg_invalid;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\t/* impossible states */\n\t\tgoto http_msg_invalid;\n\t}\n\n\t/* Now we've left the headers state and are either in H1_MSG_DATA or\n\t * H1_MSG_CHUNK_SIZE.\n\t */\n\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->state = state;\n\th1m->next  = ptr - start + skip;\n\treturn h1m->next;\n\n http_msg_ood:\n\t/* out of data at <ptr> during state <state> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->state = state;\n\th1m->next  = ptr - start + skip;\n\treturn 0;\n\n http_msg_invalid:\n\t/* invalid message, error at <ptr> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->err_state = h1m->state = state;\n\th1m->err_pos   = h1m->next  = ptr - start + skip;\n\treturn -1;\n\n http_output_full:\n\t/* no more room to store the current header, error at <ptr> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->err_state = h1m->state = state;\n\th1m->err_pos   = h1m->next  = ptr - start + skip;\n\treturn -2;\n\n restart:\n\th1m->flags &= ~(H1_MF_VER_11|H1_MF_CLEN|H1_MF_XFER_ENC|H1_MF_CHNK|H1_MF_CONN_KAL|H1_MF_CONN_CLO|H1_MF_CONN_UPG);\n\th1m->curr_len = h1m->body_len = h1m->next  = 0;\n\tif (h1m->flags & H1_MF_RESP)\n\t\th1m->state = H1_MSG_RPBEFORE;\n\telse\n\t\th1m->state = H1_MSG_RQBEFORE;\n\tgoto try_again;\n}\n"", ""start_line"": 304, ""end_line"": 1008, ""full_name"": ""h1_headers_to_hdr_list"", ""file_path"": ""src/h1.c""}]}, {""source"": ""caller_info(func:h1_headers_to_hdr_list)"", ""result"": [{""call_line"": 333, ""call_code"": ""h1_headers_to_hdr_list(b_peek(srcbuf, ofs), b_tail(srcbuf),\n\t\t\t\t     hdrs, sizeof(hdrs)/sizeof(hdrs[0]), h1m, h1sl)"", ""caller_code"": ""size_t h1_parse_msg_hdrs(struct h1m *h1m, union h1_sl *h1sl, struct htx *dsthtx,\n\t\t\t struct buffer *srcbuf, size_t ofs, size_t max)\n{\n\tstruct http_hdr hdrs[global.tune.max_http_hdr];\n\tint ret = 0;\n\n\tif (!max || !b_data(srcbuf))\n\t\tgoto end;\n\n\t/* Realing input buffer if necessary */\n\tif (b_head(srcbuf) + b_data(srcbuf) > b_wrap(srcbuf))\n\t\tb_slow_realign_ofs(srcbuf, trash.area, 0);\n\n\tif (!h1sl) {\n\t\t/* If there no start-line, be sure to only parse the headers */\n\t\th1m->flags |= H1_MF_HDRS_ONLY;\n\t}\n\tret = h1_headers_to_hdr_list(b_peek(srcbuf, ofs), b_tail(srcbuf),\n\t\t\t\t     hdrs, sizeof(hdrs)/sizeof(hdrs[0]), h1m, h1sl);\n\tif (ret <= 0) {\n\t\t/* Incomplete or invalid message. If the input buffer only\n\t\t * contains headers and is full, which is detected by it being\n\t\t * full and the offset to be zero, it's an error because\n\t\t * headers are too large to be handled by the parser. */\n\t\tif (ret < 0 || (!ret && !ofs && !buf_room_for_htx_data(srcbuf)))\n\t\t\tgoto error;\n\t\tgoto end;\n\t}\n\n\t/* messages headers fully parsed, do some checks to prepare the body\n\t * parsing.\n\t */\n\n\tif (!(h1m->flags & H1_MF_RESP)) {\n\t\tif (!h1_process_req_vsn(h1m, h1sl)) {\n\t\t\th1m->err_pos = h1sl->rq.v.ptr - b_head(srcbuf);\n\t\t\th1m->err_state = h1m->state;\n\t\t\tgoto vsn_error;\n\t\t}\n\t\tif (!h1_postparse_req_hdrs(h1m, h1sl, dsthtx, hdrs, max))\n\t\t\tret = 0;\n\t}\n\telse {\n\t\tif (h1sl && !h1_process_res_vsn(h1m, h1sl)) {\n\t\t\th1m->err_pos = h1sl->st.v.ptr - b_head(srcbuf);\n\t\t\th1m->err_state = h1m->state;\n\t\t\tgoto vsn_error;\n\t\t}\n\t\tif (!h1_postparse_res_hdrs(h1m, h1sl, dsthtx, hdrs, max))\n\t\t\tret = 0;\n\t}\n\n\t/* Switch messages without any payload to DONE state */\n\tif (((h1m->flags & H1_MF_CLEN) && h1m->body_len == 0) ||\n\t    ((h1m->flags & (H1_MF_XFER_LEN|H1_MF_CLEN|H1_MF_CHNK)) == H1_MF_XFER_LEN)) {\n\t\th1m->state = H1_MSG_DONE;\n\t\tdsthtx->flags |= HTX_FL_EOM;\n\t}\n\n  end:\n\treturn ret;\n  error:\n\th1m->err_pos = h1m->next;\n\th1m->err_state = h1m->state;\n  vsn_error:\n\tdsthtx->flags |= HTX_FL_PARSING_ERROR;\n\treturn 0;\n\n}\n"", ""caller_start"": 316, ""file_path"": ""src/h1_htx.c""}, {""call_line"": 868, ""call_code"": ""h1_headers_to_hdr_list(b_peek(srcbuf, ofs), b_tail(srcbuf),\n\t\t\t\t     hdrs, sizeof(hdrs)/sizeof(hdrs[0]), &tlr_h1m, NULL)"", ""caller_code"": ""size_t h1_parse_msg_tlrs(struct h1m *h1m, struct htx *dsthtx,\n\t\t\t struct buffer *srcbuf, size_t ofs, size_t max)\n{\n\tstruct http_hdr hdrs[global.tune.max_http_hdr];\n\tstruct h1m tlr_h1m;\n\tint ret = 0;\n\n\tif (!max || !b_data(srcbuf))\n\t\tgoto end;\n\n\t/* Realing input buffer if necessary */\n\tif (b_peek(srcbuf, ofs) > b_tail(srcbuf))\n\t\tb_slow_realign_ofs(srcbuf, trash.area, 0);\n\n\ttlr_h1m.flags = (H1_MF_NO_PHDR|H1_MF_HDRS_ONLY);\n\tret = h1_headers_to_hdr_list(b_peek(srcbuf, ofs), b_tail(srcbuf),\n\t\t\t\t     hdrs, sizeof(hdrs)/sizeof(hdrs[0]), &tlr_h1m, NULL);\n\tif (ret <= 0) {\n\t\t/* Incomplete or invalid trailers. If the input buffer only\n\t\t * contains trailers and is full, which is detected by it being\n\t\t * full and the offset to be zero, it's an error because\n\t\t * trailers are too large to be handled by the parser. */\n\t\tif (ret < 0 || (!ret && !ofs && !buf_room_for_htx_data(srcbuf)))\n\t\t\tgoto error;\n\t\tgoto end;\n\t}\n\n\t/* messages trailers fully parsed. */\n\tif (h1_eval_htx_hdrs_size(hdrs) > max) {\n\t\tif (htx_is_empty(dsthtx))\n\t\t\tgoto error;\n\t\tret = 0;\n\t\tgoto end;\n\t}\n\n\tif (!htx_add_all_trailers(dsthtx, hdrs))\n\t\tgoto error;\n\n\th1m->state = H1_MSG_DONE;\n\tdsthtx->flags |= HTX_FL_EOM;\n\n  end:\n\treturn ret;\n  error:\n\th1m->err_state = h1m->state;\n\th1m->err_pos = h1m->next;\n\tdsthtx->flags |= HTX_FL_PARSING_ERROR;\n\treturn 0;\n}\n"", ""caller_start"": 853, ""file_path"": ""src/h1_htx.c""}, {""call_line"": 254, ""call_code"": ""h1_headers_to_hdr_list(b_head(buf), b_stop(buf),\n\t\t\t\t\t     hdrs, sizeof(hdrs)/sizeof(hdrs[0]), &h1m, &h1sl)"", ""caller_code"": ""struct htx *smp_prefetch_htx(struct sample *smp, struct channel *chn, struct check *check, int vol)\n{\n\tstruct stream *s = smp->strm;\n\tstruct http_txn *txn = NULL;\n\tstruct htx *htx = NULL;\n\tstruct http_msg *msg;\n\tstruct htx_sl *sl;\n\n\tif (chn &&\n\t    (((smp->opt & SMP_OPT_DIR) == SMP_OPT_DIR_REQ && (chn->flags & CF_ISRESP)) ||\n\t     ((smp->opt & SMP_OPT_DIR) == SMP_OPT_DIR_RES && !(chn->flags & CF_ISRESP))))\n\t\treturn 0;\n\n\t/* Note: it is possible that <s> is NULL when called before stream\n\t * initialization (eg: tcp-request connection), so this function is the\n\t * one responsible for guarding against this case for all HTTP users.\n\t *\n\t * In the health check context, the stream and the channel must be NULL\n\t * and <check> must be set. In this case, only the input buffer,\n\t * corresponding to the response, is considered. It is the caller\n\t * responsibility to provide <check>.\n\t */\n\tBUG_ON(check && (s || chn));\n\tif (!s || !chn) {\n\t\tif (check) {\n\t\t\thtx = htxbuf(&check->bi);\n\n\t\t\t/* Analyse not yet started */\n\t\t\tif (htx_is_empty(htx) || htx->first == -1)\n\t\t\t\treturn NULL;\n\n\t\t\tsl = http_get_stline(htx);\n\t\t\tif (vol && !sl) {\n\t\t\t\t/* The start-line was already forwarded, it is too late to fetch anything */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgoto end;\n\t\t}\n\n\t\treturn NULL;\n\t}\n\n\tif (!s->txn && !http_create_txn(s))\n\t\treturn NULL;\n\ttxn = s->txn;\n\tmsg = (!(chn->flags & CF_ISRESP) ? &txn->req : &txn->rsp);\n\n\tif (IS_HTX_STRM(s)) {\n\t\thtx = htxbuf(&chn->buf);\n\n\t\tif (msg->msg_state == HTTP_MSG_ERROR || (htx->flags & HTX_FL_PARSING_ERROR))\n\t\t\treturn NULL;\n\n\t\tif (msg->msg_state < HTTP_MSG_BODY) {\n\t\t\t/* Analyse not yet started */\n\t\t\tif (htx_is_empty(htx) || htx->first == -1) {\n\t\t\t\t/* Parsing is done by the mux, just wait */\n\t\t\t\tsmp->flags |= SMP_F_MAY_CHANGE;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsl = http_get_stline(htx);\n\t\tif (vol && !sl) {\n\t\t\t/* The start-line was already forwarded, it is too late to fetch anything */\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse { /* RAW mode */\n\t\tstruct buffer *buf;\n\t\tstruct h1m h1m;\n\t\tstruct http_hdr hdrs[global.tune.max_http_hdr];\n\t\tunion h1_sl h1sl;\n\t\tunsigned int flags = HTX_FL_NONE;\n\t\tint ret;\n\n\t\t/* no HTTP fetch on the response in TCP mode */\n\t\tif (chn->flags & CF_ISRESP)\n\t\t\treturn NULL;\n\n\t\t/* Now we are working on the request only */\n\t\tbuf = &chn->buf;\n\t\tif (b_head(buf) + b_data(buf) > b_wrap(buf))\n\t\t\tb_slow_realign(buf, trash.area, 0);\n\n\t\th1m_init_req(&h1m);\n\t\tret = h1_headers_to_hdr_list(b_head(buf), b_stop(buf),\n\t\t\t\t\t     hdrs, sizeof(hdrs)/sizeof(hdrs[0]), &h1m, &h1sl);\n\t\tif (ret <= 0) {\n\t\t\t/* Invalid or too big*/\n\t\t\tif (ret < 0 || channel_full(&s->req, global.tune.maxrewrite))\n\t\t\t\treturn NULL;\n\n\t\t\t/* wait for a full request */\n\t\t\tsmp->flags |= SMP_F_MAY_CHANGE;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* OK we just got a valid HTTP message. We have to convert it\n\t\t * into an HTX message.\n\t\t */\n\t\tif (unlikely(h1sl.rq.v.len == 0)) {\n\t\t\t/* try to convert HTTP/0.9 requests to HTTP/1.0 */\n\t\t\tif (h1sl.rq.meth != HTTP_METH_GET || !h1sl.rq.u.len)\n\t\t\t\treturn NULL;\n\t\t\th1sl.rq.v = ist(\""HTTP/1.0\"");\n\t\t}\n\n\t\t/* Set HTX start-line flags */\n\t\tif (h1m.flags & H1_MF_VER_11)\n\t\t\tflags |= HTX_SL_F_VER_11;\n\t\tif (h1m.flags & H1_MF_XFER_ENC)\n\t\t\tflags |= HTX_SL_F_XFER_ENC;\n\t\tflags |= HTX_SL_F_XFER_LEN;\n\t\tif (h1m.flags & H1_MF_CHNK)\n\t\t\tflags |= HTX_SL_F_CHNK;\n\t\telse if (h1m.flags & H1_MF_CLEN)\n\t\t\tflags |= HTX_SL_F_CLEN;\n\n\t\thtx = htx_from_buf(get_raw_htx_chunk());\n\t\tsl = htx_add_stline(htx, HTX_BLK_REQ_SL, flags, h1sl.rq.m, h1sl.rq.u, h1sl.rq.v);\n\t\tif (!sl || !htx_add_all_headers(htx, hdrs))\n\t\t\treturn NULL;\n\t\tsl->info.req.meth = h1sl.rq.meth;\n\t}\n\n\t/* OK we just got a valid HTTP message. If not already done by\n\t * HTTP analyzers, we have some minor preparation to perform so\n\t * that further checks can rely on HTTP tests.\n\t */\n\tif (sl && msg->msg_state < HTTP_MSG_BODY) {\n\t\tif (!(chn->flags & CF_ISRESP)) {\n\t\t\ttxn->meth = sl->info.req.meth;\n\t\t\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\t\t\ts->flags |= SF_REDIRECTABLE;\n\t\t}\n\t\telse\n\t\t\ttxn->status = sl->info.res.status;\n\t\tif (sl->flags & HTX_SL_F_VER_11)\n\t\t\tmsg->flags |= HTTP_MSGF_VER_11;\n\t}\n\n\t/* everything's OK */\n  end:\n\treturn htx;\n}\n"", ""caller_start"": 169, ""file_path"": ""src/http_fetch.c""}, {""call_line"": 924, ""call_code"": ""h1_headers_to_hdr_list(raw.ptr, raw.ptr + raw.len,\n\t\t\t\t     hdrs, sizeof(hdrs)/sizeof(hdrs[0]), &h1m, &h1sl)"", ""caller_code"": ""int http_str_to_htx(struct buffer *buf, struct ist raw, char **errmsg)\n{\n\tstruct htx *htx;\n\tstruct htx_sl *sl;\n\tstruct h1m h1m;\n\tstruct http_hdr hdrs[global.tune.max_http_hdr];\n\tunion h1_sl h1sl;\n\tunsigned int flags = HTX_SL_F_IS_RESP;\n\tint ret = 0;\n\n\tb_reset(buf);\n\tif (!raw.len) {\n\t\tbuf->size = 0;\n\t\tbuf->area = NULL;\n\t\treturn 1;\n\t}\n\n\tbuf->size = global.tune.bufsize;\n\tbuf->area = malloc(buf->size);\n\tif (!buf->area)\n\t\tgoto error;\n\n\th1m_init_res(&h1m);\n\th1m.flags |= H1_MF_NO_PHDR;\n\tret = h1_headers_to_hdr_list(raw.ptr, raw.ptr + raw.len,\n\t\t\t\t     hdrs, sizeof(hdrs)/sizeof(hdrs[0]), &h1m, &h1sl);\n\tif (ret <= 0) {\n\t\tmemprintf(errmsg, \""unabled to parse headers (error offset: %d)\"", h1m.err_pos);\n\t\tgoto error;\n\t}\n\n\tif (unlikely(h1sl.st.v.len != 8)) {\n\t\tmemprintf(errmsg, \""invalid http version (%.*s)\"", (int)h1sl.st.v.len, h1sl.st.v.ptr);\n\t\tgoto error;\n\t}\n\tif ((*(h1sl.st.v.ptr + 5) > '1') ||\n\t    ((*(h1sl.st.v.ptr + 5) == '1') && (*(h1sl.st.v.ptr + 7) >= '1')))\n\t\th1m.flags |= H1_MF_VER_11;\n\n\tif (h1sl.st.status < 200 && (h1sl.st.status == 100 || h1sl.st.status >= 102)) {\n\t\tmemprintf(errmsg, \""invalid http status code for an error message (%u)\"",\n\t\t\t  h1sl.st.status);\n\t\tgoto error;\n\t}\n\n\tif (h1sl.st.status == 204 || h1sl.st.status == 304) {\n\t\t/* Responses known to have no body. */\n\t\th1m.flags &= ~(H1_MF_CLEN|H1_MF_CHNK);\n\t\th1m.flags |= H1_MF_XFER_LEN;\n\t\th1m.curr_len = h1m.body_len = 0;\n\t}\n\telse if (h1m.flags & (H1_MF_CLEN|H1_MF_CHNK))\n\t\th1m.flags |= H1_MF_XFER_LEN;\n\n\tif (h1m.flags & H1_MF_VER_11)\n\t\tflags |= HTX_SL_F_VER_11;\n\tif (h1m.flags & H1_MF_XFER_ENC)\n\t\tflags |= HTX_SL_F_XFER_ENC;\n\tif (h1m.flags & H1_MF_XFER_LEN) {\n\t\tflags |= HTX_SL_F_XFER_LEN;\n\t\tif (h1m.flags & H1_MF_CHNK) {\n\t\t\tmemprintf(errmsg, \""chunk-encoded payload not supported\"");\n\t\t\tgoto error;\n\t\t}\n\t\telse if (h1m.flags & H1_MF_CLEN) {\n\t\t\tflags |= HTX_SL_F_CLEN;\n\t\t\tif (h1m.body_len == 0)\n\t\t\t\tflags |= HTX_SL_F_BODYLESS;\n\t\t}\n\t\telse\n\t\t\tflags |= HTX_SL_F_BODYLESS;\n\t}\n\n\tif ((flags & HTX_SL_F_BODYLESS) && raw.len > ret) {\n\t\tmemprintf(errmsg, \""message payload not expected\"");\n\t\tgoto error;\n\t}\n\tif ((flags & HTX_SL_F_CLEN) && h1m.body_len != (raw.len - ret)) {\n\t\tmemprintf(errmsg, \""payload size does not match the announced content-length (%lu != %lu)\"",\n\t\t\t  (unsigned long)(raw.len - ret), (unsigned long)h1m.body_len);\n\t\tgoto error;\n\t}\n\n\thtx = htx_from_buf(buf);\n\tsl = htx_add_stline(htx, HTX_BLK_RES_SL, flags, h1sl.st.v, h1sl.st.c, h1sl.st.r);\n\tif (!sl || !htx_add_all_headers(htx, hdrs)) {\n\t\tmemprintf(errmsg, \""unable to add headers into the HTX message\"");\n\t\tgoto error;\n\t}\n\tsl->info.res.status = h1sl.st.status;\n\n\twhile (raw.len > ret) {\n\t\tint sent = htx_add_data(htx, ist2(raw.ptr + ret, raw.len - ret));\n\t\tif (!sent) {\n\t\t\tmemprintf(errmsg, \""unable to add payload into the HTX message\"");\n\t\t\tgoto error;\n\t\t}\n\t\tret += sent;\n\t}\n\n\thtx->flags |= HTX_FL_EOM;\n\n\treturn 1;\n\nerror:\n\tif (buf->size)\n\t\tfree(buf->area);\n\treturn 0;\n}\n"", ""caller_start"": 900, ""file_path"": ""src/http_htx.c""}]}, {""source"": ""func_info(file:h1.c, func:h1_headers_to_hdr_list)"", ""result"": [{""code"": ""int h1_headers_to_hdr_list(char *start, const char *stop,\n                           struct http_hdr *hdr, unsigned int hdr_num,\n                           struct h1m *h1m, union h1_sl *slp)\n{\n\tenum h1m_state state;\n\tregister char *ptr;\n\tregister const char *end;\n\tunsigned int hdr_count;\n\tunsigned int skip; /* number of bytes skipped at the beginning */\n\tunsigned int sol;  /* start of line */\n\tunsigned int col;  /* position of the colon */\n\tunsigned int eol;  /* end of line */\n\tunsigned int sov;  /* start of value */\n\tunion h1_sl sl;\n\tint skip_update;\n\tint restarting;\n\tint host_idx;\n\tstruct ist n, v;       /* header name and value during parsing */\n\n\tskip = 0; // do it only once to keep track of the leading CRLF.\n\n try_again:\n\thdr_count = sol = col = eol = sov = 0;\n\tsl.st.status = 0;\n\tskip_update = restarting = 0;\n\thost_idx = -1;\n\n\tif (h1m->flags & H1_MF_HDRS_ONLY) {\n\t\tstate = H1_MSG_HDR_FIRST;\n\t\th1m->next = 0;\n\t}\n\telse {\n\t\tstate = h1m->state;\n\t\tif (h1m->state != H1_MSG_RQBEFORE && h1m->state != H1_MSG_RPBEFORE)\n\t\t\trestarting = 1;\n\t}\n\n\tptr   = start + h1m->next;\n\tend   = stop;\n\n\tif (unlikely(ptr >= end))\n\t\tgoto http_msg_ood;\n\n\t/* don't update output if hdr is NULL or if we're restarting */\n\tif (!hdr || restarting)\n\t\tskip_update = 1;\n\n\tswitch (state)\t{\n\tcase H1_MSG_RQBEFORE:\n\thttp_msg_rqbefore:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\t/* we have a start of message, we may have skipped some\n\t\t\t * heading CRLF. Skip them now.\n\t\t\t */\n\t\t\tskip += ptr - start;\n\t\t\tstart = ptr;\n\n\t\t\tsol = 0;\n\t\t\tsl.rq.m.ptr = ptr;\n\t\t\thdr_count = 0;\n\t\t\tstate = H1_MSG_RQMETH;\n\t\t\tgoto http_msg_rqmeth;\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tstate = H1_MSG_RQBEFORE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (unlikely(*ptr == '\\n'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore, http_msg_ood, state, H1_MSG_RQBEFORE);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore_cr, http_msg_ood, state, H1_MSG_RQBEFORE_CR);\n\t\t/* stop here */\n\n\tcase H1_MSG_RQBEFORE_CR:\n\thttp_msg_rqbefore_cr:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RQBEFORE_CR);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore, http_msg_ood, state, H1_MSG_RQBEFORE);\n\t\t/* stop here */\n\n\tcase H1_MSG_RQMETH:\n\thttp_msg_rqmeth:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth, http_msg_ood, state, H1_MSG_RQMETH);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.rq.m.len = ptr - sl.rq.m.ptr;\n\t\t\tsl.rq.meth = find_http_meth(start, sl.rq.m.len);\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth_sp, http_msg_ood, state, H1_MSG_RQMETH_SP);\n\t\t}\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\t/* HTTP 0.9 request */\n\t\t\tsl.rq.m.len = ptr - sl.rq.m.ptr;\n\t\t\tsl.rq.meth = find_http_meth(sl.rq.m.ptr, sl.rq.m.len);\n\t\thttp_msg_req09_uri:\n\t\t\tsl.rq.u.ptr = ptr;\n\t\thttp_msg_req09_uri_e:\n\t\t\tsl.rq.u.len = ptr - sl.rq.u.ptr;\n\t\thttp_msg_req09_ver:\n\t\t\tsl.rq.v.ptr = ptr;\n\t\t\tsl.rq.v.len = 0;\n\t\t\tgoto http_msg_rqline_eol;\n\t\t}\n\t\tstate = H1_MSG_RQMETH;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQMETH_SP:\n\thttp_msg_rqmeth_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.rq.u.ptr = ptr;\n\t\t\tgoto http_msg_rquri;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth_sp, http_msg_ood, state, H1_MSG_RQMETH_SP);\n\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\tgoto http_msg_req09_uri;\n\n\tcase H1_MSG_RQURI:\n\thttp_msg_rquri:\n#ifdef HA_UNALIGNED_LE\n\t\t/* speedup: skip bytes not between 0x21 and 0x7e inclusive */\n\t\twhile (ptr <= end - sizeof(int)) {\n\t\t\tint x = *(int *)ptr - 0x21212121;\n\t\t\tif (x & 0x80808080)\n\t\t\t\tbreak;\n\n\t\t\tx -= 0x5e5e5e5e;\n\t\t\tif (!(x & 0x80808080))\n\t\t\t\tbreak;\n\n\t\t\tptr += sizeof(int);\n\t\t}\n#endif\n\t\tif (ptr >= end) {\n\t\t\tstate = H1_MSG_RQURI;\n\t\t\tgoto http_msg_ood;\n\t\t}\n\thttp_msg_rquri2:\n\t\tif (likely((unsigned char)(*ptr - 33) <= 93)) /* 33 to 126 included */\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri2, http_msg_ood, state, H1_MSG_RQURI);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.rq.u.len = ptr - sl.rq.u.ptr;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri_sp, http_msg_ood, state, H1_MSG_RQURI_SP);\n\t\t}\n\t\tif (likely((unsigned char)*ptr >= 128)) {\n\t\t\t/* non-ASCII chars are forbidden unless option\n\t\t\t * accept-invalid-http-request is enabled in the frontend.\n\t\t\t * In any case, we capture the faulty char.\n\t\t\t */\n\t\t\tif (h1m->err_pos < -1)\n\t\t\t\tgoto invalid_char;\n\t\t\tif (h1m->err_pos == -1)\n\t\t\t\th1m->err_pos = ptr - start + skip;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri, http_msg_ood, state, H1_MSG_RQURI);\n\t\t}\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\t\tgoto http_msg_req09_uri_e;\n\t\t}\n\n\t\t/* OK forbidden chars, 0..31 or 127 */\n\tinvalid_char:\n\t\tstate = H1_MSG_RQURI;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQURI_SP:\n\thttp_msg_rquri_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.rq.v.ptr = ptr;\n\t\t\tgoto http_msg_rqver;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri_sp, http_msg_ood, state, H1_MSG_RQURI_SP);\n\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\tgoto http_msg_req09_ver;\n\n\n\tcase H1_MSG_RQVER:\n\thttp_msg_rqver:\n\t\tif (likely(HTTP_IS_VER_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqver, http_msg_ood, state, H1_MSG_RQVER);\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\tsl.rq.v.len = ptr - sl.rq.v.ptr;\n\t\thttp_msg_rqline_eol:\n\t\t\t/* We have seen the end of line. Note that we do not\n\t\t\t * necessarily have the \\n yet, but at least we know that we\n\t\t\t * have EITHER \\r OR \\n, otherwise the request would not be\n\t\t\t * complete. We can then record the request length and return\n\t\t\t * to the caller which will be able to register it.\n\t\t\t */\n\n\t\t\tif (likely(!skip_update)) {\n\t\t\t\tif ((sl.rq.v.len == 8) &&\n\t\t\t\t    (*(sl.rq.v.ptr + 5) > '1' ||\n\t\t\t\t     (*(sl.rq.v.ptr + 5) == '1' && *(sl.rq.v.ptr + 7) >= '1')))\n\t\t\t\t\th1m->flags |= H1_MF_VER_11;\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_RQVER;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\t\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\"":method\""), sl.rq.m);\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_RQVER;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\t\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\"":path\""), sl.rq.u);\n\t\t\t}\n\n\t\t\tsol = ptr - start;\n\t\t\tif (likely(*ptr == '\\r'))\n\t\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqline_end, http_msg_ood, state, H1_MSG_RQLINE_END);\n\t\t\tgoto http_msg_rqline_end;\n\t\t}\n\n\t\t/* neither an HTTP_VER token nor a CRLF */\n\t\tstate = H1_MSG_RQVER;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQLINE_END:\n\thttp_msg_rqline_end:\n\t\t/* check for HTTP/0.9 request : no version information\n\t\t * available. sol must point to the first of CR or LF. However\n\t\t * since we don't save these elements between calls, if we come\n\t\t * here from a restart, we don't necessarily know. Thus in this\n\t\t * case we simply start over.\n\t\t */\n\t\tif (restarting)\n\t\t\tgoto restart;\n\n\t\tif (unlikely(sl.rq.v.len == 0))\n\t\t\tgoto http_msg_last_lf;\n\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RQLINE_END);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_first, http_msg_ood, state, H1_MSG_HDR_FIRST);\n\t\t/* stop here */\n\n\t/*\n\t * Common states below\n\t */\n\tcase H1_MSG_RPBEFORE:\n\thttp_msg_rpbefore:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\t/* we have a start of message, we may have skipped some\n\t\t\t * heading CRLF. Skip them now.\n\t\t\t */\n\t\t\tskip += ptr - start;\n\t\t\tstart = ptr;\n\n\t\t\tsol = 0;\n\t\t\tsl.st.v.ptr = ptr;\n\t\t\thdr_count = 0;\n\t\t\tstate = H1_MSG_RPVER;\n\t\t\tgoto http_msg_rpver;\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tstate = H1_MSG_RPBEFORE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (unlikely(*ptr == '\\n'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore, http_msg_ood, state, H1_MSG_RPBEFORE);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore_cr, http_msg_ood, state, H1_MSG_RPBEFORE_CR);\n\t\t/* stop here */\n\n\tcase H1_MSG_RPBEFORE_CR:\n\thttp_msg_rpbefore_cr:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RPBEFORE_CR);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore, http_msg_ood, state, H1_MSG_RPBEFORE);\n\t\t/* stop here */\n\n\tcase H1_MSG_RPVER:\n\thttp_msg_rpver:\n\t\tif (likely(HTTP_IS_VER_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver, http_msg_ood, state, H1_MSG_RPVER);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.st.v.len = ptr - sl.st.v.ptr;\n\n\t\t\tif ((sl.st.v.len == 8) &&\n\t\t\t    (*(sl.st.v.ptr + 5) > '1' ||\n\t\t\t     (*(sl.st.v.ptr + 5) == '1' && *(sl.st.v.ptr + 7) >= '1')))\n\t\t\t\th1m->flags |= H1_MF_VER_11;\n\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver_sp, http_msg_ood, state, H1_MSG_RPVER_SP);\n\t\t}\n\t\tstate = H1_MSG_RPVER;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RPVER_SP:\n\thttp_msg_rpver_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.st.status = 0;\n\t\t\tsl.st.c.ptr = ptr;\n\t\t\tgoto http_msg_rpcode;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver_sp, http_msg_ood, state, H1_MSG_RPVER_SP);\n\t\t/* so it's a CR/LF, this is invalid */\n\t\tstate = H1_MSG_RPVER_SP;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RPCODE:\n\thttp_msg_rpcode:\n\t\tif (likely(HTTP_IS_DIGIT(*ptr))) {\n\t\t\tsl.st.status = sl.st.status * 10 + *ptr - '0';\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode, http_msg_ood, state, H1_MSG_RPCODE);\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tstate = H1_MSG_RPCODE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.st.c.len = ptr - sl.st.c.ptr;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode_sp, http_msg_ood, state, H1_MSG_RPCODE_SP);\n\t\t}\n\n\t\t/* so it's a CR/LF, so there is no reason phrase */\n\t\tsl.st.c.len = ptr - sl.st.c.ptr;\n\n\thttp_msg_rsp_reason:\n\t\tsl.st.r.ptr = ptr;\n\t\tsl.st.r.len = 0;\n\t\tgoto http_msg_rpline_eol;\n\n\tcase H1_MSG_RPCODE_SP:\n\thttp_msg_rpcode_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.st.r.ptr = ptr;\n\t\t\tgoto http_msg_rpreason;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode_sp, http_msg_ood, state, H1_MSG_RPCODE_SP);\n\t\t/* so it's a CR/LF, so there is no reason phrase */\n\t\tgoto http_msg_rsp_reason;\n\n\tcase H1_MSG_RPREASON:\n\thttp_msg_rpreason:\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpreason, http_msg_ood, state, H1_MSG_RPREASON);\n\t\tsl.st.r.len = ptr - sl.st.r.ptr;\n\thttp_msg_rpline_eol:\n\t\t/* We have seen the end of line. Note that we do not\n\t\t * necessarily have the \\n yet, but at least we know that we\n\t\t * have EITHER \\r OR \\n, otherwise the response would not be\n\t\t * complete. We can then record the response length and return\n\t\t * to the caller which will be able to register it.\n\t\t */\n\n\t\tif (likely(!skip_update)) {\n\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\tstate = H1_MSG_RPREASON;\n\t\t\t\tgoto http_output_full;\n\t\t\t}\n\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\"":status\""), sl.st.c);\n\t\t}\n\n\t\tsol = ptr - start;\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpline_end, http_msg_ood, state, H1_MSG_RPLINE_END);\n\t\tgoto http_msg_rpline_end;\n\n\tcase H1_MSG_RPLINE_END:\n\thttp_msg_rpline_end:\n\t\t/* sol must point to the first of CR or LF. */\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RPLINE_END);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_first, http_msg_ood, state, H1_MSG_HDR_FIRST);\n\t\t/* stop here */\n\n\tcase H1_MSG_HDR_FIRST:\n\thttp_msg_hdr_first:\n\t\tsol = ptr - start;\n\t\tif (likely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tgoto http_msg_hdr_name;\n\t\t}\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_last_lf, http_msg_ood, state, H1_MSG_LAST_LF);\n\t\tgoto http_msg_last_lf;\n\n\tcase H1_MSG_HDR_NAME:\n\thttp_msg_hdr_name:\n\t\t/* assumes sol points to the first char */\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* turn it to lower case if needed */\n\t\t\t\tif (isupper((unsigned char)*ptr) && h1m->flags & H1_MF_TOLOWER)\n\t\t\t\t\t*ptr = tolower((unsigned char)*ptr);\n\t\t\t}\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_name, http_msg_ood, state, H1_MSG_HDR_NAME);\n\t\t}\n\n\t\tif (likely(*ptr == ':')) {\n\t\t\tcol = ptr - start;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_sp, http_msg_ood, state, H1_MSG_HDR_L1_SP);\n\t\t}\n\n\t\tif (likely(h1m->err_pos < -1) || *ptr == '\\n') {\n\t\t\tstate = H1_MSG_HDR_NAME;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\th1m->err_pos = ptr - start + skip; /* >= 0 now */\n\n\t\t/* and we still accept this non-token character */\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_name, http_msg_ood, state, H1_MSG_HDR_NAME);\n\n\tcase H1_MSG_HDR_L1_SP:\n\thttp_msg_hdr_l1_sp:\n\t\t/* assumes sol points to the first char */\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_sp, http_msg_ood, state, H1_MSG_HDR_L1_SP);\n\n\t\t/* header value can be basically anything except CR/LF */\n\t\tsov = ptr - start;\n\n\t\tif (likely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tgoto http_msg_hdr_val;\n\t\t}\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_lf, http_msg_ood, state, H1_MSG_HDR_L1_LF);\n\t\tgoto http_msg_hdr_l1_lf;\n\n\tcase H1_MSG_HDR_L1_LF:\n\thttp_msg_hdr_l1_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_HDR_L1_LF);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_lws, http_msg_ood, state, H1_MSG_HDR_L1_LWS);\n\n\tcase H1_MSG_HDR_L1_LWS:\n\thttp_msg_hdr_l1_lws:\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* replace HT,CR,LF with spaces */\n\t\t\t\tfor (; start + sov < ptr; sov++)\n\t\t\t\t\tstart[sov] = ' ';\n\t\t\t}\n\t\t\tgoto http_msg_hdr_l1_sp;\n\t\t}\n\t\t/* we had a header consisting only in spaces ! */\n\t\teol = sov;\n\t\tgoto http_msg_complete_header;\n\n\tcase H1_MSG_HDR_VAL:\n\thttp_msg_hdr_val:\n\t\t/* assumes sol points to the first char, and sov\n\t\t * points to the first character of the value.\n\t\t */\n\n\t\t/* speedup: we'll skip packs of 4 or 8 bytes not containing bytes 0x0D\n\t\t * and lower. In fact since most of the time is spent in the loop, we\n\t\t * also remove the sign bit test so that bytes 0x8e..0x0d break the\n\t\t * loop, but we don't care since they're very rare in header values.\n\t\t */\n#ifdef HA_UNALIGNED_LE64\n\t\twhile (ptr <= end - sizeof(long)) {\n\t\t\tif ((*(long *)ptr - 0x0e0e0e0e0e0e0e0eULL) & 0x8080808080808080ULL)\n\t\t\t\tgoto http_msg_hdr_val2;\n\t\t\tptr += sizeof(long);\n\t\t}\n#endif\n#ifdef HA_UNALIGNED_LE\n\t\twhile (ptr <= end - sizeof(int)) {\n\t\t\tif ((*(int*)ptr - 0x0e0e0e0e) & 0x80808080)\n\t\t\t\tgoto http_msg_hdr_val2;\n\t\t\tptr += sizeof(int);\n\t\t}\n#endif\n\t\tif (ptr >= end) {\n\t\t\tstate = H1_MSG_HDR_VAL;\n\t\t\tgoto http_msg_ood;\n\t\t}\n\thttp_msg_hdr_val2:\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_val2, http_msg_ood, state, H1_MSG_HDR_VAL);\n\n\t\teol = ptr - start;\n\t\t/* Note: we could also copy eol into ->eoh so that we have the\n\t\t * real header end in case it ends with lots of LWS, but is this\n\t\t * really needed ?\n\t\t */\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l2_lf, http_msg_ood, state, H1_MSG_HDR_L2_LF);\n\t\tgoto http_msg_hdr_l2_lf;\n\n\tcase H1_MSG_HDR_L2_LF:\n\thttp_msg_hdr_l2_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_HDR_L2_LF);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l2_lws, http_msg_ood, state, H1_MSG_HDR_L2_LWS);\n\n\tcase H1_MSG_HDR_L2_LWS:\n\thttp_msg_hdr_l2_lws:\n\t\tif (unlikely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* LWS: replace HT,CR,LF with spaces */\n\t\t\t\tfor (; start + eol < ptr; eol++)\n\t\t\t\t\tstart[eol] = ' ';\n\t\t\t}\n\t\t\tgoto http_msg_hdr_val;\n\t\t}\n\thttp_msg_complete_header:\n\t\t/*\n\t\t * It was a new header, so the last one is finished. Assumes\n\t\t * <sol> points to the first char of the name, <col> to the\n\t\t * colon, <sov> points to the first character of the value and\n\t\t * <eol> to the first CR or LF so we know how the line ends. We\n\t\t * will trim spaces around the value. It's possible to do it by\n\t\t * adjusting <eol> and <sov> which are no more used after this.\n\t\t * We can add the header field to the list.\n\t\t */\n\t\tif (likely(!skip_update)) {\n\t\t\twhile (sov < eol && HTTP_IS_LWS(start[sov]))\n\t\t\t\tsov++;\n\n\t\t\twhile (eol - 1 > sov && HTTP_IS_LWS(start[eol - 1]))\n\t\t\t\teol--;\n\n\n\t\t\tn = ist2(start + sol, col - sol);\n\t\t\tv = ist2(start + sov, eol - sov);\n\n\t\t\tdo {\n\t\t\t\tint ret;\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\n\t\t\t\tif (isteqi(n, ist(\""transfer-encoding\""))) {\n\t\t\t\t\th1_parse_xfer_enc_header(h1m, v);\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\""content-length\""))) {\n\t\t\t\t\tret = h1_parse_cont_len_header(h1m, &v);\n\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ret == 0) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\""connection\""))) {\n\t\t\t\t\th1_parse_connection_header(h1m, &v);\n\t\t\t\t\tif (!v.len) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\""upgrade\""))) {\n\t\t\t\t\th1_parse_upgrade_header(h1m, v);\n\t\t\t\t}\n\t\t\t\telse if (!(h1m->flags & (H1_MF_HDRS_ONLY|H1_MF_RESP)) && isteqi(n, ist(\""host\""))) {\n\t\t\t\t\tif (host_idx == -1) {\n\t\t\t\t\t\tstruct ist authority;\n\t\t\t\t\t\tstruct http_uri_parser parser = http_uri_parser_init(sl.rq.u);\n\n\t\t\t\t\t\tauthority = http_parse_authority(&parser, 1);\n\t\t\t\t\t\tif (authority.len && !isteqi(v, authority)) {\n\t\t\t\t\t\t\tif (h1m->err_pos < -1) {\n\t\t\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\t\t\t\t\t\th1m->err_pos = v.ptr - start + skip; /* >= 0 now */\n\t\t\t\t\t\t}\n\t\t\t\t\t\thost_idx = hdr_count;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!isteqi(v, hdr[host_idx].v)) {\n\t\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* if the same host, skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thttp_set_hdr(&hdr[hdr_count++], n, v);\n\t\t\t} while (0);\n\t\t}\n\n\t\tsol = ptr - start;\n\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tgoto http_msg_hdr_name;\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_last_lf, http_msg_ood, state, H1_MSG_LAST_LF);\n\t\tgoto http_msg_last_lf;\n\n\tcase H1_MSG_LAST_LF:\n\thttp_msg_last_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_LAST_LF);\n\t\tptr++;\n\t\t/* <ptr> now points to the first byte of payload. If needed sol\n\t\t * still points to the first of either CR or LF of the empty\n\t\t * line ending the headers block.\n\t\t */\n\t\tif (likely(!skip_update)) {\n\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\tstate = H1_MSG_LAST_LF;\n\t\t\t\tgoto http_output_full;\n\t\t\t}\n\t\t\thttp_set_hdr(&hdr[hdr_count++], ist2(start+sol, 0), ist(\""\""));\n\t\t}\n\n\t\t/* reaching here we've parsed the whole message. We may detect\n\t\t * that we were already continuing an interrupted parsing pass\n\t\t * so we were silently looking for the end of message not\n\t\t * updating anything before deciding to parse it fully at once.\n\t\t * It's guaranteed that we won't match this test twice in a row\n\t\t * since restarting will turn zero.\n\t\t */\n\t\tif (restarting)\n\t\t\tgoto restart;\n\n\t\tstate = H1_MSG_DATA;\n\t\tif (h1m->flags & H1_MF_XFER_ENC) {\n\t\t\tif (h1m->flags & H1_MF_CLEN) {\n\t\t\t\th1m->flags &= ~H1_MF_CLEN;\n\t\t\t\thdr_count = http_del_hdr(hdr, ist(\""content-length\""));\n\t\t\t}\n\n\t\t\tif (h1m->flags & H1_MF_CHNK)\n\t\t\t\tstate = H1_MSG_CHUNK_SIZE;\n\t\t\telse if (!(h1m->flags & H1_MF_RESP)) {\n\t\t\t\t/* cf RFC7230#3.3.3 : transfer-encoding in\n\t\t\t\t * request without chunked encoding is invalid.\n\t\t\t\t */\n\t\t\t\tgoto http_msg_invalid;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\t/* impossible states */\n\t\tgoto http_msg_invalid;\n\t}\n\n\t/* Now we've left the headers state and are either in H1_MSG_DATA or\n\t * H1_MSG_CHUNK_SIZE.\n\t */\n\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->state = state;\n\th1m->next  = ptr - start + skip;\n\treturn h1m->next;\n\n http_msg_ood:\n\t/* out of data at <ptr> during state <state> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->state = state;\n\th1m->next  = ptr - start + skip;\n\treturn 0;\n\n http_msg_invalid:\n\t/* invalid message, error at <ptr> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->err_state = h1m->state = state;\n\th1m->err_pos   = h1m->next  = ptr - start + skip;\n\treturn -1;\n\n http_output_full:\n\t/* no more room to store the current header, error at <ptr> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->err_state = h1m->state = state;\n\th1m->err_pos   = h1m->next  = ptr - start + skip;\n\treturn -2;\n\n restart:\n\th1m->flags &= ~(H1_MF_VER_11|H1_MF_CLEN|H1_MF_XFER_ENC|H1_MF_CHNK|H1_MF_CONN_KAL|H1_MF_CONN_CLO|H1_MF_CONN_UPG);\n\th1m->curr_len = h1m->body_len = h1m->next  = 0;\n\tif (h1m->flags & H1_MF_RESP)\n\t\th1m->state = H1_MSG_RPBEFORE;\n\telse\n\t\th1m->state = H1_MSG_RQBEFORE;\n\tgoto try_again;\n}\n"", ""start_line"": 304, ""end_line"": 1008, ""full_name"": ""h1_headers_to_hdr_list"", ""file_path"": ""src/h1.c""}]}, {""source"": ""code_info(file:h1.c, lines:1-200)"", ""result"": ""/*\n * HTTP/1 protocol analyzer\n *\n * Copyright 2000-2017 Willy Tarreau <w@1wt.eu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n */\n\n#include <ctype.h>\n\n#include <import/sha1.h>\n\n#include <haproxy/api.h>\n#include <haproxy/base64.h>\n#include <haproxy/h1.h>\n#include <haproxy/http-hdr.h>\n#include <haproxy/tools.h>\n\n/* Parse the Content-Length header field of an HTTP/1 request. The function\n * checks all possible occurrences of a comma-delimited value, and verifies\n * if any of them doesn't match a previous value. It returns <0 if a value\n * differs, 0 if the whole header can be dropped (i.e. already known), or >0\n * if the value can be indexed (first one). In the last case, the value might\n * be adjusted and the caller must only add the updated value.\n */\nint h1_parse_cont_len_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n;\n\tlong long cl;\n\tint not_first = !!(h1m->flags & H1_MF_CLEN);\n\tstruct ist word;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (h1m->flags & H1_MF_CLEN && cl != h1m->body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\th1m->flags |= H1_MF_CLEN;\n\t\th1m->curr_len = h1m->body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t}\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}\n\n/* Parse the Transfer-Encoding: header field of an HTTP/1 request, looking for\n * \""chunked\"" being the last value, and setting H1_MF_CHNK in h1m->flags only in\n * this case. Any other token found or any empty header field found will reset\n * this flag, so that it accurately represents the token's presence at the last\n * position. The H1_MF_XFER_ENC flag is always set. Note that transfer codings\n * are case-insensitive (cf RFC7230#4).\n */\nvoid h1_parse_xfer_enc_header(struct h1m *h1m, struct ist value)\n{\n\tchar *e, *n;\n\tstruct ist word;\n\n\th1m->flags |= H1_MF_XFER_ENC;\n\th1m->flags &= ~H1_MF_CHNK;\n\n\tword.ptr = value.ptr - 1; // -1 for next loop's pre-increment\n\te = value.ptr + value.len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (HTTP_IS_LWS(*word.ptr))\n\t\t\tcontinue;\n\n\t\tn = http_find_hdr_value_end(word.ptr, e); // next comma or end of line\n\t\tword.len = n - word.ptr;\n\n\t\t/* trim trailing blanks */\n\t\twhile (word.len && HTTP_IS_LWS(word.ptr[word.len-1]))\n\t\t\tword.len--;\n\n\t\th1m->flags &= ~H1_MF_CHNK;\n\t\tif (isteqi(word, ist(\""chunked\"")))\n\t\t\th1m->flags |= H1_MF_CHNK;\n\n\t\tword.ptr = n;\n\t}\n}\n\n/* Parse the Connection: header of an HTTP/1 request, looking for \""close\"",\n * \""keep-alive\"", and \""upgrade\"" values, and updating h1m->flags according to\n * what was found there. Note that flags are only added, not removed, so the\n * function is safe for being called multiple times if multiple occurrences\n * are found. If the flag H1_MF_CLEAN_CONN_HDR, the header value is cleaned\n * up from \""keep-alive\"" and \""close\"" values. To do so, the header value is\n * rewritten in place and its length is updated.\n */\nvoid h1_parse_connection_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n, *p;\n\tstruct ist word;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\tp = value->ptr;\n\te = value->ptr + value->len;\n\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR)\n\t\tvalue->len = 0;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (HTTP_IS_LWS(*word.ptr))\n\t\t\tcontinue;\n\n\t\tn = http_find_hdr_value_end(word.ptr, e); // next comma or end of line\n\t\tword.len = n - word.ptr;\n\n\t\t/* trim trailing blanks */\n\t\twhile (word.len && HTTP_IS_LWS(word.ptr[word.len-1]))\n\t\t\tword.len--;\n\n\t\tif (isteqi(word, ist(\""keep-alive\""))) {\n\t\t\th1m->flags |= H1_MF_CONN_KAL;\n\t\t\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR)\n\t\t\t\tgoto skip_val;\n\t\t}\n\t\telse if (isteqi(word, ist(\""close\""))) {\n\t\t\th1m->flags |= H1_MF_CONN_CLO;\n\t\t\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR)\n\t\t\t\tgoto skip_val;\n\t\t}\n\t\telse if (isteqi(word, ist(\""upgrade\"")))\n\t\t\th1m->flags |= H1_MF_CONN_UPG;\n\n\t\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR) {\n\t\t\tif (value->ptr + value->len == p) {\n\t\t\t\t/* no rewrite done till now */\n\t\t\t\tvalue->len = n - value->ptr;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (value->len)\n\t\t\t\t\tvalue->ptr[value->len++] = ',';\n\t\t\t\tistcat(value, word, e - value->ptr);\n\t\t\t}\n\t\t}\n\n\t  skip_val:\n\t\tword.ptr = p = n;\n\t}\n}\n\n/* Parse the Upgrade: header of an HTTP/1 request.\n * If \""websocket\"" is found, set H1_MF_UPG_WEBSOCKET flag\n */\nvoid h1_parse_upgrade_header(struct h1m *h1m, struct ist value)\n{\n\tchar *e, *n;\n\tstruct ist word;\n\n""}]","Root cause: Missing length validation in htx_add_header (include/haproxy/htx.h:467-469) and htx_add_trailer (include/haproxy/htx.h:486-488). Attackers could inject oversized header names via HTTP parsers (e.g., h1_headers_to_hdr_list in src/h1.c) that populate struct http_hdr without enforcing name length limits. Callers like h1_postparse_req_hdrs (src/h1_htx.c:183) pass unvalidated hdrs to htx_add_all_headers (include/haproxy/htx.h:522), which relies on the missing checks in htx_add_header. This allows forged headers (e.g., Content-Length manipulation) leading to request smuggling.",0.95,./github/other_context/CVE-2021-40346
33,CVE-2021-45960,CWE-682,c_cpp,"In Expat (aka libexpat) before 2.4.3, a left shift by 29 (or more) places in the storeAtts function in xmlparse.c can lead to realloc misbehavior (e.g., allocating too few bytes, or only freeing memory).",https://github.com/libexpat/libexpat/commit/0adcb34c49bee5b19bd29b16a578c510c23597ea,lib: Detect and prevent troublesome left shifts in function storeAtts (CVE-2021-45960),1,"[{""func_name"": ""storeAtts"", ""file_path"": ""expat/lib/xmlparse.c"", ""func_code"": ""static enum XML_Error\nstoreAtts(XML_Parser parser, const ENCODING *enc, const char *attStr,\n          TAG_NAME *tagNamePtr, BINDING **bindingsPtr,\n          enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  ELEMENT_TYPE *elementType;\n  int nDefaultAtts;\n  const XML_Char **appAtts; /* the attribute list for the application */\n  int attIndex = 0;\n  int prefixLen;\n  int i;\n  int n;\n  XML_Char *uri;\n  int nPrefixes = 0;\n  BINDING *binding;\n  const XML_Char *localPart;\n\n  /* lookup the element type name */\n  elementType\n      = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, tagNamePtr->str, 0);\n  if (! elementType) {\n    const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str);\n    if (! name)\n      return XML_ERROR_NO_MEMORY;\n    elementType = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, name,\n                                         sizeof(ELEMENT_TYPE));\n    if (! elementType)\n      return XML_ERROR_NO_MEMORY;\n    if (parser->m_ns && ! setElementTypePrefix(parser, elementType))\n      return XML_ERROR_NO_MEMORY;\n  }\n  nDefaultAtts = elementType->nDefaultAtts;\n\n  /* get the attributes from the tokenizer */\n  n = XmlGetAttributes(enc, attStr, parser->m_attsSize, parser->m_atts);\n  if (n + nDefaultAtts > parser->m_attsSize) {\n    int oldAttsSize = parser->m_attsSize;\n    ATTRIBUTE *temp;\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *temp2;\n#endif\n    parser->m_attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;\n    temp = (ATTRIBUTE *)REALLOC(parser, (void *)parser->m_atts,\n                                parser->m_attsSize * sizeof(ATTRIBUTE));\n    if (temp == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_atts = temp;\n#ifdef XML_ATTR_INFO\n    temp2 = (XML_AttrInfo *)REALLOC(parser, (void *)parser->m_attInfo,\n                                    parser->m_attsSize * sizeof(XML_AttrInfo));\n    if (temp2 == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_attInfo = temp2;\n#endif\n    if (n > oldAttsSize)\n      XmlGetAttributes(enc, attStr, n, parser->m_atts);\n  }\n\n  appAtts = (const XML_Char **)parser->m_atts;\n  for (i = 0; i < n; i++) {\n    ATTRIBUTE *currAtt = &parser->m_atts[i];\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *currAttInfo = &parser->m_attInfo[i];\n#endif\n    /* add the name and value to the attribute list */\n    ATTRIBUTE_ID *attId\n        = getAttributeId(parser, enc, currAtt->name,\n                         currAtt->name + XmlNameLength(enc, currAtt->name));\n    if (! attId)\n      return XML_ERROR_NO_MEMORY;\n#ifdef XML_ATTR_INFO\n    currAttInfo->nameStart\n        = parser->m_parseEndByteIndex - (parser->m_parseEndPtr - currAtt->name);\n    currAttInfo->nameEnd\n        = currAttInfo->nameStart + XmlNameLength(enc, currAtt->name);\n    currAttInfo->valueStart = parser->m_parseEndByteIndex\n                              - (parser->m_parseEndPtr - currAtt->valuePtr);\n    currAttInfo->valueEnd = parser->m_parseEndByteIndex\n                            - (parser->m_parseEndPtr - currAtt->valueEnd);\n#endif\n    /* Detect duplicate attributes by their QNames. This does not work when\n       namespace processing is turned on and different prefixes for the same\n       namespace are used. For this case we have a check further down.\n    */\n    if ((attId->name)[-1]) {\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = parser->m_atts[i].name;\n      return XML_ERROR_DUPLICATE_ATTRIBUTE;\n    }\n    (attId->name)[-1] = 1;\n    appAtts[attIndex++] = attId->name;\n    if (! parser->m_atts[i].normalized) {\n      enum XML_Error result;\n      XML_Bool isCdata = XML_TRUE;\n\n      /* figure out whether declared as other than CDATA */\n      if (attId->maybeTokenized) {\n        int j;\n        for (j = 0; j < nDefaultAtts; j++) {\n          if (attId == elementType->defaultAtts[j].id) {\n            isCdata = elementType->defaultAtts[j].isCdata;\n            break;\n          }\n        }\n      }\n\n      /* normalize the attribute value */\n      result = storeAttributeValue(\n          parser, enc, isCdata, parser->m_atts[i].valuePtr,\n          parser->m_atts[i].valueEnd, &parser->m_tempPool, account);\n      if (result)\n        return result;\n      appAtts[attIndex] = poolStart(&parser->m_tempPool);\n      poolFinish(&parser->m_tempPool);\n    } else {\n      /* the value did not need normalizing */\n      appAtts[attIndex] = poolStoreString(&parser->m_tempPool, enc,\n                                          parser->m_atts[i].valuePtr,\n                                          parser->m_atts[i].valueEnd);\n      if (appAtts[attIndex] == 0)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n    }\n    /* handle prefixed attribute names */\n    if (attId->prefix) {\n      if (attId->xmlns) {\n        /* deal with namespace declarations here */\n        enum XML_Error result = addBinding(parser, attId->prefix, attId,\n                                           appAtts[attIndex], bindingsPtr);\n        if (result)\n          return result;\n        --attIndex;\n      } else {\n        /* deal with other prefixed names later */\n        attIndex++;\n        nPrefixes++;\n        (attId->name)[-1] = 2;\n      }\n    } else\n      attIndex++;\n  }\n\n  /* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */\n  parser->m_nSpecifiedAtts = attIndex;\n  if (elementType->idAtt && (elementType->idAtt->name)[-1]) {\n    for (i = 0; i < attIndex; i += 2)\n      if (appAtts[i] == elementType->idAtt->name) {\n        parser->m_idAttIndex = i;\n        break;\n      }\n  } else\n    parser->m_idAttIndex = -1;\n\n  /* do attribute defaulting */\n  for (i = 0; i < nDefaultAtts; i++) {\n    const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i;\n    if (! (da->id->name)[-1] && da->value) {\n      if (da->id->prefix) {\n        if (da->id->xmlns) {\n          enum XML_Error result = addBinding(parser, da->id->prefix, da->id,\n                                             da->value, bindingsPtr);\n          if (result)\n            return result;\n        } else {\n          (da->id->name)[-1] = 2;\n          nPrefixes++;\n          appAtts[attIndex++] = da->id->name;\n          appAtts[attIndex++] = da->value;\n        }\n      } else {\n        (da->id->name)[-1] = 1;\n        appAtts[attIndex++] = da->id->name;\n        appAtts[attIndex++] = da->value;\n      }\n    }\n  }\n  appAtts[attIndex] = 0;\n\n  /* expand prefixed attribute names, check for duplicates,\n     and clear flags that say whether attributes were specified */\n  i = 0;\n  if (nPrefixes) {\n    int j; /* hash table index */\n    unsigned long version = parser->m_nsAttsVersion;\n    int nsAttsSize = (int)1 << parser->m_nsAttsPower;\n    unsigned char oldNsAttsPower = parser->m_nsAttsPower;\n    /* size of hash table must be at least 2 * (# of prefixed attributes) */\n    if ((nPrefixes << 1)\n        >> parser->m_nsAttsPower) { /* true for m_nsAttsPower = 0 */\n      NS_ATT *temp;\n      /* hash table size must also be a power of 2 and >= 8 */\n      while (nPrefixes >> parser->m_nsAttsPower++)\n        ;\n      if (parser->m_nsAttsPower < 3)\n        parser->m_nsAttsPower = 3;\n      nsAttsSize = (int)1 << parser->m_nsAttsPower;\n      temp = (NS_ATT *)REALLOC(parser, parser->m_nsAtts,\n                               nsAttsSize * sizeof(NS_ATT));\n      if (! temp) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n      parser->m_nsAtts = temp;\n      version = 0; /* force re-initialization of m_nsAtts hash table */\n    }\n    /* using a version flag saves us from initializing m_nsAtts every time */\n    if (! version) { /* initialize version flags when version wraps around */\n      version = INIT_ATTS_VERSION;\n      for (j = nsAttsSize; j != 0;)\n        parser->m_nsAtts[--j].version = version;\n    }\n    parser->m_nsAttsVersion = --version;\n\n    /* expand prefixed names and check for duplicates */\n    for (; i < attIndex; i += 2) {\n      const XML_Char *s = appAtts[i];\n      if (s[-1] == 2) { /* prefixed */\n        ATTRIBUTE_ID *id;\n        const BINDING *b;\n        unsigned long uriHash;\n        struct siphash sip_state;\n        struct sipkey sip_key;\n\n        copy_salt_to_sipkey(parser, &sip_key);\n        sip24_init(&sip_state, &sip_key);\n\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n        id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, s, 0);\n        if (! id || ! id->prefix) {\n          /* This code is walking through the appAtts array, dealing\n           * with (in this case) a prefixed attribute name.  To be in\n           * the array, the attribute must have already been bound, so\n           * has to have passed through the hash table lookup once\n           * already.  That implies that an entry for it already\n           * exists, so the lookup above will return a pointer to\n           * already allocated memory.  There is no opportunaity for\n           * the allocator to fail, so the condition above cannot be\n           * fulfilled.\n           *\n           * Since it is difficult to be certain that the above\n           * analysis is complete, we retain the test and merely\n           * remove the code from coverage tests.\n           */\n          return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */\n        }\n        b = id->prefix->binding;\n        if (! b)\n          return XML_ERROR_UNBOUND_PREFIX;\n\n        for (j = 0; j < b->uriLen; j++) {\n          const XML_Char c = b->uri[j];\n          if (! poolAppendChar(&parser->m_tempPool, c))\n            return XML_ERROR_NO_MEMORY;\n        }\n\n        sip24_update(&sip_state, b->uri, b->uriLen * sizeof(XML_Char));\n\n        while (*s++ != XML_T(ASCII_COLON))\n          ;\n\n        sip24_update(&sip_state, s, keylen(s) * sizeof(XML_Char));\n\n        do { /* copies null terminator */\n          if (! poolAppendChar(&parser->m_tempPool, *s))\n            return XML_ERROR_NO_MEMORY;\n        } while (*s++);\n\n        uriHash = (unsigned long)sip24_final(&sip_state);\n\n        { /* Check hash table for duplicate of expanded name (uriName).\n             Derived from code in lookup(parser, HASH_TABLE *table, ...).\n          */\n          unsigned char step = 0;\n          unsigned long mask = nsAttsSize - 1;\n          j = uriHash & mask; /* index into hash table */\n          while (parser->m_nsAtts[j].version == version) {\n            /* for speed we compare stored hash values first */\n            if (uriHash == parser->m_nsAtts[j].hash) {\n              const XML_Char *s1 = poolStart(&parser->m_tempPool);\n              const XML_Char *s2 = parser->m_nsAtts[j].uriName;\n              /* s1 is null terminated, but not s2 */\n              for (; *s1 == *s2 && *s1 != 0; s1++, s2++)\n                ;\n              if (*s1 == 0)\n                return XML_ERROR_DUPLICATE_ATTRIBUTE;\n            }\n            if (! step)\n              step = PROBE_STEP(uriHash, mask, parser->m_nsAttsPower);\n            j < step ? (j += nsAttsSize - step) : (j -= step);\n          }\n        }\n\n        if (parser->m_ns_triplets) { /* append namespace separator and prefix */\n          parser->m_tempPool.ptr[-1] = parser->m_namespaceSeparator;\n          s = b->prefix->name;\n          do {\n            if (! poolAppendChar(&parser->m_tempPool, *s))\n              return XML_ERROR_NO_MEMORY;\n          } while (*s++);\n        }\n\n        /* store expanded name in attribute list */\n        s = poolStart(&parser->m_tempPool);\n        poolFinish(&parser->m_tempPool);\n        appAtts[i] = s;\n\n        /* fill empty slot with new version, uriName and hash value */\n        parser->m_nsAtts[j].version = version;\n        parser->m_nsAtts[j].hash = uriHash;\n        parser->m_nsAtts[j].uriName = s;\n\n        if (! --nPrefixes) {\n          i += 2;\n          break;\n        }\n      } else                     /* not prefixed */\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n    }\n  }\n  /* clear flags for the remaining attributes */\n  for (; i < attIndex; i += 2)\n    ((XML_Char *)(appAtts[i]))[-1] = 0;\n  for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)\n    binding->attId->name[-1] = 0;\n\n  if (! parser->m_ns)\n    return XML_ERROR_NONE;\n\n  /* expand the element type name */\n  if (elementType->prefix) {\n    binding = elementType->prefix->binding;\n    if (! binding)\n      return XML_ERROR_UNBOUND_PREFIX;\n    localPart = tagNamePtr->str;\n    while (*localPart++ != XML_T(ASCII_COLON))\n      ;\n  } else if (dtd->defaultPrefix.binding) {\n    binding = dtd->defaultPrefix.binding;\n    localPart = tagNamePtr->str;\n  } else\n    return XML_ERROR_NONE;\n  prefixLen = 0;\n  if (parser->m_ns_triplets && binding->prefix->name) {\n    for (; binding->prefix->name[prefixLen++];)\n      ; /* prefixLen includes null terminator */\n  }\n  tagNamePtr->localPart = localPart;\n  tagNamePtr->uriLen = binding->uriLen;\n  tagNamePtr->prefix = binding->prefix->name;\n  tagNamePtr->prefixLen = prefixLen;\n  for (i = 0; localPart[i++];)\n    ; /* i includes null terminator */\n  n = i + binding->uriLen + prefixLen;\n  if (n > binding->uriAlloc) {\n    TAG *p;\n    uri = (XML_Char *)MALLOC(parser, (n + EXPAND_SPARE) * sizeof(XML_Char));\n    if (! uri)\n      return XML_ERROR_NO_MEMORY;\n    binding->uriAlloc = n + EXPAND_SPARE;\n    memcpy(uri, binding->uri, binding->uriLen * sizeof(XML_Char));\n    for (p = parser->m_tagStack; p; p = p->parent)\n      if (p->name.str == binding->uri)\n        p->name.str = uri;\n    FREE(parser, binding->uri);\n    binding->uri = uri;\n  }\n  /* if m_namespaceSeparator != '\\0' then uri includes it already */\n  uri = binding->uri + binding->uriLen;\n  memcpy(uri, localPart, i * sizeof(XML_Char));\n  /* we always have a namespace separator between localPart and prefix */\n  if (prefixLen) {\n    uri += i - 1;\n    *uri = parser->m_namespaceSeparator; /* replace null terminator */\n    memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char));\n  }\n  tagNamePtr->str = binding->uri;\n  return XML_ERROR_NONE;\n}"", ""target"": 0}]","[{""func_name"": ""storeAtts"", ""file_path"": ""expat/lib/xmlparse.c"", ""func_code"": ""static enum XML_Error\nstoreAtts(XML_Parser parser, const ENCODING *enc, const char *attStr,\n          TAG_NAME *tagNamePtr, BINDING **bindingsPtr,\n          enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  ELEMENT_TYPE *elementType;\n  int nDefaultAtts;\n  const XML_Char **appAtts; /* the attribute list for the application */\n  int attIndex = 0;\n  int prefixLen;\n  int i;\n  int n;\n  XML_Char *uri;\n  int nPrefixes = 0;\n  BINDING *binding;\n  const XML_Char *localPart;\n\n  /* lookup the element type name */\n  elementType\n      = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, tagNamePtr->str, 0);\n  if (! elementType) {\n    const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str);\n    if (! name)\n      return XML_ERROR_NO_MEMORY;\n    elementType = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, name,\n                                         sizeof(ELEMENT_TYPE));\n    if (! elementType)\n      return XML_ERROR_NO_MEMORY;\n    if (parser->m_ns && ! setElementTypePrefix(parser, elementType))\n      return XML_ERROR_NO_MEMORY;\n  }\n  nDefaultAtts = elementType->nDefaultAtts;\n\n  /* get the attributes from the tokenizer */\n  n = XmlGetAttributes(enc, attStr, parser->m_attsSize, parser->m_atts);\n  if (n + nDefaultAtts > parser->m_attsSize) {\n    int oldAttsSize = parser->m_attsSize;\n    ATTRIBUTE *temp;\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *temp2;\n#endif\n    parser->m_attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;\n    temp = (ATTRIBUTE *)REALLOC(parser, (void *)parser->m_atts,\n                                parser->m_attsSize * sizeof(ATTRIBUTE));\n    if (temp == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_atts = temp;\n#ifdef XML_ATTR_INFO\n    temp2 = (XML_AttrInfo *)REALLOC(parser, (void *)parser->m_attInfo,\n                                    parser->m_attsSize * sizeof(XML_AttrInfo));\n    if (temp2 == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_attInfo = temp2;\n#endif\n    if (n > oldAttsSize)\n      XmlGetAttributes(enc, attStr, n, parser->m_atts);\n  }\n\n  appAtts = (const XML_Char **)parser->m_atts;\n  for (i = 0; i < n; i++) {\n    ATTRIBUTE *currAtt = &parser->m_atts[i];\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *currAttInfo = &parser->m_attInfo[i];\n#endif\n    /* add the name and value to the attribute list */\n    ATTRIBUTE_ID *attId\n        = getAttributeId(parser, enc, currAtt->name,\n                         currAtt->name + XmlNameLength(enc, currAtt->name));\n    if (! attId)\n      return XML_ERROR_NO_MEMORY;\n#ifdef XML_ATTR_INFO\n    currAttInfo->nameStart\n        = parser->m_parseEndByteIndex - (parser->m_parseEndPtr - currAtt->name);\n    currAttInfo->nameEnd\n        = currAttInfo->nameStart + XmlNameLength(enc, currAtt->name);\n    currAttInfo->valueStart = parser->m_parseEndByteIndex\n                              - (parser->m_parseEndPtr - currAtt->valuePtr);\n    currAttInfo->valueEnd = parser->m_parseEndByteIndex\n                            - (parser->m_parseEndPtr - currAtt->valueEnd);\n#endif\n    /* Detect duplicate attributes by their QNames. This does not work when\n       namespace processing is turned on and different prefixes for the same\n       namespace are used. For this case we have a check further down.\n    */\n    if ((attId->name)[-1]) {\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = parser->m_atts[i].name;\n      return XML_ERROR_DUPLICATE_ATTRIBUTE;\n    }\n    (attId->name)[-1] = 1;\n    appAtts[attIndex++] = attId->name;\n    if (! parser->m_atts[i].normalized) {\n      enum XML_Error result;\n      XML_Bool isCdata = XML_TRUE;\n\n      /* figure out whether declared as other than CDATA */\n      if (attId->maybeTokenized) {\n        int j;\n        for (j = 0; j < nDefaultAtts; j++) {\n          if (attId == elementType->defaultAtts[j].id) {\n            isCdata = elementType->defaultAtts[j].isCdata;\n            break;\n          }\n        }\n      }\n\n      /* normalize the attribute value */\n      result = storeAttributeValue(\n          parser, enc, isCdata, parser->m_atts[i].valuePtr,\n          parser->m_atts[i].valueEnd, &parser->m_tempPool, account);\n      if (result)\n        return result;\n      appAtts[attIndex] = poolStart(&parser->m_tempPool);\n      poolFinish(&parser->m_tempPool);\n    } else {\n      /* the value did not need normalizing */\n      appAtts[attIndex] = poolStoreString(&parser->m_tempPool, enc,\n                                          parser->m_atts[i].valuePtr,\n                                          parser->m_atts[i].valueEnd);\n      if (appAtts[attIndex] == 0)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n    }\n    /* handle prefixed attribute names */\n    if (attId->prefix) {\n      if (attId->xmlns) {\n        /* deal with namespace declarations here */\n        enum XML_Error result = addBinding(parser, attId->prefix, attId,\n                                           appAtts[attIndex], bindingsPtr);\n        if (result)\n          return result;\n        --attIndex;\n      } else {\n        /* deal with other prefixed names later */\n        attIndex++;\n        nPrefixes++;\n        (attId->name)[-1] = 2;\n      }\n    } else\n      attIndex++;\n  }\n\n  /* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */\n  parser->m_nSpecifiedAtts = attIndex;\n  if (elementType->idAtt && (elementType->idAtt->name)[-1]) {\n    for (i = 0; i < attIndex; i += 2)\n      if (appAtts[i] == elementType->idAtt->name) {\n        parser->m_idAttIndex = i;\n        break;\n      }\n  } else\n    parser->m_idAttIndex = -1;\n\n  /* do attribute defaulting */\n  for (i = 0; i < nDefaultAtts; i++) {\n    const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i;\n    if (! (da->id->name)[-1] && da->value) {\n      if (da->id->prefix) {\n        if (da->id->xmlns) {\n          enum XML_Error result = addBinding(parser, da->id->prefix, da->id,\n                                             da->value, bindingsPtr);\n          if (result)\n            return result;\n        } else {\n          (da->id->name)[-1] = 2;\n          nPrefixes++;\n          appAtts[attIndex++] = da->id->name;\n          appAtts[attIndex++] = da->value;\n        }\n      } else {\n        (da->id->name)[-1] = 1;\n        appAtts[attIndex++] = da->id->name;\n        appAtts[attIndex++] = da->value;\n      }\n    }\n  }\n  appAtts[attIndex] = 0;\n\n  /* expand prefixed attribute names, check for duplicates,\n     and clear flags that say whether attributes were specified */\n  i = 0;\n  if (nPrefixes) {\n    int j; /* hash table index */\n    unsigned long version = parser->m_nsAttsVersion;\n\n    /* Detect and prevent invalid shift */\n    if (parser->m_nsAttsPower >= sizeof(unsigned int) * 8 /* bits per byte */) {\n      return XML_ERROR_NO_MEMORY;\n    }\n\n    unsigned int nsAttsSize = 1u << parser->m_nsAttsPower;\n    unsigned char oldNsAttsPower = parser->m_nsAttsPower;\n    /* size of hash table must be at least 2 * (# of prefixed attributes) */\n    if ((nPrefixes << 1)\n        >> parser->m_nsAttsPower) { /* true for m_nsAttsPower = 0 */\n      NS_ATT *temp;\n      /* hash table size must also be a power of 2 and >= 8 */\n      while (nPrefixes >> parser->m_nsAttsPower++)\n        ;\n      if (parser->m_nsAttsPower < 3)\n        parser->m_nsAttsPower = 3;\n\n      /* Detect and prevent invalid shift */\n      if (parser->m_nsAttsPower >= sizeof(nsAttsSize) * 8 /* bits per byte */) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      nsAttsSize = 1u << parser->m_nsAttsPower;\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \""always false\"" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if (nsAttsSize > (size_t)(-1) / sizeof(NS_ATT)) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      temp = (NS_ATT *)REALLOC(parser, parser->m_nsAtts,\n                               nsAttsSize * sizeof(NS_ATT));\n      if (! temp) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n      parser->m_nsAtts = temp;\n      version = 0; /* force re-initialization of m_nsAtts hash table */\n    }\n    /* using a version flag saves us from initializing m_nsAtts every time */\n    if (! version) { /* initialize version flags when version wraps around */\n      version = INIT_ATTS_VERSION;\n      for (j = nsAttsSize; j != 0;)\n        parser->m_nsAtts[--j].version = version;\n    }\n    parser->m_nsAttsVersion = --version;\n\n    /* expand prefixed names and check for duplicates */\n    for (; i < attIndex; i += 2) {\n      const XML_Char *s = appAtts[i];\n      if (s[-1] == 2) { /* prefixed */\n        ATTRIBUTE_ID *id;\n        const BINDING *b;\n        unsigned long uriHash;\n        struct siphash sip_state;\n        struct sipkey sip_key;\n\n        copy_salt_to_sipkey(parser, &sip_key);\n        sip24_init(&sip_state, &sip_key);\n\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n        id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, s, 0);\n        if (! id || ! id->prefix) {\n          /* This code is walking through the appAtts array, dealing\n           * with (in this case) a prefixed attribute name.  To be in\n           * the array, the attribute must have already been bound, so\n           * has to have passed through the hash table lookup once\n           * already.  That implies that an entry for it already\n           * exists, so the lookup above will return a pointer to\n           * already allocated memory.  There is no opportunaity for\n           * the allocator to fail, so the condition above cannot be\n           * fulfilled.\n           *\n           * Since it is difficult to be certain that the above\n           * analysis is complete, we retain the test and merely\n           * remove the code from coverage tests.\n           */\n          return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */\n        }\n        b = id->prefix->binding;\n        if (! b)\n          return XML_ERROR_UNBOUND_PREFIX;\n\n        for (j = 0; j < b->uriLen; j++) {\n          const XML_Char c = b->uri[j];\n          if (! poolAppendChar(&parser->m_tempPool, c))\n            return XML_ERROR_NO_MEMORY;\n        }\n\n        sip24_update(&sip_state, b->uri, b->uriLen * sizeof(XML_Char));\n\n        while (*s++ != XML_T(ASCII_COLON))\n          ;\n\n        sip24_update(&sip_state, s, keylen(s) * sizeof(XML_Char));\n\n        do { /* copies null terminator */\n          if (! poolAppendChar(&parser->m_tempPool, *s))\n            return XML_ERROR_NO_MEMORY;\n        } while (*s++);\n\n        uriHash = (unsigned long)sip24_final(&sip_state);\n\n        { /* Check hash table for duplicate of expanded name (uriName).\n             Derived from code in lookup(parser, HASH_TABLE *table, ...).\n          */\n          unsigned char step = 0;\n          unsigned long mask = nsAttsSize - 1;\n          j = uriHash & mask; /* index into hash table */\n          while (parser->m_nsAtts[j].version == version) {\n            /* for speed we compare stored hash values first */\n            if (uriHash == parser->m_nsAtts[j].hash) {\n              const XML_Char *s1 = poolStart(&parser->m_tempPool);\n              const XML_Char *s2 = parser->m_nsAtts[j].uriName;\n              /* s1 is null terminated, but not s2 */\n              for (; *s1 == *s2 && *s1 != 0; s1++, s2++)\n                ;\n              if (*s1 == 0)\n                return XML_ERROR_DUPLICATE_ATTRIBUTE;\n            }\n            if (! step)\n              step = PROBE_STEP(uriHash, mask, parser->m_nsAttsPower);\n            j < step ? (j += nsAttsSize - step) : (j -= step);\n          }\n        }\n\n        if (parser->m_ns_triplets) { /* append namespace separator and prefix */\n          parser->m_tempPool.ptr[-1] = parser->m_namespaceSeparator;\n          s = b->prefix->name;\n          do {\n            if (! poolAppendChar(&parser->m_tempPool, *s))\n              return XML_ERROR_NO_MEMORY;\n          } while (*s++);\n        }\n\n        /* store expanded name in attribute list */\n        s = poolStart(&parser->m_tempPool);\n        poolFinish(&parser->m_tempPool);\n        appAtts[i] = s;\n\n        /* fill empty slot with new version, uriName and hash value */\n        parser->m_nsAtts[j].version = version;\n        parser->m_nsAtts[j].hash = uriHash;\n        parser->m_nsAtts[j].uriName = s;\n\n        if (! --nPrefixes) {\n          i += 2;\n          break;\n        }\n      } else                     /* not prefixed */\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n    }\n  }\n  /* clear flags for the remaining attributes */\n  for (; i < attIndex; i += 2)\n    ((XML_Char *)(appAtts[i]))[-1] = 0;\n  for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)\n    binding->attId->name[-1] = 0;\n\n  if (! parser->m_ns)\n    return XML_ERROR_NONE;\n\n  /* expand the element type name */\n  if (elementType->prefix) {\n    binding = elementType->prefix->binding;\n    if (! binding)\n      return XML_ERROR_UNBOUND_PREFIX;\n    localPart = tagNamePtr->str;\n    while (*localPart++ != XML_T(ASCII_COLON))\n      ;\n  } else if (dtd->defaultPrefix.binding) {\n    binding = dtd->defaultPrefix.binding;\n    localPart = tagNamePtr->str;\n  } else\n    return XML_ERROR_NONE;\n  prefixLen = 0;\n  if (parser->m_ns_triplets && binding->prefix->name) {\n    for (; binding->prefix->name[prefixLen++];)\n      ; /* prefixLen includes null terminator */\n  }\n  tagNamePtr->localPart = localPart;\n  tagNamePtr->uriLen = binding->uriLen;\n  tagNamePtr->prefix = binding->prefix->name;\n  tagNamePtr->prefixLen = prefixLen;\n  for (i = 0; localPart[i++];)\n    ; /* i includes null terminator */\n  n = i + binding->uriLen + prefixLen;\n  if (n > binding->uriAlloc) {\n    TAG *p;\n    uri = (XML_Char *)MALLOC(parser, (n + EXPAND_SPARE) * sizeof(XML_Char));\n    if (! uri)\n      return XML_ERROR_NO_MEMORY;\n    binding->uriAlloc = n + EXPAND_SPARE;\n    memcpy(uri, binding->uri, binding->uriLen * sizeof(XML_Char));\n    for (p = parser->m_tagStack; p; p = p->parent)\n      if (p->name.str == binding->uri)\n        p->name.str = uri;\n    FREE(parser, binding->uri);\n    binding->uri = uri;\n  }\n  /* if m_namespaceSeparator != '\\0' then uri includes it already */\n  uri = binding->uri + binding->uriLen;\n  memcpy(uri, localPart, i * sizeof(XML_Char));\n  /* we always have a namespace separator between localPart and prefix */\n  if (prefixLen) {\n    uri += i - 1;\n    *uri = parser->m_namespaceSeparator; /* replace null terminator */\n    memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char));\n  }\n  tagNamePtr->str = binding->uri;\n  return XML_ERROR_NONE;\n}""}]","{""value"": 1, ""caller"": 1}","[{""source"": ""value_info(file:xmlparse.c, value:parser->m_nsAttsPower)"", ""result"": {""value_trace"": [{""full_code"": ""parser->m_nsAttsPower = 0"", ""line"": 1060, ""func_name"": ""parserCreate""}, {""full_code"": ""parser->m_nsAttsPower++"", ""line"": 3424, ""func_name"": ""storeAtts""}, {""full_code"": ""parser->m_nsAttsPower = 3"", ""line"": 3427, ""func_name"": ""storeAtts""}, {""full_code"": ""parser->m_nsAttsPower = oldNsAttsPower"", ""line"": 3433, ""func_name"": ""storeAtts""}], ""struct_var"": ""parser"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:xmlparse.c, func:storeAtts)"", ""result"": [{""call_line"": 2941, ""call_code"": ""storeAtts(parser, enc, s, &(tag->name), &(tag->bindings), account)"", ""caller_code"": ""static enum XML_Error\ndoContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,\n          const char *s, const char *end, const char **nextPtr,\n          XML_Bool haveMore, enum XML_Account account) {\n  /* save one level of indirection */\n  DTD *const dtd = parser->m_dtd;\n\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n\n  for (;;) {\n    const char *next = s; /* XmlContentTok doesn't always set the last arg */\n    int tok = XmlContentTok(enc, s, end, &next);\n#ifdef XML_DTD\n    const char *accountAfter\n        = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n              ? (haveMore ? s /* i.e. 0 bytes */ : end)\n              : next;\n    if (! accountingDiffTolerated(parser, tok, s, accountAfter, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    *eventEndPP = next;\n    switch (tok) {\n    case XML_TOK_TRAILING_CR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      *eventEndPP = end;\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0)\n        return XML_ERROR_NO_ELEMENTS;\n      if (parser->m_tagLevel != startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (startTagLevel > 0) {\n        if (parser->m_tagLevel != startTagLevel)\n          return XML_ERROR_ASYNC_ENTITY;\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_NO_ELEMENTS;\n    case XML_TOK_INVALID:\n      *eventPP = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#ifdef XML_DTD\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* XML_DTD */\n        if (parser->m_characterDataHandler)\n          parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;\n      entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);\n      poolDiscard(&dtd->pool);\n      /* First, determine if a check for an existing declaration is needed;\n         if yes, check that the entity exists, and that it is internal,\n         otherwise call the skipped entity or default handler.\n      */\n      if (! dtd->hasParamEntityRefs || dtd->standalone) {\n        if (! entity)\n          return XML_ERROR_UNDEFINED_ENTITY;\n        else if (! entity->is_internal)\n          return XML_ERROR_ENTITY_DECLARED_IN_PE;\n      } else if (! entity) {\n        if (parser->m_skippedEntityHandler)\n          parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      if (entity->open)\n        return XML_ERROR_RECURSIVE_ENTITY_REF;\n      if (entity->notation)\n        return XML_ERROR_BINARY_ENTITY_REF;\n      if (entity->textPtr) {\n        enum XML_Error result;\n        if (! parser->m_defaultExpandInternalEntities) {\n          if (parser->m_skippedEntityHandler)\n            parser->m_skippedEntityHandler(parser->m_handlerArg, entity->name,\n                                           0);\n          else if (parser->m_defaultHandler)\n            reportDefault(parser, enc, s, next);\n          break;\n        }\n        result = processInternalEntity(parser, entity, XML_FALSE);\n        if (result != XML_ERROR_NONE)\n          return result;\n      } else if (parser->m_externalEntityRefHandler) {\n        const XML_Char *context;\n        entity->open = XML_TRUE;\n        context = getContext(parser);\n        entity->open = XML_FALSE;\n        if (! context)\n          return XML_ERROR_NO_MEMORY;\n        if (! parser->m_externalEntityRefHandler(\n                parser->m_externalEntityRefHandlerArg, context, entity->base,\n                entity->systemId, entity->publicId))\n          return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n        poolDiscard(&parser->m_tempPool);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    }\n    case XML_TOK_START_TAG_NO_ATTS:\n      /* fall through */\n    case XML_TOK_START_TAG_WITH_ATTS: {\n      TAG *tag;\n      enum XML_Error result;\n      XML_Char *toPtr;\n      if (parser->m_freeTagList) {\n        tag = parser->m_freeTagList;\n        parser->m_freeTagList = parser->m_freeTagList->parent;\n      } else {\n        tag = (TAG *)MALLOC(parser, sizeof(TAG));\n        if (! tag)\n          return XML_ERROR_NO_MEMORY;\n        tag->buf = (char *)MALLOC(parser, INIT_TAG_BUF_SIZE);\n        if (! tag->buf) {\n          FREE(parser, tag);\n          return XML_ERROR_NO_MEMORY;\n        }\n        tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;\n      }\n      tag->bindings = NULL;\n      tag->parent = parser->m_tagStack;\n      parser->m_tagStack = tag;\n      tag->name.localPart = NULL;\n      tag->name.prefix = NULL;\n      tag->rawName = s + enc->minBytesPerChar;\n      tag->rawNameLength = XmlNameLength(enc, tag->rawName);\n      ++parser->m_tagLevel;\n      {\n        const char *rawNameEnd = tag->rawName + tag->rawNameLength;\n        const char *fromPtr = tag->rawName;\n        toPtr = (XML_Char *)tag->buf;\n        for (;;) {\n          int bufSize;\n          int convLen;\n          const enum XML_Convert_Result convert_res\n              = XmlConvert(enc, &fromPtr, rawNameEnd, (ICHAR **)&toPtr,\n                           (ICHAR *)tag->bufEnd - 1);\n          convLen = (int)(toPtr - (XML_Char *)tag->buf);\n          if ((fromPtr >= rawNameEnd)\n              || (convert_res == XML_CONVERT_INPUT_INCOMPLETE)) {\n            tag->name.strLen = convLen;\n            break;\n          }\n          bufSize = (int)(tag->bufEnd - tag->buf) << 1;\n          {\n            char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n            if (temp == NULL)\n              return XML_ERROR_NO_MEMORY;\n            tag->buf = temp;\n            tag->bufEnd = temp + bufSize;\n            toPtr = (XML_Char *)temp + convLen;\n          }\n        }\n      }\n      tag->name.str = (XML_Char *)tag->buf;\n      *toPtr = XML_T('\\0');\n      result\n          = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings), account);\n      if (result)\n        return result;\n      if (parser->m_startElementHandler)\n        parser->m_startElementHandler(parser->m_handlerArg, tag->name.str,\n                                      (const XML_Char **)parser->m_atts);\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      break;\n    }\n    case XML_TOK_EMPTY_ELEMENT_NO_ATTS:\n      /* fall through */\n    case XML_TOK_EMPTY_ELEMENT_WITH_ATTS: {\n      const char *rawName = s + enc->minBytesPerChar;\n      enum XML_Error result;\n      BINDING *bindings = NULL;\n      XML_Bool noElmHandlers = XML_TRUE;\n      TAG_NAME name;\n      name.str = poolStoreString(&parser->m_tempPool, enc, rawName,\n                                 rawName + XmlNameLength(enc, rawName));\n      if (! name.str)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n      result = storeAtts(parser, enc, s, &name, &bindings,\n                         XML_ACCOUNT_NONE /* token spans whole start tag */);\n      if (result != XML_ERROR_NONE) {\n        freeBindings(parser, bindings);\n        return result;\n      }\n      poolFinish(&parser->m_tempPool);\n      if (parser->m_startElementHandler) {\n        parser->m_startElementHandler(parser->m_handlerArg, name.str,\n                                      (const XML_Char **)parser->m_atts);\n        noElmHandlers = XML_FALSE;\n      }\n      if (parser->m_endElementHandler) {\n        if (parser->m_startElementHandler)\n          *eventPP = *eventEndPP;\n        parser->m_endElementHandler(parser->m_handlerArg, name.str);\n        noElmHandlers = XML_FALSE;\n      }\n      if (noElmHandlers && parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      freeBindings(parser, bindings);\n    }\n      if ((parser->m_tagLevel == 0)\n          && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n        if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n          parser->m_processor = epilogProcessor;\n        else\n          return epilogProcessor(parser, next, end, nextPtr);\n      }\n      break;\n    case XML_TOK_END_TAG:\n      if (parser->m_tagLevel == startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      else {\n        int len;\n        const char *rawName;\n        TAG *tag = parser->m_tagStack;\n        parser->m_tagStack = tag->parent;\n        tag->parent = parser->m_freeTagList;\n        parser->m_freeTagList = tag;\n        rawName = s + enc->minBytesPerChar * 2;\n        len = XmlNameLength(enc, rawName);\n        if (len != tag->rawNameLength\n            || memcmp(tag->rawName, rawName, len) != 0) {\n          *eventPP = rawName;\n          return XML_ERROR_TAG_MISMATCH;\n        }\n        --parser->m_tagLevel;\n        if (parser->m_endElementHandler) {\n          const XML_Char *localPart;\n          const XML_Char *prefix;\n          XML_Char *uri;\n          localPart = tag->name.localPart;\n          if (parser->m_ns && localPart) {\n            /* localPart and prefix may have been overwritten in\n               tag->name.str, since this points to the binding->uri\n               buffer which gets re-used; so we have to add them again\n            */\n            uri = (XML_Char *)tag->name.str + tag->name.uriLen;\n            /* don't need to check for space - already done in storeAtts() */\n            while (*localPart)\n              *uri++ = *localPart++;\n            prefix = (XML_Char *)tag->name.prefix;\n            if (parser->m_ns_triplets && prefix) {\n              *uri++ = parser->m_namespaceSeparator;\n              while (*prefix)\n                *uri++ = *prefix++;\n            }\n            *uri = XML_T('\\0');\n          }\n          parser->m_endElementHandler(parser->m_handlerArg, tag->name.str);\n        } else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        while (tag->bindings) {\n          BINDING *b = tag->bindings;\n          if (parser->m_endNamespaceDeclHandler)\n            parser->m_endNamespaceDeclHandler(parser->m_handlerArg,\n                                              b->prefix->name);\n          tag->bindings = tag->bindings->nextTagBinding;\n          b->nextTagBinding = parser->m_freeBindingList;\n          parser->m_freeBindingList = b;\n          b->prefix->binding = b->prevPrefixBinding;\n        }\n        if ((parser->m_tagLevel == 0)\n            && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n          if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n            parser->m_processor = epilogProcessor;\n          else\n            return epilogProcessor(parser, next, end, nextPtr);\n        }\n      }\n      break;\n    case XML_TOK_CHAR_REF: {\n      int n = XmlCharRefNumber(enc, s);\n      if (n < 0)\n        return XML_ERROR_BAD_CHAR_REF;\n      if (parser->m_characterDataHandler) {\n        XML_Char buf[XML_ENCODE_MAX];\n        parser->m_characterDataHandler(parser->m_handlerArg, buf,\n                                       XmlEncode(n, (ICHAR *)buf));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_XML_DECL:\n      return XML_ERROR_MISPLACED_XML_PI;\n    case XML_TOK_DATA_NEWLINE:\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    case XML_TOK_CDATA_SECT_OPEN: {\n      enum XML_Error result;\n      if (parser->m_startCdataSectionHandler)\n        parser->m_startCdataSectionHandler(parser->m_handlerArg);\n      /* BEGIN disabled code */\n      /* Suppose you doing a transformation on a document that involves\n         changing only the character data.  You set up a defaultHandler\n         and a characterDataHandler.  The defaultHandler simply copies\n         characters through.  The characterDataHandler does the\n         transformation and writes the characters out escaping them as\n         necessary.  This case will fail to work if we leave out the\n         following two lines (because & and < inside CDATA sections will\n         be incorrectly escaped).\n\n         However, now we have a start/endCdataSectionHandler, so it seems\n         easier to let the user deal with this.\n      */\n      else if (0 && parser->m_characterDataHandler)\n        parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                                       0);\n      /* END disabled code */\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      result\n          = doCdataSection(parser, enc, &next, end, nextPtr, haveMore, account);\n      if (result != XML_ERROR_NONE)\n        return result;\n      else if (! next) {\n        parser->m_processor = cdataSectionProcessor;\n        return result;\n      }\n    } break;\n    case XML_TOK_TRAILING_RSQB:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (parser->m_characterDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n          XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, parser->m_dataBuf,\n              (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n        } else\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, (XML_Char *)s,\n              (int)((XML_Char *)end - (XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0) {\n        *eventPP = end;\n        return XML_ERROR_NO_ELEMENTS;\n      }\n      if (parser->m_tagLevel != startTagLevel) {\n        *eventPP = end;\n        return XML_ERROR_ASYNC_ENTITY;\n      }\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_DATA_CHARS: {\n      XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;\n      if (charDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          for (;;) {\n            ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n            const enum XML_Convert_Result convert_res = XmlConvert(\n                enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n            *eventEndPP = s;\n            charDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                            (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n            if ((convert_res == XML_CONVERT_COMPLETED)\n                || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n              break;\n            *eventPP = s;\n          }\n        } else\n          charDataHandler(parser->m_handlerArg, (XML_Char *)s,\n                          (int)((XML_Char *)next - (XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    default:\n      /* All of the tokens produced by XmlContentTok() have their own\n       * explicit cases, so this default is not strictly necessary.\n       * However it is a useful safety net, so we retain the code and\n       * simply exclude it from the coverage tests.\n       *\n       * LCOV_EXCL_START\n       */\n      if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n      /* LCOV_EXCL_STOP */\n    }\n    *eventPP = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n  /* not reached */\n}\n"", ""caller_start"": 2727, ""file_path"": ""expat/lib/xmlparse.c""}, {""call_line"": 2965, ""call_code"": ""storeAtts(parser, enc, s, &name, &bindings,\n                         XML_ACCOUNT_NONE /* token spans whole start tag */)"", ""caller_code"": ""static enum XML_Error\ndoContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,\n          const char *s, const char *end, const char **nextPtr,\n          XML_Bool haveMore, enum XML_Account account) {\n  /* save one level of indirection */\n  DTD *const dtd = parser->m_dtd;\n\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n\n  for (;;) {\n    const char *next = s; /* XmlContentTok doesn't always set the last arg */\n    int tok = XmlContentTok(enc, s, end, &next);\n#ifdef XML_DTD\n    const char *accountAfter\n        = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n              ? (haveMore ? s /* i.e. 0 bytes */ : end)\n              : next;\n    if (! accountingDiffTolerated(parser, tok, s, accountAfter, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    *eventEndPP = next;\n    switch (tok) {\n    case XML_TOK_TRAILING_CR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      *eventEndPP = end;\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0)\n        return XML_ERROR_NO_ELEMENTS;\n      if (parser->m_tagLevel != startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (startTagLevel > 0) {\n        if (parser->m_tagLevel != startTagLevel)\n          return XML_ERROR_ASYNC_ENTITY;\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_NO_ELEMENTS;\n    case XML_TOK_INVALID:\n      *eventPP = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#ifdef XML_DTD\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* XML_DTD */\n        if (parser->m_characterDataHandler)\n          parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;\n      entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);\n      poolDiscard(&dtd->pool);\n      /* First, determine if a check for an existing declaration is needed;\n         if yes, check that the entity exists, and that it is internal,\n         otherwise call the skipped entity or default handler.\n      */\n      if (! dtd->hasParamEntityRefs || dtd->standalone) {\n        if (! entity)\n          return XML_ERROR_UNDEFINED_ENTITY;\n        else if (! entity->is_internal)\n          return XML_ERROR_ENTITY_DECLARED_IN_PE;\n      } else if (! entity) {\n        if (parser->m_skippedEntityHandler)\n          parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      if (entity->open)\n        return XML_ERROR_RECURSIVE_ENTITY_REF;\n      if (entity->notation)\n        return XML_ERROR_BINARY_ENTITY_REF;\n      if (entity->textPtr) {\n        enum XML_Error result;\n        if (! parser->m_defaultExpandInternalEntities) {\n          if (parser->m_skippedEntityHandler)\n            parser->m_skippedEntityHandler(parser->m_handlerArg, entity->name,\n                                           0);\n          else if (parser->m_defaultHandler)\n            reportDefault(parser, enc, s, next);\n          break;\n        }\n        result = processInternalEntity(parser, entity, XML_FALSE);\n        if (result != XML_ERROR_NONE)\n          return result;\n      } else if (parser->m_externalEntityRefHandler) {\n        const XML_Char *context;\n        entity->open = XML_TRUE;\n        context = getContext(parser);\n        entity->open = XML_FALSE;\n        if (! context)\n          return XML_ERROR_NO_MEMORY;\n        if (! parser->m_externalEntityRefHandler(\n                parser->m_externalEntityRefHandlerArg, context, entity->base,\n                entity->systemId, entity->publicId))\n          return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n        poolDiscard(&parser->m_tempPool);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    }\n    case XML_TOK_START_TAG_NO_ATTS:\n      /* fall through */\n    case XML_TOK_START_TAG_WITH_ATTS: {\n      TAG *tag;\n      enum XML_Error result;\n      XML_Char *toPtr;\n      if (parser->m_freeTagList) {\n        tag = parser->m_freeTagList;\n        parser->m_freeTagList = parser->m_freeTagList->parent;\n      } else {\n        tag = (TAG *)MALLOC(parser, sizeof(TAG));\n        if (! tag)\n          return XML_ERROR_NO_MEMORY;\n        tag->buf = (char *)MALLOC(parser, INIT_TAG_BUF_SIZE);\n        if (! tag->buf) {\n          FREE(parser, tag);\n          return XML_ERROR_NO_MEMORY;\n        }\n        tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;\n      }\n      tag->bindings = NULL;\n      tag->parent = parser->m_tagStack;\n      parser->m_tagStack = tag;\n      tag->name.localPart = NULL;\n      tag->name.prefix = NULL;\n      tag->rawName = s + enc->minBytesPerChar;\n      tag->rawNameLength = XmlNameLength(enc, tag->rawName);\n      ++parser->m_tagLevel;\n      {\n        const char *rawNameEnd = tag->rawName + tag->rawNameLength;\n        const char *fromPtr = tag->rawName;\n        toPtr = (XML_Char *)tag->buf;\n        for (;;) {\n          int bufSize;\n          int convLen;\n          const enum XML_Convert_Result convert_res\n              = XmlConvert(enc, &fromPtr, rawNameEnd, (ICHAR **)&toPtr,\n                           (ICHAR *)tag->bufEnd - 1);\n          convLen = (int)(toPtr - (XML_Char *)tag->buf);\n          if ((fromPtr >= rawNameEnd)\n              || (convert_res == XML_CONVERT_INPUT_INCOMPLETE)) {\n            tag->name.strLen = convLen;\n            break;\n          }\n          bufSize = (int)(tag->bufEnd - tag->buf) << 1;\n          {\n            char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n            if (temp == NULL)\n              return XML_ERROR_NO_MEMORY;\n            tag->buf = temp;\n            tag->bufEnd = temp + bufSize;\n            toPtr = (XML_Char *)temp + convLen;\n          }\n        }\n      }\n      tag->name.str = (XML_Char *)tag->buf;\n      *toPtr = XML_T('\\0');\n      result\n          = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings), account);\n      if (result)\n        return result;\n      if (parser->m_startElementHandler)\n        parser->m_startElementHandler(parser->m_handlerArg, tag->name.str,\n                                      (const XML_Char **)parser->m_atts);\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      break;\n    }\n    case XML_TOK_EMPTY_ELEMENT_NO_ATTS:\n      /* fall through */\n    case XML_TOK_EMPTY_ELEMENT_WITH_ATTS: {\n      const char *rawName = s + enc->minBytesPerChar;\n      enum XML_Error result;\n      BINDING *bindings = NULL;\n      XML_Bool noElmHandlers = XML_TRUE;\n      TAG_NAME name;\n      name.str = poolStoreString(&parser->m_tempPool, enc, rawName,\n                                 rawName + XmlNameLength(enc, rawName));\n      if (! name.str)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n      result = storeAtts(parser, enc, s, &name, &bindings,\n                         XML_ACCOUNT_NONE /* token spans whole start tag */);\n      if (result != XML_ERROR_NONE) {\n        freeBindings(parser, bindings);\n        return result;\n      }\n      poolFinish(&parser->m_tempPool);\n      if (parser->m_startElementHandler) {\n        parser->m_startElementHandler(parser->m_handlerArg, name.str,\n                                      (const XML_Char **)parser->m_atts);\n        noElmHandlers = XML_FALSE;\n      }\n      if (parser->m_endElementHandler) {\n        if (parser->m_startElementHandler)\n          *eventPP = *eventEndPP;\n        parser->m_endElementHandler(parser->m_handlerArg, name.str);\n        noElmHandlers = XML_FALSE;\n      }\n      if (noElmHandlers && parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      freeBindings(parser, bindings);\n    }\n      if ((parser->m_tagLevel == 0)\n          && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n        if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n          parser->m_processor = epilogProcessor;\n        else\n          return epilogProcessor(parser, next, end, nextPtr);\n      }\n      break;\n    case XML_TOK_END_TAG:\n      if (parser->m_tagLevel == startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      else {\n        int len;\n        const char *rawName;\n        TAG *tag = parser->m_tagStack;\n        parser->m_tagStack = tag->parent;\n        tag->parent = parser->m_freeTagList;\n        parser->m_freeTagList = tag;\n        rawName = s + enc->minBytesPerChar * 2;\n        len = XmlNameLength(enc, rawName);\n        if (len != tag->rawNameLength\n            || memcmp(tag->rawName, rawName, len) != 0) {\n          *eventPP = rawName;\n          return XML_ERROR_TAG_MISMATCH;\n        }\n        --parser->m_tagLevel;\n        if (parser->m_endElementHandler) {\n          const XML_Char *localPart;\n          const XML_Char *prefix;\n          XML_Char *uri;\n          localPart = tag->name.localPart;\n          if (parser->m_ns && localPart) {\n            /* localPart and prefix may have been overwritten in\n               tag->name.str, since this points to the binding->uri\n               buffer which gets re-used; so we have to add them again\n            */\n            uri = (XML_Char *)tag->name.str + tag->name.uriLen;\n            /* don't need to check for space - already done in storeAtts() */\n            while (*localPart)\n              *uri++ = *localPart++;\n            prefix = (XML_Char *)tag->name.prefix;\n            if (parser->m_ns_triplets && prefix) {\n              *uri++ = parser->m_namespaceSeparator;\n              while (*prefix)\n                *uri++ = *prefix++;\n            }\n            *uri = XML_T('\\0');\n          }\n          parser->m_endElementHandler(parser->m_handlerArg, tag->name.str);\n        } else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        while (tag->bindings) {\n          BINDING *b = tag->bindings;\n          if (parser->m_endNamespaceDeclHandler)\n            parser->m_endNamespaceDeclHandler(parser->m_handlerArg,\n                                              b->prefix->name);\n          tag->bindings = tag->bindings->nextTagBinding;\n          b->nextTagBinding = parser->m_freeBindingList;\n          parser->m_freeBindingList = b;\n          b->prefix->binding = b->prevPrefixBinding;\n        }\n        if ((parser->m_tagLevel == 0)\n            && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n          if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n            parser->m_processor = epilogProcessor;\n          else\n            return epilogProcessor(parser, next, end, nextPtr);\n        }\n      }\n      break;\n    case XML_TOK_CHAR_REF: {\n      int n = XmlCharRefNumber(enc, s);\n      if (n < 0)\n        return XML_ERROR_BAD_CHAR_REF;\n      if (parser->m_characterDataHandler) {\n        XML_Char buf[XML_ENCODE_MAX];\n        parser->m_characterDataHandler(parser->m_handlerArg, buf,\n                                       XmlEncode(n, (ICHAR *)buf));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_XML_DECL:\n      return XML_ERROR_MISPLACED_XML_PI;\n    case XML_TOK_DATA_NEWLINE:\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    case XML_TOK_CDATA_SECT_OPEN: {\n      enum XML_Error result;\n      if (parser->m_startCdataSectionHandler)\n        parser->m_startCdataSectionHandler(parser->m_handlerArg);\n      /* BEGIN disabled code */\n      /* Suppose you doing a transformation on a document that involves\n         changing only the character data.  You set up a defaultHandler\n         and a characterDataHandler.  The defaultHandler simply copies\n         characters through.  The characterDataHandler does the\n         transformation and writes the characters out escaping them as\n         necessary.  This case will fail to work if we leave out the\n         following two lines (because & and < inside CDATA sections will\n         be incorrectly escaped).\n\n         However, now we have a start/endCdataSectionHandler, so it seems\n         easier to let the user deal with this.\n      */\n      else if (0 && parser->m_characterDataHandler)\n        parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                                       0);\n      /* END disabled code */\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      result\n          = doCdataSection(parser, enc, &next, end, nextPtr, haveMore, account);\n      if (result != XML_ERROR_NONE)\n        return result;\n      else if (! next) {\n        parser->m_processor = cdataSectionProcessor;\n        return result;\n      }\n    } break;\n    case XML_TOK_TRAILING_RSQB:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (parser->m_characterDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n          XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, parser->m_dataBuf,\n              (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n        } else\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, (XML_Char *)s,\n              (int)((XML_Char *)end - (XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0) {\n        *eventPP = end;\n        return XML_ERROR_NO_ELEMENTS;\n      }\n      if (parser->m_tagLevel != startTagLevel) {\n        *eventPP = end;\n        return XML_ERROR_ASYNC_ENTITY;\n      }\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_DATA_CHARS: {\n      XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;\n      if (charDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          for (;;) {\n            ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n            const enum XML_Convert_Result convert_res = XmlConvert(\n                enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n            *eventEndPP = s;\n            charDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                            (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n            if ((convert_res == XML_CONVERT_COMPLETED)\n                || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n              break;\n            *eventPP = s;\n          }\n        } else\n          charDataHandler(parser->m_handlerArg, (XML_Char *)s,\n                          (int)((XML_Char *)next - (XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    default:\n      /* All of the tokens produced by XmlContentTok() have their own\n       * explicit cases, so this default is not strictly necessary.\n       * However it is a useful safety net, so we retain the code and\n       * simply exclude it from the coverage tests.\n       *\n       * LCOV_EXCL_START\n       */\n      if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n      /* LCOV_EXCL_STOP */\n    }\n    *eventPP = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n  /* not reached */\n}\n"", ""caller_start"": 2727, ""file_path"": ""expat/lib/xmlparse.c""}]}]","xmlparse.c:3415-3432: Left shift (1u << parser->m_nsAttsPower) in storeAtts could overflow if m_nsAttsPower  32 (on 32-bit systems). Patch adds bounds checks. m_nsAttsPower is initialized to 0 in parserCreate (xmlparse.c:1060) and incremented in storeAtts (xmlparse.c:3424/3427). When realloc is called with overflowed nsAttsSize, incorrect memory allocation occurs.",0.95,./github/other_context/CVE-2021-45960
34,CVE-2022-25314,CWE-190,c_cpp,"In Expat (aka libexpat) before 2.4.5, there is an integer overflow in copyString.",https://github.com/libexpat/libexpat/commit/efcb347440ade24b9f1054671e6bd05e60b4cafd,Prevent integer overflow in copyString\n\nThe copyString function is only used for encoding string supplied by\nthe library user.,1,"[{""func_name"": ""copyString"", ""file_path"": ""expat/lib/xmlparse.c"", ""func_code"": ""static XML_Char *\ncopyString(const XML_Char *s, const XML_Memory_Handling_Suite *memsuite) {\n  int charsRequired = 0;\n  XML_Char *result;\n\n  /* First determine how long the string is */\n  while (s[charsRequired] != 0) {\n    charsRequired++;\n  }\n  /* Include the terminator */\n  charsRequired++;\n\n  /* Now allocate space for the copy */\n  result = memsuite->malloc_fcn(charsRequired * sizeof(XML_Char));\n  if (result == NULL)\n    return NULL;\n  /* Copy the original into place */\n  memcpy(result, s, charsRequired * sizeof(XML_Char));\n  return result;\n}"", ""target"": 0}]","[{""func_name"": ""copyString"", ""file_path"": ""expat/lib/xmlparse.c"", ""func_code"": ""static XML_Char *\ncopyString(const XML_Char *s, const XML_Memory_Handling_Suite *memsuite) {\n  size_t charsRequired = 0;\n  XML_Char *result;\n\n  /* First determine how long the string is */\n  while (s[charsRequired] != 0) {\n    charsRequired++;\n  }\n  /* Include the terminator */\n  charsRequired++;\n\n  /* Now allocate space for the copy */\n  result = memsuite->malloc_fcn(charsRequired * sizeof(XML_Char));\n  if (result == NULL)\n    return NULL;\n  /* Copy the original into place */\n  memcpy(result, s, charsRequired * sizeof(XML_Char));\n  return result;\n}""}]","{""code"": 1, ""value"": 1}","[{""source"": ""code_info(file:xmlparse.c, lines:7414-7425)"", ""result"": ""copyString(const XML_Char *s, const XML_Memory_Handling_Suite *memsuite) {\n  int charsRequired = 0;\n  XML_Char *result;\n\n  /* First determine how long the string is */\n  while (s[charsRequired] != 0) {\n    charsRequired++;\n  }\n  /* Include the terminator */\n  charsRequired++;\n\n  /* Now allocate space for the copy */\n  result = memsuite->malloc_fcn(charsRequired * sizeof(XML_Char));\n""}, {""source"": ""value_info(file:xmlparse.c, value:charsRequired)"", ""result"": {""value_trace"": [{""full_code"": ""charsRequired = 0"", ""line"": 7415, ""func_name"": ""copyString""}, {""full_code"": ""charsRequired++"", ""line"": 7420, ""func_name"": ""copyString""}, {""full_code"": ""charsRequired++"", ""line"": 7423, ""func_name"": ""copyString""}], ""struct_var"": ""charsRequired"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}]","expat/lib/xmlparse.c:7414-7425: 'charsRequired' was declared as 'int', leading to integer overflow during string length calculation. The loop increments `charsRequired` to count characters and the null terminator. The overflow results in an incorrect value passed to `malloc_fcn`, causing insufficient memory allocation. The patch changes 'charsRequired' to 'size_t' to prevent overflow.",0.95,./github/other_context/CVE-2022-25314
35,CVE-2022-35977,CWE-190,c_cpp,"Redis is an in-memory database that persists on disk. Authenticated users issuing specially crafted `SETRANGE` and `SORT(_RO)` commands can trigger an integer overflow, resulting with Redis attempting to allocate impossible amounts of memory and abort with an out-of-memory (OOM) panic. The problem is fixed in Redis versions 7.0.8, 6.2.9 and 6.0.17. Users are advised to upgrade. There are no known workarounds for this vulnerability.",https://github.com/redis/redis/commit/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7,"Avoid integer overflows in SETRANGE and SORT (CVE-2022-35977) (#11720)\n\nAuthenticated users issuing specially crafted SETRANGE and SORT(_RO)\r\ncommands can trigger an integer overflow, resulting with Redis attempting\r\nto allocate impossible amounts of memory and abort with an OOM panic.",4,"[{""func_name"": ""appendCommand"", ""file_path"": ""src/t_string.c"", ""func_code"": ""void appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* \""append\"" is an argument, so always an sds */\n        append = c->argv[2];\n        totlen = stringObjectLen(o)+sdslen(append->ptr);\n        if (checkStringLength(c,totlen) != C_OK)\n            return;\n\n        /* Append the value */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\""append\"",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}"", ""target"": 0}, {""func_name"": ""setrangeCommand"", ""file_path"": ""src/t_string.c"", ""func_code"": ""void setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n\n    if (offset < 0) {\n        addReplyError(c,\""offset is out of range\"");\n        return;\n    }\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Return 0 when setting nothing on a non-existing string */\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* Return existing string length when setting nothing */\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n\n        /* Create a copy when the object is shared or encoded. */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \""setrange\"",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}"", ""target"": 0}, {""func_name"": ""checkStringLength"", ""file_path"": ""src/t_string.c"", ""func_code"": ""static int checkStringLength(client *c, long long size) {\n    if (!mustObeyClient(c) && size > server.proto_max_bulk_len) {\n        addReplyError(c,\""string exceeds maximum allowed size (proto-max-bulk-len)\"");\n        return C_ERR;\n    }\n    return C_OK;\n}"", ""target"": 0}, {""func_name"": ""sortCommandGeneric"", ""file_path"": ""src/sort.c"", ""func_code"": ""void sortCommandGeneric(client *c, int readonly) {\n    list *operations;\n    unsigned int outputlen = 0;\n    int desc = 0, alpha = 0;\n    long limit_start = 0, limit_count = -1, start, end;\n    int j, dontsort = 0, vectorlen;\n    int getop = 0; /* GET operation counter */\n    int int_conversion_error = 0;\n    int syntax_error = 0;\n    robj *sortval, *sortby = NULL, *storekey = NULL;\n    redisSortObject *vector; /* Resulting vector to sort */\n    int user_has_full_key_access = 0; /* ACL - used in order to verify 'get' and 'by' options can be used */\n    /* Create a list of operations to perform for every sorted element.\n     * Operations can be GET */\n    operations = listCreate();\n    listSetFreeMethod(operations,zfree);\n    j = 2; /* options start at argv[2] */\n\n    user_has_full_key_access = ACLUserCheckCmdWithUnrestrictedKeyAccess(c->user, c->cmd, c->argv, c->argc, CMD_KEY_ACCESS);\n\n    /* The SORT command has an SQL-alike syntax, parse it */\n    while(j < c->argc) {\n        int leftargs = c->argc-j-1;\n        if (!strcasecmp(c->argv[j]->ptr,\""asc\"")) {\n            desc = 0;\n        } else if (!strcasecmp(c->argv[j]->ptr,\""desc\"")) {\n            desc = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\""alpha\"")) {\n            alpha = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\""limit\"") && leftargs >= 2) {\n            if ((getLongFromObjectOrReply(c, c->argv[j+1], &limit_start, NULL)\n                 != C_OK) ||\n                (getLongFromObjectOrReply(c, c->argv[j+2], &limit_count, NULL)\n                 != C_OK))\n            {\n                syntax_error++;\n                break;\n            }\n            j+=2;\n        } else if (readonly == 0 && !strcasecmp(c->argv[j]->ptr,\""store\"") && leftargs >= 1) {\n            storekey = c->argv[j+1];\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\""by\"") && leftargs >= 1) {\n            sortby = c->argv[j+1];\n            /* If the BY pattern does not contain '*', i.e. it is constant,\n             * we don't need to sort nor to lookup the weight keys. */\n            if (strchr(c->argv[j+1]->ptr,'*') == NULL) {\n                dontsort = 1;\n            } else {\n                /* If BY is specified with a real pattern, we can't accept\n                 * it in cluster mode. */\n                if (server.cluster_enabled) {\n                    addReplyError(c,\""BY option of SORT denied in Cluster mode.\"");\n                    syntax_error++;\n                    break;\n                }\n                /* If BY is specified with a real pattern, we can't accept\n                 * it if no full ACL key access is applied for this command. */\n                if (!user_has_full_key_access) {\n                    addReplyError(c,\""BY option of SORT denied due to insufficient ACL permissions.\"");\n                    syntax_error++;\n                    break;\n                }\n            }\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\""get\"") && leftargs >= 1) {\n            if (server.cluster_enabled) {\n                addReplyError(c,\""GET option of SORT denied in Cluster mode.\"");\n                syntax_error++;\n                break;\n            }\n            if (!user_has_full_key_access) {\n                addReplyError(c,\""GET option of SORT denied due to insufficient ACL permissions.\"");\n                syntax_error++;\n                break;\n            }\n            listAddNodeTail(operations,createSortOperation(\n                SORT_OP_GET,c->argv[j+1]));\n            getop++;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            syntax_error++;\n            break;\n        }\n        j++;\n    }\n\n    /* Handle syntax errors set during options parsing. */\n    if (syntax_error) {\n        listRelease(operations);\n        return;\n    }\n\n    /* Lookup the key to sort. It must be of the right types */\n    sortval = lookupKeyRead(c->db, c->argv[1]);\n    if (sortval && sortval->type != OBJ_SET &&\n                   sortval->type != OBJ_LIST &&\n                   sortval->type != OBJ_ZSET)\n    {\n        listRelease(operations);\n        addReplyErrorObject(c,shared.wrongtypeerr);\n        return;\n    }\n\n    /* Now we need to protect sortval incrementing its count, in the future\n     * SORT may have options able to overwrite/delete keys during the sorting\n     * and the sorted key itself may get destroyed */\n    if (sortval)\n        incrRefCount(sortval);\n    else\n        sortval = createQuicklistObject();\n\n\n    /* When sorting a set with no sort specified, we must sort the output\n     * so the result is consistent across scripting and replication.\n     *\n     * The other types (list, sorted set) will retain their native order\n     * even if no sort order is requested, so they remain stable across\n     * scripting and replication. */\n    if (dontsort &&\n        sortval->type == OBJ_SET &&\n        (storekey || c->flags & CLIENT_SCRIPT))\n    {\n        /* Force ALPHA sorting */\n        dontsort = 0;\n        alpha = 1;\n        sortby = NULL;\n    }\n\n    /* Destructively convert encoded sorted sets for SORT. */\n    if (sortval->type == OBJ_ZSET)\n        zsetConvert(sortval, OBJ_ENCODING_SKIPLIST);\n\n    /* Obtain the length of the object to sort. */\n    switch(sortval->type) {\n    case OBJ_LIST: vectorlen = listTypeLength(sortval); break;\n    case OBJ_SET: vectorlen =  setTypeSize(sortval); break;\n    case OBJ_ZSET: vectorlen = dictSize(((zset*)sortval->ptr)->dict); break;\n    default: vectorlen = 0; serverPanic(\""Bad SORT type\""); /* Avoid GCC warning */\n    }\n\n    /* Perform LIMIT start,count sanity checking. */\n    start = (limit_start < 0) ? 0 : limit_start;\n    end = (limit_count < 0) ? vectorlen-1 : start+limit_count-1;\n    if (start >= vectorlen) {\n        start = vectorlen-1;\n        end = vectorlen-2;\n    }\n    if (end >= vectorlen) end = vectorlen-1;\n\n    /* Whenever possible, we load elements into the output array in a more\n     * direct way. This is possible if:\n     *\n     * 1) The object to sort is a sorted set or a list (internally sorted).\n     * 2) There is nothing to sort as dontsort is true (BY <constant string>).\n     *\n     * In this special case, if we have a LIMIT option that actually reduces\n     * the number of elements to fetch, we also optimize to just load the\n     * range we are interested in and allocating a vector that is big enough\n     * for the selected range length. */\n    if ((sortval->type == OBJ_ZSET || sortval->type == OBJ_LIST) &&\n        dontsort &&\n        (start != 0 || end != vectorlen-1))\n    {\n        vectorlen = end-start+1;\n    }\n\n    /* Load the sorting vector with all the objects to sort */\n    vector = zmalloc(sizeof(redisSortObject)*vectorlen);\n    j = 0;\n\n    if (sortval->type == OBJ_LIST && dontsort) {\n        /* Special handling for a list, if 'dontsort' is true.\n         * This makes sure we return elements in the list original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n        if (end >= start) {\n            listTypeIterator *li;\n            listTypeEntry entry;\n            li = listTypeInitIterator(sortval,\n                    desc ? (long)(listTypeLength(sortval) - start - 1) : start,\n                    desc ? LIST_HEAD : LIST_TAIL);\n\n            while(j < vectorlen && listTypeNext(li,&entry)) {\n                vector[j].obj = listTypeGet(&entry);\n                vector[j].u.score = 0;\n                vector[j].u.cmpobj = NULL;\n                j++;\n            }\n            listTypeReleaseIterator(li);\n            /* Fix start/end: output code is not aware of this optimization. */\n            end -= start;\n            start = 0;\n        }\n    } else if (sortval->type == OBJ_LIST) {\n        listTypeIterator *li = listTypeInitIterator(sortval,0,LIST_TAIL);\n        listTypeEntry entry;\n        while(listTypeNext(li,&entry)) {\n            vector[j].obj = listTypeGet(&entry);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        listTypeReleaseIterator(li);\n    } else if (sortval->type == OBJ_SET) {\n        setTypeIterator *si = setTypeInitIterator(sortval);\n        sds sdsele;\n        while((sdsele = setTypeNextObject(si)) != NULL) {\n            vector[j].obj = createObject(OBJ_STRING,sdsele);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        setTypeReleaseIterator(si);\n    } else if (sortval->type == OBJ_ZSET && dontsort) {\n        /* Special handling for a sorted set, if 'dontsort' is true.\n         * This makes sure we return elements in the sorted set original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n\n        zset *zs = sortval->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n        sds sdsele;\n        int rangelen = vectorlen;\n\n        /* Check if starting point is trivial, before doing log(N) lookup. */\n        if (desc) {\n            long zsetlen = dictSize(((zset*)sortval->ptr)->dict);\n\n            ln = zsl->tail;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,zsetlen-start);\n        } else {\n            ln = zsl->header->level[0].forward;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,start+1);\n        }\n\n        while(rangelen--) {\n            serverAssertWithInfo(c,sortval,ln != NULL);\n            sdsele = ln->ele;\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n            ln = desc ? ln->backward : ln->level[0].forward;\n        }\n        /* Fix start/end: output code is not aware of this optimization. */\n        end -= start;\n        start = 0;\n    } else if (sortval->type == OBJ_ZSET) {\n        dict *set = ((zset*)sortval->ptr)->dict;\n        dictIterator *di;\n        dictEntry *setele;\n        sds sdsele;\n        di = dictGetIterator(set);\n        while((setele = dictNext(di)) != NULL) {\n            sdsele =  dictGetKey(setele);\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        dictReleaseIterator(di);\n    } else {\n        serverPanic(\""Unknown type\"");\n    }\n    serverAssertWithInfo(c,sortval,j == vectorlen);\n\n    /* Now it's time to load the right scores in the sorting vector */\n    if (!dontsort) {\n        for (j = 0; j < vectorlen; j++) {\n            robj *byval;\n            if (sortby) {\n                /* lookup value to sort by */\n                byval = lookupKeyByPattern(c->db,sortby,vector[j].obj);\n                if (!byval) continue;\n            } else {\n                /* use object itself to sort by */\n                byval = vector[j].obj;\n            }\n\n            if (alpha) {\n                if (sortby) vector[j].u.cmpobj = getDecodedObject(byval);\n            } else {\n                if (sdsEncodedObject(byval)) {\n                    char *eptr;\n\n                    vector[j].u.score = strtod(byval->ptr,&eptr);\n                    if (eptr[0] != '\\0' || errno == ERANGE ||\n                        isnan(vector[j].u.score))\n                    {\n                        int_conversion_error = 1;\n                    }\n                } else if (byval->encoding == OBJ_ENCODING_INT) {\n                    /* Don't need to decode the object if it's\n                     * integer-encoded (the only encoding supported) so\n                     * far. We can just cast it */\n                    vector[j].u.score = (long)byval->ptr;\n                } else {\n                    serverAssertWithInfo(c,sortval,1 != 1);\n                }\n            }\n\n            /* when the object was retrieved using lookupKeyByPattern,\n             * its refcount needs to be decreased. */\n            if (sortby) {\n                decrRefCount(byval);\n            }\n        }\n\n        server.sort_desc = desc;\n        server.sort_alpha = alpha;\n        server.sort_bypattern = sortby ? 1 : 0;\n        server.sort_store = storekey ? 1 : 0;\n        if (sortby && (start != 0 || end != vectorlen-1))\n            pqsort(vector,vectorlen,sizeof(redisSortObject),sortCompare, start,end);\n        else\n            qsort(vector,vectorlen,sizeof(redisSortObject),sortCompare);\n    }\n\n    /* Send command output to the output buffer, performing the specified\n     * GET/DEL/INCR/DECR operations if any. */\n    outputlen = getop ? getop*(end-start+1) : end-start+1;\n    if (int_conversion_error) {\n        addReplyError(c,\""One or more scores can't be converted into double\"");\n    } else if (storekey == NULL) {\n        /* STORE option not specified, sent the sorting result to client */\n        addReplyArrayLen(c,outputlen);\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) addReplyBulk(c,vector[j].obj);\n            listRewind(operations,&li);\n            while((ln = listNext(&li))) {\n                redisSortOperation *sop = ln->value;\n                robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                               vector[j].obj);\n\n                if (sop->type == SORT_OP_GET) {\n                    if (!val) {\n                        addReplyNull(c);\n                    } else {\n                        addReplyBulk(c,val);\n                        decrRefCount(val);\n                    }\n                } else {\n                    /* Always fails */\n                    serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                }\n            }\n        }\n    } else {\n        /* We can't predict the size and encoding of the stored list, we\n         * assume it's a large list and then convert it at the end if needed. */\n        robj *sobj = createQuicklistObject();\n\n        /* STORE option specified, set the sorting result as a List object */\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) {\n                listTypePush(sobj,vector[j].obj,LIST_TAIL);\n            } else {\n                listRewind(operations,&li);\n                while((ln = listNext(&li))) {\n                    redisSortOperation *sop = ln->value;\n                    robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                                   vector[j].obj);\n\n                    if (sop->type == SORT_OP_GET) {\n                        if (!val) val = createStringObject(\""\"",0);\n\n                        /* listTypePush does an incrRefCount, so we should take care\n                         * care of the incremented refcount caused by either\n                         * lookupKeyByPattern or createStringObject(\""\"",0) */\n                        listTypePush(sobj,val,LIST_TAIL);\n                        decrRefCount(val);\n                    } else {\n                        /* Always fails */\n                        serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                    }\n                }\n            }\n        }\n        if (outputlen) {\n            listTypeTryConversion(sobj,LIST_CONV_AUTO,NULL,NULL);\n            setKey(c,c->db,storekey,sobj,0);\n            notifyKeyspaceEvent(NOTIFY_LIST,\""sortstore\"",storekey,\n                                c->db->id);\n            server.dirty += outputlen;\n        } else if (dbDelete(c->db,storekey)) {\n            signalModifiedKey(c,c->db,storekey);\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\""del\"",storekey,c->db->id);\n            server.dirty++;\n        }\n        decrRefCount(sobj);\n        addReplyLongLong(c,outputlen);\n    }\n\n    /* Cleanup */\n    for (j = 0; j < vectorlen; j++)\n        decrRefCount(vector[j].obj);\n\n    decrRefCount(sortval);\n    listRelease(operations);\n    for (j = 0; j < vectorlen; j++) {\n        if (alpha && vector[j].u.cmpobj)\n            decrRefCount(vector[j].u.cmpobj);\n    }\n    zfree(vector);\n}"", ""target"": 0}]","[{""func_name"": ""appendCommand"", ""file_path"": ""src/t_string.c"", ""func_code"": ""void appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* \""append\"" is an argument, so always an sds */\n        append = c->argv[2];\n        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)\n            return;\n\n        /* Append the value */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\""append\"",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}""}, {""func_name"": ""setrangeCommand"", ""file_path"": ""src/t_string.c"", ""func_code"": ""void setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n\n    if (offset < 0) {\n        addReplyError(c,\""offset is out of range\"");\n        return;\n    }\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Return 0 when setting nothing on a non-existing string */\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            return;\n\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* Return existing string length when setting nothing */\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            return;\n\n        /* Create a copy when the object is shared or encoded. */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \""setrange\"",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}""}, {""func_name"": ""checkStringLength"", ""file_path"": ""src/t_string.c"", ""func_code"": ""static int checkStringLength(client *c, long long size, long long append) {\n    if (mustObeyClient(c))\n        return C_OK;\n    /* 'uint64_t' cast is there just to prevent undefined behavior on overflow */\n    long long total = (uint64_t)size + append;\n    /* Test configured max-bulk-len represending a limit of the biggest string object,\n     * and also test for overflow. */\n    if (total > server.proto_max_bulk_len || total < size || total < append) {\n        addReplyError(c,\""string exceeds maximum allowed size (proto-max-bulk-len)\"");\n        return C_ERR;\n    }\n    return C_OK;\n}""}, {""func_name"": ""sortCommandGeneric"", ""file_path"": ""src/sort.c"", ""func_code"": ""void sortCommandGeneric(client *c, int readonly) {\n    list *operations;\n    unsigned int outputlen = 0;\n    int desc = 0, alpha = 0;\n    long limit_start = 0, limit_count = -1, start, end;\n    int j, dontsort = 0, vectorlen;\n    int getop = 0; /* GET operation counter */\n    int int_conversion_error = 0;\n    int syntax_error = 0;\n    robj *sortval, *sortby = NULL, *storekey = NULL;\n    redisSortObject *vector; /* Resulting vector to sort */\n    int user_has_full_key_access = 0; /* ACL - used in order to verify 'get' and 'by' options can be used */\n    /* Create a list of operations to perform for every sorted element.\n     * Operations can be GET */\n    operations = listCreate();\n    listSetFreeMethod(operations,zfree);\n    j = 2; /* options start at argv[2] */\n\n    user_has_full_key_access = ACLUserCheckCmdWithUnrestrictedKeyAccess(c->user, c->cmd, c->argv, c->argc, CMD_KEY_ACCESS);\n\n    /* The SORT command has an SQL-alike syntax, parse it */\n    while(j < c->argc) {\n        int leftargs = c->argc-j-1;\n        if (!strcasecmp(c->argv[j]->ptr,\""asc\"")) {\n            desc = 0;\n        } else if (!strcasecmp(c->argv[j]->ptr,\""desc\"")) {\n            desc = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\""alpha\"")) {\n            alpha = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr,\""limit\"") && leftargs >= 2) {\n            if ((getLongFromObjectOrReply(c, c->argv[j+1], &limit_start, NULL)\n                 != C_OK) ||\n                (getLongFromObjectOrReply(c, c->argv[j+2], &limit_count, NULL)\n                 != C_OK))\n            {\n                syntax_error++;\n                break;\n            }\n            j+=2;\n        } else if (readonly == 0 && !strcasecmp(c->argv[j]->ptr,\""store\"") && leftargs >= 1) {\n            storekey = c->argv[j+1];\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\""by\"") && leftargs >= 1) {\n            sortby = c->argv[j+1];\n            /* If the BY pattern does not contain '*', i.e. it is constant,\n             * we don't need to sort nor to lookup the weight keys. */\n            if (strchr(c->argv[j+1]->ptr,'*') == NULL) {\n                dontsort = 1;\n            } else {\n                /* If BY is specified with a real pattern, we can't accept\n                 * it in cluster mode. */\n                if (server.cluster_enabled) {\n                    addReplyError(c,\""BY option of SORT denied in Cluster mode.\"");\n                    syntax_error++;\n                    break;\n                }\n                /* If BY is specified with a real pattern, we can't accept\n                 * it if no full ACL key access is applied for this command. */\n                if (!user_has_full_key_access) {\n                    addReplyError(c,\""BY option of SORT denied due to insufficient ACL permissions.\"");\n                    syntax_error++;\n                    break;\n                }\n            }\n            j++;\n        } else if (!strcasecmp(c->argv[j]->ptr,\""get\"") && leftargs >= 1) {\n            if (server.cluster_enabled) {\n                addReplyError(c,\""GET option of SORT denied in Cluster mode.\"");\n                syntax_error++;\n                break;\n            }\n            if (!user_has_full_key_access) {\n                addReplyError(c,\""GET option of SORT denied due to insufficient ACL permissions.\"");\n                syntax_error++;\n                break;\n            }\n            listAddNodeTail(operations,createSortOperation(\n                SORT_OP_GET,c->argv[j+1]));\n            getop++;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            syntax_error++;\n            break;\n        }\n        j++;\n    }\n\n    /* Handle syntax errors set during options parsing. */\n    if (syntax_error) {\n        listRelease(operations);\n        return;\n    }\n\n    /* Lookup the key to sort. It must be of the right types */\n    sortval = lookupKeyRead(c->db, c->argv[1]);\n    if (sortval && sortval->type != OBJ_SET &&\n                   sortval->type != OBJ_LIST &&\n                   sortval->type != OBJ_ZSET)\n    {\n        listRelease(operations);\n        addReplyErrorObject(c,shared.wrongtypeerr);\n        return;\n    }\n\n    /* Now we need to protect sortval incrementing its count, in the future\n     * SORT may have options able to overwrite/delete keys during the sorting\n     * and the sorted key itself may get destroyed */\n    if (sortval)\n        incrRefCount(sortval);\n    else\n        sortval = createQuicklistObject();\n\n\n    /* When sorting a set with no sort specified, we must sort the output\n     * so the result is consistent across scripting and replication.\n     *\n     * The other types (list, sorted set) will retain their native order\n     * even if no sort order is requested, so they remain stable across\n     * scripting and replication. */\n    if (dontsort &&\n        sortval->type == OBJ_SET &&\n        (storekey || c->flags & CLIENT_SCRIPT))\n    {\n        /* Force ALPHA sorting */\n        dontsort = 0;\n        alpha = 1;\n        sortby = NULL;\n    }\n\n    /* Destructively convert encoded sorted sets for SORT. */\n    if (sortval->type == OBJ_ZSET)\n        zsetConvert(sortval, OBJ_ENCODING_SKIPLIST);\n\n    /* Obtain the length of the object to sort. */\n    switch(sortval->type) {\n    case OBJ_LIST: vectorlen = listTypeLength(sortval); break;\n    case OBJ_SET: vectorlen =  setTypeSize(sortval); break;\n    case OBJ_ZSET: vectorlen = dictSize(((zset*)sortval->ptr)->dict); break;\n    default: vectorlen = 0; serverPanic(\""Bad SORT type\""); /* Avoid GCC warning */\n    }\n\n    /* Perform LIMIT start,count sanity checking.\n     * And avoid integer overflow by limiting inputs to object sizes. */\n    start = min(max(limit_start, 0), vectorlen);\n    limit_count = min(max(limit_count, -1), vectorlen);\n    end = (limit_count < 0) ? vectorlen-1 : start+limit_count-1;\n    if (start >= vectorlen) {\n        start = vectorlen-1;\n        end = vectorlen-2;\n    }\n    if (end >= vectorlen) end = vectorlen-1;\n\n    /* Whenever possible, we load elements into the output array in a more\n     * direct way. This is possible if:\n     *\n     * 1) The object to sort is a sorted set or a list (internally sorted).\n     * 2) There is nothing to sort as dontsort is true (BY <constant string>).\n     *\n     * In this special case, if we have a LIMIT option that actually reduces\n     * the number of elements to fetch, we also optimize to just load the\n     * range we are interested in and allocating a vector that is big enough\n     * for the selected range length. */\n    if ((sortval->type == OBJ_ZSET || sortval->type == OBJ_LIST) &&\n        dontsort &&\n        (start != 0 || end != vectorlen-1))\n    {\n        vectorlen = end-start+1;\n    }\n\n    /* Load the sorting vector with all the objects to sort */\n    vector = zmalloc(sizeof(redisSortObject)*vectorlen);\n    j = 0;\n\n    if (sortval->type == OBJ_LIST && dontsort) {\n        /* Special handling for a list, if 'dontsort' is true.\n         * This makes sure we return elements in the list original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n        if (end >= start) {\n            listTypeIterator *li;\n            listTypeEntry entry;\n            li = listTypeInitIterator(sortval,\n                    desc ? (long)(listTypeLength(sortval) - start - 1) : start,\n                    desc ? LIST_HEAD : LIST_TAIL);\n\n            while(j < vectorlen && listTypeNext(li,&entry)) {\n                vector[j].obj = listTypeGet(&entry);\n                vector[j].u.score = 0;\n                vector[j].u.cmpobj = NULL;\n                j++;\n            }\n            listTypeReleaseIterator(li);\n            /* Fix start/end: output code is not aware of this optimization. */\n            end -= start;\n            start = 0;\n        }\n    } else if (sortval->type == OBJ_LIST) {\n        listTypeIterator *li = listTypeInitIterator(sortval,0,LIST_TAIL);\n        listTypeEntry entry;\n        while(listTypeNext(li,&entry)) {\n            vector[j].obj = listTypeGet(&entry);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        listTypeReleaseIterator(li);\n    } else if (sortval->type == OBJ_SET) {\n        setTypeIterator *si = setTypeInitIterator(sortval);\n        sds sdsele;\n        while((sdsele = setTypeNextObject(si)) != NULL) {\n            vector[j].obj = createObject(OBJ_STRING,sdsele);\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        setTypeReleaseIterator(si);\n    } else if (sortval->type == OBJ_ZSET && dontsort) {\n        /* Special handling for a sorted set, if 'dontsort' is true.\n         * This makes sure we return elements in the sorted set original\n         * ordering, accordingly to DESC / ASC options.\n         *\n         * Note that in this case we also handle LIMIT here in a direct\n         * way, just getting the required range, as an optimization. */\n\n        zset *zs = sortval->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n        sds sdsele;\n        int rangelen = vectorlen;\n\n        /* Check if starting point is trivial, before doing log(N) lookup. */\n        if (desc) {\n            long zsetlen = dictSize(((zset*)sortval->ptr)->dict);\n\n            ln = zsl->tail;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,zsetlen-start);\n        } else {\n            ln = zsl->header->level[0].forward;\n            if (start > 0)\n                ln = zslGetElementByRank(zsl,start+1);\n        }\n\n        while(rangelen--) {\n            serverAssertWithInfo(c,sortval,ln != NULL);\n            sdsele = ln->ele;\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n            ln = desc ? ln->backward : ln->level[0].forward;\n        }\n        /* Fix start/end: output code is not aware of this optimization. */\n        end -= start;\n        start = 0;\n    } else if (sortval->type == OBJ_ZSET) {\n        dict *set = ((zset*)sortval->ptr)->dict;\n        dictIterator *di;\n        dictEntry *setele;\n        sds sdsele;\n        di = dictGetIterator(set);\n        while((setele = dictNext(di)) != NULL) {\n            sdsele =  dictGetKey(setele);\n            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));\n            vector[j].u.score = 0;\n            vector[j].u.cmpobj = NULL;\n            j++;\n        }\n        dictReleaseIterator(di);\n    } else {\n        serverPanic(\""Unknown type\"");\n    }\n    serverAssertWithInfo(c,sortval,j == vectorlen);\n\n    /* Now it's time to load the right scores in the sorting vector */\n    if (!dontsort) {\n        for (j = 0; j < vectorlen; j++) {\n            robj *byval;\n            if (sortby) {\n                /* lookup value to sort by */\n                byval = lookupKeyByPattern(c->db,sortby,vector[j].obj);\n                if (!byval) continue;\n            } else {\n                /* use object itself to sort by */\n                byval = vector[j].obj;\n            }\n\n            if (alpha) {\n                if (sortby) vector[j].u.cmpobj = getDecodedObject(byval);\n            } else {\n                if (sdsEncodedObject(byval)) {\n                    char *eptr;\n\n                    vector[j].u.score = strtod(byval->ptr,&eptr);\n                    if (eptr[0] != '\\0' || errno == ERANGE ||\n                        isnan(vector[j].u.score))\n                    {\n                        int_conversion_error = 1;\n                    }\n                } else if (byval->encoding == OBJ_ENCODING_INT) {\n                    /* Don't need to decode the object if it's\n                     * integer-encoded (the only encoding supported) so\n                     * far. We can just cast it */\n                    vector[j].u.score = (long)byval->ptr;\n                } else {\n                    serverAssertWithInfo(c,sortval,1 != 1);\n                }\n            }\n\n            /* when the object was retrieved using lookupKeyByPattern,\n             * its refcount needs to be decreased. */\n            if (sortby) {\n                decrRefCount(byval);\n            }\n        }\n\n        server.sort_desc = desc;\n        server.sort_alpha = alpha;\n        server.sort_bypattern = sortby ? 1 : 0;\n        server.sort_store = storekey ? 1 : 0;\n        if (sortby && (start != 0 || end != vectorlen-1))\n            pqsort(vector,vectorlen,sizeof(redisSortObject),sortCompare, start,end);\n        else\n            qsort(vector,vectorlen,sizeof(redisSortObject),sortCompare);\n    }\n\n    /* Send command output to the output buffer, performing the specified\n     * GET/DEL/INCR/DECR operations if any. */\n    outputlen = getop ? getop*(end-start+1) : end-start+1;\n    if (int_conversion_error) {\n        addReplyError(c,\""One or more scores can't be converted into double\"");\n    } else if (storekey == NULL) {\n        /* STORE option not specified, sent the sorting result to client */\n        addReplyArrayLen(c,outputlen);\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) addReplyBulk(c,vector[j].obj);\n            listRewind(operations,&li);\n            while((ln = listNext(&li))) {\n                redisSortOperation *sop = ln->value;\n                robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                               vector[j].obj);\n\n                if (sop->type == SORT_OP_GET) {\n                    if (!val) {\n                        addReplyNull(c);\n                    } else {\n                        addReplyBulk(c,val);\n                        decrRefCount(val);\n                    }\n                } else {\n                    /* Always fails */\n                    serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                }\n            }\n        }\n    } else {\n        /* We can't predict the size and encoding of the stored list, we\n         * assume it's a large list and then convert it at the end if needed. */\n        robj *sobj = createQuicklistObject();\n\n        /* STORE option specified, set the sorting result as a List object */\n        for (j = start; j <= end; j++) {\n            listNode *ln;\n            listIter li;\n\n            if (!getop) {\n                listTypePush(sobj,vector[j].obj,LIST_TAIL);\n            } else {\n                listRewind(operations,&li);\n                while((ln = listNext(&li))) {\n                    redisSortOperation *sop = ln->value;\n                    robj *val = lookupKeyByPattern(c->db,sop->pattern,\n                                                   vector[j].obj);\n\n                    if (sop->type == SORT_OP_GET) {\n                        if (!val) val = createStringObject(\""\"",0);\n\n                        /* listTypePush does an incrRefCount, so we should take care\n                         * care of the incremented refcount caused by either\n                         * lookupKeyByPattern or createStringObject(\""\"",0) */\n                        listTypePush(sobj,val,LIST_TAIL);\n                        decrRefCount(val);\n                    } else {\n                        /* Always fails */\n                        serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);\n                    }\n                }\n            }\n        }\n        if (outputlen) {\n            listTypeTryConversion(sobj,LIST_CONV_AUTO,NULL,NULL);\n            setKey(c,c->db,storekey,sobj,0);\n            notifyKeyspaceEvent(NOTIFY_LIST,\""sortstore\"",storekey,\n                                c->db->id);\n            server.dirty += outputlen;\n        } else if (dbDelete(c->db,storekey)) {\n            signalModifiedKey(c,c->db,storekey);\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\""del\"",storekey,c->db->id);\n            server.dirty++;\n        }\n        decrRefCount(sobj);\n        addReplyLongLong(c,outputlen);\n    }\n\n    /* Cleanup */\n    for (j = 0; j < vectorlen; j++)\n        decrRefCount(vector[j].obj);\n\n    decrRefCount(sortval);\n    listRelease(operations);\n    for (j = 0; j < vectorlen; j++) {\n        if (alpha && vector[j].u.cmpobj)\n            decrRefCount(vector[j].u.cmpobj);\n    }\n    zfree(vector);\n}""}]",{},[],SETRANGE/APPEND: Unchecked addition of offset/value length (src/t_string.c:455-457) could overflow before checkStringLength. SORT: Unbounded LIMIT parameters (src/sort.c:329-333) could overflow during end calculation. Patches add overflow validation (src/t_string.c:41-57) and clamping (src/sort.c:329-333).,0.95,./github/other_context/CVE-2022-35977
36,CVE-2022-38266,CWE-369,c_cpp,An issue in the Leptonica linked library (v1.79.0) allows attackers to cause an arithmetic exception leading to a Denial of Service (DoS) via a crafted JPEG file.,https://github.com/DanBloomberg/leptonica/commit/f062b42c0ea8dddebdc6a152fd16152de215d614,Issue 26393: morphapp_fuzzer: Divide-by-zero in blockconvLow\n* Removed the code that allowed divide by zero for tiny pix\n* Ditto for 4 other block convolution functions.,5,"[{""func_name"": ""pixBlockconvGrayUnnormalized"", ""file_path"": ""src/convolve.c"", ""func_code"": ""PIX *\npixBlockconvGrayUnnormalized(PIX     *pixs,\n                             l_int32  wc,\n                             l_int32  hc)\n{\nl_int32    i, j, w, h, d, wpla, wpld, jmax;\nl_uint32  *linemina, *linemaxa, *lined, *dataa, *datad;\nPIX       *pixsb, *pixacc, *pixd;\n\n    PROCNAME(\""pixBlockconvGrayUnnormalized\"");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\""pixs not defined\"", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\""pixs not 8 bpp\"", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\""kernel too large; reducing!\\n\"", procName);\n        L_INFO(\""wc = %d, hc = %d\\n\"", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   /* no-op */\n        return pixCopy(NULL, pixs);\n\n    if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL)\n        return (PIX *)ERROR_PTR(\""pixsb not made\"", procName, NULL);\n    pixacc = pixBlockconvAccum(pixsb);\n    pixDestroy(&pixsb);\n    if (!pixacc)\n        return (PIX *)ERROR_PTR(\""pixacc not made\"", procName, NULL);\n    if ((pixd = pixCreate(w, h, 32)) == NULL) {\n        pixDestroy(&pixacc);\n        return (PIX *)ERROR_PTR(\""pixd not made\"", procName, NULL);\n    }\n\n    wpla = pixGetWpl(pixacc);\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixacc);\n    for (i = 0; i < h; i++) {\n        lined = datad + i * wpld;\n        linemina = dataa + i * wpla;\n        linemaxa = dataa + (i + 2 * hc + 1) * wpla;\n        for (j = 0; j < w; j++) {\n            jmax = j + 2 * wc + 1;\n            lined[j] = linemaxa[jmax] - linemaxa[j] -\n                       linemina[jmax] + linemina[j];\n        }\n    }\n\n    pixDestroy(&pixacc);\n    return pixd;\n}"", ""target"": 0}, {""func_name"": ""pixBlockconvGray"", ""file_path"": ""src/convolve.c"", ""func_code"": ""PIX *\npixBlockconvGray(PIX     *pixs,\n                 PIX     *pixacc,\n                 l_int32  wc,\n                 l_int32  hc)\n{\nl_int32    w, h, d, wpl, wpla;\nl_uint32  *datad, *dataa;\nPIX       *pixd, *pixt;\n\n    PROCNAME(\""pixBlockconvGray\"");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\""pixs not defined\"", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\""pixs not 8 bpp\"", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (wc == 0 && hc == 0)   /* no-op */\n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_WARNING(\""kernel too large; returning a copy\\n\"", procName);\n        L_INFO(\""w = %d, wc = %d, h = %d, hc = %d\\n\"", procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\""pixacc not 32 bpp; making new one\\n\"", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\""pixt not made\"", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\""pixt not made\"", procName, NULL);\n    }\n\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\""pixd not made\"", procName, NULL);\n    }\n\n    pixSetPadBits(pixt, 0);\n    wpl = pixGetWpl(pixd);\n    wpla = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixt);\n    blockconvLow(datad, w, h, wpl, dataa, wpla, wc, hc);\n\n    pixDestroy(&pixt);\n    return pixd;\n}"", ""target"": 0}, {""func_name"": ""pixBlockconvGrayTile"", ""file_path"": ""src/convolve.c"", ""func_code"": ""PIX *\npixBlockconvGrayTile(PIX     *pixs,\n                     PIX     *pixacc,\n                     l_int32  wc,\n                     l_int32  hc)\n{\nl_int32    w, h, d, wd, hd, i, j, imin, imax, jmin, jmax, wplt, wpld;\nl_float32  norm;\nl_uint32   val;\nl_uint32  *datat, *datad, *lined, *linemint, *linemaxt;\nPIX       *pixt, *pixd;\n\n    PROCNAME(\""pixBlockconvGrayTile\"");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\""pix not defined\"", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\""pixs not 8 bpp\"", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        wc = L_MAX(0, L_MIN(wc, (w - 3) / 2));\n        hc = L_MAX(0, L_MIN(hc, (h - 3) / 2));\n        L_WARNING(\""kernel too large; reducing!\\n\"", procName);\n        L_INFO(\""wc = %d, hc = %d\\n\"", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)\n        return pixCopy(NULL, pixs);\n    wd = w - 2 * wc;\n    hd = h - 2 * hc;\n\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\""pixacc not 32 bpp; making new one\\n\"", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\""pixt not made\"", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\""pixt not made\"", procName, NULL);\n    }\n\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\""pixd not made\"", procName, NULL);\n    }\n    datat = pixGetData(pixt);\n    wplt = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    norm = 1. / (l_float32)((2 * wc + 1) * (2 * hc + 1));\n\n        /* Do the convolution over the subregion of size (wd - 2, hd - 2),\n         * which exactly corresponds to the size of the subregion that\n         * will be extracted by pixTilingPaintTile().  Note that the\n         * region in which points are computed is not symmetric about\n         * the center of the images; instead the computation in\n         * the accumulator image is shifted up and to the left by 1,\n         * relative to the center, because the 4 accumulator sampling\n         * points are taken at the LL corner of the filter and at 3 other\n         * points that are shifted -wc and -hc to the left and above.  */\n    for (i = hc; i < hc + hd - 2; i++) {\n        imin = L_MAX(i - hc - 1, 0);\n        imax = L_MIN(i + hc, h - 1);\n        lined = datad + i * wpld;\n        linemint = datat + imin * wplt;\n        linemaxt = datat + imax * wplt;\n        for (j = wc; j < wc + wd - 2; j++) {\n            jmin = L_MAX(j - wc - 1, 0);\n            jmax = L_MIN(j + wc, w - 1);\n            val = linemaxt[jmax] - linemaxt[jmin]\n                  + linemint[jmin] - linemint[jmax];\n            val = (l_uint8)(norm * val + 0.5);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n\n    pixDestroy(&pixt);\n    return pixd;\n}"", ""target"": 1}, {""func_name"": ""pixBlockconv"", ""file_path"": ""src/convolve.c"", ""func_code"": ""PIX  *\npixBlockconv(PIX     *pix,\n             l_int32  wc,\n             l_int32  hc)\n{\nl_int32  w, h, d;\nPIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\n\n    PROCNAME(\""pixBlockconv\"");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\""pix not defined\"", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\""kernel too large; reducing!\\n\"", procName);\n        L_INFO(\""wc = %d, hc = %d\\n\"", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   /* no-op */\n        return pixCopy(NULL, pix);\n\n        /* Remove colormap if necessary */\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\""pix has colormap; removing\\n\"", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\""depth not 8 or 32 bpp\"", procName, NULL);\n    }\n\n    if (d == 8) {\n        pixd = pixBlockconvGray(pixs, NULL, wc, hc);\n    } else { /* d == 32 */\n        pixr = pixGetRGBComponent(pixs, COLOR_RED);\n        pixrc = pixBlockconvGray(pixr, NULL, wc, hc);\n        pixDestroy(&pixr);\n        pixg = pixGetRGBComponent(pixs, COLOR_GREEN);\n        pixgc = pixBlockconvGray(pixg, NULL, wc, hc);\n        pixDestroy(&pixg);\n        pixb = pixGetRGBComponent(pixs, COLOR_BLUE);\n        pixbc = pixBlockconvGray(pixb, NULL, wc, hc);\n        pixDestroy(&pixb);\n        pixd = pixCreateRGBImage(pixrc, pixgc, pixbc);\n        pixDestroy(&pixrc);\n        pixDestroy(&pixgc);\n        pixDestroy(&pixbc);\n    }\n\n    pixDestroy(&pixs);\n    return pixd;\n}"", ""target"": 0}, {""func_name"": ""pixBlockconvTiled"", ""file_path"": ""src/convolve.c"", ""func_code"": ""PIX *\npixBlockconvTiled(PIX     *pix,\n                  l_int32  wc,\n                  l_int32  hc,\n                  l_int32  nx,\n                  l_int32  ny)\n{\nl_int32     i, j, w, h, d, xrat, yrat;\nPIX        *pixs, *pixd, *pixc, *pixt;\nPIX        *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\nPIXTILING  *pt;\n\n    PROCNAME(\""pixBlockconvTiled\"");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\""pix not defined\"", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        wc = L_MAX(0, L_MIN(wc, (w - 3) / 2));\n        hc = L_MAX(0, L_MIN(hc, (h - 3) / 2));\n        L_WARNING(\""kernel too large; reducing!\\n\"", procName);\n        L_INFO(\""wc = %d, hc = %d\\n\"", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   /* no-op */\n        return pixCopy(NULL, pix);\n    if (nx <= 1 && ny <= 1)\n        return pixBlockconv(pix, wc, hc);\n\n        /* Test to see if the tiles are too small.  The required\n         * condition is that the tile dimensions must be at least\n         * (wc + 2) x (hc + 2). */\n    xrat = w / nx;\n    yrat = h / ny;\n    if (xrat < wc + 2) {\n        nx = w / (wc + 2);\n        L_WARNING(\""tile width too small; nx reduced to %d\\n\"", procName, nx);\n    }\n    if (yrat < hc + 2) {\n        ny = h / (hc + 2);\n        L_WARNING(\""tile height too small; ny reduced to %d\\n\"", procName, ny);\n    }\n\n        /* Remove colormap if necessary */\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\""pix has colormap; removing\\n\"", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\""depth not 8 or 32 bpp\"", procName, NULL);\n    }\n\n       /* Note that the overlaps in the width and height that\n        * are added to the tile are (wc + 2) and (hc + 2).\n        * These overlaps are removed by pixTilingPaintTile().\n        * They are larger than the extent of the filter because\n        * although the filter is symmetric with respect to its origin,\n        * the implementation is asymmetric -- see the implementation in\n        * pixBlockconvGrayTile(). */\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\""pixd not made\"", procName, NULL);\n    }\n    pt = pixTilingCreate(pixs, nx, ny, 0, 0, wc + 2, hc + 2);\n    for (i = 0; i < ny; i++) {\n        for (j = 0; j < nx; j++) {\n            pixt = pixTilingGetTile(pt, i, j);\n\n                /* Convolve over the tile */\n            if (d == 8) {\n                pixc = pixBlockconvGrayTile(pixt, NULL, wc, hc);\n            } else { /* d == 32 */\n                pixr = pixGetRGBComponent(pixt, COLOR_RED);\n                pixrc = pixBlockconvGrayTile(pixr, NULL, wc, hc);\n                pixDestroy(&pixr);\n                pixg = pixGetRGBComponent(pixt, COLOR_GREEN);\n                pixgc = pixBlockconvGrayTile(pixg, NULL, wc, hc);\n                pixDestroy(&pixg);\n                pixb = pixGetRGBComponent(pixt, COLOR_BLUE);\n                pixbc = pixBlockconvGrayTile(pixb, NULL, wc, hc);\n                pixDestroy(&pixb);\n                pixc = pixCreateRGBImage(pixrc, pixgc, pixbc);\n                pixDestroy(&pixrc);\n                pixDestroy(&pixgc);\n                pixDestroy(&pixbc);\n            }\n\n            pixTilingPaintTile(pixd, i, j, pixc, pt);\n            pixDestroy(&pixt);\n            pixDestroy(&pixc);\n        }\n    }\n\n    pixDestroy(&pixs);\n    pixTilingDestroy(&pt);\n    return pixd;\n}"", ""target"": 0}]","[{""func_name"": ""pixBlockconvGrayUnnormalized"", ""file_path"": ""src/convolve.c"", ""func_code"": ""PIX *\npixBlockconvGrayUnnormalized(PIX     *pixs,\n                             l_int32  wc,\n                             l_int32  hc)\n{\nl_int32    i, j, w, h, d, wpla, wpld, jmax;\nl_uint32  *linemina, *linemaxa, *lined, *dataa, *datad;\nPIX       *pixsb, *pixacc, *pixd;\n\n    PROCNAME(\""pixBlockconvGrayUnnormalized\"");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\""pixs not defined\"", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\""pixs not 8 bpp\"", procName, NULL);\n    if (wc <= 0 || hc <= 0)  /* no-op */\n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_ERROR(\""kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\"",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n\n    if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL)\n        return (PIX *)ERROR_PTR(\""pixsb not made\"", procName, NULL);\n    pixacc = pixBlockconvAccum(pixsb);\n    pixDestroy(&pixsb);\n    if (!pixacc)\n        return (PIX *)ERROR_PTR(\""pixacc not made\"", procName, NULL);\n    if ((pixd = pixCreate(w, h, 32)) == NULL) {\n        pixDestroy(&pixacc);\n        return (PIX *)ERROR_PTR(\""pixd not made\"", procName, NULL);\n    }\n\n    wpla = pixGetWpl(pixacc);\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixacc);\n    for (i = 0; i < h; i++) {\n        lined = datad + i * wpld;\n        linemina = dataa + i * wpla;\n        linemaxa = dataa + (i + 2 * hc + 1) * wpla;\n        for (j = 0; j < w; j++) {\n            jmax = j + 2 * wc + 1;\n            lined[j] = linemaxa[jmax] - linemaxa[j] -\n                       linemina[jmax] + linemina[j];\n        }\n    }\n\n    pixDestroy(&pixacc);\n    return pixd;\n}""}, {""func_name"": ""pixBlockconvGray"", ""file_path"": ""src/convolve.c"", ""func_code"": ""PIX *\npixBlockconvGray(PIX     *pixs,\n                 PIX     *pixacc,\n                 l_int32  wc,\n                 l_int32  hc)\n{\nl_int32    w, h, d, wpl, wpla;\nl_uint32  *datad, *dataa;\nPIX       *pixd, *pixt;\n\n    PROCNAME(\""pixBlockconvGray\"");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\""pixs not defined\"", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\""pixs not 8 bpp\"", procName, NULL);\n    if (wc <= 0 || hc <= 0)   /* no-op */\n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_ERROR(\""kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\"",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\""pixacc not 32 bpp; making new one\\n\"", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\""pixt not made\"", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\""pixt not made\"", procName, NULL);\n    }\n\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\""pixd not made\"", procName, NULL);\n    }\n\n    pixSetPadBits(pixt, 0);\n    wpl = pixGetWpl(pixd);\n    wpla = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixt);\n    blockconvLow(datad, w, h, wpl, dataa, wpla, wc, hc);\n\n    pixDestroy(&pixt);\n    return pixd;\n}""}, {""func_name"": ""pixBlockconvGrayTile"", ""file_path"": ""src/convolve.c"", ""func_code"": ""PIX *\npixBlockconvGrayTile(PIX     *pixs,\n                     PIX     *pixacc,\n                     l_int32  wc,\n                     l_int32  hc)\n{\nl_int32    w, h, d, wd, hd, i, j, imin, imax, jmin, jmax, wplt, wpld;\nl_float32  norm;\nl_uint32   val;\nl_uint32  *datat, *datad, *lined, *linemint, *linemaxt;\nPIX       *pixt, *pixd;\n\n    PROCNAME(\""pixBlockconvGrayTile\"");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\""pix not defined\"", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\""pixs not 8 bpp\"", procName, NULL);\n    if (wc <= 0 || hc <= 0)  /* no-op */\n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        L_ERROR(\""kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\"",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n    wd = w - 2 * wc;\n    hd = h - 2 * hc;\n\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\""pixacc not 32 bpp; making new one\\n\"", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\""pixt not made\"", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\""pixt not made\"", procName, NULL);\n    }\n\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\""pixd not made\"", procName, NULL);\n    }\n    datat = pixGetData(pixt);\n    wplt = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    norm = 1. / (l_float32)((2 * wc + 1) * (2 * hc + 1));\n\n        /* Do the convolution over the subregion of size (wd - 2, hd - 2),\n         * which exactly corresponds to the size of the subregion that\n         * will be extracted by pixTilingPaintTile().  Note that the\n         * region in which points are computed is not symmetric about\n         * the center of the images; instead the computation in\n         * the accumulator image is shifted up and to the left by 1,\n         * relative to the center, because the 4 accumulator sampling\n         * points are taken at the LL corner of the filter and at 3 other\n         * points that are shifted -wc and -hc to the left and above.  */\n    for (i = hc; i < hc + hd - 2; i++) {\n        imin = L_MAX(i - hc - 1, 0);\n        imax = L_MIN(i + hc, h - 1);\n        lined = datad + i * wpld;\n        linemint = datat + imin * wplt;\n        linemaxt = datat + imax * wplt;\n        for (j = wc; j < wc + wd - 2; j++) {\n            jmin = L_MAX(j - wc - 1, 0);\n            jmax = L_MIN(j + wc, w - 1);\n            val = linemaxt[jmax] - linemaxt[jmin]\n                  + linemint[jmin] - linemint[jmax];\n            val = (l_uint8)(norm * val + 0.5);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n\n    pixDestroy(&pixt);\n    return pixd;\n}""}, {""func_name"": ""pixBlockconv"", ""file_path"": ""src/convolve.c"", ""func_code"": ""PIX  *\npixBlockconv(PIX     *pix,\n             l_int32  wc,\n             l_int32  hc)\n{\nl_int32  w, h, d;\nPIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\n\n    PROCNAME(\""pixBlockconv\"");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\""pix not defined\"", procName, NULL);\n    if (wc <= 0 || hc <= 0)\n        return pixCopy(NULL, pix);\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_ERROR(\""kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\"",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pix);  /* no-op */\n    }\n\n        /* Remove colormap if necessary */\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\""pix has colormap; removing\\n\"", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\""depth not 8 or 32 bpp\"", procName, NULL);\n    }\n\n    if (d == 8) {\n        pixd = pixBlockconvGray(pixs, NULL, wc, hc);\n    } else { /* d == 32 */\n        pixr = pixGetRGBComponent(pixs, COLOR_RED);\n        pixrc = pixBlockconvGray(pixr, NULL, wc, hc);\n        pixDestroy(&pixr);\n        pixg = pixGetRGBComponent(pixs, COLOR_GREEN);\n        pixgc = pixBlockconvGray(pixg, NULL, wc, hc);\n        pixDestroy(&pixg);\n        pixb = pixGetRGBComponent(pixs, COLOR_BLUE);\n        pixbc = pixBlockconvGray(pixb, NULL, wc, hc);\n        pixDestroy(&pixb);\n        pixd = pixCreateRGBImage(pixrc, pixgc, pixbc);\n        pixDestroy(&pixrc);\n        pixDestroy(&pixgc);\n        pixDestroy(&pixbc);\n    }\n\n    pixDestroy(&pixs);\n    return pixd;\n}""}, {""func_name"": ""pixBlockconvTiled"", ""file_path"": ""src/convolve.c"", ""func_code"": ""PIX *\npixBlockconvTiled(PIX     *pix,\n                  l_int32  wc,\n                  l_int32  hc,\n                  l_int32  nx,\n                  l_int32  ny)\n{\nl_int32     i, j, w, h, d, xrat, yrat;\nPIX        *pixs, *pixd, *pixc, *pixt;\nPIX        *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\nPIXTILING  *pt;\n\n    PROCNAME(\""pixBlockconvTiled\"");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\""pix not defined\"", procName, NULL);\n    if (wc <= 0 || hc <= 0)   /* no-op */\n        return pixCopy(NULL, pix);\n    if (nx <= 1 && ny <= 1)\n        return pixBlockconv(pix, wc, hc);\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        L_ERROR(\""kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\"",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pix);\n    }\n\n        /* Test to see if the tiles are too small.  The required\n         * condition is that the tile dimensions must be at least\n         * (wc + 2) x (hc + 2). */\n    xrat = w / nx;\n    yrat = h / ny;\n    if (xrat < wc + 2) {\n        nx = w / (wc + 2);\n        L_WARNING(\""tile width too small; nx reduced to %d\\n\"", procName, nx);\n    }\n    if (yrat < hc + 2) {\n        ny = h / (hc + 2);\n        L_WARNING(\""tile height too small; ny reduced to %d\\n\"", procName, ny);\n    }\n\n        /* Remove colormap if necessary */\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\""pix has colormap; removing\\n\"", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\""depth not 8 or 32 bpp\"", procName, NULL);\n    }\n\n       /* Note that the overlaps in the width and height that\n        * are added to the tile are (wc + 2) and (hc + 2).\n        * These overlaps are removed by pixTilingPaintTile().\n        * They are larger than the extent of the filter because\n        * although the filter is symmetric with respect to its origin,\n        * the implementation is asymmetric -- see the implementation in\n        * pixBlockconvGrayTile(). */\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\""pixd not made\"", procName, NULL);\n    }\n    pt = pixTilingCreate(pixs, nx, ny, 0, 0, wc + 2, hc + 2);\n    for (i = 0; i < ny; i++) {\n        for (j = 0; j < nx; j++) {\n            pixt = pixTilingGetTile(pt, i, j);\n\n                /* Convolve over the tile */\n            if (d == 8) {\n                pixc = pixBlockconvGrayTile(pixt, NULL, wc, hc);\n            } else { /* d == 32 */\n                pixr = pixGetRGBComponent(pixt, COLOR_RED);\n                pixrc = pixBlockconvGrayTile(pixr, NULL, wc, hc);\n                pixDestroy(&pixr);\n                pixg = pixGetRGBComponent(pixt, COLOR_GREEN);\n                pixgc = pixBlockconvGrayTile(pixg, NULL, wc, hc);\n                pixDestroy(&pixg);\n                pixb = pixGetRGBComponent(pixt, COLOR_BLUE);\n                pixbc = pixBlockconvGrayTile(pixb, NULL, wc, hc);\n                pixDestroy(&pixb);\n                pixc = pixCreateRGBImage(pixrc, pixgc, pixbc);\n                pixDestroy(&pixrc);\n                pixDestroy(&pixgc);\n                pixDestroy(&pixbc);\n            }\n\n            pixTilingPaintTile(pixd, i, j, pixc, pt);\n            pixDestroy(&pixt);\n            pixDestroy(&pixc);\n        }\n    }\n\n    pixDestroy(&pixs);\n    pixTilingDestroy(&pt);\n    return pixd;\n}""}]","{""function"": 1, ""value"": 2}","[{""source"": ""func_info(file:convolve.c, func:blockconvLow)"", ""result"": [{""code"": ""static void\nblockconvLow(l_uint32  *data,\n             l_int32    w,\n             l_int32    h,\n             l_int32    wpl,\n             l_uint32  *dataa,\n             l_int32    wpla,\n             l_int32    wc,\n             l_int32    hc)\n{\nl_int32    i, j, imax, imin, jmax, jmin;\nl_int32    wn, hn, fwc, fhc, wmwc, hmhc;\nl_float32  norm, normh, normw;\nl_uint32   val;\nl_uint32  *linemina, *linemaxa, *line;\n\n    PROCNAME(\""blockconvLow\"");\n\n    wmwc = w - wc;\n    hmhc = h - hc;\n    if (wmwc <= 0 || hmhc <= 0) {\n        L_ERROR(\""wc >= w || hc >=h\\n\"", procName);\n        return;\n    }\n    fwc = 2 * wc + 1;\n    fhc = 2 * hc + 1;\n    norm = 1.0 / ((l_float32)(fwc) * fhc);\n\n        /*------------------------------------------------------------*\n         *  Compute, using b.c. only to set limits on the accum image *\n         *------------------------------------------------------------*/\n    for (i = 0; i < h; i++) {\n        imin = L_MAX(i - 1 - hc, 0);\n        imax = L_MIN(i + hc, h - 1);\n        line = data + wpl * i;\n        linemina = dataa + wpla * imin;\n        linemaxa = dataa + wpla * imax;\n        for (j = 0; j < w; j++) {\n            jmin = L_MAX(j - 1 - wc, 0);\n            jmax = L_MIN(j + wc, w - 1);\n            val = linemaxa[jmax] - linemaxa[jmin]\n                  + linemina[jmin] - linemina[jmax];\n            val = (l_uint8)(norm * val + 0.5);  /* see comment above */\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n\n        /*------------------------------------------------------------*\n         *             Fix normalization for boundary pixels          *\n         *------------------------------------------------------------*/\n    for (i = 0; i <= hc; i++) {    /* first hc + 1 lines */\n        hn = L_MAX(1, hc + i);\n        normh = (l_float32)fhc / (l_float32)hn;   /* >= 1 */\n        line = data + wpl * i;\n        for (j = 0; j <= wc; j++) {\n            wn = L_MAX(1, wc + j);\n            normw = (l_float32)fwc / (l_float32)wn;   /* >= 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wc + 1; j < wmwc; j++) {\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wmwc; j < w; j++) {\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n\n    for (i = hmhc; i < h; i++) {  /* last hc lines */\n        hn = hc + h - i;\n        normh = (l_float32)fhc / (l_float32)hn;   /* > 1 */\n        line = data + wpl * i;\n        for (j = 0; j <= wc; j++) {\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wc + 1; j < wmwc; j++) {\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wmwc; j < w; j++) {\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n\n    for (i = hc + 1; i < hmhc; i++) {    /* intermediate lines */\n        line = data + wpl * i;\n        for (j = 0; j <= wc; j++) {   /* first wc + 1 columns */\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wmwc; j < w; j++) {   /* last wc columns */\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n}\n"", ""start_line"": 317, ""end_line"": 434, ""full_name"": ""blockconvLow"", ""file_path"": ""src/convolve.c""}]}, {""source"": ""value_info(file:convolve.c, value:wc)"", ""result"": {""value_trace"": [{""full_code"": ""l_int32 wc"", ""line"": 58, ""func_name"": null}, {""full_code"": ""l_int32 wc"", ""line"": 273, ""func_name"": null}, {""full_code"": ""l_int32 wc"", ""line"": 504, ""func_name"": null}, {""full_code"": ""l_int32 wc"", ""line"": 701, ""func_name"": null}, {""full_code"": ""l_int32 wc"", ""line"": 837, ""func_name"": null}], ""struct_var"": ""wc"", ""struct_type"": ""l_int32"", ""struct_definition"": ""typedef int                     l_int32;\n\ntypedef int                     l_int32;""}}, {""source"": ""value_info(file:convolve.c, value:hc)"", ""result"": {""value_trace"": [{""full_code"": ""l_int32 hc"", ""line"": 58, ""func_name"": null}, {""full_code"": ""l_int32 hc"", ""line"": 273, ""func_name"": null}, {""full_code"": ""l_int32 hc"", ""line"": 504, ""func_name"": null}, {""full_code"": ""l_int32 hc"", ""line"": 701, ""func_name"": null}, {""full_code"": ""l_int32 hc"", ""line"": 837, ""func_name"": null}], ""struct_var"": ""hc"", ""struct_type"": ""l_int32"", ""struct_definition"": ""typedef int                     l_int32;\n\ntypedef int                     l_int32;""}}]","src/convolve.c:317-434 (blockconvLow): When `wc=0`, the loop for intermediate lines (lines 404-413) computes `wn = wc + j` (j=0  wn=0), leading to `normw = 1.0 / 0.0` (division-by-zero). This occurs if `pixBlockconv...` functions pass `wc=0` to `blockconvLow` without clamping.",0.95,./github/other_context/CVE-2022-38266
37,CVE-2022-3821,CWE-193,c_cpp,"An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.",https://github.com/systemd/systemd/commit/9102c625a673a3246d7e73d8737f3494446bad4e,time-util: fix buffer-over-run\n\nFixes #23928.,1,"[{""func_name"": ""format_timespan"", ""file_path"": ""src/basic/time-util.c"", ""func_code"": ""char *format_timespan(char *buf, size_t l, usec_t t, usec_t accuracy) {\n        static const struct {\n                const char *suffix;\n                usec_t usec;\n        } table[] = {\n                { \""y\"",     USEC_PER_YEAR   },\n                { \""month\"", USEC_PER_MONTH  },\n                { \""w\"",     USEC_PER_WEEK   },\n                { \""d\"",     USEC_PER_DAY    },\n                { \""h\"",     USEC_PER_HOUR   },\n                { \""min\"",   USEC_PER_MINUTE },\n                { \""s\"",     USEC_PER_SEC    },\n                { \""ms\"",    USEC_PER_MSEC   },\n                { \""us\"",    1               },\n        };\n\n        char *p = buf;\n        bool something = false;\n\n        assert(buf);\n        assert(l > 0);\n\n        if (t == USEC_INFINITY) {\n                strncpy(p, \""infinity\"", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        if (t <= 0) {\n                strncpy(p, \""0\"", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        /* The result of this function can be parsed with parse_sec */\n\n        for (size_t i = 0; i < ELEMENTSOF(table); i++) {\n                int k = 0;\n                size_t n;\n                bool done = false;\n                usec_t a, b;\n\n                if (t <= 0)\n                        break;\n\n                if (t < accuracy && something)\n                        break;\n\n                if (t < table[i].usec)\n                        continue;\n\n                if (l <= 1)\n                        break;\n\n                a = t / table[i].usec;\n                b = t % table[i].usec;\n\n                /* Let's see if we should shows this in dot notation */\n                if (t < USEC_PER_MINUTE && b > 0) {\n                        signed char j = 0;\n\n                        for (usec_t cc = table[i].usec; cc > 1; cc /= 10)\n                                j++;\n\n                        for (usec_t cc = accuracy; cc > 1; cc /= 10) {\n                                b /= 10;\n                                j--;\n                        }\n\n                        if (j > 0) {\n                                k = snprintf(p, l,\n                                             \""%s\""USEC_FMT\"".%0*\""PRI_USEC\""%s\"",\n                                             p > buf ? \"" \"" : \""\"",\n                                             a,\n                                             j,\n                                             b,\n                                             table[i].suffix);\n\n                                t = 0;\n                                done = true;\n                        }\n                }\n\n                /* No? Then let's show it normally */\n                if (!done) {\n                        k = snprintf(p, l,\n                                     \""%s\""USEC_FMT\""%s\"",\n                                     p > buf ? \"" \"" : \""\"",\n                                     a,\n                                     table[i].suffix);\n\n                        t = b;\n                }\n\n                n = MIN((size_t) k, l);\n\n                l -= n;\n                p += n;\n\n                something = true;\n        }\n\n        *p = 0;\n\n        return buf;\n}"", ""target"": 0}]","[{""func_name"": ""format_timespan"", ""file_path"": ""src/basic/time-util.c"", ""func_code"": ""char *format_timespan(char *buf, size_t l, usec_t t, usec_t accuracy) {\n        static const struct {\n                const char *suffix;\n                usec_t usec;\n        } table[] = {\n                { \""y\"",     USEC_PER_YEAR   },\n                { \""month\"", USEC_PER_MONTH  },\n                { \""w\"",     USEC_PER_WEEK   },\n                { \""d\"",     USEC_PER_DAY    },\n                { \""h\"",     USEC_PER_HOUR   },\n                { \""min\"",   USEC_PER_MINUTE },\n                { \""s\"",     USEC_PER_SEC    },\n                { \""ms\"",    USEC_PER_MSEC   },\n                { \""us\"",    1               },\n        };\n\n        char *p = buf;\n        bool something = false;\n\n        assert(buf);\n        assert(l > 0);\n\n        if (t == USEC_INFINITY) {\n                strncpy(p, \""infinity\"", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        if (t <= 0) {\n                strncpy(p, \""0\"", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        /* The result of this function can be parsed with parse_sec */\n\n        for (size_t i = 0; i < ELEMENTSOF(table); i++) {\n                int k = 0;\n                size_t n;\n                bool done = false;\n                usec_t a, b;\n\n                if (t <= 0)\n                        break;\n\n                if (t < accuracy && something)\n                        break;\n\n                if (t < table[i].usec)\n                        continue;\n\n                if (l <= 1)\n                        break;\n\n                a = t / table[i].usec;\n                b = t % table[i].usec;\n\n                /* Let's see if we should shows this in dot notation */\n                if (t < USEC_PER_MINUTE && b > 0) {\n                        signed char j = 0;\n\n                        for (usec_t cc = table[i].usec; cc > 1; cc /= 10)\n                                j++;\n\n                        for (usec_t cc = accuracy; cc > 1; cc /= 10) {\n                                b /= 10;\n                                j--;\n                        }\n\n                        if (j > 0) {\n                                k = snprintf(p, l,\n                                             \""%s\""USEC_FMT\"".%0*\""PRI_USEC\""%s\"",\n                                             p > buf ? \"" \"" : \""\"",\n                                             a,\n                                             j,\n                                             b,\n                                             table[i].suffix);\n\n                                t = 0;\n                                done = true;\n                        }\n                }\n\n                /* No? Then let's show it normally */\n                if (!done) {\n                        k = snprintf(p, l,\n                                     \""%s\""USEC_FMT\""%s\"",\n                                     p > buf ? \"" \"" : \""\"",\n                                     a,\n                                     table[i].suffix);\n\n                        t = b;\n                }\n\n                n = MIN((size_t) k, l-1);\n\n                l -= n;\n                p += n;\n\n                something = true;\n        }\n\n        *p = 0;\n\n        return buf;\n}""}]","{""code"": 5, ""caller"": 1}","[{""source"": ""code_info(file:time-util.c, lines:580-595)"", ""result"": ""                        }\n                }\n\n                /* No? Then let's show it normally */\n                if (!done) {\n                        k = snprintf(p, l,\n                                     \""%s\""USEC_FMT\""%s\"",\n                                     p > buf ? \"" \"" : \""\"",\n                                     a,\n                                     table[i].suffix);\n\n                        t = b;\n                }\n\n                n = MIN((size_t) k, l);\n\n                l -= n;\n""}, {""source"": ""code_info(file:time-util.c, lines:550-600)"", ""result"": ""\n                if (l <= 1)\n                        break;\n\n                a = t / table[i].usec;\n                b = t % table[i].usec;\n\n                /* Let's see if we should shows this in dot notation */\n                if (t < USEC_PER_MINUTE && b > 0) {\n                        signed char j = 0;\n\n                        for (usec_t cc = table[i].usec; cc > 1; cc /= 10)\n                                j++;\n\n                        for (usec_t cc = accuracy; cc > 1; cc /= 10) {\n                                b /= 10;\n                                j--;\n                        }\n\n                        if (j > 0) {\n                                k = snprintf(p, l,\n                                             \""%s\""USEC_FMT\"".%0*\""PRI_USEC\""%s\"",\n                                             p > buf ? \"" \"" : \""\"",\n                                             a,\n                                             j,\n                                             b,\n                                             table[i].suffix);\n\n                                t = 0;\n                                done = true;\n                        }\n                }\n\n                /* No? Then let's show it normally */\n                if (!done) {\n                        k = snprintf(p, l,\n                                     \""%s\""USEC_FMT\""%s\"",\n                                     p > buf ? \"" \"" : \""\"",\n                                     a,\n                                     table[i].suffix);\n\n                        t = b;\n                }\n\n                n = MIN((size_t) k, l);\n\n                l -= n;\n                p += n;\n\n                something = true;\n        }\n\n""}, {""source"": ""caller_info(file:time-util.c, func:format_timespan)"", ""result"": [{""call_line"": 34, ""call_code"": ""format_timespan((char []){}, 64U, times->activating - boot->userspace_time, ((usec_t)1000ULL))"", ""caller_code"": ""static int list_dependencies_print(\n                const char *name,\n                unsigned level,\n                unsigned branches,\n                bool last,\n                UnitTimes *times,\n                BootTimes *boot) {\n\n        for (unsigned i = level; i != 0; i--)\n                printf(\""%s\"", special_glyph(branches & (1 << (i-1)) ? SPECIAL_GLYPH_TREE_VERTICAL : SPECIAL_GLYPH_TREE_SPACE));\n\n        printf(\""%s\"", special_glyph(last ? SPECIAL_GLYPH_TREE_RIGHT : SPECIAL_GLYPH_TREE_BRANCH));\n\n        if (times) {\n                if (times->time > 0)\n                        printf(\""%s%s @%s +%s%s\"", ansi_highlight_red(), name,\n                               FORMAT_TIMESPAN(times->activating - boot->userspace_time, USEC_PER_MSEC),\n                               FORMAT_TIMESPAN(times->time, USEC_PER_MSEC), ansi_normal());\n                else if (times->activated > boot->userspace_time)\n                        printf(\""%s @%s\"", name, FORMAT_TIMESPAN(times->activated - boot->userspace_time, USEC_PER_MSEC));\n                else\n                        printf(\""%s\"", name);\n        } else\n                printf(\""%s\"", name);\n        printf(\""\\n\"");\n\n        return 0;\n}\n"", ""caller_start"": 18, ""file_path"": ""src/analyze/analyze-critical-chain.c""}, {""call_line"": 35, ""call_code"": ""format_timespan((char []){}, 64U, times->time, ((usec_t)1000ULL))"", ""caller_code"": ""static int list_dependencies_print(\n                const char *name,\n                unsigned level,\n                unsigned branches,\n                bool last,\n                UnitTimes *times,\n                BootTimes *boot) {\n\n        for (unsigned i = level; i != 0; i--)\n                printf(\""%s\"", special_glyph(branches & (1 << (i-1)) ? SPECIAL_GLYPH_TREE_VERTICAL : SPECIAL_GLYPH_TREE_SPACE));\n\n        printf(\""%s\"", special_glyph(last ? SPECIAL_GLYPH_TREE_RIGHT : SPECIAL_GLYPH_TREE_BRANCH));\n\n        if (times) {\n                if (times->time > 0)\n                        printf(\""%s%s @%s +%s%s\"", ansi_highlight_red(), name,\n                               FORMAT_TIMESPAN(times->activating - boot->userspace_time, USEC_PER_MSEC),\n                               FORMAT_TIMESPAN(times->time, USEC_PER_MSEC), ansi_normal());\n                else if (times->activated > boot->userspace_time)\n                        printf(\""%s @%s\"", name, FORMAT_TIMESPAN(times->activated - boot->userspace_time, USEC_PER_MSEC));\n                else\n                        printf(\""%s\"", name);\n        } else\n                printf(\""%s\"", name);\n        printf(\""\\n\"");\n\n        return 0;\n}\n"", ""caller_start"": 18, ""file_path"": ""src/analyze/analyze-critical-chain.c""}, {""call_line"": 37, ""call_code"": ""format_timespan((char []){}, 64U, times->activated - boot->userspace_time, ((usec_t)1000ULL))"", ""caller_code"": ""static int list_dependencies_print(\n                const char *name,\n                unsigned level,\n                unsigned branches,\n                bool last,\n                UnitTimes *times,\n                BootTimes *boot) {\n\n        for (unsigned i = level; i != 0; i--)\n                printf(\""%s\"", special_glyph(branches & (1 << (i-1)) ? SPECIAL_GLYPH_TREE_VERTICAL : SPECIAL_GLYPH_TREE_SPACE));\n\n        printf(\""%s\"", special_glyph(last ? SPECIAL_GLYPH_TREE_RIGHT : SPECIAL_GLYPH_TREE_BRANCH));\n\n        if (times) {\n                if (times->time > 0)\n                        printf(\""%s%s @%s +%s%s\"", ansi_highlight_red(), name,\n                               FORMAT_TIMESPAN(times->activating - boot->userspace_time, USEC_PER_MSEC),\n                               FORMAT_TIMESPAN(times->time, USEC_PER_MSEC), ansi_normal());\n                else if (times->activated > boot->userspace_time)\n                        printf(\""%s @%s\"", name, FORMAT_TIMESPAN(times->activated - boot->userspace_time, USEC_PER_MSEC));\n                else\n                        printf(\""%s\"", name);\n        } else\n                printf(\""%s\"", name);\n        printf(\""\\n\"");\n\n        return 0;\n}\n"", ""caller_start"": 18, ""file_path"": ""src/analyze/analyze-critical-chain.c""}, {""call_line"": 188, ""call_code"": ""format_timespan((char []){}, 64U, times->time, ((usec_t)1000ULL))"", ""caller_code"": ""static int list_dependencies(sd_bus *bus, const char *name) {\n        _cleanup_strv_free_ char **units = NULL;\n        UnitTimes *times;\n        int r;\n        const char *id;\n        _cleanup_free_ char *path = NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        BootTimes *boot;\n\n        assert(bus);\n\n        path = unit_dbus_path_from_name(name);\n        if (!path)\n                return -ENOMEM;\n\n        r = sd_bus_get_property(\n                        bus,\n                        \""org.freedesktop.systemd1\"",\n                        path,\n                        \""org.freedesktop.systemd1.Unit\"",\n                        \""Id\"",\n                        &error,\n                        &reply,\n                        \""s\"");\n        if (r < 0)\n                return log_error_errno(r, \""Failed to get ID: %s\"", bus_error_message(&error, r));\n\n        r = sd_bus_message_read(reply, \""s\"", &id);\n        if (r < 0)\n                return bus_log_parse_error(r);\n\n        times = hashmap_get(unit_times_hashmap, id);\n\n        r = acquire_boot_times(bus, &boot);\n        if (r < 0)\n                return r;\n\n        if (times) {\n                if (times->time)\n                        printf(\""%s%s +%s%s\\n\"", ansi_highlight_red(), id,\n                               FORMAT_TIMESPAN(times->time, USEC_PER_MSEC), ansi_normal());\n                else if (times->activated > boot->userspace_time)\n                        printf(\""%s @%s\\n\"", id,\n                               FORMAT_TIMESPAN(times->activated - boot->userspace_time, USEC_PER_MSEC));\n                else\n                        printf(\""%s\\n\"", id);\n        }\n\n        return list_dependencies_one(bus, name, 0, &units, 0);\n}\n"", ""caller_start"": 147, ""file_path"": ""src/analyze/analyze-critical-chain.c""}]}, {""source"": ""code_info(file:time-util.c, lines:550-580)"", ""result"": ""\n                if (l <= 1)\n                        break;\n\n                a = t / table[i].usec;\n                b = t % table[i].usec;\n\n                /* Let's see if we should shows this in dot notation */\n                if (t < USEC_PER_MINUTE && b > 0) {\n                        signed char j = 0;\n\n                        for (usec_t cc = table[i].usec; cc > 1; cc /= 10)\n                                j++;\n\n                        for (usec_t cc = accuracy; cc > 1; cc /= 10) {\n                                b /= 10;\n                                j--;\n                        }\n\n                        if (j > 0) {\n                                k = snprintf(p, l,\n                                             \""%s\""USEC_FMT\"".%0*\""PRI_USEC\""%s\"",\n                                             p > buf ? \"" \"" : \""\"",\n                                             a,\n                                             j,\n                                             b,\n                                             table[i].suffix);\n\n                                t = 0;\n                                done = true;\n                        }\n                }\n""}, {""source"": ""code_info(file:time-util.c, lines:530-550)"", ""result"": ""                p[l-1] = 0;\n                return p;\n        }\n\n        /* The result of this function can be parsed with parse_sec */\n\n        for (size_t i = 0; i < ELEMENTSOF(table); i++) {\n                int k = 0;\n                size_t n;\n                bool done = false;\n                usec_t a, b;\n\n                if (t <= 0)\n                        break;\n\n                if (t < accuracy && something)\n                        break;\n\n                if (t < table[i].usec)\n                        continue;\n\n                if (l <= 1)\n""}, {""source"": ""code_info(file:time-util.c, lines:500-530)"", ""result"": ""char *format_timespan(char *buf, size_t l, usec_t t, usec_t accuracy) {\n        static const struct {\n                const char *suffix;\n                usec_t usec;\n        } table[] = {\n                { \""y\"",     USEC_PER_YEAR   },\n                { \""month\"", USEC_PER_MONTH  },\n                { \""w\"",     USEC_PER_WEEK   },\n                { \""d\"",     USEC_PER_DAY    },\n                { \""h\"",     USEC_PER_HOUR   },\n                { \""min\"",   USEC_PER_MINUTE },\n                { \""s\"",     USEC_PER_SEC    },\n                { \""ms\"",    USEC_PER_MSEC   },\n                { \""us\"",    1               },\n        };\n\n        char *p = buf;\n        bool something = false;\n\n        assert(buf);\n        assert(l > 0);\n\n        if (t == USEC_INFINITY) {\n                strncpy(p, \""infinity\"", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        if (t <= 0) {\n                strncpy(p, \""0\"", l-1);\n                p[l-1] = 0;\n                return p;\n""}]","src/basic/time-util.c:592: The original code calculated `n = MIN((size_t)k, l);`, allowing `k` bytes to be written into a buffer with `l` remaining space. This did not reserve space for the null terminator, risking overflow if `k == l`. The patch uses `l-1` to ensure at least one byte remains. `l` is initialized to the buffer size parameter in `format_timespan()` (src/basic/time-util.c:500-530), which is set by callers like `src/analyze/analyze-critical-chain.c:34` (64U). The loop decrements `l` each iteration, and the vulnerability occurs when `k == l` in any iteration, leading to buffer overrun.",0.95,./github/other_context/CVE-2022-3821
38,CVE-2023-34453,CWE-190,java,"snappy-java is a fast compressor/decompressor for Java. Due to unchecked multiplications, an integer overflow may occur in versions prior to 1.1.10.1, causing a fatal error.

The function `shuffle(int[] input)` in the file `BitShuffle.java` receives an array of integers and applies a bit shuffle on it. It does so by multiplying the length by 4 and passing it to the natively compiled shuffle function. Since the length is not tested, the multiplication by four can cause an integer overflow and become a smaller value than the true size, or even zero or negative. In the case of a negative value, a `java.lang.NegativeArraySizeException` exception will raise, which can crash the program. In a case of a value that is zero or too small, the code that afterwards references the shuffled array will assume a bigger size of the array, which might cause exceptions such as `java.lang.ArrayIndexOutOfBoundsException`.

The same issue exists also when using the `shuffle` functions that receive a double, float, long and short, each using a different multiplier that may cause the same issue.

Version 1.1.10.1 contains a patch for this vulnerability.",https://github.com/xerial/snappy-java/commit/820e2e074c58748b41dbd547f4edba9e108ad905,Merge pull request from GHSA-pqr6-cmr2-h8hf\n\n* Fixed integer overflow by checking if multiplication result is smaller than original value\n\n* Fixed integer overflow by checking if multiplication result is smaller than original value\n\n* Fixed integer overflow by checking if multiplication result is smaller than original value\n\n* imporved error messages and added happy and sad cases for unit test in SnappyTest.java\n\n* switched SnappyError into ILLEGAL_ARGUMENT in SnappyErrorCode.java and Snappy.java\n\n* wrote new and updated unit test methods\n\n* updated comments in SnappyTest.java\n\n* Fixed and updated unit tests in SnappyTest.java,5,"[{""func_name"": ""shuffle"", ""file_path"": ""src/main/java/org/xerial/snappy/BitShuffle.java"", ""func_code"": ""public static byte[] shuffle(short[] input) throws IOException {\n        byte[] output = new byte[input.length * 2];\n        int numProcessed = impl.shuffle(input, 0, 2, input.length * 2, output, 0);\n        assert(numProcessed == input.length * 2);\n        return output;\n    }"", ""target"": 0}, {""func_name"": ""shuffle"", ""file_path"": ""src/main/java/org/xerial/snappy/BitShuffle.java"", ""func_code"": ""public static byte[] shuffle(double[] input) throws IOException {\n        byte[] output = new byte[input.length * 8];\n        int numProcessed = impl.shuffle(input, 0, 8, input.length * 8, output, 0);\n        assert(numProcessed == input.length * 8);\n        return output;\n    }"", ""target"": 0}, {""func_name"": ""shuffle"", ""file_path"": ""src/main/java/org/xerial/snappy/BitShuffle.java"", ""func_code"": ""public static byte[] shuffle(int[] input) throws IOException {\n        byte[] output = new byte[input.length * 4];\n        int numProcessed = impl.shuffle(input, 0, 4, input.length * 4, output, 0);\n        assert(numProcessed == input.length * 4);\n        return output;\n    }"", ""target"": 0}, {""func_name"": ""shuffle"", ""file_path"": ""src/main/java/org/xerial/snappy/BitShuffle.java"", ""func_code"": ""public static byte[] shuffle(long[] input) throws IOException {\n        byte[] output = new byte[input.length * 8];\n        int numProcessed = impl.shuffle(input, 0, 8, input.length * 8, output, 0);\n        assert(numProcessed == input.length * 8);\n        return output;\n    }"", ""target"": 0}, {""func_name"": ""shuffle"", ""file_path"": ""src/main/java/org/xerial/snappy/BitShuffle.java"", ""func_code"": ""public static byte[] shuffle(float[] input) throws IOException {\n        byte[] output = new byte[input.length * 4];\n        int numProcessed = impl.shuffle(input, 0, 4, input.length * 4, output, 0);\n        assert(numProcessed == input.length * 4);\n        return output;\n    }"", ""target"": 0}]","[{""func_name"": ""shuffle"", ""file_path"": ""src/main/java/org/xerial/snappy/BitShuffle.java"", ""func_code"": ""public static byte[] shuffle(short[] input) throws IOException {\n        if (input.length * 2 < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \""input array size is too large: \"" + input.length);\n        }\n        byte[] output = new byte[input.length * 2];\n        int numProcessed = impl.shuffle(input, 0, 2, input.length * 2, output, 0);\n        assert(numProcessed == input.length * 2);\n        return output;\n    }""}, {""func_name"": ""shuffle"", ""file_path"": ""src/main/java/org/xerial/snappy/BitShuffle.java"", ""func_code"": ""public static byte[] shuffle(double[] input) throws IOException {\n        if (input.length * 8 < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \""input array size is too large: \"" + input.length);\n        }\n        byte[] output = new byte[input.length * 8];\n        int numProcessed = impl.shuffle(input, 0, 8, input.length * 8, output, 0);\n        assert(numProcessed == input.length * 8);\n        return output;\n    }""}, {""func_name"": ""shuffle"", ""file_path"": ""src/main/java/org/xerial/snappy/BitShuffle.java"", ""func_code"": ""public static byte[] shuffle(int[] input) throws IOException {\n        if (input.length * 4 < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \""input array size is too large: \"" + input.length);\n        }\n        byte[] output = new byte[input.length * 4];\n        int numProcessed = impl.shuffle(input, 0, 4, input.length * 4, output, 0);\n        assert(numProcessed == input.length * 4);\n        return output;\n    }""}, {""func_name"": ""shuffle"", ""file_path"": ""src/main/java/org/xerial/snappy/BitShuffle.java"", ""func_code"": ""public static byte[] shuffle(long[] input) throws IOException {\n        if (input.length * 8 < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \""input array size is too large: \"" + input.length);\n        }\n        byte[] output = new byte[input.length * 8];\n        int numProcessed = impl.shuffle(input, 0, 8, input.length * 8, output, 0);\n        assert(numProcessed == input.length * 8);\n        return output;\n    }""}, {""func_name"": ""shuffle"", ""file_path"": ""src/main/java/org/xerial/snappy/BitShuffle.java"", ""func_code"": ""public static byte[] shuffle(float[] input) throws IOException {\n        if (input.length * 4 < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \""input array size is too large: \"" + input.length);\n        }\n        byte[] output = new byte[input.length * 4];\n        int numProcessed = impl.shuffle(input, 0, 4, input.length * 4, output, 0);\n        assert(numProcessed == input.length * 4);\n        return output;\n    }""}]","{""value"": 2, ""function"": 1, ""caller"": 1}","[{""source"": ""value_info(file:BitShuffle.java, value:input)"", ""result"": {""value_trace"": [{""full_code"": ""byte[] input = buffer.array()"", ""line"": 504, ""func_name"": ""org.xerial.snappy.SnappyFramedOutputStream.writeCompressed:void(java.nio.ByteBuffer)""}], ""struct_var"": ""input"", ""struct_type"": ""byte[]"", ""struct_definition"": null}}, {""source"": ""func_info(file:SnappyFramedOutputStream.java, func:writeCompressed)"", ""result"": [{""code"": ""    private void writeCompressed(ByteBuffer buffer)\n            throws IOException\n    {\n\n        final byte[] input = buffer.array();\n        final int length = buffer.remaining();\n\n        // crc is based on the user supplied input data\n        final int crc32c = maskedCrc32c(crc32, input, 0, length);\n\n        directInputBuffer.clear();\n        directInputBuffer.put(buffer);\n        directInputBuffer.flip();\n\n        outputBuffer.clear();\n        Snappy.compress(directInputBuffer, outputBuffer);\n\n        final int compressedLength = outputBuffer.remaining();\n\n        // only use the compressed data if compression ratio is <= the\n        // minCompressonRatio\n        if (((double) compressedLength / (double) length) <= minCompressionRatio) {\n            writeBlock(out, outputBuffer, true, crc32c);\n        }\n        else {\n            // otherwise use the uncompressed data.\n            buffer.flip();\n            writeBlock(out, buffer, false, crc32c);\n        }\n    }\n"", ""start_line"": 500, ""end_line"": 529, ""full_name"": ""org.xerial.snappy.SnappyFramedOutputStream.writeCompressed:void(java.nio.ByteBuffer)"", ""file_path"": ""src/main/java/org/xerial/snappy/SnappyFramedOutputStream.java""}]}, {""source"": ""value_info(file:SnappyFramedOutputStream.java, value:buffer)"", ""result"": {""value_trace"": [{""full_code"": ""byte[] buffer = new byte[8192]"", ""line"": 244, ""func_name"": ""org.xerial.snappy.SnappyLoader.extractLibraryFile:java.io.File(java.lang.String,java.lang.String,java.lang.String)""}], ""struct_var"": ""buffer"", ""struct_type"": ""byte[]"", ""struct_definition"": null}}, {""source"": ""caller_info(file:SnappyFramedOutputStream.java, func:writeCompressed)"", ""result"": [{""call_line"": 485, ""call_code"": ""this.writeCompressed(buffer)"", ""caller_code"": ""    private void flushBuffer()\n            throws IOException\n    {\n        if (buffer.position() > 0) {\n            buffer.flip();\n            writeCompressed(buffer);\n            buffer.clear();\n            buffer.limit(blockSize);\n        }\n    }\n"", ""caller_start"": 480, ""file_path"": ""src/main/java/org/xerial/snappy/SnappyFramedOutputStream.java""}]}]","src/main/java/org/xerial/snappy/BitShuffle.java:59-61: Unchecked multiplication of input.length by data-type-specific multipliers (e.g., 4 for int) could overflow, resulting in undersized array allocations. The input variable is derived from a ByteBuffer in SnappyFramedOutputStream.writeCompressed (src/main/java/org/xerial/snappy/SnappyFramedOutputStream.java:504), which is populated by user-controlled data via the stream's internal buffer (src/main/java/org/xerial/snappy/SnappyFramedOutputStream.java:485). The buffer is filled by data written to the SnappyFramedOutputStream, making it user-controlled.",0.95,./github/other_context/CVE-2023-34453
39,CVE-2023-42298,CWE-190,c_cpp,An issue in GPAC GPAC v.2.2.1 and before allows a local attacker to cause a denial of service via the Q_DecCoordOnUnitSphere function of file src/bifs/unquantize.c.,https://github.com/gpac/gpac/commit/16c4fafc2881112eba7051cac48f922eb2b94e06,fix integer overflow issue in bifs/unquantize.c:298,1,"[{""func_name"": ""Q_DecCoordOnUnitSphere"", ""file_path"": ""src/bifs/unquantize.c"", ""func_code"": ""GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)\n{\n\tu32 i, orient, sign;\n\ts32 value;\n\tFixed tang[4], delta;\n\ts32 dir;\n\tif (NbBits>32) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;\n\n\t//only 2 or 3 comp in the quantized version\n\tdir = 1;\n\tif(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);\n\n\torient = gf_bs_read_int(bs, 2);\n\tif ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tfor(i=0; i<NbComp; i++) {\n\t\tvalue = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );\n\t\tsign = (value >= 0) ? 1 : -1;\n\t\tm_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);\n\t}\n\tdelta = 1;\n\tfor (i=0; i<NbComp; i++) {\n\t\ttang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );\n\t\tdelta += gf_mulfix(tang[i], tang[i]);\n\t}\n\tdelta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );\n\tm_ft[orient] = delta;\n\n\tfor (i=0; i<NbComp; i++) {\n\t\tm_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);\n\t}\n\treturn GF_OK;\n}"", ""target"": 0}]","[{""func_name"": ""Q_DecCoordOnUnitSphere"", ""file_path"": ""src/bifs/unquantize.c"", ""func_code"": ""GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)\n{\n\tu32 i, orient, sign;\n\ts32 value;\n\tFixed tang[4], delta;\n\ts32 dir;\n\tif (!NbBits || NbBits>32) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;\n\n\t//only 2 or 3 comp in the quantized version\n\tdir = 1;\n\tif(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);\n\n\torient = gf_bs_read_int(bs, 2);\n\tif ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tfor(i=0; i<NbComp; i++) {\n\t\tvalue = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );\n\t\tsign = (value >= 0) ? 1 : -1;\n\t\tm_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);\n\t}\n\tdelta = 1;\n\tfor (i=0; i<NbComp; i++) {\n\t\ttang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );\n\t\tdelta += gf_mulfix(tang[i], tang[i]);\n\t}\n\tdelta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );\n\tm_ft[orient] = delta;\n\n\tfor (i=0; i<NbComp; i++) {\n\t\tm_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);\n\t}\n\treturn GF_OK;\n}""}]","{""value"": 2, ""function"": 1, ""caller"": 1}","[{""source"": ""value_info(file:unquantize.c, value:NbBits)"", ""result"": {""value_trace"": [{""full_code"": ""NbBits = gf_bifs_dec_qp14_get_bits(codec)"", ""line"": 389, ""func_name"": ""gf_bifs_dec_unquant_field""}], ""struct_var"": ""NbBits"", ""struct_type"": ""u32"", ""struct_definition"": ""typedef unsigned int u32;\n\ntypedef unsigned int u32;\n\ntypedef uint32_t u32;""}}, {""source"": ""func_info(file:unquantize.c, func:gf_bifs_dec_qp14_get_bits)"", ""result"": [{""code"": ""u32 gf_bifs_dec_qp14_get_bits(GF_BifsDecoder *codec)\n{\n\tif (!codec->ActiveQP || !codec->coord_stored) return 0;\n\treturn (u32) ceil(log1p(codec->NumCoord) / log(2) );\n}"", ""start_line"": 32, ""end_line"": 36, ""full_name"": ""gf_bifs_dec_qp14_get_bits"", ""file_path"": ""src/bifs/unquantize.c""}]}, {""source"": ""value_info(file:unquantize.c, value:NumCoord)"", ""result"": {""value_trace"": [{""full_code"": ""codec->NumCoord = 0"", ""line"": 52, ""func_name"": ""gf_bifs_dec_qp14_reset""}, {""full_code"": ""codec->NumCoord = NbElements"", ""line"": 58, ""func_name"": ""gf_bifs_dec_qp14_set_length""}], ""struct_var"": ""NumCoord"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:unquantize.c, func:gf_bifs_dec_qp14_set_length)"", ""result"": [{""call_line"": 394, ""call_code"": ""gf_bifs_dec_qp14_set_length(codec, nbF)"", ""caller_code"": ""GF_Err BD_DecMFFieldList(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Node *new_node;\n\tGF_Err e=GF_OK;\n\tu8 endFlag, qp_local, qp_on, initial_qp;\n\tGF_ChildNodeItem *last = NULL;\n\tu32 nbF;\n\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tnbF = 0;\n\tqp_on = qp_local = 0;\n\tinitial_qp = codec->ActiveQP ? 1 : 0;\n\n\tendFlag = gf_bs_read_int(bs, 1);\n\twhile (!endFlag  && (codec->LastError>=0)) {\n\t\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\t\te = gf_sg_vrml_mf_append(field->far_ptr, field->fieldType, & sffield.far_ptr);\n\t\t\tif (e) goto exit;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) goto exit;\n\t\t} else {\n\t\t\tnew_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\t\t//append\n\t\t\tif (new_node) {\n\t\t\t\te = gf_node_register(..."", ""caller_start"": 302, ""file_path"": ""src/bifs/field_decode.c""}, {""call_line"": 422, ""call_code"": ""gf_bifs_dec_qp14_set_length(codec, nbFields)"", ""caller_code"": ""GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu32 NbBits, nbFields;\n\tu32 i;\n\tGF_ChildNodeItem *last;\n\tu8 qp_local, qp_on, initial_qp;\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tinitial_qp = qp_local = qp_on = 0;\n\n\t//vector description - alloc the MF size before\n\tNbBits = gf_bs_read_int(bs, 5);\n\tnbFields = gf_bs_read_int(bs, NbBits);\n\n\tif (codec->ActiveQP) {\n\t\tinitial_qp = 1;\n\t\t/*this is for QP 14*/\n\t\tgf_bifs_dec_qp14_set_length(codec, nbFields);\n\t}\n\n\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\te = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);\n\t\tif (e) return e;\n\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\te = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);\n\t\t\tif ..."", ""caller_start"": 398, ""file_path"": ""src/bifs/field_decode.c""}, {""call_line"": 783, ""call_code"": ""gf_bifs_dec_qp14_set_length(codec, nbCoord)"", ""caller_code"": ""GF_Node *gf_bifs_dec_node(GF_BifsDecoder * codec, GF_BitStream *bs, u32 NDT_Tag)\n{\n\tu32 nodeID, NDTBits, node_type, node_tag, ProtoID, BVersion;\n\tBool skip_init, reset_qp14;\n\tGF_Node *new_node;\n\tGF_Err e;\n\tGF_Proto *proto;\n\tvoid SetupConditional(GF_BifsDecoder *codec, GF_Node *node);\n\n\t//to store the UseName\n\tchar name[1000];\n\n#if 0\n\t/*should only happen with inputSensor, in which case this is BAAAAD*/\n\tif (!codec->info) {\n\t\tcodec->LastError = GF_BAD_PARAM;\n\t\treturn NULL;\n\t}\n#endif\n\n\n\tBVersion = GF_BIFS_V1;\n\n\t/*this is a USE statement*/\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tnodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\t/*NULL node is encoded as USE with ID = all bits to 1*/\n\t\tif (nodeID == (u32) (1<<codec->info->config.NodeIDBits))\n\t\t\treturn NULL;\n\t\t//find node\n\t\tnew_node = gf_sg_find_node(codec->current_graph, nodeID);\n\n\t\t//check node is allowed for the given NDT\n\t\tif (new_node && !gf_node_in_table(new_node, NDT_Tag)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[BIFS]..."", ""caller_start"": 735, ""file_path"": ""src/bifs/field_decode.c""}]}]","The vulnerability arises from unvalidated `NbBits` in `Q_DecCoordOnUnitSphere` (src/bifs/unquantize.c:298). The patch (src/bifs/unquantize.c:298) adds a check for `!NbBits || NbBits>32` to reject invalid values. `NbBits` is derived from `gf_bifs_dec_qp14_get_bits(codec)` (src/bifs/unquantize.c:389), which calculates `ceil(log1p(codec->NumCoord)/log(2))`. `codec->NumCoord` is set via `gf_bifs_dec_qp14_set_length(codec, NbElements)` (src/bifs/unquantize.c:58), where `NbElements` is user-controlled input parsed from the bitstream (e.g., `nbFields = gf_bs_read_int(bs, NbBits)` in `BD_DecMFFieldVec` at src/bifs/field_decode.c:398). This chain confirms that invalid `NbBits` values (0 or >32) originate from user input, leading to a denial of service.",1.0,./github/other_context/CVE-2023-42298
40,CVE-2023-36328,CWE-190,c_cpp,"Integer Overflow vulnerability in mp_grow in libtom libtommath before commit beba892bc0d4e4ded4d667ab1d2a94f4d75109a9, allows attackers to execute arbitrary code and cause a denial of service (DoS).",https://github.com/libtom/libtommath/commit/beba892bc0d4e4ded4d667ab1d2a94f4d75109a9,Fix possible integer overflow,8,"[{""func_name"": ""s_mp_mul_high_digs"", ""file_path"": ""bn_s_mp_mul_high_digs.c"", ""func_code"": ""mp_err s_mp_mul_high_digs(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   mp_int   t;\n   int      pa, pb, ix, iy;\n   mp_err   err;\n   mp_digit u;\n   mp_word  r;\n   mp_digit tmpx, *tmpt, *tmpy;\n\n   /* can we use the fast multiplier? */\n   if (MP_HAS(S_MP_MUL_HIGH_DIGS_FAST)\n       && ((a->used + b->used + 1) < MP_WARRAY)\n       && (MP_MIN(a->used, b->used) < MP_MAXFAST)) {\n      return s_mp_mul_high_digs_fast(a, b, c, digs);\n   }\n\n   if ((err = mp_init_size(&t, a->used + b->used + 1)) != MP_OKAY) {\n      return err;\n   }\n   t.used = a->used + b->used + 1;\n\n   pa = a->used;\n   pb = b->used;\n   for (ix = 0; ix < pa; ix++) {\n      /* clear the carry */\n      u = 0;\n\n      /* left hand side of A[ix] * B[iy] */\n      tmpx = a->dp[ix];\n\n      /* alias to the address of where the digits will be stored */\n      tmpt = &(t.dp[digs]);\n\n      /* alias for where to read the right hand side from */\n      tmpy = b->dp + (digs - ix);\n\n      for (iy = digs - ix; iy < pb; iy++) {\n         /* calculate the double precision result */\n         r       = (mp_word)*tmpt +\n                   ((mp_word)tmpx * (mp_word)*tmpy++) +\n                   (mp_word)u;\n\n         /* get the lower part */\n         *tmpt++ = (mp_digit)(r & (mp_word)MP_MASK);\n\n         /* carry the carry */\n         u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT);\n      }\n      *tmpt = u;\n   }\n   mp_clamp(&t);\n   mp_exch(&t, c);\n   mp_clear(&t);\n   return MP_OKAY;\n}"", ""target"": 0}, {""func_name"": ""mp_2expt"", ""file_path"": ""bn_mp_2expt.c"", ""func_code"": ""mp_err mp_2expt(mp_int *a, int b)\n{\n   mp_err    err;\n\n   /* zero a as per default */\n   mp_zero(a);\n\n   /* grow a to accomodate the single bit */\n   if ((err = mp_grow(a, (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) {\n      return err;\n   }\n\n   /* set the used count of where the bit will go */\n   a->used = (b / MP_DIGIT_BIT) + 1;\n\n   /* put the single bit in its place */\n   a->dp[b / MP_DIGIT_BIT] = (mp_digit)1 << (mp_digit)(b % MP_DIGIT_BIT);\n\n   return MP_OKAY;\n}"", ""target"": 0}, {""func_name"": ""s_mp_mul_digs_fast"", ""file_path"": ""bn_s_mp_mul_digs_fast.c"", ""func_code"": ""mp_err s_mp_mul_digs_fast(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   int      olduse, pa, ix, iz;\n   mp_err   err;\n   mp_digit W[MP_WARRAY];\n   mp_word  _W;\n\n   /* grow the destination as required */\n   if (c->alloc < digs) {\n      if ((err = mp_grow(c, digs)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* number of output digits to produce */\n   pa = MP_MIN(digs, a->used + b->used);\n\n   /* clear the carry */\n   _W = 0;\n   for (ix = 0; ix < pa; ix++) {\n      int      tx, ty;\n      int      iy;\n      mp_digit *tmpx, *tmpy;\n\n      /* get offsets into the two bignums */\n      ty = MP_MIN(b->used-1, ix);\n      tx = ix - ty;\n\n      /* setup temp aliases */\n      tmpx = a->dp + tx;\n      tmpy = b->dp + ty;\n\n      /* this is the number of times the loop will iterrate, essentially\n         while (tx++ < a->used && ty-- >= 0) { ... }\n       */\n      iy = MP_MIN(a->used-tx, ty+1);\n\n      /* execute loop */\n      for (iz = 0; iz < iy; ++iz) {\n         _W += (mp_word)*tmpx++ * (mp_word)*tmpy--;\n\n      }\n\n      /* store term */\n      W[ix] = (mp_digit)_W & MP_MASK;\n\n      /* make next carry */\n      _W = _W >> (mp_word)MP_DIGIT_BIT;\n   }\n\n   /* setup dest */\n   olduse  = c->used;\n   c->used = pa;\n\n   {\n      mp_digit *tmpc;\n      tmpc = c->dp;\n      for (ix = 0; ix < pa; ix++) {\n         /* now extract the previous digit [below the carry] */\n         *tmpc++ = W[ix];\n      }\n\n      /* clear unused digits [that existed in the old copy of c] */\n      MP_ZERO_DIGITS(tmpc, olduse - ix);\n   }\n   mp_clamp(c);\n   return MP_OKAY;\n}"", ""target"": 0}, {""func_name"": ""s_mp_mul_high_digs_fast"", ""file_path"": ""bn_s_mp_mul_high_digs_fast.c"", ""func_code"": ""mp_err s_mp_mul_high_digs_fast(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   int     olduse, pa, ix, iz;\n   mp_err   err;\n   mp_digit W[MP_WARRAY];\n   mp_word  _W;\n\n   /* grow the destination as required */\n   pa = a->used + b->used;\n   if (c->alloc < pa) {\n      if ((err = mp_grow(c, pa)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* number of output digits to produce */\n   pa = a->used + b->used;\n   _W = 0;\n   for (ix = digs; ix < pa; ix++) {\n      int      tx, ty, iy;\n      mp_digit *tmpx, *tmpy;\n\n      /* get offsets into the two bignums */\n      ty = MP_MIN(b->used-1, ix);\n      tx = ix - ty;\n\n      /* setup temp aliases */\n      tmpx = a->dp + tx;\n      tmpy = b->dp + ty;\n\n      /* this is the number of times the loop will iterrate, essentially its\n         while (tx++ < a->used && ty-- >= 0) { ... }\n       */\n      iy = MP_MIN(a->used-tx, ty+1);\n\n      /* execute loop */\n      for (iz = 0; iz < iy; iz++) {\n         _W += (mp_word)*tmpx++ * (mp_word)*tmpy--;\n      }\n\n      /* store term */\n      W[ix] = (mp_digit)_W & MP_MASK;\n\n      /* make next carry */\n      _W = _W >> (mp_word)MP_DIGIT_BIT;\n   }\n\n   /* setup dest */\n   olduse  = c->used;\n   c->used = pa;\n\n   {\n      mp_digit *tmpc;\n\n      tmpc = c->dp + digs;\n      for (ix = digs; ix < pa; ix++) {\n         /* now extract the previous digit [below the carry] */\n         *tmpc++ = W[ix];\n      }\n\n      /* clear unused digits [that existed in the old copy of c] */\n      MP_ZERO_DIGITS(tmpc, olduse - ix);\n   }\n   mp_clamp(c);\n   return MP_OKAY;\n}"", ""target"": 0}, {""func_name"": ""mp_grow"", ""file_path"": ""bn_mp_grow.c"", ""func_code"": ""mp_err mp_grow(mp_int *a, int size)\n{\n   int     i;\n   mp_digit *tmp;\n\n   /* if the alloc size is smaller alloc more ram */\n   if (a->alloc < size) {\n      /* reallocate the array a->dp\n       *\n       * We store the return in a temporary variable\n       * in case the operation failed we don't want\n       * to overwrite the dp member of a.\n       */\n      tmp = (mp_digit *) MP_REALLOC(a->dp,\n                                    (size_t)a->alloc * sizeof(mp_digit),\n                                    (size_t)size * sizeof(mp_digit));\n      if (tmp == NULL) {\n         /* reallocation failed but \""a\"" is still valid [can be freed] */\n         return MP_MEM;\n      }\n\n      /* reallocation succeeded so set a->dp */\n      a->dp = tmp;\n\n      /* zero excess digits */\n      i        = a->alloc;\n      a->alloc = size;\n      MP_ZERO_DIGITS(a->dp + i, a->alloc - i);\n   }\n   return MP_OKAY;\n}"", ""target"": 0}, {""func_name"": ""s_mp_mul_digs"", ""file_path"": ""bn_s_mp_mul_digs.c"", ""func_code"": ""mp_err s_mp_mul_digs(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   mp_int  t;\n   mp_err  err;\n   int     pa, pb, ix, iy;\n   mp_digit u;\n   mp_word r;\n   mp_digit tmpx, *tmpt, *tmpy;\n\n   /* can we use the fast multiplier? */\n   if ((digs < MP_WARRAY) &&\n       (MP_MIN(a->used, b->used) < MP_MAXFAST)) {\n      return s_mp_mul_digs_fast(a, b, c, digs);\n   }\n\n   if ((err = mp_init_size(&t, digs)) != MP_OKAY) {\n      return err;\n   }\n   t.used = digs;\n\n   /* compute the digits of the product directly */\n   pa = a->used;\n   for (ix = 0; ix < pa; ix++) {\n      /* set the carry to zero */\n      u = 0;\n\n      /* limit ourselves to making digs digits of output */\n      pb = MP_MIN(b->used, digs - ix);\n\n      /* setup some aliases */\n      /* copy of the digit from a used within the nested loop */\n      tmpx = a->dp[ix];\n\n      /* an alias for the destination shifted ix places */\n      tmpt = t.dp + ix;\n\n      /* an alias for the digits of b */\n      tmpy = b->dp;\n\n      /* compute the columns of the output and propagate the carry */\n      for (iy = 0; iy < pb; iy++) {\n         /* compute the column as a mp_word */\n         r       = (mp_word)*tmpt +\n                   ((mp_word)tmpx * (mp_word)*tmpy++) +\n                   (mp_word)u;\n\n         /* the new column is the lower part of the result */\n         *tmpt++ = (mp_digit)(r & (mp_word)MP_MASK);\n\n         /* get the carry word from the result */\n         u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT);\n      }\n      /* set carry if it is placed below digs */\n      if ((ix + iy) < digs) {\n         *tmpt = u;\n      }\n   }\n\n   mp_clamp(&t);\n   mp_exch(&t, c);\n\n   mp_clear(&t);\n   return MP_OKAY;\n}"", ""target"": 0}, {""func_name"": ""mp_mul_2d"", ""file_path"": ""bn_mp_mul_2d.c"", ""func_code"": ""mp_err mp_mul_2d(const mp_int *a, int b, mp_int *c)\n{\n   mp_digit d;\n   mp_err   err;\n\n   /* copy */\n   if (a != c) {\n      if ((err = mp_copy(a, c)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   if (c->alloc < (c->used + (b / MP_DIGIT_BIT) + 1)) {\n      if ((err = mp_grow(c, c->used + (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* shift by as many digits in the bit count */\n   if (b >= MP_DIGIT_BIT) {\n      if ((err = mp_lshd(c, b / MP_DIGIT_BIT)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* shift any bit count < MP_DIGIT_BIT */\n   d = (mp_digit)(b % MP_DIGIT_BIT);\n   if (d != 0u) {\n      mp_digit *tmpc, shift, mask, r, rr;\n      int x;\n\n      /* bitmask for carries */\n      mask = ((mp_digit)1 << d) - (mp_digit)1;\n\n      /* shift for msbs */\n      shift = (mp_digit)MP_DIGIT_BIT - d;\n\n      /* alias */\n      tmpc = c->dp;\n\n      /* carry */\n      r    = 0;\n      for (x = 0; x < c->used; x++) {\n         /* get the higher bits of the current word */\n         rr = (*tmpc >> shift) & mask;\n\n         /* shift the current word and OR in the carry */\n         *tmpc = ((*tmpc << d) | r) & MP_MASK;\n         ++tmpc;\n\n         /* set the carry to the carry bits of the current word */\n         r = rr;\n      }\n\n      /* set final carry */\n      if (r != 0u) {\n         c->dp[(c->used)++] = r;\n      }\n   }\n   mp_clamp(c);\n   return MP_OKAY;\n}"", ""target"": 0}, {""func_name"": ""mp_init_size"", ""file_path"": ""bn_mp_init_size.c"", ""func_code"": ""mp_err mp_init_size(mp_int *a, int size)\n{\n   size = MP_MAX(MP_MIN_PREC, size);\n\n   /* alloc mem */\n   a->dp = (mp_digit *) MP_CALLOC((size_t)size, sizeof(mp_digit));\n   if (a->dp == NULL) {\n      return MP_MEM;\n   }\n\n   /* set the members */\n   a->used  = 0;\n   a->alloc = size;\n   a->sign  = MP_ZPOS;\n\n   return MP_OKAY;\n}"", ""target"": 0}]","[{""func_name"": ""s_mp_mul_high_digs"", ""file_path"": ""bn_s_mp_mul_high_digs.c"", ""func_code"": ""mp_err s_mp_mul_high_digs(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   mp_int   t;\n   int      pa, pb, ix, iy;\n   mp_err   err;\n   mp_digit u;\n   mp_word  r;\n   mp_digit tmpx, *tmpt, *tmpy;\n\n   if (digs < 0) {\n      return MP_VAL;\n   }\n\n   /* can we use the fast multiplier? */\n   if (MP_HAS(S_MP_MUL_HIGH_DIGS_FAST)\n       && ((a->used + b->used + 1) < MP_WARRAY)\n       && (MP_MIN(a->used, b->used) < MP_MAXFAST)) {\n      return s_mp_mul_high_digs_fast(a, b, c, digs);\n   }\n\n   if ((err = mp_init_size(&t, a->used + b->used + 1)) != MP_OKAY) {\n      return err;\n   }\n   t.used = a->used + b->used + 1;\n\n   pa = a->used;\n   pb = b->used;\n   for (ix = 0; ix < pa; ix++) {\n      /* clear the carry */\n      u = 0;\n\n      /* left hand side of A[ix] * B[iy] */\n      tmpx = a->dp[ix];\n\n      /* alias to the address of where the digits will be stored */\n      tmpt = &(t.dp[digs]);\n\n      /* alias for where to read the right hand side from */\n      tmpy = b->dp + (digs - ix);\n\n      for (iy = digs - ix; iy < pb; iy++) {\n         /* calculate the double precision result */\n         r       = (mp_word)*tmpt +\n                   ((mp_word)tmpx * (mp_word)*tmpy++) +\n                   (mp_word)u;\n\n         /* get the lower part */\n         *tmpt++ = (mp_digit)(r & (mp_word)MP_MASK);\n\n         /* carry the carry */\n         u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT);\n      }\n      *tmpt = u;\n   }\n   mp_clamp(&t);\n   mp_exch(&t, c);\n   mp_clear(&t);\n   return MP_OKAY;\n}""}, {""func_name"": ""mp_2expt"", ""file_path"": ""bn_mp_2expt.c"", ""func_code"": ""mp_err mp_2expt(mp_int *a, int b)\n{\n   mp_err    err;\n\n   if (b < 0) {\n      return MP_VAL;\n   }\n\n   /* zero a as per default */\n   mp_zero(a);\n\n   /* grow a to accomodate the single bit */\n   if ((err = mp_grow(a, (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) {\n      return err;\n   }\n\n   /* set the used count of where the bit will go */\n   a->used = (b / MP_DIGIT_BIT) + 1;\n\n   /* put the single bit in its place */\n   a->dp[b / MP_DIGIT_BIT] = (mp_digit)1 << (mp_digit)(b % MP_DIGIT_BIT);\n\n   return MP_OKAY;\n}""}, {""func_name"": ""s_mp_mul_digs_fast"", ""file_path"": ""bn_s_mp_mul_digs_fast.c"", ""func_code"": ""mp_err s_mp_mul_digs_fast(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   int      olduse, pa, ix, iz;\n   mp_err   err;\n   mp_digit W[MP_WARRAY];\n   mp_word  _W;\n\n   if (digs < 0) {\n      return MP_VAL;\n   }\n\n   /* grow the destination as required */\n   if (c->alloc < digs) {\n      if ((err = mp_grow(c, digs)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* number of output digits to produce */\n   pa = MP_MIN(digs, a->used + b->used);\n\n   /* clear the carry */\n   _W = 0;\n   for (ix = 0; ix < pa; ix++) {\n      int      tx, ty;\n      int      iy;\n      mp_digit *tmpx, *tmpy;\n\n      /* get offsets into the two bignums */\n      ty = MP_MIN(b->used-1, ix);\n      tx = ix - ty;\n\n      /* setup temp aliases */\n      tmpx = a->dp + tx;\n      tmpy = b->dp + ty;\n\n      /* this is the number of times the loop will iterrate, essentially\n         while (tx++ < a->used && ty-- >= 0) { ... }\n       */\n      iy = MP_MIN(a->used-tx, ty+1);\n\n      /* execute loop */\n      for (iz = 0; iz < iy; ++iz) {\n         _W += (mp_word)*tmpx++ * (mp_word)*tmpy--;\n\n      }\n\n      /* store term */\n      W[ix] = (mp_digit)_W & MP_MASK;\n\n      /* make next carry */\n      _W = _W >> (mp_word)MP_DIGIT_BIT;\n   }\n\n   /* setup dest */\n   olduse  = c->used;\n   c->used = pa;\n\n   {\n      mp_digit *tmpc;\n      tmpc = c->dp;\n      for (ix = 0; ix < pa; ix++) {\n         /* now extract the previous digit [below the carry] */\n         *tmpc++ = W[ix];\n      }\n\n      /* clear unused digits [that existed in the old copy of c] */\n      MP_ZERO_DIGITS(tmpc, olduse - ix);\n   }\n   mp_clamp(c);\n   return MP_OKAY;\n}""}, {""func_name"": ""s_mp_mul_high_digs_fast"", ""file_path"": ""bn_s_mp_mul_high_digs_fast.c"", ""func_code"": ""mp_err s_mp_mul_high_digs_fast(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   int     olduse, pa, ix, iz;\n   mp_err   err;\n   mp_digit W[MP_WARRAY];\n   mp_word  _W;\n\n   if (digs < 0) {\n      return MP_VAL;\n   }\n\n   /* grow the destination as required */\n   pa = a->used + b->used;\n   if (c->alloc < pa) {\n      if ((err = mp_grow(c, pa)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* number of output digits to produce */\n   pa = a->used + b->used;\n   _W = 0;\n   for (ix = digs; ix < pa; ix++) {\n      int      tx, ty, iy;\n      mp_digit *tmpx, *tmpy;\n\n      /* get offsets into the two bignums */\n      ty = MP_MIN(b->used-1, ix);\n      tx = ix - ty;\n\n      /* setup temp aliases */\n      tmpx = a->dp + tx;\n      tmpy = b->dp + ty;\n\n      /* this is the number of times the loop will iterrate, essentially its\n         while (tx++ < a->used && ty-- >= 0) { ... }\n       */\n      iy = MP_MIN(a->used-tx, ty+1);\n\n      /* execute loop */\n      for (iz = 0; iz < iy; iz++) {\n         _W += (mp_word)*tmpx++ * (mp_word)*tmpy--;\n      }\n\n      /* store term */\n      W[ix] = (mp_digit)_W & MP_MASK;\n\n      /* make next carry */\n      _W = _W >> (mp_word)MP_DIGIT_BIT;\n   }\n\n   /* setup dest */\n   olduse  = c->used;\n   c->used = pa;\n\n   {\n      mp_digit *tmpc;\n\n      tmpc = c->dp + digs;\n      for (ix = digs; ix < pa; ix++) {\n         /* now extract the previous digit [below the carry] */\n         *tmpc++ = W[ix];\n      }\n\n      /* clear unused digits [that existed in the old copy of c] */\n      MP_ZERO_DIGITS(tmpc, olduse - ix);\n   }\n   mp_clamp(c);\n   return MP_OKAY;\n}""}, {""func_name"": ""mp_grow"", ""file_path"": ""bn_mp_grow.c"", ""func_code"": ""mp_err mp_grow(mp_int *a, int size)\n{\n   int     i;\n   mp_digit *tmp;\n\n   if (size < 0) {\n      return MP_VAL;\n   }\n\n   /* if the alloc size is smaller alloc more ram */\n   if (a->alloc < size) {\n      /* reallocate the array a->dp\n       *\n       * We store the return in a temporary variable\n       * in case the operation failed we don't want\n       * to overwrite the dp member of a.\n       */\n      tmp = (mp_digit *) MP_REALLOC(a->dp,\n                                    (size_t)a->alloc * sizeof(mp_digit),\n                                    (size_t)size * sizeof(mp_digit));\n      if (tmp == NULL) {\n         /* reallocation failed but \""a\"" is still valid [can be freed] */\n         return MP_MEM;\n      }\n\n      /* reallocation succeeded so set a->dp */\n      a->dp = tmp;\n\n      /* zero excess digits */\n      i        = a->alloc;\n      a->alloc = size;\n      MP_ZERO_DIGITS(a->dp + i, a->alloc - i);\n   }\n   return MP_OKAY;\n}""}, {""func_name"": ""s_mp_mul_digs"", ""file_path"": ""bn_s_mp_mul_digs.c"", ""func_code"": ""mp_err s_mp_mul_digs(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   mp_int  t;\n   mp_err  err;\n   int     pa, pb, ix, iy;\n   mp_digit u;\n   mp_word r;\n   mp_digit tmpx, *tmpt, *tmpy;\n\n   if (digs < 0) {\n      return MP_VAL;\n   }\n\n   /* can we use the fast multiplier? */\n   if ((digs < MP_WARRAY) &&\n       (MP_MIN(a->used, b->used) < MP_MAXFAST)) {\n      return s_mp_mul_digs_fast(a, b, c, digs);\n   }\n\n   if ((err = mp_init_size(&t, digs)) != MP_OKAY) {\n      return err;\n   }\n   t.used = digs;\n\n   /* compute the digits of the product directly */\n   pa = a->used;\n   for (ix = 0; ix < pa; ix++) {\n      /* set the carry to zero */\n      u = 0;\n\n      /* limit ourselves to making digs digits of output */\n      pb = MP_MIN(b->used, digs - ix);\n\n      /* setup some aliases */\n      /* copy of the digit from a used within the nested loop */\n      tmpx = a->dp[ix];\n\n      /* an alias for the destination shifted ix places */\n      tmpt = t.dp + ix;\n\n      /* an alias for the digits of b */\n      tmpy = b->dp;\n\n      /* compute the columns of the output and propagate the carry */\n      for (iy = 0; iy < pb; iy++) {\n         /* compute the column as a mp_word */\n         r       = (mp_word)*tmpt +\n                   ((mp_word)tmpx * (mp_word)*tmpy++) +\n                   (mp_word)u;\n\n         /* the new column is the lower part of the result */\n         *tmpt++ = (mp_digit)(r & (mp_word)MP_MASK);\n\n         /* get the carry word from the result */\n         u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT);\n      }\n      /* set carry if it is placed below digs */\n      if ((ix + iy) < digs) {\n         *tmpt = u;\n      }\n   }\n\n   mp_clamp(&t);\n   mp_exch(&t, c);\n\n   mp_clear(&t);\n   return MP_OKAY;\n}""}, {""func_name"": ""mp_mul_2d"", ""file_path"": ""bn_mp_mul_2d.c"", ""func_code"": ""mp_err mp_mul_2d(const mp_int *a, int b, mp_int *c)\n{\n   mp_digit d;\n   mp_err   err;\n\n   if (b < 0) {\n      return MP_VAL;\n   }\n\n   /* copy */\n   if (a != c) {\n      if ((err = mp_copy(a, c)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   if (c->alloc < (c->used + (b / MP_DIGIT_BIT) + 1)) {\n      if ((err = mp_grow(c, c->used + (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* shift by as many digits in the bit count */\n   if (b >= MP_DIGIT_BIT) {\n      if ((err = mp_lshd(c, b / MP_DIGIT_BIT)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* shift any bit count < MP_DIGIT_BIT */\n   d = (mp_digit)(b % MP_DIGIT_BIT);\n   if (d != 0u) {\n      mp_digit *tmpc, shift, mask, r, rr;\n      int x;\n\n      /* bitmask for carries */\n      mask = ((mp_digit)1 << d) - (mp_digit)1;\n\n      /* shift for msbs */\n      shift = (mp_digit)MP_DIGIT_BIT - d;\n\n      /* alias */\n      tmpc = c->dp;\n\n      /* carry */\n      r    = 0;\n      for (x = 0; x < c->used; x++) {\n         /* get the higher bits of the current word */\n         rr = (*tmpc >> shift) & mask;\n\n         /* shift the current word and OR in the carry */\n         *tmpc = ((*tmpc << d) | r) & MP_MASK;\n         ++tmpc;\n\n         /* set the carry to the carry bits of the current word */\n         r = rr;\n      }\n\n      /* set final carry */\n      if (r != 0u) {\n         c->dp[(c->used)++] = r;\n      }\n   }\n   mp_clamp(c);\n   return MP_OKAY;\n}""}, {""func_name"": ""mp_init_size"", ""file_path"": ""bn_mp_init_size.c"", ""func_code"": ""mp_err mp_init_size(mp_int *a, int size)\n{\n\n   if (size < 0) {\n      return MP_VAL;\n   }\n\n   size = MP_MAX(MP_MIN_PREC, size);\n\n   /* alloc mem */\n   a->dp = (mp_digit *) MP_CALLOC((size_t)size, sizeof(mp_digit));\n   if (a->dp == NULL) {\n      return MP_MEM;\n   }\n\n   /* set the members */\n   a->used  = 0;\n   a->alloc = size;\n   a->sign  = MP_ZPOS;\n\n   return MP_OKAY;\n}""}]","{""caller"": 2, ""value"": 1}","[{""source"": ""caller_info(file:bn_mp_grow.c, func:mp_grow)"", ""result"": [{""call_line"": 19, ""call_code"": ""mp_grow(a, (b / MP_DIGIT_BIT) + 1)"", ""caller_code"": ""mp_err mp_2expt(mp_int *a, int b)\n{\n   mp_err    err;\n\n   /* zero a as per default */\n   mp_zero(a);\n\n   /* grow a to accomodate the single bit */\n   if ((err = mp_grow(a, (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) {\n      return err;\n   }\n\n   /* set the used count of where the bit will go */\n   a->used = (b / MP_DIGIT_BIT) + 1;\n\n   /* put the single bit in its place */\n   a->dp[b / MP_DIGIT_BIT] = (mp_digit)1 << (mp_digit)(b % MP_DIGIT_BIT);\n\n   return MP_OKAY;\n}"", ""caller_start"": 11, ""file_path"": ""bn_mp_2expt.c""}, {""call_line"": 15, ""call_code"": ""mp_grow(c, a->used + 1)"", ""caller_code"": ""mp_err mp_add_d(const mp_int *a, mp_digit b, mp_int *c)\n{\n   mp_err     err;\n   int ix, oldused;\n   mp_digit *tmpa, *tmpc;\n\n   /* grow c as required */\n   if (c->alloc < (a->used + 1)) {\n      if ((err = mp_grow(c, a->used + 1)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* if a is negative and |a| >= b, call c = |a| - b */\n   if ((a->sign == MP_NEG) && ((a->used > 1) || (a->dp[0] >= b))) {\n      mp_int a_ = *a;\n      /* temporarily fix sign of a */\n      a_.sign = MP_ZPOS;\n\n      /* c = |a| - b */\n      err = mp_sub_d(&a_, b, c);\n\n      /* fix sign  */\n      c->sign = MP_NEG;\n\n      /* clamp */\n      mp_clamp(c);\n\n      return err;\n   }\n\n   /* old number of used digits in c */\n   oldused = c->used;\n\n   /* source alias */\n   tmpa    = a->dp;\n\n   /* destination alias */\n   tmpc    = c->dp;\n\n   /* if a is positive */\n   if (a->sign == MP_ZPOS) {\n      /* add digits, mu is carry */\n      mp_digit mu = b;\n      for (ix = 0; ix < a->used; ix++) {\n         *tmpc   = *tmpa++ + mu;\n         mu      = *tmpc >> MP_DIGIT_BIT;\n         *tmpc++ &= MP_MASK;\n      }\n      /* set final carry */\n      ix++;\n      *tmpc++  = mu;\n\n      /* setup size */\n      c->used = a->used + 1;\n   } else {\n      /* a was negative and |a| < b */\n      c->used  = 1;\n\n      /* the result is a single digit */\n      if (a->used == 1) {\n         *tmpc++  =  b - a->dp[0];\n      } else {\n         *tmpc++  =  b;\n      }\n\n      /* setup count so the clearing of oldused\n       * can fall through correctly\n       */\n      ix       = 1;\n   }\n\n   /* sign always positive */\n   c->sign = MP_ZPOS;\n\n   /* now zero to oldused */\n   MP_ZERO_DIGITS(tmpc, oldused - ix);\n   mp_clamp(c);\n\n   return MP_OKAY;\n}\n"", ""caller_start"": 7, ""file_path"": ""bn_mp_add_d.c""}, {""call_line"": 15, ""call_code"": ""mp_grow(c, used)"", ""caller_code"": ""mp_err mp_and(const mp_int *a, const mp_int *b, mp_int *c)\n{\n   int used = MP_MAX(a->used, b->used) + 1, i;\n   mp_err err;\n   mp_digit ac = 1, bc = 1, cc = 1;\n   mp_sign csign = ((a->sign == MP_NEG) && (b->sign == MP_NEG)) ? MP_NEG : MP_ZPOS;\n\n   if (c->alloc < used) {\n      if ((err = mp_grow(c, used)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   for (i = 0; i < used; i++) {\n      mp_digit x, y;\n\n      /* convert to two complement if negative */\n      if (a->sign == MP_NEG) {\n         ac += (i >= a->used) ? MP_MASK : (~a->dp[i] & MP_MASK);\n         x = ac & MP_MASK;\n         ac >>= MP_DIGIT_BIT;\n      } else {\n         x = (i >= a->used) ? 0uL : a->dp[i];\n      }\n\n      /* convert to two complement if negative */\n      if (b->sign == MP_NEG) {\n         bc += (i >= b->used) ? MP_MASK : (~b->dp[i] & MP_MASK);\n         y = bc & MP_MASK;\n         bc >>= MP_DIGIT_BIT;\n      } else {\n         y = (i >= b->used) ? 0uL : b->dp[i];\n      }\n\n      c->dp[i] = x & y;\n\n      /* convert to to sign-magnitude if negative */\n      if (csign == MP_NEG) {\n         cc += ~c->dp[i] & MP_MASK;\n         c->dp[i] = cc & MP_MASK;\n         cc >>= MP_DIGIT_BIT;\n      }\n   }\n\n   c->used = used;\n   c->sign = csign;\n   mp_clamp(c);\n   return MP_OKAY;\n}\n"", ""caller_start"": 7, ""file_path"": ""bn_mp_and.c""}, {""call_line"": 20, ""call_code"": ""mp_grow(b, a->used)"", ""caller_code"": ""mp_err mp_copy(const mp_int *a, mp_int *b)\n{\n   int n;\n   mp_digit *tmpa, *tmpb;\n   mp_err err;\n\n   /* if dst == src do nothing */\n   if (a == b) {\n      return MP_OKAY;\n   }\n\n   /* grow dest */\n   if (b->alloc < a->used) {\n      if ((err = mp_grow(b, a->used)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* zero b and copy the parameters over */\n   /* pointer aliases */\n\n   /* source */\n   tmpa = a->dp;\n\n   /* destination */\n   tmpb = b->dp;\n\n   /* copy all the digits */\n   for (n = 0; n < a->used; n++) {\n      *tmpb++ = *tmpa++;\n   }\n\n   /* clear high digits */\n   MP_ZERO_DIGITS(tmpb, b->used - n);\n\n   /* copy used count and sign */\n   b->used = a->used;\n   b->sign = a->sign;\n   return MP_OKAY;\n}"", ""caller_start"": 7, ""file_path"": ""bn_mp_copy.c""}]}, {""source"": ""caller_info(file:bn_s_mp_mul_digs.c, func:s_mp_mul_digs)"", ""result"": [{""call_line"": 45, ""call_code"": ""s_mp_mul_digs(a, b, c, digs)"", ""caller_code"": ""mp_err mp_mul(const mp_int *a, const mp_int *b, mp_int *c)\n{\n   mp_err err;\n   int min_len = MP_MIN(a->used, b->used),\n       max_len = MP_MAX(a->used, b->used),\n       digs = a->used + b->used + 1;\n   mp_sign neg = (a->sign == b->sign) ? MP_ZPOS : MP_NEG;\n\n   if (MP_HAS(S_MP_BALANCE_MUL) &&\n       /* Check sizes. The smaller one needs to be larger than the Karatsuba cut-off.\n        * The bigger one needs to be at least about one MP_KARATSUBA_MUL_CUTOFF bigger\n        * to make some sense, but it depends on architecture, OS, position of the\n        * stars... so YMMV.\n        * Using it to cut the input into slices small enough for fast_s_mp_mul_digs\n        * was actually slower on the author's machine, but YMMV.\n        */\n       (min_len >= MP_KARATSUBA_MUL_CUTOFF) &&\n       ((max_len / 2) >= MP_KARATSUBA_MUL_CUTOFF) &&\n       /* Not much effect was observed below a ratio of 1:2, but again: YMMV. */\n       (max_len >= (2 * min_len))) {\n      err = s_mp_balance_mul(a,b,c);\n   } else if (MP_HAS(S_MP_TOOM_MUL) &&\n              (min_len >= MP_TOOM_MUL_CUTOFF)) {\n      err = s_mp_toom_mul(a, b, c);\n   } else if (MP_HAS(S_MP_KARATSUBA_MUL) &&\n              (min_len >= MP_KARATSUBA_MUL_CUTOFF)) {\n      err = s_mp_karatsuba_mul(a, b, c);\n   } else if (MP_HAS(S_MP_MUL_DIGS_FAST) &&\n              /* can we use the fast multiplier?\n               *\n               * The fast multiplier can be used if the output will\n               * have less than MP_WARRAY digits and the number of\n               * digits won't affect carry propagation\n               */\n              (digs < MP_WARRAY) &&\n              (min_len <= MP_MAXFAST)) {\n      err = s_mp_mul_digs_fast(a, b, c, digs);\n   } else if (MP_HAS(S_MP_MUL_DIGS)) {\n      err = s_mp_mul_digs(a, b, c, digs);\n   } else {\n      err = MP_VAL;\n   }\n   c->sign = (c->used > 0) ? neg : MP_ZPOS;\n   return err;\n}\n"", ""caller_start"": 7, ""file_path"": ""bn_mp_mul.c""}, {""call_line"": 51, ""call_code"": ""s_mp_mul_digs(&q, m, &q, um + 1)"", ""caller_code"": ""mp_err mp_reduce(mp_int *x, const mp_int *m, const mp_int *mu)\n{\n   mp_int  q;\n   mp_err  err;\n   int     um = m->used;\n\n   /* q = x */\n   if ((err = mp_init_copy(&q, x)) != MP_OKAY) {\n      return err;\n   }\n\n   /* q1 = x / b**(k-1)  */\n   mp_rshd(&q, um - 1);\n\n   /* according to HAC this optimization is ok */\n   if ((mp_digit)um > ((mp_digit)1 << (MP_DIGIT_BIT - 1))) {\n      if ((err = mp_mul(&q, mu, &q)) != MP_OKAY) {\n         goto CLEANUP;\n      }\n   } else if (MP_HAS(S_MP_MUL_HIGH_DIGS)) {\n      if ((err = s_mp_mul_high_digs(&q, mu, &q, um)) != MP_OKAY) {\n         goto CLEANUP;\n      }\n   } else if (MP_HAS(S_MP_MUL_HIGH_DIGS_FAST)) {\n      if ((err = s_mp_mul_high_digs_fast(&q, mu, &q, um)) != MP_OKAY) {\n         goto CLEANUP;\n      }\n   } else {\n      err = MP_VAL;\n      goto CLEANUP;\n   }\n\n   /* q3 = q2 / b**(k+1) */\n   mp_rshd(&q, um + 1);\n\n   /* x = x mod b**(k+1), quick (no division) */\n   if ((err = mp_mod_2d(x, MP_DIGIT_BIT * (um + 1), x)) != MP_OKAY) {\n      goto CLEANUP;\n   }\n\n   /* q = q * m mod b**(k+1), quick (no division) */\n   if ((err = s_mp_mul_digs(&q, m, &q, um + 1)) != MP_OKAY) {\n      goto CLEANUP;\n   }\n\n   /* x = x - q */\n   if ((err = mp_sub(x, &q, x)) != MP_OKAY) {\n      goto CLEANUP;\n   }\n\n   /* If x < 0, add b**(k+1) to it */\n   if (mp_cmp_d(x, 0uL) == MP_LT) {\n      mp_set(&q, 1uL);\n      if ((err = mp_lshd(&q, um + 1)) != MP_OKAY) {\n         goto CLEANUP;\n      }\n      if ((err = mp_add(x, &q, x)) != MP_OKAY) {\n         goto CLEANUP;\n      }\n   }\n\n   /* Back off if it's too big */\n   while (mp_cmp(x, m) != MP_LT) {\n      if ((err = s_mp_sub(x, m, x)) != MP_OKAY) {\n         goto CLEANUP;\n      }\n   }\n\nCLEANUP:\n   mp_clear(&q);\n\n   return err;\n}\n"", ""caller_start"": 10, ""file_path"": ""bn_mp_reduce.c""}, {""call_line"": 2144, ""call_code"": ""s_mp_mul_digs(&a, &b, &d, (&a)->used + (&b)->used + 1)"", ""caller_code"": ""static int test_s_mp_karatsuba_mul(void)\n{\n   mp_int a, b, c, d;\n   int size, err;\n\n   if ((err = mp_init_multi(&a, &b, &c, &d, NULL)) != MP_OKAY) {\n      goto LTM_ERR;\n   }\n   for (size = MP_KARATSUBA_MUL_CUTOFF; size < MP_KARATSUBA_MUL_CUTOFF + 20; size++) {\n      if ((err = mp_rand(&a, size)) != MP_OKAY) {\n         goto LTM_ERR;\n      }\n      if ((err = mp_rand(&b, size)) != MP_OKAY) {\n         goto LTM_ERR;\n      }\n      if ((err = s_mp_karatsuba_mul(&a, &b, &c)) != MP_OKAY) {\n         goto LTM_ERR;\n      }\n      if ((err = s_mp_mul(&a,&b,&d)) != MP_OKAY) {\n         goto LTM_ERR;\n      }\n      if (mp_cmp(&c, &d) != MP_EQ) {\n         fprintf(stderr, \""Karatsuba multiplication failed at size %d\\n\"", size);\n         goto LTM_ERR;\n      }\n   }\n\n   mp_clear_multi(&a, &b, &c, &d, NULL);\n   return EXIT_SUCCESS;\nLTM_ERR:\n   mp_clear_multi(&a, &b, &c, &d, NULL);\n   return EXIT_FAILURE;\n}"", ""caller_start"": 2126, ""file_path"": ""demo/test.c""}, {""call_line"": 2253, ""call_code"": ""s_mp_mul_digs(&a, &b, &d, (&a)->used + (&b)->used + 1)"", ""caller_code"": ""static int test_s_mp_toom_mul(void)\n{\n   mp_int a, b, c, d;\n   int size, err;\n\n#if (MP_DIGIT_BIT == 60)\n   int tc_cutoff;\n#endif\n\n   if ((err = mp_init_multi(&a, &b, &c, &d, NULL)) != MP_OKAY) {\n      goto LTM_ERR;\n   }\n   /* This number construction is limb-size specific */\n#if (MP_DIGIT_BIT == 60)\n   if ((err = mp_rand(&a, 1196)) != MP_OKAY) {\n      goto LTM_ERR;\n   }\n   if ((err = mp_mul_2d(&a,71787  - mp_count_bits(&a), &a)) != MP_OKAY) {\n      goto LTM_ERR;\n   }\n\n   if ((err = mp_rand(&b, 1338)) != MP_OKAY) {\n      goto LTM_ERR;\n   }\n   if ((err = mp_mul_2d(&b, 80318 - mp_count_bits(&b), &b)) != MP_OKAY) {\n      goto LTM_ERR;\n   }\n   if ((err = mp_mul_2d(&b, 6310, &b)) != MP_OKAY) {\n      goto LTM_ERR;\n   }\n   if ((err = mp_2expt(&c, 99000 - 1000)) != MP_OKAY) {\n      goto LTM_ERR;\n   }\n   if ((err = mp_add(&b, &c, &b)) != MP_OKAY) {\n      goto LTM_ERR;\n   }\n\n   tc_cutoff = TOOM_MUL_CUTOFF;\n   TOOM_MUL_CUTOFF = INT_MAX;\n   if ((err = mp_mul(&a, &b, &c)) != MP_OKAY) {\n      goto LTM_ERR;\n   }\n   TOOM_MUL_CUTOFF = tc_cutoff;\n   if ((err = mp_mul(&a, &b, &d)) != MP_OKAY) {\n      goto LTM_ERR;\n   }\n   if (mp_cmp(&c, &d) != MP_EQ) {\n      fprintf(stderr, \""Toom-Cook 3-way multiplication failed for edgecase f1 * f2\\n\"");\n      goto LTM_ERR;\n   }\n#endif\n\n   for (size = MP_TOOM_MUL_CUTOFF; size < MP_TOOM_MUL_CUTOFF + 20; size++) {\n      if ((err = mp_rand(&a, size)) != MP_OKAY) {\n         goto LTM_ERR;\n      }\n      if ((err = mp_rand(&b, size)) != MP_OKAY) {\n         goto LTM_ERR;\n      }\n      if ((err = s_mp_toom_mul(&a, &b, &c)) != MP_OKAY) {\n         goto LTM_ERR;\n      }\n      if ((err = s_mp_mul(&a,&b,&d)) != MP_OKAY) {\n         goto LTM_ERR;\n      }\n      if (mp_cmp(&c, &d) != MP_EQ) {\n         fprintf(stderr, \""Toom-Cook 3-way multiplication failed at size %d\\n\"", size);\n         goto LTM_ERR;\n      }\n   }\n\n   mp_clear_multi(&a, &b, &c, &d, NULL);\n   return EXIT_SUCCESS;\nLTM_ERR:\n   mp_clear_multi(&a, &b, &c, &d, NULL);\n   return EXIT_FAILURE;\n}\n"", ""caller_start"": 2191, ""file_path"": ""demo/test.c""}]}, {""source"": ""value_info(value:digs)"", ""result"": {""value_trace"": [{""full_code"": ""digs = (n->used * 2) + 1"", ""line"": 19, ""func_name"": ""mp_montgomery_reduce""}, {""full_code"": ""digs = a->used + b->used + 1"", ""line"": 12, ""func_name"": ""mp_mul""}, {""full_code"": ""digs = 0"", ""line"": 33, ""func_name"": ""mp_radix_size""}, {""full_code"": ""++digs"", ""line"": 37, ""func_name"": ""mp_radix_size""}, {""full_code"": ""++digs"", ""line"": 53, ""func_name"": ""mp_radix_size""}], ""struct_var"": ""digs"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}]","1. In mp_mul (bn_mp_mul.c:45), 'digs' is calculated as 'a->used + b->used + 1'.\n2. If this sum exceeds INT_MAX, 'digs' becomes negative due to signed integer overflow (e.g., 0x7FFFFFFF + 0x7FFFFFFF + 1 = 0xFFFFFFFE  -2 as int).\n3. This negative 'digs' is passed to s_mp_mul_digs (bn_s_mp_mul_digs.c:16), which, prior to the patch, lacked a check for negative values.\n4. Functions like mp_grow (bn_mp_grow.c:9) would then allocate insufficient memory based on the overflowed 'digs', enabling buffer overflows during subsequent operations.",0.95,./github/other_context/CVE-2023-36328
41,CVE-2023-48234,CWE-190,c_cpp,"Vim is an open source command line text editor. When getting the count for a normal mode z command, it may overflow for large counts given. Impact is low, user interaction is required and a crash may not even happen in all situations. This issue has been addressed in commit `58f9befca1` which has been included in release version 9.0.2109. Users are advised to upgrade. There are no known workarounds for this vulnerability.",https://github.com/vim/vim/commit/58f9befca1fa172068effad7f2ea5a9d6a7b0cca,"patch 9.0.2109: [security]: overflow in nv_z_get_count\n\nProblem:  [security]: overflow in nv_z_get_count\nSolution: break out, if count is too large\n\nWhen getting the count for a normal z command, it may overflow for large\ncounts given. So verify, that we can safely store the result in a long.\n\nSigned-off-by: Christian Brabandt <cb@256bit.org>",1,"[{""func_name"": ""nv_z_get_count"", ""file_path"": ""src/normal.c"", ""func_code"": ""static int\nnv_z_get_count(cmdarg_T *cap, int *nchar_arg)\n{\n    int\t\tnchar = *nchar_arg;\n    long\tn;\n\n    // \""z123{nchar}\"": edit the count before obtaining {nchar}\n    if (checkclearop(cap->oap))\n\treturn FALSE;\n    n = nchar - '0';\n\n    for (;;)\n    {\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (nchar == K_DEL || nchar == K_KDEL)\n\t    n /= 10;\n\telse if (VIM_ISDIGIT(nchar))\n\t    n = n * 10 + (nchar - '0');\n\telse if (nchar == CAR)\n\t{\n#ifdef FEAT_GUI\n\t    need_mouse_correct = TRUE;\n#endif\n\t    win_setheight((int)n);\n\t    break;\n\t}\n\telse if (nchar == 'l'\n\t\t|| nchar == 'h'\n\t\t|| nchar == K_LEFT\n\t\t|| nchar == K_RIGHT)\n\t{\n\t    cap->count1 = n ? n * cap->count1 : cap->count1;\n\t    *nchar_arg = nchar;\n\t    return TRUE;\n\t}\n\telse\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n    }\n    cap->oap->op_type = OP_NOP;\n    return FALSE;\n}"", ""target"": 0}]","[{""func_name"": ""nv_z_get_count"", ""file_path"": ""src/normal.c"", ""func_code"": ""static int\nnv_z_get_count(cmdarg_T *cap, int *nchar_arg)\n{\n    int\t\tnchar = *nchar_arg;\n    long\tn;\n\n    // \""z123{nchar}\"": edit the count before obtaining {nchar}\n    if (checkclearop(cap->oap))\n\treturn FALSE;\n    n = nchar - '0';\n\n    for (;;)\n    {\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (nchar == K_DEL || nchar == K_KDEL)\n\t    n /= 10;\n\telse if (VIM_ISDIGIT(nchar))\n\t{\n\t    if (n > LONG_MAX / 10)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    n = n * 10 + (nchar - '0');\n\t}\n\telse if (nchar == CAR)\n\t{\n#ifdef FEAT_GUI\n\t    need_mouse_correct = TRUE;\n#endif\n\t    win_setheight((int)n);\n\t    break;\n\t}\n\telse if (nchar == 'l'\n\t\t|| nchar == 'h'\n\t\t|| nchar == K_LEFT\n\t\t|| nchar == K_RIGHT)\n\t{\n\t    cap->count1 = n ? n * cap->count1 : cap->count1;\n\t    *nchar_arg = nchar;\n\t    return TRUE;\n\t}\n\telse\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n    }\n    cap->oap->op_type = OP_NOP;\n    return FALSE;\n}""}]","{""value"": 1}","[{""source"": ""value_info(file:normal.c, value:n)"", ""result"": {""value_trace"": [{""full_code"": ""n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1"", ""line"": 2349, ""func_name"": ""nv_screengo""}, {""full_code"": ""n = width1"", ""line"": 2351, ""func_name"": ""nv_screengo""}, {""full_code"": ""n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1"", ""line"": 2388, ""func_name"": ""nv_screengo""}, {""full_code"": ""n = width1"", ""line"": 2390, ""func_name"": ""nv_screengo""}, {""full_code"": ""n = nchar - '0'"", ""line"": 2547, ""func_name"": ""nv_z_get_count""}], ""struct_var"": ""n"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}]","src/normal.c:2563-2570: Vulnerable line is n = n * 10 + (nchar - '0');. 'n' is declared as an int (confirmed in value trace). Without the patch's check (n > LONG_MAX / 10), multiplying by 10 could overflow the int type before being stored in a long, causing undefined behavior. The overflow occurs during digit processing in normal mode z commands.",0.95,./github/other_context/CVE-2023-48234
42,CVE-2024-22862,CWE-190,c_cpp,"Integer overflow vulnerability in FFmpeg before n6.1, allows remote attackers to execute arbitrary code via the JJPEG XL Parser.",https://github.com/FFmpeg/FFmpeg/commit/ca09d8a0dcd82e3128e62463231296aaf63ae6f7,avcodec/jpegxl_parser: Check for ctx->skip overflow\n\nFixes: out of array access\nFixes: 62113/clusterfuzz-testcase-minimized-ffmpeg_DEMUXER_fuzzer-5025082076168192\n\nFound-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>,1,"[{""func_name"": ""skip_boxes"", ""file_path"": ""libavcodec/jpegxl_parser.c"", ""func_code"": ""static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        /* invalid ISOBMFF size */\n        if (size <= head_size + 4)\n            return AVERROR_INVALIDDATA;\n\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""skip_boxes"", ""file_path"": ""libavcodec/jpegxl_parser.c"", ""func_code"": ""static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        /* invalid ISOBMFF size */\n        if (size <= head_size + 4 || size > INT_MAX - ctx->skip)\n            return AVERROR_INVALIDDATA;\n\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n\n    return 0;\n}""}]","{""code"": 2, ""value"": 2}","[{""source"": ""code_info(file:jpegxl_parser.c, lines:1320-1340)"", ""result"": ""        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        /* invalid ISOBMFF size */\n        if (size <= head_size + 4)\n            return AVERROR_INVALIDDATA;\n\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n\n    return 0;\n}\n\nstatic int try_parse(AVCodecParserContext *s, AVCodecContext *avctx, JXLParseContext *ctx,\n""}, {""source"": ""value_info(file:jpegxl_parser.c, value:size)"", ""result"": {""value_trace"": [{""full_code"": ""size = bytestream2_get_be32(&gb)"", ""line"": 1319, ""func_name"": ""skip_boxes""}, {""full_code"": ""size = bytestream2_get_be64(&gb)"", ""line"": 1323, ""func_name"": ""skip_boxes""}], ""struct_var"": ""size"", ""struct_type"": ""uint64_t"", ""struct_definition"": ""uint64_t""}}, {""source"": ""value_info(file:jpegxl_parser.c, value:ctx)"", ""result"": {""value_trace"": [{""full_code"": ""*ctx = s->priv_data"", ""line"": 1418, ""func_name"": ""jpegxl_parse""}], ""struct_var"": ""ctx"", ""struct_type"": ""JXLParseContext*"", ""struct_definition"": ""typedef struct JXLParseContext {\n    ParseContext pc;\n    JXLCodestream codestream;\n\n    /* using ISOBMFF-based container */\n    int container;\n    int skip;\n    int copied;\n    int collected_size;\n    int codestream_length;\n    int skipped_icc;\n    int next;\n\n    uint8_t cs_buffer[4096];\n}\n\ntypedef struct JXLParseContext {\n    ParseContext pc;\n    JXLCodestream codestream;\n\n    /* using ISOBMFF-based container */\n    int container;\n    int skip;\n    int copied;\n    int collected_size;\n    int codestream_length;\n    int skipped_icc;\n    int next;\n\n    uint8_t cs_buffer[4096];\n} JXLParseContext;""}}, {""source"": ""code_info(file:jpegxl_parser.c, lines:1310-1330)"", ""result"": ""\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        /* invalid ISOBMFF size */\n        if (size <= head_size + 4)\n            return AVERROR_INVALIDDATA;\n\n""}]","libavcodec/jpegxl_parser.c:1327: 'ctx->skip' (int) is incremented by 'size' (uint64_t) without overflow checking. 'size' is derived from input via bytestream2_get_be32 (line 1319) or bytestream2_get_be64 (line 1323). If 'size' exceeds INT_MAX - ctx->skip, overflow occurs, leading to out-of-bounds memory access. The patch adds 'size > INT_MAX - ctx->skip' check to prevent this.",0.95,./github/other_context/CVE-2024-22862
43,CVE-2017-5596,"CWE-190, CWE-835",c_cpp,"In Wireshark 2.2.0 to 2.2.3 and 2.0.0 to 2.0.9, the ASTERIX dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-asterix.c by changing a data type to avoid an integer overflow.",https://github.com/wireshark/wireshark/commit/781f03580c81339513bb1238b202b72469a1240b,ASTERIX: Avoid an integer overflow.\n\nCount using a guint instead of a guint8.\n\nBug: 13344\nChange-Id: Ic7d337dbb29b92ebb8332f50fd47b5ba2aa3f41e\nReviewed-on: https://code.wireshark.org/review/19746\nPetri-Dish: Gerald Combs <gerald@wireshark.org>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Gerald Combs <gerald@wireshark.org>,1,"[{""func_name"": ""asterix_fspec_len"", ""file_path"": ""epan/dissectors/packet-asterix.c"", ""func_code"": ""static guint8 asterix_fspec_len (tvbuff_t *tvb, guint offset)\n{\n    guint8 i;\n    for (i = 0; (tvb_get_guint8 (tvb, offset + i) & 1) && i < tvb_reported_length (tvb) - offset; i++);\n    return i + 1;\n}"", ""target"": 0}]","[{""func_name"": ""asterix_fspec_len"", ""file_path"": ""epan/dissectors/packet-asterix.c"", ""func_code"": ""static guint asterix_fspec_len (tvbuff_t *tvb, guint offset)\n{\n    guint i;\n    guint max_length = tvb_reported_length (tvb) - offset;\n    for (i = 0; (tvb_get_guint8 (tvb, offset + i) & 1) && i < max_length; i++);\n    return i + 1;\n}""}]",{},[],"Original root cause: In epan/dissectors/packet-asterix.c, the loop variable 'i' (guint8) would overflow at 255, leading to an infinite loop if the condition (tvb_get_guint8(...) & 1) remained true. Patch changes 'i' to guint and precomputes 'max_length' to prevent overflow.",0.95,./github/other_context/CVE-2017-5596
44,CVE-2014-9626,"CWE-704, CWE-191, CWE-120",c_cpp,Integer underflow in the MP4_ReadBox_String function in modules/demux/mp4/libmp4.c in VideoLAN VLC media player before 2.1.6 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a box size less than 7.,https://github.com/videolan/vlc/commit/2e7c7091a61aa5d07e7997b393d821e91f593c39,demux: mp4: fix buffer overflow in parsing of string boxes.\n\nWe ensure that pbox->i_size is never smaller than 8 to avoid an\ninteger underflow in the third argument of the subsequent call to\nmemcpy. We also make sure no truncation occurs when passing values\nderived from the 64 bit integer p_box->i_size to arguments of malloc\nand memcpy that may be 32 bit integers on 32 bit platforms.\n\nSigned-off-by: Jean-Baptiste Kempf <jb@videolan.org>,1,"[{""func_name"": ""MP4_ReadBox_String"", ""file_path"": ""modules/demux/mp4/libmp4.c"", ""func_code"": ""static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\\0, -name, -size */\n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \""read box: \\\""%4.4s\\\"" text=`%s'\"", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}"", ""target"": 0}]","[{""func_name"": ""MP4_ReadBox_String"", ""file_path"": ""modules/demux/mp4/libmp4.c"", ""func_code"": ""static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n\n    if( p_box->i_size < 8 || p_box->i_size > SIZE_MAX )\n        MP4_READBOX_EXIT( 0 );\n\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\\0, -name, -size */\n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \""read box: \\\""%4.4s\\\"" text=`%s'\"", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}""}]","{""value"": 2, ""function"": 1, ""code"": 1}","[{""source"": ""value_info(file:libmp4.c, value:p_box->i_size)"", ""result"": {""value_trace"": [{""full_code"": ""p_box->i_size = (GetQWBE(p_peek))"", ""line"": 109, ""func_name"": ""MP4_ReadBoxCommon""}, {""full_code"": ""p_box->i_size = p_box->i_shortsize"", ""line"": 113, ""func_name"": ""MP4_ReadBoxCommon""}], ""struct_var"": ""p_box"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:libmp4.c, value:p_box->i_shortsize)"", ""result"": {""value_trace"": [{""full_code"": ""p_box->i_shortsize = (GetDWBE(p_peek))"", ""line"": 101, ""func_name"": ""MP4_ReadBoxCommon""}], ""struct_var"": ""p_box"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:libmp4.c, func:MP4_ReadBoxCommon)"", ""result"": [{""code"": ""int MP4_ReadBoxCommon( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    int      i_read;\n    const uint8_t  *p_peek;\n\n    if( ( ( i_read = stream_Peek( p_stream, &p_peek, 32 ) ) < 8 ) )\n    {\n        return 0;\n    }\n    p_box->i_pos = stream_Tell( p_stream );\n\n    p_box->data.p_payload = NULL;\n    p_box->p_father = NULL;\n    p_box->p_first  = NULL;\n    p_box->p_last  = NULL;\n    p_box->p_next   = NULL;\n\n    MP4_GET4BYTES( p_box->i_shortsize );\n    MP4_GETFOURCC( p_box->i_type );\n\n    /* Now special case */\n\n    if( p_box->i_shortsize == 1 )\n    {\n        /* get the true size on 64 bits */\n        MP4_GET8BYTES( p_box->i_size );\n    }\n    else\n    {\n        p_box->i_size = p_box->i_shortsize;\n        /* XXX size of 0 means that the box extends to end of file */\n    }\n\n    if( p_box->i_type == ATOM_uuid )\n    {\n        /* get extented type on 16 bytes */\n        GetUUID( &p_box->i_uuid, p_peek );\n        p_peek += 16; i_read -= 16;\n    }\n    else\n    {\n        CreateUUID( &p_box->i_uuid, p_box->i_type );\n    }\n#ifdef MP4_ULTRA_VERBOSE\n    if( p_box->i_size )\n    {\n        if MP4_BOX_TYPE_ASCII()\n            msg_Dbg( p_stream, \""found Box: %4.4s size %\""PRId64\"" %\""PRId64,\n                    (char*)&p_box->i_type, p_box->i_size, p_box->i_pos );\n        else\n            msg_Dbg( p_stream, \""found Box: c%3.3s size %\""PRId64,\n                    (char*)&p_box->i_type+1, p_box->i_size );\n    }\n#endif\n\n    return 1;\n}\n"", ""start_line"": 84, ""end_line"": 140, ""full_name"": ""MP4_ReadBoxCommon"", ""file_path"": ""modules/demux/mp4/libmp4.c""}]}, {""source"": ""code_info(file:libmp4.c, lines:100-120)"", ""result"": ""\n    MP4_GET4BYTES( p_box->i_shortsize );\n    MP4_GETFOURCC( p_box->i_type );\n\n    /* Now special case */\n\n    if( p_box->i_shortsize == 1 )\n    {\n        /* get the true size on 64 bits */\n        MP4_GET8BYTES( p_box->i_size );\n    }\n    else\n    {\n        p_box->i_size = p_box->i_shortsize;\n        /* XXX size of 0 means that the box extends to end of file */\n    }\n\n    if( p_box->i_type == ATOM_uuid )\n    {\n        /* get extented type on 16 bytes */\n        GetUUID( &p_box->i_uuid, p_peek );\n""}]","modules/demux/mp4/libmp4.c:2858: MP4_ReadBox_String uses p_box->i_size without ensuring it is 8, leading to integer underflow in 'malloc(p_box->i_size + 1 - 8)'. The value p_box->i_size is initialized in MP4_ReadBoxCommon (line 113) as p_box->i_shortsize (line 101), which is parsed from input via GetDWBE(p_peek). If the input provides a box with i_shortsize <8, MP4_ReadBox_String calculates an invalid buffer size. The patch (line 2858+) adds a check to reject i_size <8.",0.95,./github/other_context/CVE-2014-9626
45,CVE-2016-5767,CWE-190,c_cpp,"Integer overflow in the gdImageCreate function in gd.c in the GD Graphics Library (aka libgd) before 2.0.34RC1, as used in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8, allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted image dimensions.",https://github.com/php/php-src/commit/c395c6e5d7e8df37a21265ff76e48fe75ceb5ae6,iFixed bug #72446 - Integer Overflow in gdImagePaletteToTrueColor() resulting in heap overflow,7,"[{""func_name"": ""gdImageCreate"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""gdImagePtr gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tim->open[i] = 1;\n\t\tim->red[i] = 0;\n\t\tim->green[i] = 0;\n\t\tim->blue[i] = 0;\n\t}\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}"", ""target"": 0}, {""func_name"": ""gdImageFill"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""void gdImageFill(gdImagePtr im, int x, int y, int nc)\n{\n\tint l, x1, x2, dy;\n\tint oc;   /* old pixel value */\n\tint wx2,wy2;\n\n\tint alphablending_bak;\n\n\t/* stack of filled segments */\n\t/* struct seg stack[FILL_MAX],*sp = stack;; */\n\tstruct seg *stack = NULL;\n\tstruct seg *sp;\n\n\tif (!im->trueColor && nc > (im->colorsTotal -1)) {\n\t\treturn;\n\t}\n\n\talphablending_bak = im->alphaBlendingFlag;\t\n\tim->alphaBlendingFlag = 0;\n\n\tif (nc==gdTiled){\n\t\t_gdImageFillTiled(im,x,y,nc);\n\t\tim->alphaBlendingFlag = alphablending_bak;\n\t\treturn;\n\t}\n\n\twx2=im->sx;wy2=im->sy;\n\toc = gdImageGetPixel(im, x, y);\n\tif (oc==nc || x<0 || x>wx2 || y<0 || y>wy2) {\n\t\tim->alphaBlendingFlag = alphablending_bak;\t\n\t\treturn;\n\t}\n\n\t/* Do not use the 4 neighbors implementation with\n\t * small images\n\t */\n\tif (im->sx < 4) {\n\t\tint ix = x, iy = y, c;\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tc = gdImageGetPixel(im, ix, iy);\n\t\t\t\tif (c != oc) {\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, ix, iy, nc);\n\t\t\t} while(ix++ < (im->sx -1));\n\t\t\tix = x;\n\t\t} while(iy++ < (im->sy -1));\n\t\tgoto done;\n\t}\n\n\tstack = (struct seg *)safe_emalloc(sizeof(struct seg), ((int)(im->sy*im->sx)/4), 1);\n\tsp = stack;\n\n\t/* required! */\n\tFILL_PUSH(y,x,x,1);\n\t/* seed segment (popped 1st) */\n \tFILL_PUSH(y+1, x, x, -1);\n\twhile (sp>stack) {\n\t\tFILL_POP(y, x1, x2, dy);\n\n\t\tfor (x=x1; x>=0 && gdImageGetPixel(im,x, y)==oc; x--) {\n\t\t\tgdImageSetPixel(im,x, y, nc);\n\t\t}\n\t\tif (x>=x1) {\n\t\t\tgoto skip;\n\t\t}\n\t\tl = x+1;\n\n                /* leak on left? */\n\t\tif (l<x1) {\n\t\t\tFILL_PUSH(y, l, x1-1, -dy);\n\t\t}\n\t\tx = x1+1;\n\t\tdo {\n\t\t\tfor (; x<=wx2 && gdImageGetPixel(im,x, y)==oc; x++) {\n\t\t\t\tgdImageSetPixel(im, x, y, nc);\n\t\t\t}\n\t\t\tFILL_PUSH(y, l, x-1, dy);\n\t\t\t/* leak on right? */\n\t\t\tif (x>x2+1) {\n\t\t\t\tFILL_PUSH(y, x2+1, x-1, -dy);\n\t\t\t}\nskip:\t\t\tfor (x++; x<=x2 && (gdImageGetPixel(im, x, y)!=oc); x++);\n\n\t\t\tl = x;\n\t\t} while (x<=x2);\n\t}\n\n\tefree(stack);\n\ndone:\n\tim->alphaBlendingFlag = alphablending_bak;\t\n}"", ""target"": 1}, {""func_name"": ""gdImageCopyMerge"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""void gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h, int pct)\n{\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\ttoy = dstY;\n\t\n\tfor (y = srcY; y < (srcY + h); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; x < (srcX + w); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel(src, x, y);\n\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\tif (gdImageGetTransparent(src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* If it's the same image, mapping is trivial */\n\t\t\tif (dst == src) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel(dst, tox, toy);\n\n \t\t\t\tncR = (int)(gdImageRed (src, c) * (pct / 100.0) + gdImageRed (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncG = (int)(gdImageGreen (src, c) * (pct / 100.0) + gdImageGreen (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncB = (int)(gdImageBlue (src, c) * (pct / 100.0) + gdImageBlue (dst, dc) * ((100 - pct) / 100.0));\n\n\t\t\t\t/* Find a reasonable color */\n\t\t\t\tnc = gdImageColorResolve (dst, ncR, ncG, ncB);\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}"", ""target"": 0}, {""func_name"": ""gdImageLine"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""void gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;\n\tint wid;\n\tint w, wstart;\n\tint thick = im->thick;\n\n\tif (color == gdAntiAliased) {\n\t\t/* \n\t\t   gdAntiAliased passed as color: use the much faster, much cheaper\n\t\t   and equally attractive gdImageAALine implementation. That\n\t\t   clips too, so don't clip twice.\n\t\t   */\n\t\tgdImageAALine(im, x1, y1, x2, y2, im->AA_color); \n\t\treturn;\n\t}\n\n\t/* 2.0.10: Nick Atty: clip to edges of drawing rectangle, return if no points need to be drawn */\n\tif (!clip_1d(&x1,&y1,&x2,&y2,gdImageSX(im)) || !clip_1d(&y1,&x1,&y2,&x2,gdImageSY(im))) {\n\t\treturn;\n\t}\n\n\tdx = abs (x2 - x1);\n\tdy = abs (y2 - y1);\n\n\tif (dx == 0) {\n\t\tgdImageVLine(im, x1, y1, y2, color);\n\t\treturn;\n\t} else if (dy == 0) {\n\t\tgdImageHLine(im, y1, x1, x2, color);\n\t\treturn;\n\t}\n\n\tif (dy <= dx) {\n\t\t/* More-or-less horizontal. use wid for vertical stroke */\n\t\t/* Doug Claar: watch out for NaN in atan2 (2.0.5) */\n\t\tif ((dx == 0) && (dy == 0)) {\n\t\t\twid = 1;\n\t\t} else {\n\t\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\nTBB: but watch out for /0! */\n\t\t\tdouble ac = cos (atan2 (dy, dx));\n\t\t\tif (ac != 0) {\n\t\t\t\twid = thick / ac;\n\t\t\t} else {\n\t\t\t\twid = 1;\n\t\t\t}\n\t\t\tif (wid == 0) {\n\t\t\t\twid = 1;\n\t\t\t}\n\t\t}\n\t\td = 2 * dy - dx;\n\t\tincr1 = 2 * dy;\n\t\tincr2 = 2 * (dy - dx);\n\t\tif (x1 > x2) {\n\t\t\tx = x2;\n\t\t\ty = y2;\n\t\t\tydirflag = (-1);\n\t\t\txend = x1;\n\t\t} else {\n\t\t\tx = x1;\n\t\t\ty = y1;\n\t\t\tydirflag = 1;\n\t\t\txend = x2;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = y - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\tgdImageSetPixel(im, x, w, color);\n\t\t}\n\n\t\tif (((y2 - y1) * ydirflag) > 0) {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* More-or-less vertical. use wid for horizontal stroke */\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t   TBB: but watch out for /0! */\n\t\tdouble as = sin (atan2 (dy, dx));\n\t\tif (as != 0) {\n\t\t\twid = thick / as;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0) {\n\t\t\twid = 1;\n\t\t}\n\n\t\td = 2 * dx - dy;\n\t\tincr1 = 2 * dx;\n\t\tincr2 = 2 * (dx - dy);\n\t\tif (y1 > y2) {\n\t\t\ty = y2;\n\t\t\tx = x2;\n\t\t\tyend = y1;\n\t\t\txdirflag = (-1);\n\t\t} else {\n\t\t\ty = y1;\n\t\t\tx = x1;\n\t\t\tyend = y2;\n\t\t\txdirflag = 1;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = x - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t}\n\n\t\tif (((x2 - x1) * xdirflag) > 0) {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"", ""target"": 0}, {""func_name"": ""gdImageCopyResized"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""void gdImageCopyResized (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int dstW, int dstH, int srcW, int srcH)\n{\n\tint c;\n\tint x, y;\n\tint tox, toy;\n\tint ydest;\n\tint i;\n\tint colorMap[gdMaxColors];\n\t/* Stretch vectors */\n\tint *stx, *sty;\n\t\n\tif (overflow2(sizeof(int), srcW)) {\n\t\treturn;\n\t}\n\tif (overflow2(sizeof(int), srcH)) {\n\t\treturn;\n\t}\n\n\tstx = (int *) gdMalloc (sizeof (int) * srcW);\n\tsty = (int *) gdMalloc (sizeof (int) * srcH);\n\n\t/* Fixed by Mao Morimoto 2.0.16 */\n\tfor (i = 0; (i < srcW); i++) {\n\t\tstx[i] = dstW * (i+1) / srcW - dstW * i / srcW ;\n\t}\n\tfor (i = 0; (i < srcH); i++) {\n\t\tsty[i] = dstH * (i+1) / srcH - dstH * i / srcH ;\n\t}\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tcolorMap[i] = (-1);\n\t}\n\ttoy = dstY;\n\tfor (y = srcY; (y < (srcY + srcH)); y++) {\n\t\tfor (ydest = 0; (ydest < sty[y - srcY]); ydest++) {\n\t\t\ttox = dstX;\n\t\t\tfor (x = srcX; (x < (srcX + srcW)); x++) {\n\t\t\t\tint nc = 0;\n\t\t\t\tint mapTo;\n\t\t\t\tif (!stx[x - srcX]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (dst->trueColor) {\n\t\t\t\t\t/* 2.0.9: Thorben Kundinger: Maybe the source image is not a truecolor image */\n\t\t\t\t\tif (!src->trueColor) {\n\t\t\t\t\t  \tint tmp = gdImageGetPixel (src, x, y);\n\t\t  \t\t\t\tmapTo = gdImageGetTrueColorPixel (src, x, y);\n\t\t\t\t\t  \tif (gdImageGetTransparent (src) == tmp) {\n\t\t\t\t\t\t\t/* 2.0.21, TK: not tox++ */\n\t\t\t\t\t\t\ttox += stx[x - srcX];\n\t\t\t\t\t  \t\tcontinue;\n\t\t\t\t\t  \t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* TK: old code follows */\n\t\t\t\t\t  \tmapTo = gdImageGetTrueColorPixel (src, x, y);\n\t\t\t\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\t\t\t\tif (gdImageGetTransparent (src) == mapTo) {\n\t\t\t\t\t\t\t/* 2.0.21, TK: not tox++ */\n\t\t\t\t\t\t\ttox += stx[x - srcX];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc = gdImageGetPixel (src, x, y);\n\t\t\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\t\t\tif (gdImageGetTransparent (src) == c) {\n\t\t\t\t\t      tox += stx[x - srcX];\n\t\t\t\t\t      continue;\n\t\t\t\t\t}\n\t\t\t\t\tif (src->trueColor) {\n\t\t\t\t\t      /* Remap to the palette available in the destination image. This is slow and works badly. */\n\t\t\t\t\t      mapTo = gdImageColorResolveAlpha(dst, gdTrueColorGetRed(c),\n\t\t\t\t\t      \t\t\t\t\t    gdTrueColorGetGreen(c),\n\t\t\t\t\t      \t\t\t\t\t    gdTrueColorGetBlue(c),\n\t\t\t\t\t      \t\t\t\t\t    gdTrueColorGetAlpha (c));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Have we established a mapping for this color? */\n\t\t\t\t\t\tif (colorMap[c] == (-1)) {\n\t\t\t\t\t\t\t/* If it's the same image, mapping is trivial */\n\t\t\t\t\t\t\tif (dst == src) {\n\t\t\t\t\t\t\t\tnc = c;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/* Find or create the best match */\n\t\t\t\t\t\t\t\t/* 2.0.5: can't use gdTrueColorGetRed, etc with palette */\n\t\t\t\t\t\t\t\tnc = gdImageColorResolveAlpha(dst, gdImageRed(src, c),\n\t\t\t\t\t\t\t\t\t\t\t\t   gdImageGreen(src, c),\n\t\t\t\t\t\t\t\t\t\t\t\t   gdImageBlue(src, c),\n\t\t\t\t\t\t\t\t\t\t\t\t   gdImageAlpha(src, c));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcolorMap[c] = nc;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapTo = colorMap[c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = 0; (i < stx[x - srcX]); i++) {\n\t\t\t\t\tgdImageSetPixel (dst, tox, toy, mapTo);\n\t\t\t\t\ttox++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoy++;\n\t\t}\n\t}\n\tgdFree (stx);\n\tgdFree (sty);\n}"", ""target"": 0}, {""func_name"": ""gdImageRectangle"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""void gdImageRectangle (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint x1h = x1, x1v = x1, y1h = y1, y1v = y1, x2h = x2, x2v = x2, y2h = y2, y2v = y2;\n\tint thick = im->thick;\n\tint t;\n\n\tif (x1 == x2 && y1 == y2 && thick == 1) {\n\t\tgdImageSetPixel(im, x1, y1, color);\n\t\treturn;\n\t}\n\n\tif (y2 < y1) {\n\t\tt=y1;\n\t\ty1 = y2;\n\t\ty2 = t;\n\n\t\tt = x1;\n\t\tx1 = x2;\n\t\tx2 = t;\n\t}\n\n\tx1h = x1; x1v = x1; y1h = y1; y1v = y1; x2h = x2; x2v = x2; y2h = y2; y2v = y2;\n\tif (thick > 1) {\n\t\tint cx, cy, x1ul, y1ul, x2lr, y2lr;\n\t\tint half = thick >> 1;\n\n\t\tx1ul = x1 - half;\n\t\ty1ul = y1 - half;\n\t\t\n\t\tx2lr = x2 + half;\n\t\ty2lr = y2 + half;\n\n\t\tcy = y1ul + thick;\n\t\twhile (cy-- > y1ul) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y2lr - thick;\n\t\twhile (cy++ < y2lr) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x1ul + thick) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x2lr - thick - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t} else {\n\t\ty1v = y1h + 1;\n\t\ty2v = y2h - 1;\n\t\tgdImageLine(im, x1h, y1h, x2h, y1h, color);\n\t\tgdImageLine(im, x1h, y2h, x2h, y2h, color);\n\t\tgdImageLine(im, x1v, y1v, x1v, y2v, color);\n\t\tgdImageLine(im, x2v, y1v, x2v, y2v, color);\n\t}\n}"", ""target"": 0}, {""func_name"": ""gdAlphaBlend"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n\n/* -------------------------------------------------------------------- */\n/*      Simple cases we want to handle fast.                            */\n/* -------------------------------------------------------------------- */\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n\n/* -------------------------------------------------------------------- */\n/*      What will the source and destination alphas be?  Note that      */\n/*      the destination weighting is substantially reduced as the       */\n/*      overlay becomes quite opaque.                                   */\n/* -------------------------------------------------------------------- */\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n    \n/* -------------------------------------------------------------------- */\n/*      What red, green and blue result values will we use?             */\n/* -------------------------------------------------------------------- */\n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n/* -------------------------------------------------------------------- */\n/*      Return merged result.                                           */\n/* -------------------------------------------------------------------- */\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n\n}"", ""target"": 0}]","[{""func_name"": ""gdImageCreate"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""gdImagePtr gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\n\tif (overflow2(sizeof(unsigned char *), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tim->open[i] = 1;\n\t\tim->red[i] = 0;\n\t\tim->green[i] = 0;\n\t\tim->blue[i] = 0;\n\t}\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}""}, {""func_name"": ""gdImageFill"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""void gdImageFill(gdImagePtr im, int x, int y, int nc)\n{\n\tint l, x1, x2, dy;\n\tint oc;   /* old pixel value */\n\tint wx2,wy2;\n\n\tint alphablending_bak;\n\n\t/* stack of filled segments */\n\t/* struct seg stack[FILL_MAX],*sp = stack;; */\n\tstruct seg *stack = NULL;\n\tstruct seg *sp;\n\n\tif (!im->trueColor && nc > (im->colorsTotal -1)) {\n\t\treturn;\n\t}\n\n\talphablending_bak = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (nc==gdTiled){\n\t\t_gdImageFillTiled(im,x,y,nc);\n\t\tim->alphaBlendingFlag = alphablending_bak;\n\t\treturn;\n\t}\n\n\twx2=im->sx;wy2=im->sy;\n\toc = gdImageGetPixel(im, x, y);\n\tif (oc==nc || x<0 || x>wx2 || y<0 || y>wy2) {\n\t\tim->alphaBlendingFlag = alphablending_bak;\n\t\treturn;\n\t}\n\n\t/* Do not use the 4 neighbors implementation with\n\t * small images\n\t */\n\tif (im->sx < 4) {\n\t\tint ix = x, iy = y, c;\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tc = gdImageGetPixel(im, ix, iy);\n\t\t\t\tif (c != oc) {\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, ix, iy, nc);\n\t\t\t} while(ix++ < (im->sx -1));\n\t\t\tix = x;\n\t\t} while(iy++ < (im->sy -1));\n\t\tgoto done;\n\t}\n\n\tstack = (struct seg *)safe_emalloc(sizeof(struct seg), ((int)(im->sy*im->sx)/4), 1);\n\tsp = stack;\n\n\t/* required! */\n\tFILL_PUSH(y,x,x,1);\n\t/* seed segment (popped 1st) */\n \tFILL_PUSH(y+1, x, x, -1);\n\twhile (sp>stack) {\n\t\tFILL_POP(y, x1, x2, dy);\n\n\t\tfor (x=x1; x>=0 && gdImageGetPixel(im,x, y)==oc; x--) {\n\t\t\tgdImageSetPixel(im,x, y, nc);\n\t\t}\n\t\tif (x>=x1) {\n\t\t\tgoto skip;\n\t\t}\n\t\tl = x+1;\n\n                /* leak on left? */\n\t\tif (l<x1) {\n\t\t\tFILL_PUSH(y, l, x1-1, -dy);\n\t\t}\n\t\tx = x1+1;\n\t\tdo {\n\t\t\tfor (; x<=wx2 && gdImageGetPixel(im,x, y)==oc; x++) {\n\t\t\t\tgdImageSetPixel(im, x, y, nc);\n\t\t\t}\n\t\t\tFILL_PUSH(y, l, x-1, dy);\n\t\t\t/* leak on right? */\n\t\t\tif (x>x2+1) {\n\t\t\t\tFILL_PUSH(y, x2+1, x-1, -dy);\n\t\t\t}\nskip:\t\t\tfor (x++; x<=x2 && (gdImageGetPixel(im, x, y)!=oc); x++);\n\n\t\t\tl = x;\n\t\t} while (x<=x2);\n\t}\n\n\tefree(stack);\n\ndone:\n\tim->alphaBlendingFlag = alphablending_bak;\n}""}, {""func_name"": ""gdImageCopyMerge"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""void gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h, int pct)\n{\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\ttoy = dstY;\n\n\tfor (y = srcY; y < (srcY + h); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; x < (srcX + w); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel(src, x, y);\n\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\tif (gdImageGetTransparent(src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* If it's the same image, mapping is trivial */\n\t\t\tif (dst == src) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel(dst, tox, toy);\n\n \t\t\t\tncR = (int)(gdImageRed (src, c) * (pct / 100.0) + gdImageRed (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncG = (int)(gdImageGreen (src, c) * (pct / 100.0) + gdImageGreen (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncB = (int)(gdImageBlue (src, c) * (pct / 100.0) + gdImageBlue (dst, dc) * ((100 - pct) / 100.0));\n\n\t\t\t\t/* Find a reasonable color */\n\t\t\t\tnc = gdImageColorResolve (dst, ncR, ncG, ncB);\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}""}, {""func_name"": ""gdImageLine"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""void gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;\n\tint wid;\n\tint w, wstart;\n\tint thick = im->thick;\n\n\tif (color == gdAntiAliased) {\n\t\t/*\n\t\t   gdAntiAliased passed as color: use the much faster, much cheaper\n\t\t   and equally attractive gdImageAALine implementation. That\n\t\t   clips too, so don't clip twice.\n\t\t   */\n\t\tgdImageAALine(im, x1, y1, x2, y2, im->AA_color);\n\t\treturn;\n\t}\n\n\t/* 2.0.10: Nick Atty: clip to edges of drawing rectangle, return if no points need to be drawn */\n\tif (!clip_1d(&x1,&y1,&x2,&y2,gdImageSX(im)) || !clip_1d(&y1,&x1,&y2,&x2,gdImageSY(im))) {\n\t\treturn;\n\t}\n\n\tdx = abs (x2 - x1);\n\tdy = abs (y2 - y1);\n\n\tif (dx == 0) {\n\t\tgdImageVLine(im, x1, y1, y2, color);\n\t\treturn;\n\t} else if (dy == 0) {\n\t\tgdImageHLine(im, y1, x1, x2, color);\n\t\treturn;\n\t}\n\n\tif (dy <= dx) {\n\t\t/* More-or-less horizontal. use wid for vertical stroke */\n\t\t/* Doug Claar: watch out for NaN in atan2 (2.0.5) */\n\t\tif ((dx == 0) && (dy == 0)) {\n\t\t\twid = 1;\n\t\t} else {\n\t\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\nTBB: but watch out for /0! */\n\t\t\tdouble ac = cos (atan2 (dy, dx));\n\t\t\tif (ac != 0) {\n\t\t\t\twid = thick / ac;\n\t\t\t} else {\n\t\t\t\twid = 1;\n\t\t\t}\n\t\t\tif (wid == 0) {\n\t\t\t\twid = 1;\n\t\t\t}\n\t\t}\n\t\td = 2 * dy - dx;\n\t\tincr1 = 2 * dy;\n\t\tincr2 = 2 * (dy - dx);\n\t\tif (x1 > x2) {\n\t\t\tx = x2;\n\t\t\ty = y2;\n\t\t\tydirflag = (-1);\n\t\t\txend = x1;\n\t\t} else {\n\t\t\tx = x1;\n\t\t\ty = y1;\n\t\t\tydirflag = 1;\n\t\t\txend = x2;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = y - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\tgdImageSetPixel(im, x, w, color);\n\t\t}\n\n\t\tif (((y2 - y1) * ydirflag) > 0) {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* More-or-less vertical. use wid for horizontal stroke */\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t   TBB: but watch out for /0! */\n\t\tdouble as = sin (atan2 (dy, dx));\n\t\tif (as != 0) {\n\t\t\twid = thick / as;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0) {\n\t\t\twid = 1;\n\t\t}\n\n\t\td = 2 * dx - dy;\n\t\tincr1 = 2 * dx;\n\t\tincr2 = 2 * (dx - dy);\n\t\tif (y1 > y2) {\n\t\t\ty = y2;\n\t\t\tx = x2;\n\t\t\tyend = y1;\n\t\t\txdirflag = (-1);\n\t\t} else {\n\t\t\ty = y1;\n\t\t\tx = x1;\n\t\t\tyend = y2;\n\t\t\txdirflag = 1;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = x - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t}\n\n\t\tif (((x2 - x1) * xdirflag) > 0) {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}""}, {""func_name"": ""gdImageCopyResized"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""void gdImageCopyResized (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int dstW, int dstH, int srcW, int srcH)\n{\n\tint c;\n\tint x, y;\n\tint tox, toy;\n\tint ydest;\n\tint i;\n\tint colorMap[gdMaxColors];\n\t/* Stretch vectors */\n\tint *stx, *sty;\n\n\tif (overflow2(sizeof(int), srcW)) {\n\t\treturn;\n\t}\n\tif (overflow2(sizeof(int), srcH)) {\n\t\treturn;\n\t}\n\n\tstx = (int *) gdMalloc (sizeof (int) * srcW);\n\tsty = (int *) gdMalloc (sizeof (int) * srcH);\n\n\t/* Fixed by Mao Morimoto 2.0.16 */\n\tfor (i = 0; (i < srcW); i++) {\n\t\tstx[i] = dstW * (i+1) / srcW - dstW * i / srcW ;\n\t}\n\tfor (i = 0; (i < srcH); i++) {\n\t\tsty[i] = dstH * (i+1) / srcH - dstH * i / srcH ;\n\t}\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tcolorMap[i] = (-1);\n\t}\n\ttoy = dstY;\n\tfor (y = srcY; (y < (srcY + srcH)); y++) {\n\t\tfor (ydest = 0; (ydest < sty[y - srcY]); ydest++) {\n\t\t\ttox = dstX;\n\t\t\tfor (x = srcX; (x < (srcX + srcW)); x++) {\n\t\t\t\tint nc = 0;\n\t\t\t\tint mapTo;\n\t\t\t\tif (!stx[x - srcX]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (dst->trueColor) {\n\t\t\t\t\t/* 2.0.9: Thorben Kundinger: Maybe the source image is not a truecolor image */\n\t\t\t\t\tif (!src->trueColor) {\n\t\t\t\t\t  \tint tmp = gdImageGetPixel (src, x, y);\n\t\t  \t\t\t\tmapTo = gdImageGetTrueColorPixel (src, x, y);\n\t\t\t\t\t  \tif (gdImageGetTransparent (src) == tmp) {\n\t\t\t\t\t\t\t/* 2.0.21, TK: not tox++ */\n\t\t\t\t\t\t\ttox += stx[x - srcX];\n\t\t\t\t\t  \t\tcontinue;\n\t\t\t\t\t  \t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* TK: old code follows */\n\t\t\t\t\t  \tmapTo = gdImageGetTrueColorPixel (src, x, y);\n\t\t\t\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\t\t\t\tif (gdImageGetTransparent (src) == mapTo) {\n\t\t\t\t\t\t\t/* 2.0.21, TK: not tox++ */\n\t\t\t\t\t\t\ttox += stx[x - srcX];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc = gdImageGetPixel (src, x, y);\n\t\t\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\t\t\tif (gdImageGetTransparent (src) == c) {\n\t\t\t\t\t      tox += stx[x - srcX];\n\t\t\t\t\t      continue;\n\t\t\t\t\t}\n\t\t\t\t\tif (src->trueColor) {\n\t\t\t\t\t      /* Remap to the palette available in the destination image. This is slow and works badly. */\n\t\t\t\t\t      mapTo = gdImageColorResolveAlpha(dst, gdTrueColorGetRed(c),\n\t\t\t\t\t      \t\t\t\t\t    gdTrueColorGetGreen(c),\n\t\t\t\t\t      \t\t\t\t\t    gdTrueColorGetBlue(c),\n\t\t\t\t\t      \t\t\t\t\t    gdTrueColorGetAlpha (c));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Have we established a mapping for this color? */\n\t\t\t\t\t\tif (colorMap[c] == (-1)) {\n\t\t\t\t\t\t\t/* If it's the same image, mapping is trivial */\n\t\t\t\t\t\t\tif (dst == src) {\n\t\t\t\t\t\t\t\tnc = c;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/* Find or create the best match */\n\t\t\t\t\t\t\t\t/* 2.0.5: can't use gdTrueColorGetRed, etc with palette */\n\t\t\t\t\t\t\t\tnc = gdImageColorResolveAlpha(dst, gdImageRed(src, c),\n\t\t\t\t\t\t\t\t\t\t\t\t   gdImageGreen(src, c),\n\t\t\t\t\t\t\t\t\t\t\t\t   gdImageBlue(src, c),\n\t\t\t\t\t\t\t\t\t\t\t\t   gdImageAlpha(src, c));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcolorMap[c] = nc;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapTo = colorMap[c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = 0; (i < stx[x - srcX]); i++) {\n\t\t\t\t\tgdImageSetPixel (dst, tox, toy, mapTo);\n\t\t\t\t\ttox++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoy++;\n\t\t}\n\t}\n\tgdFree (stx);\n\tgdFree (sty);\n}""}, {""func_name"": ""gdImageRectangle"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""void gdImageRectangle (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint x1h = x1, x1v = x1, y1h = y1, y1v = y1, x2h = x2, x2v = x2, y2h = y2, y2v = y2;\n\tint thick = im->thick;\n\tint t;\n\n\tif (x1 == x2 && y1 == y2 && thick == 1) {\n\t\tgdImageSetPixel(im, x1, y1, color);\n\t\treturn;\n\t}\n\n\tif (y2 < y1) {\n\t\tt=y1;\n\t\ty1 = y2;\n\t\ty2 = t;\n\n\t\tt = x1;\n\t\tx1 = x2;\n\t\tx2 = t;\n\t}\n\n\tx1h = x1; x1v = x1; y1h = y1; y1v = y1; x2h = x2; x2v = x2; y2h = y2; y2v = y2;\n\tif (thick > 1) {\n\t\tint cx, cy, x1ul, y1ul, x2lr, y2lr;\n\t\tint half = thick >> 1;\n\n\t\tx1ul = x1 - half;\n\t\ty1ul = y1 - half;\n\n\t\tx2lr = x2 + half;\n\t\ty2lr = y2 + half;\n\n\t\tcy = y1ul + thick;\n\t\twhile (cy-- > y1ul) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y2lr - thick;\n\t\twhile (cy++ < y2lr) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x1ul + thick) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x2lr - thick - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t} else {\n\t\ty1v = y1h + 1;\n\t\ty2v = y2h - 1;\n\t\tgdImageLine(im, x1h, y1h, x2h, y1h, color);\n\t\tgdImageLine(im, x1h, y2h, x2h, y2h, color);\n\t\tgdImageLine(im, x1v, y1v, x1v, y2v, color);\n\t\tgdImageLine(im, x2v, y1v, x2v, y2v, color);\n\t}\n}""}, {""func_name"": ""gdAlphaBlend"", ""file_path"": ""ext/gd/libgd/gd.c"", ""func_code"": ""int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n\n/* -------------------------------------------------------------------- */\n/*      Simple cases we want to handle fast.                            */\n/* -------------------------------------------------------------------- */\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n\n/* -------------------------------------------------------------------- */\n/*      What will the source and destination alphas be?  Note that      */\n/*      the destination weighting is substantially reduced as the       */\n/*      overlay becomes quite opaque.                                   */\n/* -------------------------------------------------------------------- */\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n\n/* -------------------------------------------------------------------- */\n/*      What red, green and blue result values will we use?             */\n/* -------------------------------------------------------------------- */\n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n/* -------------------------------------------------------------------- */\n/*      Return merged result.                                           */\n/* -------------------------------------------------------------------- */\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n\n}""}]","{""caller"": 3, ""function"": 4}","[{""source"": ""caller_info(file:gd.c, func:gdImageCreate)"", ""result"": [{""call_line"": 2157, ""call_code"": ""gdImageCreate(x_size, y_size)"", ""caller_code"": ""PHP_FUNCTION(imagecreate)\n{\n\tlong x_size, y_size;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ll\"", &x_size, &y_size) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (x_size <= 0 || y_size <= 0 || x_size >= INT_MAX || y_size >= INT_MAX) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid image dimensions\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tim = gdImageCreate(x_size, y_size);\n\n\tif (!im) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n}"", ""caller_start"": 2143, ""file_path"": ""ext/gd/gd.c""}, {""call_line"": 4389, ""call_code"": ""gdImageCreate(dest_width, dest_height)"", ""caller_code"": ""static void _php_image_bw_convert(gdImagePtr im_org, gdIOCtx *out, int threshold)\n{\n\tgdImagePtr im_dest;\n\tint white, black;\n\tint color, color_org, median;\n\tint dest_height = gdImageSY(im_org);\n\tint dest_width = gdImageSX(im_org);\n\tint x, y;\n\tTSRMLS_FETCH();\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate temporary buffer\"");\n\t\treturn;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\treturn;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\treturn;\n\t}\n\n\tif (im_org->trueColor) {\n\t\tgdImageTrueColorToPalette(im_org, 1, 256);\n\t}\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel(im_org, x, y);\n\t\t\tmedian = (im_org->red[color_org] + im_org->green[color_org] + im_org->blue[color_org]) / 3;\n\t\t\tif (median < threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\tgdImageWBMPCtx (im_dest, black, out);\n\n}\n"", ""caller_start"": 4379, ""file_path"": ""ext/gd/gd.c""}, {""call_line"": 4548, ""call_code"": ""gdImageCreate (dest_width, dest_height)"", ""caller_code"": ""static void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )\n{\n\tchar *f_org, *f_dest;\n\tint f_org_len, f_dest_len;\n\tlong height, width, threshold;\n\tgdImagePtr im_org, im_dest, im_tmp;\n\tchar *fn_org = NULL;\n\tchar *fn_dest = NULL;\n\tFILE *org, *dest;\n\tint dest_height = -1;\n\tint dest_width = -1;\n\tint org_height, org_width;\n\tint white, black;\n\tint color, color_org, median;\n\tint int_threshold;\n\tint x, y;\n\tfloat x_ratio, y_ratio;\n    long ignore_warning;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""pplll\"", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfn_org  = f_org;\n\tfn_dest = f_dest;\n\tdest_height = height;\n\tdest_width = width;\n\tint_threshold = threshold;\n\n\t/* Check threshold value */\n\tif (int_threshold < 0 || int_threshold > 8) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid threshold value '%d'\"", int_threshold);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Check origin file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_org, \""Invalid origin filename\"");\n\n\t/* Check destination file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_dest, \""Invalid destination filename\"");\n\n\t/* Open origin file */\n\torg = VCWD_FOPEN(fn_org, \""rb\"");\n\tif (!org) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' for reading\"", fn_org);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Open destination file */\n\tdest = VCWD_FOPEN(fn_dest, \""wb\"");\n\tif (!dest) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' for writing\"", fn_dest);\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (image_type) {\n\t\tcase PHP_GDIMG_TYPE_GIF:\n\t\t\tim_org = gdImageCreateFromGif(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid GIF file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef HAVE_GD_JPG\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\tignore_warning = INI_INT(\""gd.jpeg_ignore_warning\"");\n\t\t\tim_org = gdImageCreateFromJpegEx(org, ignore_warning);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid JPEG file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_JPG */\n\n#ifdef HAVE_GD_PNG\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\tim_org = gdImageCreateFromPng(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid PNG file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_PNG */\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Format not supported\"");\n\t\t\tRETURN_FALSE;\n\t\t\tbreak;\n\t}\n\n\torg_width  = gdImageSX (im_org);\n\torg_height = gdImageSY (im_org);\n\n\tx_ratio = (float) org_width / (float) dest_width;\n\ty_ratio = (float) org_height / (float) dest_height;\n\n\tif (x_ratio > 1 && y_ratio > 1) {\n\t\tif (y_ratio > x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width / x_ratio);\n\t\tdest_height = (int) (org_height / y_ratio);\n\t} else {\n\t\tx_ratio = (float) dest_width / (float) org_width;\n\t\ty_ratio = (float) dest_height / (float) org_height;\n\n\t\tif (y_ratio < x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width * x_ratio);\n\t\tdest_height = (int) (org_height * y_ratio);\n\t}\n\n\tim_tmp = gdImageCreate (dest_width, dest_height);\n\tif (im_tmp == NULL ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate temporary buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized (im_tmp, im_org, 0, 0, 0, 0, dest_width, dest_height, org_width, org_height);\n\n\tgdImageDestroy(im_org);\n\n\tfclose(org);\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tint_threshold = int_threshold * 32;\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel (im_tmp, x, y);\n\t\t\tmedian = (im_tmp->red[color_org] + im_tmp->green[color_org] + im_tmp->blue[color_org]) / 3;\n\t\t\tif (median < int_threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\n\tgdImageDestroy (im_tmp );\n\n\tgdImageWBMP(im_dest, black , dest);\n\n\tfflush(dest);\n\tfclose(dest);\n\n\tgdImageDestroy(im_dest);\n\n\tRETURN_TRUE;\n}\n"", ""caller_start"": 4430, ""file_path"": ""ext/gd/gd.c""}, {""call_line"": 4560, ""call_code"": ""gdImageCreate(dest_width, dest_height)"", ""caller_code"": ""static void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )\n{\n\tchar *f_org, *f_dest;\n\tint f_org_len, f_dest_len;\n\tlong height, width, threshold;\n\tgdImagePtr im_org, im_dest, im_tmp;\n\tchar *fn_org = NULL;\n\tchar *fn_dest = NULL;\n\tFILE *org, *dest;\n\tint dest_height = -1;\n\tint dest_width = -1;\n\tint org_height, org_width;\n\tint white, black;\n\tint color, color_org, median;\n\tint int_threshold;\n\tint x, y;\n\tfloat x_ratio, y_ratio;\n    long ignore_warning;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""pplll\"", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfn_org  = f_org;\n\tfn_dest = f_dest;\n\tdest_height = height;\n\tdest_width = width;\n\tint_threshold = threshold;\n\n\t/* Check threshold value */\n\tif (int_threshold < 0 || int_threshold > 8) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid threshold value '%d'\"", int_threshold);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Check origin file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_org, \""Invalid origin filename\"");\n\n\t/* Check destination file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_dest, \""Invalid destination filename\"");\n\n\t/* Open origin file */\n\torg = VCWD_FOPEN(fn_org, \""rb\"");\n\tif (!org) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' for reading\"", fn_org);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Open destination file */\n\tdest = VCWD_FOPEN(fn_dest, \""wb\"");\n\tif (!dest) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' for writing\"", fn_dest);\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (image_type) {\n\t\tcase PHP_GDIMG_TYPE_GIF:\n\t\t\tim_org = gdImageCreateFromGif(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid GIF file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef HAVE_GD_JPG\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\tignore_warning = INI_INT(\""gd.jpeg_ignore_warning\"");\n\t\t\tim_org = gdImageCreateFromJpegEx(org, ignore_warning);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid JPEG file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_JPG */\n\n#ifdef HAVE_GD_PNG\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\tim_org = gdImageCreateFromPng(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid PNG file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_PNG */\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Format not supported\"");\n\t\t\tRETURN_FALSE;\n\t\t\tbreak;\n\t}\n\n\torg_width  = gdImageSX (im_org);\n\torg_height = gdImageSY (im_org);\n\n\tx_ratio = (float) org_width / (float) dest_width;\n\ty_ratio = (float) org_height / (float) dest_height;\n\n\tif (x_ratio > 1 && y_ratio > 1) {\n\t\tif (y_ratio > x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width / x_ratio);\n\t\tdest_height = (int) (org_height / y_ratio);\n\t} else {\n\t\tx_ratio = (float) dest_width / (float) org_width;\n\t\ty_ratio = (float) dest_height / (float) org_height;\n\n\t\tif (y_ratio < x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width * x_ratio);\n\t\tdest_height = (int) (org_height * y_ratio);\n\t}\n\n\tim_tmp = gdImageCreate (dest_width, dest_height);\n\tif (im_tmp == NULL ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate temporary buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized (im_tmp, im_org, 0, 0, 0, 0, dest_width, dest_height, org_width, org_height);\n\n\tgdImageDestroy(im_org);\n\n\tfclose(org);\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tint_threshold = int_threshold * 32;\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel (im_tmp, x, y);\n\t\t\tmedian = (im_tmp->red[color_org] + im_tmp->green[color_org] + im_tmp->blue[color_org]) / 3;\n\t\t\tif (median < int_threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\n\tgdImageDestroy (im_tmp );\n\n\tgdImageWBMP(im_dest, black , dest);\n\n\tfflush(dest);\n\tfclose(dest);\n\n\tgdImageDestroy(im_dest);\n\n\tRETURN_TRUE;\n}\n"", ""caller_start"": 4430, ""file_path"": ""ext/gd/gd.c""}]}, {""source"": ""func_info(func:overflow2)"", ""result"": [{""code"": ""int overflow2(int a, int b)\n{\n\tTSRMLS_FETCH();\n\n\tif(a <= 0 || b <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""gd warning: one parameter to a memory allocation multiplication is negative or zero, failing operation gracefully\\n\"");\n\t\treturn 1;\n\t}\n\tif(a > INT_MAX / b) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""gd warning: product of memory allocation multiplication would exceed INT_MAX, failing operation gracefully\\n\"");\n\t\treturn 1;\n\t}\n\treturn 0;\n}"", ""start_line"": 49, ""end_line"": 62, ""full_name"": ""overflow2"", ""file_path"": ""ext/gd/gd_compat.c""}, {""code"": ""int overflow2(int a, int b)\n{\n\tif(a <= 0 || b <= 0) {\n\t\tphp_gd_error(\""gd warning: one parameter to a memory allocation multiplication is negative or zero, failing operation gracefully\\n\"");\n\t\treturn 1;\n\t}\n\tif(a > INT_MAX / b) {\n\t\tphp_gd_error(\""gd warning: product of memory allocation multiplication would exceed INT_MAX, failing operation gracefully\\n\"");\n\t\treturn 1;\n\t}\n\treturn 0;\n}"", ""start_line"": 20, ""end_line"": 31, ""full_name"": ""overflow2<duplicate>0"", ""file_path"": ""ext/gd/libgd/gd_security.c""}]}, {""source"": ""caller_info(file:gd.c, func:gdImagePaletteToTrueColor)"", ""result"": [{""call_line"": 1643, ""call_code"": ""gdImagePaletteToTrueColor(im)"", ""caller_code"": ""PHP_FUNCTION(imagepalettetotruecolor)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""r\"", &IM) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \""Image\"", le_gd);\n\n\tif (gdImagePaletteToTrueColor(im) == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}"", ""caller_start"": 1632, ""file_path"": ""ext/gd/gd.c""}, {""call_line"": 1419, ""call_code"": ""gdImagePaletteToTrueColor(src)"", ""caller_code"": ""gdImagePtr gdImageScaleBicubicFixed(gdImagePtr src, const unsigned int width, const unsigned int height)\n{\n\tconst long new_width = MAX(1, width);\n\tconst long new_height = MAX(1, height);\n\tconst int src_w = gdImageSX(src);\n\tconst int src_h = gdImageSY(src);\n\tconst gdFixed f_dx = gd_ftofx((float)src_w / (float)new_width);\n\tconst gdFixed f_dy = gd_ftofx((float)src_h / (float)new_height);\n\tconst gdFixed f_1 = gd_itofx(1);\n\tconst gdFixed f_2 = gd_itofx(2);\n\tconst gdFixed f_4 = gd_itofx(4);\n\tconst gdFixed f_6 = gd_itofx(6);\n\tconst gdFixed f_gamma = gd_ftofx(1.04f);\n\tgdImagePtr dst;\n\n\tunsigned int dst_offset_x;\n\tunsigned int dst_offset_y = 0;\n\tlong i;\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (!dst) {\n\t\treturn NULL;\n\t}\n\n\tdst->saveAlphaFlag = 1;\n\n\tfor (i=0; i < new_height; i++) {\n\t\tlong j;\n\t\tdst_offset_x = 0;\n\n\t\tfor (j=0; j < new_width; j++) {\n\t\t\tconst gdFixed f_a = gd_mulfx(gd_itofx(i), f_dy);\n\t\t\tconst gdFixed f_b = gd_mulfx(gd_itofx(j), f_dx);\n\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\tconst long n = gd_fxtoi(f_b);\n\t\t\tconst gdFixed f_f = f_a - gd_itofx(m);\n\t\t\tconst gdFixed f_g = f_b - gd_itofx(n);\n\t\t\tunsigned int src_offset_x[16], src_offset_y[16];\n\t\t\tlong k;\n\t\t\tregister gdFixed f_red = 0, f_green = 0, f_blue = 0, f_alpha = 0;\n\t\t\tunsigned char red, green, blue, alpha = 0;\n\t\t\tint *dst_row = dst->tpixels[dst_offset_y];\n\n\t\t\tif ((m < 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[0] = n;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[0] = n - 1;\n\t\t\t\tsrc_offset_y[0] = m;\n\t\t\t}\n\n\t\t\tif (m < 1) {\n\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[1] = n;\n\t\t\t\tsrc_offset_y[1] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[2] = n;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[2] = n + 1;\n\t\t\t\tsrc_offset_y[2] = m;\n\t\t\t}\n\n\t\t\tif ((m < 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[3] = n;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[3] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[3] = m;\n\t\t\t}\n\n\t\t\tif (n < 1) {\n\t\t\t\tsrc_offset_x[4] = n;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[4] = n - 1;\n\t\t\t\tsrc_offset_y[4] = m;\n\t\t\t}\n\n\t\t\tsrc_offset_x[5] = n;\n\t\t\tsrc_offset_y[5] = m;\n\t\t\tif (n >= src_w-1) {\n\t\t\t\tsrc_offset_x[6] = n;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[6] = n + 1;\n\t\t\t\tsrc_offset_y[6] = m;\n\t\t\t}\n\n\t\t\tif (n >= src_w - 2) {\n\t\t\t\tsrc_offset_x[7] = n;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[7] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[7] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n < 1)) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[8] = n - 1;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t}\n\n\t\t\tif (m >= src_h - 1) {\n\t\t\t\tsrc_offset_x[8] = n;\n\t\t\t\tsrc_offset_y[8] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[9] = n;\n\t\t\t\tsrc_offset_y[9] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h-1) || (n >= src_w-1)) {\n\t\t\t\tsrc_offset_x[10] = n;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[10] = n + 1;\n\t\t\t\tsrc_offset_y[10] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 1) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[11] = n;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[11] = n + 1 + 1;\n\t\t\t\tsrc_offset_y[11] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n < 1)) {\n\t\t\t\tsrc_offset_x[12] = n;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[12] = n - 1;\n\t\t\t\tsrc_offset_y[12] = m;\n\t\t\t}\n\n\t\t\tif (m >= src_h - 2) {\n\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[13] = n;\n\t\t\t\tsrc_offset_y[13] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 1)) {\n\t\t\t\tsrc_offset_x[14] = n;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[14] = n + 1;\n\t\t\t\tsrc_offset_y[14] = m;\n\t\t\t}\n\n\t\t\tif ((m >= src_h - 2) || (n >= src_w - 2)) {\n\t\t\t\tsrc_offset_x[15] = n;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t} else {\n\t\t\t\tsrc_offset_x[15] = n  + 1 + 1;\n\t\t\t\tsrc_offset_y[15] = m;\n\t\t\t}\n\n\t\t\tfor (k = -1; k < 3; k++) {\n\t\t\t\tconst gdFixed f = gd_itofx(k)-f_f;\n\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_d = 0, f_c = 0;\n\t\t\t\tregister gdFixed f_RY;\n\t\t\t\tint l;\n\n\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2, gd_mulfx(f_fp2,f_fp2));\n\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1, gd_mulfx(f_fp1,f_fp1));\n\t\t\t\tif (f > 0)     f_c = gd_mulfx(f, gd_mulfx(f,f));\n\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1, gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\tf_RY = gd_divfx((f_a - gd_mulfx(f_4,f_b) + gd_mulfx(f_6,f_c) - gd_mulfx(f_4,f_d)),f_6);\n\n\t\t\t\tfor (l = -1; l < 3; l++) {\n\t\t\t\t\tconst gdFixed f = gd_itofx(l) - f_g;\n\t\t\t\t\tconst gdFixed f_fm1 = f - f_1;\n\t\t\t\t\tconst gdFixed f_fp1 = f + f_1;\n\t\t\t\t\tconst gdFixed f_fp2 = f + f_2;\n\t\t\t\t\tregister gdFixed f_a = 0, f_b = 0, f_c = 0, f_d = 0;\n\t\t\t\t\tregister gdFixed f_RX, f_R, f_rs, f_gs, f_bs, f_ba;\n\t\t\t\t\tregister int c;\n\t\t\t\t\tconst int _k = ((k+1)*4) + (l+1);\n\n\t\t\t\t\tif (f_fp2 > 0) f_a = gd_mulfx(f_fp2,gd_mulfx(f_fp2,f_fp2));\n\n\t\t\t\t\tif (f_fp1 > 0) f_b = gd_mulfx(f_fp1,gd_mulfx(f_fp1,f_fp1));\n\n\t\t\t\t\tif (f > 0) f_c = gd_mulfx(f,gd_mulfx(f,f));\n\n\t\t\t\t\tif (f_fm1 > 0) f_d = gd_mulfx(f_fm1,gd_mulfx(f_fm1,f_fm1));\n\n\t\t\t\t\tf_RX = gd_divfx((f_a-gd_mulfx(f_4,f_b)+gd_mulfx(f_6,f_c)-gd_mulfx(f_4,f_d)),f_6);\n\t\t\t\t\tf_R = gd_mulfx(f_RY,f_RX);\n\n\t\t\t\t\tc = src->tpixels[*(src_offset_y + _k)][*(src_offset_x + _k)];\n\t\t\t\t\tf_rs = gd_itofx(gdTrueColorGetRed(c));\n\t\t\t\t\tf_gs = gd_itofx(gdTrueColorGetGreen(c));\n\t\t\t\t\tf_bs = gd_itofx(gdTrueColorGetBlue(c));\n\t\t\t\t\tf_ba = gd_itofx(gdTrueColorGetAlpha(c));\n\n\t\t\t\t\tf_red += gd_mulfx(f_rs,f_R);\n\t\t\t\t\tf_green += gd_mulfx(f_gs,f_R);\n\t\t\t\t\tf_blue += gd_mulfx(f_bs,f_R);\n\t\t\t\t\tf_alpha += gd_mulfx(f_ba,f_R);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tred    = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_red,   f_gamma)),  0, 255);\n\t\t\tgreen  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_green, f_gamma)),  0, 255);\n\t\t\tblue   = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_blue,  f_gamma)),  0, 255);\n\t\t\talpha  = (unsigned char) CLAMP(gd_fxtoi(gd_mulfx(f_alpha,  f_gamma)), 0, 127);\n\n\t\t\t*(dst_row + dst_offset_x) = gdTrueColorAlpha(red, green, blue, alpha);\n\n\t\t\tdst_offset_x++;\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst;\n}\n"", ""caller_start"": 1396, ""file_path"": ""ext/gd/libgd/gd_interpolation.c""}, {""call_line"": 2171, ""call_code"": ""gdImagePaletteToTrueColor(src)"", ""caller_code"": ""gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\tconst int angle_rounded = (int)floor(angle * 100);\n\n\tif (bgcolor < 0) {\n\t\treturn NULL;\n\t}\n\n\t/* impact perf a bit, but not that much. Implementation for palette\n\t   images can be done at a later point.\n\t*/\n\tif (src->trueColor == 0) {\n\t\tif (bgcolor < gdMaxColors) {\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\n\t\t}\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\t/* no interpolation needed here */\n\tswitch (angle_rounded) {\n\t\tcase 9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\t\tcase 18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\t\tcase 27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}\n"", ""caller_start"": 2156, ""file_path"": ""ext/gd/libgd/gd_interpolation.c""}, {""call_line"": 2277, ""call_code"": ""gdImagePaletteToTrueColor(src)"", ""caller_code"": ""int gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\t/* Translate to dst origin (0,0) */\n\tgdAffineTranslate(m, -bbox.x, -bbox.y);\n\tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}"", ""caller_start"": 2250, ""file_path"": ""ext/gd/libgd/gd_interpolation.c""}]}, {""source"": ""func_info(file:gd.c, func:gdImagePaletteToTrueColor)"", ""result"": [{""code"": ""int gdImagePaletteToTrueColor(gdImagePtr src)\n{\n\tunsigned int y;\n\tunsigned int yy;\n\n\tif (src == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (src->trueColor == 1) {\n\t\treturn 1;\n\t} else {\n\t\tunsigned int x;\n\t\tconst unsigned int sy = gdImageSY(src);\n\t\tconst unsigned int sx = gdImageSX(src);\n\n\t\tsrc->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n\t\tif (src->tpixels == NULL) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (y = 0; y < sy; y++) {\n\t\t\tconst unsigned char *src_row = src->pixels[y];\n\t\t\tint * dst_row;\n\n\t\t\t/* no need to calloc it, we overwrite all pxl anyway */\n\t\t\tsrc->tpixels[y] = (int *) gdMalloc(sx * sizeof(int));\n\t\t\tif (src->tpixels[y] == NULL) {\n\t\t\t\tgoto clean_on_error;\n\t\t\t}\n\n\t\t\tdst_row = src->tpixels[y];\n\t\t\tfor (x = 0; x < sx; x++) {\n\t\t\t\tconst unsigned char c = *(src_row + x);\n\t\t\t\tif (c == src->transparent) {\n\t\t\t\t\t*(dst_row + x) = gdTrueColorAlpha(0, 0, 0, 127);\n\t\t\t\t} else {\n\t\t\t\t\t*(dst_row + x) = gdTrueColorAlpha(src->red[c], src->green[c], src->blue[c], src->alpha[c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* free old palette buffer (y is sy) */\n\tfor (yy = 0; yy < y; yy++) {\n\t\tgdFree(src->pixels[yy]);\n\t}\n\tgdFree(src->pixels);\n\tsrc->trueColor = 1;\n\tsrc->pixels = NULL;\n\tsrc->alphaBlendingFlag = 0;\n\tsrc->saveAlphaFlag = 1;\n\n\tif (src->transparent >= 0) {\n\t\tconst unsigned char c = src->transparent;\n\t\tsrc->transparent =  gdTrueColorAlpha(src->red[c], src->green[c], src->blue[c], src->alpha[c]);\n\t}\n\n\treturn 1;\n\nclean_on_error:\n\tif (y > 0) {\n\n\t\tfor (yy = y; yy >= yy - 1; y--) {\n\t\t\tgdFree(src->tpixels[y]);\n\t\t}\n\t\tgdFree(src->tpixels);\n\t}\n\treturn 0;\n}\n"", ""start_line"": 3015, ""end_line"": 3084, ""full_name"": ""gdImagePaletteToTrueColor"", ""file_path"": ""ext/gd/libgd/gd.c""}]}, {""source"": ""func_info(func:gdImageCreateTrueColor)"", ""result"": [{""code"": ""gdImagePtr gdImageCreateTrueColor (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\n\tif (overflow2(sizeof(int), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdMalloc(sizeof(gdImage));\n\tmemset(im, 0, sizeof(gdImage));\n\tim->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\tim->tpixels[i] = (int *) gdCalloc(sx, sizeof(int));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->trueColor = 1;\n\t/* 2.0.2: alpha blending is now on by default, and saving of alpha is\n\t * off by default. This allows font antialiasing to work as expected\n\t * on the first try in JPEGs -- quite important -- and also allows\n\t * for smaller PNGs when saving of alpha channel is not really\n\t * desired, which it usually isn't!\n\t */\n\tim->saveAlphaFlag = 0;\n\tim->alphaBlendingFlag = 1;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}\n"", ""start_line"": 176, ""end_line"": 229, ""full_name"": ""gdImageCreateTrueColor"", ""file_path"": ""ext/gd/libgd/gd.c""}]}, {""source"": ""func_info(func:gdImageTrueColorToPalette)"", ""result"": [{""code"": ""void gdImageTrueColorToPalette (gdImagePtr im, int dither, int colorsWanted)\n{\n\tgdImageTrueColorToPaletteBody(im, dither, colorsWanted, 0);\n}"", ""start_line"": 1766, ""end_line"": 1769, ""full_name"": ""gdImageTrueColorToPalette"", ""file_path"": ""ext/gd/libgd/gd_topal.c""}]}, {""source"": ""caller_info(func:gdImageCreate)"", ""result"": [{""call_line"": 2157, ""call_code"": ""gdImageCreate(x_size, y_size)"", ""caller_code"": ""PHP_FUNCTION(imagecreate)\n{\n\tlong x_size, y_size;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""ll\"", &x_size, &y_size) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (x_size <= 0 || y_size <= 0 || x_size >= INT_MAX || y_size >= INT_MAX) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid image dimensions\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tim = gdImageCreate(x_size, y_size);\n\n\tif (!im) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n}"", ""caller_start"": 2143, ""file_path"": ""ext/gd/gd.c""}, {""call_line"": 4389, ""call_code"": ""gdImageCreate(dest_width, dest_height)"", ""caller_code"": ""static void _php_image_bw_convert(gdImagePtr im_org, gdIOCtx *out, int threshold)\n{\n\tgdImagePtr im_dest;\n\tint white, black;\n\tint color, color_org, median;\n\tint dest_height = gdImageSY(im_org);\n\tint dest_width = gdImageSX(im_org);\n\tint x, y;\n\tTSRMLS_FETCH();\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate temporary buffer\"");\n\t\treturn;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\treturn;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\treturn;\n\t}\n\n\tif (im_org->trueColor) {\n\t\tgdImageTrueColorToPalette(im_org, 1, 256);\n\t}\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel(im_org, x, y);\n\t\t\tmedian = (im_org->red[color_org] + im_org->green[color_org] + im_org->blue[color_org]) / 3;\n\t\t\tif (median < threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\tgdImageWBMPCtx (im_dest, black, out);\n\n}\n"", ""caller_start"": 4379, ""file_path"": ""ext/gd/gd.c""}, {""call_line"": 4548, ""call_code"": ""gdImageCreate (dest_width, dest_height)"", ""caller_code"": ""static void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )\n{\n\tchar *f_org, *f_dest;\n\tint f_org_len, f_dest_len;\n\tlong height, width, threshold;\n\tgdImagePtr im_org, im_dest, im_tmp;\n\tchar *fn_org = NULL;\n\tchar *fn_dest = NULL;\n\tFILE *org, *dest;\n\tint dest_height = -1;\n\tint dest_width = -1;\n\tint org_height, org_width;\n\tint white, black;\n\tint color, color_org, median;\n\tint int_threshold;\n\tint x, y;\n\tfloat x_ratio, y_ratio;\n    long ignore_warning;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""pplll\"", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfn_org  = f_org;\n\tfn_dest = f_dest;\n\tdest_height = height;\n\tdest_width = width;\n\tint_threshold = threshold;\n\n\t/* Check threshold value */\n\tif (int_threshold < 0 || int_threshold > 8) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid threshold value '%d'\"", int_threshold);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Check origin file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_org, \""Invalid origin filename\"");\n\n\t/* Check destination file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_dest, \""Invalid destination filename\"");\n\n\t/* Open origin file */\n\torg = VCWD_FOPEN(fn_org, \""rb\"");\n\tif (!org) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' for reading\"", fn_org);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Open destination file */\n\tdest = VCWD_FOPEN(fn_dest, \""wb\"");\n\tif (!dest) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' for writing\"", fn_dest);\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (image_type) {\n\t\tcase PHP_GDIMG_TYPE_GIF:\n\t\t\tim_org = gdImageCreateFromGif(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid GIF file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef HAVE_GD_JPG\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\tignore_warning = INI_INT(\""gd.jpeg_ignore_warning\"");\n\t\t\tim_org = gdImageCreateFromJpegEx(org, ignore_warning);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid JPEG file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_JPG */\n\n#ifdef HAVE_GD_PNG\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\tim_org = gdImageCreateFromPng(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid PNG file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_PNG */\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Format not supported\"");\n\t\t\tRETURN_FALSE;\n\t\t\tbreak;\n\t}\n\n\torg_width  = gdImageSX (im_org);\n\torg_height = gdImageSY (im_org);\n\n\tx_ratio = (float) org_width / (float) dest_width;\n\ty_ratio = (float) org_height / (float) dest_height;\n\n\tif (x_ratio > 1 && y_ratio > 1) {\n\t\tif (y_ratio > x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width / x_ratio);\n\t\tdest_height = (int) (org_height / y_ratio);\n\t} else {\n\t\tx_ratio = (float) dest_width / (float) org_width;\n\t\ty_ratio = (float) dest_height / (float) org_height;\n\n\t\tif (y_ratio < x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width * x_ratio);\n\t\tdest_height = (int) (org_height * y_ratio);\n\t}\n\n\tim_tmp = gdImageCreate (dest_width, dest_height);\n\tif (im_tmp == NULL ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate temporary buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized (im_tmp, im_org, 0, 0, 0, 0, dest_width, dest_height, org_width, org_height);\n\n\tgdImageDestroy(im_org);\n\n\tfclose(org);\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tint_threshold = int_threshold * 32;\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel (im_tmp, x, y);\n\t\t\tmedian = (im_tmp->red[color_org] + im_tmp->green[color_org] + im_tmp->blue[color_org]) / 3;\n\t\t\tif (median < int_threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\n\tgdImageDestroy (im_tmp );\n\n\tgdImageWBMP(im_dest, black , dest);\n\n\tfflush(dest);\n\tfclose(dest);\n\n\tgdImageDestroy(im_dest);\n\n\tRETURN_TRUE;\n}\n"", ""caller_start"": 4430, ""file_path"": ""ext/gd/gd.c""}, {""call_line"": 4560, ""call_code"": ""gdImageCreate(dest_width, dest_height)"", ""caller_code"": ""static void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )\n{\n\tchar *f_org, *f_dest;\n\tint f_org_len, f_dest_len;\n\tlong height, width, threshold;\n\tgdImagePtr im_org, im_dest, im_tmp;\n\tchar *fn_org = NULL;\n\tchar *fn_dest = NULL;\n\tFILE *org, *dest;\n\tint dest_height = -1;\n\tint dest_width = -1;\n\tint org_height, org_width;\n\tint white, black;\n\tint color, color_org, median;\n\tint int_threshold;\n\tint x, y;\n\tfloat x_ratio, y_ratio;\n    long ignore_warning;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \""pplll\"", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfn_org  = f_org;\n\tfn_dest = f_dest;\n\tdest_height = height;\n\tdest_width = width;\n\tint_threshold = threshold;\n\n\t/* Check threshold value */\n\tif (int_threshold < 0 || int_threshold > 8) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Invalid threshold value '%d'\"", int_threshold);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Check origin file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_org, \""Invalid origin filename\"");\n\n\t/* Check destination file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_dest, \""Invalid destination filename\"");\n\n\t/* Open origin file */\n\torg = VCWD_FOPEN(fn_org, \""rb\"");\n\tif (!org) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' for reading\"", fn_org);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Open destination file */\n\tdest = VCWD_FOPEN(fn_dest, \""wb\"");\n\tif (!dest) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' for writing\"", fn_dest);\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (image_type) {\n\t\tcase PHP_GDIMG_TYPE_GIF:\n\t\t\tim_org = gdImageCreateFromGif(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid GIF file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef HAVE_GD_JPG\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\tignore_warning = INI_INT(\""gd.jpeg_ignore_warning\"");\n\t\t\tim_org = gdImageCreateFromJpegEx(org, ignore_warning);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid JPEG file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_JPG */\n\n#ifdef HAVE_GD_PNG\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\tim_org = gdImageCreateFromPng(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to open '%s' Not a valid PNG file\"", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_PNG */\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Format not supported\"");\n\t\t\tRETURN_FALSE;\n\t\t\tbreak;\n\t}\n\n\torg_width  = gdImageSX (im_org);\n\torg_height = gdImageSY (im_org);\n\n\tx_ratio = (float) org_width / (float) dest_width;\n\ty_ratio = (float) org_height / (float) dest_height;\n\n\tif (x_ratio > 1 && y_ratio > 1) {\n\t\tif (y_ratio > x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width / x_ratio);\n\t\tdest_height = (int) (org_height / y_ratio);\n\t} else {\n\t\tx_ratio = (float) dest_width / (float) org_width;\n\t\ty_ratio = (float) dest_height / (float) org_height;\n\n\t\tif (y_ratio < x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width * x_ratio);\n\t\tdest_height = (int) (org_height * y_ratio);\n\t}\n\n\tim_tmp = gdImageCreate (dest_width, dest_height);\n\tif (im_tmp == NULL ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate temporary buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized (im_tmp, im_org, 0, 0, 0, 0, dest_width, dest_height, org_width, org_height);\n\n\tgdImageDestroy(im_org);\n\n\tfclose(org);\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Unable to allocate the colors for the destination buffer\"");\n\t\tRETURN_FALSE;\n\t}\n\n\tint_threshold = int_threshold * 32;\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel (im_tmp, x, y);\n\t\t\tmedian = (im_tmp->red[color_org] + im_tmp->green[color_org] + im_tmp->blue[color_org]) / 3;\n\t\t\tif (median < int_threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\n\tgdImageDestroy (im_tmp );\n\n\tgdImageWBMP(im_dest, black , dest);\n\n\tfflush(dest);\n\tfclose(dest);\n\n\tgdImageDestroy(im_dest);\n\n\tRETURN_TRUE;\n}\n"", ""caller_start"": 4430, ""file_path"": ""ext/gd/gd.c""}]}]","ext/gd/libgd/gd.c:3015-3084: Integer overflow in `gdImagePaletteToTrueColor()` during memory allocation for `tpixels` (sy * sizeof(int*), sx * sizeof(int)) without overflow checks. Triggered by callers like `gdImageScaleBicubicFixed()` (ext/gd/libgd/gd_interpolation.c:1396) when processing palette images with crafted dimensions. The vulnerability arises because `gdMalloc` is used directly instead of `gdImageCreateTrueColor()` (which includes overflow checks).",0.95,./github/other_context/CVE-2016-5767
46,CVE-2016-6823,CWE-190,c_cpp,"Integer overflow in the BMP coder in ImageMagick before 7.0.2-10 allows remote attackers to cause a denial of service (crash) via crafted height and width values, which triggers an out-of-bounds write.",https://github.com/ImageMagick/ImageMagick/commit/4cc6ec8a4197d4c008577127736bf7985d632323,Prevent buffer overflow in BMP coder (bug report from pwchen of tencent).,1,"[{""func_name"": ""WriteBMPImage"", ""file_path"": ""coders/bmp.c"", ""func_code"": ""static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  type=4;\n  if (LocaleCompare(image_info->magick,\""BMP2\"") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\""BMP3\"") == 0)\n      type=3;\n\n  option=GetImageOption(image_info,\""bmp:format\"");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""  Format=%s\"",option);\n\n      if (LocaleCompare(option,\""bmp2\"") == 0)\n        type=2;\n      if (LocaleCompare(option,\""bmp3\"") == 0)\n        type=3;\n      if (LocaleCompare(option,\""bmp4\"") == 0)\n        type=4;\n    }\n\n  scene=0;\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        bmp_info.bits_per_pixel=(unsigned short)\n          ((type > 3) && (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n        bmp_info.compression=(unsigned int) ((type > 3) &&\n          (image->alpha_trait != UndefinedPixelTrait) ?  BI_BITFIELDS : BI_RGB);\n        if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n          {\n            option=GetImageOption(image_info,\""bmp3:alpha\"");\n            if (IsStringTrue(option))\n              bmp_info.bits_per_pixel=32;\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\""icc\"");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n    bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,\n      sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        size_t\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((size_t) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\""MemoryAllocationFailed\"");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""   Writing BMP version %.20g datastream\"",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Storage class=DirectClass\"");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Storage class=PseudoClass\"");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""   Image depth=%.20g\"",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Matte=True\"");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Matte=MagickFalse\"");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""   BMP bits_per_pixel=%.20g\"",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \""   Compression=BI_RGB\"");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \""   Compression=BI_RLE8\"");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \""   Compression=BI_BITFIELDS\"");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \""   Compression=UNKNOWN (%lu)\"",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Number_colors=unspecified\"");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Number_colors=%lu\"",bmp_info.number_colors);\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \""BM\"");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,0x00ff0000U);  /* Red mask */\n        (void) WriteBlobLSBLong(image,0x0000ff00U);  /* Green mask */\n        (void) WriteBlobLSBLong(image,0x000000ffU);  /* Blue mask */\n        (void) WriteBlobLSBLong(image,0xff000000U);  /* Alpha mask */\n        (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""  Colormap: %.20g entries\"",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \""  Pixels:  %lu bytes\"",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}"", ""target"": 0}]","[{""func_name"": ""WriteBMPImage"", ""file_path"": ""coders/bmp.c"", ""func_code"": ""static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  type=4;\n  if (LocaleCompare(image_info->magick,\""BMP2\"") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\""BMP3\"") == 0)\n      type=3;\n\n  option=GetImageOption(image_info,\""bmp:format\"");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""  Format=%s\"",option);\n\n      if (LocaleCompare(option,\""bmp2\"") == 0)\n        type=2;\n      if (LocaleCompare(option,\""bmp3\"") == 0)\n        type=3;\n      if (LocaleCompare(option,\""bmp4\"") == 0)\n        type=4;\n    }\n\n  scene=0;\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        bmp_info.bits_per_pixel=(unsigned short)\n          ((type > 3) && (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n        bmp_info.compression=(unsigned int) ((type > 3) &&\n          (image->alpha_trait != UndefinedPixelTrait) ?  BI_BITFIELDS : BI_RGB);\n        if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n          {\n            option=GetImageOption(image_info,\""bmp3:alpha\"");\n            if (IsStringTrue(option))\n              bmp_info.bits_per_pixel=32;\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\""icc\"");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    if ((image->columns != (signed int) image->columns) ||\n        (image->rows != (signed int) image->rows))\n      ThrowWriterException(ImageError,\""WidthOrHeightExceedsLimit\"");\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned long) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n    bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,\n      sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        size_t\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((size_t) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\""MemoryAllocationFailed\"");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""   Writing BMP version %.20g datastream\"",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Storage class=DirectClass\"");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Storage class=PseudoClass\"");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""   Image depth=%.20g\"",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Matte=True\"");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Matte=MagickFalse\"");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""   BMP bits_per_pixel=%.20g\"",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \""   Compression=BI_RGB\"");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \""   Compression=BI_RLE8\"");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \""   Compression=BI_BITFIELDS\"");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \""   Compression=UNKNOWN (%lu)\"",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Number_colors=unspecified\"");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""   Number_colors=%lu\"",bmp_info.number_colors);\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \""BM\"");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,0x00ff0000U);  /* Red mask */\n        (void) WriteBlobLSBLong(image,0x0000ff00U);  /* Green mask */\n        (void) WriteBlobLSBLong(image,0x000000ffU);  /* Blue mask */\n        (void) WriteBlobLSBLong(image,0xff000000U);  /* Alpha mask */\n        (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""  Colormap: %.20g entries\"",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \""  Pixels:  %lu bytes\"",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}""}]","{""code"": 2, ""value"": 3}","[{""source"": ""code_info(file:bmp.c, lines:1670-1690)"", ""result"": ""        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n""}, {""source"": ""code_info(file:bmp.c, lines:1600-1700)"", ""result"": ""    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        bmp_info.bits_per_pixel=(unsigned short)\n          ((type > 3) && (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n        bmp_info.compression=(unsigned int) ((type > 3) &&\n          (image->alpha_trait != UndefinedPixelTrait) ?  BI_BITFIELDS : BI_RGB);\n        if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n          {\n            option=GetImageOption(image_info,\""bmp3:alpha\"");\n            if (IsStringTrue(option))\n              bmp_info.bits_per_pixel=32;\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\""icc\"");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n    bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n""}, {""source"": ""value_info(file:bmp.c, value:bytes_per_line)"", ""result"": {""value_trace"": [{""full_code"": ""bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32)"", ""line"": 924, ""func_name"": ""ReadBMPImage""}, {""full_code"": ""bytes_per_line=4*(image->columns)"", ""line"": 973, ""func_name"": ""ReadBMPImage""}, {""full_code"": ""bytes_per_line=image->columns"", ""line"": 1140, ""func_name"": ""ReadBMPImage""}, {""full_code"": ""bytes_per_line=2*(image->columns+image->columns % 2)"", ""line"": 1185, ""func_name"": ""ReadBMPImage""}, {""full_code"": ""bytes_per_line=4*((image->columns*24+31)/32)"", ""line"": 1246, ""func_name"": ""ReadBMPImage""}], ""struct_var"": ""bytes_per_line"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}, {""source"": ""value_info(file:image.h, value:image->columns)"", ""result"": {""value_trace"": [{""full_code"": ""image->columns=columns"", ""line"": 155, ""func_name"": ""ConstituteImage""}, {""full_code"": ""image->columns=columns"", ""line"": 1787, ""func_name"": ""RenderHoughLines""}, {""full_code"": ""image->columns=(size_t) (draw_info->affine.sx*image->columns)"", ""line"": 1794, ""func_name"": ""RenderHoughLines""}, {""full_code"": ""image->columns=image->extract_info.width"", ""line"": 229, ""func_name"": ""AcquireImage""}, {""full_code"": ""(image->columns) ^= (image->extract_info.width)"", ""line"": 244, ""func_name"": ""AcquireImage""}], ""struct_var"": ""image"", ""struct_type"": ""Image"", ""struct_definition"": ""Magick.Image.Image:ANY(void)\n\nMagick.Image.Image:ANY(Magick.Blob&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t,std.string&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,std.string&)\n\nMagick.Image.Image:ANY(Magick.Geometry&,Magick.Color&)\n\nMagick.Image.Image:ANY(Magick.Image&)\n\nMagick.Image.Image:ANY(Magick.Image&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(size_t,size_t,std.string&,StorageType,void*)\n\nMagick.Image.Image:ANY(std.string&)\n\nMagick.Image.Image:ANY(MagickCore.Image*)\n\nclass MagickPPExport Image\n\nclass MagickPPExport Image\n  {\n  public:\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n    // Construct Image of specified size from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_);\n\n    // Construct Image of specified size and depth from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_);\n\n    // Construct Image of specified size, depth, and format from\n    // in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_,\n      const std::string &magick_);\n\n    // Construct Image of specified size, and format from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const std::string &magick_);\n\n    // Construct a blank image canvas of specified size and color\n    Image(const Geometry &size_,const Color &color_);\n\n    // Copy constructor\n    Image(const Image &image_);\n\n    // Copy constructor to copy part of the image\n   ...\n\nclass Image\n\nclass Image\n\nfriend class Image\n\ntypedef struct _Image Image;""}}, {""source"": ""value_info(file:image.h, value:bmp_info.bits_per_pixel)"", ""result"": {""value_trace"": [{""full_code"": ""bmp_info.bits_per_pixel=ReadBlobLSBShort(image)"", ""line"": 608, ""func_name"": ""ReadBMPImage""}, {""full_code"": ""bmp_info.bits_per_pixel=ReadBlobLSBShort(image)"", ""line"": 634, ""func_name"": ""ReadBMPImage""}, {""full_code"": ""bmp_info.bits_per_pixel<<=1"", ""line"": 923, ""func_name"": ""ReadBMPImage""}, {""full_code"": ""bmp_info.bits_per_pixel=8"", ""line"": 1609, ""func_name"": ""WriteBMPImage""}, {""full_code"": ""bmp_info.bits_per_pixel=1"", ""line"": 1611, ""func_name"": ""WriteBMPImage""}], ""struct_var"": ""bmp_info"", ""struct_type"": null, ""struct_definition"": null}}]","coders/bmp.c:1684: image_size = bytes_per_line * image->rows (using 'unsigned int') is prone to overflow. Patch promotes image_size to 'unsigned long' but retains unvalidated 'bytes_per_line' calculation from coders/bmp.c:1600-1700 (bytes_per_line = 4*((columns*bmp_info.bits_per_pixel+31)/32)). Lack of overflow checks on 'columns*bmp_info.bits_per_pixel' creates a chain of potential overflows. image->columns is of type 'size_t' (from image.h) and bmp_info.bits_per_pixel is 'unsigned short' (from value_info). Multiplication of large 'columns' and 'bits_per_pixel' could overflow 'size_t' on 32-bit systems, leading to incorrect 'bytes_per_line' and subsequent buffer allocation.",0.95,./github/other_context/CVE-2016-6823
47,CVE-2017-1000450,CWE-190,c_cpp,"In opencv/modules/imgcodecs/src/utils.cpp, functions FillUniColor and FillUniGray do not check the input length, which can lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",https://github.com/opencv/opencv/commit/c58152d94ba878b2d7d76bcac59146312199b9eb,Fix out of bounds write,1,"[{""func_name"": ""BmpDecoder::readData"", ""file_path"": ""modules/imgcodecs/src/grfmt_bmp.cpp"", ""func_code"": ""bool  BmpDecoder::readData( Mat& img )\n{\n    uchar* data = img.ptr();\n    int step = validateToInt(img.step);\n    bool color = img.channels() > 1;\n    uchar  gray_palette[256] = {0};\n    bool   result = false;\n    int  src_pitch = ((m_width*(m_bpp != 15 ? m_bpp : 16) + 7)/8 + 3) & -4;\n    int  nch = color ? 3 : 1;\n    int  y, width3 = m_width*nch;\n\n    if( m_offset < 0 || !m_strm.isOpened())\n        return false;\n\n    if( m_origin == IPL_ORIGIN_BL )\n    {\n        data += (m_height - 1)*(size_t)step;\n        step = -step;\n    }\n\n    AutoBuffer<uchar> _src, _bgr;\n    _src.allocate(src_pitch + 32);\n\n    if( !color )\n    {\n        if( m_bpp <= 8 )\n        {\n            CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp );\n        }\n        _bgr.allocate(m_width*3 + 32);\n    }\n    uchar *src = _src, *bgr = _bgr;\n\n    try\n    {\n        m_strm.setPos( m_offset );\n\n        switch( m_bpp )\n        {\n        /************************* 1 BPP ************************/\n        case 1:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                FillColorRow1( color ? data : bgr, src, m_width, m_palette );\n                if( !color )\n                    icvCvt_BGR2Gray_8u_C3C1R( bgr, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n\n        /************************* 4 BPP ************************/\n        case 4:\n            if( m_rle_code == BMP_RGB )\n            {\n                for( y = 0; y < m_height; y++, data += step )\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( color )\n                        FillColorRow4( data, src, m_width, m_palette );\n                    else\n                        FillGrayRow4( data, src, m_width, gray_palette );\n                }\n                result = true;\n            }\n            else if( m_rle_code == BMP_RLE4 ) // rle4 compression\n            {\n                uchar* line_end = data + width3;\n                y = 0;\n\n                for(;;)\n                {\n                    int code = m_strm.getWord();\n                    int len = code & 255;\n                    code >>= 8;\n                    if( len != 0 ) // encoded mode\n                    {\n                        PaletteEntry clr[2];\n                        uchar gray_clr[2];\n                        int t = 0;\n\n                        clr[0] = m_palette[code >> 4];\n                        clr[1] = m_palette[code & 15];\n                        gray_clr[0] = gray_palette[code >> 4];\n                        gray_clr[1] = gray_palette[code & 15];\n\n                        uchar* end = data + len*nch;\n                        if( end > line_end ) goto decode_rle4_bad;\n                        do\n                        {\n                            if( color )\n                                WRITE_PIX( data, clr[t] );\n                            else\n                                *data = gray_clr[t];\n                            t ^= 1;\n                        }\n                        while( (data += nch) < end );\n                    }\n                    else if( code > 2 ) // absolute mode\n                    {\n                        if( data + code*nch > line_end ) goto decode_rle4_bad;\n                        int sz = (((code + 1)>>1) + 1) & (~1);\n                        CV_Assert((size_t)sz < _src.size());\n                        m_strm.getBytes(src, sz);\n                        if( color )\n                            data = FillColorRow4( data, src, code, m_palette );\n                        else\n                            data = FillGrayRow4( data, src, code, gray_palette );\n                    }\n                    else\n                    {\n                        int x_shift3 = (int)(line_end - data);\n                        int y_shift = m_height - y;\n\n                        if( code == 2 )\n                        {\n                            x_shift3 = m_strm.getByte()*nch;\n                            y_shift = m_strm.getByte();\n                        }\n\n                        len = x_shift3 + ((y_shift * width3) & ((code == 0) - 1));\n\n                        if( color )\n                            data = FillUniColor( data, line_end, step, width3,\n                                                 y, m_height, x_shift3,\n                                                 m_palette[0] );\n                        else\n                            data = FillUniGray( data, line_end, step, width3,\n                                                y, m_height, x_shift3,\n                                                gray_palette[0] );\n\n                        if( y >= m_height )\n                            break;\n                    }\n                }\n\n                result = true;\ndecode_rle4_bad: ;\n            }\n            break;\n\n        /************************* 8 BPP ************************/\n        case 8:\n            if( m_rle_code == BMP_RGB )\n            {\n                for( y = 0; y < m_height; y++, data += step )\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( color )\n                        FillColorRow8( data, src, m_width, m_palette );\n                    else\n                        FillGrayRow8( data, src, m_width, gray_palette );\n                }\n                result = true;\n            }\n            else if( m_rle_code == BMP_RLE8 ) // rle8 compression\n            {\n                uchar* line_end = data + width3;\n                int line_end_flag = 0;\n                y = 0;\n\n                for(;;)\n                {\n                    int code = m_strm.getWord();\n                    int len = code & 255;\n                    code >>= 8;\n                    if( len != 0 ) // encoded mode\n                    {\n                        int prev_y = y;\n                        len *= nch;\n\n                        if( data + len > line_end )\n                            goto decode_rle8_bad;\n\n                        if( color )\n                            data = FillUniColor( data, line_end, step, width3,\n                                                 y, m_height, len,\n                                                 m_palette[code] );\n                        else\n                            data = FillUniGray( data, line_end, step, width3,\n                                                y, m_height, len,\n                                                gray_palette[code] );\n\n                        line_end_flag = y - prev_y;\n                    }\n                    else if( code > 2 ) // absolute mode\n                    {\n                        int prev_y = y;\n                        int code3 = code*nch;\n\n                        if( data + code3 > line_end )\n                            goto decode_rle8_bad;\n                        int sz = (code + 1) & (~1);\n                        CV_Assert((size_t)sz < _src.size());\n                        m_strm.getBytes(src, sz);\n                        if( color )\n                            data = FillColorRow8( data, src, code, m_palette );\n                        else\n                            data = FillGrayRow8( data, src, code, gray_palette );\n\n                        line_end_flag = y - prev_y;\n                    }\n                    else\n                    {\n                        int x_shift3 = (int)(line_end - data);\n                        int y_shift = m_height - y;\n\n                        if( code || !line_end_flag || x_shift3 < width3 )\n                        {\n                            if( code == 2 )\n                            {\n                                x_shift3 = m_strm.getByte()*nch;\n                                y_shift = m_strm.getByte();\n                            }\n\n                            x_shift3 += (y_shift * width3) & ((code == 0) - 1);\n\n                            if( y >= m_height )\n                                break;\n\n                            if( color )\n                                data = FillUniColor( data, line_end, step, width3,\n                                                     y, m_height, x_shift3,\n                                                     m_palette[0] );\n                            else\n                                data = FillUniGray( data, line_end, step, width3,\n                                                    y, m_height, x_shift3,\n                                                    gray_palette[0] );\n\n                            if( y >= m_height )\n                                break;\n                        }\n\n                        line_end_flag = 0;\n                        if( y >= m_height )\n                            break;\n                    }\n                }\n\n                result = true;\ndecode_rle8_bad: ;\n            }\n            break;\n        /************************* 15 BPP ************************/\n        case 15:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if( !color )\n                    icvCvt_BGR5552Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGR5552BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        /************************* 16 BPP ************************/\n        case 16:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if( !color )\n                    icvCvt_BGR5652Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGR5652BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        /************************* 24 BPP ************************/\n        case 24:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if(!color)\n                    icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    memcpy( data, src, m_width*3 );\n            }\n            result = true;\n            break;\n        /************************* 32 BPP ************************/\n        case 32:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n\n                if( !color )\n                    icvCvt_BGRA2Gray_8u_C4C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGRA2BGR_8u_C4C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        default:\n            CV_ErrorNoReturn(cv::Error::StsError, \""Invalid/unsupported mode\"");\n        }\n    }\n    catch(...)\n    {\n        throw;\n    }\n\n    return result;\n}"", ""target"": 0}]","[{""func_name"": ""BmpDecoder::readData"", ""file_path"": ""modules/imgcodecs/src/grfmt_bmp.cpp"", ""func_code"": ""bool  BmpDecoder::readData( Mat& img )\n{\n    uchar* data = img.ptr();\n    int step = validateToInt(img.step);\n    bool color = img.channels() > 1;\n    uchar  gray_palette[256] = {0};\n    bool   result = false;\n    int  src_pitch = ((m_width*(m_bpp != 15 ? m_bpp : 16) + 7)/8 + 3) & -4;\n    int  nch = color ? 3 : 1;\n    int  y, width3 = m_width*nch;\n\n    if( m_offset < 0 || !m_strm.isOpened())\n        return false;\n\n    if( m_origin == IPL_ORIGIN_BL )\n    {\n        data += (m_height - 1)*(size_t)step;\n        step = -step;\n    }\n\n    AutoBuffer<uchar> _src, _bgr;\n    _src.allocate(src_pitch + 32);\n\n    if( !color )\n    {\n        if( m_bpp <= 8 )\n        {\n            CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp );\n        }\n        _bgr.allocate(m_width*3 + 32);\n    }\n    uchar *src = _src, *bgr = _bgr;\n\n    try\n    {\n        m_strm.setPos( m_offset );\n\n        switch( m_bpp )\n        {\n        /************************* 1 BPP ************************/\n        case 1:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                FillColorRow1( color ? data : bgr, src, m_width, m_palette );\n                if( !color )\n                    icvCvt_BGR2Gray_8u_C3C1R( bgr, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n\n        /************************* 4 BPP ************************/\n        case 4:\n            if( m_rle_code == BMP_RGB )\n            {\n                for( y = 0; y < m_height; y++, data += step )\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( color )\n                        FillColorRow4( data, src, m_width, m_palette );\n                    else\n                        FillGrayRow4( data, src, m_width, gray_palette );\n                }\n                result = true;\n            }\n            else if( m_rle_code == BMP_RLE4 ) // rle4 compression\n            {\n                uchar* line_end = data + width3;\n                y = 0;\n\n                for(;;)\n                {\n                    int code = m_strm.getWord();\n                    int len = code & 255;\n                    code >>= 8;\n                    if( len != 0 ) // encoded mode\n                    {\n                        PaletteEntry clr[2];\n                        uchar gray_clr[2];\n                        int t = 0;\n\n                        clr[0] = m_palette[code >> 4];\n                        clr[1] = m_palette[code & 15];\n                        gray_clr[0] = gray_palette[code >> 4];\n                        gray_clr[1] = gray_palette[code & 15];\n\n                        uchar* end = data + len*nch;\n                        if( end > line_end ) goto decode_rle4_bad;\n                        do\n                        {\n                            if( color )\n                                WRITE_PIX( data, clr[t] );\n                            else\n                                *data = gray_clr[t];\n                            t ^= 1;\n                        }\n                        while( (data += nch) < end );\n                    }\n                    else if( code > 2 ) // absolute mode\n                    {\n                        if( data + code*nch > line_end ) goto decode_rle4_bad;\n                        int sz = (((code + 1)>>1) + 1) & (~1);\n                        CV_Assert((size_t)sz < _src.size());\n                        m_strm.getBytes(src, sz);\n                        if( color )\n                            data = FillColorRow4( data, src, code, m_palette );\n                        else\n                            data = FillGrayRow4( data, src, code, gray_palette );\n                    }\n                    else\n                    {\n                        int x_shift3 = (int)(line_end - data);\n                        int y_shift = m_height - y;\n\n                        if( code == 2 )\n                        {\n                            x_shift3 = m_strm.getByte()*nch;\n                            y_shift = m_strm.getByte();\n                        }\n\n                        len = x_shift3 + ((y_shift * width3) & ((code == 0) - 1));\n\n                        if( color )\n                            data = FillUniColor( data, line_end, step, width3,\n                                                 y, m_height, x_shift3,\n                                                 m_palette[0] );\n                        else\n                            data = FillUniGray( data, line_end, step, width3,\n                                                y, m_height, x_shift3,\n                                                gray_palette[0] );\n\n                        if( y >= m_height )\n                            break;\n                    }\n                }\n\n                result = true;\ndecode_rle4_bad: ;\n            }\n            break;\n\n        /************************* 8 BPP ************************/\n        case 8:\n            if( m_rle_code == BMP_RGB )\n            {\n                for( y = 0; y < m_height; y++, data += step )\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( color )\n                        FillColorRow8( data, src, m_width, m_palette );\n                    else\n                        FillGrayRow8( data, src, m_width, gray_palette );\n                }\n                result = true;\n            }\n            else if( m_rle_code == BMP_RLE8 ) // rle8 compression\n            {\n                uchar* line_end = data + width3;\n                int line_end_flag = 0;\n                y = 0;\n\n                for(;;)\n                {\n                    int code = m_strm.getWord();\n                    int len = code & 255;\n                    code >>= 8;\n                    if( len != 0 ) // encoded mode\n                    {\n                        int prev_y = y;\n                        len *= nch;\n\n                        if( data + len > line_end )\n                            goto decode_rle8_bad;\n\n                        if( color )\n                            data = FillUniColor( data, line_end, step, width3,\n                                                 y, m_height, len,\n                                                 m_palette[code] );\n                        else\n                            data = FillUniGray( data, line_end, step, width3,\n                                                y, m_height, len,\n                                                gray_palette[code] );\n\n                        line_end_flag = y - prev_y;\n\n                        if( y >= m_height )\n                            break;\n                    }\n                    else if( code > 2 ) // absolute mode\n                    {\n                        int prev_y = y;\n                        int code3 = code*nch;\n\n                        if( data + code3 > line_end )\n                            goto decode_rle8_bad;\n                        int sz = (code + 1) & (~1);\n                        CV_Assert((size_t)sz < _src.size());\n                        m_strm.getBytes(src, sz);\n                        if( color )\n                            data = FillColorRow8( data, src, code, m_palette );\n                        else\n                            data = FillGrayRow8( data, src, code, gray_palette );\n\n                        line_end_flag = y - prev_y;\n                    }\n                    else\n                    {\n                        int x_shift3 = (int)(line_end - data);\n                        int y_shift = m_height - y;\n\n                        if( code || !line_end_flag || x_shift3 < width3 )\n                        {\n                            if( code == 2 )\n                            {\n                                x_shift3 = m_strm.getByte()*nch;\n                                y_shift = m_strm.getByte();\n                            }\n\n                            x_shift3 += (y_shift * width3) & ((code == 0) - 1);\n\n                            if( y >= m_height )\n                                break;\n\n                            if( color )\n                                data = FillUniColor( data, line_end, step, width3,\n                                                     y, m_height, x_shift3,\n                                                     m_palette[0] );\n                            else\n                                data = FillUniGray( data, line_end, step, width3,\n                                                    y, m_height, x_shift3,\n                                                    gray_palette[0] );\n\n                            if( y >= m_height )\n                                break;\n                        }\n\n                        line_end_flag = 0;\n                        if( y >= m_height )\n                            break;\n                    }\n                }\n\n                result = true;\ndecode_rle8_bad: ;\n            }\n            break;\n        /************************* 15 BPP ************************/\n        case 15:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if( !color )\n                    icvCvt_BGR5552Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGR5552BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        /************************* 16 BPP ************************/\n        case 16:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if( !color )\n                    icvCvt_BGR5652Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGR5652BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        /************************* 24 BPP ************************/\n        case 24:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n                if(!color)\n                    icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    memcpy( data, src, m_width*3 );\n            }\n            result = true;\n            break;\n        /************************* 32 BPP ************************/\n        case 32:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( src, src_pitch );\n\n                if( !color )\n                    icvCvt_BGRA2Gray_8u_C4C1R( src, 0, data, 0, cvSize(m_width,1) );\n                else\n                    icvCvt_BGRA2BGR_8u_C4C3R( src, 0, data, 0, cvSize(m_width,1) );\n            }\n            result = true;\n            break;\n        default:\n            CV_ErrorNoReturn(cv::Error::StsError, \""Invalid/unsupported mode\"");\n        }\n    }\n    catch(...)\n    {\n        throw;\n    }\n\n    return result;\n}""}]","{""function"": 2, ""code"": 4, ""value"": 2}","[{""source"": ""func_info(file:utils.cpp, func:FillUniColor)"", ""result"": [{""code"": ""uchar* FillUniColor( uchar* data, uchar*& line_end,\n                     int step, int width3,\n                     int& y, int height,\n                     int count3, PaletteEntry clr )\n{\n    do\n   "", ""start_line"": 408, ""end_line"": 437, ""full_name"": ""FillUniColor:unsigned char*(uchar*,uchar*&,int,int,int&,int,int,PaletteEntry)"", ""file_path"": ""modules/imgcodecs/src/utils.cpp""}]}, {""source"": ""func_info(file:utils.cpp, func:FillUniGray)"", ""result"": [{""code"": ""uchar* FillUniGray( uchar* data, uchar*& line_end,\n                    int step, int width,\n                    int& y, int height,\n                    int count, uchar clr )\n{\n    do\n    {\n        uc"", ""start_line"": 440, ""end_line"": 469, ""full_name"": ""FillUniGray:unsigned char*(uchar*,uchar*&,int,int,int&,int,int,uchar)"", ""file_path"": ""modules/imgcodecs/src/utils.cpp""}]}, {""source"": ""code_info(file:grfmt_bmp.cpp, lines:350-380)"", ""result"": ""            {\n                uchar* line_end = data + width3;\n                int line_end_flag = 0;\n                y = 0;\n\n                for(;;)\n                {\n                    int code = m_strm.getWord();\n                    int len = code & 255;\n                    code >>= 8;\n                    if( len != 0 ) // encoded mode\n                    {\n                        int prev_y = y;\n                        len *= nch;\n\n                        if( data + len > line_end )\n                            goto decode_rle8_bad;\n\n                        if( color )\n                            data = FillUniColor( data, line_end, step, width3,\n                                                 y, m_height, len,\n                                                 m_palette[code] );\n                        else\n                            data = FillUniGray( data, line_end, step, width3,\n                                                y, m_height, len,\n                                                gray_palette[code] );\n\n                        line_end_flag = y - prev_y;\n                    }\n                    else if( code > 2 ) // absolute mode\n                    {\n                        int prev_y = y;\n""}, {""source"": ""value_info(file:grfmt_bmp.cpp, value:code)"", ""result"": {""value_trace"": [{""full_code"": ""code = m_strm.getWord()"", ""line"": 266, ""func_name"": ""cv.BmpDecoder.readData:bool(cv.Mat&)""}, {""full_code"": ""code >>= 8"", ""line"": 268, ""func_name"": ""cv.BmpDecoder.readData:bool(cv.Mat&)""}, {""full_code"": ""code = m_strm.getWord()"", ""line"": 357, ""func_name"": ""cv.BmpDecoder.readData:bool(cv.Mat&)""}, {""full_code"": ""code >>= 8"", ""line"": 359, ""func_name"": ""cv.BmpDecoder.readData:bool(cv.Mat&)""}], ""struct_var"": ""code"", ""struct_type"": ""int"", ""struct_definition"": ""RNG.int:ANY()\n\ncv.FileNode.int:int()<const>\n\ncv.RNG_MT19937.int:int()\n\nint""}}, {""source"": ""value_info(file:grfmt_bmp.cpp, value:y)"", ""result"": {""value_trace"": [{""full_code"": ""y = 0"", ""line"": 235, ""func_name"": ""cv.BmpDecoder.readData:bool(cv.Mat&)""}, {""full_code"": ""y = 0"", ""line"": 249, ""func_name"": ""cv.BmpDecoder.readData:bool(cv.Mat&)""}, {""full_code"": ""y = 0"", ""line"": 262, ""func_name"": ""cv.BmpDecoder.readData:bool(cv.Mat&)""}], ""struct_var"": ""y"", ""struct_type"": ""int"", ""struct_definition"": ""RNG.int:ANY()\n\ncv.FileNode.int:int()<const>\n\ncv.RNG_MT19937.int:int()\n\nint""}}, {""source"": ""code_info(file:utils.cpp, lines:408-437)"", ""result"": ""uchar* FillUniColor( uchar* data, uchar*& line_end,\n                     int step, int width3,\n                     int& y, int height,\n                     int count3, PaletteEntry clr )\n{\n    do\n    {\n        uchar* end = data + count3;\n\n        if( end > line_end )\n            end = line_end;\n\n        count3 -= (int)(end - data);\n\n        for( ; data < end; data += 3 )\n        {\n            WRITE_PIX( data, clr );\n        }\n\n        if( data >= line_end )\n        {\n            line_end += step;\n            data = line_end - width3;\n            if( ++y >= height  ) break;\n        }\n    }\n    while( count3 > 0 );\n\n    return data;\n}\n\n""}, {""source"": ""code_info(file:utils.cpp, lines:440-469)"", ""result"": ""uchar* FillUniGray( uchar* data, uchar*& line_end,\n                    int step, int width,\n                    int& y, int height,\n                    int count, uchar clr )\n{\n    do\n    {\n        uchar* end = data + count;\n\n        if( end > line_end )\n            end = line_end;\n\n        count -= (int)(end - data);\n\n        for( ; data < end; data++ )\n        {\n            *data = clr;\n        }\n\n        if( data >= line_end )\n        {\n            line_end += step;\n            data = line_end - width;\n            if( ++y >= height  ) break;\n        }\n    }\n    while( count > 0 );\n\n    return data;\n}\n\n""}, {""source"": ""code_info(file:grfmt_bmp.cpp, lines:266-268)"", ""result"": ""                    int code = m_strm.getWord();\n                    int len = code & 255;\n                    code >>= 8;\n                    if( len != 0 ) // encoded mode\n""}]","The patch in `BmpDecoder::readData` (lines 376-378) adds a check to break if `y >= m_height`, preventing out-of-bounds writes. In `BmpDecoder::readData` (lines 357-359), `len` is calculated as `code & 255` and multiplied by `nch` (number of channels). If `len * nch` exceeds buffer bounds, it could cause overflow. The `FillUniColor` (lines 408-437) and `FillUniGray` (lines 440-469) functions increment `y` when processing data across lines. If `y` exceeds `m_height`, these functions would write beyond the allocated buffer. The patch ensures `y` does not exceed `m_height`, directly addressing the vulnerability by preventing out-of-bounds memory access.",0.95,./github/other_context/CVE-2017-1000450
48,CVE-2017-5953,CWE-190,c_cpp,"vim before patch 8.0.0322 does not properly validate values for tree length when handling a spell file, which may result in an integer overflow at a memory allocation site and a resultant buffer overflow.",https://github.com/vim/vim/commit/399c297aa93afe2c0a39e2a1b3f972aebba44c9d,patch 8.0.0322: possible overflow with corrupted spell file\n\nProblem:    Possible overflow with spell file where the tree length is\n            corrupted.\nSolution:   Check for an invalid length (suggested by shqking),1,"[{""func_name"": ""spell_read_tree"", ""file_path"": ""src/spellfile.c"", ""func_code"": ""static int\nspell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t/* TRUE for the prefix tree */\n    int\t\tprefixcnt)\t/* when \""prefixtree\"" is TRUE: prefix count */\n{\n    int\t\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    /* The tree size was computed when writing the file, so that we can\n     * allocate it as one long block. <nodecount> */\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len > 0)\n    {\n\t/* Allocate the byte array. */\n\tbp = lalloc((long_u)len, TRUE);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\n\t/* Allocate the index array. */\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t/* Recursively read the tree and store it in the array. */\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""spell_read_tree"", ""file_path"": ""src/spellfile.c"", ""func_code"": ""static int\nspell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t/* TRUE for the prefix tree */\n    int\t\tprefixcnt)\t/* when \""prefixtree\"" is TRUE: prefix count */\n{\n    int\t\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    /* The tree size was computed when writing the file, so that we can\n     * allocate it as one long block. <nodecount> */\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len >= 0x3ffffff)\n\t/* Invalid length, multiply with sizeof(int) would overflow. */\n\treturn SP_FORMERROR;\n    if (len > 0)\n    {\n\t/* Allocate the byte array. */\n\tbp = lalloc((long_u)len, TRUE);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\n\t/* Allocate the index array. */\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t/* Recursively read the tree and store it in the array. */\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}""}]","{""code"": 1}","[{""source"": ""code_info(file:spellfile.c, lines:1602-1610)"", ""result"": ""\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\n\t/* Allocate the index array. */\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n""}]","The 'len' variable is read from a spell file via get4c(fd) in src/spellfile.c:1596. The original code lacked validation for excessively large 'len' values. The patch adds a check at src/spellfile.c:1599-1601 to reject len >= 0x3ffffff, which would overflow when multiplied by sizeof(int) during allocation. The allocation logic is explicitly shown in src/spellfile.c:1605 with (long_u)(len * sizeof(int)), confirming the overflow risk prior to the patch.",0.95,./github/other_context/CVE-2017-5953
49,CVE-2017-6350,CWE-190,c_cpp,"An integer overflow at an unserialize_uep memory allocation site would occur for vim before patch 8.0.0378, if it does not properly validate values for tree length when reading a corrupted undo file, which may lead to resultant buffer overflows.",https://github.com/vim/vim/commit/0c8485f0e4931463c0f7986e1ea84a7d79f10c75,patch 8.0.0378: possible overflow when reading corrupted undo file\n\nProblem:    Another possible overflow when reading corrupted undo file.\nSolution:   Check if allocated size is not too big. (King),1,"[{""func_name"": ""unserialize_uep"", ""file_path"": ""src/undo.c"", ""func_code"": ""static u_entry_T *\nunserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tarray = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    else\n\tarray = NULL;\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\""line length\"", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i] = line;\n    }\n    return uep;\n}"", ""target"": 0}]","[{""func_name"": ""unserialize_uep"", ""file_path"": ""src/undo.c"", ""func_code"": ""static u_entry_T *\nunserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array = NULL;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tif (uep->ue_size < LONG_MAX / (int)sizeof(char_u *))\n\t    array = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\""line length\"", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i] = line;\n    }\n    return uep;\n}""}]","{""function"": 1}","[{""source"": ""func_info(file:undo.c, func:undo_read_4c)"", ""result"": [{""code"": ""static int\nundo_read_4c(bufinfo_T *bi)\n{\n#ifdef FEAT_CRYPT\n    if (bi->bi_buffer != NULL)\n    {\n\tchar_u  buf[4];\n\tint\tn;\n\n\tundo_read(bi, buf, (size_t)4);\n\tn = ((unsigned)buf[0] << 24) + (buf[1] << 16) + (buf[2] << 8) + buf[3];\n\treturn n;\n    }\n#endif\n    return get4c(bi->bi_fp);\n}"", ""start_line"": 991, ""end_line"": 1006, ""full_name"": ""undo_read_4c"", ""file_path"": ""src/undo.c""}]}]","1. 'uep->ue_size' is assigned via 'undo_read_4c(bi)' in 'src/undo.c:1403'.\n2. 'undo_read_4c' (src/undo.c:991-1006) reads 4 bytes from the undo file buffer and returns them as an integer. This value is untrusted and can be manipulated by a corrupted undo file.\n3. In 'unserialize_uep', the unchecked 'uep->ue_size' is used in 'sizeof(char_u *) * uep->ue_size' (src/undo.c:1404-1405) for memory allocation. Without the patch's guard, this multiplication risks integer overflow if 'uep->ue_size' is excessively large.\n4. The patch adds a check to ensure 'uep->ue_size < LONG_MAX / (int)sizeof(char_u *)' before allocation, preventing overflow.",0.95,./github/other_context/CVE-2017-6350
50,CVE-2018-14938,"CWE-190, CWE-125",c_cpp,"An issue was discovered in wifipcap/wifipcap.cpp in TCPFLOW through 1.5.0-alpha. There is an integer overflow in the function handle_prism during caplen processing. If the caplen is less than 144, one can cause an integer overflow in the function handle_80211, which will result in an out-of-bounds read and may allow access to sensitive memory (or a denial of service).",https://github.com/simsong/tcpflow/commit/a4e1cd14eb5ccc51ed271b65b3420f7d692c40eb,fixed buffer overflow,2,"[{""func_name"": ""WifiPacket::handle_prism"", ""file_path"": ""src/wifipcap/wifipcap.cpp"", ""func_code"": ""void WifiPacket::handle_prism(const u_char *pc, size_t len)\n{\n    prism2_pkthdr hdr;\n\n    /* get the fields */\n    hdr.host_time \t= EXTRACT_LE_32BITS(pc+32);\n    hdr.mac_time \t= EXTRACT_LE_32BITS(pc+44);\n    hdr.channel \t= EXTRACT_LE_32BITS(pc+56);\n    hdr.rssi \t\t= EXTRACT_LE_32BITS(pc+68);\n    hdr.sq \t\t= EXTRACT_LE_32BITS(pc+80);\n    hdr.signal  \t= EXTRACT_LE_32BITS(pc+92);\n    hdr.noise   \t= EXTRACT_LE_32BITS(pc+104);\n    hdr.rate\t\t= EXTRACT_LE_32BITS(pc+116)/2;\n    hdr.istx\t\t= EXTRACT_LE_32BITS(pc+128);\n    cbs->HandlePrism( *this, &hdr, pc + 144, len - 144);\n    handle_80211(pc+144,len-144);\n}"", ""target"": 0}, {""func_name"": ""Wifipcap::handle_packet"", ""file_path"": ""src/wifipcap/wifipcap.cpp"", ""func_code"": ""void Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,\n                             const struct pcap_pkthdr *header, const u_char * packet) \n{\n    /* Record start time if we don't have it */\n    if (startTime == TIME_NONE) {\n\tstartTime = header->ts;\n\tlastPrintTime = header->ts;\n    }\n    /* Print stats if necessary */\n    if (header->ts.tv_sec > lastPrintTime.tv_sec + Wifipcap::PRINT_TIME_INTERVAL) {\n\tif (verbose) {\n\t    int hours = (header->ts.tv_sec - startTime.tv_sec)/3600;\n\t    int days  = hours/24;\n\t    int left  = hours%24;\n\t    fprintf(stderr, \""wifipcap: %2d days %2d hours, %10\"" PRId64 \"" pkts\\n\"", \n\t\t    days, left, packetsProcessed);\n\t}\n\tlastPrintTime = header->ts;\n    }\n    packetsProcessed++;\n\n    /* Create the packet object and call the appropriate callbacks */\n    WifiPacket pkt(cbs,header_type,header,packet);\n\n    /* Notify callback */\n    cbs->PacketBegin(pkt, packet, header->caplen, header->len);\n    //int frameLen = header->caplen;\n    switch(header_type) {\n    case DLT_PRISM_HEADER:\n        pkt.handle_prism(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11_RADIO:\n        pkt.handle_radiotap(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11:\n        pkt.handle_80211(packet,header->caplen);\n        break;\n    case DLT_EN10MB:\n        pkt.handle_ether(packet,header->caplen);\n        break;\n    default:\n#if 0\n\t// try handling it as default IP assuming framing is ethernet \n\t// (this is for testing)\n        pkt.handle_ip(packet,header->caplen);\n#endif\n        break;\n    }\n    cbs->PacketEnd(pkt);\n}"", ""target"": 1}]","[{""func_name"": ""WifiPacket::handle_prism"", ""file_path"": ""src/wifipcap/wifipcap.cpp"", ""func_code"": ""void WifiPacket::handle_prism(const u_char *pc, size_t len)\n{\n    prism2_pkthdr hdr;\n\n    /* get the fields */\n    if (len>=144){\n        hdr.host_time \t= EXTRACT_LE_32BITS(pc+32);\n        hdr.mac_time \t= EXTRACT_LE_32BITS(pc+44);\n        hdr.channel \t= EXTRACT_LE_32BITS(pc+56);\n        hdr.rssi \t\t= EXTRACT_LE_32BITS(pc+68);\n        hdr.sq \t\t= EXTRACT_LE_32BITS(pc+80);\n        hdr.signal  \t= EXTRACT_LE_32BITS(pc+92);\n        hdr.noise   \t= EXTRACT_LE_32BITS(pc+104);\n        hdr.rate\t\t= EXTRACT_LE_32BITS(pc+116)/2;\n        hdr.istx\t\t= EXTRACT_LE_32BITS(pc+128);\n        cbs->HandlePrism( *this, &hdr, pc + 144, len - 144);\n        handle_80211(pc+144,len-144);\n    }\n}""}, {""func_name"": ""Wifipcap::handle_packet"", ""file_path"": ""src/wifipcap/wifipcap.cpp"", ""func_code"": ""void Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,\n                             const struct pcap_pkthdr *header, const u_char * packet) \n{\n    /* Record start time if we don't have it */\n    if (startTime == TIME_NONE) {\n\tstartTime = header->ts;\n\tlastPrintTime = header->ts;\n    }\n    /* Print stats if necessary */\n    if (header->ts.tv_sec > lastPrintTime.tv_sec + Wifipcap::PRINT_TIME_INTERVAL) {\n\tif (verbose) {\n\t    int hours = (header->ts.tv_sec - startTime.tv_sec)/3600;\n\t    int days  = hours/24;\n\t    int left  = hours%24;\n\t    fprintf(stderr, \""wifipcap: %2d days %2d hours, %10\"" PRId64 \"" pkts\\n\"", \n\t\t    days, left, packetsProcessed);\n\t}\n\tlastPrintTime = header->ts;\n    }\n    packetsProcessed++;\n\n    /* Create the packet object and call the appropriate callbacks */\n    WifiPacket pkt(cbs,header_type,header,packet);\n\n    /* Notify callback */\n    cbs->PacketBegin(pkt, packet, header->caplen, header->len);\n    //int frameLen = header->caplen;\n    switch(header_type) {\n    case DLT_PRISM_HEADER:\n        pkt.handle_prism(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11_RADIO:\n        pkt.handle_radiotap(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11:\n        pkt.handle_80211(packet,header->caplen);\n        break;\n    case DLT_EN10MB:\n        pkt.handle_ether(packet,header->caplen);\n        break;\n    default:\n#if 0\n        /// 2018-08-02: slg - I'm also not sure why this is commented out.\n\t// try handling it as default IP assuming framing is ethernet \n\t// (this is for testing)\n        pkt.handle_ip(packet,header->caplen);\n#endif\n        break;\n    }\n    cbs->PacketEnd(pkt);\n}""}]","{""value"": 1, ""function"": 1}","[{""source"": ""value_info(file:wifipcap.cpp, value:len)"", ""result"": {""value_trace"": [{""full_code"": ""len = EXTRACT_LE_16BITS(&hdr->it_len)"", ""line"": 1422, ""func_name"": ""WifiPacket.handle_radiotap:void(u_char*,size_t)""}], ""struct_var"": ""len"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}, {""source"": ""func_info(file:wifipcap.cpp, func:handle_80211)"", ""result"": [{""code"": ""void WifiPacket::handle_80211(const u_char * pkt, size_t len /* , int pad */)  \n{\n    if (debug) std::cerr << \""handle_80211(len= \"" << len << \"" \"";\n    if (len < 2) {\n\tcbs->Handle80211( *this, 0, MAC::null, MAC::null, MAC::null, MAC::null, pkt, len);\n\tcbs->Handle80211Unknown( *this, -1, pkt, len);\n\treturn;\n    }\n\n    u_int16_t fc  = EXTRACT_LE_16BITS(pkt);       //frame control\n    size_t hdrlen = extract_header_length(fc);\n    /*\n      if (pad) {\n      hdrlen = roundup2(hdrlen, 4);\n      }\n    */\n\n    if (debug) std::cerr << \""FC_TYPE(fc)= \"" << FC_TYPE(fc) << \"" \"";\n\n    if (len < IEEE802_11_FC_LEN || len < hdrlen) {\n\tcbs->Handle80211Unknown( *this, fc, pkt, len);\n\treturn;\n    }\n\n    /* Always calculate the frame checksum, but only process the packets if the FCS or if we are ignoring it */\n    if (len >= hdrlen + 4) {\n        // assume fcs is last 4 bytes (?)\n        u_int32_t fcs_sent = EXTRACT_32BITS(pkt+len-4);\n        u_int32_t fcs = crc32_802(pkt, len-4);\n        \n        /*\n          if (fcs != fcs_sent) {\n          cerr << \""bad fcs: \"";\n          fprintf (stderr, \""%08x != %08x\\n\"", fcs_sent, fcs); \n          }\n        */\n\t\n        fcs_ok = (fcs == fcs_sent);\n    }\n    if (cbs->Check80211FCS(*this) && fcs_ok==false){\n        cbs->Handle80211Unknown(*this,fc,pkt,len);\n        return;\n    }\n\n\n    // fill in current_frame: type, sn\n    switch (FC_TYPE(fc)) {\n    case T_MGMT:\n\tif(decode_mgmt_frame(pkt, len, fc, hdrlen)<0)\n\t    return;\n\tbreak;\n    case T_DATA:\n\tif(decode_data_frame(pkt, len, fc)<0)\n\t    return;\n\tbreak;\n    case T_CTRL:\n\tif(decode_ctrl_frame(pkt, len, fc)<0)\n\t    return;\n\tbreak;\n    default:\n\tcbs->Handle80211( *this, fc, MAC::null, MAC::null, MAC::null, MAC::null, pkt, len);\n\tcbs->Handle80211Unknown( *this, fc, pkt, len);\n\treturn;\n    }\n}\n"", ""start_line"": 1145, ""end_line"": 1209, ""full_name"": ""WifiPacket.handle_80211:void(u_char*,size_t)"", ""file_path"": ""src/wifipcap/wifipcap.cpp""}]}]","src/wifipcap/wifipcap.cpp:1493-1505: Code uses 'len-144' without verifying 'len >= 144', causing integer underflow when 'len' (derived from radiotap header's 'it_len' at line 1422) is less than 144. This results in a large unsigned value passed to 'handle_80211', triggering out-of-bounds reads. The patch adds the 'if (len >= 144)' check to prevent underflow.",0.95,./github/other_context/CVE-2018-14938
51,CVE-2018-5815,CWE-190,c_cpp,"An integer overflow error within the ""parse_qt()"" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.12 can be exploited to trigger an infinite loop via a specially crafted Apple QuickTime file.",https://github.com/LibRaw/LibRaw/commit/1334647862b0c90b2e8cb2f668e66627d9517b17,parse_qt: possible integer overflow,1,"[{""func_name"": ""parse_qt"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\""moov\"",4) ||\n\t!memcmp(tag,\""udta\"",4) ||\n\t!memcmp(tag,\""CNTH\"",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\""CNDA\"",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}"", ""target"": 0}]","[{""func_name"": ""parse_qt"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    if ((int)size < 0) return; // 2+GB is too much\n    if (save + size < save) return; // 32bit overflow\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\""moov\"",4) ||\n\t!memcmp(tag,\""udta\"",4) ||\n\t!memcmp(tag,\""CNTH\"",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\""CNDA\"",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}""}]","{""function"": 1, ""value"": 2, ""code"": 1}","[{""source"": ""func_info(file:dcraw.c, func:get4)"", ""result"": [{""code"": ""unsigned CLASS get4()\n{\n  uchar str[4] = { 0xff,0xff,0xff,0xff };\n  fread (str, 1, 4, ifp);\n  return sget4(str);\n}"", ""start_line"": 452, ""end_line"": 457, ""full_name"": ""get4"", ""file_path"": ""dcraw/dcraw.c""}]}, {""source"": ""value_info(file:dcraw.c, value:size)"", ""result"": {""value_trace"": [{""full_code"": ""size = dsize"", ""line"": 4473, ""func_name"": ""foveon_camf_matrix""}], ""struct_var"": ""size"", ""struct_type"": ""unsigned"", ""struct_definition"": ""unsigned""}}, {""source"": ""value_info(file:dcraw.c, value:save)"", ""result"": {""value_trace"": [{""full_code"": ""save = ftell(ifp)"", ""line"": 955, ""func_name"": ""canon_load_raw""}, {""full_code"": ""save = ftell(ifp)"", ""line"": 1391, ""func_name"": ""lossless_dng_load_raw""}, {""full_code"": ""save = ftell(ifp)"", ""line"": 1928, ""func_name"": ""phase_one_correct""}, {""full_code"": ""save=data_offset-4"", ""line"": 3263, ""func_name"": ""lossy_dng_load_raw<duplicate>0""}, {""full_code"": ""save+=4"", ""line"": 3295, ""func_name"": ""lossy_dng_load_raw<duplicate>0""}], ""struct_var"": ""save"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""code_info(file:dcraw.c, lines:13590-13600)"", ""result"": ""  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\""moov\"",4) ||\n\t!memcmp(tag,\""udta\"",4) ||\n\t!memcmp(tag,\""CNTH\"",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\""CNDA\"",4))\n""}]","The vulnerability stems from unchecked size values read via `get4()` (dcraw/dcraw.c:452-457), which returns an `unsigned` 32-bit value. The `size` variable (unsigned) is assigned this value (dcraw/dcraw.c:13594). The `save` variable is an `int` (signed 32-bit) (dcraw/dcraw.c:955, 1391, etc.). The original code computes `save + size` without overflow checks, leading to potential 32-bit integer overflow when `save` (int) is positive and `size` (unsigned) is large (e.g., 0xFFFFFFFF). This overflow causes `save + size` to wrap to a small unsigned value, making the loop condition `ftell(ifp)+7 < end` evaluate to true indefinitely. The patch adds overflow checks to reject oversized values.",0.95,./github/other_context/CVE-2018-5815
52,CVE-2018-7225,CWE-190,c_cpp,"An issue was discovered in LibVNCServer through 0.9.11. rfbProcessClientNormalMessage() in rfbserver.c does not sanitize msg.cct.length, leading to access to uninitialized and potentially sensitive data or possibly unspecified other impact (e.g., an integer overflow) via specially crafted VNC packets.",https://github.com/LibVNC/libvncserver/commit/28afb6c537dc82ba04d5f245b15ca7205c6dbb9c,Limit client cut text length to 1 MB\n\nThis patch constrains a client cut text length to 1 MB. Otherwise\na client could make server allocate 2 GB of memory and that seems to\nbe to much to classify it as a denial of service.\n\nThe limit also prevents from an integer overflow followed by copying\nan uninitilized memory when processing msg.cct.length value larger\nthan SIZE_MAX or INT_MAX - sz_rfbClientCutTextMsg.\n\nThis patch also corrects accepting length value of zero (malloc(0) is\ninterpreted on differnet systems differently).\n\nCVE-2018-7225\n<https://github.com/LibVNC/libvncserver/issues/218>,1,"[{""func_name"": ""rfbProcessClientNormalMessage"", ""file_path"": ""libvncserver/rfbserver.c"", ""func_code"": ""static void\nrfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n    int n=0;\n    rfbClientToServerMsg msg;\n    char *str;\n    int i;\n    uint32_t enc=0;\n    uint32_t lastPreferredEncoding = -1;\n    char encBuf[64];\n    char encBuf2[64];\n\n    if ((n = rfbReadExact(cl, (char *)&msg, 1)) <= 0) {\n        if (n != 0)\n            rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetPixelFormatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n        cl->format.depth = msg.spf.format.depth;\n        cl->format.bigEndian = (msg.spf.format.bigEndian ? TRUE : FALSE);\n        cl->format.trueColour = (msg.spf.format.trueColour ? TRUE : FALSE);\n        cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n        cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n        cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n        cl->format.redShift = msg.spf.format.redShift;\n        cl->format.greenShift = msg.spf.format.greenShift;\n        cl->format.blueShift = msg.spf.format.blueShift;\n\n\tcl->readyForSetColourMapEntries = TRUE;\n        cl->screen->setTranslateFunction(cl);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n\n        return;\n\n\n    case rfbFixColourMapEntries:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFixColourMapEntriesMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n        rfbLog(\""rfbProcessClientNormalMessage: %s\"",\n                \""FixColourMapEntries unsupported\\n\"");\n        rfbCloseClient(cl);\n        return;\n\n\n    /* NOTE: Some clients send us a set of encodings (ie: PointerPos) designed to enable/disable features...\n     * We may want to look into this...\n     * Example:\n     *     case rfbEncodingXCursor:\n     *         cl->enableCursorShapeUpdates = TRUE;\n     *\n     * Currently: cl->enableCursorShapeUpdates can *never* be turned off...\n     */\n    case rfbSetEncodings:\n    {\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetEncodingsMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4),sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4));\n\n        /*\n         * UltraVNC Client has the ability to adapt to changing network environments\n         * So, let's give it a change to tell us what it wants now!\n         */\n        if (cl->preferredEncoding!=-1)\n            lastPreferredEncoding = cl->preferredEncoding;\n\n        /* Reset all flags to defaults (allows us to switch between PointerPos and Server Drawn Cursors) */\n        cl->preferredEncoding=-1;\n        cl->useCopyRect              = FALSE;\n        cl->useNewFBSize             = FALSE;\n        cl->cursorWasChanged         = FALSE;\n        cl->useRichCursorEncoding    = FALSE;\n        cl->enableCursorPosUpdates   = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableLastRectEncoding   = FALSE;\n        cl->enableKeyboardLedState   = FALSE;\n        cl->enableSupportedMessages  = FALSE;\n        cl->enableSupportedEncodings = FALSE;\n        cl->enableServerIdentity     = FALSE;\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n        cl->tightQualityLevel        = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n        cl->tightCompressLevel       = TIGHT_DEFAULT_COMPRESSION;\n        cl->turboSubsampLevel        = TURBO_DEFAULT_SUBSAMP;\n        cl->turboQualityLevel        = -1;\n#endif\n#endif\n\n\n        for (i = 0; i < msg.se.nEncodings; i++) {\n            if ((n = rfbReadExact(cl, (char *)&enc, 4)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n                rfbCloseClient(cl);\n                return;\n            }\n            enc = Swap32IfLE(enc);\n\n            switch (enc) {\n\n            case rfbEncodingCopyRect:\n\t\tcl->useCopyRect = TRUE;\n                break;\n            case rfbEncodingRaw:\n            case rfbEncodingRRE:\n            case rfbEncodingCoRRE:\n            case rfbEncodingHextile:\n            case rfbEncodingUltra:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t    case rfbEncodingZlib:\n            case rfbEncodingZRLE:\n            case rfbEncodingZYWRLE:\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t    case rfbEncodingTight:\n#endif\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\t    case rfbEncodingTightPng:\n#endif\n            /* The first supported encoding is the 'preferred' encoding */\n                if (cl->preferredEncoding == -1)\n                    cl->preferredEncoding = enc;\n\n\n                break;\n\t    case rfbEncodingXCursor:\n\t\tif(!cl->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\""Enabling X-style cursor updates for client %s\\n\"",\n\t\t\t   cl->host);\n\t\t    /* if cursor was drawn, hide the cursor */\n\t\t    if(!cl->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(cl,NULL);\n\n\t\t    cl->enableCursorShapeUpdates = TRUE;\n\t\t    cl->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingRichCursor:\n\t        rfbLog(\""Enabling full-color cursor updates for client %s\\n\"",\n\t\t       cl->host);\n\t\t/* if cursor was drawn, hide the cursor */\n\t\tif(!cl->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(cl,NULL);\n\n\t        cl->enableCursorShapeUpdates = TRUE;\n\t        cl->useRichCursorEncoding = TRUE;\n\t        cl->cursorWasChanged = TRUE;\n\t        break;\n\t    case rfbEncodingPointerPos:\n\t\tif (!cl->enableCursorPosUpdates) {\n\t\t    rfbLog(\""Enabling cursor position updates for client %s\\n\"",\n\t\t\t   cl->host);\n\t\t    cl->enableCursorPosUpdates = TRUE;\n\t\t    cl->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case rfbEncodingLastRect:\n\t\tif (!cl->enableLastRectEncoding) {\n\t\t    rfbLog(\""Enabling LastRect protocol extension for client \""\n\t\t\t   \""%s\\n\"", cl->host);\n\t\t    cl->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingNewFBSize:\n\t\tif (!cl->useNewFBSize) {\n\t\t    rfbLog(\""Enabling NewFBSize protocol extension for client \""\n\t\t\t   \""%s\\n\"", cl->host);\n\t\t    cl->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case rfbEncodingKeyboardLedState:\n                if (!cl->enableKeyboardLedState) {\n                  rfbLog(\""Enabling KeyboardLedState protocol extension for client \""\n                          \""%s\\n\"", cl->host);\n                  cl->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedMessages:\n                if (!cl->enableSupportedMessages) {\n                  rfbLog(\""Enabling SupportedMessages protocol extension for client \""\n                          \""%s\\n\"", cl->host);\n                  cl->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedEncodings:\n                if (!cl->enableSupportedEncodings) {\n                  rfbLog(\""Enabling SupportedEncodings protocol extension for client \""\n                          \""%s\\n\"", cl->host);\n                  cl->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case rfbEncodingServerIdentity:\n                if (!cl->enableServerIdentity) {\n                  rfbLog(\""Enabling ServerIdentity protocol extension for client \""\n                          \""%s\\n\"", cl->host);\n                  cl->enableServerIdentity = TRUE;\n                }\n                break;\n            case rfbEncodingXvp:\n                if (cl->screen->xvpHook) {\n                  rfbLog(\""Enabling Xvp protocol extension for client \""\n                          \""%s\\n\"", cl->host);\n                  if (!rfbSendXvp(cl, 1, rfbXvp_Init)) {\n                    rfbCloseClient(cl);\n                    return;\n                  }\n                }\n                break;\n            default:\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n\t\tif ( enc >= (uint32_t)rfbEncodingCompressLevel0 &&\n\t\t     enc <= (uint32_t)rfbEncodingCompressLevel9 ) {\n\t\t    cl->zlibCompressLevel = enc & 0x0F;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->tightCompressLevel = enc & 0x0F;\n\t\t    rfbLog(\""Using compression level %d for client %s\\n\"",\n\t\t\t   cl->tightCompressLevel, cl->host);\n#endif\n\t\t} else if ( enc >= (uint32_t)rfbEncodingQualityLevel0 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingQualityLevel9 ) {\n\t\t    cl->tightQualityLevel = enc & 0x0F;\n\t\t    rfbLog(\""Using image quality level %d for client %s\\n\"",\n\t\t\t   cl->tightQualityLevel, cl->host);\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->turboQualityLevel = tight2turbo_qual[enc & 0x0F];\n\t\t    cl->turboSubsampLevel = tight2turbo_subsamp[enc & 0x0F];\n\t\t    rfbLog(\""Using JPEG subsampling %d, Q%d for client %s\\n\"",\n\t\t\t   cl->turboSubsampLevel, cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingFineQualityLevel0 + 1 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingFineQualityLevel100 ) {\n\t\t    cl->turboQualityLevel = enc & 0xFF;\n\t\t    rfbLog(\""Using fine quality level %d for client %s\\n\"",\n\t\t\t   cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingSubsamp1X &&\n\t\t\t    enc <= (uint32_t)rfbEncodingSubsampGray ) {\n\t\t    cl->turboSubsampLevel = enc & 0xFF;\n\t\t    rfbLog(\""Using subsampling level %d for client %s\\n\"",\n\t\t\t   cl->turboSubsampLevel, cl->host);\n#endif\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* e;\n\t\t\tfor(e = cl->extensions; e;) {\n\t\t\t\trfbExtensionData* next = e->next;\n\t\t\t\tif(e->extension->enablePseudoEncoding &&\n\t\t\t\t\te->extension->enablePseudoEncoding(cl,\n\t\t\t\t\t\t&e->data, (int)enc))\n\t\t\t\t\t/* ext handles this encoding */\n\t\t\t\t\tbreak;\n\t\t\t\te = next;\n\t\t\t}\n\t\t\tif(e == NULL) {\n\t\t\t\trfbBool handled = FALSE;\n\t\t\t\t/* if the pseudo encoding is not handled by the\n\t\t\t\t   enabled extensions, search through all\n\t\t\t\t   extensions. */\n\t\t\t\trfbProtocolExtension* e;\n\n\t\t\t\tfor(e = rfbGetExtensionIterator(); e;) {\n\t\t\t\t\tint* encs = e->pseudoEncodings;\n\t\t\t\t\twhile(encs && *encs!=0) {\n\t\t\t\t\t\tif(*encs==(int)enc) {\n\t\t\t\t\t\t\tvoid* data = NULL;\n\t\t\t\t\t\t\tif(!e->enablePseudoEncoding(cl, &data, (int)enc)) {\n\t\t\t\t\t\t\t\trfbLog(\""Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\"",(int)enc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(cl, e, data);\n\t\t\t\t\t\t\t\thandled = TRUE;\n\t\t\t\t\t\t\t\te = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencs++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(e)\n\t\t\t\t\t\te = e->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!handled)\n\t\t\t\t\trfbLog(\""rfbProcessClientNormalMessage: \""\n\t\t\t\t\t    \""ignoring unsupported encoding type %s\\n\"",\n\t\t\t\t\t    encodingName(enc,encBuf,sizeof(encBuf)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (cl->preferredEncoding == -1) {\n            if (lastPreferredEncoding==-1) {\n                cl->preferredEncoding = rfbEncodingRaw;\n                rfbLog(\""Defaulting to %s encoding for client %s\\n\"", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n            else {\n                cl->preferredEncoding = lastPreferredEncoding;\n                rfbLog(\""Sticking with %s encoding for client %s\\n\"", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n        }\n        else\n        {\n          if (lastPreferredEncoding==-1) {\n              rfbLog(\""Using %s encoding for client %s\\n\"", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n          } else {\n              rfbLog(\""Switching from %s to %s Encoding for client %s\\n\"", \n                  encodingName(lastPreferredEncoding,encBuf2,sizeof(encBuf2)),\n                  encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)), cl->host);\n          }\n        }\n        \n\tif (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n\t  rfbLog(\""Disabling cursor position updates for client %s\\n\"",\n\t\t cl->host);\n\t  cl->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case rfbFramebufferUpdateRequest:\n    {\n        sraRegionPtr tmpRegion;\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFramebufferUpdateRequestMsg-1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbFramebufferUpdateRequestMsg,sz_rfbFramebufferUpdateRequestMsg);\n\n        /* The values come in based on the scaled screen, we need to convert them to\n         * values based on the main screen's coordinate system\n         */\n\tif(!rectSwapIfLEAndClip(&msg.fur.x,&msg.fur.y,&msg.fur.w,&msg.fur.h,cl))\n\t{\n\t        rfbLog(\""Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\"",msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);\n\t\treturn;\n        }\n \n        \n\ttmpRegion =\n\t  sraRgnCreateRect(msg.fur.x,\n\t\t\t   msg.fur.y,\n\t\t\t   msg.fur.x+msg.fur.w,\n\t\t\t   msg.fur.y+msg.fur.h);\n\n        LOCK(cl->updateMutex);\n\tsraRgnOr(cl->requestedRegion,tmpRegion);\n\n\tif (!cl->readyForSetColourMapEntries) {\n\t    /* client hasn't sent a SetPixelFormat so is using server's */\n\t    cl->readyForSetColourMapEntries = TRUE;\n\t    if (!cl->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(cl, 0, 0)) {\n\t\t    sraRgnDestroy(tmpRegion);\n\t\t    TSIGNAL(cl->updateCond);\n\t\t    UNLOCK(cl->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!msg.fur.incremental) {\n\t    sraRgnOr(cl->modifiedRegion,tmpRegion);\n\t    sraRgnSubtract(cl->copyRegion,tmpRegion);\n       }\n       TSIGNAL(cl->updateCond);\n       UNLOCK(cl->updateMutex);\n\n       sraRgnDestroy(tmpRegion);\n\n       return;\n    }\n\n    case rfbKeyEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbKeyEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbKeyEventMsg, sz_rfbKeyEventMsg);\n\n\tif(!cl->viewOnly) {\n\t    cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\t}\n\n        return;\n\n\n    case rfbPointerEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbPointerEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbPointerEventMsg, sz_rfbPointerEventMsg);\n\t\n\tif (cl->screen->pointerClient && cl->screen->pointerClient != cl)\n\t    return;\n\n\tif (msg.pe.buttonMask == 0)\n\t    cl->screen->pointerClient = NULL;\n\telse\n\t    cl->screen->pointerClient = cl;\n\n\tif(!cl->viewOnly) {\n\t    if (msg.pe.buttonMask != cl->lastPtrButtons ||\n\t\t    cl->screen->deferPtrUpdateTime == 0) {\n\t\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t\tScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x)), \n\t\t\tScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y)),\n\t\t\tcl);\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    } else {\n\t\tcl->lastPtrX = ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x));\n\t\tcl->lastPtrY = ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y));\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case rfbFileTransfer:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbFileTransferMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.ft.size         = Swap32IfLE(msg.ft.size);\n        msg.ft.length       = Swap32IfLE(msg.ft.length);\n        /* record statistics in rfbProcessFileTransfer as length is filled with garbage when it is not valid */\n        rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);\n        return;\n\n    case rfbSetSW:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetSWMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.sw.x = Swap16IfLE(msg.sw.x);\n        msg.sw.y = Swap16IfLE(msg.sw.y);\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetSWMsg, sz_rfbSetSWMsg);\n        /* msg.sw.status is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n\n        rfbLog(\""Received a rfbSetSingleWindow(%d x, %d y)\\n\"", msg.sw.x, msg.sw.y);\n        if (cl->screen->setSingleWindow!=NULL)\n            cl->screen->setSingleWindow(cl, msg.sw.x, msg.sw.y);\n        return;\n\n    case rfbSetServerInput:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetServerInputMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetServerInputMsg, sz_rfbSetServerInputMsg);\n\n        /* msg.sim.pad is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n        /* msg.sim.pad = Swap16IfLE(msg.sim.pad); */\n\n        rfbLog(\""Received a rfbSetServerInput(%d status)\\n\"", msg.sim.status);\n        if (cl->screen->setServerInput!=NULL)\n            cl->screen->setServerInput(cl, msg.sim.status);\n        return;\n        \n    case rfbTextChat:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbTextChatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n        \n        msg.tc.pad2   = Swap16IfLE(msg.tc.pad2);\n        msg.tc.length = Swap32IfLE(msg.tc.length);\n\n        switch (msg.tc.length) {\n        case rfbTextChatOpen:\n        case rfbTextChatClose:\n        case rfbTextChatFinished:\n            /* commands do not have text following */\n            /* Why couldn't they have used the pad byte??? */\n            str=NULL;\n            rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg, sz_rfbTextChatMsg);\n            break;\n        default:\n            if ((msg.tc.length>0) && (msg.tc.length<rfbTextMaxSize))\n            {\n                str = (char *)malloc(msg.tc.length);\n                if (str==NULL)\n                {\n                    rfbLog(\""Unable to malloc %d bytes for a TextChat Message\\n\"", msg.tc.length);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                if ((n = rfbReadExact(cl, str, msg.tc.length)) <= 0) {\n                    if (n != 0)\n                        rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n                    free(str);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg+msg.tc.length, sz_rfbTextChatMsg+msg.tc.length);\n            }\n            else\n            {\n                /* This should never happen */\n                rfbLog(\""client sent us a Text Message that is too big %d>%d\\n\"", msg.tc.length, rfbTextMaxSize);\n                rfbCloseClient(cl);\n                return;\n            }\n        }\n\n        /* Note: length can be commands: rfbTextChatOpen, rfbTextChatClose, and rfbTextChatFinished\n         * at which point, the str is NULL (as it is not sent)\n         */\n        if (cl->screen->setTextChat!=NULL)\n            cl->screen->setTextChat(cl, msg.tc.length, str);\n\n        free(str);\n        return;\n\n\n    case rfbClientCutText:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbClientCutTextMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.cct.length = Swap32IfLE(msg.cct.length);\n\n\tstr = (char *)malloc(msg.cct.length);\n\tif (str == NULL) {\n\t\trfbLogPerror(\""rfbProcessClientNormalMessage: not enough memory\"");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\n\tif ((n = rfbReadExact(cl, str, msg.cct.length)) <= 0) {\n\t    if (n != 0)\n\t        rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n\t    free(str);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbClientCutTextMsg+msg.cct.length, sz_rfbClientCutTextMsg+msg.cct.length);\n\tif(!cl->viewOnly) {\n\t    cl->screen->setXCutText(str, msg.cct.length, cl);\n\t}\n\tfree(str);\n\n        return;\n\n    case rfbPalmVNCSetScaleFactor:\n      cl->PalmVNC = TRUE;\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\""rfbProcessClientNormalMessage: will not accept a scale factor of zero\"");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\""rfbSetScale(%d)\\n\"", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n      \n    case rfbSetScale:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\""rfbProcessClientNormalMessage: will not accept a scale factor of zero\"");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\""rfbSetScale(%d)\\n\"", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n\n    case rfbXvp:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbXvpMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbXvpMsg, sz_rfbXvpMsg);\n\n      /* only version when is defined, so echo back a fail */\n      if(msg.xvp.version != 1) {\n\trfbSendXvp(cl, msg.xvp.version, rfbXvp_Fail);\n      }\n      else {\n\t/* if the hook exists and fails, send a fail msg */\n\tif(cl->screen->xvpHook && !cl->screen->xvpHook(cl, msg.xvp.version, msg.xvp.code))\n\t  rfbSendXvp(cl, 1, rfbXvp_Fail);\n      }\n      return;\n\n    default:\n\t{\n\t    rfbExtensionData *e,*next;\n\n\t    for(e=cl->extensions; e;) {\n\t\tnext = e->next;\n\t\tif(e->extension->handleMessage &&\n\t\t\te->extension->handleMessage(cl, e->data, &msg))\n                {\n                    rfbStatRecordMessageRcvd(cl, msg.type, 0, 0); /* Extension should handle this */\n\t\t    return;\n                }\n\t\te = next;\n\t    }\n\n\t    rfbLog(\""rfbProcessClientNormalMessage: unknown message type %d\\n\"",\n\t\t    msg.type);\n\t    rfbLog(\"" ... closing connection\\n\"");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n    }\n}"", ""target"": 0}]","[{""func_name"": ""rfbProcessClientNormalMessage"", ""file_path"": ""libvncserver/rfbserver.c"", ""func_code"": ""static void\nrfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n    int n=0;\n    rfbClientToServerMsg msg;\n    char *str;\n    int i;\n    uint32_t enc=0;\n    uint32_t lastPreferredEncoding = -1;\n    char encBuf[64];\n    char encBuf2[64];\n\n    if ((n = rfbReadExact(cl, (char *)&msg, 1)) <= 0) {\n        if (n != 0)\n            rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetPixelFormatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n        cl->format.depth = msg.spf.format.depth;\n        cl->format.bigEndian = (msg.spf.format.bigEndian ? TRUE : FALSE);\n        cl->format.trueColour = (msg.spf.format.trueColour ? TRUE : FALSE);\n        cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n        cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n        cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n        cl->format.redShift = msg.spf.format.redShift;\n        cl->format.greenShift = msg.spf.format.greenShift;\n        cl->format.blueShift = msg.spf.format.blueShift;\n\n\tcl->readyForSetColourMapEntries = TRUE;\n        cl->screen->setTranslateFunction(cl);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n\n        return;\n\n\n    case rfbFixColourMapEntries:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFixColourMapEntriesMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n        rfbLog(\""rfbProcessClientNormalMessage: %s\"",\n                \""FixColourMapEntries unsupported\\n\"");\n        rfbCloseClient(cl);\n        return;\n\n\n    /* NOTE: Some clients send us a set of encodings (ie: PointerPos) designed to enable/disable features...\n     * We may want to look into this...\n     * Example:\n     *     case rfbEncodingXCursor:\n     *         cl->enableCursorShapeUpdates = TRUE;\n     *\n     * Currently: cl->enableCursorShapeUpdates can *never* be turned off...\n     */\n    case rfbSetEncodings:\n    {\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetEncodingsMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4),sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4));\n\n        /*\n         * UltraVNC Client has the ability to adapt to changing network environments\n         * So, let's give it a change to tell us what it wants now!\n         */\n        if (cl->preferredEncoding!=-1)\n            lastPreferredEncoding = cl->preferredEncoding;\n\n        /* Reset all flags to defaults (allows us to switch between PointerPos and Server Drawn Cursors) */\n        cl->preferredEncoding=-1;\n        cl->useCopyRect              = FALSE;\n        cl->useNewFBSize             = FALSE;\n        cl->cursorWasChanged         = FALSE;\n        cl->useRichCursorEncoding    = FALSE;\n        cl->enableCursorPosUpdates   = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableLastRectEncoding   = FALSE;\n        cl->enableKeyboardLedState   = FALSE;\n        cl->enableSupportedMessages  = FALSE;\n        cl->enableSupportedEncodings = FALSE;\n        cl->enableServerIdentity     = FALSE;\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n        cl->tightQualityLevel        = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n        cl->tightCompressLevel       = TIGHT_DEFAULT_COMPRESSION;\n        cl->turboSubsampLevel        = TURBO_DEFAULT_SUBSAMP;\n        cl->turboQualityLevel        = -1;\n#endif\n#endif\n\n\n        for (i = 0; i < msg.se.nEncodings; i++) {\n            if ((n = rfbReadExact(cl, (char *)&enc, 4)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n                rfbCloseClient(cl);\n                return;\n            }\n            enc = Swap32IfLE(enc);\n\n            switch (enc) {\n\n            case rfbEncodingCopyRect:\n\t\tcl->useCopyRect = TRUE;\n                break;\n            case rfbEncodingRaw:\n            case rfbEncodingRRE:\n            case rfbEncodingCoRRE:\n            case rfbEncodingHextile:\n            case rfbEncodingUltra:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t    case rfbEncodingZlib:\n            case rfbEncodingZRLE:\n            case rfbEncodingZYWRLE:\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t    case rfbEncodingTight:\n#endif\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\t    case rfbEncodingTightPng:\n#endif\n            /* The first supported encoding is the 'preferred' encoding */\n                if (cl->preferredEncoding == -1)\n                    cl->preferredEncoding = enc;\n\n\n                break;\n\t    case rfbEncodingXCursor:\n\t\tif(!cl->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\""Enabling X-style cursor updates for client %s\\n\"",\n\t\t\t   cl->host);\n\t\t    /* if cursor was drawn, hide the cursor */\n\t\t    if(!cl->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(cl,NULL);\n\n\t\t    cl->enableCursorShapeUpdates = TRUE;\n\t\t    cl->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingRichCursor:\n\t        rfbLog(\""Enabling full-color cursor updates for client %s\\n\"",\n\t\t       cl->host);\n\t\t/* if cursor was drawn, hide the cursor */\n\t\tif(!cl->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(cl,NULL);\n\n\t        cl->enableCursorShapeUpdates = TRUE;\n\t        cl->useRichCursorEncoding = TRUE;\n\t        cl->cursorWasChanged = TRUE;\n\t        break;\n\t    case rfbEncodingPointerPos:\n\t\tif (!cl->enableCursorPosUpdates) {\n\t\t    rfbLog(\""Enabling cursor position updates for client %s\\n\"",\n\t\t\t   cl->host);\n\t\t    cl->enableCursorPosUpdates = TRUE;\n\t\t    cl->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case rfbEncodingLastRect:\n\t\tif (!cl->enableLastRectEncoding) {\n\t\t    rfbLog(\""Enabling LastRect protocol extension for client \""\n\t\t\t   \""%s\\n\"", cl->host);\n\t\t    cl->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingNewFBSize:\n\t\tif (!cl->useNewFBSize) {\n\t\t    rfbLog(\""Enabling NewFBSize protocol extension for client \""\n\t\t\t   \""%s\\n\"", cl->host);\n\t\t    cl->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case rfbEncodingKeyboardLedState:\n                if (!cl->enableKeyboardLedState) {\n                  rfbLog(\""Enabling KeyboardLedState protocol extension for client \""\n                          \""%s\\n\"", cl->host);\n                  cl->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedMessages:\n                if (!cl->enableSupportedMessages) {\n                  rfbLog(\""Enabling SupportedMessages protocol extension for client \""\n                          \""%s\\n\"", cl->host);\n                  cl->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedEncodings:\n                if (!cl->enableSupportedEncodings) {\n                  rfbLog(\""Enabling SupportedEncodings protocol extension for client \""\n                          \""%s\\n\"", cl->host);\n                  cl->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case rfbEncodingServerIdentity:\n                if (!cl->enableServerIdentity) {\n                  rfbLog(\""Enabling ServerIdentity protocol extension for client \""\n                          \""%s\\n\"", cl->host);\n                  cl->enableServerIdentity = TRUE;\n                }\n                break;\n            case rfbEncodingXvp:\n                if (cl->screen->xvpHook) {\n                  rfbLog(\""Enabling Xvp protocol extension for client \""\n                          \""%s\\n\"", cl->host);\n                  if (!rfbSendXvp(cl, 1, rfbXvp_Init)) {\n                    rfbCloseClient(cl);\n                    return;\n                  }\n                }\n                break;\n            default:\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n\t\tif ( enc >= (uint32_t)rfbEncodingCompressLevel0 &&\n\t\t     enc <= (uint32_t)rfbEncodingCompressLevel9 ) {\n\t\t    cl->zlibCompressLevel = enc & 0x0F;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->tightCompressLevel = enc & 0x0F;\n\t\t    rfbLog(\""Using compression level %d for client %s\\n\"",\n\t\t\t   cl->tightCompressLevel, cl->host);\n#endif\n\t\t} else if ( enc >= (uint32_t)rfbEncodingQualityLevel0 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingQualityLevel9 ) {\n\t\t    cl->tightQualityLevel = enc & 0x0F;\n\t\t    rfbLog(\""Using image quality level %d for client %s\\n\"",\n\t\t\t   cl->tightQualityLevel, cl->host);\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->turboQualityLevel = tight2turbo_qual[enc & 0x0F];\n\t\t    cl->turboSubsampLevel = tight2turbo_subsamp[enc & 0x0F];\n\t\t    rfbLog(\""Using JPEG subsampling %d, Q%d for client %s\\n\"",\n\t\t\t   cl->turboSubsampLevel, cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingFineQualityLevel0 + 1 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingFineQualityLevel100 ) {\n\t\t    cl->turboQualityLevel = enc & 0xFF;\n\t\t    rfbLog(\""Using fine quality level %d for client %s\\n\"",\n\t\t\t   cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingSubsamp1X &&\n\t\t\t    enc <= (uint32_t)rfbEncodingSubsampGray ) {\n\t\t    cl->turboSubsampLevel = enc & 0xFF;\n\t\t    rfbLog(\""Using subsampling level %d for client %s\\n\"",\n\t\t\t   cl->turboSubsampLevel, cl->host);\n#endif\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* e;\n\t\t\tfor(e = cl->extensions; e;) {\n\t\t\t\trfbExtensionData* next = e->next;\n\t\t\t\tif(e->extension->enablePseudoEncoding &&\n\t\t\t\t\te->extension->enablePseudoEncoding(cl,\n\t\t\t\t\t\t&e->data, (int)enc))\n\t\t\t\t\t/* ext handles this encoding */\n\t\t\t\t\tbreak;\n\t\t\t\te = next;\n\t\t\t}\n\t\t\tif(e == NULL) {\n\t\t\t\trfbBool handled = FALSE;\n\t\t\t\t/* if the pseudo encoding is not handled by the\n\t\t\t\t   enabled extensions, search through all\n\t\t\t\t   extensions. */\n\t\t\t\trfbProtocolExtension* e;\n\n\t\t\t\tfor(e = rfbGetExtensionIterator(); e;) {\n\t\t\t\t\tint* encs = e->pseudoEncodings;\n\t\t\t\t\twhile(encs && *encs!=0) {\n\t\t\t\t\t\tif(*encs==(int)enc) {\n\t\t\t\t\t\t\tvoid* data = NULL;\n\t\t\t\t\t\t\tif(!e->enablePseudoEncoding(cl, &data, (int)enc)) {\n\t\t\t\t\t\t\t\trfbLog(\""Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\"",(int)enc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(cl, e, data);\n\t\t\t\t\t\t\t\thandled = TRUE;\n\t\t\t\t\t\t\t\te = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencs++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(e)\n\t\t\t\t\t\te = e->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!handled)\n\t\t\t\t\trfbLog(\""rfbProcessClientNormalMessage: \""\n\t\t\t\t\t    \""ignoring unsupported encoding type %s\\n\"",\n\t\t\t\t\t    encodingName(enc,encBuf,sizeof(encBuf)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (cl->preferredEncoding == -1) {\n            if (lastPreferredEncoding==-1) {\n                cl->preferredEncoding = rfbEncodingRaw;\n                rfbLog(\""Defaulting to %s encoding for client %s\\n\"", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n            else {\n                cl->preferredEncoding = lastPreferredEncoding;\n                rfbLog(\""Sticking with %s encoding for client %s\\n\"", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n        }\n        else\n        {\n          if (lastPreferredEncoding==-1) {\n              rfbLog(\""Using %s encoding for client %s\\n\"", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n          } else {\n              rfbLog(\""Switching from %s to %s Encoding for client %s\\n\"", \n                  encodingName(lastPreferredEncoding,encBuf2,sizeof(encBuf2)),\n                  encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)), cl->host);\n          }\n        }\n        \n\tif (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n\t  rfbLog(\""Disabling cursor position updates for client %s\\n\"",\n\t\t cl->host);\n\t  cl->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case rfbFramebufferUpdateRequest:\n    {\n        sraRegionPtr tmpRegion;\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFramebufferUpdateRequestMsg-1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbFramebufferUpdateRequestMsg,sz_rfbFramebufferUpdateRequestMsg);\n\n        /* The values come in based on the scaled screen, we need to convert them to\n         * values based on the main screen's coordinate system\n         */\n\tif(!rectSwapIfLEAndClip(&msg.fur.x,&msg.fur.y,&msg.fur.w,&msg.fur.h,cl))\n\t{\n\t        rfbLog(\""Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\"",msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);\n\t\treturn;\n        }\n \n        \n\ttmpRegion =\n\t  sraRgnCreateRect(msg.fur.x,\n\t\t\t   msg.fur.y,\n\t\t\t   msg.fur.x+msg.fur.w,\n\t\t\t   msg.fur.y+msg.fur.h);\n\n        LOCK(cl->updateMutex);\n\tsraRgnOr(cl->requestedRegion,tmpRegion);\n\n\tif (!cl->readyForSetColourMapEntries) {\n\t    /* client hasn't sent a SetPixelFormat so is using server's */\n\t    cl->readyForSetColourMapEntries = TRUE;\n\t    if (!cl->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(cl, 0, 0)) {\n\t\t    sraRgnDestroy(tmpRegion);\n\t\t    TSIGNAL(cl->updateCond);\n\t\t    UNLOCK(cl->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!msg.fur.incremental) {\n\t    sraRgnOr(cl->modifiedRegion,tmpRegion);\n\t    sraRgnSubtract(cl->copyRegion,tmpRegion);\n       }\n       TSIGNAL(cl->updateCond);\n       UNLOCK(cl->updateMutex);\n\n       sraRgnDestroy(tmpRegion);\n\n       return;\n    }\n\n    case rfbKeyEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbKeyEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbKeyEventMsg, sz_rfbKeyEventMsg);\n\n\tif(!cl->viewOnly) {\n\t    cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\t}\n\n        return;\n\n\n    case rfbPointerEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbPointerEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbPointerEventMsg, sz_rfbPointerEventMsg);\n\t\n\tif (cl->screen->pointerClient && cl->screen->pointerClient != cl)\n\t    return;\n\n\tif (msg.pe.buttonMask == 0)\n\t    cl->screen->pointerClient = NULL;\n\telse\n\t    cl->screen->pointerClient = cl;\n\n\tif(!cl->viewOnly) {\n\t    if (msg.pe.buttonMask != cl->lastPtrButtons ||\n\t\t    cl->screen->deferPtrUpdateTime == 0) {\n\t\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t\tScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x)), \n\t\t\tScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y)),\n\t\t\tcl);\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    } else {\n\t\tcl->lastPtrX = ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x));\n\t\tcl->lastPtrY = ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y));\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case rfbFileTransfer:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbFileTransferMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.ft.size         = Swap32IfLE(msg.ft.size);\n        msg.ft.length       = Swap32IfLE(msg.ft.length);\n        /* record statistics in rfbProcessFileTransfer as length is filled with garbage when it is not valid */\n        rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);\n        return;\n\n    case rfbSetSW:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetSWMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.sw.x = Swap16IfLE(msg.sw.x);\n        msg.sw.y = Swap16IfLE(msg.sw.y);\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetSWMsg, sz_rfbSetSWMsg);\n        /* msg.sw.status is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n\n        rfbLog(\""Received a rfbSetSingleWindow(%d x, %d y)\\n\"", msg.sw.x, msg.sw.y);\n        if (cl->screen->setSingleWindow!=NULL)\n            cl->screen->setSingleWindow(cl, msg.sw.x, msg.sw.y);\n        return;\n\n    case rfbSetServerInput:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetServerInputMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetServerInputMsg, sz_rfbSetServerInputMsg);\n\n        /* msg.sim.pad is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n        /* msg.sim.pad = Swap16IfLE(msg.sim.pad); */\n\n        rfbLog(\""Received a rfbSetServerInput(%d status)\\n\"", msg.sim.status);\n        if (cl->screen->setServerInput!=NULL)\n            cl->screen->setServerInput(cl, msg.sim.status);\n        return;\n        \n    case rfbTextChat:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbTextChatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n            rfbCloseClient(cl);\n            return;\n        }\n        \n        msg.tc.pad2   = Swap16IfLE(msg.tc.pad2);\n        msg.tc.length = Swap32IfLE(msg.tc.length);\n\n        switch (msg.tc.length) {\n        case rfbTextChatOpen:\n        case rfbTextChatClose:\n        case rfbTextChatFinished:\n            /* commands do not have text following */\n            /* Why couldn't they have used the pad byte??? */\n            str=NULL;\n            rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg, sz_rfbTextChatMsg);\n            break;\n        default:\n            if ((msg.tc.length>0) && (msg.tc.length<rfbTextMaxSize))\n            {\n                str = (char *)malloc(msg.tc.length);\n                if (str==NULL)\n                {\n                    rfbLog(\""Unable to malloc %d bytes for a TextChat Message\\n\"", msg.tc.length);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                if ((n = rfbReadExact(cl, str, msg.tc.length)) <= 0) {\n                    if (n != 0)\n                        rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n                    free(str);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg+msg.tc.length, sz_rfbTextChatMsg+msg.tc.length);\n            }\n            else\n            {\n                /* This should never happen */\n                rfbLog(\""client sent us a Text Message that is too big %d>%d\\n\"", msg.tc.length, rfbTextMaxSize);\n                rfbCloseClient(cl);\n                return;\n            }\n        }\n\n        /* Note: length can be commands: rfbTextChatOpen, rfbTextChatClose, and rfbTextChatFinished\n         * at which point, the str is NULL (as it is not sent)\n         */\n        if (cl->screen->setTextChat!=NULL)\n            cl->screen->setTextChat(cl, msg.tc.length, str);\n\n        free(str);\n        return;\n\n\n    case rfbClientCutText:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbClientCutTextMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.cct.length = Swap32IfLE(msg.cct.length);\n\n\t/* uint32_t input is passed to malloc()'s size_t argument,\n\t * to rfbReadExact()'s int argument, to rfbStatRecordMessageRcvd()'s int\n\t * argument increased of sz_rfbClientCutTextMsg, and to setXCutText()'s int\n\t * argument. Here we impose a limit of 1 MB so that the value fits\n\t * into all of the types to prevent from misinterpretation and thus\n\t * from accessing uninitialized memory (CVE-2018-7225) and also to\n\t * prevent from a denial-of-service by allocating to much memory in\n\t * the server. */\n\tif (msg.cct.length > 1<<20) {\n\t    rfbLog(\""rfbClientCutText: too big cut text length requested: %\"" PRIu32 \""\\n\"",\n\t\t    msg.cct.length);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\t/* Allow zero-length client cut text. */\n\tstr = (char *)calloc(msg.cct.length ? msg.cct.length : 1, 1);\n\tif (str == NULL) {\n\t\trfbLogPerror(\""rfbProcessClientNormalMessage: not enough memory\"");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\n\tif ((n = rfbReadExact(cl, str, msg.cct.length)) <= 0) {\n\t    if (n != 0)\n\t        rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n\t    free(str);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbClientCutTextMsg+msg.cct.length, sz_rfbClientCutTextMsg+msg.cct.length);\n\tif(!cl->viewOnly) {\n\t    cl->screen->setXCutText(str, msg.cct.length, cl);\n\t}\n\tfree(str);\n\n        return;\n\n    case rfbPalmVNCSetScaleFactor:\n      cl->PalmVNC = TRUE;\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\""rfbProcessClientNormalMessage: will not accept a scale factor of zero\"");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\""rfbSetScale(%d)\\n\"", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n      \n    case rfbSetScale:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\""rfbProcessClientNormalMessage: will not accept a scale factor of zero\"");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\""rfbSetScale(%d)\\n\"", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n\n    case rfbXvp:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbXvpMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbXvpMsg, sz_rfbXvpMsg);\n\n      /* only version when is defined, so echo back a fail */\n      if(msg.xvp.version != 1) {\n\trfbSendXvp(cl, msg.xvp.version, rfbXvp_Fail);\n      }\n      else {\n\t/* if the hook exists and fails, send a fail msg */\n\tif(cl->screen->xvpHook && !cl->screen->xvpHook(cl, msg.xvp.version, msg.xvp.code))\n\t  rfbSendXvp(cl, 1, rfbXvp_Fail);\n      }\n      return;\n\n    default:\n\t{\n\t    rfbExtensionData *e,*next;\n\n\t    for(e=cl->extensions; e;) {\n\t\tnext = e->next;\n\t\tif(e->extension->handleMessage &&\n\t\t\te->extension->handleMessage(cl, e->data, &msg))\n                {\n                    rfbStatRecordMessageRcvd(cl, msg.type, 0, 0); /* Extension should handle this */\n\t\t    return;\n                }\n\t\te = next;\n\t    }\n\n\t    rfbLog(\""rfbProcessClientNormalMessage: unknown message type %d\\n\"",\n\t\t    msg.type);\n\t    rfbLog(\"" ... closing connection\\n\"");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n    }\n}""}]","{""function"": 1, ""value"": 1, ""code"": 2}","[{""source"": ""func_info(func:rfbReadExact)"", ""result"": [{""code"": ""int rfbReadExact(rfbClientPtr cl,char* buf,int len)\n{\n  /* favor the per-screen value if set */\n  if(cl->screen && cl->screen->maxClientWait)\n    return(rfbReadExactTimeout(cl,buf,len,cl->screen->maxClientWait));\n  else\n    return(rfbReadExactTimeout(cl,buf,len,rfbMaxClientWait));\n}"", ""start_line"": 675, ""end_line"": 682, ""full_name"": ""rfbReadExact"", ""file_path"": ""libvncserver/sockets.c""}]}, {""source"": ""value_info(file:rfbserver.c, value:msg.cct.length)"", ""result"": {""value_trace"": [{""full_code"": ""msg.cct.length = Swap32IfLE(msg.cct.length)"", ""line"": 2576, ""func_name"": ""rfbProcessClientNormalMessage""}], ""struct_var"": ""msg"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:rfbserver.c, lines:2570-2580)"", ""result"": ""\t    if (n != 0)\n\t\trfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.cct.length = Swap32IfLE(msg.cct.length);\n\n\tstr = (char *)malloc(msg.cct.length);\n\tif (str == NULL) {\n\t\trfbLogPerror(\""rfbProcessClientNormalMessage: not enough memory\"");\n""}, {""source"": ""code_info(file:rfbserver.c, lines:2560-2575)"", ""result"": ""            cl->screen->setTextChat(cl, msg.tc.length, str);\n\n        free(str);\n        return;\n\n\n    case rfbClientCutText:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbClientCutTextMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\""rfbProcessClientNormalMessage: read\"");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n""}]",libvncserver/rfbserver.c:2577 (unsanitized `msg.cct.length` passed to `malloc`). Data flow: Client input  `rfbReadExact` (libvncserver/rfbserver.c:2565)  `msg.cct.length` populated  `Swap32IfLE` (libvncserver/rfbserver.c:2576)  `malloc` (libvncserver/rfbserver.c:2577).,0.95,./github/other_context/CVE-2018-7225
53,CVE-2018-7329,"CWE-193, CWE-835",c_cpp,"In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be,"S7comm: fix range check to prevent infinite loop when upper bound is 255\n\nWhile we are at it, fix identification of not last element in a few\nplaces\n\nBug: 14423\nChange-Id: I568530949d09ddfd8c5c58d24050dfed32ce10f5\nReviewed-on: https://code.wireshark.org/review/25851\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51)\nConflicts:\n	epan/dissectors/packet-s7comm.c\nReviewed-on: https://code.wireshark.org/review/25867\n(cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)\nReviewed-on: https://code.wireshark.org/review/25868",5,"[{""func_name"": ""s7comm_decode_response_write_data"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_response_write_data(tvbuff_t *tvb,\n                                  proto_tree *tree,\n                                  guint8 item_count,\n                                  guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 1; i <= item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, 1, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \"" [%d]: (%s)\"", i, val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        offset += 1;\n    }\n    return offset;\n}"", ""target"": 1}, {""func_name"": ""s7comm_decode_req_resp"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_req_resp(tvbuff_t *tvb,\n                       packet_info *pinfo,\n                       proto_tree *tree,\n                       guint16 plength,\n                       guint16 dlength,\n                       guint32 offset,\n                       guint8 rosctr)\n{\n    proto_item *item = NULL;\n    proto_tree *param_tree = NULL;\n    proto_tree *data_tree = NULL;\n    guint8 function = 0;\n    guint8 item_count = 0;\n    guint8 i;\n    guint32 offset_old;\n    guint32 len;\n\n    if (plength > 0) {\n        /* Add parameter tree */\n        item = proto_tree_add_item(tree, hf_s7comm_param, tvb, offset, plength, ENC_NA);\n        param_tree = proto_item_add_subtree(item, ett_s7comm_param);\n        /* Analyze function */\n        function = tvb_get_guint8(tvb, offset);\n        /* add param.function to info column */\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"" Function:[%s]\"", val_to_str(function, param_functionnames, \""Unknown function: 0x%02x\""));\n        proto_tree_add_uint(param_tree, hf_s7comm_param_service, tvb, offset, 1, function);\n        /* show param.function code at the tree */\n        proto_item_append_text(param_tree, \"": (%s)\"", val_to_str(function, param_functionnames, \""Unknown function: 0x%02x\""));\n        offset += 1;\n\n        if (rosctr == S7COMM_ROSCTR_JOB) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* parse item data */\n                    for (i = 0; i < item_count; i++) {\n                        offset_old = offset;\n                        offset = s7comm_decode_param_item(tvb, offset, param_tree, i);\n                        /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                        len = offset - offset_old;\n                        if ((len % 2) && (i < item_count)) {\n                            offset += 1;\n                        }\n                    }\n                    /* in write-function there is a data part */\n                    if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        /* Add returned data to data-tree */\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                /* Special functions */\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    offset = s7comm_decode_pi_service(tvb, pinfo, param_tree, plength, offset -1);\n                    break;\n                case S7COMM_FUNC_PLC_STOP:\n                    offset = s7comm_decode_plc_controls_param_hex29(tvb, param_tree, offset -1);\n                    break;\n\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        } else if (rosctr == S7COMM_ROSCTR_ACK_DATA) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    /* This is a read-response, so the requested data may follow when address in request was ok */\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* Add data tree */\n                    item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                    data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                    /* Add returned data to data-tree */\n                    if ((function == S7COMM_SERV_READVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    } else if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_write_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    if (plength >= 2) {\n                        proto_tree_add_bitmask(param_tree, tvb, offset, hf_s7comm_data_blockcontrol_functionstatus,\n                            ett_s7comm_data_blockcontrol_status, s7comm_data_blockcontrol_status_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    break;\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        }\n    }\n    return offset;\n}"", ""target"": 1}, {""func_name"": ""s7comm_decode_ud_cyclic_subfunc"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_ud_cyclic_subfunc(tvbuff_t *tvb,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint16 dlength,            /* length of data part given in header */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    gboolean know_data = FALSE;\n    guint32 offset_old;\n    guint32 len_item;\n    guint8 item_count;\n    guint8 i;\n\n    switch (subfunc)\n    {\n        case S7COMM_UD_SUBF_CYCLIC_MEM:\n            item_count = tvb_get_guint8(tvb, offset + 1);     /* first byte reserved??? */\n            proto_tree_add_uint(data_tree, hf_s7comm_param_itemcount, tvb, offset, 2, item_count);\n            offset += 2;\n            if (type == S7COMM_UD_TYPE_REQ) {                   /* Request to PLC to send cyclic data */\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_timebase, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_time, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                /* parse item data */\n                for (i = 0; i < item_count; i++) {\n                    offset_old = offset;\n                    offset = s7comm_decode_param_item(tvb, offset, data_tree, i);\n                    /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                    len_item = offset - offset_old;\n                    if ((len_item % 2) && (i < item_count)) {\n                        offset += 1;\n                    }\n                }\n\n            } else if (type == S7COMM_UD_TYPE_RES || type == S7COMM_UD_TYPE_PUSH) {   /* Response from PLC with the requested data */\n                /* parse item data */\n                offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n            }\n            know_data = TRUE;\n            break;\n    }\n\n    if (know_data == FALSE && dlength > 4) {\n        proto_tree_add_item(data_tree, hf_s7comm_userdata_data, tvb, offset, dlength - 4, ENC_NA);\n        offset += dlength;\n    }\n    return offset;\n}"", ""target"": 1}, {""func_name"": ""s7comm_decode_response_read_data"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_response_read_data(tvbuff_t *tvb,\n                                 proto_tree *tree,\n                                 guint8 item_count,\n                                 guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 tsize = 0;\n    guint16 len = 0, len2 = 0;\n    guint16 head_len = 4;           /* 1 byte res-code, 1 byte transp-size, 2 bytes len */\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 1; i <= item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_ERR\n            ) {\n            tsize = tvb_get_guint8(tvb, offset + 1);\n            len = tvb_get_ntohs(tvb, offset + 2);\n            /* calculate length in bytes */\n            if (tsize == S7COMM_DATA_TRANSPORT_SIZE_BBIT ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BBYTE ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BINT\n                ) {     /* given length is in number of bits */\n                if (len % 8) { /* len is not a multiple of 8, then round up to next number */\n                    len /= 8;\n                    len = len + 1;\n                } else {\n                    len /= 8;\n                }\n            }\n\n            /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n            if ((len % 2) && (i < item_count)) {\n                len2 = len + 1;\n            } else {\n                len2 = len;\n            }\n        }\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \"" [%d]: (%s)\"", i, val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_length, tvb, offset + 2, 2, len);\n        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}"", ""target"": 0}, {""func_name"": ""s7comm_decode_ud_cpu_alarm_main"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_ud_cpu_alarm_main(tvbuff_t *tvb,\n                                packet_info *pinfo,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    guint32 start_offset;\n    guint32 asc_start_offset;\n    guint32 msg_obj_start_offset;\n    guint32 ev_id;\n    proto_item *msg_item = NULL;\n    proto_tree *msg_item_tree = NULL;\n    proto_item *msg_obj_item = NULL;\n    proto_tree *msg_obj_item_tree = NULL;\n    proto_item *msg_work_item = NULL;\n    proto_tree *msg_work_item_tree = NULL;\n    guint8 nr_objects;\n    guint8 i;\n    guint8 syntax_id;\n    guint8 nr_of_additional_values;\n    guint8 signalstate;\n    guint8 sig_nr;\n    guint8 ret_val;\n    guint8 querytype;\n    guint8 varspec_length;\n\n    start_offset = offset;\n\n    msg_item = proto_tree_add_item(data_tree, hf_s7comm_cpu_alarm_message_item, tvb, offset, 0, ENC_NA);\n    msg_item_tree = proto_item_add_subtree(msg_item, ett_s7comm_cpu_alarm_message);\n\n    if (subfunc == S7COMM_UD_SUBF_CPU_ALARM8_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMACK_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_ALARMSQ_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMS_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_NOTIFY_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY8_IND) {\n        msg_work_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_timestamp_coming, tvb, offset, 8, ENC_NA);\n        msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_timestamp);\n        offset = s7comm_add_timestamp_to_tree(tvb, msg_work_item_tree, offset, TRUE, FALSE);\n    }\n    proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_function, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    nr_objects = tvb_get_guint8(tvb, offset);\n    proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n    offset += 1;\n    for (i = 1; i <= nr_objects; i++) {\n        msg_obj_start_offset = offset;\n        msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n        msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n        proto_item_append_text(msg_obj_item_tree, \"" [%d]\"", i);\n        if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset += 1;\n            varspec_length = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length);\n            offset += 1;\n            syntax_id = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id);\n            offset += 1;\n            switch (syntax_id) {\n                case S7COMM_SYNTAXID_ALARM_LOCKFREESET:\n                case S7COMM_SYNTAXID_ALARM_INDSET:\n                case S7COMM_SYNTAXID_NOTIFY_INDSET:\n                case S7COMM_SYNTAXID_ALARM_ACKSET:\n                    nr_of_additional_values = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id);\n                    offset += 4;\n                    proto_item_append_text(msg_obj_item_tree, \"": EventID=0x%08x\"", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \"" EventID=0x%08x\"", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" On=[\"");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d\"", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d,\"", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n                                }\n                            }\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \""]\"");\n                        }\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_state,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_ALARM_ACKSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_lastchanged,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_event_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        if (nr_of_additional_values > 0) {\n                            asc_start_offset = offset;\n                            msg_work_item = proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_associated_value, tvb, offset, 0, ENC_NA);\n                            msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_associated_value);\n                            offset = s7comm_decode_response_read_data(tvb, msg_work_item_tree, nr_of_additional_values, offset);\n                            proto_item_set_len(msg_work_item_tree, offset - asc_start_offset);\n                        }\n                    }\n                    break;\n                case S7COMM_SYNTAXID_ALARM_QUERYREQSET:\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown1, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    querytype = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_querytype, tvb, offset, 1, querytype);\n                    offset += 1;\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown2, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    /* there is a querytype=8, which only occurs when a previous SZL request 0x131 index 0x10 has a missing flag in funk_1 */\n                    switch (querytype) {\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYALARMTYPE:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_alarmtype, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" ByAlarmtype=%s\"",\n                                val_to_str(ev_id, alarm_message_query_alarmtype_names, \""Unknown Alarmtype: %u\""));\n                            break;\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYEVENTID:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" ByEventID=0x%08x\"", ev_id);\n                            break;\n                        default:\n                            break;\n                    }\n                    offset += 4;\n                    break;\n                default:\n                    /* for current unknown syntax id, set offset to end of dataset. The varspec_length includes\n                     * the byte for the syntax_id, so minus one.\n                     */\n                    offset += (varspec_length - 1);\n                    break;\n            }\n        } else if (type == S7COMM_UD_TYPE_RES) {\n            ret_val = tvb_get_guint8(tvb, offset);\n            proto_item_append_text(msg_obj_item_tree, \"": (%s)\"", val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n            offset += 1;\n        }\n        proto_item_set_len(msg_obj_item_tree, offset - msg_obj_start_offset);\n    }\n    proto_item_set_len(msg_item_tree, offset - start_offset);\n    return offset;\n}"", ""target"": 0}]","[{""func_name"": ""s7comm_decode_response_write_data"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_response_write_data(tvbuff_t *tvb,\n                                  proto_tree *tree,\n                                  guint8 item_count,\n                                  guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 0; i < item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, 1, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \"" [%d]: (%s)\"", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        offset += 1;\n    }\n    return offset;\n}""}, {""func_name"": ""s7comm_decode_req_resp"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_req_resp(tvbuff_t *tvb,\n                       packet_info *pinfo,\n                       proto_tree *tree,\n                       guint16 plength,\n                       guint16 dlength,\n                       guint32 offset,\n                       guint8 rosctr)\n{\n    proto_item *item = NULL;\n    proto_tree *param_tree = NULL;\n    proto_tree *data_tree = NULL;\n    guint8 function = 0;\n    guint8 item_count = 0;\n    guint8 i;\n    guint32 offset_old;\n    guint32 len;\n\n    if (plength > 0) {\n        /* Add parameter tree */\n        item = proto_tree_add_item(tree, hf_s7comm_param, tvb, offset, plength, ENC_NA);\n        param_tree = proto_item_add_subtree(item, ett_s7comm_param);\n        /* Analyze function */\n        function = tvb_get_guint8(tvb, offset);\n        /* add param.function to info column */\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"" Function:[%s]\"", val_to_str(function, param_functionnames, \""Unknown function: 0x%02x\""));\n        proto_tree_add_uint(param_tree, hf_s7comm_param_service, tvb, offset, 1, function);\n        /* show param.function code at the tree */\n        proto_item_append_text(param_tree, \"": (%s)\"", val_to_str(function, param_functionnames, \""Unknown function: 0x%02x\""));\n        offset += 1;\n\n        if (rosctr == S7COMM_ROSCTR_JOB) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* parse item data */\n                    for (i = 0; i < item_count; i++) {\n                        offset_old = offset;\n                        offset = s7comm_decode_param_item(tvb, offset, param_tree, i);\n                        /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                        len = offset - offset_old;\n                        if ((len % 2) && (i < (item_count-1))) {\n                            offset += 1;\n                        }\n                    }\n                    /* in write-function there is a data part */\n                    if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        /* Add returned data to data-tree */\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                /* Special functions */\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    offset = s7comm_decode_pi_service(tvb, pinfo, param_tree, plength, offset -1);\n                    break;\n                case S7COMM_FUNC_PLC_STOP:\n                    offset = s7comm_decode_plc_controls_param_hex29(tvb, param_tree, offset -1);\n                    break;\n\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        } else if (rosctr == S7COMM_ROSCTR_ACK_DATA) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    /* This is a read-response, so the requested data may follow when address in request was ok */\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* Add data tree */\n                    item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                    data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                    /* Add returned data to data-tree */\n                    if ((function == S7COMM_SERV_READVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    } else if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_write_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    if (plength >= 2) {\n                        proto_tree_add_bitmask(param_tree, tvb, offset, hf_s7comm_data_blockcontrol_functionstatus,\n                            ett_s7comm_data_blockcontrol_status, s7comm_data_blockcontrol_status_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    break;\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        }\n    }\n    return offset;\n}""}, {""func_name"": ""s7comm_decode_ud_cyclic_subfunc"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_ud_cyclic_subfunc(tvbuff_t *tvb,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint16 dlength,            /* length of data part given in header */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    gboolean know_data = FALSE;\n    guint32 offset_old;\n    guint32 len_item;\n    guint8 item_count;\n    guint8 i;\n\n    switch (subfunc)\n    {\n        case S7COMM_UD_SUBF_CYCLIC_MEM:\n            item_count = tvb_get_guint8(tvb, offset + 1);     /* first byte reserved??? */\n            proto_tree_add_uint(data_tree, hf_s7comm_param_itemcount, tvb, offset, 2, item_count);\n            offset += 2;\n            if (type == S7COMM_UD_TYPE_REQ) {                   /* Request to PLC to send cyclic data */\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_timebase, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_time, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                /* parse item data */\n                for (i = 0; i < item_count; i++) {\n                    offset_old = offset;\n                    offset = s7comm_decode_param_item(tvb, offset, data_tree, i);\n                    /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                    len_item = offset - offset_old;\n                    if ((len_item % 2) && (i < (item_count-1))) {\n                        offset += 1;\n                    }\n                }\n\n            } else if (type == S7COMM_UD_TYPE_RES || type == S7COMM_UD_TYPE_PUSH) {   /* Response from PLC with the requested data */\n                /* parse item data */\n                offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n            }\n            know_data = TRUE;\n            break;\n    }\n\n    if (know_data == FALSE && dlength > 4) {\n        proto_tree_add_item(data_tree, hf_s7comm_userdata_data, tvb, offset, dlength - 4, ENC_NA);\n        offset += dlength;\n    }\n    return offset;\n}""}, {""func_name"": ""s7comm_decode_response_read_data"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_response_read_data(tvbuff_t *tvb,\n                                 proto_tree *tree,\n                                 guint8 item_count,\n                                 guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 tsize = 0;\n    guint16 len = 0, len2 = 0;\n    guint16 head_len = 4;           /* 1 byte res-code, 1 byte transp-size, 2 bytes len */\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 0; i < item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_ERR\n            ) {\n            tsize = tvb_get_guint8(tvb, offset + 1);\n            len = tvb_get_ntohs(tvb, offset + 2);\n            /* calculate length in bytes */\n            if (tsize == S7COMM_DATA_TRANSPORT_SIZE_BBIT ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BBYTE ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BINT\n                ) {     /* given length is in number of bits */\n                if (len % 8) { /* len is not a multiple of 8, then round up to next number */\n                    len /= 8;\n                    len = len + 1;\n                } else {\n                    len /= 8;\n                }\n            }\n\n            /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n            if ((len % 2) && (i < (item_count-1))) {\n                len2 = len + 1;\n            } else {\n                len2 = len;\n            }\n        }\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \"" [%d]: (%s)\"", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_length, tvb, offset + 2, 2, len);\n        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}""}, {""func_name"": ""s7comm_decode_ud_cpu_alarm_main"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_ud_cpu_alarm_main(tvbuff_t *tvb,\n                                packet_info *pinfo,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    guint32 start_offset;\n    guint32 asc_start_offset;\n    guint32 msg_obj_start_offset;\n    guint32 ev_id;\n    proto_item *msg_item = NULL;\n    proto_tree *msg_item_tree = NULL;\n    proto_item *msg_obj_item = NULL;\n    proto_tree *msg_obj_item_tree = NULL;\n    proto_item *msg_work_item = NULL;\n    proto_tree *msg_work_item_tree = NULL;\n    guint8 nr_objects;\n    guint8 i;\n    guint8 syntax_id;\n    guint8 nr_of_additional_values;\n    guint8 signalstate;\n    guint8 sig_nr;\n    guint8 ret_val;\n    guint8 querytype;\n    guint8 varspec_length;\n\n    start_offset = offset;\n\n    msg_item = proto_tree_add_item(data_tree, hf_s7comm_cpu_alarm_message_item, tvb, offset, 0, ENC_NA);\n    msg_item_tree = proto_item_add_subtree(msg_item, ett_s7comm_cpu_alarm_message);\n\n    if (subfunc == S7COMM_UD_SUBF_CPU_ALARM8_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMACK_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_ALARMSQ_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMS_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_NOTIFY_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY8_IND) {\n        msg_work_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_timestamp_coming, tvb, offset, 8, ENC_NA);\n        msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_timestamp);\n        offset = s7comm_add_timestamp_to_tree(tvb, msg_work_item_tree, offset, TRUE, FALSE);\n    }\n    proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_function, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    nr_objects = tvb_get_guint8(tvb, offset);\n    proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n    offset += 1;\n    for (i = 0; i < nr_objects; i++) {\n        msg_obj_start_offset = offset;\n        msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n        msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n        proto_item_append_text(msg_obj_item_tree, \"" [%d]\"", i+1);\n        if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset += 1;\n            varspec_length = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length);\n            offset += 1;\n            syntax_id = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id);\n            offset += 1;\n            switch (syntax_id) {\n                case S7COMM_SYNTAXID_ALARM_LOCKFREESET:\n                case S7COMM_SYNTAXID_ALARM_INDSET:\n                case S7COMM_SYNTAXID_NOTIFY_INDSET:\n                case S7COMM_SYNTAXID_ALARM_ACKSET:\n                    nr_of_additional_values = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id);\n                    offset += 4;\n                    proto_item_append_text(msg_obj_item_tree, \"": EventID=0x%08x\"", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \"" EventID=0x%08x\"", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" On=[\"");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d\"", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d,\"", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n                                }\n                            }\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \""]\"");\n                        }\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_state,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_ALARM_ACKSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_lastchanged,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_event_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        if (nr_of_additional_values > 0) {\n                            asc_start_offset = offset;\n                            msg_work_item = proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_associated_value, tvb, offset, 0, ENC_NA);\n                            msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_associated_value);\n                            offset = s7comm_decode_response_read_data(tvb, msg_work_item_tree, nr_of_additional_values, offset);\n                            proto_item_set_len(msg_work_item_tree, offset - asc_start_offset);\n                        }\n                    }\n                    break;\n                case S7COMM_SYNTAXID_ALARM_QUERYREQSET:\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown1, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    querytype = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_querytype, tvb, offset, 1, querytype);\n                    offset += 1;\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown2, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    /* there is a querytype=8, which only occurs when a previous SZL request 0x131 index 0x10 has a missing flag in funk_1 */\n                    switch (querytype) {\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYALARMTYPE:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_alarmtype, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" ByAlarmtype=%s\"",\n                                val_to_str(ev_id, alarm_message_query_alarmtype_names, \""Unknown Alarmtype: %u\""));\n                            break;\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYEVENTID:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" ByEventID=0x%08x\"", ev_id);\n                            break;\n                        default:\n                            break;\n                    }\n                    offset += 4;\n                    break;\n                default:\n                    /* for current unknown syntax id, set offset to end of dataset. The varspec_length includes\n                     * the byte for the syntax_id, so minus one.\n                     */\n                    offset += (varspec_length - 1);\n                    break;\n            }\n        } else if (type == S7COMM_UD_TYPE_RES) {\n            ret_val = tvb_get_guint8(tvb, offset);\n            proto_item_append_text(msg_obj_item_tree, \"": (%s)\"", val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n            offset += 1;\n        }\n        proto_item_set_len(msg_obj_item_tree, offset - msg_obj_start_offset);\n    }\n    proto_item_set_len(msg_item_tree, offset - start_offset);\n    return offset;\n}""}]","{""code"": 6, ""value"": 2}","[{""source"": ""code_info(file:packet-s7comm.c, lines:2663-2700)"", ""result"": ""    proto_tree *item_tree = NULL;\n\n    for (i = 1; i <= item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_ERR\n            ) {\n            tsize = tvb_get_guint8(tvb, offset + 1);\n            len = tvb_get_ntohs(tvb, offset + 2);\n            /* calculate length in bytes */\n            if (tsize == S7COMM_DATA_TRANSPORT_SIZE_BBIT ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BBYTE ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BINT\n                ) {     /* given length is in number of bits */\n                if (len % 8) { /* len is not a multiple of 8, then round up to next number */\n                    len /= 8;\n                    len = len + 1;\n                } else {\n                    len /= 8;\n                }\n            }\n\n            /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n            if ((len % 2) && (i < item_count)) {\n                len2 = len + 1;\n            } else {\n                len2 = len;\n            }\n        }\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \"" [%d]: (%s)\"", i, val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_length, tvb, offset + 2, 2, len);\n""}, {""source"": ""code_info(file:packet-s7comm.c, lines:3874-3900)"", ""result"": ""    proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n    offset += 1;\n    for (i = 1; i <= nr_objects; i++) {\n        msg_obj_start_offset = offset;\n        msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n        msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n        proto_item_append_text(msg_obj_item_tree, \"" [%d]\"", i);\n        if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset += 1;\n            varspec_length = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length);\n            offset += 1;\n            syntax_id = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id);\n            offset += 1;\n            switch (syntax_id) {\n                case S7COMM_SYNTAXID_ALARM_LOCKFREESET:\n                case S7COMM_SYNTAXID_ALARM_INDSET:\n                case S7COMM_SYNTAXID_NOTIFY_INDSET:\n                case S7COMM_SYNTAXID_ALARM_ACKSET:\n                    nr_of_additional_values = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id);\n                    offset += 4;\n""}, {""source"": ""code_info(file:packet-s7comm.c, lines:2701-2720)"", ""result"": ""        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}\n\n/*******************************************************************************************************\n *\n * PDU Type: Request or Response -> Function 0x29 (PLC control functions -> STOP)\n *\n *******************************************************************************************************/\nstatic guint32\n""}, {""source"": ""code_info(file:packet-s7comm.c, lines:3901-3920)"", ""result"": ""                    proto_item_append_text(msg_obj_item_tree, \"": EventID=0x%08x\"", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \"" EventID=0x%08x\"", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" On=[\"");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d\"", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d,\"", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n""}, {""source"": ""code_info(file:packet-s7comm.c, lines:2701-2720)"", ""result"": ""        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}\n\n/*******************************************************************************************************\n *\n * PDU Type: Request or Response -> Function 0x29 (PLC control functions -> STOP)\n *\n *******************************************************************************************************/\nstatic guint32\n""}, {""source"": ""code_info(file:packet-s7comm.c, lines:3901-3920)"", ""result"": ""                    proto_item_append_text(msg_obj_item_tree, \"": EventID=0x%08x\"", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \"" EventID=0x%08x\"", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" On=[\"");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d\"", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d,\"", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n""}, {""source"": ""value_info(file:packet-s7comm.c, value:item_count)"", ""result"": {""value_trace"": [{""full_code"": ""item_count = tvb_get_guint8(tvb, offset + 1)"", ""line"": 4483, ""func_name"": ""s7comm_decode_ud_cyclic_subfunc""}, {""full_code"": ""item_count = tvb_get_ntohs(tvb, offset)"", ""line"": 4570, ""func_name"": ""s7comm_decode_ud_prog_subfunc""}, {""full_code"": ""item_count = tvb_get_ntohs(tvb, offset)"", ""line"": 4588, ""func_name"": ""s7comm_decode_ud_prog_subfunc""}, {""full_code"": ""item_count = 0"", ""line"": 4844, ""func_name"": ""s7comm_decode_req_resp""}, {""full_code"": ""item_count = tvb_get_guint8(tvb, offset)"", ""line"": 4866, ""func_name"": ""s7comm_decode_req_resp""}], ""struct_var"": ""item_count"", ""struct_type"": ""guint8"", ""struct_definition"": ""guint8\n\nguint8\n\nguint8\n\nguint8\n\nguint8\n\nguint8""}}, {""source"": ""value_info(file:packet-s7comm.c, value:nr_objects)"", ""result"": {""value_trace"": [{""full_code"": ""nr_objects = tvb_get_guint8(tvb, offset)"", ""line"": 3873, ""func_name"": ""s7comm_decode_ud_cpu_alarm_main""}], ""struct_var"": ""nr_objects"", ""struct_type"": ""guint8"", ""struct_definition"": ""guint8\n\nguint8\n\nguint8\n\nguint8\n\nguint8\n\nguint8""}}]","1. **Off-by-one error in loop bounds**: In `s7comm_decode_response_read_data` (lines 2663-2700) and `s7comm_decode_ud_cpu_alarm_main` (lines 3874-3900), the original loop used 1-based indexing (`i=1` to `i <= item_count`/`nr_objects`). For `item_count`/`nr_objects` = 255 (guint8 max), this caused an extra iteration (256th iteration). 2. **Missing offset increment on invalid data**: When `ret_val` is invalid (not `S7COMM_ITEM_RETVAL_DATA_OK`/`RESERVED`), the code does not increment `offset` (evidenced by absence of `offset += ...` in these branches). This leads to reprocessing the same `offset`, creating an infinite loop. 3. **Patch correction**: The loop was changed to 0-based indexing (`i=0` to `i < item_count`/`nr_objects`), preventing the extra iteration and eliminating the infinite loop.",0.95,./github/other_context/CVE-2018-7329
54,CVE-2018-8787,"CWE-190, CWE-787",c_cpp,FreeRDP prior to version 2.0.0-rc4 contains an Integer Overflow that leads to a Heap-Based Buffer Overflow in function gdi_Bitmap_Decompress() and results in a memory corruption and probably even a remote code execution.,https://github.com/FreeRDP/FreeRDP/commit/09b9d4f1994a674c4ec85b4947aa656eda1aed8a,Fixed CVE-2018-8787\n\nThanks to Eyal Itkin from Check Point Software Technologies.,1,"[{""func_name"": ""gdi_Bitmap_Decompress"", ""file_path"": ""libfreerdp/gdi/graphics.c"", ""func_code"": ""static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}"", ""target"": 0}]","[{""func_name"": ""gdi_Bitmap_Decompress"", ""file_path"": ""libfreerdp/gdi/graphics.c"", ""func_code"": ""static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tUINT32 size = DstWidth * DstHeight;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\n\tif ((GetBytesPerPixel(bitmap->format) == 0) ||\n\t    (DstWidth == 0) || (DstHeight == 0) || (DstWidth > UINT32_MAX / DstHeight) ||\n\t    (size > (UINT32_MAX / GetBytesPerPixel(bitmap->format))))\n\t\treturn FALSE;\n\n\tsize *= GetBytesPerPixel(bitmap->format);\n\tbitmap->length = size;\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}""}]","{""value"": 6, ""code"": 1}","[{""source"": ""value_info(file:graphics.c, value:DstWidth)"", ""result"": {""value_trace"": [{""full_code"": ""copyDstWidth = nWidth * dstByte"", ""line"": 403, ""func_name"": ""freerdp_image_copy""}], ""struct_var"": ""DstWidth"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:graphics.c, value:DstHeight)"", ""result"": {""value_trace"": [{""full_code"": ""padDstHeight = nDstHeight + 16"", ""line"": 301, ""func_name"": ""avc444_ensure_buffer""}], ""struct_var"": ""DstHeight"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:graphics.c, value:nWidth)"", ""result"": {""value_trace"": [{""full_code"": ""nWidth = nDstWidth - nXDst"", ""line"": 107, ""func_name"": ""convert_color""}, {""full_code"": ""nWidth = updateRects[j].right - updateRects[j].left"", ""line"": 1190, ""func_name"": ""rfx_process_message""}, {""full_code"": ""nWidth = nWidth + nXSrc"", ""line"": 368, ""func_name"": ""adjust_src_coordinates""}, {""full_code"": ""nWidth = *pnWidth"", ""line"": 401, ""func_name"": ""adjust_src_dst_coordinates""}, {""full_code"": ""nWidth += nXDst"", ""line"": 410, ""func_name"": ""adjust_src_dst_coordinates""}], ""struct_var"": ""nWidth"", ""struct_type"": ""UINT32"", ""struct_definition"": ""UINT32""}}, {""source"": ""value_info(file:graphics.c, value:dstByte)"", ""result"": {""value_trace"": [{""full_code"": ""dstByte = GetBytesPerPixel(DstFormat)"", ""line"": 401, ""func_name"": ""freerdp_image_copy""}], ""struct_var"": ""dstByte"", ""struct_type"": ""UINT32"", ""struct_definition"": ""UINT32""}}, {""source"": ""value_info(file:graphics.c, value:pnWidth)"", ""result"": {""value_trace"": [{""full_code"": ""*pnWidth = nWidth"", ""line"": 443, ""func_name"": ""adjust_src_dst_coordinates""}], ""struct_var"": ""pnWidth"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:graphics.c, lines:301-310)"", ""result"": ""\t\tif (y + h > 0)\n\t\t\trect.bottom = y + h - 1;\n\n\t\tif ((rect.left < rect.right) && (rect.top < rect.bottom))\n\t\t{\n\t\t\tbrush = gdi_CreateSolidBrush(gdi->drawing->hdc->bkColor);\n\n\t\t\tif (!brush)\n\t\t\t\treturn FALSE;\n\n\t\t\tgdi_FillRect(gdi->drawing->hdc, &rect, brush);\n""}, {""source"": ""value_info(file:graphics.c, value:DstFormat)"", ""result"": {""value_trace"": [{""full_code"": ""DstFormat = PIXEL_FORMAT_ABGR32"", ""line"": 90, ""func_name"": ""wf_decode_color""}, {""full_code"": ""DstFormat = PIXEL_FORMAT_BGR24"", ""line"": 94, ""func_name"": ""wf_decode_color""}, {""full_code"": ""DstFormat = PIXEL_FORMAT_RGB16"", ""line"": 98, ""func_name"": ""wf_decode_color""}, {""full_code"": ""DstFormat = (!invert) ? PIXEL_FORMAT_RGBA32 : PIXEL_FORMAT_BGRA32"", ""line"": 567, ""func_name"": ""xf_get_local_color_format""}, {""full_code"": ""DstFormat = (!invert) ? PIXEL_FORMAT_RGBX32 : PIXEL_FORMAT_BGRX32"", ""line"": 571, ""func_name"": ""xf_get_local_color_format""}], ""struct_var"": ""DstFormat"", ""struct_type"": ""UINT32"", ""struct_definition"": ""UINT32""}}]","Unchecked multiplication of `DstWidth` (derived from `nWidth * dstByte` in libfreerdp/gdi/graphics.c:403) and `DstHeight` (derived from `nDstHeight + 16` in libfreerdp/gdi/graphics.c:301) in `gdi_Bitmap_Decompress` (libfreerdp/gdi/graphics.c:145) and subsequent multiplication by `GetBytesPerPixel(...)` (libfreerdp/gdi/graphics.c:147) leads to integer overflow. The overflow results in incorrect `bitmap->length`, causing `_aligned_malloc` (libfreerdp/gdi/graphics.c:147) to allocate an undersized buffer, enabling heap-based buffer overflow. `nWidth` is assigned from `*pnWidth` (libfreerdp/gdi/graphics.c:401), and `nDstHeight` is untraced beyond libfreerdp/gdi/graphics.c:301. `GetBytesPerPixel(...)` returns fixed values based on `DstFormat` (libfreerdp/gdi/graphics.c:401, 90-98, 567-571).",0.95,./github/other_context/CVE-2018-8787
55,CVE-2019-1010065,CWE-190,c_cpp,"The Sleuth Kit 4.6.0 and earlier is affected by: Integer Overflow. The impact is: Opening crafted disk image triggers crash in tsk/fs/hfs_dent.c:237. The component is: Overflow in fls tool used on HFS image. Bug is in tsk/fs/hfs.c file in function hfs_cat_traverse() in lines: 952, 1062. The attack vector is: Victim must open a crafted HFS filesystem image.",https://github.com/sleuthkit/sleuthkit/commit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b,"hfs: fix keylen check in hfs_cat_traverse()\n\nIf key->key_len is 65535, calculating ""uint16_t keylen' would\ncause an overflow:\n\n   uint16_t keylen;\n   ...\n   keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len)\n\nso the code bypasses the sanity check ""if (keylen > nodesize)""\nwhich results in crash later:\n\n    ./toolfs/fstools/fls -b 512 -f hfs <image>\n    =================================================================\n    ==16==ERROR: AddressSanitizer: SEGV on unknown address 0x6210000256a4 (pc 0x00000054812b bp 0x7ffca548a8f0 sp 0x7ffca548a480 T0)\n    ==16==The signal is caused by a READ memory access.\n        #0 0x54812a in hfs_dir_open_meta_cb /fuzzing/sleuthkit/tsk/fs/hfs_dent.c:237:20\n        #1 0x51a96c in hfs_cat_traverse /fuzzing/sleuthkit/tsk/fs/hfs.c:1082:21\n        #2 0x547785 in hfs_dir_open_meta /fuzzing/sleuthkit/tsk/fs/hfs_dent.c:480:9\n        #3 0x50f57d in tsk_fs_dir_open_meta /fuzzing/sleuthkit/tsk/fs/fs_dir.c:290:14\n        #4 0x54af17 in tsk_fs_path2inum /fuzzing/sleuthkit/tsk/fs/ifind_lib.c:237:23\n        #5 0x522266 in hfs_open /fuzzing/sleuthkit/tsk/fs/hfs.c:6579:9\n        #6 0x508e89 in main /fuzzing/sleuthkit/tools/fstools/fls.cpp:267:19\n        #7 0x7f9daf67c2b0 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x202b0)\n        #8 0x41d679 in _start (/fuzzing/sleuthkit/tools/fstools/fls+0x41d679)\n\nMake 'keylen' int type to prevent the overflow and fix that.\nNow, I get proper error message instead of crash:\n    ./toolfs/fstools/fls -b 512 -f hfs <image>\n    General file system error (hfs_cat_traverse: length of key 3 in leaf node 1 too large (65537 vs 4096))",1,"[{""func_name"": ""hfs_cat_traverse"", ""file_path"": ""tsk/fs/hfs.c"", ""func_code"": ""uint8_t\nhfs_cat_traverse(HFS_INFO * hfs,\n    TSK_HFS_BTREE_CB a_cb, void *ptr)\n{\n    TSK_FS_INFO *fs = &(hfs->fs_info);\n    uint32_t cur_node;          /* node id of the current node */\n    char *node;\n\n    uint16_t nodesize;\n    uint8_t is_done = 0;\n\n    tsk_error_reset();\n\n    nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize);\n    if ((node = (char *) tsk_malloc(nodesize)) == NULL)\n        return 1;\n\n    /* start at root node */\n    cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode);\n\n    /* if the root node is zero, then the extents btree is empty */\n    /* if no files have overflow extents, the Extents B-tree still\n       exists on disk, but is an empty B-tree containing only\n       the header node */\n    if (cur_node == 0) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \""hfs_cat_traverse: \""\n                \""empty extents btree\\n\"");\n        free(node);\n        return 1;\n    }\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \""hfs_cat_traverse: starting at \""\n            \""root node %\"" PRIu32 \""; nodesize = %\""\n            PRIu16 \""\\n\"", cur_node, nodesize);\n\n    /* Recurse down to the needed leaf nodes and then go forward */\n    is_done = 0;\n    while (is_done == 0) {\n        TSK_OFF_T cur_off;      /* start address of cur_node */\n        uint16_t num_rec;       /* number of records in this node */\n        ssize_t cnt;\n        hfs_btree_node *node_desc;\n\n        // sanity check\n        if (cur_node > tsk_getu32(fs->endian,\n                hfs->catalog_header.totalNodes)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n                (\""hfs_cat_traverse: Node %d too large for file\"", cur_node);\n            free(node);\n            return 1;\n        }\n\n        // read the current node\n        cur_off = cur_node * nodesize;\n        cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off,\n            node, nodesize, 0);\n        if (cnt != nodesize) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\""hfs_cat_traverse: Error reading node %d at offset %\""\n                PRIuOFF, cur_node, cur_off);\n            free(node);\n            return 1;\n        }\n\n        // process the header / descriptor\n        if (nodesize < sizeof(hfs_btree_node)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n            (\""hfs_cat_traverse: Node size %d is too small to be valid\"", nodesize);\n            free(node);\n            return 1;\n        }\n        node_desc = (hfs_btree_node *) node;\n        num_rec = tsk_getu16(fs->endian, node_desc->num_rec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \""hfs_cat_traverse: node %\"" PRIu32\n                \"" @ %\"" PRIu64 \"" has %\"" PRIu16 \"" records\\n\"",\n                cur_node, cur_off, num_rec);\n\n        if (num_rec == 0) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\""hfs_cat_traverse: zero records in node %\""\n                PRIu32, cur_node);\n            free(node);\n            return 1;\n        }\n\n        /* With an index node, find the record with the largest key that is smaller\n         * to or equal to cnid */\n        if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {\n            uint32_t next_node = 0;\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                uint16_t keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\""hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %\""\n                        PRIu16 \"")\"", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\""hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\""\n                        PRIu16 \"")\"", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \""hfs_cat_traverse: record %\"" PRIu16\n                   \"" ; keylen %\"" PRIu16 \"" (%\"" PRIu32 \"")\\n\"", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n\n\n                /* save the info from this record unless it is too big */\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\""hfs_cat_traverse: Callback returned error\"");\n                    free(node);\n                    return 1;\n                }\n                // record the closest entry\n                else if ((retval == HFS_BTREE_CB_IDX_LT)\n                    || (next_node == 0)) {\n                    hfs_btree_index_record *idx_rec;\n                    int keylen =\n                        2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,\n                            key->key_len), &(hfs->catalog_header));\n                    if (rec_off + keylen > nodesize) {\n                        tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                        tsk_error_set_errstr\n                            (\""hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %\""\n                            PRIu16 \"")\"", rec, cur_node,\n                            (int) rec_off + keylen, nodesize);\n                        free(node);\n                        return 1;\n                    }\n                    idx_rec =\n                        (hfs_btree_index_record *) & node[rec_off +\n                        keylen];\n                    next_node = tsk_getu32(fs->endian, idx_rec->childNode);\n                }\n                if (retval == HFS_BTREE_CB_IDX_EQGT) {\n                    // move down to the next node\n                    break;\n                }\n            }\n            // check if we found a relevant node\n            if (next_node == 0) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\""hfs_cat_traverse: did not find any keys in index node %d\"",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            // TODO: Handle multinode loops\n            if (next_node == cur_node) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\""hfs_cat_traverse: node %d references itself as next node\"",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            cur_node = next_node;\n        }\n\n        /* With a leaf, we look for the specific record. */\n        else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                uint16_t keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\""hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %\""\n                        PRIu16 \"")\"", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\""hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %\""\n                        PRIu16 \"")\"", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \""hfs_cat_traverse: record %\"" PRIu16\n                   \""; keylen %\"" PRIu16 \"" (%\"" PRIu32 \"")\\n\"", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n                //                rec_cnid = tsk_getu32(fs->endian, key->file_id);\n\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_LEAF_STOP) {\n                    is_done = 1;\n                    break;\n                }\n                else if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\""hfs_cat_traverse: Callback returned error\"");\n                    free(node);\n                    return 1;\n                }\n            }\n\n            // move right to the next node if we got this far\n            if (is_done == 0) {\n                cur_node = tsk_getu32(fs->endian, node_desc->flink);\n                if (cur_node == 0) {\n                    is_done = 1;\n                }\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \""hfs_cat_traverse: moving forward to next leaf\"");\n            }\n        }\n        else {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\""hfs_cat_traverse: btree node %\"" PRIu32\n                \"" (%\"" PRIu64 \"") is neither index nor leaf (%\"" PRIu8 \"")\"",\n                cur_node, cur_off, node_desc->type);\n            free(node);\n            return 1;\n        }\n    }\n    free(node);\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""hfs_cat_traverse"", ""file_path"": ""tsk/fs/hfs.c"", ""func_code"": ""uint8_t\nhfs_cat_traverse(HFS_INFO * hfs,\n    TSK_HFS_BTREE_CB a_cb, void *ptr)\n{\n    TSK_FS_INFO *fs = &(hfs->fs_info);\n    uint32_t cur_node;          /* node id of the current node */\n    char *node;\n\n    uint16_t nodesize;\n    uint8_t is_done = 0;\n\n    tsk_error_reset();\n\n    nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize);\n    if ((node = (char *) tsk_malloc(nodesize)) == NULL)\n        return 1;\n\n    /* start at root node */\n    cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode);\n\n    /* if the root node is zero, then the extents btree is empty */\n    /* if no files have overflow extents, the Extents B-tree still\n       exists on disk, but is an empty B-tree containing only\n       the header node */\n    if (cur_node == 0) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \""hfs_cat_traverse: \""\n                \""empty extents btree\\n\"");\n        free(node);\n        return 1;\n    }\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \""hfs_cat_traverse: starting at \""\n            \""root node %\"" PRIu32 \""; nodesize = %\""\n            PRIu16 \""\\n\"", cur_node, nodesize);\n\n    /* Recurse down to the needed leaf nodes and then go forward */\n    is_done = 0;\n    while (is_done == 0) {\n        TSK_OFF_T cur_off;      /* start address of cur_node */\n        uint16_t num_rec;       /* number of records in this node */\n        ssize_t cnt;\n        hfs_btree_node *node_desc;\n\n        // sanity check\n        if (cur_node > tsk_getu32(fs->endian,\n                hfs->catalog_header.totalNodes)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n                (\""hfs_cat_traverse: Node %d too large for file\"", cur_node);\n            free(node);\n            return 1;\n        }\n\n        // read the current node\n        cur_off = cur_node * nodesize;\n        cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off,\n            node, nodesize, 0);\n        if (cnt != nodesize) {\n            if (cnt >= 0) {\n                tsk_error_reset();\n                tsk_error_set_errno(TSK_ERR_FS_READ);\n            }\n            tsk_error_set_errstr2\n                (\""hfs_cat_traverse: Error reading node %d at offset %\""\n                PRIuOFF, cur_node, cur_off);\n            free(node);\n            return 1;\n        }\n\n        // process the header / descriptor\n        if (nodesize < sizeof(hfs_btree_node)) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr\n            (\""hfs_cat_traverse: Node size %d is too small to be valid\"", nodesize);\n            free(node);\n            return 1;\n        }\n        node_desc = (hfs_btree_node *) node;\n        num_rec = tsk_getu16(fs->endian, node_desc->num_rec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \""hfs_cat_traverse: node %\"" PRIu32\n                \"" @ %\"" PRIu64 \"" has %\"" PRIu16 \"" records\\n\"",\n                cur_node, cur_off, num_rec);\n\n        if (num_rec == 0) {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\""hfs_cat_traverse: zero records in node %\""\n                PRIu32, cur_node);\n            free(node);\n            return 1;\n        }\n\n        /* With an index node, find the record with the largest key that is smaller\n         * to or equal to cnid */\n        if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {\n            uint32_t next_node = 0;\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                int keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\""hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %\""\n                        PRIu16 \"")\"", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\""hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\""\n                        PRIu16 \"")\"", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \""hfs_cat_traverse: record %\"" PRIu16\n                   \"" ; keylen %\"" PRIu16 \"" (%\"" PRIu32 \"")\\n\"", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n\n\n                /* save the info from this record unless it is too big */\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\""hfs_cat_traverse: Callback returned error\"");\n                    free(node);\n                    return 1;\n                }\n                // record the closest entry\n                else if ((retval == HFS_BTREE_CB_IDX_LT)\n                    || (next_node == 0)) {\n                    hfs_btree_index_record *idx_rec;\n                    int keylen =\n                        2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,\n                            key->key_len), &(hfs->catalog_header));\n                    if (rec_off + keylen > nodesize) {\n                        tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                        tsk_error_set_errstr\n                            (\""hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %\""\n                            PRIu16 \"")\"", rec, cur_node,\n                            (int) rec_off + keylen, nodesize);\n                        free(node);\n                        return 1;\n                    }\n                    idx_rec =\n                        (hfs_btree_index_record *) & node[rec_off +\n                        keylen];\n                    next_node = tsk_getu32(fs->endian, idx_rec->childNode);\n                }\n                if (retval == HFS_BTREE_CB_IDX_EQGT) {\n                    // move down to the next node\n                    break;\n                }\n            }\n            // check if we found a relevant node\n            if (next_node == 0) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\""hfs_cat_traverse: did not find any keys in index node %d\"",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            // TODO: Handle multinode loops\n            if (next_node == cur_node) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\""hfs_cat_traverse: node %d references itself as next node\"",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            cur_node = next_node;\n        }\n\n        /* With a leaf, we look for the specific record. */\n        else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                int keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\""hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %\""\n                        PRIu16 \"")\"", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\""hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %\""\n                        PRIu16 \"")\"", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \""hfs_cat_traverse: record %\"" PRIu16\n                   \""; keylen %\"" PRIu16 \"" (%\"" PRIu32 \"")\\n\"", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n                //                rec_cnid = tsk_getu32(fs->endian, key->file_id);\n\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_LEAF_STOP) {\n                    is_done = 1;\n                    break;\n                }\n                else if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\""hfs_cat_traverse: Callback returned error\"");\n                    free(node);\n                    return 1;\n                }\n            }\n\n            // move right to the next node if we got this far\n            if (is_done == 0) {\n                cur_node = tsk_getu32(fs->endian, node_desc->flink);\n                if (cur_node == 0) {\n                    is_done = 1;\n                }\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \""hfs_cat_traverse: moving forward to next leaf\"");\n            }\n        }\n        else {\n            tsk_error_set_errno(TSK_ERR_FS_GENFS);\n            tsk_error_set_errstr(\""hfs_cat_traverse: btree node %\"" PRIu32\n                \"" (%\"" PRIu64 \"") is neither index nor leaf (%\"" PRIu8 \"")\"",\n                cur_node, cur_off, node_desc->type);\n            free(node);\n            return 1;\n        }\n    }\n    free(node);\n    return 0;\n}""}]","{""code"": 1}","[{""source"": ""code_info(file:hfs.c, lines:952-1062)"", ""result"": ""                    free(node);\n                    return 1;\n                }\n\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                if ((keylen) > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\""hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\""\n                        PRIu16 \"")\"", rec, cur_node, keylen, nodesize);\n                    free(node);\n                    return 1;\n                }\n\n\n                /*\n                   if (tsk_verbose)\n                   tsk_fprintf(stderr,\n                   \""hfs_cat_traverse: record %\"" PRIu16\n                   \"" ; keylen %\"" PRIu16 \"" (%\"" PRIu32 \"")\\n\"", rec,\n                   tsk_getu16(fs->endian, key->key_len),\n                   tsk_getu32(fs->endian, key->parent_cnid));\n                 */\n\n\n                /* save the info from this record unless it is too big */\n                retval =\n                    a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key,\n                    cur_off + rec_off, ptr);\n                if (retval == HFS_BTREE_CB_ERR) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr2\n                        (\""hfs_cat_traverse: Callback returned error\"");\n                    free(node);\n                    return 1;\n                }\n                // record the closest entry\n                else if ((retval == HFS_BTREE_CB_IDX_LT)\n                    || (next_node == 0)) {\n                    hfs_btree_index_record *idx_rec;\n                    int keylen =\n                        2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,\n                            key->key_len), &(hfs->catalog_header));\n                    if (rec_off + keylen > nodesize) {\n                        tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                        tsk_error_set_errstr\n                            (\""hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %\""\n                            PRIu16 \"")\"", rec, cur_node,\n                            (int) rec_off + keylen, nodesize);\n                        free(node);\n                        return 1;\n                    }\n                    idx_rec =\n                        (hfs_btree_index_record *) & node[rec_off +\n                        keylen];\n                    next_node = tsk_getu32(fs->endian, idx_rec->childNode);\n                }\n                if (retval == HFS_BTREE_CB_IDX_EQGT) {\n                    // move down to the next node\n                    break;\n                }\n            }\n            // check if we found a relevant node\n            if (next_node == 0) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\""hfs_cat_traverse: did not find any keys in index node %d\"",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            // TODO: Handle multinode loops\n            if (next_node == cur_node) {\n                tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                tsk_error_set_errstr\n                    (\""hfs_cat_traverse: node %d references itself as next node\"",\n                    cur_node);\n                is_done = 1;\n                break;\n            }\n            cur_node = next_node;\n        }\n\n        /* With a leaf, we look for the specific record. */\n        else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {\n            int rec;\n\n            for (rec = 0; rec < num_rec; ++rec) {\n                size_t rec_off;\n                hfs_btree_key_cat *key;\n                uint8_t retval;\n                uint16_t keylen;\n\n                // get the record offset in the node\n                rec_off =\n                    tsk_getu16(fs->endian,\n                    &node[nodesize - (rec + 1) * 2]);\n                if (rec_off > nodesize) {\n                    tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                    tsk_error_set_errstr\n                        (\""hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %\""\n                        PRIu16 \"")\"", rec, cur_node, (int) rec_off,\n                        nodesize);\n                    free(node);\n                    return 1;\n                }\n                key = (hfs_btree_key_cat *) & node[rec_off];\n\n                keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n""}]","tsk/fs/hfs.c:952-1062: Declaration of 'keylen' as uint16_t allowed overflow during calculation '2 + tsk_getu16(...)'. When key->key_len=65535, keylen=65537 overflows to 1 (uint16_t), bypassing 'keylen > nodesize' check. This led to invalid memory access in hfs_dir_open_meta_cb (tsk/fs/hfs_dent.c:237).",0.95,./github/other_context/CVE-2019-1010065
56,CVE-2019-1010298,"CWE-190, CWE-787",c_cpp,Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Code execution in the context of TEE core (kernel). The component is: optee_os. The fixed version is: 3.4.0 and later.,https://github.com/OP-TEE/optee_os/commit/70697bf3c5dc3d201341b01a1a8e5bc6d2fb48f8,"svc: check for allocation overflow in crypto calls part 2\n\nWithout checking for overflow there is a risk of allocating a buffer\nwith size smaller than anticipated and as a consequence of that it might\nlead to a heap based overflow with attacker controlled data written\noutside the boundaries of the buffer.\n\nFixes: OP-TEE-2018-0011: ""Integer overflow in crypto system calls (x2)""\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>",2,"[{""func_name"": ""syscall_asymm_verify"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_asymm_verify(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *data, size_t data_len,\n\t\t\tconst void *sig, size_t sig_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tsize_t hash_size;\n\tint salt_len = 0;\n\tTEE_Attribute *params = NULL;\n\tuint32_t hash_algo;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_VERIFY)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)data, data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)sig, sig_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tparams = malloc(sizeof(TEE_Attribute) * num_params);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(cs->algo)) {\n\tcase TEE_MAIN_ALGO_RSA:\n\t\tif (cs->algo != TEE_ALG_RSASSA_PKCS1_V1_5) {\n\t\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\t\tres = tee_hash_get_digest_size(hash_algo, &hash_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t\tif (data_len != hash_size) {\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsalt_len = pkcs1_get_salt_len(params, num_params,\n\t\t\t\t\t\t      hash_size);\n\t\t}\n\t\tres = crypto_acipher_rsassa_verify(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t   data, data_len, sig,\n\t\t\t\t\t\t   sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_DSA:\n\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\tres = tee_hash_get_digest_size(hash_algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tbreak;\n\t\t/*\n\t\t * Depending on the DSA algorithm (NIST), the digital signature\n\t\t * output size may be truncated to the size of a key pair\n\t\t * (Q prime size). Q prime size must be less or equal than the\n\t\t * hash output length of the hash algorithm involved.\n\t\t */\n\t\tif (data_len > hash_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tres = crypto_acipher_dsa_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_ECDSA:\n\t\tres = crypto_acipher_ecc_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t}\n\nout:\n\tfree(params);\n\treturn res;\n}"", ""target"": 0}, {""func_name"": ""syscall_asymm_operate"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_asymm_operate(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *src_data, size_t src_len,\n\t\t\tvoid *dst_data, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tuint64_t dlen64;\n\tsize_t dlen;\n\tstruct tee_obj *o;\n\tvoid *label = NULL;\n\tsize_t label_len = 0;\n\tsize_t n;\n\tint salt_len;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_copy_from_user(&dlen64, dst_len, sizeof(dlen64));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdlen = dlen64;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |\n\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tparams = malloc(sizeof(TEE_Attribute) * num_params);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tswitch (cs->algo) {\n\tcase TEE_ALG_RSA_NOPAD:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We will panic because \""the mode is not compatible\n\t\t\t * with the function\""\n\t\t\t */\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\tfor (n = 0; n < num_params; n++) {\n\t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {\n\t\t\t\tlabel = params[n].content.ref.buffer;\n\t\t\t\tlabel_len = params[n].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,\n\t\t\t\t\t\t\t   label, label_len,\n\t\t\t\t\t\t\t   src_data, src_len,\n\t\t\t\t\t\t\t   dst_data, &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tcs->algo, o->attr, label, label_len,\n\t\t\t\t\tsrc_data, src_len, dst_data, &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\n#if defined(CFG_CRYPTO_RSASSA_NA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (cs->mode != TEE_MODE_SIGN) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);\n\t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t src_data, src_len, dst_data,\n\t\t\t\t\t\t &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_DSA_SHA256:\n\t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\tcase TEE_ALG_ECDSA_P192:\n\tcase TEE_ALG_ECDSA_P224:\n\tcase TEE_ALG_ECDSA_P256:\n\tcase TEE_ALG_ECDSA_P384:\n\tcase TEE_ALG_ECDSA_P521:\n\t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\nout:\n\tfree(params);\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tdlen64 = dlen;\n\t\tres2 = tee_svc_copy_to_user(dst_len, &dlen64, sizeof(*dst_len));\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}"", ""target"": 0}]","[{""func_name"": ""syscall_asymm_verify"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_asymm_verify(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *data, size_t data_len,\n\t\t\tconst void *sig, size_t sig_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tsize_t hash_size;\n\tint salt_len = 0;\n\tTEE_Attribute *params = NULL;\n\tuint32_t hash_algo;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_VERIFY)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)data, data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)sig, sig_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(cs->algo)) {\n\tcase TEE_MAIN_ALGO_RSA:\n\t\tif (cs->algo != TEE_ALG_RSASSA_PKCS1_V1_5) {\n\t\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\t\tres = tee_hash_get_digest_size(hash_algo, &hash_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t\tif (data_len != hash_size) {\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsalt_len = pkcs1_get_salt_len(params, num_params,\n\t\t\t\t\t\t      hash_size);\n\t\t}\n\t\tres = crypto_acipher_rsassa_verify(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t   data, data_len, sig,\n\t\t\t\t\t\t   sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_DSA:\n\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\tres = tee_hash_get_digest_size(hash_algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tbreak;\n\t\t/*\n\t\t * Depending on the DSA algorithm (NIST), the digital signature\n\t\t * output size may be truncated to the size of a key pair\n\t\t * (Q prime size). Q prime size must be less or equal than the\n\t\t * hash output length of the hash algorithm involved.\n\t\t */\n\t\tif (data_len > hash_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tres = crypto_acipher_dsa_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_ECDSA:\n\t\tres = crypto_acipher_ecc_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t}\n\nout:\n\tfree(params);\n\treturn res;\n}""}, {""func_name"": ""syscall_asymm_operate"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_asymm_operate(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *src_data, size_t src_len,\n\t\t\tvoid *dst_data, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tuint64_t dlen64;\n\tsize_t dlen;\n\tstruct tee_obj *o;\n\tvoid *label = NULL;\n\tsize_t label_len = 0;\n\tsize_t n;\n\tint salt_len;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_copy_from_user(&dlen64, dst_len, sizeof(dlen64));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdlen = dlen64;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |\n\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tswitch (cs->algo) {\n\tcase TEE_ALG_RSA_NOPAD:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We will panic because \""the mode is not compatible\n\t\t\t * with the function\""\n\t\t\t */\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\tfor (n = 0; n < num_params; n++) {\n\t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {\n\t\t\t\tlabel = params[n].content.ref.buffer;\n\t\t\t\tlabel_len = params[n].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,\n\t\t\t\t\t\t\t   label, label_len,\n\t\t\t\t\t\t\t   src_data, src_len,\n\t\t\t\t\t\t\t   dst_data, &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tcs->algo, o->attr, label, label_len,\n\t\t\t\t\tsrc_data, src_len, dst_data, &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\n#if defined(CFG_CRYPTO_RSASSA_NA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (cs->mode != TEE_MODE_SIGN) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);\n\t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t src_data, src_len, dst_data,\n\t\t\t\t\t\t &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_DSA_SHA256:\n\t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\tcase TEE_ALG_ECDSA_P192:\n\tcase TEE_ALG_ECDSA_P224:\n\tcase TEE_ALG_ECDSA_P256:\n\tcase TEE_ALG_ECDSA_P384:\n\tcase TEE_ALG_ECDSA_P521:\n\t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\nout:\n\tfree(params);\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tdlen64 = dlen;\n\t\tres2 = tee_svc_copy_to_user(dst_len, &dlen64, sizeof(*dst_len));\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}""}]","{""value"": 2, ""function"": 2}","[{""source"": ""value_info(file:tee_svc_cryp.c, value:num_params)"", ""result"": {""value_trace"": [{""full_code"": "".num_params = 3"", ""line"": 48, ""func_name"": ""operation_open""}, {""full_code"": "".num_params = 3"", ""line"": 88, ""func_name"": ""operation_open_dfh""}], ""struct_var"": ""num_params"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""func_info(file:tee_svc_cryp.c, func:syscall_asymm_verify)"", ""result"": [{""code"": ""TEE_Result syscall_asymm_verify(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *data, size_t data_len,\n\t\t\tconst void *sig, size_t sig_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tsize_t hash_size;\n\tint salt_len = 0;\n\tTEE_Attribute *params = NULL;\n\tuint32_t hash_algo;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_VERIFY)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)data, data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)sig, sig_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tparams = malloc(sizeof(TEE_Attribute) * num_params);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(cs->algo)) {\n\tcase TEE_MAIN_ALGO_RSA:\n\t\tif (cs->algo != TEE_ALG_RSASSA_PKCS1_V1_5) {\n\t\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\t\tres = tee_hash_get_digest_size(hash_algo, &hash_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t\tif (data_len != hash_size) {\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsalt_len = pkcs1_get_salt_len(params, num_params,\n\t\t\t\t\t\t      hash_size);\n\t\t}\n\t\tres = crypto_acipher_rsassa_verify(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t   data, data_len, sig,\n\t\t\t\t\t\t   sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_DSA:\n\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\tres = tee_hash_get_digest_size(hash_algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tbreak;\n\t\t/*\n\t\t * Depending on the DSA algorithm (NIST), the digital signature\n\t\t * output size may be truncated to the size of a key pair\n\t\t * (Q prime size). Q prime size must be less or equal than the\n\t\t * hash output length of the hash algorithm involved.\n\t\t */\n\t\tif (data_len > hash_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tres = crypto_acipher_dsa_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_ECDSA:\n\t\tres = crypto_acipher_ecc_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t}\n\nout:\n\tfree(params);\n\treturn res;\n}\n"", ""start_line"": 3398, ""end_line"": 3504, ""full_name"": ""syscall_asymm_verify"", ""file_path"": ""core/tee/tee_svc_cryp.c""}]}, {""source"": ""func_info(file:tee_svc_cryp.c, func:syscall_asymm_operate)"", ""result"": [{""code"": ""TEE_Result syscall_asymm_operate(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *src_data, size_t src_len,\n\t\t\tvoid *dst_data, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tuint64_t dlen64;\n\tsize_t dlen;\n\tstruct tee_obj *o;\n\tvoid *label = NULL;\n\tsize_t label_len = 0;\n\tsize_t n;\n\tint salt_len;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_copy_from_user(&dlen64, dst_len, sizeof(dlen64));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdlen = dlen64;\n\n\tres = tee_mmu_check_access_rights(\n\t\tutc,\n\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |\n\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t(uaddr_t) dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tparams = malloc(sizeof(TEE_Attribute) * num_params);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tswitch (cs->algo) {\n\tcase TEE_ALG_RSA_NOPAD:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We will panic because \""the mode is not compatible\n\t\t\t * with the function\""\n\t\t\t */\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\tfor (n = 0; n < num_params; n++) {\n\t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {\n\t\t\t\tlabel = params[n].content.ref.buffer;\n\t\t\t\tlabel_len = params[n].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,\n\t\t\t\t\t\t\t   label, label_len,\n\t\t\t\t\t\t\t   src_data, src_len,\n\t\t\t\t\t\t\t   dst_data, &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tcs->algo, o->attr, label, label_len,\n\t\t\t\t\tsrc_data, src_len, dst_data, &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\n#if defined(CFG_CRYPTO_RSASSA_NA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (cs->mode != TEE_MODE_SIGN) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);\n\t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t src_data, src_len, dst_data,\n\t\t\t\t\t\t &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_DSA_SHA256:\n\t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\tcase TEE_ALG_ECDSA_P192:\n\tcase TEE_ALG_ECDSA_P224:\n\tcase TEE_ALG_ECDSA_P256:\n\tcase TEE_ALG_ECDSA_P384:\n\tcase TEE_ALG_ECDSA_P521:\n\t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\nout:\n\tfree(params);\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tdlen64 = dlen;\n\t\tres2 = tee_svc_copy_to_user(dst_len, &dlen64, sizeof(*dst_len));\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n"", ""start_line"": 3230, ""end_line"": 3396, ""full_name"": ""syscall_asymm_operate"", ""file_path"": ""core/tee/tee_svc_cryp.c""}]}, {""source"": ""value_info(file:tee_svc_cryp.c, value:num_params)"", ""result"": {""value_trace"": [{""full_code"": "".num_params = 3"", ""line"": 48, ""func_name"": ""operation_open""}, {""full_code"": "".num_params = 3"", ""line"": 88, ""func_name"": ""operation_open_dfh""}], ""struct_var"": ""num_params"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}]","In 'core/tee/tee_svc_cryp.c:3437-3442' (syscall_asymm_verify) and 'core/tee/tee_svc_cryp.c:3275-3280' (syscall_asymm_operate), 'num_params' is passed as a function argument to these syscall handlers. These functions are system call entry points (visible from their parameter lists and context in 'tee_svc_cryp.c'), making 'num_params' directly controllable by user-space applications. The unchecked multiplication of 'sizeof(TEE_Attribute)' (fixed size) and 'num_params' (user-controlled) risks integer overflow, leading to heap-based buffer overflow during 'malloc' and subsequent 'copy_in_attrs'. The patch introduces 'MUL_OVERFLOW' checks to validate the multiplication result before allocation.",0.95,./github/other_context/CVE-2019-1010298
57,CVE-2019-13109,CWE-190,c_cpp,"An integer overflow in Exiv2 through 0.27.1 allows an attacker to cause a denial of service (SIGSEGV) via a crafted PNG image file, because PngImage::readMetadata mishandles a chunkLength - iccOffset subtraction.",https://github.com/Exiv2/exiv2/commit/491c3ebe3b3faa6d8f75fb28146186792c2439da,Avoid negative integer overflow when `iccOffset > chunkLength`.\n\nThis fixes #790.\n\n(cherry picked from commit 6fa2e31206127bd8bcac0269311f3775a8d6ea21),1,"[{""func_name"": ""PngImage::readMetadata"", ""file_path"": ""src/pngimage.cpp"", ""func_code"": ""void PngImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \""Exiv2::PngImage::readMetadata: Reading PNG file \"" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPngType(*io_, true)) {\n            throw Error(kerNotAnImage, \""PNG\"");\n        }\n        clearMetadata();\n\n        const long imgSize = (long)io_->size();\n        DataBuf cheaderBuf(8);  // Chunk header: 4 bytes (data size) + 4 bytes (chunk type).\n\n        while (!io_->eof()) {\n            std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n            readChunk(cheaderBuf, *io_);  // Read chunk header.\n\n            // Decode chunk data length.\n            uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n            long pos = io_->tell();\n            if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) {\n                throw Exiv2::Error(kerFailedToReadImageData);\n            }\n\n            std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4);\n#ifdef DEBUG\n            std::cout << \""Exiv2::PngImage::readMetadata: chunk type: \"" << chunkType << \"" length: \"" << chunkLength\n                      << std::endl;\n#endif\n\n            /// \\todo analyse remaining chunks of the standard\n            // Perform a chunk triage for item that we need.\n            if (chunkType == \""IEND\"" || chunkType == \""IHDR\"" || chunkType == \""tEXt\"" || chunkType == \""zTXt\"" ||\n                chunkType == \""iTXt\"" || chunkType == \""iCCP\"") {\n                DataBuf chunkData(chunkLength);\n                readChunk(chunkData, *io_);  // Extract chunk data.\n\n                if (chunkType == \""IEND\"") {\n                    return;  // Last chunk found: we stop parsing.\n                } else if (chunkType == \""IHDR\"" && chunkData.size_ >= 8) {\n                    Internal::PngImageHeader header;\n                    PngChunk::decodeIHDRChunk(chunkData, header);\n                    pixelWidth_ = header.width;\n                    pixelHeight_ = header.height;\n                    /// \\todo handle rest of data\n                } else if (chunkType == \""tEXt\"") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);\n                } else if (chunkType == \""zTXt\"") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);\n                } else if (chunkType == \""iTXt\"") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);\n                } else if (chunkType == \""iCCP\"") {\n                    // The ICC profile name can vary from 1-79 characters.\n                    uint32_t iccOffset = 0;\n                    while (iccOffset < 80 && iccOffset < chunkLength) {\n                        if (chunkData.pData_[iccOffset++] == 0x00) {\n                            break;\n                        }\n                    }\n                    profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1);\n                    ++iccOffset;  // +1 = 'compressed' flag\n\n                    zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);\n#ifdef DEBUG\n                    std::cout << \""Exiv2::PngImage::readMetadata: profile name: \"" << profileName_ << std::endl;\n                    std::cout << \""Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \""\n                              << iccProfile_.size_ << std::endl;\n#endif\n                }\n\n                // Set chunkLength to 0 in case we have read a supported chunk type. Otherwise, we need to seek the\n                // file to the next chunk position.\n                chunkLength = 0;\n            }\n\n            // Move to the next chunk: chunk data size + 4 CRC bytes.\n#ifdef DEBUG\n            std::cout << \""Exiv2::PngImage::readMetadata: Seek to offset: \"" << chunkLength + 4 << std::endl;\n#endif\n            io_->seek(chunkLength + 4, BasicIo::cur);\n            if (io_->error() || io_->eof()) {\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n    }"", ""target"": 0}]","[{""func_name"": ""PngImage::readMetadata"", ""file_path"": ""src/pngimage.cpp"", ""func_code"": ""void PngImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \""Exiv2::PngImage::readMetadata: Reading PNG file \"" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPngType(*io_, true)) {\n            throw Error(kerNotAnImage, \""PNG\"");\n        }\n        clearMetadata();\n\n        const long imgSize = (long)io_->size();\n        DataBuf cheaderBuf(8);  // Chunk header: 4 bytes (data size) + 4 bytes (chunk type).\n\n        while (!io_->eof()) {\n            std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n            readChunk(cheaderBuf, *io_);  // Read chunk header.\n\n            // Decode chunk data length.\n            uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n            long pos = io_->tell();\n            if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) {\n                throw Exiv2::Error(kerFailedToReadImageData);\n            }\n\n            std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4);\n#ifdef DEBUG\n            std::cout << \""Exiv2::PngImage::readMetadata: chunk type: \"" << chunkType << \"" length: \"" << chunkLength\n                      << std::endl;\n#endif\n\n            /// \\todo analyse remaining chunks of the standard\n            // Perform a chunk triage for item that we need.\n            if (chunkType == \""IEND\"" || chunkType == \""IHDR\"" || chunkType == \""tEXt\"" || chunkType == \""zTXt\"" ||\n                chunkType == \""iTXt\"" || chunkType == \""iCCP\"") {\n                DataBuf chunkData(chunkLength);\n                readChunk(chunkData, *io_);  // Extract chunk data.\n\n                if (chunkType == \""IEND\"") {\n                    return;  // Last chunk found: we stop parsing.\n                } else if (chunkType == \""IHDR\"" && chunkData.size_ >= 8) {\n                    Internal::PngImageHeader header;\n                    PngChunk::decodeIHDRChunk(chunkData, header);\n                    pixelWidth_ = header.width;\n                    pixelHeight_ = header.height;\n                    /// \\todo handle rest of data\n                } else if (chunkType == \""tEXt\"") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);\n                } else if (chunkType == \""zTXt\"") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);\n                } else if (chunkType == \""iTXt\"") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);\n                } else if (chunkType == \""iCCP\"") {\n                    // The ICC profile name can vary from 1-79 characters.\n                    uint32_t iccOffset = 0;\n                    while (iccOffset < 80 && iccOffset < chunkLength) {\n                        if (chunkData.pData_[iccOffset++] == 0x00) {\n                            break;\n                        }\n                    }\n                    profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1);\n                    ++iccOffset;  // +1 = 'compressed' flag\n                    enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata);\n\n                    zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);\n#ifdef DEBUG\n                    std::cout << \""Exiv2::PngImage::readMetadata: profile name: \"" << profileName_ << std::endl;\n                    std::cout << \""Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \""\n                              << iccProfile_.size_ << std::endl;\n#endif\n                }\n\n                // Set chunkLength to 0 in case we have read a supported chunk type. Otherwise, we need to seek the\n                // file to the next chunk position.\n                chunkLength = 0;\n            }\n\n            // Move to the next chunk: chunk data size + 4 CRC bytes.\n#ifdef DEBUG\n            std::cout << \""Exiv2::PngImage::readMetadata: Seek to offset: \"" << chunkLength + 4 << std::endl;\n#endif\n            io_->seek(chunkLength + 4, BasicIo::cur);\n            if (io_->error() || io_->eof()) {\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n    }""}]","{""value"": 2, ""function"": 1}","[{""source"": ""value_info(file:pngimage.cpp, value:iccOffset)"", ""result"": {""value_trace"": [{""full_code"": ""iccOffset = 0"", ""line"": 470, ""func_name"": ""PngImage.readMetadata:void()""}, {""full_code"": ""iccOffset++"", ""line"": 472, ""func_name"": ""PngImage.readMetadata:void()""}, {""full_code"": ""++iccOffset"", ""line"": 477, ""func_name"": ""PngImage.readMetadata:void()""}], ""struct_var"": ""iccOffset"", ""struct_type"": ""uint32_t"", ""struct_definition"": ""uint32_t""}}, {""source"": ""value_info(file:pngimage.cpp, value:chunkLength)"", ""result"": {""value_trace"": [{""full_code"": ""chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian)"", ""line"": 435, ""func_name"": ""PngImage.readMetadata:void()""}, {""full_code"": ""chunkLength = 0"", ""line"": 489, ""func_name"": ""PngImage.readMetadata:void()""}, {""full_code"": ""chunkLength = nameLength + 2 + compressed.size_"", ""line"": 628, ""func_name"": ""PngImage.doWriteMetadata:void(BasicIo&)""}], ""struct_var"": ""chunkLength"", ""struct_type"": ""uint32_t"", ""struct_definition"": ""uint32_t""}}, {""source"": ""func_info(file:pngimage.cpp, func:readMetadata)"", ""result"": [{""code"": ""    void PngImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \""Exiv2::PngImage::readMetadata: Reading PNG file \"" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPngType(*io_, true)) {\n            throw Error(kerNotAnImage, \""PNG\"");\n        }\n        clearMetadata();\n\n        const long imgSize = (long)io_->size();\n        DataBuf cheaderBuf(8);  // Chunk header: 4 bytes (data size) + 4 bytes (chunk type).\n\n        while (!io_->eof()) {\n            std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n            readChunk(cheaderBuf, *io_);  // Read chunk header.\n\n            // Decode chunk data length.\n            uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n            long pos = io_->tell();\n            if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) {\n                throw Exiv2::Error(kerFailedToReadImageData);\n            }\n\n            std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4);\n#ifdef DEBUG\n            std::cout << \""Exiv2::PngImage::readMetadata: chunk type: \"" << chunkType << \"" length: \"" << chunkLength\n                      << std::endl;\n#endif\n\n            /// \\todo analyse remaining chunks of the standard\n            // Perform a chunk triage for item that we need.\n            if (chunkType == \""IEND\"" || chunkType == \""IHDR\"" || chunkType == \""tEXt\"" || chunkType == \""zTXt\"" ||\n                chunkType == \""iTXt\"" || chunkType == \""iCCP\"") {\n                DataBuf chunkData(chunkLength);\n                readChunk(chunkData, *io_);  // Extract chunk data.\n\n                if (chunkType == \""IEND\"") {\n                    return;  // Last chunk found: we stop parsing.\n                } else if (chunkType == \""IHDR\"" && chunkData.size_ >= 8) {\n                    Internal::PngImageHeader header;\n                    PngChunk::decodeIHDRChunk(chunkData, header);\n                    pixelWidth_ = header.width;\n                    pixelHeight_ = header.height;\n                    /// \\todo handle rest of data\n                } else if (chunkType == \""tEXt\"") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk);\n                } else if (chunkType == \""zTXt\"") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk);\n                } else if (chunkType == \""iTXt\"") {\n                    PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk);\n                } else if (chunkType == \""iCCP\"") {\n                    // The ICC profile name can vary from 1-79 characters.\n                    uint32_t iccOffset = 0;\n                    while (iccOffset < 80 && iccOffset < chunkLength) {\n                        if (chunkData.pData_[iccOffset++] == 0x00) {\n                            break;\n                        }\n                    }\n                    profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1);\n                    ++iccOffset;  // +1 = 'compressed' flag\n\n                    zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_);\n#ifdef DEBUG\n                    std::cout << \""Exiv2::PngImage::readMetadata: profile name: \"" << profileName_ << std::endl;\n                    std::cout << \""Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : \""\n                              << iccProfile_.size_ << std::endl;\n#endif\n                }\n\n                // Set chunkLength to 0 in case we have read a supported chunk type. Otherwise, we need to seek the\n                // file to the next chunk position.\n                chunkLength = 0;\n            }\n\n            // Move to the next chunk: chunk data size + 4 CRC bytes.\n#ifdef DEBUG\n            std::cout << \""Exiv2::PngImage::readMetadata: Seek to offset: \"" << chunkLength + 4 << std::endl;\n#endif\n            io_->seek(chunkLength + 4, BasicIo::cur);\n            if (io_->error() || io_->eof()) {\n                throw Error(kerFailedToReadImageData);\n            }\n        }\n    }  // PngImage::readMetadata\n"", ""start_line"": 413, ""end_line"": 501, ""full_name"": ""PngImage.readMetadata:void()"", ""file_path"": ""src/pngimage.cpp""}]}]","src/pngimage.cpp:470: `iccOffset` is initialized to 0. src/pngimage.cpp:471-473: A loop increments `iccOffset` to find a null terminator in the ICC profile name, bounded by `iccOffset < chunkLength`. src/pngimage.cpp:477: After loop exit, `iccOffset` is incremented again (`++iccOffset`), potentially exceeding `chunkLength` if the loop exited at `iccOffset == chunkLength`. src/pngimage.cpp:478: `chunkLength - iccOffset` is computed as a buffer size for `zlibToDataBuf`. If `iccOffset > chunkLength`, this subtraction causes integer overflow/wraparound. src/pngimage.cpp:230 (patch): The added check `enforce(iccOffset <= chunkLength, ...)` prevents this overflow.",0.95,./github/other_context/CVE-2019-13109
58,CVE-2019-13110,"CWE-190, CWE-125",c_cpp,A CiffDirectory::readDirectory integer overflow and out-of-bounds read in Exiv2 through 0.27.1 allows an attacker to cause a denial of service (SIGSEGV) via a crafted CRW image file.,https://github.com/Exiv2/exiv2/commit/f7253d44da08b082781267f855cda172f75d7869,Avoid integer overflow.,1,"[{""func_name"": ""CiffDirectory::readDirectory"", ""file_path"": ""src/crwimage.cpp"", ""func_code"": ""void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if (o + 2 > size) throw Error(33);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \""Directory at offset \"" << std::dec << o\n                  <<\"", \"" << count << \"" entries \\n\"";\n#endif\n        o += 2;\n        for (uint16_t i = 0; i < count; ++i) {\n            if (o + 10 > size) throw Error(33);\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::AutoPtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;\n            default: m = CiffComponent::AutoPtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(m);\n            o += 10;\n        }\n    }"", ""target"": 0}]","[{""func_name"": ""CiffDirectory::readDirectory"", ""file_path"": ""src/crwimage.cpp"", ""func_code"": ""void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        if (size < 4) throw Error(33);\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if (o > size-2) throw Error(33);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \""Directory at offset \"" << std::dec << o\n                  <<\"", \"" << count << \"" entries \\n\"";\n#endif\n        o += 2;\n        if (static_cast<uint32_t>(count) * 10 > size-o) throw Error(33);\n        for (uint16_t i = 0; i < count; ++i) {\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::AutoPtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;\n            default: m = CiffComponent::AutoPtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(m);\n            o += 10;\n        }\n    }""}]","{""value"": 4, ""function"": 3, ""caller"": 3}","[{""source"": ""value_info(value:size)"", ""result"": {""value_trace"": [{""full_code"": ""size = file.tellg()"", ""line"": 796, ""func_name"": ""Jzon.FileReader.loadFile:bool(std.string&,std.string&)""}, {""full_code"": ""size = file.size()"", ""line"": 27, ""func_name"": ""main<duplicate>16:int(int,char[]*)""}, {""full_code"": ""size  = EXV_MAX(32768 * (1 + need / 32768), size_)"", ""line"": 1145, ""func_name"": ""MemIo.Impl.reserve:void(long)""}, {""full_code"": ""size = base64decode(data.c_str(), decodeData, data.length())"", ""line"": 1512, ""func_name"": ""XPathIo.writeDataToFile:string(std.string&)""}, {""full_code"": ""size = 0"", ""line"": 120, ""func_name"": ""Cr2Image.writeMetadata:void()""}], ""struct_var"": ""size"", ""struct_type"": ""std.ios.pos_type"", ""struct_definition"": null}}, {""source"": ""func_info(func:getULong)"", ""result"": [{""code"": ""uint32_t getULong(const byte* buf, ByteOrder byteOrder)\n    {\n        if (byteOrder == littleEndian) {\n            return   (byte)buf[3] << 24 | (byte)buf[2] << 16\n                   | (byte)buf[1] <<  8 | (byte)buf[0];\n        }\n        else {\n            return   (byte)buf[0] << 24 | (byte)buf[1] << 16\n                   | (byte)buf[2] <<  8 | (byte)buf[3];\n        }\n    }"", ""start_line"": 243, ""end_line"": 253, ""full_name"": ""Exiv2.getULong:uint32_t(Exiv2.byte*,Exiv2.ByteOrder)"", ""file_path"": ""src/types.cpp""}, {""code"": ""uint32_t getULong(const byte* buf, ByteOrder byteOrder);"", ""start_line"": 258, ""end_line"": 258, ""full_name"": ""Exiv2.getULong:ANY(Exiv2.byte*,Exiv2.ByteOrder)"", ""file_path"": ""include/exiv2/types.hpp""}]}, {""source"": ""caller_info(func:readDirectory)"", ""result"": [{""call_line"": 391, ""call_code"": ""pRootDir_->readDirectory(pData + offset_, size - offset_, byteOrder_)"", ""caller_code"": ""void CiffHeader::read(const byte* pData, uint32_t size)\n    {\n        if (size < 14) throw Error(33);\n\n        if (pData[0] == 0x49 && pData[1] == 0x49) {\n            byteOrder_ = littleEndian;\n        }\n        else if (pData[0] == 0x4d && pData[1] == 0x4d) {\n            byteOrder_ = bigEndian;\n        }\n        else {\n            throw Error(33);\n        }\n        offset_ = getULong(pData + 2, byteOrder_);\n        if (offset_ < 14 || offset_ > size) throw Error(33);\n        if (std::memcmp(pData + 6, signature(), 8) != 0) {\n            throw Error(33);\n        }\n\n        delete pPadding_;\n        pPadding_ = new byte[offset_ - 14];\n        padded_ = offset_ - 14;\n        std::memcpy(pPadding_, pData + 14, padded_);\n\n        pRootDir_ = new CiffDirectory;\n        pRootDir_->readDirectory(pData + offset_, size - offset_, byteOrder_);\n    }"", ""caller_start"": 366, ""file_path"": ""src/crwimage.cpp""}, {""call_line"": 440, ""call_code"": ""readDirectory(pData + offset(), this->size(), byteOrder)"", ""caller_code"": ""void CiffDirectory::doRead(const byte* pData,\n                               uint32_t    size,\n                               uint32_t    start,\n                               ByteOrder   byteOrder)\n    {\n        CiffComponent::doRead(pData, size, start, byteOrder);\n#ifdef DEBUG\n        std::cout << \""Reading directory 0x\"" << std::hex << tag() << \""\\n\"";\n#endif\n        readDirectory(pData + offset(), this->size(), byteOrder);\n#ifdef DEBUG\n        std::cout << \""<---- 0x\"" << std::hex << tag() << \""\\n\"";\n#endif\n    }"", ""caller_start"": 431, ""file_path"": ""src/crwimage.cpp""}]}, {""source"": ""value_info(value:pData)"", ""result"": {""value_trace"": [{""full_code"": ""* pData = file.mmap()"", ""line"": 26, ""func_name"": ""main<duplicate>16:int(int,char[]*)""}, {""full_code"": ""* pData = 0"", ""line"": 119, ""func_name"": ""Cr2Image.writeMetadata:void()""}, {""full_code"": ""pData = io_->mmap(true)"", ""line"": 125, ""func_name"": ""Cr2Image.writeMetadata:void()""}, {""full_code"": ""* pData = 0"", ""line"": 119, ""func_name"": ""OrfImage.writeMetadata:void()""}, {""full_code"": ""pData = io_->mmap(true)"", ""line"": 125, ""func_name"": ""OrfImage.writeMetadata:void()""}], ""struct_var"": ""pData"", ""struct_type"": ""Exiv2.byte*"", ""struct_definition"": null}}, {""source"": ""value_info(value:size)"", ""result"": {""value_trace"": [{""full_code"": ""size = file.tellg()"", ""line"": 796, ""func_name"": ""Jzon.FileReader.loadFile:bool(std.string&,std.string&)""}, {""full_code"": ""size = file.size()"", ""line"": 27, ""func_name"": ""main<duplicate>16:int(int,char[]*)""}, {""full_code"": ""size  = EXV_MAX(32768 * (1 + need / 32768), size_)"", ""line"": 1145, ""func_name"": ""MemIo.Impl.reserve:void(long)""}, {""full_code"": ""size = base64decode(data.c_str(), decodeData, data.length())"", ""line"": 1512, ""func_name"": ""XPathIo.writeDataToFile:string(std.string&)""}, {""full_code"": ""size = 0"", ""line"": 120, ""func_name"": ""Cr2Image.writeMetadata:void()""}], ""struct_var"": ""size"", ""struct_type"": ""std.ios.pos_type"", ""struct_definition"": null}}, {""source"": ""func_info(func:read)"", ""result"": [{""code"": ""int ValueType<T>::read(const byte* buf, long len, ByteOrder byteOrder)\n    {\n        value_.clear();\n        long ts = TypeInfo::typeSize(typeId());\n        if (ts != 0)\n            if (len % ts != 0) len = (len / ts) * ts;\n        for (long i = 0; i < len; i += ts) {\n            value_.push_back(getValue<T>(buf + i, byteOrder));\n        }\n        return 0;\n    }"", ""start_line"": 1579, ""end_line"": 1589, ""full_name"": ""Exiv2.ValueType.read:int(Exiv2.byte*,long,Exiv2.ByteOrder)"", ""file_path"": ""include/exiv2/value.hpp""}, {""code"": ""int ValueType<T>::read(const std::string& buf)\n    {\n        std::istringstream is(buf);\n        T tmp;\n        ValueList val;\n        while (!(is.eof())) {\n            is >> tmp;\n            if (is.fail()) return 1;\n            val.push_back(tmp);\n        }\n        value_.swap(val);\n        return 0;\n    }"", ""start_line"": 1592, ""end_line"": 1604, ""full_name"": ""Exiv2.ValueType.read:int(std.string&)"", ""file_path"": ""include/exiv2/value.hpp""}, {""code"": ""int Timestamp::read(const std::string& path)\n    {\n        struct stat buf;\n        int rc = stat(path.c_str(), &buf);\n        if (0 == rc) {\n            actime_  = buf.st_atime;\n            modtime_ = buf.st_mtime;\n        }\n        return rc;\n    }"", ""start_line"": 1765, ""end_line"": 1774, ""full_name"": ""Timestamp.read:int(std.string&)"", ""file_path"": ""src/actions.cpp""}]}, {""source"": ""caller_info(func:read)"", ""result"": [{""call_line"": 306, ""call_code"": ""io.read(buff, 4096)"", ""caller_code"": ""bool md5sum(const fs::path &path, md5digest &digest)\n{\n    try {\n        Exiv2::FileIo io(path.string());\n        if (io.open() != 0)\n            return false;\n        Exiv2::IoCloser closer(io);\n\n        Exiv2::byte buff[4096];\n        MD5_CTX context;\n        MD5Init(&context);\n\n        long read_count = io.read(buff, 4096);\n        while(read_count) {\n            MD5Update(&context, buff, read_count);\n            read_count = io.read(buff, 4096);\n        }\n        MD5Final(digest, &context);\n        return true;\n    }\n    catch (std::exception& ) {\n        return false;\n    }\n}"", ""caller_start"": 294, ""file_path"": ""contrib/organize/organize.cpp""}, {""call_line"": 309, ""call_code"": ""io.read(buff, 4096)"", ""caller_code"": ""bool md5sum(const fs::path &path, md5digest &digest)\n{\n    try {\n        Exiv2::FileIo io(path.string());\n        if (io.open() != 0)\n            return false;\n        Exiv2::IoCloser closer(io);\n\n        Exiv2::byte buff[4096];\n        MD5_CTX context;\n        MD5Init(&context);\n\n        long read_count = io.read(buff, 4096);\n        while(read_count) {\n            MD5Update(&context, buff, read_count);\n            read_count = io.read(buff, 4096);\n        }\n        MD5Final(digest, &context);\n        return true;\n    }\n    catch (std::exception& ) {\n        return false;\n    }\n}"", ""caller_start"": 294, ""file_path"": ""contrib/organize/organize.cpp""}, {""call_line"": 1532, ""call_code"": ""read(buf, len, byteOrder)"", ""caller_code"": ""ValueType<T>::ValueType(const byte* buf, long len, ByteOrder byteOrder, TypeId typeId)\n        : Value(typeId), pDataArea_(0), sizeDataArea_(0)\n    {\n        read(buf, len, byteOrder);\n    }"", ""caller_start"": 1529, ""file_path"": ""include/exiv2/value.hpp""}, {""call_line"": 149, ""call_code"": ""imgWrap->image->io().read(buffer, size)"", ""caller_code"": ""EXIVSIMPLE_API int ImageData(HIMAGE img, BYTE *buffer, unsigned int size)\n{\n    assert(img);\n    int result = 0;\n    ImageWrapper *imgWrap = (ImageWrapper*)img;\n    Exiv2::BasicIo &io = imgWrap->image->io();\n    if(io.open() == 0) {\n        result = imgWrap->image->io().read(buffer, size);\n        io.close();\n    }\n    return result;\n}"", ""caller_start"": 142, ""file_path"": ""msvc2003/exivsimple/exivsimple.cpp""}]}, {""source"": ""caller_info(file:crwimage.cpp, func:read)"", ""result"": [{""call_line"": 151, ""call_code"": ""io_->read(buf.pData_, buf.size_)"", ""caller_code"": ""void CrwImage::writeMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \""Writing CRW file \"" << io_->path() << \""\\n\"";\n#endif\n        // Read existing image\n        DataBuf buf;\n        if (io_->open() == 0) {\n            IoCloser closer(*io_);\n            // Ensure that this is the correct image type\n            if (isCrwType(*io_, false)) {\n                // Read the image into a memory buffer\n                buf.alloc(io_->size());\n                io_->read(buf.pData_, buf.size_);\n                if (io_->error() || io_->eof()) {\n                    buf.reset();\n                }\n            }\n        }\n\n        Blob blob;\n        CrwParser::encode(blob, buf.pData_, buf.size_, this);\n\n        // Write new buffer to file\n        BasicIo::AutoPtr tempIo(io_->temporary()); // may throw\n        assert(tempIo.get() != 0);\n        tempIo->write((blob.size() > 0 ? &blob[0] : 0), static_cast<long>(blob.size()));\n        io_->close();\n        io_->transfer(*tempIo); // may throw\n\n    }"", ""caller_start"": 138, ""file_path"": ""src/crwimage.cpp""}, {""call_line"": 177, ""call_code"": ""head->read(pData, size)"", ""caller_code"": ""void CrwParser::decode(CrwImage* pCrwImage, const byte* pData, uint32_t size)\n    {\n        assert(pCrwImage != 0);\n        assert(pData != 0);\n\n        // Parse the image, starting with a CIFF header component\n        CiffHeader::AutoPtr head(new CiffHeader);\n        head->read(pData, size);\n#ifdef DEBUG\n        head->print(std::cerr);\n#endif\n        head->decode(*pCrwImage);\n\n        // a hack to get absolute offset of preview image inside CRW structure\n        CiffComponent* preview = head->findComponent(0x2007, 0x0000);\n        if (preview) {\n            (pCrwImage->exifData())[\""Exif.Image2.JPEGInterchangeFormat\""] = uint32_t(preview->pData() - pData);\n            (pCrwImage->exifData())[\""Exif.Image2.JPEGInterchangeFormatLength\""] = preview->size();\n        }\n    }"", ""caller_start"": 170, ""file_path"": ""src/crwimage.cpp""}, {""call_line"": 201, ""call_code"": ""head->read(pData, size)"", ""caller_code"": ""void CrwParser::encode(\n              Blob&     blob,\n        const byte*     pData,\n              uint32_t  size,\n        const CrwImage* pCrwImage\n    )\n    {\n        // Parse image, starting with a CIFF header component\n        CiffHeader::AutoPtr head(new CiffHeader);\n        if (size != 0) {\n            head->read(pData, size);\n        }\n\n        // Encode Exif tags from image into the CRW parse tree and write the\n        // structure to the binary image blob\n        CrwMap::encode(head.get(), *pCrwImage);\n        head->write(blob);\n\n    }"", ""caller_start"": 191, ""file_path"": ""src/crwimage.cpp""}, {""call_line"": 226, ""call_code"": ""iIo.read(tmpBuf, 14)"", ""caller_code"": ""bool isCrwType(BasicIo& iIo, bool advance)\n    {\n        bool result = true;\n        byte tmpBuf[14];\n        iIo.read(tmpBuf, 14);\n        if (iIo.error() || iIo.eof()) {\n            return false;\n        }\n        if (!(   ('I' == tmpBuf[0] && 'I' == tmpBuf[1])\n              || ('M' == tmpBuf[0] && 'M' == tmpBuf[1]))) {\n            result = false;\n        }\n        if (   true == result\n            && std::memcmp(tmpBuf + 6, CiffHeader::signature(), 8) != 0) {\n            result = false;\n        }\n        if (!advance || !result) iIo.seek(-14, BasicIo::cur);\n        return result;\n    }"", ""caller_start"": 222, ""file_path"": ""src/crwimage.cpp""}]}, {""source"": ""func_info(func:mmap)"", ""result"": [{""code"": ""    byte* FileIo::mmap(bool isWriteable)\n    {\n        assert(p_->fp_ != 0);\n        if (munmap() != 0) {\n#ifdef EXV_UNICODE_PATH\n            if (p_->wpMode_ == Impl::wpUnicode) {\n                throw WError(2, wpath(), strError().c_str(), \""munmap\"");\n            }\n            else\n#endif\n            {\n                throw Error(2, path(), strError(), \""munmap\"");\n            }\n        }\n        p_->mappedLength_ = size();\n        p_->isWriteable_ = isWriteable;\n        if (p_->isWriteable_ && p_->switchMode(Impl::opWrite) != 0) {\n#ifdef EXV_UNICODE_PATH\n            if (p_->wpMode_ == Impl::wpUnicode) {\n                throw WError(16, wpath(), strError().c_str());\n            }\n            else\n#endif\n            {\n                throw Error(16, path(), strError());\n            }\n        }\n#if defined EXV_HAVE_MMAP && defined EXV_HAVE_MUNMAP\n        int prot = PROT_READ;\n        if (p_->isWriteable_) {\n            prot |= PROT_WRITE;\n        }\n        void* rc = ::mmap(0, p_->mappedLength_, prot, MAP_SHARED, fileno(p_->fp_), 0);\n        if (MAP_FAILED == rc) {\n#ifdef EXV_UNICODE_PATH\n            if (p_->wpMode_ == Impl::wpUnicode) {\n                throw WError(2, wpath(), strError().c_str(), \""mmap\"");\n            }\n            else\n#endif\n            {\n                throw Error(2, path(), strError(), \""mmap\"");\n            }\n        }\n        p_->pMappedArea_ = static_cast<byte*>(rc);\n\n#elif defined WIN32 && !defined __CYGWIN__\n        // Windows implementation\n\n        // TODO: An attempt to map a file with a length of 0 (zero) fails with\n        // an error code of ERROR_FILE_INVALID.\n        // Applications should test for files with a length of 0 (zero) and\n        // reject those files.\n\n        DWORD dwAccess = FILE_MAP_READ;\n        DWORD flProtect = PAGE_READONLY;\n        if (isWriteable) {\n            dwAccess = FILE_MAP_WRITE;\n            flProtect = PAGE_READWRITE;\n        }\n        HANDLE hPh = GetCurrentProcess();\n        HANDLE hFd = (HANDLE)_get_osfhandle(fileno(p_->fp_));\n        if (hFd == INVALID_HANDLE_VALUE) {\n#ifdef EXV_UNICODE_PATH\n            if (p_->wpMode_ == Impl::wpUnicode) {\n                throw WError(2, wpath(), \""MSG1\"", \""_get_osfhandle\"");\n            }\n            else\n#endif\n            {\n                throw Error(2, path(), \""MSG1\"", \""_get_osfhandle\"");\n            }\n        }\n        if (!DuplicateHandle(hPh, hFd, hPh, &p_->hFile_, 0, false, DUPLICATE_SAME_ACCESS)) {\n#ifdef EXV_UNICODE_PATH\n            if (p_->wpMode_ == Impl::wpUnicode) {\n                throw WError(2, wpath(), \""MSG2\"", \""DuplicateHandle\"");\n            }\n            else\n#endif\n            {\n                throw Error(2, path(), \""MSG2\"", \""DuplicateHandle\"");\n            }\n        }\n        p_->hMap_ = CreateFileMapping(p_->hFile_, 0, flProtect, 0, (DWORD) p_->mappedLength_, 0);\n        if (p_->hMap_ == 0 ) {\n#ifdef EXV_UNICODE_PATH\n            if (p_->wpMode_ == Impl::wpUnicode) {\n                throw WError(2, wpath(), \""MSG3\"", \""CreateFileMapping\"");\n            }\n            else\n#endif\n            {\n                throw Error(2, path(), \""MSG3\"", \""CreateFileMapping\"");\n            }\n        }\n        void* rc = MapViewOfFile(p_->hMap_, dwAccess, 0, 0, 0);\n        if (rc == 0) {\n#ifdef EXV_UNICODE_PATH\n            if (p_->wpMode_ == Impl::wpUnicode) {\n                throw WError(2, wpath(), \""MSG4\"", \""CreateFileMapping\"");\n            }\n            else\n#endif\n            {\n                throw Error(2, path(), \""MSG4\"", \""CreateFileMapping\"");\n            }\n        }\n        p_->pMappedArea_ = static_cast<byte*>(rc);\n#else\n        // Workaround for platforms without mmap: Read the file into memory\n        DataBuf buf(static_cast<long>(p_->mappedLength_));\n        if (read(buf.pData_, buf.size_) != buf.size_) {\n#ifdef EXV_UNICODE_PATH\n            if (p_->wpMode_ == Impl::wpUnicode) {\n                throw WError(2, wpath(), strError().c_str(), \""FileIo::read\"");\n            }\n            else\n#endif\n            {\n                throw Error(2, path(), strError(), \""FileIo::read\"");\n            }\n        }\n        if (error() || eof()) {\n#ifdef EXV_UNICODE_PATH\n            if (p_->wpMode_ == Impl::wpUnicode) {\n                throw WError(2, wpath(), strError().c_str(), \""FileIo::mmap\"");\n            }\n            else\n#endif\n            {\n                throw Error(2, path(), strError(), \""FileIo::mmap\"");\n            }\n        }\n        p_->pMappedArea_ = buf.release().first;\n        p_->isMalloced_ = true;\n#endif\n        return p_->pMappedArea_;\n    }\n"", ""start_line"": 403, ""end_line"": 541, ""full_name"": ""FileIo.mmap:byte(bool)"", ""file_path"": ""src/basicio.cpp""}, {""code"": ""byte* MemIo::mmap(bool /*isWriteable*/)\n    {\n        return p_->data_;\n    }"", ""start_line"": 1285, ""end_line"": 1288, ""full_name"": ""MemIo.mmap:byte(bool)"", ""file_path"": ""src/basicio.cpp""}, {""code"": ""byte* RemoteIo::mmap(bool /*isWriteable*/)\n    {\n        return NULL;\n    }"", ""start_line"": 1892, ""end_line"": 1895, ""full_name"": ""RemoteIo.mmap:byte(bool)"", ""file_path"": ""src/basicio.cpp""}]}, {""source"": ""value_info(value:size)"", ""result"": {""value_trace"": [{""full_code"": ""size = file.tellg()"", ""line"": 796, ""func_name"": ""Jzon.FileReader.loadFile:bool(std.string&,std.string&)""}, {""full_code"": ""size = file.size()"", ""line"": 27, ""func_name"": ""main<duplicate>16:int(int,char[]*)""}, {""full_code"": ""size  = EXV_MAX(32768 * (1 + need / 32768), size_)"", ""line"": 1145, ""func_name"": ""MemIo.Impl.reserve:void(long)""}, {""full_code"": ""size = base64decode(data.c_str(), decodeData, data.length())"", ""line"": 1512, ""func_name"": ""XPathIo.writeDataToFile:string(std.string&)""}, {""full_code"": ""size = 0"", ""line"": 120, ""func_name"": ""Cr2Image.writeMetadata:void()""}], ""struct_var"": ""size"", ""struct_type"": ""std.ios.pos_type"", ""struct_definition"": null}}]","1. **Data Source**: CRW files are memory-mapped via `FileIo::mmap()` (src/basicio.cpp:403-541), where `pData` points to the file's data and `size` is derived from `FileIo::size()`. 2. **Parsing Flow**: `CrwParser::decode()` (src/crwimage.cpp:177) calls `CiffHeader::read(pData, size)`, passing the raw CRW data. 3. **Offset Calculation**: `CiffHeader::read()` (src/crwimage.cpp:366) uses `getULong()` on untrusted data to compute `offset_`, which is passed to `CiffDirectory::readDirectory()`. 4. **Vulnerable Logic**: In `CiffDirectory::readDirectory()` (src/crwimage.cpp:448), the original code lacked a check for `count * 10` overflow, allowing untrusted `count` to create an out-of-bounds read via `pData`. The patch adds `if (static_cast<uint32_t>(count) * 10 > size-o) throw Error(33);` to mitigate this.",0.95,./github/other_context/CVE-2019-13110
59,CVE-2019-14523,CWE-191,c_cpp,An issue was discovered in Schism Tracker through 20190722. There is an integer underflow via a large plen in fmt_okt_load_song in the Amiga Oktalyzer parser in fmt/okt.c.,https://github.com/schismtracker/schismtracker/commit/c8986a876959a9d282e882d782af351a86e4034c,Guard against negative size_t to memset in MTM and OKT loaders (#202),2,"[{""func_name"": ""fmt_mtm_load_song"", ""file_path"": ""fmt/mtm.c"", ""func_code"": ""int fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags)\n{\n\tuint8_t b[192];\n\tint16_t ntrk, nchan, nord, npat, nsmp; // signed so that EOF is -1\n\tuint16_t comment_len;\n\tint n, pat, chan, smp, rows, todo = 0;\n\tsong_note_t *note;\n\tuint16_t tmp;\n\tuint32_t tmplong;\n\tsong_note_t **trackdata, *tracknote;\n\tsong_sample_t *sample;\n\n\tslurp_read(fp, b, 3);\n\tif (memcmp(b, \""MTM\"", 3) != 0)\n\t\treturn LOAD_UNSUPPORTED;\n\tn = slurp_getc(fp);\n\tsprintf(song->tracker_id, \""MultiTracker %d.%d\"", n >> 4, n & 0xf);\n\tslurp_read(fp, song->title, 20);\n\tsong->title[20] = 0;\n\tslurp_read(fp, &ntrk, 2);\n\tntrk = bswapLE16(ntrk);\n\tnpat = slurp_getc(fp);\n\tnord = slurp_getc(fp) + 1;\n\n\tslurp_read(fp, &comment_len, 2);\n\tcomment_len = bswapLE16(comment_len);\n\n\tnsmp = slurp_getc(fp);\n\tslurp_getc(fp); /* attribute byte (unused) */\n\trows = slurp_getc(fp); /* beats per track (translation: number of rows in every pattern) */\n\tif (rows != 64)\n\t\ttodo |= 64;\n\trows = MIN(rows, 64);\n\tnchan = slurp_getc(fp);\n\tfor (n = 0; n < 32; n++) {\n\t\tint pan = slurp_getc(fp) & 0xf;\n\t\tpan = SHORT_PANNING(pan);\n\t\tpan *= 4; //mphack\n\t\tsong->channels[n].panning = pan;\n\t}\n\tfor (n = nchan; n < MAX_CHANNELS; n++)\n\t\tsong->channels[n].flags = CHN_MUTE;\n\n\t/* samples */\n\tif (nsmp > MAX_SAMPLES) {\n\t\tlog_appendf(4, \"" Warning: Too many samples\"");\n\t}\n\tfor (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) {\n\t\tif (n > MAX_SAMPLES) {\n\t\t\tslurp_seek(fp, 37, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* IT truncates .mtm sample names at the first \\0 rather than the normal behavior\n\t\tof presenting them as spaces (k-achaet.mtm has some \""junk\"" in the sample text) */\n\t\tchar name[23];\n\t\tslurp_read(fp, name, 22);\n\t\tname[22] = '\\0';\n\t\tstrcpy(sample->name, name);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->length = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_start = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_end = bswapLE32(tmplong);\n\t\tif ((sample->loop_end - sample->loop_start) > 2) {\n\t\t\tsample->flags |= CHN_LOOP;\n\t\t} else {\n\t\t\t/* Both Impulse Tracker and Modplug do this */\n\t\t\tsample->loop_start = 0;\n\t\t\tsample->loop_end = 0;\n\t\t}\n\t\tsong->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp));\n\t\tsample->volume = slurp_getc(fp);\n\t\tsample->volume *= 4; //mphack\n\t\tsample->global_volume = 64;\n\t\tif (slurp_getc(fp) & 1) {\n\t\t\ttodo |= 16;\n\t\t\tsample->flags |= CHN_16BIT;\n\t\t\tsample->length >>= 1;\n\t\t\tsample->loop_start >>= 1;\n\t\t\tsample->loop_end >>= 1;\n\t\t}\n\t\tsong->samples[n].vib_type = 0;\n\t\tsong->samples[n].vib_rate = 0;\n\t\tsong->samples[n].vib_depth = 0;\n\t\tsong->samples[n].vib_speed = 0;\n\t}\n\n\t/* orderlist */\n\tslurp_read(fp, song->orderlist, 128);\n\tmemset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord);\n\n\t/* tracks */\n\ttrackdata = mem_calloc(ntrk, sizeof(song_note_t *));\n\tfor (n = 0; n < ntrk; n++) {\n\t\tslurp_read(fp, b, 3 * rows);\n\t\ttrackdata[n] = mem_calloc(rows, sizeof(song_note_t));\n\t\tmtm_unpack_track(b, trackdata[n], rows);\n\t}\n\n\t/* patterns */\n\tif (npat >= MAX_PATTERNS) {\n\t\tlog_appendf(4, \"" Warning: Too many patterns\"");\n\t}\n\tfor (pat = 0; pat <= npat; pat++) {\n\t\t// skip ones that can't be loaded\n\t\tif (pat >= MAX_PATTERNS) {\n\t\t\tslurp_seek(fp, 64, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsong->patterns[pat] = csf_allocate_pattern(MAX(rows, 32));\n\t\tsong->pattern_size[pat] = song->pattern_alloc_size[pat] = 64;\n\t\ttracknote = trackdata[n];\n\t\tfor (chan = 0; chan < 32; chan++) {\n\t\t\tslurp_read(fp, &tmp, 2);\n\t\t\ttmp = bswapLE16(tmp);\n\t\t\tif (tmp == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (tmp > ntrk) {\n\t\t\t\tfor (n = 0; n < ntrk; n++)\n\t\t\t\t\tfree(trackdata[n]);\n\t\t\t\tfree(trackdata);\n\t\t\t\treturn LOAD_FORMAT_ERROR;\n\t\t\t}\n\t\t\tnote = song->patterns[pat] + chan;\n\t\t\ttracknote = trackdata[tmp - 1];\n\t\t\tfor (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS)\n\t\t\t\t*note = *tracknote;\n\t\t}\n\t\tif (rows < 32) {\n\t\t\t/* stick a pattern break on the first channel with an empty effect column\n\t\t\t * (XXX don't do this if there's already one in another column) */\n\t\t\tnote = song->patterns[pat] + 64 * (rows - 1);\n\t\t\twhile (note->effect || note->param)\n\t\t\t\tnote++;\n\t\t\tnote->effect = FX_PATTERNBREAK;\n\t\t}\n\t}\n\n\t/* free willy */\n\tfor (n = 0; n < ntrk; n++)\n\t\tfree(trackdata[n]);\n\tfree(trackdata);\n\n\tread_lined_message(song->message, fp, comment_len, 40);\n\n\t/* sample data */\n\tif (!(lflags & LOAD_NOSAMPLES)) {\n\t\tfor (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) {\n\t\t\tuint32_t ssize;\n\n\t\t\tif (song->samples[smp].length == 0)\n\t\t\t\tcontinue;\n\t\t\tssize = csf_read_sample(song->samples + smp,\n\t\t\t\t(SF_LE | SF_PCMU | SF_M\n\t\t\t\t | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)),\n\t\t\t\tfp->data + fp->pos, fp->length - fp->pos);\n\t\t\tslurp_seek(fp, ssize, SEEK_CUR);\n\t\t}\n\t}\n\n\t/* set the rest of the stuff */\n\tsong->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX;\n\n//      if (ferror(fp)) {\n//              return LOAD_FILE_ERROR;\n//      }\n\n\tif (todo & 64)\n\t\tlog_appendf(2, \"" TODO: test this file with other players (beats per track != 64)\"");\n\tif (todo & 16)\n\t\tlog_appendf(2, \"" TODO: double check 16 bit sample loading\"");\n\n\t/* done! */\n\treturn LOAD_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""fmt_okt_load_song"", ""file_path"": ""fmt/okt.c"", ""func_code"": ""int fmt_okt_load_song(song_t *song, slurp_t *fp, unsigned int lflags)\n{\n\tuint8_t tag[8];\n\tunsigned int readflags = 0;\n\tuint16_t w; // temp for reading\n\tint plen = 0; // how many positions in the orderlist are valid\n\tint npat = 0; // next pattern to read\n\tint nsmp = 1; // next sample (data, not header)\n\tint pat, sh, sd, e; // iterators (pattern, sample header, sample data, effect warnings\n\tint nchn = 0; // how many channels does this song use?\n\tsize_t patseek[MAX_PATTERNS] = {0};\n\tsize_t smpseek[MAX_SAMPLES + 1] = {0}; // where the sample's data starts\n\tuint32_t smpsize[MAX_SAMPLES + 2] = {0}; // data size (one element bigger to simplify loop condition)\n\tuint32_t smpflag[MAX_SAMPLES + 1] = {0}; // bit width\n\tuint32_t effwarn = 0; // effect warning mask\n\n\tslurp_read(fp, tag, 8);\n\tif (memcmp(tag, \""OKTASONG\"", 8) != 0)\n\t\treturn LOAD_UNSUPPORTED;\n\n\twhile (!slurp_eof(fp)) {\n\t\tuint32_t blklen; // length of this block\n\t\tsize_t nextpos; // ... and start of next one\n\n\t\tslurp_read(fp, tag, 4);\n\t\tslurp_read(fp, &blklen, 4);\n\t\tblklen = bswapBE32(blklen);\n\t\tnextpos = slurp_tell(fp) + blklen;\n\n\t\tswitch (OKT_BLOCK(tag[0], tag[1], tag[2], tag[3])) {\n\t\tcase OKT_BLK_CMOD:\n\t\t\tif (!(readflags & OKT_HAS_CMOD)) {\n\t\t\t\treadflags |= OKT_HAS_CMOD;\n\t\t\t\tnchn = okt_read_cmod(song, fp);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SAMP:\n\t\t\tif (!(readflags & OKT_HAS_SAMP)) {\n\t\t\t\treadflags |= OKT_HAS_SAMP;\n\t\t\t\tokt_read_samp(song, fp, blklen, smpflag);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SPEE:\n\t\t\tif (!(readflags & OKT_HAS_SPEE)) {\n\t\t\t\treadflags |= OKT_HAS_SPEE;\n\t\t\t\tslurp_read(fp, &w, 2);\n\t\t\t\tw = bswapBE16(w);\n\t\t\t\tsong->initial_speed = CLAMP(w, 1, 255);\n\t\t\t\tsong->initial_tempo = 125;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SLEN:\n\t\t\t// Don't care.\n\t\t\tbreak;\n\t\tcase OKT_BLK_PLEN:\n\t\t\tif (!(readflags & OKT_HAS_PLEN)) {\n\t\t\t\treadflags |= OKT_HAS_PLEN;\n\t\t\t\tslurp_read(fp, &w, 2);\n\t\t\t\tplen = bswapBE16(w);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_PATT:\n\t\t\tif (!(readflags & OKT_HAS_PATT)) {\n\t\t\t\treadflags |= OKT_HAS_PATT;\n\t\t\t\tslurp_read(fp, song->orderlist, MIN(blklen, MAX_ORDERS));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_PBOD:\n\t\t\t/* Need the channel count (in CMOD) in order to read these */\n\t\t\tif (npat < MAX_PATTERNS) {\n\t\t\t\tif (blklen > 0)\n\t\t\t\t\tpatseek[npat] = slurp_tell(fp);\n\t\t\t\tnpat++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SBOD:\n\t\t\tif (nsmp < MAX_SAMPLES) {\n\t\t\t\tsmpseek[nsmp] = slurp_tell(fp);\n\t\t\t\tsmpsize[nsmp] = blklen;\n\t\t\t\tif (smpsize[nsmp])\n\t\t\t\t\tnsmp++;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t//log_appendf(4, \"" Warning: Unknown block of type '%c%c%c%c' at 0x%lx\"",\n\t\t\t//        tag[0], tag[1], tag[2], tag[3], fp->pos - 8);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (slurp_seek(fp, nextpos, SEEK_SET) != 0) {\n\t\t\tlog_appendf(4, \"" Warning: Failed to seek (file truncated?)\"");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((readflags & (OKT_HAS_CMOD | OKT_HAS_SPEE)) != (OKT_HAS_CMOD | OKT_HAS_SPEE))\n\t\treturn LOAD_FORMAT_ERROR;\n\n\tif (!(lflags & LOAD_NOPATTERNS)) {\n\t\tfor (pat = 0; pat < npat; pat++) {\n\t\t\tslurp_seek(fp, patseek[pat], SEEK_SET);\n\t\t\teffwarn |= okt_read_pbod(song, fp, nchn, pat);\n\t\t}\n\n\t\tif (effwarn) {\n\t\t\tif (effwarn & 1)\n\t\t\t\tlog_appendf(4, \"" Warning: Out-of-range effects (junk data?)\"");\n\t\t\tfor (e = 2; e <= 32; e++) {\n\t\t\t\tif (effwarn & (1 << (e - 1))) {\n\t\t\t\t\tlog_appendf(4, \"" Warning: Unimplemented effect %cxx\"",\n\t\t\t\t\t\te + (e < 10 ? '0' : ('A' - 10)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(lflags & LOAD_NOSAMPLES)) {\n\t\tfor (sh = sd = 1; sh < MAX_SAMPLES && smpsize[sd]; sh++) {\n\t\t\tsong_sample_t *ssmp = song->samples + sh;\n\t\t\tif (!ssmp->length)\n\t\t\t\tcontinue;\n\n\t\t\tif (ssmp->length != smpsize[sd]) {\n\t\t\t\tlog_appendf(4, \"" Warning: Sample %d: header/data size mismatch (%d/%d)\"", sh,\n\t\t\t\t\tssmp->length, smpsize[sd]);\n\t\t\t\tssmp->length = MIN(smpsize[sd], ssmp->length);\n\t\t\t}\n\n\t\t\tcsf_read_sample(ssmp, SF_BE | SF_M | SF_PCMS | smpflag[sd],\n\t\t\t\t\tfp->data + smpseek[sd], ssmp->length);\n\t\t\tsd++;\n\t\t}\n\t\t// Make sure there's nothing weird going on\n\t\tfor (; sh < MAX_SAMPLES; sh++) {\n\t\t\tif (song->samples[sh].length) {\n\t\t\t\tlog_appendf(4, \"" Warning: Sample %d: file truncated\"", sh);\n\t\t\t\tsong->samples[sh].length = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tsong->pan_separation = 64;\n\tmemset(song->orderlist + plen, ORDER_LAST, MAX_ORDERS - plen);\n\tstrcpy(song->tracker_id, \""Amiga Oktalyzer\"");\n\n\treturn LOAD_SUCCESS;\n}"", ""target"": 0}]","[{""func_name"": ""fmt_mtm_load_song"", ""file_path"": ""fmt/mtm.c"", ""func_code"": ""int fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags)\n{\n\tuint8_t b[192];\n\tint16_t ntrk, nchan, nord, npat, nsmp; // signed so that EOF is -1\n\tuint16_t comment_len;\n\tint n, pat, chan, smp, rows, todo = 0;\n\tsong_note_t *note;\n\tuint16_t tmp;\n\tuint32_t tmplong;\n\tsong_note_t **trackdata, *tracknote;\n\tsong_sample_t *sample;\n\n\tslurp_read(fp, b, 3);\n\tif (memcmp(b, \""MTM\"", 3) != 0)\n\t\treturn LOAD_UNSUPPORTED;\n\tn = slurp_getc(fp);\n\tsprintf(song->tracker_id, \""MultiTracker %d.%d\"", n >> 4, n & 0xf);\n\tslurp_read(fp, song->title, 20);\n\tsong->title[20] = 0;\n\tslurp_read(fp, &ntrk, 2);\n\tntrk = bswapLE16(ntrk);\n\tnpat = slurp_getc(fp);\n\tnord = slurp_getc(fp) + 1;\n\n\tslurp_read(fp, &comment_len, 2);\n\tcomment_len = bswapLE16(comment_len);\n\n\tnsmp = slurp_getc(fp);\n\tslurp_getc(fp); /* attribute byte (unused) */\n\trows = slurp_getc(fp); /* beats per track (translation: number of rows in every pattern) */\n\tif (rows != 64)\n\t\ttodo |= 64;\n\trows = MIN(rows, 64);\n\tnchan = slurp_getc(fp);\n\tfor (n = 0; n < 32; n++) {\n\t\tint pan = slurp_getc(fp) & 0xf;\n\t\tpan = SHORT_PANNING(pan);\n\t\tpan *= 4; //mphack\n\t\tsong->channels[n].panning = pan;\n\t}\n\tfor (n = nchan; n < MAX_CHANNELS; n++)\n\t\tsong->channels[n].flags = CHN_MUTE;\n\n\tif (slurp_eof(fp)) {\n\t\treturn LOAD_FORMAT_ERROR;\n\t}\n\n\t/* samples */\n\tif (nsmp > MAX_SAMPLES) {\n\t\tlog_appendf(4, \"" Warning: Too many samples\"");\n\t}\n\tfor (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) {\n\t\tif (n > MAX_SAMPLES) {\n\t\t\tslurp_seek(fp, 37, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* IT truncates .mtm sample names at the first \\0 rather than the normal behavior\n\t\tof presenting them as spaces (k-achaet.mtm has some \""junk\"" in the sample text) */\n\t\tchar name[23];\n\t\tslurp_read(fp, name, 22);\n\t\tname[22] = '\\0';\n\t\tstrcpy(sample->name, name);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->length = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_start = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_end = bswapLE32(tmplong);\n\t\tif ((sample->loop_end - sample->loop_start) > 2) {\n\t\t\tsample->flags |= CHN_LOOP;\n\t\t} else {\n\t\t\t/* Both Impulse Tracker and Modplug do this */\n\t\t\tsample->loop_start = 0;\n\t\t\tsample->loop_end = 0;\n\t\t}\n\t\tsong->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp));\n\t\tsample->volume = slurp_getc(fp);\n\t\tsample->volume *= 4; //mphack\n\t\tsample->global_volume = 64;\n\t\tif (slurp_getc(fp) & 1) {\n\t\t\ttodo |= 16;\n\t\t\tsample->flags |= CHN_16BIT;\n\t\t\tsample->length >>= 1;\n\t\t\tsample->loop_start >>= 1;\n\t\t\tsample->loop_end >>= 1;\n\t\t}\n\t\tsong->samples[n].vib_type = 0;\n\t\tsong->samples[n].vib_rate = 0;\n\t\tsong->samples[n].vib_depth = 0;\n\t\tsong->samples[n].vib_speed = 0;\n\t}\n\n\t/* orderlist */\n\tslurp_read(fp, song->orderlist, 128);\n\tmemset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord);\n\n\t/* tracks */\n\ttrackdata = mem_calloc(ntrk, sizeof(song_note_t *));\n\tfor (n = 0; n < ntrk; n++) {\n\t\tslurp_read(fp, b, 3 * rows);\n\t\ttrackdata[n] = mem_calloc(rows, sizeof(song_note_t));\n\t\tmtm_unpack_track(b, trackdata[n], rows);\n\t}\n\n\t/* patterns */\n\tif (npat >= MAX_PATTERNS) {\n\t\tlog_appendf(4, \"" Warning: Too many patterns\"");\n\t}\n\tfor (pat = 0; pat <= npat; pat++) {\n\t\t// skip ones that can't be loaded\n\t\tif (pat >= MAX_PATTERNS) {\n\t\t\tslurp_seek(fp, 64, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsong->patterns[pat] = csf_allocate_pattern(MAX(rows, 32));\n\t\tsong->pattern_size[pat] = song->pattern_alloc_size[pat] = 64;\n\t\ttracknote = trackdata[n];\n\t\tfor (chan = 0; chan < 32; chan++) {\n\t\t\tslurp_read(fp, &tmp, 2);\n\t\t\ttmp = bswapLE16(tmp);\n\t\t\tif (tmp == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (tmp > ntrk) {\n\t\t\t\tfor (n = 0; n < ntrk; n++)\n\t\t\t\t\tfree(trackdata[n]);\n\t\t\t\tfree(trackdata);\n\t\t\t\treturn LOAD_FORMAT_ERROR;\n\t\t\t}\n\t\t\tnote = song->patterns[pat] + chan;\n\t\t\ttracknote = trackdata[tmp - 1];\n\t\t\tfor (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS)\n\t\t\t\t*note = *tracknote;\n\t\t}\n\t\tif (rows < 32) {\n\t\t\t/* stick a pattern break on the first channel with an empty effect column\n\t\t\t * (XXX don't do this if there's already one in another column) */\n\t\t\tnote = song->patterns[pat] + 64 * (rows - 1);\n\t\t\twhile (note->effect || note->param)\n\t\t\t\tnote++;\n\t\t\tnote->effect = FX_PATTERNBREAK;\n\t\t}\n\t}\n\n\t/* free willy */\n\tfor (n = 0; n < ntrk; n++)\n\t\tfree(trackdata[n]);\n\tfree(trackdata);\n\n\tread_lined_message(song->message, fp, comment_len, 40);\n\n\t/* sample data */\n\tif (!(lflags & LOAD_NOSAMPLES)) {\n\t\tfor (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) {\n\t\t\tuint32_t ssize;\n\n\t\t\tif (song->samples[smp].length == 0)\n\t\t\t\tcontinue;\n\t\t\tssize = csf_read_sample(song->samples + smp,\n\t\t\t\t(SF_LE | SF_PCMU | SF_M\n\t\t\t\t | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)),\n\t\t\t\tfp->data + fp->pos, fp->length - fp->pos);\n\t\t\tslurp_seek(fp, ssize, SEEK_CUR);\n\t\t}\n\t}\n\n\t/* set the rest of the stuff */\n\tsong->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX;\n\n//      if (ferror(fp)) {\n//              return LOAD_FILE_ERROR;\n//      }\n\n\tif (todo & 64)\n\t\tlog_appendf(2, \"" TODO: test this file with other players (beats per track != 64)\"");\n\tif (todo & 16)\n\t\tlog_appendf(2, \"" TODO: double check 16 bit sample loading\"");\n\n\t/* done! */\n\treturn LOAD_SUCCESS;\n}""}, {""func_name"": ""fmt_okt_load_song"", ""file_path"": ""fmt/okt.c"", ""func_code"": ""int fmt_okt_load_song(song_t *song, slurp_t *fp, unsigned int lflags)\n{\n\tuint8_t tag[8];\n\tunsigned int readflags = 0;\n\tuint16_t w; // temp for reading\n\tint plen = 0; // how many positions in the orderlist are valid\n\tint npat = 0; // next pattern to read\n\tint nsmp = 1; // next sample (data, not header)\n\tint pat, sh, sd, e; // iterators (pattern, sample header, sample data, effect warnings\n\tint nchn = 0; // how many channels does this song use?\n\tsize_t patseek[MAX_PATTERNS] = {0};\n\tsize_t smpseek[MAX_SAMPLES + 1] = {0}; // where the sample's data starts\n\tuint32_t smpsize[MAX_SAMPLES + 2] = {0}; // data size (one element bigger to simplify loop condition)\n\tuint32_t smpflag[MAX_SAMPLES + 1] = {0}; // bit width\n\tuint32_t effwarn = 0; // effect warning mask\n\n\tslurp_read(fp, tag, 8);\n\tif (memcmp(tag, \""OKTASONG\"", 8) != 0)\n\t\treturn LOAD_UNSUPPORTED;\n\n\twhile (!slurp_eof(fp)) {\n\t\tuint32_t blklen; // length of this block\n\t\tsize_t nextpos; // ... and start of next one\n\n\t\tslurp_read(fp, tag, 4);\n\t\tslurp_read(fp, &blklen, 4);\n\t\tblklen = bswapBE32(blklen);\n\t\tnextpos = slurp_tell(fp) + blklen;\n\n\t\tswitch (OKT_BLOCK(tag[0], tag[1], tag[2], tag[3])) {\n\t\tcase OKT_BLK_CMOD:\n\t\t\tif (!(readflags & OKT_HAS_CMOD)) {\n\t\t\t\treadflags |= OKT_HAS_CMOD;\n\t\t\t\tnchn = okt_read_cmod(song, fp);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SAMP:\n\t\t\tif (!(readflags & OKT_HAS_SAMP)) {\n\t\t\t\treadflags |= OKT_HAS_SAMP;\n\t\t\t\tokt_read_samp(song, fp, blklen, smpflag);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SPEE:\n\t\t\tif (!(readflags & OKT_HAS_SPEE)) {\n\t\t\t\treadflags |= OKT_HAS_SPEE;\n\t\t\t\tslurp_read(fp, &w, 2);\n\t\t\t\tw = bswapBE16(w);\n\t\t\t\tsong->initial_speed = CLAMP(w, 1, 255);\n\t\t\t\tsong->initial_tempo = 125;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SLEN:\n\t\t\t// Don't care.\n\t\t\tbreak;\n\t\tcase OKT_BLK_PLEN:\n\t\t\tif (!(readflags & OKT_HAS_PLEN)) {\n\t\t\t\treadflags |= OKT_HAS_PLEN;\n\t\t\t\tslurp_read(fp, &w, 2);\n\t\t\t\tplen = bswapBE16(w);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_PATT:\n\t\t\tif (!(readflags & OKT_HAS_PATT)) {\n\t\t\t\treadflags |= OKT_HAS_PATT;\n\t\t\t\tslurp_read(fp, song->orderlist, MIN(blklen, MAX_ORDERS));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_PBOD:\n\t\t\t/* Need the channel count (in CMOD) in order to read these */\n\t\t\tif (npat < MAX_PATTERNS) {\n\t\t\t\tif (blklen > 0)\n\t\t\t\t\tpatseek[npat] = slurp_tell(fp);\n\t\t\t\tnpat++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SBOD:\n\t\t\tif (nsmp < MAX_SAMPLES) {\n\t\t\t\tsmpseek[nsmp] = slurp_tell(fp);\n\t\t\t\tsmpsize[nsmp] = blklen;\n\t\t\t\tif (smpsize[nsmp])\n\t\t\t\t\tnsmp++;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t//log_appendf(4, \"" Warning: Unknown block of type '%c%c%c%c' at 0x%lx\"",\n\t\t\t//        tag[0], tag[1], tag[2], tag[3], fp->pos - 8);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (slurp_seek(fp, nextpos, SEEK_SET) != 0) {\n\t\t\tlog_appendf(4, \"" Warning: Failed to seek (file truncated?)\"");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((readflags & (OKT_HAS_CMOD | OKT_HAS_SPEE)) != (OKT_HAS_CMOD | OKT_HAS_SPEE))\n\t\treturn LOAD_FORMAT_ERROR;\n\n\tif (!(lflags & LOAD_NOPATTERNS)) {\n\t\tfor (pat = 0; pat < npat; pat++) {\n\t\t\tslurp_seek(fp, patseek[pat], SEEK_SET);\n\t\t\teffwarn |= okt_read_pbod(song, fp, nchn, pat);\n\t\t}\n\n\t\tif (effwarn) {\n\t\t\tif (effwarn & 1)\n\t\t\t\tlog_appendf(4, \"" Warning: Out-of-range effects (junk data?)\"");\n\t\t\tfor (e = 2; e <= 32; e++) {\n\t\t\t\tif (effwarn & (1 << (e - 1))) {\n\t\t\t\t\tlog_appendf(4, \"" Warning: Unimplemented effect %cxx\"",\n\t\t\t\t\t\te + (e < 10 ? '0' : ('A' - 10)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(lflags & LOAD_NOSAMPLES)) {\n\t\tfor (sh = sd = 1; sh < MAX_SAMPLES && smpsize[sd]; sh++) {\n\t\t\tsong_sample_t *ssmp = song->samples + sh;\n\t\t\tif (!ssmp->length)\n\t\t\t\tcontinue;\n\n\t\t\tif (ssmp->length != smpsize[sd]) {\n\t\t\t\tlog_appendf(4, \"" Warning: Sample %d: header/data size mismatch (%d/%d)\"", sh,\n\t\t\t\t\tssmp->length, smpsize[sd]);\n\t\t\t\tssmp->length = MIN(smpsize[sd], ssmp->length);\n\t\t\t}\n\n\t\t\tcsf_read_sample(ssmp, SF_BE | SF_M | SF_PCMS | smpflag[sd],\n\t\t\t\t\tfp->data + smpseek[sd], ssmp->length);\n\t\t\tsd++;\n\t\t}\n\t\t// Make sure there's nothing weird going on\n\t\tfor (; sh < MAX_SAMPLES; sh++) {\n\t\t\tif (song->samples[sh].length) {\n\t\t\t\tlog_appendf(4, \"" Warning: Sample %d: file truncated\"", sh);\n\t\t\t\tsong->samples[sh].length = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tsong->pan_separation = 64;\n\tmemset(song->orderlist + plen, ORDER_LAST, MAX(0, MAX_ORDERS - plen));\n\tstrcpy(song->tracker_id, \""Amiga Oktalyzer\"");\n\n\treturn LOAD_SUCCESS;\n}""}]","{""code"": 2, ""value"": 1}","[{""source"": ""code_info(file:okt.c, lines:450-470)"", ""result"": ""\t\tfor (sh = sd = 1; sh < MAX_SAMPLES && smpsize[sd]; sh++) {\n\t\t\tsong_sample_t *ssmp = song->samples + sh;\n\t\t\tif (!ssmp->length)\n\t\t\t\tcontinue;\n\n\t\t\tif (ssmp->length != smpsize[sd]) {\n\t\t\t\tlog_appendf(4, \"" Warning: Sample %d: header/data size mismatch (%d/%d)\"", sh,\n\t\t\t\t\tssmp->length, smpsize[sd]);\n\t\t\t\tssmp->length = MIN(smpsize[sd], ssmp->length);\n\t\t\t}\n\n\t\t\tcsf_read_sample(ssmp, SF_BE | SF_M | SF_PCMS | smpflag[sd],\n\t\t\t\t\tfp->data + smpseek[sd], ssmp->length);\n\t\t\tsd++;\n\t\t}\n\t\t// Make sure there's nothing weird going on\n\t\tfor (; sh < MAX_SAMPLES; sh++) {\n\t\t\tif (song->samples[sh].length) {\n\t\t\t\tlog_appendf(4, \"" Warning: Sample %d: file truncated\"", sh);\n\t\t\t\tsong->samples[sh].length = 0;\n\t\t\t}\n""}, {""source"": ""value_info(file:okt.c, value:plen)"", ""result"": {""value_trace"": [{""full_code"": ""plen = 0"", ""line"": 337, ""func_name"": ""fmt_okt_load_song""}, {""full_code"": ""plen = bswapBE16(w)"", ""line"": 390, ""func_name"": ""fmt_okt_load_song""}], ""struct_var"": ""plen"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""code_info(file:okt.c, lines:380-395)"", ""result"": ""\t\t\t\tsong->initial_tempo = 125;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SLEN:\n\t\t\t// Don't care.\n\t\t\tbreak;\n\t\tcase OKT_BLK_PLEN:\n\t\t\tif (!(readflags & OKT_HAS_PLEN)) {\n\t\t\t\treadflags |= OKT_HAS_PLEN;\n\t\t\t\tslurp_read(fp, &w, 2);\n\t\t\t\tplen = bswapBE16(w);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_PATT:\n\t\t\tif (!(readflags & OKT_HAS_PATT)) {\n\t\t\t\treadflags |= OKT_HAS_PATT;\n""}]","fmt/okt.c:473: 'plen' is derived from unvalidated user input via 'bswapBE16(w)' at fmt/okt.c:390. 'w' is read from the file via 'slurp_read(fp, &w, 2)' without bounds checking (fmt/okt.c:390). If 'plen' exceeds MAX_ORDERS, 'MAX_ORDERS - plen' underflows when cast to size_t, leading to excessive memory writes in memset. The patch uses MAX(0, ...) to clamp the size.",0.95,./github/other_context/CVE-2019-14523
60,CVE-2019-15161,CWE-131,c_cpp,rpcapd/daemon.c in libpcap before 1.9.1 mishandles certain length values because of reuse of a variable. This may open up an attack vector involving extra data at the end of a request.,https://github.com/the-tcpdump-group/libpcap/commit/617b12c0339db4891d117b661982126c495439ea,"Calculate the reply payload length in a local variable.\n\nUsing the same variable for the remaining request length and the reply\nlength is confusing at best and can cause errors at worst (if the\nrequest had extra stuff at the end, so that the variable is non-zero).\n\nThis addresses Include Security issue I8: [libpcap] Remote Packet\nCapture Daemon Parameter Reuse.",1,"[{""func_name"": ""daemon_msg_findallif_req"", ""file_path"": ""rpcapd/daemon.c"", ""func_code"": ""static int\ndaemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tpcap_if_t *alldevs = NULL;\t\t// pointer to the header of the interface chain\n\tpcap_if_t *d;\t\t\t\t// temp pointer needed to scan the interface chain\n\tstruct pcap_addr *address;\t\t// pcap structure that keeps a network address of an interface\n\tstruct rpcap_findalldevs_if *findalldevs_if;// rpcap structure that packet all the data of an interface together\n\tuint16 nif = 0;\t\t\t\t// counts the number of interface listed\n\n\t// Discard the rest of the message; there shouldn't be any payload.\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// Retrieve the device list\n\tif (pcap_findalldevs(&alldevs, errmsgbuf) == -1)\n\t\tgoto error;\n\n\tif (alldevs == NULL)\n\t{\n\t\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_NOREMOTEIF,\n\t\t\t\""No interfaces found! Make sure libpcap/WinPcap is properly installed\""\n\t\t\t\"" and you have the right to access to the remote device.\"",\n\t\t\terrbuf) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \""Send to client failed: %s\"", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// checks the number of interfaces and it computes the total length of the payload\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tnif++;\n\n\t\tif (d->description)\n\t\t\tplen+= strlen(d->description);\n\t\tif (d->name)\n\t\t\tplen+= strlen(d->name);\n\n\t\tplen+= sizeof(struct rpcap_findalldevs_if);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tplen+= (sizeof(struct rpcap_sockaddr) * 4);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// RPCAP findalldevs command\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf,\n\t    PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_FINDALLIF_REPLY, nif, plen);\n\n\t// send the interface list\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tuint16 lname, ldescr;\n\n\t\tfindalldevs_if = (struct rpcap_findalldevs_if *) &sendbuf[sendbufidx];\n\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_findalldevs_if), NULL,\n\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tmemset(findalldevs_if, 0, sizeof(struct rpcap_findalldevs_if));\n\n\t\tif (d->description) ldescr = (short) strlen(d->description);\n\t\telse ldescr = 0;\n\t\tif (d->name) lname = (short) strlen(d->name);\n\t\telse lname = 0;\n\n\t\tfindalldevs_if->desclen = htons(ldescr);\n\t\tfindalldevs_if->namelen = htons(lname);\n\t\tfindalldevs_if->flags = htonl(d->flags);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tfindalldevs_if->naddr++;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfindalldevs_if->naddr = htons(findalldevs_if->naddr);\n\n\t\tif (sock_bufferize(d->name, lname, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif (sock_bufferize(d->description, ldescr, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\t// send all addresses\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\tstruct rpcap_sockaddr *sockaddr;\n\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->addr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->netmask, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->broadaddr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->dstaddr, sockaddr);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// We no longer need the device list. Free it.\n\tpcap_freealldevs(alldevs);\n\n\t// Send a final command that says \""now send it!\""\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \""Send to client failed: %s\"", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (alldevs)\n\t\tpcap_freealldevs(alldevs);\n\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_FINDALLIF,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \""Send to client failed: %s\"", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""daemon_msg_findallif_req"", ""file_path"": ""rpcapd/daemon.c"", ""func_code"": ""static int\ndaemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tpcap_if_t *alldevs = NULL;\t\t// pointer to the header of the interface chain\n\tpcap_if_t *d;\t\t\t\t// temp pointer needed to scan the interface chain\n\tstruct pcap_addr *address;\t\t// pcap structure that keeps a network address of an interface\n\tstruct rpcap_findalldevs_if *findalldevs_if;// rpcap structure that packet all the data of an interface together\n\tuint32 replylen;\t\t\t// length of reply payload\n\tuint16 nif = 0;\t\t\t\t// counts the number of interface listed\n\n\t// Discard the rest of the message; there shouldn't be any payload.\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// Retrieve the device list\n\tif (pcap_findalldevs(&alldevs, errmsgbuf) == -1)\n\t\tgoto error;\n\n\tif (alldevs == NULL)\n\t{\n\t\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_NOREMOTEIF,\n\t\t\t\""No interfaces found! Make sure libpcap/WinPcap is properly installed\""\n\t\t\t\"" and you have the right to access to the remote device.\"",\n\t\t\terrbuf) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \""Send to client failed: %s\"", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// This checks the number of interfaces and computes the total\n\t// length of the payload.\n\treplylen = 0;\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tnif++;\n\n\t\tif (d->description)\n\t\t\treplylen += strlen(d->description);\n\t\tif (d->name)\n\t\t\treplylen += strlen(d->name);\n\n\t\treplylen += sizeof(struct rpcap_findalldevs_if);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\treplylen += (sizeof(struct rpcap_sockaddr) * 4);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// RPCAP findalldevs command\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf,\n\t    PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_FINDALLIF_REPLY, nif, replylen);\n\n\t// send the interface list\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tuint16 lname, ldescr;\n\n\t\tfindalldevs_if = (struct rpcap_findalldevs_if *) &sendbuf[sendbufidx];\n\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_findalldevs_if), NULL,\n\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tmemset(findalldevs_if, 0, sizeof(struct rpcap_findalldevs_if));\n\n\t\tif (d->description) ldescr = (short) strlen(d->description);\n\t\telse ldescr = 0;\n\t\tif (d->name) lname = (short) strlen(d->name);\n\t\telse lname = 0;\n\n\t\tfindalldevs_if->desclen = htons(ldescr);\n\t\tfindalldevs_if->namelen = htons(lname);\n\t\tfindalldevs_if->flags = htonl(d->flags);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tfindalldevs_if->naddr++;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfindalldevs_if->naddr = htons(findalldevs_if->naddr);\n\n\t\tif (sock_bufferize(d->name, lname, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif (sock_bufferize(d->description, ldescr, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\t// send all addresses\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\tstruct rpcap_sockaddr *sockaddr;\n\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->addr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->netmask, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->broadaddr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->dstaddr, sockaddr);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// We no longer need the device list. Free it.\n\tpcap_freealldevs(alldevs);\n\n\t// Send a final command that says \""now send it!\""\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \""Send to client failed: %s\"", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (alldevs)\n\t\tpcap_freealldevs(alldevs);\n\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_FINDALLIF,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \""Send to client failed: %s\"", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}""}]","{""value"": 2, ""code"": 1}","[{""source"": ""value_info(file:daemon.c, value:plen)"", ""result"": {""value_trace"": [{""full_code"": ""plen = header.plen"", ""line"": 332, ""func_name"": ""daemon_serviceloop""}, {""full_code"": ""plen = header.plen"", ""line"": 570, ""func_name"": ""daemon_serviceloop""}, {""full_code"": ""plen+= strlen(d->description)"", ""line"": 1370, ""func_name"": ""daemon_msg_findallif_req""}, {""full_code"": ""plen+= strlen(d->name)"", ""line"": 1372, ""func_name"": ""daemon_msg_findallif_req""}, {""full_code"": ""plen+= sizeof(struct rpcap_findalldevs_if)"", ""line"": 1374, ""func_name"": ""daemon_msg_findallif_req""}], ""struct_var"": ""plen"", ""struct_type"": ""uint32"", ""struct_definition"": ""typedef unsigned int uint32;""}}, {""source"": ""code_info(file:daemon.c, lines:1330-1360)"", ""result"": ""\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tpcap_if_t *alldevs = NULL;\t\t// pointer to the header of the interface chain\n\tpcap_if_t *d;\t\t\t\t// temp pointer needed to scan the interface chain\n\tstruct pcap_addr *address;\t\t// pcap structure that keeps a network address of an interface\n\tstruct rpcap_findalldevs_if *findalldevs_if;// rpcap structure that packet all the data of an interface together\n\tuint16 nif = 0;\t\t\t\t// counts the number of interface listed\n\n\t// Discard the rest of the message; there shouldn't be any payload.\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// Retrieve the device list\n\tif (pcap_findalldevs(&alldevs, errmsgbuf) == -1)\n\t\tgoto error;\n\n\tif (alldevs == NULL)\n\t{\n\t\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_NOREMOTEIF,\n\t\t\t\""No interfaces found! Make sure libpcap/WinPcap is properly installed\""\n\t\t\t\"" and you have the right to access to the remote device.\"",\n\t\t\terrbuf) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \""Send to client failed: %s\"", errbuf);\n\t\t\treturn -1;\n\t\t}\n""}, {""source"": ""value_info(file:daemon.c, value:plen)"", ""result"": {""value_trace"": [{""full_code"": ""plen = header.plen"", ""line"": 332, ""func_name"": ""daemon_serviceloop""}, {""full_code"": ""plen = header.plen"", ""line"": 570, ""func_name"": ""daemon_serviceloop""}, {""full_code"": ""plen+= strlen(d->description)"", ""line"": 1370, ""func_name"": ""daemon_msg_findallif_req""}, {""full_code"": ""plen+= strlen(d->name)"", ""line"": 1372, ""func_name"": ""daemon_msg_findallif_req""}, {""full_code"": ""plen+= sizeof(struct rpcap_findalldevs_if)"", ""line"": 1374, ""func_name"": ""daemon_msg_findallif_req""}], ""struct_var"": ""plen"", ""struct_type"": ""uint32"", ""struct_definition"": ""typedef unsigned int uint32;""}}]","Original code reused 'plen' (initialized from request header.plen in daemon_serviceloop:332/570) for reply length calculation in daemon_msg_findallif_req. This allowed residual 'plen' values (from request payload length) to corrupt reply size computation (e.g., 'plen+= strlen(d->description)' in daemon.c:1370). Patch replaces 'plen' with 'replylen' (daemon.c:1363) initialized to 0, preventing interference from request data.",0.95,./github/other_context/CVE-2019-15161
61,CVE-2019-19004,"CWE-415, CWE-190",c_cpp,A biWidth*biBitCnt integer overflow in input-bmp.c in autotrace 0.31.1 allows attackers to provide an unexpected input value to malloc via a malformed bitmap image.,https://github.com/autotrace/autotrace/commit/64c5833e55d7672d6136a3fbfeae24bd012d36a5,Check for overflow in row bytes\n\nFixes CVE-2019-19004,1,"[{""func_name"": ""input_bmp_reader"", ""file_path"": ""src/input-bmp.c"", ""func_code"": ""at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps, Grey;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n\n  fd = fopen(filename, \""rb\"");\n\n  if (!fd) {\n    LOG(\""Can't open \\\""%s\\\""\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: cannot open input file\"");\n    return image;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, buffer, 18) || (strncmp((const char *)buffer, \""BM\"", 2))) {\n    LOG(\""Not a valid BMP file %s\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: invalid input file\"");\n    goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x02]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x06]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x08]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x0a]);\n  Bitmap_File_Head.biSize = ToL(&buffer[0x0e]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 4;\n  } else if (Bitmap_File_Head.biSize >= 40 && Bitmap_File_Head.biSize <= 64) {  /* Probably OS/2 2.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 3;\n  } else {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    Bitmap_Head.biClrUsed = ColormapSize;\n\n  /* Sanity checks */\n\n  if ((Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n      || (Bitmap_Head.biPlanes != 1)\n      || (ColormapSize > 256 || Bitmap_Head.biClrUsed > 256)) {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\""\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\"", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n  /* Get the Colormap */\n  ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp);\n  if (at_exception_got_fatal(&exp))\n    goto cleanup;\n\n#ifdef DEBUG\n  printf(\""Colormap read\\n\"");\n#endif\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, Bitmap_Head.biWidth, Bitmap_Head.biHeight, ColorMap, Bitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes, Grey);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}"", ""target"": 0}]","[{""func_name"": ""input_bmp_reader"", ""file_path"": ""src/input-bmp.c"", ""func_code"": ""at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps, Grey;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n\n  fd = fopen(filename, \""rb\"");\n\n  if (!fd) {\n    LOG(\""Can't open \\\""%s\\\""\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: cannot open input file\"");\n    return image;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, buffer, 18) || (strncmp((const char *)buffer, \""BM\"", 2))) {\n    LOG(\""Not a valid BMP file %s\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: invalid input file\"");\n    goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x02]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x06]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x08]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x0a]);\n  Bitmap_File_Head.biSize = ToL(&buffer[0x0e]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 4;\n  } else if (Bitmap_File_Head.biSize >= 40 && Bitmap_File_Head.biSize <= 64) {  /* Probably OS/2 2.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 3;\n  } else {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    Bitmap_Head.biClrUsed = ColormapSize;\n\n  /* Sanity checks */\n\n  if ((Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n      || (Bitmap_Head.biPlanes != 1)\n      || (ColormapSize > 256 || Bitmap_Head.biClrUsed > 256)) {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n   \n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\""Error reading BMP file header. Width is too large\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header. Width is too large\"");\n    goto cleanup;\n  }\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\""\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\"", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n  /* Get the Colormap */\n  ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp);\n  if (at_exception_got_fatal(&exp))\n    goto cleanup;\n\n#ifdef DEBUG\n  printf(\""Colormap read\\n\"");\n#endif\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, Bitmap_Head.biWidth, Bitmap_Head.biHeight, ColorMap, Bitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes, Grey);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}""}]","{""code"": 1, ""value"": 2}","[{""source"": ""code_info(file:input-bmp.c, lines:1-182)"", ""result"": ""/* input-bmp.c:\treads any bitmap I could get for testing\n\n   Copyright (C) 1999, 2000, 2001 Martin Weber.\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public License\n   as published by the Free Software Foundation; either version 2.1 of\n   the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n   USA. */\n\n#ifdef HAVE_CONFIG_H\n#include \""config.h\""\n#endif /* Def: HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \""types.h\""\n#include \""bitmap.h\""\n#include \""logreport.h\""\n#include \""xstd.h\""\n#include \""input-bmp.h\""\n\n#define BitSet(byte, bit)  (((byte) & (bit)) == (bit))\n\n#define ReadOK(file,buffer,len)  (fread(buffer, len, 1, file) != 0)\n\nstruct Bitmap_File_Head_Struct {\n  char zzMagic[2];              /* 00 \""BM\"" */\n  unsigned long bfSize;         /* 02 */\n  unsigned short zzHotX;        /* 06 */\n  unsigned short zzHotY;        /* 08 */\n  unsigned long bfOffs;         /* 0A */\n  unsigned long biSize;         /* 0E */\n} Bitmap_File_Head;\n\nstruct Bitmap_Head_Struct {\n  unsigned long biWidth;        /* 12 */\n  unsigned long biHeight;       /* 16 */\n  unsigned short biPlanes;      /* 1A */\n  unsigned short biBitCnt;      /* 1C */\n  unsigned long biCompr;        /* 1E */\n  unsigned long biSizeIm;       /* 22 */\n  unsigned long biXPels;        /* 26 */\n  unsigned long biYPels;        /* 2A */\n  unsigned long biClrUsed;      /* 2E */\n  unsigned long biClrImp;       /* 32 */\n  /* 36 */\n} Bitmap_Head;\n\nstatic long ToL(unsigned char *);\nstatic short ToS(unsigned char *);\nstatic int ReadColorMap(FILE *, unsigned char[256][3], int, int, int *, at_exception_type *);\nstatic unsigned char *ReadImage(FILE *, int, int, unsigned char[256][3], int, int, int, int);\n\nat_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps, Grey;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n\n  fd = fopen(filename, \""rb\"");\n\n  if (!fd) {\n    LOG(\""Can't open \\\""%s\\\""\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: cannot open input file\"");\n    return image;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, buffer, 18) || (strncmp((const char *)buffer, \""BM\"", 2))) {\n    LOG(\""Not a valid BMP file %s\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: invalid input file\"");\n    goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x02]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x06]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x08]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x0a]);\n  Bitmap_File_Head.biSize = ToL(&buffer[0x0e]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 4;\n  } else if (Bitmap_File_Head.biSize >= 40 && Bitmap_File_Head.biSize <= 64) {  /* Probably OS/2 2.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 3;\n  } else {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    Bitmap_Head.biClrUsed = ColormapSize;\n\n  /* Sanity checks */\n\n  if ((Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n      || (Bitmap_Head.biPlanes != 1)\n      || (ColormapSize > 256 || Bitmap_Head.biClrUsed > 256)) {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n""}, {""source"": ""value_info(file:input-bmp.c, value:Bitmap_Head.biWidth)"", ""result"": {""value_trace"": [{""full_code"": ""Bitmap_Head.biWidth = ToS(&buffer[0x00])"", ""line"": 109, ""func_name"": ""input_bmp_reader""}, {""full_code"": ""Bitmap_Head.biWidth = ToL(&buffer[0x00])"", ""line"": 125, ""func_name"": ""input_bmp_reader""}, {""full_code"": ""Bitmap_Head.biWidth = ToL(&buffer[0x00])"", ""line"": 144, ""func_name"": ""input_bmp_reader""}], ""struct_var"": ""Bitmap_Head"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:input-bmp.c, value:Bitmap_Head.biBitCnt)"", ""result"": {""value_trace"": [{""full_code"": ""Bitmap_Head.biBitCnt = ToS(&buffer[0x06])"", ""line"": 112, ""func_name"": ""input_bmp_reader""}, {""full_code"": ""Bitmap_Head.biBitCnt = ToS(&buffer[0x0A])"", ""line"": 128, ""func_name"": ""input_bmp_reader""}, {""full_code"": ""Bitmap_Head.biBitCnt = ToS(&buffer[0x0A])"", ""line"": 147, ""func_name"": ""input_bmp_reader""}], ""struct_var"": ""Bitmap_Head"", ""struct_type"": null, ""struct_definition"": null}}]","The vulnerability arises from unchecked multiplication of user-controlled `biWidth` (src/input-bmp.c:109, 125, 144) and `biBitCnt` (src/input-bmp.c:112, 128, 147) read from a BMP file header via `fread`. These values are derived from `fopen(filename, ""rb"")` (src/input-bmp.c:43), making them attacker-controlled. The unchecked product is used in `rowbytes = ((biWidth * biBitCnt - 1) / 32) * 4 + 4` (src/input-bmp.c:183), leading to integer overflow and unsafe memory allocation. The patch (src/input-bmp.c:183) adds an overflow check via division validation.",0.95,./github/other_context/CVE-2019-19004
62,CVE-2019-20805,CWE-190,c_cpp,p_lx_elf.cpp in UPX before 3.96 has an integer overflow during unpacking via crafted values in a PT_DYNAMIC segment.,https://github.com/upx/upx/commit/8be9da8280dfa69d5df4417d4d81bda1cab78010,"Avoid bogus values in PT_DYNAMIC segment.\n\nDetect duplicate DT_*.\nDetect out-of-bounds hashtab and gashtab.\nDetect missing DT_REL, DT_RELA.\nDetect out-of-bounds d_val.\nhttps://github.com/upx/upx/issues/317\n	modified:   p_lx_elf.cpp",6,"[{""func_name"": ""PackLinuxElf64::calls_crt1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \""__libc_start_main\"")  // glibc\n        ||  0==strcmp(symnam, \""__libc_init\"")  // Android\n        ||  0==strcmp(symnam, \""__uClibc_main\"")\n        ||  0==strcmp(symnam, \""__uClibc_start_main\""))\n            return true;\n    }\n    return false;\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf64::invert_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)\n{\n    if (dt_table[Elf64_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf64_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 1+ 0;\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        upx_uint64_t const d_tag = get_te64(&dynp->d_tag);\n        if (d_tag>>32) { // outrageous\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad Elf64_Dyn[%d].d_tag %#lx\"", -1+ ndx, (long unsigned)d_tag);\n            throwCantPack(msg);\n        }\n        if (d_tag < DT_NUM) {\n            dt_table[d_tag] = ndx;\n        }\n        if (Elf64_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;\n    else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te64(&dynp0[-1+ z_str].d_val);\n        if ((u64_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad DT_STRSZ %#x\"", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    // DT_SYMTAB has no designated length.\n    // End it when next area else starts; often DT_STRTAB.  (FIXME)\n    unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)\n            : get_te64(&dynp0[-1+ z_sym].d_val);\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_HASH nbucket=%#x  len=%#x\"",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(upx_uint64_t) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)  // FIXME: weak\n        // FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*n_bucket  // hasharr\n            ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx\"",\n                n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh));\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \""bad .e_shstrndx %d >= .e_shnum %d\"", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf32::calls_crt1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \""__libc_start_main\"")  // glibc\n        ||  0==strcmp(symnam, \""__libc_init\"")  // Android\n        ||  0==strcmp(symnam, \""__uClibc_main\"")\n        ||  0==strcmp(symnam, \""__uClibc_start_main\""))\n            return true;\n    }\n    return false;\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf32::elf_find_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void const *\nPackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf64::elf_find_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void const *\nPackLinuxElf64::elf_find_dynamic(unsigned int key) const\n{\n    Elf64_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {\n        upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));\n        if (t) {\n            return &((unsigned char const *)file_image)[(size_t)t];\n        }\n        break;\n    }\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf32::invert_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)\n{\n    if (dt_table[Elf32_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf32_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 1+ 0;\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        unsigned const d_tag = get_te32(&dynp->d_tag);\n        if (d_tag < DT_NUM) {\n            dt_table[d_tag] = ndx;\n        }\n        if (Elf32_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;\n    else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te32(&dynp0[-1+ z_str].d_val);\n        if ((u32_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad DT_STRSZ %#x\"", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)\n            : get_te32(&dynp0[-1+ z_sym].d_val);\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_HASH nbucket=%#x  len=%#x\"",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(unsigned) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)  // FIXME: weak\n        // FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*n_bucket  // hasharr\n            ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x\"",\n                n_bucket, n_bitmask, v_sym - v_gsh);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \""bad .e_shstrndx %d >= .e_shnum %d\"", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}"", ""target"": 0}]","[{""func_name"": ""PackLinuxElf64::calls_crt1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr || !rela) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \""__libc_start_main\"")  // glibc\n        ||  0==strcmp(symnam, \""__libc_init\"")  // Android\n        ||  0==strcmp(symnam, \""__uClibc_main\"")\n        ||  0==strcmp(symnam, \""__uClibc_start_main\""))\n            return true;\n    }\n    return false;\n}""}, {""func_name"": ""PackLinuxElf64::invert_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)\n{\n    if (dt_table[Elf64_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf64_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 1+ 0;\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        upx_uint64_t const d_tag = get_te64(&dynp->d_tag);\n        if (d_tag>>32) { // outrageous\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad Elf64_Dyn[%d].d_tag %#lx\"", -1+ ndx, (long unsigned)d_tag);\n            throwCantPack(msg);\n        }\n        if (d_tag < DT_NUM) {\n            if (dt_table[d_tag]\n            &&    get_te64(&dynp->d_val)\n               != get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {\n                char msg[50]; snprintf(msg, sizeof(msg),\n                    \""duplicate DT_%#x: [%#x] [%#x]\"",\n                    (unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);\n                throwCantPack(msg);\n            }\n            dt_table[d_tag] = ndx;\n        }\n        if (Elf64_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;\n    else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te64(&dynp0[-1+ z_str].d_val);\n        if ((u64_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad DT_STRSZ %#x\"", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    // DT_SYMTAB has no designated length.\n    // End it when next area else starts; often DT_STRTAB.  (FIXME)\n    unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)\n            : get_te64(&dynp0[-1+ z_sym].d_val);\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_HASH %#x\"", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_HASH nbucket=%#x  len=%#x\"",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        if (!gashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_GNU_HASH %#x\"", v_gsh);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(upx_uint64_t) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)  // FIXME: weak\n        // FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*n_bucket  // hasharr\n            ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx\"",\n                n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh));\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \""bad .e_shstrndx %d >= .e_shnum %d\"", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}""}, {""func_name"": ""PackLinuxElf32::calls_crt1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr || !rel) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \""__libc_start_main\"")  // glibc\n        ||  0==strcmp(symnam, \""__libc_init\"")  // Android\n        ||  0==strcmp(symnam, \""__uClibc_main\"")\n        ||  0==strcmp(symnam, \""__uClibc_start_main\""))\n            return true;\n    }\n    return false;\n}""}, {""func_name"": ""PackLinuxElf32::elf_find_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void const *\nPackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t && t < file_size) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}""}, {""func_name"": ""PackLinuxElf64::elf_find_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void const *\nPackLinuxElf64::elf_find_dynamic(unsigned int key) const\n{\n    Elf64_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {\n        upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));\n        if (t && t < (upx_uint64_t)file_size) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}""}, {""func_name"": ""PackLinuxElf32::invert_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)\n{\n    if (dt_table[Elf32_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf32_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 1+ 0;\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        unsigned const d_tag = get_te32(&dynp->d_tag);\n        if (d_tag < DT_NUM) {\n            if (dt_table[d_tag]\n            &&    get_te32(&dynp->d_val)\n               != get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) {\n                char msg[50]; snprintf(msg, sizeof(msg),\n                    \""duplicate DT_%#x: [%#x] [%#x]\"",\n                    d_tag, -1+ dt_table[d_tag], -1+ ndx);\n                throwCantPack(msg);\n            }\n            dt_table[d_tag] = ndx;\n        }\n        if (Elf32_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;\n    else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te32(&dynp0[-1+ z_str].d_val);\n        if ((u32_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad DT_STRSZ %#x\"", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)\n            : get_te32(&dynp0[-1+ z_sym].d_val);\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_HASH %#x\"", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_HASH nbucket=%#x  len=%#x\"",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        if (!gashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_GNU_HASH %#x\"", v_gsh);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(unsigned) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)  // FIXME: weak\n        // FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*n_bucket  // hasharr\n            ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x\"",\n                n_bucket, n_bitmask, v_sym - v_gsh);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \""bad .e_shstrndx %d >= .e_shnum %d\"", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}""}]","{""function"": 2, ""caller"": 1}","[{""source"": ""func_info(func:get_te64)"", ""result"": [{""code"": ""upx_uint64_t get_te64(const void *p) const { return bele->get64(p); }"", ""start_line"": 112, ""end_line"": 112, ""full_name"": ""ElfLinker.get_te64:upx_uint64_t(void*)<const>"", ""file_path"": ""src/linker.h""}, {""code"": ""upx_uint64_t get_te64(const void *p)   const { return bele->get64(p); }"", ""start_line"": 297, ""end_line"": 297, ""full_name"": ""Packer.get_te64:upx_uint64_t(void*)<const>"", ""file_path"": ""src/packer.h""}]}, {""source"": ""func_info(file:p_lx_elf.cpp, func:elf_get_offset_from_address)"", ""result"": [{""code"": ""unsigned\nPackLinuxElf32::elf_get_offset_from_address(unsigned addr) const\n{\n    Elf32_Phdr const *phdr = phdri;\n    int j = e_phnum;\n    for (; --j>=0; ++phdr) if (PT_LOAD32 == get_te32(&phdr->p_type)) {\n        unsigned const t = addr - get_te32(&phdr->p_vaddr);\n        if (t < get_te32(&phdr->p_filesz)) {\n            unsigned const p_offset = get_te32(&phdr->p_offset);\n            if ((u32_t)file_size <= p_offset) { // FIXME: weak\n                char msg[40]; snprintf(msg, sizeof(msg),\n                    \""bad Elf32_Phdr[%d].p_offset %x\"",\n                    -1+ e_phnum - j, p_offset);\n                throwCantPack(msg);\n            }\n            return t + p_offset;\n        }\n    }\n    return 0;\n}"", ""start_line"": 4823, ""end_line"": 4842, ""full_name"": ""PackLinuxElf32.elf_get_offset_from_address:unsigned int(unsigned)<const>"", ""file_path"": ""src/p_lx_elf.cpp""}, {""code"": ""upx_uint64_t\nPackLinuxElf64::elf_get_offset_from_address(upx_uint64_t addr) const\n{\n    Elf64_Phdr const *phdr = phdri;\n    int j = e_phnum;\n    for (; --j>=0; ++phdr) if (PT_LOAD64 == get_te32(&phdr->p_type)) {\n        upx_uint64_t const t = addr - get_te64(&phdr->p_vaddr);\n        if (t < get_te64(&phdr->p_filesz)) {\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            if ((u64_t)file_size <= p_offset) { // FIXME: weak\n                char msg[40]; snprintf(msg, sizeof(msg),\n                    \""bad Elf64_Phdr[%d].p_offset %#lx\"",\n                    -1+ e_phnum - j, (long unsigned)p_offset);\n                throwCantPack(msg);\n            }\n            return t + p_offset;\n        }\n    }\n    return 0;\n}"", ""start_line"": 4924, ""end_line"": 4943, ""full_name"": ""PackLinuxElf64.elf_get_offset_from_address:upx_uint64_t(upx_uint64_t)<const>"", ""file_path"": ""src/p_lx_elf.cpp""}]}, {""source"": ""caller_info(file:p_lx_elf.cpp, func:elf_find_dynamic)"", ""result"": [{""call_line"": 308, ""call_code"": ""elf_find_dynamic(Elf32_Dyn::DT_STRTAB)"", ""caller_code"": ""void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\""0==e_phnum\"");\n    e_phoff = get_te32(&ehdri.e_phoff);\n    unsigned const last_Phdr = e_phoff + e_phnum * sizeof(Elf32_Phdr);\n    if (last_Phdr < e_phoff || (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    e_shoff = get_te32(&ehdri.e_shoff);\n    unsigned const last_Shdr = e_shoff + e_shnum * sizeof(Elf32_Shdr);\n    if (last_Shdr < e_shoff || (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack(\""bad e_shoff\"");\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)(e_shoff + file_image);  // do not free() !!\n        if (opt->cmd != CMD_COMPRESS) {\n            shdri = NULL;\n        }\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack(\""bad dynsym->sh_link\"");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n        }\n        else if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            check_pt_load(phdr);\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}\n"", ""caller_start"": 240, ""file_path"": ""src/p_lx_elf.cpp""}, {""call_line"": 309, ""call_code"": ""elf_find_dynamic(Elf32_Dyn::DT_SYMTAB)"", ""caller_code"": ""void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\""0==e_phnum\"");\n    e_phoff = get_te32(&ehdri.e_phoff);\n    unsigned const last_Phdr = e_phoff + e_phnum * sizeof(Elf32_Phdr);\n    if (last_Phdr < e_phoff || (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    e_shoff = get_te32(&ehdri.e_shoff);\n    unsigned const last_Shdr = e_shoff + e_shnum * sizeof(Elf32_Shdr);\n    if (last_Shdr < e_shoff || (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack(\""bad e_shoff\"");\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)(e_shoff + file_image);  // do not free() !!\n        if (opt->cmd != CMD_COMPRESS) {\n            shdri = NULL;\n        }\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack(\""bad dynsym->sh_link\"");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n        }\n        else if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            check_pt_load(phdr);\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}\n"", ""caller_start"": 240, ""file_path"": ""src/p_lx_elf.cpp""}, {""call_line"": 310, ""call_code"": ""elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH)"", ""caller_code"": ""void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\""0==e_phnum\"");\n    e_phoff = get_te32(&ehdri.e_phoff);\n    unsigned const last_Phdr = e_phoff + e_phnum * sizeof(Elf32_Phdr);\n    if (last_Phdr < e_phoff || (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    e_shoff = get_te32(&ehdri.e_shoff);\n    unsigned const last_Shdr = e_shoff + e_shnum * sizeof(Elf32_Shdr);\n    if (last_Shdr < e_shoff || (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack(\""bad e_shoff\"");\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)(e_shoff + file_image);  // do not free() !!\n        if (opt->cmd != CMD_COMPRESS) {\n            shdri = NULL;\n        }\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack(\""bad dynsym->sh_link\"");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n        }\n        else if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            check_pt_load(phdr);\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}\n"", ""caller_start"": 240, ""file_path"": ""src/p_lx_elf.cpp""}, {""call_line"": 311, ""call_code"": ""elf_find_dynamic(Elf32_Dyn::DT_HASH)"", ""caller_code"": ""void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\""0==e_phnum\"");\n    e_phoff = get_te32(&ehdri.e_phoff);\n    unsigned const last_Phdr = e_phoff + e_phnum * sizeof(Elf32_Phdr);\n    if (last_Phdr < e_phoff || (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    e_shoff = get_te32(&ehdri.e_shoff);\n    unsigned const last_Shdr = e_shoff + e_shnum * sizeof(Elf32_Shdr);\n    if (last_Shdr < e_shoff || (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack(\""bad e_shoff\"");\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)(e_shoff + file_image);  // do not free() !!\n        if (opt->cmd != CMD_COMPRESS) {\n            shdri = NULL;\n        }\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack(\""bad dynsym->sh_link\"");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n        }\n        else if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            check_pt_load(phdr);\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}\n"", ""caller_start"": 240, ""file_path"": ""src/p_lx_elf.cpp""}]}]","In src/p_lx_elf.cpp, 'elf_find_dynamic' (lines 4902-4904 for 64-bit) calculates an offset from 'd_val' without validating it against 'file_size', allowing out-of-bounds access. Prior to the patch, 'elf_get_offset_from_address' (lines 4823-4842 for 32-bit, 4924-4943 for 64-bit) could return invalid offsets, which were added to 'file_image' without bounds checks. This allowed crafted PT_DYNAMIC entries to trigger integer overflow and out-of-bounds memory access during unpacking. Callers like 'PackLinuxElf32::PackLinuxElf32help1' (lines 308-311) use these pointers for dynamic section processing, leading to potential code execution or crashes.",0.95,./github/other_context/CVE-2019-20805
63,CVE-2019-9278,"CWE-190, CWE-787",c_cpp,"In libexif, there is a possible out of bounds write due to an integer overflow. This could lead to remote escalation of privilege in the media content provider with no additional execution privileges needed. User interaction is needed for exploitation. Product: AndroidVersions: Android-10Android ID: A-112537774",https://github.com/libexif/libexif/commit/75aa73267fdb1e0ebfbc00369e7312bac43d0566,"fix CVE-2019-9278\n\navoid the use of unsafe integer overflow checking constructs (unsigned integer operations cannot overflow, so ""u1 + u2 > u1"" can be optimized away)\n\ncheck for the actual sizes, which should also handle the overflows\ndocument other places google patched, but do not seem relevant due to other restrictions\n\nfixes https://github.com/libexif/libexif/issues/26",3,"[{""func_name"": ""exif_data_load_data"", ""file_path"": ""libexif/exif-data.c"", ""func_code"": ""void\nexif_data_load_data (ExifData *data, const unsigned char *d_orig,\n\t\t     unsigned int ds)\n{\n\tunsigned int l;\n\tExifLong offset;\n\tExifShort n;\n\tconst unsigned char *d = d_orig;\n\tunsigned int len, fullds;\n\n\tif (!data || !data->priv || !d || !ds)\n\t\treturn;\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t  \""Parsing %i byte(s) EXIF data...\\n\"", ds);\n\n\t/*\n\t * It can be that the data starts with the EXIF header. If it does\n\t * not, search the EXIF marker.\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (!memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t  \""Found EXIF header at start.\"");\n\t} else {\n\t\twhile (ds >= 3) {\n\t\t\twhile (ds && (d[0] == 0xff)) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_SOI */\n\t\t\tif (ds && d[0] == JPEG_MARKER_SOI) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_APP1 */\n\t\t\tif (ds && d[0] == JPEG_MARKER_APP1)\n\t\t\t\tbreak;\n\n\t\t\t/* Skip irrelevant APP markers. The branch for APP1 must come before this,\n\t\t\t   otherwise this code block will cause APP1 to be skipped. This code path\n\t\t\t   is only relevant for files that are nonconformant to the EXIF\n\t\t\t   specification. For conformant files, the APP1 code path above will be\n\t\t\t   taken. */\n\t\t\tif (ds >= 3 && d[0] >= 0xe0 && d[0] <= 0xef) {  /* JPEG_MARKER_APPn */\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tl = (d[0] << 8) | d[1];\n\t\t\t\tif (l > ds)\n\t\t\t\t\treturn;\n\t\t\t\td += l;\n\t\t\t\tds -= l;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Unknown marker or data. Give up. */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \""ExifData\"", _(\""EXIF marker not found.\""));\n\t\t\treturn;\n\t\t}\n\t\tif (ds < 3) {\n\t\t\tLOG_TOO_SMALL;\n\t\t\treturn;\n\t\t}\n\t\td++;\n\t\tds--;\n\t\tlen = (d[0] << 8) | d[1];\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t  \""We have to deal with %i byte(s) of EXIF data.\"",\n\t\t\t  len);\n\t\td += 2;\n\t\tds -= 2;\n\t}\n\n\t/*\n\t * Verify the exif header\n\t * (offset 2, length 6).\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \""ExifData\"", _(\""EXIF header not found.\""));\n\t\treturn;\n\t}\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t  \""Found EXIF header.\"");\n\n\t/* Sanity check the data length */\n\tif (ds < 14)\n\t\treturn;\n\n\t/* The JPEG APP1 section can be no longer than 64 KiB (including a\n\t   16-bit length), so cap the data length to protect against overflow\n\t   in future offset calculations */\n\tfullds = ds;\n\tif (ds > 0xfffe)\n\t\tds = 0xfffe;\n\n\t/* Byte order (offset 6, length 2) */\n\tif (!memcmp (d + 6, \""II\"", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_INTEL;\n\telse if (!memcmp (d + 6, \""MM\"", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_MOTOROLA;\n\telse {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \""ExifData\"", _(\""Unknown encoding.\""));\n\t\treturn;\n\t}\n\n\t/* Fixed value */\n\tif (exif_get_short (d + 8, data->priv->order) != 0x002a)\n\t\treturn;\n\n\t/* IFD 0 offset */\n\toffset = exif_get_long (d + 10, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"", \n\t\t  \""IFD 0 at %i.\"", (int) offset);\n\n\t/* Sanity check the offset, being careful about overflow */\n\tif (offset > ds || offset + 6 + 2 > ds)\n\t\treturn;\n\n\t/* Parse the actual exif data (usually offset 14 from start) */\n\texif_data_load_data_content (data, EXIF_IFD_0, d + 6, ds - 6, offset, 0);\n\n\t/* IFD 1 offset */\n\tn = exif_get_short (d + 6 + offset, data->priv->order);\n\tif (offset + 6 + 2 + 12 * n + 4 > ds)\n\t\treturn;\n\n\toffset = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);\n\tif (offset) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t  \""IFD 1 at %i.\"", (int) offset);\n\n\t\t/* Sanity check. */\n\t\tif (offset > ds || offset + 6 > ds) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \""ExifData\"", \""Bogus offset of IFD1.\"");\n\t\t} else {\n\t\t   exif_data_load_data_content (data, EXIF_IFD_1, d + 6, ds - 6, offset, 0);\n\t\t}\n\t}\n\n\t/*\n\t * If we got an EXIF_TAG_MAKER_NOTE, try to interpret it. Some\n\t * cameras use pointers in the maker note tag that point to the\n\t * space between IFDs. Here is the only place where we have access\n\t * to that data.\n\t */\n\tinterpret_maker_note(data, d, fullds);\n\n\t/* Fixup tags if requested */\n\tif (data->priv->options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION)\n\t\texif_data_fix (data);\n}"", ""target"": 0}, {""func_name"": ""exif_data_load_data_thumbnail"", ""file_path"": ""libexif/exif-data.c"", ""func_code"": ""static void\nexif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\t/* Sanity checks */\n\tif ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t  \""Bogus thumbnail offset (%u) or size (%u).\"",\n\t\t\t  o, s);\n\t\treturn;\n\t}\n\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \""ExifData\"", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}"", ""target"": 0}, {""func_name"": ""exif_data_load_data_entry"", ""file_path"": ""libexif/exif-data.c"", ""func_code"": ""static int\nexif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\n\t/* FIXME: should use exif_tag_get_name_in_ifd here but entry->parent \n\t * has not been set yet\n\t */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t  \""Loading entry 0x%x ('%s')...\"", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\n\t/* {0,1,2,4,8} x { 0x00000000 .. 0xffffffff } \n\t *   -> { 0x000000000 .. 0x7fffffff8 } */\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t */\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t  \""Tag data past end of buffer (%u > %u)\"", doff+s, size);\t\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \""ExifData\"", s);\n\t\treturn 0;\n\t}\n\n\t/* If this is the MakerNote, remember the offset */\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t\t  \""MakerNote found with empty data\"");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t\t       \""MakerNote found (%02x %02x %02x %02x \""\n\t\t\t\t\t       \""%02x %02x %02x...).\"",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}"", ""target"": 0}]","[{""func_name"": ""exif_data_load_data"", ""file_path"": ""libexif/exif-data.c"", ""func_code"": ""void\nexif_data_load_data (ExifData *data, const unsigned char *d_orig,\n\t\t     unsigned int ds)\n{\n\tunsigned int l;\n\tExifLong offset;\n\tExifShort n;\n\tconst unsigned char *d = d_orig;\n\tunsigned int len, fullds;\n\n\tif (!data || !data->priv || !d || !ds)\n\t\treturn;\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t  \""Parsing %i byte(s) EXIF data...\\n\"", ds);\n\n\t/*\n\t * It can be that the data starts with the EXIF header. If it does\n\t * not, search the EXIF marker.\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (!memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t  \""Found EXIF header at start.\"");\n\t} else {\n\t\twhile (ds >= 3) {\n\t\t\twhile (ds && (d[0] == 0xff)) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_SOI */\n\t\t\tif (ds && d[0] == JPEG_MARKER_SOI) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_APP1 */\n\t\t\tif (ds && d[0] == JPEG_MARKER_APP1)\n\t\t\t\tbreak;\n\n\t\t\t/* Skip irrelevant APP markers. The branch for APP1 must come before this,\n\t\t\t   otherwise this code block will cause APP1 to be skipped. This code path\n\t\t\t   is only relevant for files that are nonconformant to the EXIF\n\t\t\t   specification. For conformant files, the APP1 code path above will be\n\t\t\t   taken. */\n\t\t\tif (ds >= 3 && d[0] >= 0xe0 && d[0] <= 0xef) {  /* JPEG_MARKER_APPn */\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tl = (d[0] << 8) | d[1];\n\t\t\t\tif (l > ds)\n\t\t\t\t\treturn;\n\t\t\t\td += l;\n\t\t\t\tds -= l;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Unknown marker or data. Give up. */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \""ExifData\"", _(\""EXIF marker not found.\""));\n\t\t\treturn;\n\t\t}\n\t\tif (ds < 3) {\n\t\t\tLOG_TOO_SMALL;\n\t\t\treturn;\n\t\t}\n\t\td++;\n\t\tds--;\n\t\tlen = (d[0] << 8) | d[1];\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t  \""We have to deal with %i byte(s) of EXIF data.\"",\n\t\t\t  len);\n\t\td += 2;\n\t\tds -= 2;\n\t}\n\n\t/*\n\t * Verify the exif header\n\t * (offset 2, length 6).\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \""ExifData\"", _(\""EXIF header not found.\""));\n\t\treturn;\n\t}\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t  \""Found EXIF header.\"");\n\n\t/* Sanity check the data length */\n\tif (ds < 14)\n\t\treturn;\n\n\t/* The JPEG APP1 section can be no longer than 64 KiB (including a\n\t   16-bit length), so cap the data length to protect against overflow\n\t   in future offset calculations */\n\tfullds = ds;\n\tif (ds > 0xfffe)\n\t\tds = 0xfffe;\n\n\t/* Byte order (offset 6, length 2) */\n\tif (!memcmp (d + 6, \""II\"", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_INTEL;\n\telse if (!memcmp (d + 6, \""MM\"", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_MOTOROLA;\n\telse {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \""ExifData\"", _(\""Unknown encoding.\""));\n\t\treturn;\n\t}\n\n\t/* Fixed value */\n\tif (exif_get_short (d + 8, data->priv->order) != 0x002a)\n\t\treturn;\n\n\t/* IFD 0 offset */\n\toffset = exif_get_long (d + 10, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"", \n\t\t  \""IFD 0 at %i.\"", (int) offset);\n\n\t/* ds is restricted to 16 bit above, so offset is restricted too, and offset+8 should not overflow. */\n\tif (offset > ds || offset + 6 + 2 > ds)\n\t\treturn;\n\n\t/* Parse the actual exif data (usually offset 14 from start) */\n\texif_data_load_data_content (data, EXIF_IFD_0, d + 6, ds - 6, offset, 0);\n\n\t/* IFD 1 offset */\n\tn = exif_get_short (d + 6 + offset, data->priv->order);\n\t/* offset < 2<<16, n is 16 bit at most, so this op will not overflow */\n\tif (offset + 6 + 2 + 12 * n + 4 > ds)\n\t\treturn;\n\n\toffset = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);\n\tif (offset) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t  \""IFD 1 at %i.\"", (int) offset);\n\n\t\t/* Sanity check. ds is ensured to be above 6 above, offset is 16bit */\n\t\tif (offset > ds - 6) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \""ExifData\"", \""Bogus offset of IFD1.\"");\n\t\t} else {\n\t\t   exif_data_load_data_content (data, EXIF_IFD_1, d + 6, ds - 6, offset, 0);\n\t\t}\n\t}\n\n\t/*\n\t * If we got an EXIF_TAG_MAKER_NOTE, try to interpret it. Some\n\t * cameras use pointers in the maker note tag that point to the\n\t * space between IFDs. Here is the only place where we have access\n\t * to that data.\n\t */\n\tinterpret_maker_note(data, d, fullds);\n\n\t/* Fixup tags if requested */\n\tif (data->priv->options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION)\n\t\texif_data_fix (data);\n}""}, {""func_name"": ""exif_data_load_data_thumbnail"", ""file_path"": ""libexif/exif-data.c"", ""func_code"": ""static void\nexif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\t/* Sanity checks */\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"", \""Bogus thumbnail offset (%u).\"", o);\n\t\treturn;\n\t}\n\tif (s > ds - o) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"", \""Bogus thumbnail size (%u), max would be %u.\"", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \""ExifData\"", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}""}, {""func_name"": ""exif_data_load_data_entry"", ""file_path"": ""libexif/exif-data.c"", ""func_code"": ""static int\nexif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\n\t/* FIXME: should use exif_tag_get_name_in_ifd here but entry->parent \n\t * has not been set yet\n\t */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t  \""Loading entry 0x%x ('%s')...\"", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\n\t/* {0,1,2,4,8} x { 0x00000000 .. 0xffffffff } \n\t *   -> { 0x000000000 .. 0x7fffffff8 } */\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t */\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif (doff >= size) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t  \""Tag starts past end of buffer (%u > %u)\"", doff, size);\n\t\treturn 0;\n\t}\n\n\tif (s > size - doff) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t  \""Tag data goes past end of buffer (%u > %u)\"", doff+s, size);\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \""ExifData\"", s);\n\t\treturn 0;\n\t}\n\n\t/* If this is the MakerNote, remember the offset */\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t\t  \""MakerNote found with empty data\"");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t\t       \""MakerNote found (%02x %02x %02x %02x \""\n\t\t\t\t\t       \""%02x %02x %02x...).\"",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}""}]","{""caller"": 3, ""value"": 4}","[{""source"": ""caller_info(file:exif-data.c, func:exif_data_load_data)"", ""result"": [{""call_line"": 156, ""call_code"": ""exif_data_load_data (edata, data, size)"", ""caller_code"": ""ExifData *\nexif_data_new_from_data (const unsigned char *data, unsigned int size)\n{\n\tExifData *edata;\n\n\tedata = exif_data_new ();\n\texif_data_load_data (edata, data, size);\n\treturn (edata);\n}"", ""caller_start"": 150, ""file_path"": ""libexif/exif-data.c""}, {""call_line"": 401, ""call_code"": ""exif_data_load_data (ed, loader->buf, loader->bytes_read)"", ""caller_code"": ""ExifData *\nexif_loader_get_data (ExifLoader *loader)\n{\n\tExifData *ed;\n\n\tif (!loader || (loader->data_format == EL_DATA_FORMAT_UNKNOWN) ||\n\t    !loader->bytes_read)\n\t\treturn NULL;\n\n\ted = exif_data_new_mem (loader->mem);\n\texif_data_log (ed, loader->log);\n\texif_data_load_data (ed, loader->buf, loader->bytes_read);\n\n\treturn ed;\n}"", ""caller_start"": 390, ""file_path"": ""libexif/exif-loader.c""}]}, {""source"": ""caller_info(file:exif-data.c, func:exif_data_load_data_thumbnail)"", ""result"": [{""call_line"": 467, ""call_code"": ""exif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length)"", ""caller_code"": ""static void\nexif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_cost)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\tExifTag tag;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/* check for valid ExifIfd enum range */\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_cost > 170) {\n\t\t/*\n\t\t * recursion_cost is a logarithmic-scale indicator of how expensive this\n\t\t * recursive call might end up being. It is an indicator of the depth of\n\t\t * recursion as well as the potential for worst-case future recursive\n\t\t * calls. Since it's difficult to tell ahead of time how often recursion\n\t\t * will occur, this assumes the worst by assuming every tag could end up\n\t\t * causing recursion.\n\t\t * The value of 170 was chosen to limit typical EXIF structures to a\n\t\t * recursive depth of about 6, but pathological ones (those with very\n\t\t * many tags) to only 2.\n\t\t */\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \""ExifData\"",\n\t\t\t  \""Deep/expensive recursion detected!\"");\n\t\treturn;\n\t}\n\n\t/* Read the number of entries */\n\tif ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \""ExifData\"",\n\t\t\t  \""Tag data past end of buffer (%u > %u)\"", offset+2, ds);\n\t\treturn;\n\t}\n\tn = exif_get_short (d + offset, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t          \""Loading %hu entries...\"", n);\n\toffset += 2;\n\n\t/* Check if we have enough data. */\n\tif (offset + 12 * n > ds) {\n\t\tn = (ds - offset) / 12;\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t  \""Short data; only loading %hu entries...\"", n);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\n\t\ttag = exif_get_short (d + offset + 12 * i, data->priv->order);\n\t\tswitch (tag) {\n\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\to = exif_get_long (d + offset + 12 * i + 8,\n\t\t\t\t\t   data->priv->order);\n\t\t\t/* FIXME: IFD_POINTER tags aren't marked as being in a\n\t\t\t * specific IFD, so exif_tag_get_name_in_ifd won't work\n\t\t\t */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t  \""Sub-IFD entry 0x%x ('%s') at %u.\"", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\t\t\tthumbnail_length = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t/*\n\t\t\t * If we don't know the tag, don't fail. It could be that new \n\t\t\t * versions of the standard have defined additional tags. Note that\n\t\t\t * 0 is a valid tag in the GPS IFD.\n\t\t\t */\n\t\t\tif (!exif_tag_get_name_in_ifd (tag, ifd)) {\n\n\t\t\t\t/*\n\t\t\t\t * Special case: Tag and format 0. That's against specification\n\t\t\t\t * (at least up to 2.2). But Photoshop writes it anyways.\n\t\t\t\t */\n\t\t\t\tif (!memcmp (d + offset + 12 * i, \""\\0\\0\\0\\0\"", 4)) {\n\t\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t\t\t  \""Skipping empty entry at position %u in '%s'.\"", i, \n\t\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t\t  \""Unknown tag 0x%04x (entry %u in '%s'). Please report this tag \""\n\t\t\t\t\t  \""to <libexif-devel@lists.sourceforge.net>.\"", tag, i,\n\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\tif (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry = exif_entry_new_mem (data->priv->mem);\n\t\t\tif (!entry) {\n\t\t\t\t  exif_log (data->priv->log, EXIF_LOG_CODE_NO_MEMORY, \""ExifData\"",\n                                          \""Could not allocate memory\"");\n\t\t\t\t  return;\n\t\t\t}\n\t\t\tif (exif_data_load_data_entry (data, entry, d, ds,\n\t\t\t\t\t\t   offset + 12 * i))\n\t\t\t\texif_content_add_entry (data->ifd[ifd], entry);\n\t\t\texif_entry_unref (entry);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"", ""caller_start"": 378, ""file_path"": ""libexif/exif-data.c""}, {""call_line"": 474, ""call_code"": ""exif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length)"", ""caller_code"": ""static void\nexif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_cost)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\tExifTag tag;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/* check for valid ExifIfd enum range */\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_cost > 170) {\n\t\t/*\n\t\t * recursion_cost is a logarithmic-scale indicator of how expensive this\n\t\t * recursive call might end up being. It is an indicator of the depth of\n\t\t * recursion as well as the potential for worst-case future recursive\n\t\t * calls. Since it's difficult to tell ahead of time how often recursion\n\t\t * will occur, this assumes the worst by assuming every tag could end up\n\t\t * causing recursion.\n\t\t * The value of 170 was chosen to limit typical EXIF structures to a\n\t\t * recursive depth of about 6, but pathological ones (those with very\n\t\t * many tags) to only 2.\n\t\t */\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \""ExifData\"",\n\t\t\t  \""Deep/expensive recursion detected!\"");\n\t\treturn;\n\t}\n\n\t/* Read the number of entries */\n\tif ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \""ExifData\"",\n\t\t\t  \""Tag data past end of buffer (%u > %u)\"", offset+2, ds);\n\t\treturn;\n\t}\n\tn = exif_get_short (d + offset, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t          \""Loading %hu entries...\"", n);\n\toffset += 2;\n\n\t/* Check if we have enough data. */\n\tif (offset + 12 * n > ds) {\n\t\tn = (ds - offset) / 12;\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t  \""Short data; only loading %hu entries...\"", n);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\n\t\ttag = exif_get_short (d + offset + 12 * i, data->priv->order);\n\t\tswitch (tag) {\n\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\to = exif_get_long (d + offset + 12 * i + 8,\n\t\t\t\t\t   data->priv->order);\n\t\t\t/* FIXME: IFD_POINTER tags aren't marked as being in a\n\t\t\t * specific IFD, so exif_tag_get_name_in_ifd won't work\n\t\t\t */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t  \""Sub-IFD entry 0x%x ('%s') at %u.\"", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\t\t\tthumbnail_length = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t/*\n\t\t\t * If we don't know the tag, don't fail. It could be that new \n\t\t\t * versions of the standard have defined additional tags. Note that\n\t\t\t * 0 is a valid tag in the GPS IFD.\n\t\t\t */\n\t\t\tif (!exif_tag_get_name_in_ifd (tag, ifd)) {\n\n\t\t\t\t/*\n\t\t\t\t * Special case: Tag and format 0. That's against specification\n\t\t\t\t * (at least up to 2.2). But Photoshop writes it anyways.\n\t\t\t\t */\n\t\t\t\tif (!memcmp (d + offset + 12 * i, \""\\0\\0\\0\\0\"", 4)) {\n\t\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t\t\t  \""Skipping empty entry at position %u in '%s'.\"", i, \n\t\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t\t  \""Unknown tag 0x%04x (entry %u in '%s'). Please report this tag \""\n\t\t\t\t\t  \""to <libexif-devel@lists.sourceforge.net>.\"", tag, i,\n\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\tif (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry = exif_entry_new_mem (data->priv->mem);\n\t\t\tif (!entry) {\n\t\t\t\t  exif_log (data->priv->log, EXIF_LOG_CODE_NO_MEMORY, \""ExifData\"",\n                                          \""Could not allocate memory\"");\n\t\t\t\t  return;\n\t\t\t}\n\t\t\tif (exif_data_load_data_entry (data, entry, d, ds,\n\t\t\t\t\t\t   offset + 12 * i))\n\t\t\t\texif_content_add_entry (data->ifd[ifd], entry);\n\t\t\texif_entry_unref (entry);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"", ""caller_start"": 378, ""file_path"": ""libexif/exif-data.c""}]}, {""source"": ""value_info(file:exif-data.c, value:ds)"", ""result"": {""value_trace"": [{""full_code"": ""ds -= l"", ""line"": 879, ""func_name"": ""exif_data_load_data""}, {""full_code"": ""ds -= 2"", ""line"": 899, ""func_name"": ""exif_data_load_data""}, {""full_code"": ""ds = 0xfffe"", ""line"": 928, ""func_name"": ""exif_data_load_data""}], ""struct_var"": ""ds"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:exif-data.c, value:ds)"", ""result"": {""value_trace"": [{""full_code"": ""ds -= l"", ""line"": 879, ""func_name"": ""exif_data_load_data""}, {""full_code"": ""ds -= 2"", ""line"": 899, ""func_name"": ""exif_data_load_data""}, {""full_code"": ""ds = 0xfffe"", ""line"": 928, ""func_name"": ""exif_data_load_data""}], ""struct_var"": ""ds"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:exif-data.c, func:exif_data_load_data_entry)"", ""result"": [{""call_line"": 514, ""call_code"": ""exif_data_load_data_entry (data, entry, d, ds,\n\t\t\t\t\t\t   offset + 12 * i)"", ""caller_code"": ""static void\nexif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_cost)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\tExifTag tag;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/* check for valid ExifIfd enum range */\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_cost > 170) {\n\t\t/*\n\t\t * recursion_cost is a logarithmic-scale indicator of how expensive this\n\t\t * recursive call might end up being. It is an indicator of the depth of\n\t\t * recursion as well as the potential for worst-case future recursive\n\t\t * calls. Since it's difficult to tell ahead of time how often recursion\n\t\t * will occur, this assumes the worst by assuming every tag could end up\n\t\t * causing recursion.\n\t\t * The value of 170 was chosen to limit typical EXIF structures to a\n\t\t * recursive depth of about 6, but pathological ones (those with very\n\t\t * many tags) to only 2.\n\t\t */\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \""ExifData\"",\n\t\t\t  \""Deep/expensive recursion detected!\"");\n\t\treturn;\n\t}\n\n\t/* Read the number of entries */\n\tif ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \""ExifData\"",\n\t\t\t  \""Tag data past end of buffer (%u > %u)\"", offset+2, ds);\n\t\treturn;\n\t}\n\tn = exif_get_short (d + offset, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t          \""Loading %hu entries...\"", n);\n\toffset += 2;\n\n\t/* Check if we have enough data. */\n\tif (offset + 12 * n > ds) {\n\t\tn = (ds - offset) / 12;\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t  \""Short data; only loading %hu entries...\"", n);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\n\t\ttag = exif_get_short (d + offset + 12 * i, data->priv->order);\n\t\tswitch (tag) {\n\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\to = exif_get_long (d + offset + 12 * i + 8,\n\t\t\t\t\t   data->priv->order);\n\t\t\t/* FIXME: IFD_POINTER tags aren't marked as being in a\n\t\t\t * specific IFD, so exif_tag_get_name_in_ifd won't work\n\t\t\t */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t  \""Sub-IFD entry 0x%x ('%s') at %u.\"", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\t\t\tthumbnail_length = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t/*\n\t\t\t * If we don't know the tag, don't fail. It could be that new \n\t\t\t * versions of the standard have defined additional tags. Note that\n\t\t\t * 0 is a valid tag in the GPS IFD.\n\t\t\t */\n\t\t\tif (!exif_tag_get_name_in_ifd (tag, ifd)) {\n\n\t\t\t\t/*\n\t\t\t\t * Special case: Tag and format 0. That's against specification\n\t\t\t\t * (at least up to 2.2). But Photoshop writes it anyways.\n\t\t\t\t */\n\t\t\t\tif (!memcmp (d + offset + 12 * i, \""\\0\\0\\0\\0\"", 4)) {\n\t\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t\t\t  \""Skipping empty entry at position %u in '%s'.\"", i, \n\t\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \""ExifData\"",\n\t\t\t\t\t  \""Unknown tag 0x%04x (entry %u in '%s'). Please report this tag \""\n\t\t\t\t\t  \""to <libexif-devel@lists.sourceforge.net>.\"", tag, i,\n\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\tif (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry = exif_entry_new_mem (data->priv->mem);\n\t\t\tif (!entry) {\n\t\t\t\t  exif_log (data->priv->log, EXIF_LOG_CODE_NO_MEMORY, \""ExifData\"",\n                                          \""Could not allocate memory\"");\n\t\t\t\t  return;\n\t\t\t}\n\t\t\tif (exif_data_load_data_entry (data, entry, d, ds,\n\t\t\t\t\t\t   offset + 12 * i))\n\t\t\t\texif_content_add_entry (data->ifd[ifd], entry);\n\t\t\texif_entry_unref (entry);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"", ""caller_start"": 378, ""file_path"": ""libexif/exif-data.c""}]}, {""source"": ""value_info(file:exif-data.c, value:thumbnail_offset)"", ""result"": {""value_trace"": [{""full_code"": ""thumbnail_offset = 0"", ""line"": 383, ""func_name"": ""exif_data_load_data_content""}, {""full_code"": ""thumbnail_offset = o"", ""line"": 465, ""func_name"": ""exif_data_load_data_content""}], ""struct_var"": ""thumbnail_offset"", ""struct_type"": ""ExifLong"", ""struct_definition"": ""typedef uint32_t\tExifLong;""}}, {""source"": ""value_info(file:exif-data.c, value:thumbnail_length)"", ""result"": {""value_trace"": [{""full_code"": ""thumbnail_length = 0"", ""line"": 383, ""func_name"": ""exif_data_load_data_content""}, {""full_code"": ""thumbnail_length = o"", ""line"": 472, ""func_name"": ""exif_data_load_data_content""}], ""struct_var"": ""thumbnail_length"", ""struct_type"": ""ExifLong"", ""struct_definition"": ""typedef uint32_t\tExifLong;""}}]","libexif/exif-data.c:950 (exif_data_load_data: replaced 'offset + 6 + 2 > ds' with 'offset > ds - 6'), libexif/exif-data.c:318 (exif_data_load_data_thumbnail: replaced 'o + s' checks with 'o >= ds' and 's > ds - o'), libexif/exif-data.c:196 (exif_data_load_data_entry: replaced 'doff + s' checks with 'doff >= size' and 's > size - doff'). 'ds' is initialized from user-provided 'size' in exif_data_new_from_data (libexif/exif-data.c:156) and exif_loader_get_data (libexif/exif-loader.c:401). 'thumbnail_offset' and 'thumbnail_length' are populated from EXIF tags (libexif/exif-data.c:465-472). Attackers can craft EXIF data with malicious offsets/sizes to trigger integer overflow and OOB writes.",0.95,./github/other_context/CVE-2019-9278
64,CVE-2020-12762,"CWE-190, CWE-787",c_cpp,"json-c through 0.14 has an integer overflow and out-of-bounds write via a large JSON file, as demonstrated by printbuf_memappend.",https://github.com/json-c/json-c/commit/099016b7e8d70a6d5dd814e788bba08d33d48426,"Protect array_list_del_idx against size_t overflow.\n\nIf the assignment of stop overflows due to idx and count being\nlarger than SIZE_T_MAX in sum, out of boundary access could happen.\n\nIt takes invalid usage of this function for this to happen, but\nI decided to add this check so array_list_del_idx is as safe against\nbad usage as the other arraylist functions.",9,"[{""func_name"": ""array_list_del_idx"", ""file_path"": ""arraylist.c"", ""func_code"": ""int array_list_del_idx(struct array_list *arr, size_t idx, size_t count)\n{\n\tsize_t i, stop;\n\n\tstop = idx + count;\n\tif (idx >= arr->length || stop > arr->length)\n\t\treturn -1;\n\tfor (i = idx; i < stop; ++i)\n\t{\n\t\tif (arr->array[i])\n\t\t\tarr->free_fn(arr->array[i]);\n\t}\n\tmemmove(arr->array + idx, arr->array + stop, (arr->length - stop) * sizeof(void *));\n\tarr->length -= count;\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""printbuf_extend"", ""file_path"": ""printbuf.c"", ""func_code"": ""static int printbuf_extend(struct printbuf *p, int min_size)\n{\n\tchar *t;\n\tint new_size;\n\n\tif (p->size >= min_size)\n\t\treturn 0;\n\n\tnew_size = p->size * 2;\n\tif (new_size < min_size + 8)\n\t\tnew_size =  min_size + 8;\n#ifdef PRINTBUF_DEBUG\n\tMC_DEBUG(\""printbuf_memappend: realloc \""\n\t  \""bpos=%d min_size=%d old_size=%d new_size=%d\\n\"",\n\t  p->bpos, min_size, p->size, new_size);\n#endif /* PRINTBUF_DEBUG */\n\tif(!(t = (char*)realloc(p->buf, new_size)))\n\t\treturn -1;\n\tp->size = new_size;\n\tp->buf = t;\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""printbuf_memappend"", ""file_path"": ""printbuf.c"", ""func_code"": ""int printbuf_memappend(struct printbuf *p, const char *buf, int size)\n{\n\tif (p->size <= p->bpos + size + 1) {\n\t\tif (printbuf_extend(p, p->bpos + size + 1) < 0)\n\t\t\treturn -1;\n\t}\n\tif(size > 1)\n\t\tmemcpy(p->buf + p->bpos, buf, size);\n\telse\n\t\tp->buf[p->bpos]= *buf;\n\tp->bpos += size;\n\tp->buf[p->bpos]= '\\0';\n\treturn size;\n}"", ""target"": 0}, {""func_name"": ""printbuf_memset"", ""file_path"": ""printbuf.c"", ""func_code"": ""int printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len)\n{\n\tint size_needed;\n\n\tif (offset == -1)\n\t\toffset = pb->bpos;\n\tsize_needed = offset + len;\n\tif (pb->size < size_needed)\n\t{\n\t\tif (printbuf_extend(pb, size_needed) < 0)\n\t\t\treturn -1;\n\t}\n\n\tmemset(pb->buf + offset, charvalue, len);\n\tif (pb->bpos < size_needed)\n\t\tpb->bpos = size_needed;\n\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""lh_table_new"", ""file_path"": ""linkhash.c"", ""func_code"": ""struct lh_table *lh_table_new(int size, lh_entry_free_fn *free_fn, lh_hash_fn *hash_fn,\n                              lh_equal_fn *equal_fn)\n{\n\tint i;\n\tstruct lh_table *t;\n\n\tt = (struct lh_table *)calloc(1, sizeof(struct lh_table));\n\tif (!t)\n\t\treturn NULL;\n\n\tt->count = 0;\n\tt->size = size;\n\tt->table = (struct lh_entry *)calloc(size, sizeof(struct lh_entry));\n\tif (!t->table)\n\t{\n\t\tfree(t);\n\t\treturn NULL;\n\t}\n\tt->free_fn = free_fn;\n\tt->hash_fn = hash_fn;\n\tt->equal_fn = equal_fn;\n\tfor (i = 0; i < size; i++)\n\t\tt->table[i].k = LH_EMPTY;\n\treturn t;\n}"", ""target"": 1}, {""func_name"": ""printbuf_extend"", ""file_path"": ""printbuf.c"", ""func_code"": ""static int printbuf_extend(struct printbuf *p, int min_size)\n{\n\tchar *t;\n\tint new_size;\n\n\tif (p->size >= min_size)\n\t\treturn 0;\n\n\tnew_size = p->size * 2;\n\tif (new_size < min_size + 8)\n\t\tnew_size = min_size + 8;\n#ifdef PRINTBUF_DEBUG\n\tMC_DEBUG(\""printbuf_memappend: realloc \""\n\t         \""bpos=%d min_size=%d old_size=%d new_size=%d\\n\"",\n\t         p->bpos, min_size, p->size, new_size);\n#endif /* PRINTBUF_DEBUG */\n\tif (!(t = (char *)realloc(p->buf, new_size)))\n\t\treturn -1;\n\tp->size = new_size;\n\tp->buf = t;\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""printbuf_memappend"", ""file_path"": ""printbuf.c"", ""func_code"": ""int printbuf_memappend(struct printbuf *p, const char *buf, int size)\n{\n\tif (p->size <= p->bpos + size + 1)\n\t{\n\t\tif (printbuf_extend(p, p->bpos + size + 1) < 0)\n\t\t\treturn -1;\n\t}\n\tmemcpy(p->buf + p->bpos, buf, size);\n\tp->bpos += size;\n\tp->buf[p->bpos] = '\\0';\n\treturn size;\n}"", ""target"": 0}, {""func_name"": ""printbuf_memset"", ""file_path"": ""printbuf.c"", ""func_code"": ""int printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len)\n{\n\tint size_needed;\n\n\tif (offset == -1)\n\t\toffset = pb->bpos;\n\tsize_needed = offset + len;\n\tif (pb->size < size_needed)\n\t{\n\t\tif (printbuf_extend(pb, size_needed) < 0)\n\t\t\treturn -1;\n\t}\n\n\tmemset(pb->buf + offset, charvalue, len);\n\tif (pb->bpos < size_needed)\n\t\tpb->bpos = size_needed;\n\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""lh_table_insert_w_hash"", ""file_path"": ""linkhash.c"", ""func_code"": ""int lh_table_insert_w_hash(struct lh_table *t, const void *k, const void *v, const unsigned long h,\n                           const unsigned opts)\n{\n\tunsigned long n;\n\n\tif (t->count >= t->size * LH_LOAD_FACTOR)\n\t\tif (lh_table_resize(t, t->size * 2) != 0)\n\t\t\treturn -1;\n\n\tn = h % t->size;\n\n\twhile (1)\n\t{\n\t\tif (t->table[n].k == LH_EMPTY || t->table[n].k == LH_FREED)\n\t\t\tbreak;\n\t\tif ((int)++n == t->size)\n\t\t\tn = 0;\n\t}\n\n\tt->table[n].k = k;\n\tt->table[n].k_is_constant = (opts & JSON_C_OBJECT_KEY_IS_CONSTANT);\n\tt->table[n].v = v;\n\tt->count++;\n\n\tif (t->head == NULL)\n\t{\n\t\tt->head = t->tail = &t->table[n];\n\t\tt->table[n].next = t->table[n].prev = NULL;\n\t}\n\telse\n\t{\n\t\tt->tail->next = &t->table[n];\n\t\tt->table[n].prev = t->tail;\n\t\tt->table[n].next = NULL;\n\t\tt->tail = &t->table[n];\n\t}\n\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""array_list_del_idx"", ""file_path"": ""arraylist.c"", ""func_code"": ""int array_list_del_idx(struct array_list *arr, size_t idx, size_t count)\n{\n\tsize_t i, stop;\n\n\t/* Avoid overflow in calculation with large indices. */\n\tif (idx > SIZE_T_MAX - count)\n\t\treturn -1;\n\tstop = idx + count;\n\tif (idx >= arr->length || stop > arr->length)\n\t\treturn -1;\n\tfor (i = idx; i < stop; ++i)\n\t{\n\t\tif (arr->array[i])\n\t\t\tarr->free_fn(arr->array[i]);\n\t}\n\tmemmove(arr->array + idx, arr->array + stop, (arr->length - stop) * sizeof(void *));\n\tarr->length -= count;\n\treturn 0;\n}""}, {""func_name"": ""printbuf_extend"", ""file_path"": ""printbuf.c"", ""func_code"": ""static int printbuf_extend(struct printbuf *p, int min_size)\n{\n\tchar *t;\n\tint new_size;\n\n\tif (p->size >= min_size)\n\t\treturn 0;\n\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (min_size > INT_MAX - 8)\n\t\treturn -1;\n\tif (p->size > INT_MAX / 2)\n\t\tnew_size = min_size + 8;\n\telse {\n\t\tnew_size = p->size * 2;\n\t\tif (new_size < min_size + 8)\n\t\t\tnew_size = min_size + 8;\n\t}\n#ifdef PRINTBUF_DEBUG\n\tMC_DEBUG(\""printbuf_memappend: realloc \""\n\t  \""bpos=%d min_size=%d old_size=%d new_size=%d\\n\"",\n\t  p->bpos, min_size, p->size, new_size);\n#endif /* PRINTBUF_DEBUG */\n\tif(!(t = (char*)realloc(p->buf, new_size)))\n\t\treturn -1;\n\tp->size = new_size;\n\tp->buf = t;\n\treturn 0;\n}""}, {""func_name"": ""printbuf_memappend"", ""file_path"": ""printbuf.c"", ""func_code"": ""int printbuf_memappend(struct printbuf *p, const char *buf, int size)\n{\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (size > INT_MAX - p->bpos - 1)\n\t\treturn -1;\n\tif (p->size <= p->bpos + size + 1) {\n\t\tif (printbuf_extend(p, p->bpos + size + 1) < 0)\n\t\t\treturn -1;\n\t}\n\tif(size > 1)\n\t\tmemcpy(p->buf + p->bpos, buf, size);\n\telse\n\t\tp->buf[p->bpos]= *buf;\n\tp->bpos += size;\n\tp->buf[p->bpos]= '\\0';\n\treturn size;\n}""}, {""func_name"": ""printbuf_memset"", ""file_path"": ""printbuf.c"", ""func_code"": ""int printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len)\n{\n\tint size_needed;\n\n\tif (offset == -1)\n\t\toffset = pb->bpos;\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (len > INT_MAX - offset)\n\t\treturn -1;\n\tsize_needed = offset + len;\n\tif (pb->size < size_needed)\n\t{\n\t\tif (printbuf_extend(pb, size_needed) < 0)\n\t\t\treturn -1;\n\t}\n\n\tmemset(pb->buf + offset, charvalue, len);\n\tif (pb->bpos < size_needed)\n\t\tpb->bpos = size_needed;\n\n\treturn 0;\n}""}, {""func_name"": ""lh_table_new"", ""file_path"": ""linkhash.c"", ""func_code"": ""struct lh_table *lh_table_new(int size, lh_entry_free_fn *free_fn, lh_hash_fn *hash_fn,\n                              lh_equal_fn *equal_fn)\n{\n\tint i;\n\tstruct lh_table *t;\n\n\t/* Allocate space for elements to avoid divisions by zero. */\n\tassert(size > 0);\n\tt = (struct lh_table *)calloc(1, sizeof(struct lh_table));\n\tif (!t)\n\t\treturn NULL;\n\n\tt->count = 0;\n\tt->size = size;\n\tt->table = (struct lh_entry *)calloc(size, sizeof(struct lh_entry));\n\tif (!t->table)\n\t{\n\t\tfree(t);\n\t\treturn NULL;\n\t}\n\tt->free_fn = free_fn;\n\tt->hash_fn = hash_fn;\n\tt->equal_fn = equal_fn;\n\tfor (i = 0; i < size; i++)\n\t\tt->table[i].k = LH_EMPTY;\n\treturn t;\n}""}, {""func_name"": ""printbuf_extend"", ""file_path"": ""printbuf.c"", ""func_code"": ""static int printbuf_extend(struct printbuf *p, int min_size)\n{\n\tchar *t;\n\tint new_size;\n\n\tif (p->size >= min_size)\n\t\treturn 0;\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (min_size > INT_MAX - 8)\n\t\treturn -1;\n\tif (p->size > INT_MAX / 2)\n\t\tnew_size = min_size + 8;\n\telse {\n\t\tnew_size = p->size * 2;\n\t\tif (new_size < min_size + 8)\n\t\t\tnew_size = min_size + 8;\n\t}\n#ifdef PRINTBUF_DEBUG\n\tMC_DEBUG(\""printbuf_memappend: realloc \""\n\t         \""bpos=%d min_size=%d old_size=%d new_size=%d\\n\"",\n\t         p->bpos, min_size, p->size, new_size);\n#endif /* PRINTBUF_DEBUG */\n\tif (!(t = (char *)realloc(p->buf, new_size)))\n\t\treturn -1;\n\tp->size = new_size;\n\tp->buf = t;\n\treturn 0;\n}""}, {""func_name"": ""printbuf_memappend"", ""file_path"": ""printbuf.c"", ""func_code"": ""int printbuf_memappend(struct printbuf *p, const char *buf, int size)\n{\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (size > INT_MAX - p->bpos - 1)\n\t\treturn -1;\n\tif (p->size <= p->bpos + size + 1)\n\t{\n\t\tif (printbuf_extend(p, p->bpos + size + 1) < 0)\n\t\t\treturn -1;\n\t}\n\tmemcpy(p->buf + p->bpos, buf, size);\n\tp->bpos += size;\n\tp->buf[p->bpos] = '\\0';\n\treturn size;\n}""}, {""func_name"": ""printbuf_memset"", ""file_path"": ""printbuf.c"", ""func_code"": ""int printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len)\n{\n\tint size_needed;\n\n\tif (offset == -1)\n\t\toffset = pb->bpos;\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (len > INT_MAX - offset)\n\t\treturn -1;\n\tsize_needed = offset + len;\n\tif (pb->size < size_needed)\n\t{\n\t\tif (printbuf_extend(pb, size_needed) < 0)\n\t\t\treturn -1;\n\t}\n\n\tmemset(pb->buf + offset, charvalue, len);\n\tif (pb->bpos < size_needed)\n\t\tpb->bpos = size_needed;\n\n\treturn 0;\n}""}, {""func_name"": ""lh_table_insert_w_hash"", ""file_path"": ""linkhash.c"", ""func_code"": ""int lh_table_insert_w_hash(struct lh_table *t, const void *k, const void *v, const unsigned long h,\n                           const unsigned opts)\n{\n\tunsigned long n;\n\n\tif (t->count >= t->size * LH_LOAD_FACTOR) {\n\t\t/* Avoid signed integer overflow with large tables. */\n\t\tint new_size = INT_MAX / 2 < t->size ? t->size * 2 : INT_MAX;\n\t\tif (t->size == INT_MAX || lh_table_resize(t, new_size) != 0)\n\t\t\treturn -1;\n\t}\n\n\tn = h % t->size;\n\n\twhile (1)\n\t{\n\t\tif (t->table[n].k == LH_EMPTY || t->table[n].k == LH_FREED)\n\t\t\tbreak;\n\t\tif ((int)++n == t->size)\n\t\t\tn = 0;\n\t}\n\n\tt->table[n].k = k;\n\tt->table[n].k_is_constant = (opts & JSON_C_OBJECT_KEY_IS_CONSTANT);\n\tt->table[n].v = v;\n\tt->count++;\n\n\tif (t->head == NULL)\n\t{\n\t\tt->head = t->tail = &t->table[n];\n\t\tt->table[n].next = t->table[n].prev = NULL;\n\t}\n\telse\n\t{\n\t\tt->tail->next = &t->table[n];\n\t\tt->table[n].prev = t->tail;\n\t\tt->table[n].next = NULL;\n\t\tt->tail = &t->table[n];\n\t}\n\n\treturn 0;\n}""}]","{""caller"": 2, ""value"": 1, ""function"": 3, ""code"": 3}","[{""source"": ""caller_info(file:printbuf.c, func:printbuf_memappend)"", ""result"": [{""call_line"": 142, ""call_code"": ""printbuf_memappend(p, t, size)"", ""caller_code"": ""int sprintbuf(struct printbuf *p, const char *msg, ...)\n{\n\tva_list ap;\n\tchar *t;\n\tint size;\n\tchar buf[128];\n\n\t/* user stack buffer first */\n\tva_start(ap, msg);\n\tsize = vsnprintf(buf, 128, msg, ap);\n\tva_end(ap);\n\t/* if string is greater than stack buffer, then use dynamic string\n\t * with vasprintf.  Note: some implementation of vsnprintf return -1\n\t * if output is truncated whereas some return the number of bytes that\n\t * would have been written - this code handles both cases.\n\t */\n\tif (size == -1 || size > 127)\n\t{\n\t\tva_start(ap, msg);\n\t\tif ((size = vasprintf(&t, msg, ap)) < 0)\n\t\t{\n\t\t\tva_end(ap);\n\t\t\treturn -1;\n\t\t}\n\t\tva_end(ap);\n\t\tprintbuf_memappend(p, t, size);\n\t\tfree(t);\n\t\treturn size;\n\t}\n\telse\n\t{\n\t\tprintbuf_memappend(p, buf, size);\n\t\treturn size;\n\t}\n}\n"", ""caller_start"": 117, ""file_path"": ""printbuf.c""}, {""call_line"": 148, ""call_code"": ""printbuf_memappend(p, buf, size)"", ""caller_code"": ""int sprintbuf(struct printbuf *p, const char *msg, ...)\n{\n\tva_list ap;\n\tchar *t;\n\tint size;\n\tchar buf[128];\n\n\t/* user stack buffer first */\n\tva_start(ap, msg);\n\tsize = vsnprintf(buf, 128, msg, ap);\n\tva_end(ap);\n\t/* if string is greater than stack buffer, then use dynamic string\n\t * with vasprintf.  Note: some implementation of vsnprintf return -1\n\t * if output is truncated whereas some return the number of bytes that\n\t * would have been written - this code handles both cases.\n\t */\n\tif (size == -1 || size > 127)\n\t{\n\t\tva_start(ap, msg);\n\t\tif ((size = vasprintf(&t, msg, ap)) < 0)\n\t\t{\n\t\t\tva_end(ap);\n\t\t\treturn -1;\n\t\t}\n\t\tva_end(ap);\n\t\tprintbuf_memappend(p, t, size);\n\t\tfree(t);\n\t\treturn size;\n\t}\n\telse\n\t{\n\t\tprintbuf_memappend(p, buf, size);\n\t\treturn size;\n\t}\n}\n"", ""caller_start"": 117, ""file_path"": ""printbuf.c""}, {""call_line"": 144, ""call_code"": ""printbuf_memappend(pb, str + start_offset, pos - start_offset)"", ""caller_code"": ""static int json_escape_str(struct printbuf *pb, const char *str, int len, int flags)\n{\n\tint pos = 0, start_offset = 0;\n\tunsigned char c;\n\twhile (len--)\n\t{\n\t\tc = str[pos];\n\t\tswitch (c)\n\t\t{\n\t\tcase '\\b':\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\tcase '\\t':\n\t\tcase '\\f':\n\t\tcase '\""':\n\t\tcase '\\\\':\n\t\tcase '/':\n\t\t\tif ((flags & JSON_C_TO_STRING_NOSLASHESCAPE) && c == '/')\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pos - start_offset > 0)\n\t\t\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);\n\n\t\t\tif (c == '\\b')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\b\"", 2);\n\t\t\telse if (c == '\\n')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\n\"", 2);\n\t\t\telse if (c == '\\r')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\r\"", 2);\n\t\t\telse if (c == '\\t')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\t\"", 2);\n\t\t\telse if (c == '\\f')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\f\"", 2);\n\t\t\telse if (c == '\""')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\\\\""\"", 2);\n\t\t\telse if (c == '\\\\')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\\\\\\"", 2);\n\t\t\telse if (c == '/')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\/\"", 2);\n\n\t\t\tstart_offset = ++pos;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (c < ' ')\n\t\t\t{\n\t\t\t\tchar sbuf[7];\n\t\t\t\tif (pos - start_offset > 0)\n\t\t\t\t\tprintbuf_memappend(pb, str + start_offset,\n\t\t\t\t\t                   pos - start_offset);\n\t\t\t\tsnprintf(sbuf, sizeof(sbuf), \""\\\\u00%c%c\"", json_hex_chars[c >> 4],\n\t\t\t\t         json_hex_chars[c & 0xf]);\n\t\t\t\tprintbuf_memappend_fast(pb, sbuf, (int)sizeof(sbuf) - 1);\n\t\t\t\tstart_offset = ++pos;\n\t\t\t}\n\t\t\telse\n\t\t\t\tpos++;\n\t\t}\n\t}\n\tif (pos - start_offset > 0)\n\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);\n\treturn 0;\n}\n"", ""caller_start"": 120, ""file_path"": ""json_object.c""}, {""call_line"": 147, ""call_code"": ""printbuf_memappend(pb, \""\\\\b\"", 2)"", ""caller_code"": ""static int json_escape_str(struct printbuf *pb, const char *str, int len, int flags)\n{\n\tint pos = 0, start_offset = 0;\n\tunsigned char c;\n\twhile (len--)\n\t{\n\t\tc = str[pos];\n\t\tswitch (c)\n\t\t{\n\t\tcase '\\b':\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\tcase '\\t':\n\t\tcase '\\f':\n\t\tcase '\""':\n\t\tcase '\\\\':\n\t\tcase '/':\n\t\t\tif ((flags & JSON_C_TO_STRING_NOSLASHESCAPE) && c == '/')\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pos - start_offset > 0)\n\t\t\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);\n\n\t\t\tif (c == '\\b')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\b\"", 2);\n\t\t\telse if (c == '\\n')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\n\"", 2);\n\t\t\telse if (c == '\\r')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\r\"", 2);\n\t\t\telse if (c == '\\t')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\t\"", 2);\n\t\t\telse if (c == '\\f')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\f\"", 2);\n\t\t\telse if (c == '\""')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\\\\""\"", 2);\n\t\t\telse if (c == '\\\\')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\\\\\\"", 2);\n\t\t\telse if (c == '/')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\/\"", 2);\n\n\t\t\tstart_offset = ++pos;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (c < ' ')\n\t\t\t{\n\t\t\t\tchar sbuf[7];\n\t\t\t\tif (pos - start_offset > 0)\n\t\t\t\t\tprintbuf_memappend(pb, str + start_offset,\n\t\t\t\t\t                   pos - start_offset);\n\t\t\t\tsnprintf(sbuf, sizeof(sbuf), \""\\\\u00%c%c\"", json_hex_chars[c >> 4],\n\t\t\t\t         json_hex_chars[c & 0xf]);\n\t\t\t\tprintbuf_memappend_fast(pb, sbuf, (int)sizeof(sbuf) - 1);\n\t\t\t\tstart_offset = ++pos;\n\t\t\t}\n\t\t\telse\n\t\t\t\tpos++;\n\t\t}\n\t}\n\tif (pos - start_offset > 0)\n\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);\n\treturn 0;\n}\n"", ""caller_start"": 120, ""file_path"": ""json_object.c""}]}, {""source"": ""value_info(file:printbuf.c, value:p->bpos)"", ""result"": {""value_trace"": [{""full_code"": ""p->bpos = 0"", ""line"": 43, ""func_name"": ""printbuf_new""}, {""full_code"": ""p->bpos += size"", ""line"": 92, ""func_name"": ""printbuf_memappend""}, {""full_code"": ""p->bpos = 0"", ""line"": 156, ""func_name"": ""printbuf_reset""}], ""struct_var"": ""p"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:json_object.c, func:json_escape_str)"", ""result"": [{""code"": ""static int json_escape_str(struct printbuf *pb, const char *str, int len, int flags)\n{\n\tint pos = 0, start_offset = 0;\n\tunsigned char c;\n\twhile (len--)\n\t{\n\t\tc = str[pos];\n\t\tswitch (c)\n\t\t{\n\t\tcase '\\b':\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\tcase '\\t':\n\t\tcase '\\f':\n\t\tcase '\""':\n\t\tcase '\\\\':\n\t\tcase '/':\n\t\t\tif ((flags & JSON_C_TO_STRING_NOSLASHESCAPE) && c == '/')\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pos - start_offset > 0)\n\t\t\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);\n\n\t\t\tif (c == '\\b')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\b\"", 2);\n\t\t\telse if (c == '\\n')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\n\"", 2);\n\t\t\telse if (c == '\\r')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\r\"", 2);\n\t\t\telse if (c == '\\t')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\t\"", 2);\n\t\t\telse if (c == '\\f')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\f\"", 2);\n\t\t\telse if (c == '\""')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\\\\""\"", 2);\n\t\t\telse if (c == '\\\\')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\\\\\\"", 2);\n\t\t\telse if (c == '/')\n\t\t\t\tprintbuf_memappend(pb, \""\\\\/\"", 2);\n\n\t\t\tstart_offset = ++pos;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (c < ' ')\n\t\t\t{\n\t\t\t\tchar sbuf[7];\n\t\t\t\tif (pos - start_offset > 0)\n\t\t\t\t\tprintbuf_memappend(pb, str + start_offset,\n\t\t\t\t\t                   pos - start_offset);\n\t\t\t\tsnprintf(sbuf, sizeof(sbuf), \""\\\\u00%c%c\"", json_hex_chars[c >> 4],\n\t\t\t\t         json_hex_chars[c & 0xf]);\n\t\t\t\tprintbuf_memappend_fast(pb, sbuf, (int)sizeof(sbuf) - 1);\n\t\t\t\tstart_offset = ++pos;\n\t\t\t}\n\t\t\telse\n\t\t\t\tpos++;\n\t\t}\n\t}\n\tif (pos - start_offset > 0)\n\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);\n\treturn 0;\n}\n"", ""start_line"": 120, ""end_line"": 184, ""full_name"": ""json_escape_str"", ""file_path"": ""json_object.c""}]}, {""source"": ""caller_info(file:json_object.c, func:json_escape_str)"", ""result"": [{""call_line"": 413, ""call_code"": ""json_escape_str(pb, iter.key, strlen(iter.key), flags)"", ""caller_code"": ""static int json_object_object_to_json_string(struct json_object *jso, struct printbuf *pb,\n                                             int level, int flags)\n{\n\tint had_children = 0;\n\tstruct json_object_iter iter;\n\n\tprintbuf_strappend(pb, \""{\"" /*}*/);\n\tif (flags & JSON_C_TO_STRING_PRETTY)\n\t\tprintbuf_strappend(pb, \""\\n\"");\n\tjson_object_object_foreachC(jso, iter)\n\t{\n\t\tif (had_children)\n\t\t{\n\t\t\tprintbuf_strappend(pb, \"",\"");\n\t\t\tif (flags & JSON_C_TO_STRING_PRETTY)\n\t\t\t\tprintbuf_strappend(pb, \""\\n\"");\n\t\t}\n\t\thad_children = 1;\n\t\tif (flags & JSON_C_TO_STRING_SPACED && !(flags & JSON_C_TO_STRING_PRETTY))\n\t\t\tprintbuf_strappend(pb, \"" \"");\n\t\tindent(pb, level + 1, flags);\n\t\tprintbuf_strappend(pb, \""\\\""\"");\n\t\tjson_escape_str(pb, iter.key, strlen(iter.key), flags);\n\t\tif (flags & JSON_C_TO_STRING_SPACED)\n\t\t\tprintbuf_strappend(pb, \""\\\"": \"");\n\t\telse\n\t\t\tprintbuf_strappend(pb, \""\\\"":\"");\n\t\tif (iter.val == NULL)\n\t\t\tprintbuf_strappend(pb, \""null\"");\n\t\telse if (iter.val->_to_json_string(iter.val, pb, level + 1, flags) < 0)\n\t\t\treturn -1;\n\t}\n\tif (flags & JSON_C_TO_STRING_PRETTY)\n\t{\n\t\tif (had_children)\n\t\t\tprintbuf_strappend(pb, \""\\n\"");\n\t\tindent(pb, level, flags);\n\t}\n\tif (flags & JSON_C_TO_STRING_SPACED && !(flags & JSON_C_TO_STRING_PRETTY))\n\t\treturn printbuf_strappend(pb, /*{*/ \"" }\"");\n\telse\n\t\treturn printbuf_strappend(pb, /*{*/ \""}\"");\n}\n"", ""caller_start"": 391, ""file_path"": ""json_object.c""}, {""call_line"": 1126, ""call_code"": ""json_escape_str(pb, get_string_component(jso), jso->o.c_string.len, flags)"", ""caller_code"": ""static int json_object_string_to_json_string(struct json_object *jso, struct printbuf *pb,\n                                             int level, int flags)\n{\n\tprintbuf_strappend(pb, \""\\\""\"");\n\tjson_escape_str(pb, get_string_component(jso), jso->o.c_string.len, flags);\n\tprintbuf_strappend(pb, \""\\\""\"");\n\treturn 0;\n}"", ""caller_start"": 1122, ""file_path"": ""json_object.c""}]}, {""source"": ""code_info(file:json_tokener.c, lines:1-200)"", ""result"": ""/*\n * $Id: json_tokener.c,v 1.20 2006/07/25 03:24:50 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n *\n * Copyright (c) 2008-2009 Yahoo! Inc.  All rights reserved.\n * The copyrights to the contents of this file are licensed under the MIT License\n * (http://www.opensource.org/licenses/mit-license.php)\n */\n\n#include \""config.h\""\n\n#include \""math_compat.h\""\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n#include <math.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \""debug.h\""\n#include \""json_inttypes.h\""\n#include \""json_object.h\""\n#include \""json_object_private.h\""\n#include \""json_tokener.h\""\n#include \""json_util.h\""\n#include \""printbuf.h\""\n#include \""strdup_compat.h\""\n\n#ifdef HAVE_LOCALE_H\n#include <locale.h>\n#endif /* HAVE_LOCALE_H */\n#ifdef HAVE_XLOCALE_H\n#include <xlocale.h>\n#endif\n\n#define jt_hexdigit(x) (((x) <= '9') ? (x) - '0' : ((x)&7) + 9)\n\n#if !HAVE_STRNCASECMP && defined(_MSC_VER)\n/* MSC has the version as _strnicmp */\n#define strncasecmp _strnicmp\n#elif !HAVE_STRNCASECMP\n#error You do not have strncasecmp on your system.\n#endif /* HAVE_STRNCASECMP */\n\n/* Use C99 NAN by default; if not available, nan(\""\"") should work too. */\n#ifndef NAN\n#define NAN nan(\""\"")\n#endif /* !NAN */\n\nstatic const char json_null_str[] = \""null\"";\nstatic const int json_null_str_len = sizeof(json_null_str) - 1;\nstatic const char json_inf_str[] = \""Infinity\"";\nstatic const char json_inf_str_lower[] = \""infinity\"";\nstatic const unsigned int json_inf_str_len = sizeof(json_inf_str) - 1;\nstatic const char json_nan_str[] = \""NaN\"";\nstatic const int json_nan_str_len = sizeof(json_nan_str) - 1;\nstatic const char json_true_str[] = \""true\"";\nstatic const int json_true_str_len = sizeof(json_true_str) - 1;\nstatic const char json_false_str[] = \""false\"";\nstatic const int json_false_str_len = sizeof(json_false_str) - 1;\n\n/* clang-format off */\nstatic const char *json_tokener_errors[] = {\n\t\""success\"",\n\t\""continue\"",\n\t\""nesting too deep\"",\n\t\""unexpected end of data\"",\n\t\""unexpected character\"",\n\t\""null expected\"",\n\t\""boolean expected\"",\n\t\""number expected\"",\n\t\""array value separator ',' expected\"",\n\t\""quoted object property name expected\"",\n\t\""object property name separator ':' expected\"",\n\t\""object value separator ',' expected\"",\n\t\""invalid string sequence\"",\n\t\""expected comment\"",\n\t\""invalid utf-8 string\"",\n\t\""buffer size overflow\""\n};\n/* clang-format on */\n\n/**\n * validete the utf-8 string in strict model.\n * if not utf-8 format, return err.\n */\nstatic json_bool json_tokener_validate_utf8(const char c, unsigned int *nBytes);\n\nconst char *json_tokener_error_desc(enum json_tokener_error jerr)\n{\n\tint jerr_int = (int)jerr;\n\tif (jerr_int < 0 ||\n\t    jerr_int >= (int)(sizeof(json_tokener_errors) / sizeof(json_tokener_errors[0])))\n\t\treturn \""Unknown error, \""\n\t\t       \""invalid json_tokener_error value passed to json_tokener_error_desc()\"";\n\treturn json_tokener_errors[jerr];\n}\n\nenum json_tokener_error json_tokener_get_error(struct json_tokener *tok)\n{\n\treturn tok->err;\n}\n\n/* Stuff for decoding unicode sequences */\n#define IS_HIGH_SURROGATE(uc) (((uc)&0xFC00) == 0xD800)\n#define IS_LOW_SURROGATE(uc) (((uc)&0xFC00) == 0xDC00)\n#define DECODE_SURROGATE_PAIR(hi, lo) ((((hi)&0x3FF) << 10) + ((lo)&0x3FF) + 0x10000)\nstatic unsigned char utf8_replacement_char[3] = {0xEF, 0xBF, 0xBD};\n\nstruct json_tokener *json_tokener_new_ex(int depth)\n{\n\tstruct json_tokener *tok;\n\n\ttok = (struct json_tokener *)calloc(1, sizeof(struct json_tokener));\n\tif (!tok)\n\t\treturn NULL;\n\ttok->stack = (struct json_tokener_srec *)calloc(depth, sizeof(struct json_tokener_srec));\n\tif (!tok->stack)\n\t{\n\t\tfree(tok);\n\t\treturn NULL;\n\t}\n\ttok->pb = printbuf_new();\n\ttok->max_depth = depth;\n\tjson_tokener_reset(tok);\n\treturn tok;\n}\n\nstruct json_tokener *json_tokener_new(void)\n{\n\treturn json_tokener_new_ex(JSON_TOKENER_DEFAULT_DEPTH);\n}\n\nvoid json_tokener_free(struct json_tokener *tok)\n{\n\tjson_tokener_reset(tok);\n\tif (tok->pb)\n\t\tprintbuf_free(tok->pb);\n\tfree(tok->stack);\n\tfree(tok);\n}\n\nstatic void json_tokener_reset_level(struct json_tokener *tok, int depth)\n{\n\ttok->stack[depth].state = json_tokener_state_eatws;\n\ttok->stack[depth].saved_state = json_tokener_state_start;\n\tjson_object_put(tok->stack[depth].current);\n\ttok->stack[depth].current = NULL;\n\tfree(tok->stack[depth].obj_field_name);\n\ttok->stack[depth].obj_field_name = NULL;\n}\n\nvoid json_tokener_reset(struct json_tokener *tok)\n{\n\tint i;\n\tif (!tok)\n\t\treturn;\n\n\tfor (i = tok->depth; i >= 0; i--)\n\t\tjson_tokener_reset_level(tok, i);\n\ttok->depth = 0;\n\ttok->err = json_tokener_success;\n}\n\nstruct json_object *json_tokener_parse(const char *str)\n{\n\tenum json_tokener_error jerr_ignored;\n\tstruct json_object *obj;\n\tobj = json_tokener_parse_verbose(str, &jerr_ignored);\n\treturn obj;\n}\n\nstruct json_object *json_tokener_parse_verbose(const char *str, enum json_tokener_error *error)\n{\n\tstruct json_tokener *tok;\n\tstruct json_object *obj;\n\n\ttok = json_tokener_new();\n\tif (!tok)\n\t\treturn NULL;\n\tobj = json_tokener_parse_ex(tok, str, -1);\n\t*error = tok->err;\n\tif (tok->err != json_tokener_success)\n\t{\n\t\tif (obj != NULL)\n\t\t\tjson_object_put(obj);\n\t\tobj = NULL;\n\t}\n\n\tjson_tokener_free(tok);\n\treturn obj;\n}\n""}, {""source"": ""func_info(file:json_tokener.c, func:json_tokener_parse_ex)"", ""result"": [{""code"": ""struct json_object *json_tokener_parse_ex(struct json_tokener *tok, const char *str, int len)\n{\n\tstruct json_object *obj = NULL;\n\tchar c = '\\1';\n\tunsigned int nBytes = 0;\n\tunsigned int *nBytesp = &nBytes;\n\n#ifdef HAVE_USELOCALE\n\tlocale_t oldlocale = uselocale(NULL);\n\tlocale_t newloc;\n#elif defined(HAVE_SETLOCALE)\n\tchar *oldlocale = NULL;\n#endif\n\n\ttok->char_offset = 0;\n\ttok->err = json_tokener_success;\n\n\t/* this interface is presently not 64-bit clean due to the int len argument\n\t * and the internal printbuf interface that takes 32-bit int len arguments\n\t * so the function limits the maximum string size to INT32_MAX (2GB).\n\t * If the function is called with len == -1 then strlen is called to check\n\t * the string length is less than INT32_MAX (2GB)\n\t */\n\tif ((len < -1) || (len == -1 && strlen(str) > INT32_MAX))\n\t{\n\t\ttok->err = json_tokener_error_size;\n\t\treturn NULL;\n\t}\n\n#ifdef HAVE_USELOCALE\n\t{\n\t\tlocale_t duploc = duplocale(oldlocale);\n\t\tnewloc = newlocale(LC_NUMERIC_MASK, \""C\"", duploc);\n\t\tif (newloc == NULL)\n\t\t{\n\t\t\tfreelocale(duploc);\n\t\t\treturn NULL;\n\t\t}\n\t\tuselocale(newloc);\n\t}\n#elif defined(HAVE_SETLOCALE)\n\t{\n\t\tchar *tmplocale;\n\t\ttmplocale = setlocale(LC_NUMERIC, NULL);\n\t\tif (tmplocale)\n\t\t\toldlocale = strdup(tmplocale);\n\t\tsetlocale(LC_NUMERIC, \""C\"");\n\t}\n#endif\n\n\twhile (PEEK_CHAR(c, tok))\n\t{\n\n\tredo_char:\n\t\tswitch (state)\n\t\t{\n\n\t\tcase json_tokener_state_eatws:\n\t\t\t/* Advance until we change state */\n\t\t\twhile (isspace((unsigned char)c))\n\t\t\t{\n\t\t\t\tif ((!ADVANCE_CHAR(str, tok)) || (!PEEK_CHAR(c, tok)))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (c == '/' && !(tok->flags & JSON_TOKENER_STRICT))\n\t\t\t{\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\t\t\t\tstate = json_tokener_state_comment_start;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate = saved_state;\n\t\t\t\tgoto redo_char;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_start:\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase '{':\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\tsaved_state = json_tokener_state_object_field_start;\n\t\t\t\tcurrent = json_object_new_object();\n\t\t\t\tif (current == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\tsaved_state = json_tokener_state_array;\n\t\t\t\tcurrent = json_object_new_array();\n\t\t\t\tif (current == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\tcase 'i':\n\t\t\t\tstate = json_tokener_state_inf;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tcase 'N':\n\t\t\tcase 'n':\n\t\t\t\tstate = json_tokener_state_null; // or NaN\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tcase '\\'':\n\t\t\t\tif (tok->flags & JSON_TOKENER_STRICT)\n\t\t\t\t{\n\t\t\t\t\t/* in STRICT mode only double-quote are allowed */\n\t\t\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/* FALLTHRU */\n\t\t\tcase '\""':\n\t\t\t\tstate = json_tokener_state_string;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->quote_char = c;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\tcase 't':\n\t\t\tcase 'F':\n\t\t\tcase 'f':\n\t\t\t\tstate = json_tokener_state_boolean;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\tcase '-':\n\t\t\t\tstate = json_tokener_state_number;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->is_double = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tdefault: tok->err = json_tokener_error_parse_unexpected; goto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_finish:\n\t\t\tif (tok->depth == 0)\n\t\t\t\tgoto out;\n\t\t\tobj = json_object_get(current);\n\t\t\tjson_tokener_reset_level(tok, tok->depth);\n\t\t\ttok->depth--;\n\t\t\tgoto redo_char;\n\n\t\tcase json_tokener_state_inf: /* aka starts with 'i' (or 'I', or \""-i\"", or \""-I\"") */\n\t\t{\n\t\t\t/* If we were guaranteed to have len set, then we could (usually) handle\n\t\t\t * the entire \""Infinity\"" check in a single strncmp (strncasecmp), but\n\t\t\t * since len might be -1 (i.e. \""read until \\0\""), we need to check it\n\t\t\t * a character at a time.\n\t\t\t * Trying to handle it both ways would make this code considerably more\n\t\t\t * complicated with likely little performance benefit.\n\t\t\t */\n\t\t\tint is_negative = 0;\n\t\t\tconst char *_json_inf_str = json_inf_str;\n\t\t\tif (!(tok->flags & JSON_TOKENER_STRICT))\n\t\t\t\t_json_inf_str = json_inf_str_lower;\n\n\t\t\t/* Note: tok->st_pos must be 0 when state is set to json_tokener_state_inf */\n\t\t\twhile (tok->st_pos < (int)json_inf_str_len)\n\t\t\t{\n\t\t\t\tchar inf_char = *str;\n\t\t\t\tif (!(tok->flags & JSON_TOKENER_STRICT))\n\t\t\t\t\tinf_char = tolower((int)*str);\n\t\t\t\tif (inf_char != _json_inf_str[tok->st_pos])\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\ttok->st_pos++;\n\t\t\t\t(void)ADVANCE_CHAR(str, tok);\n\t\t\t\tif (!PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\t/* out of input chars, for now at least */\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* We checked the full length of \""Infinity\"", so create the object.\n\t\t\t * When handling -Infinity, the number parsing code will have dropped\n\t\t\t * the \""-\"" into tok->pb for us, so check it now.\n\t\t\t */\n\t\t\tif (printbuf_length(tok->pb) > 0 && *(tok->pb->buf) == '-')\n\t\t\t{\n\t\t\t\tis_negative = 1;\n\t\t\t}\n\t\t\tcurrent = json_object_new_double(is_negative ? -INFINITY : INFINITY);\n\t\t\tif (current == NULL)\n\t\t\t\tgoto out;\n\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\t\t}\n\t\tbreak;\n\t\tcase json_tokener_state_null: /* aka starts with 'n' */\n\t\t{\n\t\t\tint size;\n\t\t\tint size_nan;\n\t\t\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\t\t\tsize = json_min(tok->st_pos + 1, json_null_str_len);\n\t\t\tsize_nan = json_min(tok->st_pos + 1, json_nan_str_len);\n\t\t\tif ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t\t\t     strncasecmp(json_null_str, tok->pb->buf, size) == 0) ||\n\t\t\t    (strncmp(json_null_str, tok->pb->buf, size) == 0))\n\t\t\t{\n\t\t\t\tif (tok->st_pos == json_null_str_len)\n\t\t\t\t{\n\t\t\t\t\tcurrent = NULL;\n\t\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tgoto redo_char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t\t\t          strncasecmp(json_nan_str, tok->pb->buf, size_nan) == 0) ||\n\t\t\t         (strncmp(json_nan_str, tok->pb->buf, size_nan) == 0))\n\t\t\t{\n\t\t\t\tif (tok->st_pos == json_nan_str_len)\n\t\t\t\t{\n\t\t\t\t\tcurrent = json_object_new_double(NAN);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tgoto redo_char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_null;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttok->st_pos++;\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_comment_start:\n\t\t\tif (c == '*')\n\t\t\t{\n\t\t\t\tstate = json_tokener_state_comment;\n\t\t\t}\n\t\t\telse if (c == '/')\n\t\t\t{\n\t\t\t\tstate = json_tokener_state_comment_eol;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_comment;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_comment:\n\t\t{\n\t\t\t/* Advance until we change state */\n\t\t\tconst char *case_start = str;\n\t\t\twhile (c != '*')\n\t\t\t{\n\t\t\t\tif (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, case_start,\n\t\t\t\t\t                        str - case_start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintbuf_memappend_fast(tok->pb, case_start, 1 + str - case_start);\n\t\t\tstate = json_tokener_state_comment_end;\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_comment_eol:\n\t\t{\n\t\t\t/* Advance until we change state */\n\t\t\tconst char *case_start = str;\n\t\t\twhile (c != '\\n')\n\t\t\t{\n\t\t\t\tif (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, case_start,\n\t\t\t\t\t                        str - case_start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintbuf_memappend_fast(tok->pb, case_start, str - case_start);\n\t\t\tMC_DEBUG(\""json_tokener_comment: %s\\n\"", tok->pb->buf);\n\t\t\tstate = json_tokener_state_eatws;\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_comment_end:\n\t\t\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\t\t\tif (c == '/')\n\t\t\t{\n\t\t\t\tMC_DEBUG(\""json_tokener_comment: %s\\n\"", tok->pb->buf);\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate = json_tokener_state_comment;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_string:\n\t\t{\n\t\t\t/* Advance until we change state */\n\t\t\tconst char *case_start = str;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (c == tok->quote_char)\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, case_start,\n\t\t\t\t\t                        str - case_start);\n\t\t\t\t\tcurrent =\n\t\t\t\t\t    json_object_new_string_len(tok->pb->buf, tok->pb->bpos);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (c == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, case_start,\n\t\t\t\t\t                        str - case_start);\n\t\t\t\t\tsaved_state = json_tokener_state_string;\n\t\t\t\t\tstate = json_tokener_state_string_escape;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, case_start,\n\t\t\t\t\t                        str - case_start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_string_escape:\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase '\""':\n\t\t\tcase '\\\\':\n\t\t\tcase '/':\n\t\t\t\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\t\t\t\tstate = saved_state;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\tcase 'n':\n\t\t\tcase 'r':\n\t\t\tcase 't':\n\t\t\tcase 'f':\n\t\t\t\tif (c == 'b')\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, \""\\b\"", 1);\n\t\t\t\telse if (c == 'n')\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, \""\\n\"", 1);\n\t\t\t\telse if (c == 'r')\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, \""\\r\"", 1);\n\t\t\t\telse if (c == 't')\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, \""\\t\"", 1);\n\t\t\t\telse if (c == 'f')\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, \""\\f\"", 1);\n\t\t\t\tstate = saved_state;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\ttok->ucs_char = 0;\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tstate = json_tokener_state_escape_unicode;\n\t\t\t\tbreak;\n\t\t\tdefault: tok->err = json_tokener_error_parse_string; goto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_escape_unicode:\n\t\t{\n\t\t\tunsigned int got_hi_surrogate = 0;\n\n\t\t\t/* Handle a 4-byte sequence, or two sequences if a surrogate pair */\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (c && strchr(json_hex_chars, c))\n\t\t\t\t{\n\t\t\t\t\ttok->ucs_char += ((unsigned int)jt_hexdigit(c)\n\t\t\t\t\t                  << ((3 - tok->st_pos++) * 4));\n\t\t\t\t\tif (tok->st_pos == 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char unescaped_utf[4];\n\n\t\t\t\t\t\tif (got_hi_surrogate)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IS_LOW_SURROGATE(tok->ucs_char))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Recalculate the ucs_char, then fall thru to process normally */\n\t\t\t\t\t\t\t\ttok->ucs_char =\n\t\t\t\t\t\t\t\t    DECODE_SURROGATE_PAIR(\n\t\t\t\t\t\t\t\t        got_hi_surrogate,\n\t\t\t\t\t\t\t\t        tok->ucs_char);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Hi surrogate was not followed by a low surrogate */\n\t\t\t\t\t\t\t\t/* Replace the hi and process the rest normally */\n\t\t\t\t\t\t\t\tprintbuf_memappend_fast(\n\t\t\t\t\t\t\t\t    tok->pb,\n\t\t\t\t\t\t\t\t    (char *)utf8_replacement_char,\n\t\t\t\t\t\t\t\t    3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgot_hi_surrogate = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tok->ucs_char < 0x80)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunescaped_utf[0] = tok->ucs_char;\n\t\t\t\t\t\t\tprintbuf_memappend_fast(\n\t\t\t\t\t\t\t    tok->pb, (char *)unescaped_utf, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (tok->ucs_char < 0x800)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunescaped_utf[0] =\n\t\t\t\t\t\t\t    0xc0 | (tok->ucs_char >> 6);\n\t\t\t\t\t\t\tunescaped_utf[1] =\n\t\t\t\t\t\t\t    0x80 | (tok->ucs_char & 0x3f);\n\t\t\t\t\t\t\tprintbuf_memappend_fast(\n\t\t\t\t\t\t\t    tok->pb, (char *)unescaped_utf, 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (IS_HIGH_SURROGATE(tok->ucs_char))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Got a high surrogate.  Remember it and look for\n\t\t\t\t\t\t\t * the beginning of another sequence, which\n\t\t\t\t\t\t\t * should be the low surrogate.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tgot_hi_surrogate = tok->ucs_char;\n\t\t\t\t\t\t\t/* Not at end, and the next two chars should be \""\\u\"" */\n\t\t\t\t\t\t\tif ((len == -1 ||\n\t\t\t\t\t\t\t     len > (tok->char_offset + 2)) &&\n\t\t\t\t\t\t\t    // str[0] != '0' &&  // implied by json_hex_chars, above.\n\t\t\t\t\t\t\t    (str[1] == '\\\\') && (str[2] == 'u'))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Advance through the 16 bit surrogate, and move\n\t\t\t\t\t\t\t\t * on to the next sequence. The next step is to\n\t\t\t\t\t\t\t\t * process the following characters.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tif (!ADVANCE_CHAR(str, tok) ||\n\t\t\t\t\t\t\t\t    !ADVANCE_CHAR(str, tok))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tprintbuf_memappend_fast(\n\t\t\t\t\t\t\t\t\t    tok->pb,\n\t\t\t\t\t\t\t\t\t    (char *)\n\t\t\t\t\t\t\t\t\t        utf8_replacement_char,\n\t\t\t\t\t\t\t\t\t    3);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/* Advance to the first char of the next sequence and\n\t\t\t\t\t\t\t\t * continue processing with the next sequence.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tif (!ADVANCE_CHAR(str, tok) ||\n\t\t\t\t\t\t\t\t    !PEEK_CHAR(c, tok))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tprintbuf_memappend_fast(\n\t\t\t\t\t\t\t\t\t    tok->pb,\n\t\t\t\t\t\t\t\t\t    (char *)\n\t\t\t\t\t\t\t\t\t        utf8_replacement_char,\n\t\t\t\t\t\t\t\t\t    3);\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttok->ucs_char = 0;\n\t\t\t\t\t\t\t\ttok->st_pos = 0;\n\t\t\t\t\t\t\t\t/* other json_tokener_state_escape_unicode */\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Got a high surrogate without another sequence following\n\t\t\t\t\t\t\t\t * it.  Put a replacement char in for the hi surrogate\n\t\t\t\t\t\t\t\t * and pretend we finished.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tprintbuf_memappend_fast(\n\t\t\t\t\t\t\t\t    tok->pb,\n\t\t\t\t\t\t\t\t    (char *)utf8_replacement_char,\n\t\t\t\t\t\t\t\t    3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (IS_LOW_SURROGATE(tok->ucs_char))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Got a low surrogate not preceded by a high */\n\t\t\t\t\t\t\tprintbuf_memappend_fast(\n\t\t\t\t\t\t\t    tok->pb, (char *)utf8_replacement_char,\n\t\t\t\t\t\t\t    3);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (tok->ucs_char < 0x10000)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunescaped_utf[0] =\n\t\t\t\t\t\t\t    0xe0 | (tok->ucs_char >> 12);\n\t\t\t\t\t\t\tunescaped_utf[1] =\n\t\t\t\t\t\t\t    0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t\t\t\t\t\tunescaped_utf[2] =\n\t\t\t\t\t\t\t    0x80 | (tok->ucs_char & 0x3f);\n\t\t\t\t\t\t\tprintbuf_memappend_fast(\n\t\t\t\t\t\t\t    tok->pb, (char *)unescaped_utf, 3);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (tok->ucs_char < 0x110000)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunescaped_utf[0] =\n\t\t\t\t\t\t\t    0xf0 | ((tok->ucs_char >> 18) & 0x07);\n\t\t\t\t\t\t\tunescaped_utf[1] =\n\t\t\t\t\t\t\t    0x80 | ((tok->ucs_char >> 12) & 0x3f);\n\t\t\t\t\t\t\tunescaped_utf[2] =\n\t\t\t\t\t\t\t    0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t\t\t\t\t\tunescaped_utf[3] =\n\t\t\t\t\t\t\t    0x80 | (tok->ucs_char & 0x3f);\n\t\t\t\t\t\t\tprintbuf_memappend_fast(\n\t\t\t\t\t\t\t    tok->pb, (char *)unescaped_utf, 4);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Don't know what we got--insert the replacement char */\n\t\t\t\t\t\t\tprintbuf_memappend_fast(\n\t\t\t\t\t\t\t    tok->pb, (char *)utf8_replacement_char,\n\t\t\t\t\t\t\t    3);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate = saved_state;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_parse_string;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\t/* Clean up any pending chars */\n\t\t\t\t\tif (got_hi_surrogate)\n\t\t\t\t\t\tprintbuf_memappend_fast(\n\t\t\t\t\t\t    tok->pb, (char *)utf8_replacement_char, 3);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_boolean:\n\t\t{\n\t\t\tint size1, size2;\n\t\t\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\t\t\tsize1 = json_min(tok->st_pos + 1, json_true_str_len);\n\t\t\tsize2 = json_min(tok->st_pos + 1, json_false_str_len);\n\t\t\tif ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t\t\t     strncasecmp(json_true_str, tok->pb->buf, size1) == 0) ||\n\t\t\t    (strncmp(json_true_str, tok->pb->buf, size1) == 0))\n\t\t\t{\n\t\t\t\tif (tok->st_pos == json_true_str_len)\n\t\t\t\t{\n\t\t\t\t\tcurrent = json_object_new_boolean(1);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tgoto redo_char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t\t\t          strncasecmp(json_false_str, tok->pb->buf, size2) == 0) ||\n\t\t\t         (strncmp(json_false_str, tok->pb->buf, size2) == 0))\n\t\t\t{\n\t\t\t\tif (tok->st_pos == json_false_str_len)\n\t\t\t\t{\n\t\t\t\t\tcurrent = json_object_new_boolean(0);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tgoto redo_char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_boolean;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttok->st_pos++;\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_number:\n\t\t{\n\t\t\t/* Advance until we change state */\n\t\t\tconst char *case_start = str;\n\t\t\tint case_len = 0;\n\t\t\tint is_exponent = 0;\n\t\t\tint negativesign_next_possible_location = 1;\n\t\t\twhile (c && strchr(json_number_chars, c))\n\t\t\t{\n\t\t\t\t++case_len;\n\n\t\t\t\t/* non-digit characters checks */\n\t\t\t\t/* note: since the main loop condition to get here was\n\t\t\t\t * an input starting with 0-9 or '-', we are\n\t\t\t\t * protected from input starting with '.' or\n\t\t\t\t * e/E.\n\t\t\t\t */\n\t\t\t\tif (c == '.')\n\t\t\t\t{\n\t\t\t\t\tif (tok->is_double != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* '.' can only be found once, and out of the exponent part.\n\t\t\t\t\t\t * Thus, if the input is already flagged as double, it\n\t\t\t\t\t\t * is invalid.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\ttok->is_double = 1;\n\t\t\t\t}\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t{\n\t\t\t\t\tif (is_exponent != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* only one exponent possible */\n\t\t\t\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tis_exponent = 1;\n\t\t\t\t\ttok->is_double = 1;\n\t\t\t\t\t/* the exponent part can begin with a negative sign */\n\t\t\t\t\tnegativesign_next_possible_location = case_len + 1;\n\t\t\t\t}\n\t\t\t\tif (c == '-' && case_len != negativesign_next_possible_location)\n\t\t\t\t{\n\t\t\t\t\t/* If the negative sign is not where expected (ie\n\t\t\t\t\t * start of input or start of exponent part), the\n\t\t\t\t\t * input is invalid.\n\t\t\t\t\t */\n\t\t\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, case_start, case_len);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (case_len > 0)\n\t\t\t\tprintbuf_memappend_fast(tok->pb, case_start, case_len);\n\n\t\t\t// Check for -Infinity\n\t\t\tif (tok->pb->buf[0] == '-' && case_len <= 1 && (c == 'i' || c == 'I'))\n\t\t\t{\n\t\t\t\tstate = json_tokener_state_inf;\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tgoto redo_char;\n\t\t\t}\n\t\t}\n\t\t\t{\n\t\t\t\tint64_t num64;\n\t\t\t\tuint64_t numuint64;\n\t\t\t\tdouble numd;\n\t\t\t\tif (!tok->is_double && tok->pb->buf[0] == '-' &&\n\t\t\t\t    json_parse_int64(tok->pb->buf, &num64) == 0)\n\t\t\t\t{\n\t\t\t\t\tcurrent = json_object_new_int64(num64);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\telse if (!tok->is_double && tok->pb->buf[0] != '-' &&\n\t\t\t\t         json_parse_uint64(tok->pb->buf, &numuint64) == 0)\n\t\t\t\t{\n\t\t\t\t\tif (numuint64 && tok->pb->buf[0] == '0' &&\n\t\t\t\t\t    (tok->flags & JSON_TOKENER_STRICT))\n\t\t\t\t\t{\n\t\t\t\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (numuint64 <= INT64_MAX)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum64 = (uint64_t)numuint64;\n\t\t\t\t\t\tcurrent = json_object_new_int64(num64);\n\t\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrent = json_object_new_uint64(numuint64);\n\t\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (tok->is_double &&\n\t\t\t\t         json_parse_double(tok->pb->buf, &numd) == 0)\n\t\t\t\t{\n\t\t\t\t\tcurrent = json_object_new_double_s(numd, tok->pb->buf);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\tgoto redo_char;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_array_after_sep:\n\t\tcase json_tokener_state_array:\n\t\t\tif (c == ']')\n\t\t\t{\n\t\t\t\tif (state == json_tokener_state_array_after_sep &&\n\t\t\t\t    (tok->flags & JSON_TOKENER_STRICT))\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (tok->depth >= tok->max_depth - 1)\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_depth;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tstate = json_tokener_state_array_add;\n\t\t\t\ttok->depth++;\n\t\t\t\tjson_tokener_reset_level(tok, tok->depth);\n\t\t\t\tgoto redo_char;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_array_add:\n\t\t\tif (json_object_array_add(current, obj) != 0)\n\t\t\t\tgoto out;\n\t\t\tsaved_state = json_tokener_state_array_sep;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\n\t\tcase json_tokener_state_array_sep:\n\t\t\tif (c == ']')\n\t\t\t{\n\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse if (c == ',')\n\t\t\t{\n\t\t\t\tsaved_state = json_tokener_state_array_after_sep;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_array;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_object_field_start:\n\t\tcase json_tokener_state_object_field_start_after_sep:\n\t\t\tif (c == '}')\n\t\t\t{\n\t\t\t\tif (state == json_tokener_state_object_field_start_after_sep &&\n\t\t\t\t    (tok->flags & JSON_TOKENER_STRICT))\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse if (c == '\""' || c == '\\'')\n\t\t\t{\n\t\t\t\ttok->quote_char = c;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\tstate = json_tokener_state_object_field;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_object_key_name;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_object_field:\n\t\t{\n\t\t\t/* Advance until we change state */\n\t\t\tconst char *case_start = str;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (c == tok->quote_char)\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, case_start,\n\t\t\t\t\t                        str - case_start);\n\t\t\t\t\tobj_field_name = strdup(tok->pb->buf);\n\t\t\t\t\tsaved_state = json_tokener_state_object_field_end;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (c == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, case_start,\n\t\t\t\t\t                        str - case_start);\n\t\t\t\t\tsaved_state = json_tokener_state_object_field;\n\t\t\t\t\tstate = json_tokener_state_string_escape;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_fast(tok->pb, case_start,\n\t\t\t\t\t                        str - case_start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_object_field_end:\n\t\t\tif (c == ':')\n\t\t\t{\n\t\t\t\tsaved_state = json_tokener_state_object_value;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_object_key_sep;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_object_value:\n\t\t\tif (tok->depth >= tok->max_depth - 1)\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_depth;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstate = json_tokener_state_object_value_add;\n\t\t\ttok->depth++;\n\t\t\tjson_tokener_reset_level(tok, tok->depth);\n\t\t\tgoto redo_char;\n\n\t\tcase json_tokener_state_object_value_add:\n\t\t\tjson_object_object_add(current, obj_field_name, obj);\n\t\t\tfree(obj_field_name);\n\t\t\tobj_field_name = NULL;\n\t\t\tsaved_state = json_tokener_state_object_sep;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\n\t\tcase json_tokener_state_object_sep:\n\t\t\t/* { */\n\t\t\tif (c == '}')\n\t\t\t{\n\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse if (c == ',')\n\t\t\t{\n\t\t\t\tsaved_state = json_tokener_state_object_field_start_after_sep;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_object_value_sep;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!ADVANCE_CHAR(str, tok))\n\t\t\tgoto out;\n\t} /* while(PEEK_CHAR) */\n\nout:\n\tif ((tok->flags & JSON_TOKENER_VALIDATE_UTF8) && (nBytes != 0))\n\t{\n\t\ttok->err = json_tokener_error_parse_utf8_string;\n\t}\n\tif (c && (state == json_tokener_state_finish) && (tok->depth == 0) &&\n\t    (tok->flags & (JSON_TOKENER_STRICT|JSON_TOKENER_ALLOW_TRAILING_CHARS)) == JSON_TOKENER_STRICT)\n\t{\n\t\t/* unexpected char after JSON data */\n\t\ttok->err = json_tokener_error_parse_unexpected;\n\t}\n\tif (!c)\n\t{\n\t\t/* We hit an eof char (0) */\n\t\tif (state != json_tokener_state_finish && saved_state != json_tokener_state_finish)\n\t\t\ttok->err = json_tokener_error_parse_eof;\n\t}\n\n#ifdef HAVE_USELOCALE\n\tuselocale(oldlocale);\n\tfreelocale(newloc);\n#elif defined(HAVE_SETLOCALE)\n\tsetlocale(LC_NUMERIC, oldlocale);\n\tfree(oldlocale);\n#endif\n\n\tif (tok->err == json_tokener_success)\n\t{\n\t\tjson_object *ret = json_object_get(current);\n\t\tint ii;\n\n\t\t/* Partially reset, so we parse additional objects on subsequent calls. */\n\t\tfor (ii = tok->depth; ii >= 0; ii--)\n\t\t\tjson_tokener_reset_level(tok, ii);\n\t\treturn ret;\n\t}\n\n\tMC_DEBUG(\""json_tokener_parse_ex: error %s at offset %d\\n\"", json_tokener_errors[tok->err],\n\t         tok->char_offset);\n\treturn NULL;\n}\n"", ""start_line"": 245, ""end_line"": 1166, ""full_name"": ""json_tokener_parse_ex"", ""file_path"": ""json_tokener.c""}]}, {""source"": ""code_info(file:json_tokener.c, lines:200-400)"", ""result"": ""}\n\n#define state tok->stack[tok->depth].state\n#define saved_state tok->stack[tok->depth].saved_state\n#define current tok->stack[tok->depth].current\n#define obj_field_name tok->stack[tok->depth].obj_field_name\n\n/* Optimization:\n * json_tokener_parse_ex() consumed a lot of CPU in its main loop,\n * iterating character-by character.  A large performance boost is\n * achieved by using tighter loops to locally handle units such as\n * comments and strings.  Loops that handle an entire token within\n * their scope also gather entire strings and pass them to\n * printbuf_memappend() in a single call, rather than calling\n * printbuf_memappend() one char at a time.\n *\n * PEEK_CHAR() and ADVANCE_CHAR() macros are used for code that is\n * common to both the main loop and the tighter loops.\n */\n\n/* PEEK_CHAR(dest, tok) macro:\n *   Peeks at the current char and stores it in dest.\n *   Returns 1 on success, sets tok->err and returns 0 if no more chars.\n *   Implicit inputs:  str, len vars\n */\n#define PEEK_CHAR(dest, tok)                                                 \\\n\t(((tok)->char_offset == len)                                         \\\n\t     ? (((tok)->depth == 0 && state == json_tokener_state_eatws &&   \\\n\t         saved_state == json_tokener_state_finish)                   \\\n\t            ? (((tok)->err = json_tokener_success), 0)               \\\n\t            : (((tok)->err = json_tokener_continue), 0))             \\\n\t     : (((tok->flags & JSON_TOKENER_VALIDATE_UTF8) &&                \\\n\t         (!json_tokener_validate_utf8(*str, nBytesp)))               \\\n\t            ? ((tok->err = json_tokener_error_parse_utf8_string), 0) \\\n\t            : (((dest) = *str), 1)))\n\n/* ADVANCE_CHAR() macro:\n *   Increments str & tok->char_offset.\n *   For convenience of existing conditionals, returns the old value of c (0 on eof)\n *   Implicit inputs:  c var\n */\n#define ADVANCE_CHAR(str, tok) (++(str), ((tok)->char_offset)++, c)\n\n/* End optimization macro defs */\n\nstruct json_object *json_tokener_parse_ex(struct json_tokener *tok, const char *str, int len)\n{\n\tstruct json_object *obj = NULL;\n\tchar c = '\\1';\n\tunsigned int nBytes = 0;\n\tunsigned int *nBytesp = &nBytes;\n\n#ifdef HAVE_USELOCALE\n\tlocale_t oldlocale = uselocale(NULL);\n\tlocale_t newloc;\n#elif defined(HAVE_SETLOCALE)\n\tchar *oldlocale = NULL;\n#endif\n\n\ttok->char_offset = 0;\n\ttok->err = json_tokener_success;\n\n\t/* this interface is presently not 64-bit clean due to the int len argument\n\t * and the internal printbuf interface that takes 32-bit int len arguments\n\t * so the function limits the maximum string size to INT32_MAX (2GB).\n\t * If the function is called with len == -1 then strlen is called to check\n\t * the string length is less than INT32_MAX (2GB)\n\t */\n\tif ((len < -1) || (len == -1 && strlen(str) > INT32_MAX))\n\t{\n\t\ttok->err = json_tokener_error_size;\n\t\treturn NULL;\n\t}\n\n#ifdef HAVE_USELOCALE\n\t{\n\t\tlocale_t duploc = duplocale(oldlocale);\n\t\tnewloc = newlocale(LC_NUMERIC_MASK, \""C\"", duploc);\n\t\tif (newloc == NULL)\n\t\t{\n\t\t\tfreelocale(duploc);\n\t\t\treturn NULL;\n\t\t}\n\t\tuselocale(newloc);\n\t}\n#elif defined(HAVE_SETLOCALE)\n\t{\n\t\tchar *tmplocale;\n\t\ttmplocale = setlocale(LC_NUMERIC, NULL);\n\t\tif (tmplocale)\n\t\t\toldlocale = strdup(tmplocale);\n\t\tsetlocale(LC_NUMERIC, \""C\"");\n\t}\n#endif\n\n\twhile (PEEK_CHAR(c, tok))\n\t{\n\n\tredo_char:\n\t\tswitch (state)\n\t\t{\n\n\t\tcase json_tokener_state_eatws:\n\t\t\t/* Advance until we change state */\n\t\t\twhile (isspace((unsigned char)c))\n\t\t\t{\n\t\t\t\tif ((!ADVANCE_CHAR(str, tok)) || (!PEEK_CHAR(c, tok)))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (c == '/' && !(tok->flags & JSON_TOKENER_STRICT))\n\t\t\t{\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\t\t\t\tstate = json_tokener_state_comment_start;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate = saved_state;\n\t\t\t\tgoto redo_char;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_start:\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase '{':\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\tsaved_state = json_tokener_state_object_field_start;\n\t\t\t\tcurrent = json_object_new_object();\n\t\t\t\tif (current == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\tsaved_state = json_tokener_state_array;\n\t\t\t\tcurrent = json_object_new_array();\n\t\t\t\tif (current == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\tcase 'i':\n\t\t\t\tstate = json_tokener_state_inf;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tcase 'N':\n\t\t\tcase 'n':\n\t\t\t\tstate = json_tokener_state_null; // or NaN\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tcase '\\'':\n\t\t\t\tif (tok->flags & JSON_TOKENER_STRICT)\n\t\t\t\t{\n\t\t\t\t\t/* in STRICT mode only double-quote are allowed */\n\t\t\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/* FALLTHRU */\n\t\t\tcase '\""':\n\t\t\t\tstate = json_tokener_state_string;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->quote_char = c;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\tcase 't':\n\t\t\tcase 'F':\n\t\t\tcase 'f':\n\t\t\t\tstate = json_tokener_state_boolean;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\tcase '-':\n\t\t\t\tstate = json_tokener_state_number;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->is_double = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tdefault: tok->err = json_tokener_error_parse_unexpected; goto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_finish:\n\t\t\tif (tok->depth == 0)\n\t\t\t\tgoto out;\n\t\t\tobj = json_object_get(current);\n\t\t\tjson_tokener_reset_level(tok, tok->depth);\n\t\t\ttok->depth--;\n\t\t\tgoto redo_char;\n\n\t\tcase json_tokener_state_inf: /* aka starts with 'i' (or 'I', or \""-i\"", or \""-I\"") */\n\t\t{\n""}, {""source"": ""func_info(file:json_object.c, func:json_object_to_json_string)"", ""result"": [{""code"": ""const char *json_object_to_json_string(struct json_object *jso)\n{\n\treturn json_object_to_json_string_ext(jso, JSON_C_TO_STRING_SPACED);\n}"", ""start_line"": 369, ""end_line"": 372, ""full_name"": ""json_object_to_json_string"", ""file_path"": ""json_object.c""}]}, {""source"": ""code_info(file:json_tokener.c, lines:1167-1300)"", ""result"": ""\nstatic json_bool json_tokener_validate_utf8(const char c, unsigned int *nBytes)\n{\n\tunsigned char chr = c;\n\tif (*nBytes == 0)\n\t{\n\t\tif (chr >= 0x80)\n\t\t{\n\t\t\tif ((chr & 0xe0) == 0xc0)\n\t\t\t\t*nBytes = 1;\n\t\t\telse if ((chr & 0xf0) == 0xe0)\n\t\t\t\t*nBytes = 2;\n\t\t\telse if ((chr & 0xf8) == 0xf0)\n\t\t\t\t*nBytes = 3;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif ((chr & 0xC0) != 0x80)\n\t\t\treturn 0;\n\t\t(*nBytes)--;\n\t}\n\treturn 1;\n}\n\nvoid json_tokener_set_flags(struct json_tokener *tok, int flags)\n{\n\ttok->flags = flags;\n}\n\nsize_t json_tokener_get_parse_end(struct json_tokener *tok)\n{\n\tassert(tok->char_offset >= 0); /* Drop this line when char_offset becomes a size_t */\n\treturn (size_t)tok->char_offset;\n}\n""}]","Root cause chain:\n1. Large JSON input parsed by json_tokener_parse_ex (json_tokener.c:245-1166) creates json_object instances.\n2. Serialization via json_object_to_json_string (json_object.c:369-372) triggers json_object_object_to_json_string (json_object.c:391-413).\n3. json_escape_str (json_object.c:120-184) repeatedly calls printbuf_memappend (printbuf.c:86) with large 'size' values.\n4. Integer overflow in 'p->bpos + size' (printbuf.c:86) causes printbuf_extend (printbuf.c:66-80) to under-allocate buffers, leading to out-of-bounds writes.",0.95,./github/other_context/CVE-2020-12762
65,CVE-2020-15158,CWE-191,c_cpp,"In libIEC61850 before version 1.4.3, when a message with COTP message length field with value < 4 is received an integer underflow will happen leading to heap buffer overflow. This can cause an application crash or on some platforms even the execution of remote code. If your application is used in open networks or there are untrusted nodes in the network it is highly recommend to apply the patch. This was patched with commit 033ab5b. Users of version 1.4.x should upgrade to version 1.4.3 when available. As a workaround changes of commit 033ab5b can be applied to older versions.",https://github.com/mz-automation/libiec61850/commit/033ab5b6488250c8c3b838f25a7cbc3e099230bb,- COTP: fixed possible heap buffer overflow when handling message with invalid (zero) value in length field (#250),1,"[{""func_name"": ""CotpConnection_readToTpktBuffer"", ""file_path"": ""src/mms/iso_cotp/cotp.c"", ""func_code"": ""TpktState\nCotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n\n    assert (bufferSize > 4);\n\n    int readBytes;\n\n    if (bufPos < 4) {\n\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n\n        if (readBytes < 0)\n            goto exit_closed;\n\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\""TPKT: read %i bytes from socket\\n\"", readBytes);\n        }\n\n        bufPos += readBytes;\n\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n\n                if (DEBUG_COTP)\n                    printf(\""TPKT: header complete (msg size = %i)\\n\"", self->packetSize);\n\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\""TPKT: packet too large\\n\"");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\""TPKT: failed to decode TPKT header.\\n\"");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n\n    if (readBytes < 0)\n        goto exit_closed;\n\n    bufPos += readBytes;\n\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n\n    if (DEBUG_COTP) printf(\""TPKT: message complete (size = %i)\\n\"", self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\n\nexit_closed:\n    if (DEBUG_COTP) printf(\""TPKT: socket closed or socket error\\n\"");\n    return TPKT_ERROR;\n\nexit_error:\n    if (DEBUG_COTP) printf(\""TPKT: Error parsing message\\n\"");\n    return TPKT_ERROR;\n\nexit_waiting:\n\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\""TPKT: waiting (read %i of %i)\\n\"", bufPos, self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}"", ""target"": 0}]","[{""func_name"": ""CotpConnection_readToTpktBuffer"", ""file_path"": ""src/mms/iso_cotp/cotp.c"", ""func_code"": ""TpktState\nCotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n\n    assert (bufferSize > 4);\n\n    int readBytes;\n\n    if (bufPos < 4) {\n\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n\n        if (readBytes < 0)\n            goto exit_closed;\n\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\""TPKT: read %i bytes from socket\\n\"", readBytes);\n        }\n\n        bufPos += readBytes;\n\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n\n                if (DEBUG_COTP)\n                    printf(\""TPKT: header complete (msg size = %i)\\n\"", self->packetSize);\n\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\""TPKT: packet too large\\n\"");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\""TPKT: failed to decode TPKT header.\\n\"");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n\n    if (self->packetSize <= bufPos)\n        goto exit_error;\n\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n\n    if (readBytes < 0)\n        goto exit_closed;\n\n    bufPos += readBytes;\n\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n\n    if (DEBUG_COTP) printf(\""TPKT: message complete (size = %i)\\n\"", self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\n\nexit_closed:\n    if (DEBUG_COTP) printf(\""TPKT: socket closed or socket error\\n\"");\n    return TPKT_ERROR;\n\nexit_error:\n    if (DEBUG_COTP) printf(\""TPKT: Error parsing message\\n\"");\n    return TPKT_ERROR;\n\nexit_waiting:\n\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\""TPKT: waiting (read %i of %i)\\n\"", bufPos, self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}""}]","{""value"": 2, ""caller"": 1}","[{""source"": ""value_info(file:cotp.c, value:self->packetSize)"", ""result"": {""value_trace"": [{""full_code"": ""self->packetSize = 0"", ""line"": 478, ""func_name"": ""CotpConnection_init""}, {""full_code"": ""self->packetSize = 0"", ""line"": 652, ""func_name"": ""CotpConnection_parseIncomingMessage""}, {""full_code"": ""self->packetSize = (buffer[2] * 0x100) + buffer[3]"", ""line"": 704, ""func_name"": ""CotpConnection_readToTpktBuffer""}], ""struct_var"": ""self"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:cotp.c, value:bufPos)"", ""result"": {""value_trace"": [{""full_code"": ""bufPos = self->writeBuffer->size"", ""line"": 68, ""func_name"": ""writeOptions""}, {""full_code"": ""bufPos++"", ""line"": 75, ""func_name"": ""writeOptions""}, {""full_code"": ""bufPos++"", ""line"": 76, ""func_name"": ""writeOptions""}], ""struct_var"": ""bufPos"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""caller_info(file:cotp.c, func:CotpConnection_readToTpktBuffer)"", ""result"": [{""call_line"": 377, ""call_code"": ""CotpConnection_readToTpktBuffer(self->cotpConnection)"", ""caller_code"": ""bool\nIsoClientConnection_handleConnection(IsoClientConnection self)\n{\n    Semaphore_wait(self->tickMutex);\n\n    bool waits = false;\n\n    eIsoClientInternalState currentState = getIntState(self);\n\n    eIsoClientInternalState nextState = currentState;\n\n    switch (currentState) {\n\n    case INT_STATE_IDLE:\n    case INT_STATE_ERROR:\n        waits = true;\n        break;\n\n    case INT_STATE_TCP_CONNECTING:\n        {\n            SocketState socketState = Socket_checkAsyncConnectState(self->socket);\n\n            if (socketState == SOCKET_STATE_CONNECTED) {\n                if (sendConnectionRequestMessage(self)) {\n                    self->nextReadTimeout = Hal_getTimeInMs() + self->readTimeoutInMs;\n                    nextState = INT_STATE_WAIT_FOR_COTP_CONNECT_RESP;\n                }\n                else {\n                    IsoClientConnection_releaseTransmitBuffer(self);\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n            }\n            else if (socketState == SOCKET_STATE_FAILED) {\n                IsoClientConnection_releaseTransmitBuffer(self);\n                self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else {\n\n                /* check connect timeout */\n\n                uint64_t currentTime = Hal_getTimeInMs();\n\n                if (currentTime > self->nextReadTimeout) {\n                    IsoClientConnection_releaseTransmitBuffer(self);\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n                else {\n                    waits = true;\n                }\n\n            }\n\n        }\n        break;\n\n    case INT_STATE_WAIT_FOR_COTP_CONNECT_RESP:\n        {\n            uint64_t currentTime = Hal_getTimeInMs();\n\n            if (currentTime > self->nextReadTimeout) {\n\n                if (DEBUG_ISO_CLIENT)\n                    printf(\""Timeout waiting for COTP CR\\n\"");\n\n                IsoClientConnection_releaseTransmitBuffer(self);\n\n                self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else {\n\n                TpktState packetState = CotpConnection_readToTpktBuffer(self->cotpConnection);\n\n                if (packetState == TPKT_PACKET_COMPLETE) {\n\n                    CotpIndication cotpIndication = CotpConnection_parseIncomingMessage(self->cotpConnection);\n\n                    if (cotpIndication != COTP_CONNECT_INDICATION) {\n                        if (DEBUG_ISO_CLIENT)\n                            printf(\""Unexpected COTP state (%i)\\n\"", cotpIndication);\n\n                        IsoClientConnection_releaseTransmitBuffer(self);\n\n                        self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                        nextState = INT_STATE_CLOSE_ON_ERROR;\n                    }\n                    else {\n                        sendAcseInitiateRequest(self);\n\n                        self->nextReadTimeout = Hal_getTimeInMs() + self->readTimeoutInMs;\n\n                        nextState = INT_STATE_WAIT_FOR_ACSE_RESP;\n                    }\n                }\n                else if (packetState == TPKT_ERROR) {\n                    if (DEBUG_ISO_CLIENT)\n                        printf(\""Error receiving COTP message\\n\"");\n\n                    IsoClientConnection_releaseTransmitBuffer(self);\n\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n                else {\n                    waits = true;\n                }\n\n            }\n        }\n        break;\n\n    case INT_STATE_WAIT_FOR_ACSE_RESP:\n        {\n            uint64_t currentTime = Hal_getTimeInMs();\n\n            if (currentTime > self->nextReadTimeout) {\n\n                if (DEBUG_ISO_CLIENT)\n                    printf(\""Timeout waiting for ACSE initiate response\\n\"");\n\n                self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else {\n\n                TpktState packetState = CotpConnection_readToTpktBuffer(self->cotpConnection);\n\n                if (packetState == TPKT_PACKET_COMPLETE) {\n\n                    CotpIndication cotpIndication = CotpConnection_parseIncomingMessage(self->cotpConnection);\n\n                    if (cotpIndication != COTP_DATA_INDICATION) {\n                        if (DEBUG_ISO_CLIENT)\n                            printf(\""Unexpected COTP state (%i)\\n\"", cotpIndication);\n\n                        self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                        nextState = INT_STATE_CLOSE_ON_ERROR;\n                    }\n                    else {\n\n                        /* parse ACSE response */\n\n                       IsoSessionIndication sessionIndication;\n\n                       sessionIndication =\n                               IsoSession_parseMessage(self->session, CotpConnection_getPayload(self->cotpConnection));\n\n                       if (sessionIndication != SESSION_CONNECT) {\n                           if (DEBUG_ISO_CLIENT)\n                               printf(\""IsoClientConnection_associate: no session connect indication\\n\"");\n\n                           self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                           nextState = INT_STATE_CLOSE_ON_ERROR;\n                       }\n                       else {\n\n                           if (IsoPresentation_parseAcceptMessage(self->presentation, IsoSession_getUserData(self->session)) == false) {\n\n                               if (DEBUG_ISO_CLIENT)\n                                   printf(\""IsoClientConnection_associate: no presentation ok indication\\n\"");\n\n                               self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                               nextState = INT_STATE_CLOSE_ON_ERROR;\n                           }\n                           else {\n\n                               AcseIndication acseIndication = AcseConnection_parseMessage(&(self->acseConnection), &self->presentation->nextPayload);\n\n                               if (acseIndication != ACSE_ASSOCIATE) {\n                                   if (DEBUG_ISO_CLIENT)\n                                       printf(\""IsoClientConnection_associate: no ACSE_ASSOCIATE indication\\n\"");\n\n                                   self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                                   nextState = INT_STATE_CLOSE_ON_ERROR;\n                               }\n                               else {\n\n                               }\n\n                           }\n\n                           ByteBuffer_wrap(self->receivePayloadBuffer, self->acseConnection.userDataBuffer,\n                                   self->acseConnection.userDataBufferSize, self->acseConnection.userDataBufferSize);\n\n                           setState(self, STATE_CONNECTED);\n                           nextState = INT_STATE_WAIT_FOR_DATA_MSG;\n\n                           self->callback(ISO_IND_ASSOCIATION_SUCCESS, self->callbackParameter, self->receivePayloadBuffer);\n\n                           CotpConnection_resetPayload(self->cotpConnection);\n                       }\n                    }\n                }\n                else if (packetState == TPKT_ERROR) {\n                    if (DEBUG_ISO_CLIENT)\n                        printf(\""Error receiving COTP message\\n\"");\n\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n                else {\n                    waits = true;\n                }\n\n            }\n        }\n        break;\n\n    case INT_STATE_WAIT_FOR_DATA_MSG:\n        {\n            TpktState packetState = CotpConnection_readToTpktBuffer(self->cotpConnection);\n\n            if (packetState == TPKT_ERROR) {\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else if (packetState == TPKT_PACKET_COMPLETE) {\n\n                CotpIndication cotpIndication = CotpConnection_parseIncomingMessage(self->cotpConnection);\n\n                switch (cotpIndication) {\n\n                case COTP_MORE_FRAGMENTS_FOLLOW:\n                    break;\n\n                case COTP_DISCONNECT_INDICATION:\n                    {\n                        nextState = INT_STATE_CLOSING_CONNECTION;\n                    }\n                    break;\n\n                case COTP_DATA_INDICATION:\n                    {\n                        if (DEBUG_ISO_CLIENT)\n                            printf(\""ISO_CLIENT_CONNECTION: parse message\\n\"");\n\n                        IsoSessionIndication sessionIndication =\n                                IsoSession_parseMessage(self->session,\n                                        CotpConnection_getPayload(self->cotpConnection));\n\n                        if (sessionIndication != SESSION_DATA) {\n                            if (DEBUG_ISO_CLIENT)\n                                printf(\""ISO_CLIENT_CONNECTION: Invalid session message\\n\"");\n\n                            nextState = INT_STATE_CLOSE_ON_ERROR;\n                        }\n                        else {\n\n                            if (!IsoPresentation_parseUserData(self->presentation, IsoSession_getUserData(self->session))) {\n\n                                if (DEBUG_ISO_CLIENT)\n                                    printf(\""ISO_CLIENT_CONNECTION: Invalid presentation message\\n\"");\n\n                                nextState = INT_STATE_CLOSE_ON_ERROR;\n                            }\n                            else {\n\n                                self->callback(ISO_IND_DATA, self->callbackParameter,\n                                        &(self->presentation->nextPayload));\n\n                                CotpConnection_resetPayload(self->cotpConnection);\n                            }\n                        }\n                    }\n                    break;\n\n                default:\n                    {\n                        nextState = INT_STATE_CLOSE_ON_ERROR;\n                    }\n                    break;\n\n                }\n            }\n            else {\n                waits = true;\n            }\n\n        }\n        break;\n\n    case INT_STATE_CLOSE_ON_ERROR:\n        {\n            setState(self, STATE_ERROR);\n\n            self->callback(ISO_IND_CLOSED, self->callbackParameter, NULL);;\n\n            releaseSocket(self);\n\n            nextState = INT_STATE_ERROR;\n        }\n        break;\n\n    case INT_STATE_CLOSING_CONNECTION:\n        {\n            setState(self, STATE_IDLE);\n\n            self->callback(ISO_IND_CLOSED, self->callbackParameter, NULL);;\n\n            releaseSocket(self);\n\n            nextState = INT_STATE_IDLE;\n        }\n        break;\n\n    default:\n\n        if (DEBUG_ISO_CLIENT)\n            printf(\""ISO_CLIENT_CONNECTION: Illegal state\\n\"");\n\n        break;\n\n    }\n\n    self->callback(ISO_IND_TICK, self->callbackParameter, NULL);\n\n    setIntState(self, nextState);\n\n    Semaphore_post(self->tickMutex);\n\n    return waits;\n}\n"", ""caller_start"": 302, ""file_path"": ""src/mms/iso_client/iso_client_connection.c""}, {""call_line"": 434, ""call_code"": ""CotpConnection_readToTpktBuffer(self->cotpConnection)"", ""caller_code"": ""bool\nIsoClientConnection_handleConnection(IsoClientConnection self)\n{\n    Semaphore_wait(self->tickMutex);\n\n    bool waits = false;\n\n    eIsoClientInternalState currentState = getIntState(self);\n\n    eIsoClientInternalState nextState = currentState;\n\n    switch (currentState) {\n\n    case INT_STATE_IDLE:\n    case INT_STATE_ERROR:\n        waits = true;\n        break;\n\n    case INT_STATE_TCP_CONNECTING:\n        {\n            SocketState socketState = Socket_checkAsyncConnectState(self->socket);\n\n            if (socketState == SOCKET_STATE_CONNECTED) {\n                if (sendConnectionRequestMessage(self)) {\n                    self->nextReadTimeout = Hal_getTimeInMs() + self->readTimeoutInMs;\n                    nextState = INT_STATE_WAIT_FOR_COTP_CONNECT_RESP;\n                }\n                else {\n                    IsoClientConnection_releaseTransmitBuffer(self);\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n            }\n            else if (socketState == SOCKET_STATE_FAILED) {\n                IsoClientConnection_releaseTransmitBuffer(self);\n                self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else {\n\n                /* check connect timeout */\n\n                uint64_t currentTime = Hal_getTimeInMs();\n\n                if (currentTime > self->nextReadTimeout) {\n                    IsoClientConnection_releaseTransmitBuffer(self);\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n                else {\n                    waits = true;\n                }\n\n            }\n\n        }\n        break;\n\n    case INT_STATE_WAIT_FOR_COTP_CONNECT_RESP:\n        {\n            uint64_t currentTime = Hal_getTimeInMs();\n\n            if (currentTime > self->nextReadTimeout) {\n\n                if (DEBUG_ISO_CLIENT)\n                    printf(\""Timeout waiting for COTP CR\\n\"");\n\n                IsoClientConnection_releaseTransmitBuffer(self);\n\n                self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else {\n\n                TpktState packetState = CotpConnection_readToTpktBuffer(self->cotpConnection);\n\n                if (packetState == TPKT_PACKET_COMPLETE) {\n\n                    CotpIndication cotpIndication = CotpConnection_parseIncomingMessage(self->cotpConnection);\n\n                    if (cotpIndication != COTP_CONNECT_INDICATION) {\n                        if (DEBUG_ISO_CLIENT)\n                            printf(\""Unexpected COTP state (%i)\\n\"", cotpIndication);\n\n                        IsoClientConnection_releaseTransmitBuffer(self);\n\n                        self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                        nextState = INT_STATE_CLOSE_ON_ERROR;\n                    }\n                    else {\n                        sendAcseInitiateRequest(self);\n\n                        self->nextReadTimeout = Hal_getTimeInMs() + self->readTimeoutInMs;\n\n                        nextState = INT_STATE_WAIT_FOR_ACSE_RESP;\n                    }\n                }\n                else if (packetState == TPKT_ERROR) {\n                    if (DEBUG_ISO_CLIENT)\n                        printf(\""Error receiving COTP message\\n\"");\n\n                    IsoClientConnection_releaseTransmitBuffer(self);\n\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n                else {\n                    waits = true;\n                }\n\n            }\n        }\n        break;\n\n    case INT_STATE_WAIT_FOR_ACSE_RESP:\n        {\n            uint64_t currentTime = Hal_getTimeInMs();\n\n            if (currentTime > self->nextReadTimeout) {\n\n                if (DEBUG_ISO_CLIENT)\n                    printf(\""Timeout waiting for ACSE initiate response\\n\"");\n\n                self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else {\n\n                TpktState packetState = CotpConnection_readToTpktBuffer(self->cotpConnection);\n\n                if (packetState == TPKT_PACKET_COMPLETE) {\n\n                    CotpIndication cotpIndication = CotpConnection_parseIncomingMessage(self->cotpConnection);\n\n                    if (cotpIndication != COTP_DATA_INDICATION) {\n                        if (DEBUG_ISO_CLIENT)\n                            printf(\""Unexpected COTP state (%i)\\n\"", cotpIndication);\n\n                        self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                        nextState = INT_STATE_CLOSE_ON_ERROR;\n                    }\n                    else {\n\n                        /* parse ACSE response */\n\n                       IsoSessionIndication sessionIndication;\n\n                       sessionIndication =\n                               IsoSession_parseMessage(self->session, CotpConnection_getPayload(self->cotpConnection));\n\n                       if (sessionIndication != SESSION_CONNECT) {\n                           if (DEBUG_ISO_CLIENT)\n                               printf(\""IsoClientConnection_associate: no session connect indication\\n\"");\n\n                           self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                           nextState = INT_STATE_CLOSE_ON_ERROR;\n                       }\n                       else {\n\n                           if (IsoPresentation_parseAcceptMessage(self->presentation, IsoSession_getUserData(self->session)) == false) {\n\n                               if (DEBUG_ISO_CLIENT)\n                                   printf(\""IsoClientConnection_associate: no presentation ok indication\\n\"");\n\n                               self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                               nextState = INT_STATE_CLOSE_ON_ERROR;\n                           }\n                           else {\n\n                               AcseIndication acseIndication = AcseConnection_parseMessage(&(self->acseConnection), &self->presentation->nextPayload);\n\n                               if (acseIndication != ACSE_ASSOCIATE) {\n                                   if (DEBUG_ISO_CLIENT)\n                                       printf(\""IsoClientConnection_associate: no ACSE_ASSOCIATE indication\\n\"");\n\n                                   self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                                   nextState = INT_STATE_CLOSE_ON_ERROR;\n                               }\n                               else {\n\n                               }\n\n                           }\n\n                           ByteBuffer_wrap(self->receivePayloadBuffer, self->acseConnection.userDataBuffer,\n                                   self->acseConnection.userDataBufferSize, self->acseConnection.userDataBufferSize);\n\n                           setState(self, STATE_CONNECTED);\n                           nextState = INT_STATE_WAIT_FOR_DATA_MSG;\n\n                           self->callback(ISO_IND_ASSOCIATION_SUCCESS, self->callbackParameter, self->receivePayloadBuffer);\n\n                           CotpConnection_resetPayload(self->cotpConnection);\n                       }\n                    }\n                }\n                else if (packetState == TPKT_ERROR) {\n                    if (DEBUG_ISO_CLIENT)\n                        printf(\""Error receiving COTP message\\n\"");\n\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n                else {\n                    waits = true;\n                }\n\n            }\n        }\n        break;\n\n    case INT_STATE_WAIT_FOR_DATA_MSG:\n        {\n            TpktState packetState = CotpConnection_readToTpktBuffer(self->cotpConnection);\n\n            if (packetState == TPKT_ERROR) {\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else if (packetState == TPKT_PACKET_COMPLETE) {\n\n                CotpIndication cotpIndication = CotpConnection_parseIncomingMessage(self->cotpConnection);\n\n                switch (cotpIndication) {\n\n                case COTP_MORE_FRAGMENTS_FOLLOW:\n                    break;\n\n                case COTP_DISCONNECT_INDICATION:\n                    {\n                        nextState = INT_STATE_CLOSING_CONNECTION;\n                    }\n                    break;\n\n                case COTP_DATA_INDICATION:\n                    {\n                        if (DEBUG_ISO_CLIENT)\n                            printf(\""ISO_CLIENT_CONNECTION: parse message\\n\"");\n\n                        IsoSessionIndication sessionIndication =\n                                IsoSession_parseMessage(self->session,\n                                        CotpConnection_getPayload(self->cotpConnection));\n\n                        if (sessionIndication != SESSION_DATA) {\n                            if (DEBUG_ISO_CLIENT)\n                                printf(\""ISO_CLIENT_CONNECTION: Invalid session message\\n\"");\n\n                            nextState = INT_STATE_CLOSE_ON_ERROR;\n                        }\n                        else {\n\n                            if (!IsoPresentation_parseUserData(self->presentation, IsoSession_getUserData(self->session))) {\n\n                                if (DEBUG_ISO_CLIENT)\n                                    printf(\""ISO_CLIENT_CONNECTION: Invalid presentation message\\n\"");\n\n                                nextState = INT_STATE_CLOSE_ON_ERROR;\n                            }\n                            else {\n\n                                self->callback(ISO_IND_DATA, self->callbackParameter,\n                                        &(self->presentation->nextPayload));\n\n                                CotpConnection_resetPayload(self->cotpConnection);\n                            }\n                        }\n                    }\n                    break;\n\n                default:\n                    {\n                        nextState = INT_STATE_CLOSE_ON_ERROR;\n                    }\n                    break;\n\n                }\n            }\n            else {\n                waits = true;\n            }\n\n        }\n        break;\n\n    case INT_STATE_CLOSE_ON_ERROR:\n        {\n            setState(self, STATE_ERROR);\n\n            self->callback(ISO_IND_CLOSED, self->callbackParameter, NULL);;\n\n            releaseSocket(self);\n\n            nextState = INT_STATE_ERROR;\n        }\n        break;\n\n    case INT_STATE_CLOSING_CONNECTION:\n        {\n            setState(self, STATE_IDLE);\n\n            self->callback(ISO_IND_CLOSED, self->callbackParameter, NULL);;\n\n            releaseSocket(self);\n\n            nextState = INT_STATE_IDLE;\n        }\n        break;\n\n    default:\n\n        if (DEBUG_ISO_CLIENT)\n            printf(\""ISO_CLIENT_CONNECTION: Illegal state\\n\"");\n\n        break;\n\n    }\n\n    self->callback(ISO_IND_TICK, self->callbackParameter, NULL);\n\n    setIntState(self, nextState);\n\n    Semaphore_post(self->tickMutex);\n\n    return waits;\n}\n"", ""caller_start"": 302, ""file_path"": ""src/mms/iso_client/iso_client_connection.c""}, {""call_line"": 524, ""call_code"": ""CotpConnection_readToTpktBuffer(self->cotpConnection)"", ""caller_code"": ""bool\nIsoClientConnection_handleConnection(IsoClientConnection self)\n{\n    Semaphore_wait(self->tickMutex);\n\n    bool waits = false;\n\n    eIsoClientInternalState currentState = getIntState(self);\n\n    eIsoClientInternalState nextState = currentState;\n\n    switch (currentState) {\n\n    case INT_STATE_IDLE:\n    case INT_STATE_ERROR:\n        waits = true;\n        break;\n\n    case INT_STATE_TCP_CONNECTING:\n        {\n            SocketState socketState = Socket_checkAsyncConnectState(self->socket);\n\n            if (socketState == SOCKET_STATE_CONNECTED) {\n                if (sendConnectionRequestMessage(self)) {\n                    self->nextReadTimeout = Hal_getTimeInMs() + self->readTimeoutInMs;\n                    nextState = INT_STATE_WAIT_FOR_COTP_CONNECT_RESP;\n                }\n                else {\n                    IsoClientConnection_releaseTransmitBuffer(self);\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n            }\n            else if (socketState == SOCKET_STATE_FAILED) {\n                IsoClientConnection_releaseTransmitBuffer(self);\n                self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else {\n\n                /* check connect timeout */\n\n                uint64_t currentTime = Hal_getTimeInMs();\n\n                if (currentTime > self->nextReadTimeout) {\n                    IsoClientConnection_releaseTransmitBuffer(self);\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n                else {\n                    waits = true;\n                }\n\n            }\n\n        }\n        break;\n\n    case INT_STATE_WAIT_FOR_COTP_CONNECT_RESP:\n        {\n            uint64_t currentTime = Hal_getTimeInMs();\n\n            if (currentTime > self->nextReadTimeout) {\n\n                if (DEBUG_ISO_CLIENT)\n                    printf(\""Timeout waiting for COTP CR\\n\"");\n\n                IsoClientConnection_releaseTransmitBuffer(self);\n\n                self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else {\n\n                TpktState packetState = CotpConnection_readToTpktBuffer(self->cotpConnection);\n\n                if (packetState == TPKT_PACKET_COMPLETE) {\n\n                    CotpIndication cotpIndication = CotpConnection_parseIncomingMessage(self->cotpConnection);\n\n                    if (cotpIndication != COTP_CONNECT_INDICATION) {\n                        if (DEBUG_ISO_CLIENT)\n                            printf(\""Unexpected COTP state (%i)\\n\"", cotpIndication);\n\n                        IsoClientConnection_releaseTransmitBuffer(self);\n\n                        self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                        nextState = INT_STATE_CLOSE_ON_ERROR;\n                    }\n                    else {\n                        sendAcseInitiateRequest(self);\n\n                        self->nextReadTimeout = Hal_getTimeInMs() + self->readTimeoutInMs;\n\n                        nextState = INT_STATE_WAIT_FOR_ACSE_RESP;\n                    }\n                }\n                else if (packetState == TPKT_ERROR) {\n                    if (DEBUG_ISO_CLIENT)\n                        printf(\""Error receiving COTP message\\n\"");\n\n                    IsoClientConnection_releaseTransmitBuffer(self);\n\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n                else {\n                    waits = true;\n                }\n\n            }\n        }\n        break;\n\n    case INT_STATE_WAIT_FOR_ACSE_RESP:\n        {\n            uint64_t currentTime = Hal_getTimeInMs();\n\n            if (currentTime > self->nextReadTimeout) {\n\n                if (DEBUG_ISO_CLIENT)\n                    printf(\""Timeout waiting for ACSE initiate response\\n\"");\n\n                self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else {\n\n                TpktState packetState = CotpConnection_readToTpktBuffer(self->cotpConnection);\n\n                if (packetState == TPKT_PACKET_COMPLETE) {\n\n                    CotpIndication cotpIndication = CotpConnection_parseIncomingMessage(self->cotpConnection);\n\n                    if (cotpIndication != COTP_DATA_INDICATION) {\n                        if (DEBUG_ISO_CLIENT)\n                            printf(\""Unexpected COTP state (%i)\\n\"", cotpIndication);\n\n                        self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                        nextState = INT_STATE_CLOSE_ON_ERROR;\n                    }\n                    else {\n\n                        /* parse ACSE response */\n\n                       IsoSessionIndication sessionIndication;\n\n                       sessionIndication =\n                               IsoSession_parseMessage(self->session, CotpConnection_getPayload(self->cotpConnection));\n\n                       if (sessionIndication != SESSION_CONNECT) {\n                           if (DEBUG_ISO_CLIENT)\n                               printf(\""IsoClientConnection_associate: no session connect indication\\n\"");\n\n                           self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                           nextState = INT_STATE_CLOSE_ON_ERROR;\n                       }\n                       else {\n\n                           if (IsoPresentation_parseAcceptMessage(self->presentation, IsoSession_getUserData(self->session)) == false) {\n\n                               if (DEBUG_ISO_CLIENT)\n                                   printf(\""IsoClientConnection_associate: no presentation ok indication\\n\"");\n\n                               self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                               nextState = INT_STATE_CLOSE_ON_ERROR;\n                           }\n                           else {\n\n                               AcseIndication acseIndication = AcseConnection_parseMessage(&(self->acseConnection), &self->presentation->nextPayload);\n\n                               if (acseIndication != ACSE_ASSOCIATE) {\n                                   if (DEBUG_ISO_CLIENT)\n                                       printf(\""IsoClientConnection_associate: no ACSE_ASSOCIATE indication\\n\"");\n\n                                   self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                                   nextState = INT_STATE_CLOSE_ON_ERROR;\n                               }\n                               else {\n\n                               }\n\n                           }\n\n                           ByteBuffer_wrap(self->receivePayloadBuffer, self->acseConnection.userDataBuffer,\n                                   self->acseConnection.userDataBufferSize, self->acseConnection.userDataBufferSize);\n\n                           setState(self, STATE_CONNECTED);\n                           nextState = INT_STATE_WAIT_FOR_DATA_MSG;\n\n                           self->callback(ISO_IND_ASSOCIATION_SUCCESS, self->callbackParameter, self->receivePayloadBuffer);\n\n                           CotpConnection_resetPayload(self->cotpConnection);\n                       }\n                    }\n                }\n                else if (packetState == TPKT_ERROR) {\n                    if (DEBUG_ISO_CLIENT)\n                        printf(\""Error receiving COTP message\\n\"");\n\n                    self->callback(ISO_IND_ASSOCIATION_FAILED, self->callbackParameter, NULL);\n\n                    nextState = INT_STATE_CLOSE_ON_ERROR;\n                }\n                else {\n                    waits = true;\n                }\n\n            }\n        }\n        break;\n\n    case INT_STATE_WAIT_FOR_DATA_MSG:\n        {\n            TpktState packetState = CotpConnection_readToTpktBuffer(self->cotpConnection);\n\n            if (packetState == TPKT_ERROR) {\n                nextState = INT_STATE_CLOSE_ON_ERROR;\n            }\n            else if (packetState == TPKT_PACKET_COMPLETE) {\n\n                CotpIndication cotpIndication = CotpConnection_parseIncomingMessage(self->cotpConnection);\n\n                switch (cotpIndication) {\n\n                case COTP_MORE_FRAGMENTS_FOLLOW:\n                    break;\n\n                case COTP_DISCONNECT_INDICATION:\n                    {\n                        nextState = INT_STATE_CLOSING_CONNECTION;\n                    }\n                    break;\n\n                case COTP_DATA_INDICATION:\n                    {\n                        if (DEBUG_ISO_CLIENT)\n                            printf(\""ISO_CLIENT_CONNECTION: parse message\\n\"");\n\n                        IsoSessionIndication sessionIndication =\n                                IsoSession_parseMessage(self->session,\n                                        CotpConnection_getPayload(self->cotpConnection));\n\n                        if (sessionIndication != SESSION_DATA) {\n                            if (DEBUG_ISO_CLIENT)\n                                printf(\""ISO_CLIENT_CONNECTION: Invalid session message\\n\"");\n\n                            nextState = INT_STATE_CLOSE_ON_ERROR;\n                        }\n                        else {\n\n                            if (!IsoPresentation_parseUserData(self->presentation, IsoSession_getUserData(self->session))) {\n\n                                if (DEBUG_ISO_CLIENT)\n                                    printf(\""ISO_CLIENT_CONNECTION: Invalid presentation message\\n\"");\n\n                                nextState = INT_STATE_CLOSE_ON_ERROR;\n                            }\n                            else {\n\n                                self->callback(ISO_IND_DATA, self->callbackParameter,\n                                        &(self->presentation->nextPayload));\n\n                                CotpConnection_resetPayload(self->cotpConnection);\n                            }\n                        }\n                    }\n                    break;\n\n                default:\n                    {\n                        nextState = INT_STATE_CLOSE_ON_ERROR;\n                    }\n                    break;\n\n                }\n            }\n            else {\n                waits = true;\n            }\n\n        }\n        break;\n\n    case INT_STATE_CLOSE_ON_ERROR:\n        {\n            setState(self, STATE_ERROR);\n\n            self->callback(ISO_IND_CLOSED, self->callbackParameter, NULL);;\n\n            releaseSocket(self);\n\n            nextState = INT_STATE_ERROR;\n        }\n        break;\n\n    case INT_STATE_CLOSING_CONNECTION:\n        {\n            setState(self, STATE_IDLE);\n\n            self->callback(ISO_IND_CLOSED, self->callbackParameter, NULL);;\n\n            releaseSocket(self);\n\n            nextState = INT_STATE_IDLE;\n        }\n        break;\n\n    default:\n\n        if (DEBUG_ISO_CLIENT)\n            printf(\""ISO_CLIENT_CONNECTION: Illegal state\\n\"");\n\n        break;\n\n    }\n\n    self->callback(ISO_IND_TICK, self->callbackParameter, NULL);\n\n    setIntState(self, nextState);\n\n    Semaphore_post(self->tickMutex);\n\n    return waits;\n}\n"", ""caller_start"": 302, ""file_path"": ""src/mms/iso_client/iso_client_connection.c""}, {""call_line"": 177, ""call_code"": ""CotpConnection_readToTpktBuffer(self->cotpConnection)"", ""caller_code"": ""void\nIsoConnection_handleTcpConnection(IsoConnection self, bool isSingleThread)\n{\n#if (CONFIG_MMS_SINGLE_THREADED != 1)\n    if (isSingleThread == false) {\n\n        /* call tick handler */\n        if (self->tickHandler) {\n            self->tickHandler(self->handlerParameter);\n        }\n\n        if (Handleset_waitReady(self->handleSet, 10) < 1)\n            goto exit_function;\n    }\n#endif\n\n    TpktState tpktState = CotpConnection_readToTpktBuffer(self->cotpConnection);\n\n    if (tpktState == TPKT_ERROR)\n        self->state = ISO_CON_STATE_STOPPED;\n\n    if (tpktState != TPKT_PACKET_COMPLETE)\n        goto exit_function;\n\n    CotpIndication cotpIndication = CotpConnection_parseIncomingMessage(self->cotpConnection);\n\n    switch (cotpIndication) {\n    case COTP_MORE_FRAGMENTS_FOLLOW:\n        goto exit_function;\n\n    case COTP_CONNECT_INDICATION:\n        if (DEBUG_ISO_SERVER)\n            printf(\""ISO_SERVER: COTP connection indication\\n\"");\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n        IsoConnection_lock(self);\n#endif\n\n        CotpConnection_sendConnectionResponseMessage(self->cotpConnection);\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n        IsoConnection_unlock(self);\n#endif\n\n        break;\n    case COTP_DATA_INDICATION:\n        {\n            ByteBuffer* cotpPayload = CotpConnection_getPayload(self->cotpConnection);\n\n            if (DEBUG_ISO_SERVER)\n                printf(\""ISO_SERVER: COTP data indication (payload size = %i)\\n\"", cotpPayload->size);\n\n            IsoSessionIndication sIndication = IsoSession_parseMessage(self->session, cotpPayload);\n\n            ByteBuffer* sessionUserData = IsoSession_getUserData(self->session);\n\n            switch (sIndication) {\n            case SESSION_CONNECT:\n                if (DEBUG_ISO_SERVER)\n                    printf(\""ISO_SERVER: iso_connection: session connect indication\\n\"");\n\n                if (IsoPresentation_parseConnect(self->presentation, sessionUserData)) {\n                    if (DEBUG_ISO_SERVER)\n                        printf(\""ISO_SERVER: iso_connection: presentation ok\\n\"");\n\n                    ByteBuffer* acseBuffer = &(self->presentation->nextPayload);\n\n                    AcseIndication aIndication = AcseConnection_parseMessage(self->acseConnection, acseBuffer);\n\n                    if (aIndication == ACSE_ASSOCIATE) {\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n                        IsoConnection_lock(self);\n#endif\n\n                        if (DEBUG_ISO_SERVER)\n                            printf(\""ISO_SERVER: cotp_server: acse associate\\n\"");\n\n                        ByteBuffer mmsRequest;\n\n                        ByteBuffer_wrap(&mmsRequest, self->acseConnection->userDataBuffer,\n                                self->acseConnection->userDataBufferSize, self->acseConnection->userDataBufferSize);\n                        ByteBuffer mmsResponseBuffer; /* new */\n\n                        ByteBuffer_wrap(&mmsResponseBuffer, self->sendBuffer, 0, SEND_BUF_SIZE);\n\n                        if (self->msgRcvdHandler != NULL) {\n                            self->msgRcvdHandler(self->handlerParameter,\n                                    &mmsRequest, &mmsResponseBuffer);\n                        }\n\n                        struct sBufferChain mmsBufferPartStruct;\n                        BufferChain mmsBufferPart = &mmsBufferPartStruct;\n\n                        BufferChain_init(mmsBufferPart, mmsResponseBuffer.size, mmsResponseBuffer.size, NULL,\n                                self->sendBuffer);\n\n                        if (mmsResponseBuffer.size > 0) {\n                            if (DEBUG_ISO_SERVER)\n                                printf(\""ISO_SERVER: iso_connection: application payload size: %i\\n\"",\n                                        mmsResponseBuffer.size);\n\n                            struct sBufferChain acseBufferPartStruct;\n                            BufferChain acseBufferPart = &acseBufferPartStruct;\n\n                            acseBufferPart->buffer = self->sendBuffer + mmsBufferPart->length;\n                            acseBufferPart->partMaxLength = SEND_BUF_SIZE - mmsBufferPart->length;\n\n                            AcseConnection_createAssociateResponseMessage(self->acseConnection,\n                            ACSE_RESULT_ACCEPT, acseBufferPart, mmsBufferPart);\n\n                            struct sBufferChain presentationBufferPartStruct;\n                            BufferChain presentationBufferPart = &presentationBufferPartStruct;\n\n                            presentationBufferPart->buffer = self->sendBuffer + acseBufferPart->length;\n                            presentationBufferPart->partMaxLength = SEND_BUF_SIZE - acseBufferPart->length;\n\n                            IsoPresentation_createCpaMessage(self->presentation, presentationBufferPart,\n                                    acseBufferPart);\n\n                            struct sBufferChain sessionBufferPartStruct;\n                            BufferChain sessionBufferPart = &sessionBufferPartStruct;\n                            sessionBufferPart->buffer = self->sendBuffer + presentationBufferPart->length;\n                            sessionBufferPart->partMaxLength = SEND_BUF_SIZE - presentationBufferPart->length;\n\n                            IsoSession_createAcceptSpdu(self->session, sessionBufferPart, presentationBufferPart);\n\n                            CotpConnection_sendDataMessage(self->cotpConnection, sessionBufferPart);\n                        }\n                        else {\n                            if (DEBUG_ISO_SERVER)\n                                printf(\""ISO_SERVER: iso_connection: association error. No response from application!\\n\"");\n                        }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n                        IsoConnection_unlock(self);\n#endif\n                    }\n                    else {\n                        if (DEBUG_ISO_SERVER)\n                            printf(\""ISO_SERVER: iso_connection: acse association failed\\n\"");\n                        self->state = ISO_CON_STATE_STOPPED;\n                    }\n\n                }\n                break;\n            case SESSION_DATA:\n                if (DEBUG_ISO_SERVER)\n                    printf(\""ISO_SERVER: iso_connection: session data indication\\n\"");\n\n                if (!IsoPresentation_parseUserData(self->presentation, sessionUserData)) {\n                    if (DEBUG_ISO_SERVER)\n                        printf(\""ISO_SERVER: presentation layer error\\n\"");\n\t\t\t\t\tself->state = ISO_CON_STATE_STOPPED;\n                    break;\n                }\n\n                if (self->presentation->nextContextId == self->presentation->mmsContextId) {\n                    if (DEBUG_ISO_SERVER)\n                        printf(\""ISO_SERVER: iso_connection: mms message\\n\"");\n\n                    ByteBuffer* mmsRequest = &(self->presentation->nextPayload);\n\n                    ByteBuffer mmsResponseBuffer;\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n                    IsoServer_userLock(self->isoServer);\n                    IsoConnection_lock(self);\n#endif\n\n                    ByteBuffer_wrap(&mmsResponseBuffer, self->sendBuffer, 0, SEND_BUF_SIZE);\n\n                    if (self->msgRcvdHandler != NULL) {\n\n                        self->msgRcvdHandler(self->handlerParameter,\n                                mmsRequest, &mmsResponseBuffer);\n                    }\n\n                    /* send a response if required */\n                    if (mmsResponseBuffer.size > 0) {\n\n                        struct sBufferChain mmsBufferPartStruct;\n\t\t\t\t\t\tBufferChain mmsBufferPart = &mmsBufferPartStruct;\n\n                        BufferChain_init(mmsBufferPart, mmsResponseBuffer.size,\n                                mmsResponseBuffer.size, NULL, self->sendBuffer);\n\n                        struct sBufferChain presentationBufferPartStruct;\n                        BufferChain presentationBufferPart = &presentationBufferPartStruct;\n                        presentationBufferPart->buffer = self->sendBuffer + mmsBufferPart->length;\n                        presentationBufferPart->partMaxLength = SEND_BUF_SIZE - mmsBufferPart->length;\n\n                        IsoPresentation_createUserData(self->presentation,\n                                presentationBufferPart, mmsBufferPart);\n\n                        struct sBufferChain sessionBufferPartStruct;\n                        BufferChain sessionBufferPart = &sessionBufferPartStruct;\n                        sessionBufferPart->buffer = self->sendBuffer + presentationBufferPart->length;\n                        sessionBufferPart->partMaxLength = SEND_BUF_SIZE - presentationBufferPart->length;\n\n                        IsoSession_createDataSpdu(self->session, sessionBufferPart, presentationBufferPart);\n\n                        CotpConnection_sendDataMessage(self->cotpConnection, sessionBufferPart);\n                    }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n                    IsoConnection_unlock(self);\n                    IsoServer_userUnlock(self->isoServer);\n#endif\n                }\n                else {\n                    if (DEBUG_ISO_SERVER)\n                        printf(\""ISO_SERVER: iso_connection: unknown presentation layer context!\"");\n                }\n\n                break;\n\n            case SESSION_FINISH:\n                if (DEBUG_ISO_SERVER)\n                    printf(\""ISO_SERVER: iso_connection: session finish indication\\n\"");\n\n                if (IsoPresentation_parseUserData(self->presentation, sessionUserData)) {\n                    if (DEBUG_ISO_SERVER)\n                        printf(\""ISO_SERVER: iso_connection: presentation ok\\n\"");\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n                    IsoServer_userLock(self->isoServer);\n                    IsoConnection_lock(self);\n#endif\n\n                    struct sBufferChain acseBufferPartStruct;\n                    BufferChain acseBufferPart = &acseBufferPartStruct;\n                    acseBufferPart->buffer = self->sendBuffer;\n                    acseBufferPart->partMaxLength = SEND_BUF_SIZE;\n\n                    AcseConnection_createReleaseResponseMessage(self->acseConnection, acseBufferPart);\n\n                    struct sBufferChain presentationBufferPartStruct;\n                    BufferChain presentationBufferPart = &presentationBufferPartStruct;\n                    presentationBufferPart->buffer = self->sendBuffer + acseBufferPart->length;\n                    presentationBufferPart->partMaxLength = SEND_BUF_SIZE - acseBufferPart->length;\n\n                    IsoPresentation_createUserDataACSE(self->presentation, presentationBufferPart, acseBufferPart);\n\n                    struct sBufferChain sessionBufferPartStruct;\n                    BufferChain sessionBufferPart = &sessionBufferPartStruct;\n                    sessionBufferPart->buffer = self->sendBuffer + presentationBufferPart->length;\n                    sessionBufferPart->partMaxLength = SEND_BUF_SIZE - presentationBufferPart->length;\n\n                    IsoSession_createDisconnectSpdu(self->session, sessionBufferPart, presentationBufferPart);\n\n                    CotpConnection_sendDataMessage(self->cotpConnection, sessionBufferPart);\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n                    IsoConnection_unlock(self);\n                    IsoServer_userUnlock(self->isoServer);\n#endif\n                }\n\n                self->state = ISO_CON_STATE_STOPPED;\n\n                break;\n\n            case SESSION_ABORT:\n                if (DEBUG_ISO_SERVER)\n                    printf(\""ISO_SERVER: iso_connection: session abort indication\\n\"");\n                self->state = ISO_CON_STATE_STOPPED;\n                break;\n\n            case SESSION_ERROR:\n                if (DEBUG_ISO_SERVER)\n                    printf(\""ISO_SERVER: iso_connection: session error indication\\n\"");\n                self->state = ISO_CON_STATE_STOPPED;\n                break;\n\n            default: /* illegal state */\n                if (DEBUG_ISO_SERVER)\n                    printf(\""ISO_SERVER: iso_connection: session illegal state\\n\"");\n\n                self->state = ISO_CON_STATE_STOPPED;\n                break;\n            }\n\n            CotpConnection_resetPayload(self->cotpConnection);\n        }\n        break;\n    case COTP_ERROR:\n        if (DEBUG_ISO_SERVER)\n            printf(\""ISO_SERVER: Connection closed\\n\"");\n        self->state = ISO_CON_STATE_STOPPED;\n        break;\n    default:\n        if (DEBUG_ISO_SERVER)\n            printf(\""ISO_SERVER: COTP unknown indication: %i\\n\"", cotpIndication);\n        self->state = ISO_CON_STATE_STOPPED;\n        break;\n    }\n\nexit_function:\n    return;\n}\n"", ""caller_start"": 161, ""file_path"": ""src/mms/iso_server/iso_connection.c""}]}]","src/mms/iso_cotp/cotp.c:704: `self->packetSize` is derived from `buffer[2]` and `buffer[3]` without validation. If the COTP length field is set to a value  3, `packetSize - bufPos` becomes negative, causing `readFromSocket` to process invalid memory. The patch (cotp.c:724) adds a check for `packetSize <= bufPos`, but does not validate `packetSize  4` before use.",0.95,./github/other_context/CVE-2020-15158
66,CVE-2020-19497,CWE-190,c_cpp,"Integer overflow vulnerability in Mat_VarReadNextInfo5 in mat5.c in tbeu matio (aka MAT File I/O Library) 1.5.17, allows attackers to cause a Denial of Service or possibly other unspecified impacts.",https://github.com/tbeu/matio/commit/5fa49ef9fc4368fe3d19b5fdaa36d8fa5e7f4606,Fix integer addition overflow\n\nAs reported by https://github.com/tbeu/matio/issues/121,2,"[{""func_name"": ""Mat_VarReadNextInfo5"", ""file_path"": ""src/mat5.c"", ""func_code"": ""matvar_t *\nMat_VarReadNextInfo5( mat_t *mat )\n{\n    int err;\n    mat_int32_t data_type, nBytes;\n    long fpos;\n    matvar_t *matvar = NULL;\n    mat_uint32_t array_flags;\n\n    if ( mat == NULL )\n        return NULL;\n\n    fpos = ftell((FILE*)mat->fp);\n    if ( fpos == -1L ) {\n        Mat_Critical(\""Couldn't determine file position\"");\n        return NULL;\n    }\n    err = fread(&data_type,4,1,(FILE*)mat->fp);\n    if ( err == 0 )\n        return NULL;\n    err = fread(&nBytes,4,1,(FILE*)mat->fp);\n    if ( mat->byteswap ) {\n        (void)Mat_int32Swap(&data_type);\n        (void)Mat_int32Swap(&nBytes);\n    }\n    switch ( data_type ) {\n        case MAT_T_COMPRESSED:\n        {\n#if defined(HAVE_ZLIB)\n            mat_uint32_t uncomp_buf[16] = {0,};\n            int      nbytes;\n            long     bytesread = 0;\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\""Couldn't allocate memory\"");\n                break;\n            }\n\n            matvar->compression = MAT_COMPRESSION_ZLIB;\n            matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n            err = inflateInit(matvar->internal->z);\n            if ( err != Z_OK ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\""inflateInit returned %s\"",zError(err));\n                break;\n            }\n\n            /* Read variable tag */\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\""Uncompressed type not MAT_T_MATRIX\"");\n                break;\n            }\n            /* Array flags */\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n                array_flags = uncomp_buf[2];\n                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n                if ( matvar->class_type == MAT_C_SPARSE ) {\n                    /* Need to find a more appropriate place to store nzmax */\n                    matvar->nbytes = uncomp_buf[3];\n                }\n            }\n            if ( matvar->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    nbytes = uncomp_buf[1];\n                    matvar->rank = nbytes / 4;\n                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = dims[j];\n                    }\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(uncomp_buf);\n                /* Name of variable */\n                if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    mat_uint32_t len, len_pad;\n                    if ( mat->byteswap )\n                        len = Mat_uint32Swap(uncomp_buf+1);\n                    else\n                        len = uncomp_buf[1];\n\n                    if ( len % 8 == 0 )\n                        len_pad = len;\n                    else\n                        len_pad = len + 8 - (len % 8);\n                    matvar->name = (char*)malloc(len_pad + 1);\n                    if ( NULL != matvar->name ) {\n                        /* Variable name */\n                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad);\n                        matvar->name[len] = '\\0';\n                    }\n                } else {\n                    mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                    if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                        /* Name packed in tag */\n                        matvar->name = (char*)malloc(len+1);\n                        if ( NULL != matvar->name ) {\n                            memcpy(matvar->name,uncomp_buf+1,len);\n                            matvar->name[len] = '\\0';\n                        }\n                    }\n                }\n                if ( matvar->class_type == MAT_C_STRUCT )\n                    (void)ReadNextStructField(mat,matvar);\n                else if ( matvar->class_type == MAT_C_CELL )\n                    (void)ReadNextCell(mat,matvar);\n                (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);\n                matvar->internal->datapos = ftell((FILE*)mat->fp);\n                if ( matvar->internal->datapos == -1L ) {\n                    Mat_Critical(\""Couldn't determine file position\"");\n                }\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n#else\n            Mat_Critical(\""Compressed variable found in \\\""%s\\\"", but matio was \""\n                         \""built without zlib support\"",mat->filename);\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            return NULL;\n#endif\n        }\n        case MAT_T_MATRIX:\n        {\n            mat_uint32_t buf[6];\n            size_t readresult;\n\n            /* Read array flags and the dimensions tag */\n            readresult = fread(buf, 4, 6, (FILE*)mat->fp);\n            if ( 6 != readresult ) {\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\""Couldn't allocate memory\"");\n                break;\n            }\n\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n               matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( matvar->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   matvar->nbytes = buf[3];\n               }\n            }\n            readresult = ReadRankDims(mat, matvar, (enum matio_types)buf[4], buf[5]);\n            if ( 0 == readresult && 0 < matvar->rank ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            /* Variable name tag */\n            readresult = fread(buf, 4, 2, (FILE*)mat->fp);\n            if ( 2 != readresult ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(buf);\n            /* Name of variable */\n            if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                mat_uint32_t len, len_pad;\n                if ( mat->byteswap )\n                    len = Mat_uint32Swap(buf+1);\n                else\n                    len = buf[1];\n                if ( len % 8 == 0 )\n                    len_pad = len;\n                else\n                    len_pad = len + 8 - (len % 8);\n                matvar->name = (char*)malloc(len_pad + 1);\n                if ( NULL != matvar->name ) {\n                    readresult = fread(matvar->name, 1, len_pad, (FILE*)mat->fp);\n                    if ( readresult == len_pad ) {\n                        matvar->name[len] = '\\0';\n                    } else {\n                        Mat_VarFree(matvar);\n                        matvar = NULL;\n                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                        break;\n                    }\n                }\n            } else {\n                mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;\n                if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                    /* Name packed in tag */\n                    matvar->name = (char*)malloc(len+1);\n                    if ( NULL != matvar->name ) {\n                        memcpy(matvar->name, buf+1, len);\n                        matvar->name[len] = '\\0';\n                    }\n                }\n            }\n            if ( matvar->class_type == MAT_C_STRUCT )\n                (void)ReadNextStructField(mat,matvar);\n            else if ( matvar->class_type == MAT_C_CELL )\n                (void)ReadNextCell(mat,matvar);\n            else if ( matvar->class_type == MAT_C_FUNCTION )\n                (void)ReadNextFunctionHandle(mat,matvar);\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\""Couldn't determine file position\"");\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n        }\n        default:\n            Mat_Critical(\""%d is not valid (MAT_T_MATRIX or MAT_T_COMPRESSED)\"",\n                         data_type);\n            return NULL;\n    }\n\n    return matvar;\n}"", ""target"": 0}, {""func_name"": ""ReadNextCell"", ""file_path"": ""src/mat5.c"", ""func_code"": ""static size_t\nReadNextCell( mat_t *mat, matvar_t *matvar )\n{\n    size_t bytesread = 0, i;\n    int err;\n    matvar_t **cells = NULL;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\""Integer multiplication overflow\"");\n        return bytesread;\n    }\n    matvar->data_size = sizeof(matvar_t *);\n    err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err ) {\n        Mat_Critical(\""Integer multiplication overflow\"");\n        return bytesread;\n    }\n\n    matvar->data = calloc(nelems, matvar->data_size);\n    if ( NULL == matvar->data ) {\n        if ( NULL != matvar->name )\n            Mat_Critical(\""Couldn't allocate memory for %s->data\"", matvar->name);\n        return bytesread;\n    }\n    cells = (matvar_t **)matvar->data;\n\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        mat_uint32_t uncomp_buf[16] = {0,};\n        int nbytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            cells[i] = Mat_VarCalloc();\n            if ( NULL == cells[i] ) {\n                Mat_Critical(\""Couldn't allocate memory for cell %\"" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            uncomp_buf[0] = 0;\n            uncomp_buf[1] = 0;\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( 0 == nbytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\""cells[%\"" SIZE_T_FMTSTR \""], Uncompressed type not MAT_T_MATRIX\"", i);\n                break;\n            }\n            cells[i]->compression = MAT_COMPRESSION_ZLIB;\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            nbytes -= 16;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array Flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n               array_flags = uncomp_buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = uncomp_buf[3];\n               }\n            } else {\n                Mat_Critical(\""Expected MAT_T_UINT32 for array tags, got %d\"",\n                               uncomp_buf[0]);\n                bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n            }\n            if ( cells[i]->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and Dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    cells[i]->rank = uncomp_buf[1];\n                    nbytes -= cells[i]->rank;\n                    cells[i]->rank /= 4;\n                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = dims[j];\n                    }\n                    if ( cells[i]->rank % 2 != 0 )\n                        nbytes -= 4;\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Handle cell elements written with a variable name */\n                if ( uncomp_buf[1] > 0 ) {\n                    /* Name of variable */\n                    if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                        mat_uint32_t len = uncomp_buf[1];\n\n                        if ( len % 8 > 0 )\n                            len = len+(8-(len % 8));\n                        cells[i]->name = (char*)malloc(len+1);\n                        nbytes -= len;\n                        if ( NULL != cells[i]->name ) {\n                            /* Variable name */\n                            bytesread += InflateVarName(mat,matvar,cells[i]->name,len);\n                            cells[i]->name[len] = '\\0';\n                        }\n                    } else {\n                        mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                        if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                            /* Name packed in tag */\n                            cells[i]->name = (char*)malloc(len+1);\n                            if ( NULL != cells[i]->name ) {\n                                memcpy(cells[i]->name,uncomp_buf+1,len);\n                                cells[i]->name[len] = '\\0';\n                            }\n                        }\n                    }\n                }\n                cells[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n                if ( cells[i]->internal->z != NULL ) {\n                    err = inflateCopy(cells[i]->internal->z,matvar->internal->z);\n                    if ( err == Z_OK ) {\n                        cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n                        if ( cells[i]->internal->datapos != -1L ) {\n                            cells[i]->internal->datapos -= matvar->internal->z->avail_in;\n                            if ( cells[i]->class_type == MAT_C_STRUCT )\n                                bytesread+=ReadNextStructField(mat,cells[i]);\n                            else if ( cells[i]->class_type == MAT_C_CELL )\n                                bytesread+=ReadNextCell(mat,cells[i]);\n                            else if ( nbytes <= (1 << MAX_WBITS) ) {\n                                /* Memory optimization: Read data if less in size\n                                   than the zlib inflate state (approximately) */\n                                Mat_VarRead5(mat,cells[i]);\n                                cells[i]->internal->data = cells[i]->data;\n                                cells[i]->data = NULL;\n                            }\n                            (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos,SEEK_SET);\n                        } else {\n                            Mat_Critical(\""Couldn't determine file position\"");\n                        }\n                        if ( cells[i]->internal->data != NULL ||\n                             cells[i]->class_type == MAT_C_STRUCT ||\n                             cells[i]->class_type == MAT_C_CELL ) {\n                            /* Memory optimization: Free inflate state */\n                            inflateEnd(cells[i]->internal->z);\n                            free(cells[i]->internal->z);\n                            cells[i]->internal->z = NULL;\n                        }\n                    } else {\n                        Mat_Critical(\""inflateCopy returned error %s\"",zError(err));\n                    }\n                } else {\n                    Mat_Critical(\""Couldn't allocate memory\"");\n                }\n            }\n            bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n        }\n#else\n        Mat_Critical(\""Not compiled with zlib support\"");\n#endif\n\n    } else {\n        mat_uint32_t buf[6];\n        int nBytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            int cell_bytes_read,name_len;\n            cells[i] = Mat_VarCalloc();\n            if ( !cells[i] ) {\n                Mat_Critical(\""Couldn't allocate memory for cell %\"" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            cell_bytes_read = fread(buf,4,2,(FILE*)mat->fp);\n\n            /* Empty cells at the end of a file may cause an EOF */\n            if ( !cell_bytes_read )\n                continue;\n            bytesread += cell_bytes_read;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            nBytes = buf[1];\n            if ( 0 == nBytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\""cells[%\"" SIZE_T_FMTSTR \""] not MAT_T_MATRIX, fpos = %ld\"", i,\n                    ftell((FILE*)mat->fp));\n                break;\n            }\n\n            /* Read array flags and the dimensions tag */\n            bytesread += fread(buf,4,6,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n            nBytes-=24;\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = buf[3];\n               }\n            }\n            /* Rank and dimension */\n            {\n                size_t nbytes = ReadRankDims(mat, cells[i], (enum matio_types)buf[4], buf[5]);\n                bytesread += nbytes;\n                nBytes -= nbytes;\n            }\n            /* Variable name tag */\n            bytesread+=fread(buf,1,8,(FILE*)mat->fp);\n            nBytes-=8;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            name_len = 0;\n            if ( buf[1] > 0 ) {\n                /* Name of variable */\n                if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    name_len = buf[1];\n                    if ( name_len % 8 > 0 )\n                        name_len = name_len+(8-(name_len % 8));\n                    nBytes -= name_len;\n                    (void)fseek((FILE*)mat->fp,name_len,SEEK_CUR);\n                }\n            }\n            cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n            if ( cells[i]->internal->datapos != -1L ) {\n                if ( cells[i]->class_type == MAT_C_STRUCT )\n                    bytesread+=ReadNextStructField(mat,cells[i]);\n                if ( cells[i]->class_type == MAT_C_CELL )\n                    bytesread+=ReadNextCell(mat,cells[i]);\n                (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos+nBytes,SEEK_SET);\n            } else {\n                Mat_Critical(\""Couldn't determine file position\"");\n            }\n        }\n    }\n\n    return bytesread;\n}"", ""target"": 0}]","[{""func_name"": ""Mat_VarReadNextInfo5"", ""file_path"": ""src/mat5.c"", ""func_code"": ""matvar_t *\nMat_VarReadNextInfo5( mat_t *mat )\n{\n    int err;\n    mat_int32_t data_type, nBytes;\n    long fpos;\n    matvar_t *matvar = NULL;\n    mat_uint32_t array_flags;\n\n    if ( mat == NULL )\n        return NULL;\n\n    fpos = ftell((FILE*)mat->fp);\n    if ( fpos == -1L ) {\n        Mat_Critical(\""Couldn't determine file position\"");\n        return NULL;\n    }\n    err = fread(&data_type,4,1,(FILE*)mat->fp);\n    if ( err == 0 )\n        return NULL;\n    err = fread(&nBytes,4,1,(FILE*)mat->fp);\n    if ( mat->byteswap ) {\n        (void)Mat_int32Swap(&data_type);\n        (void)Mat_int32Swap(&nBytes);\n    }\n    switch ( data_type ) {\n        case MAT_T_COMPRESSED:\n        {\n#if defined(HAVE_ZLIB)\n            mat_uint32_t uncomp_buf[16] = {0,};\n            int      nbytes;\n            long     bytesread = 0;\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\""Couldn't allocate memory\"");\n                break;\n            }\n\n            matvar->compression = MAT_COMPRESSION_ZLIB;\n            matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n            err = inflateInit(matvar->internal->z);\n            if ( err != Z_OK ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\""inflateInit returned %s\"",zError(err));\n                break;\n            }\n\n            /* Read variable tag */\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\""Uncompressed type not MAT_T_MATRIX\"");\n                break;\n            }\n            /* Array flags */\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n                array_flags = uncomp_buf[2];\n                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n                if ( matvar->class_type == MAT_C_SPARSE ) {\n                    /* Need to find a more appropriate place to store nzmax */\n                    matvar->nbytes = uncomp_buf[3];\n                }\n            }\n            if ( matvar->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    nbytes = uncomp_buf[1];\n                    matvar->rank = nbytes / 4;\n                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = dims[j];\n                    }\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(uncomp_buf);\n                /* Name of variable */\n                if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    mat_uint32_t len, len_pad;\n                    if ( mat->byteswap )\n                        len = Mat_uint32Swap(uncomp_buf+1);\n                    else\n                        len = uncomp_buf[1];\n\n                    if ( len % 8 == 0 )\n                        len_pad = len;\n                    else if ( len < UINT32_MAX - 8 + (len % 8) )\n                        len_pad = len + 8 - (len % 8);\n                    else {\n                        Mat_VarFree(matvar);\n                        matvar = NULL;\n                        break;\n                    }\n                    matvar->name = (char*)malloc(len_pad + 1);\n                    if ( NULL != matvar->name ) {\n                        /* Variable name */\n                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad);\n                        matvar->name[len] = '\\0';\n                    }\n                } else {\n                    mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                    if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                        /* Name packed in tag */\n                        matvar->name = (char*)malloc(len+1);\n                        if ( NULL != matvar->name ) {\n                            memcpy(matvar->name,uncomp_buf+1,len);\n                            matvar->name[len] = '\\0';\n                        }\n                    }\n                }\n                if ( matvar->class_type == MAT_C_STRUCT )\n                    (void)ReadNextStructField(mat,matvar);\n                else if ( matvar->class_type == MAT_C_CELL )\n                    (void)ReadNextCell(mat,matvar);\n                (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);\n                matvar->internal->datapos = ftell((FILE*)mat->fp);\n                if ( matvar->internal->datapos == -1L ) {\n                    Mat_Critical(\""Couldn't determine file position\"");\n                }\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n#else\n            Mat_Critical(\""Compressed variable found in \\\""%s\\\"", but matio was \""\n                         \""built without zlib support\"",mat->filename);\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            return NULL;\n#endif\n        }\n        case MAT_T_MATRIX:\n        {\n            mat_uint32_t buf[6];\n            size_t readresult;\n\n            /* Read array flags and the dimensions tag */\n            readresult = fread(buf, 4, 6, (FILE*)mat->fp);\n            if ( 6 != readresult ) {\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\""Couldn't allocate memory\"");\n                break;\n            }\n\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n               matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( matvar->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   matvar->nbytes = buf[3];\n               }\n            }\n            readresult = ReadRankDims(mat, matvar, (enum matio_types)buf[4], buf[5]);\n            if ( 0 == readresult && 0 < matvar->rank ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            /* Variable name tag */\n            readresult = fread(buf, 4, 2, (FILE*)mat->fp);\n            if ( 2 != readresult ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(buf);\n            /* Name of variable */\n            if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                mat_uint32_t len, len_pad;\n                if ( mat->byteswap )\n                    len = Mat_uint32Swap(buf+1);\n                else\n                    len = buf[1];\n                if ( len % 8 == 0 )\n                    len_pad = len;\n                else if ( len < UINT32_MAX - 8 + (len % 8) )\n                    len_pad = len + 8 - (len % 8);\n                else {\n                    Mat_VarFree(matvar);\n                    matvar = NULL;\n                    (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                    break;\n                }\n                matvar->name = (char*)malloc(len_pad + 1);\n                if ( NULL != matvar->name ) {\n                    readresult = fread(matvar->name, 1, len_pad, (FILE*)mat->fp);\n                    if ( readresult == len_pad ) {\n                        matvar->name[len] = '\\0';\n                    } else {\n                        Mat_VarFree(matvar);\n                        matvar = NULL;\n                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                        break;\n                    }\n                }\n            } else {\n                mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;\n                if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                    /* Name packed in tag */\n                    matvar->name = (char*)malloc(len+1);\n                    if ( NULL != matvar->name ) {\n                        memcpy(matvar->name, buf+1, len);\n                        matvar->name[len] = '\\0';\n                    }\n                }\n            }\n            if ( matvar->class_type == MAT_C_STRUCT )\n                (void)ReadNextStructField(mat,matvar);\n            else if ( matvar->class_type == MAT_C_CELL )\n                (void)ReadNextCell(mat,matvar);\n            else if ( matvar->class_type == MAT_C_FUNCTION )\n                (void)ReadNextFunctionHandle(mat,matvar);\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\""Couldn't determine file position\"");\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n        }\n        default:\n            Mat_Critical(\""%d is not valid (MAT_T_MATRIX or MAT_T_COMPRESSED)\"",\n                         data_type);\n            return NULL;\n    }\n\n    return matvar;\n}""}, {""func_name"": ""ReadNextCell"", ""file_path"": ""src/mat5.c"", ""func_code"": ""static size_t\nReadNextCell( mat_t *mat, matvar_t *matvar )\n{\n    size_t bytesread = 0, i;\n    int err;\n    matvar_t **cells = NULL;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\""Integer multiplication overflow\"");\n        return bytesread;\n    }\n    matvar->data_size = sizeof(matvar_t *);\n    err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err ) {\n        Mat_Critical(\""Integer multiplication overflow\"");\n        return bytesread;\n    }\n\n    matvar->data = calloc(nelems, matvar->data_size);\n    if ( NULL == matvar->data ) {\n        if ( NULL != matvar->name )\n            Mat_Critical(\""Couldn't allocate memory for %s->data\"", matvar->name);\n        return bytesread;\n    }\n    cells = (matvar_t **)matvar->data;\n\n    if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n#if defined(HAVE_ZLIB)\n        mat_uint32_t uncomp_buf[16] = {0,};\n        int nbytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            cells[i] = Mat_VarCalloc();\n            if ( NULL == cells[i] ) {\n                Mat_Critical(\""Couldn't allocate memory for cell %\"" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            uncomp_buf[0] = 0;\n            uncomp_buf[1] = 0;\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( 0 == nbytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\""cells[%\"" SIZE_T_FMTSTR \""], Uncompressed type not MAT_T_MATRIX\"", i);\n                break;\n            }\n            cells[i]->compression = MAT_COMPRESSION_ZLIB;\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            nbytes -= 16;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array Flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n               array_flags = uncomp_buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = uncomp_buf[3];\n               }\n            } else {\n                Mat_Critical(\""Expected MAT_T_UINT32 for array tags, got %d\"",\n                               uncomp_buf[0]);\n                bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n            }\n            if ( cells[i]->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and Dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    cells[i]->rank = uncomp_buf[1];\n                    nbytes -= cells[i]->rank;\n                    cells[i]->rank /= 4;\n                    cells[i]->dims = (size_t*)malloc(cells[i]->rank*sizeof(*cells[i]->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < cells[i]->rank; j++ )\n                            cells[i]->dims[j] = dims[j];\n                    }\n                    if ( cells[i]->rank % 2 != 0 )\n                        nbytes -= 4;\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                nbytes -= 8;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Handle cell elements written with a variable name */\n                if ( uncomp_buf[1] > 0 ) {\n                    /* Name of variable */\n                    if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                        mat_uint32_t len = uncomp_buf[1];\n\n                        if ( len % 8 > 0 ) {\n                            if ( len < UINT32_MAX - 8 + (len % 8) )\n                              len = len + 8 - (len % 8);\n                            else {\n                                Mat_VarFree(cells[i]);\n                                cells[i] = NULL;\n                                break;\n                            }\n                        }\n                        cells[i]->name = (char*)malloc(len + 1);\n                        nbytes -= len;\n                        if ( NULL != cells[i]->name ) {\n                            /* Variable name */\n                            bytesread += InflateVarName(mat,matvar,cells[i]->name,len);\n                            cells[i]->name[len] = '\\0';\n                        }\n                    } else {\n                        mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                        if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                            /* Name packed in tag */\n                            cells[i]->name = (char*)malloc(len+1);\n                            if ( NULL != cells[i]->name ) {\n                                memcpy(cells[i]->name,uncomp_buf+1,len);\n                                cells[i]->name[len] = '\\0';\n                            }\n                        }\n                    }\n                }\n                cells[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n                if ( cells[i]->internal->z != NULL ) {\n                    err = inflateCopy(cells[i]->internal->z,matvar->internal->z);\n                    if ( err == Z_OK ) {\n                        cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n                        if ( cells[i]->internal->datapos != -1L ) {\n                            cells[i]->internal->datapos -= matvar->internal->z->avail_in;\n                            if ( cells[i]->class_type == MAT_C_STRUCT )\n                                bytesread+=ReadNextStructField(mat,cells[i]);\n                            else if ( cells[i]->class_type == MAT_C_CELL )\n                                bytesread+=ReadNextCell(mat,cells[i]);\n                            else if ( nbytes <= (1 << MAX_WBITS) ) {\n                                /* Memory optimization: Read data if less in size\n                                   than the zlib inflate state (approximately) */\n                                Mat_VarRead5(mat,cells[i]);\n                                cells[i]->internal->data = cells[i]->data;\n                                cells[i]->data = NULL;\n                            }\n                            (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos,SEEK_SET);\n                        } else {\n                            Mat_Critical(\""Couldn't determine file position\"");\n                        }\n                        if ( cells[i]->internal->data != NULL ||\n                             cells[i]->class_type == MAT_C_STRUCT ||\n                             cells[i]->class_type == MAT_C_CELL ) {\n                            /* Memory optimization: Free inflate state */\n                            inflateEnd(cells[i]->internal->z);\n                            free(cells[i]->internal->z);\n                            cells[i]->internal->z = NULL;\n                        }\n                    } else {\n                        Mat_Critical(\""inflateCopy returned error %s\"",zError(err));\n                    }\n                } else {\n                    Mat_Critical(\""Couldn't allocate memory\"");\n                }\n            }\n            bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);\n        }\n#else\n        Mat_Critical(\""Not compiled with zlib support\"");\n#endif\n\n    } else {\n        mat_uint32_t buf[6];\n        int nBytes;\n        mat_uint32_t array_flags;\n\n        for ( i = 0; i < nelems; i++ ) {\n            int cell_bytes_read;\n            mat_uint32_t name_len;\n            cells[i] = Mat_VarCalloc();\n            if ( !cells[i] ) {\n                Mat_Critical(\""Couldn't allocate memory for cell %\"" SIZE_T_FMTSTR, i);\n                continue;\n            }\n\n            /* Read variable tag for cell */\n            cell_bytes_read = fread(buf,4,2,(FILE*)mat->fp);\n\n            /* Empty cells at the end of a file may cause an EOF */\n            if ( !cell_bytes_read )\n                continue;\n            bytesread += cell_bytes_read;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            nBytes = buf[1];\n            if ( 0 == nBytes ) {\n                /* Empty cell: Memory optimization */\n                free(cells[i]->internal);\n                cells[i]->internal = NULL;\n                continue;\n            } else if ( buf[0] != MAT_T_MATRIX ) {\n                Mat_VarFree(cells[i]);\n                cells[i] = NULL;\n                Mat_Critical(\""cells[%\"" SIZE_T_FMTSTR \""] not MAT_T_MATRIX, fpos = %ld\"", i,\n                    ftell((FILE*)mat->fp));\n                break;\n            }\n\n            /* Read array flags and the dimensions tag */\n            bytesread += fread(buf,4,6,(FILE*)mat->fp);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n            nBytes-=24;\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);\n               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( cells[i]->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   cells[i]->nbytes = buf[3];\n               }\n            }\n            /* Rank and dimension */\n            {\n                size_t nbytes = ReadRankDims(mat, cells[i], (enum matio_types)buf[4], buf[5]);\n                bytesread += nbytes;\n                nBytes -= nbytes;\n            }\n            /* Variable name tag */\n            bytesread+=fread(buf,1,8,(FILE*)mat->fp);\n            nBytes-=8;\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n            }\n            name_len = 0;\n            if ( buf[1] > 0 ) {\n                /* Name of variable */\n                if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    name_len = buf[1];\n                    if ( name_len % 8 > 0 )\n                        if ( name_len < UINT32_MAX - 8 + (name_len % 8) )\n                            name_len = name_len + 8 - (name_len % 8);\n                        else {\n                            Mat_VarFree(cells[i]);\n                            cells[i] = NULL;\n                            break;\n                        }\n                    nBytes -= name_len;\n                    (void)fseek((FILE*)mat->fp,name_len,SEEK_CUR);\n                }\n            }\n            cells[i]->internal->datapos = ftell((FILE*)mat->fp);\n            if ( cells[i]->internal->datapos != -1L ) {\n                if ( cells[i]->class_type == MAT_C_STRUCT )\n                    bytesread+=ReadNextStructField(mat,cells[i]);\n                if ( cells[i]->class_type == MAT_C_CELL )\n                    bytesread+=ReadNextCell(mat,cells[i]);\n                (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos+nBytes,SEEK_SET);\n            } else {\n                Mat_Critical(\""Couldn't determine file position\"");\n            }\n        }\n    }\n\n    return bytesread;\n}""}]","{""value"": 2, ""function"": 1}","[{""source"": ""value_info(file:mat5.c, value:buf)"", ""result"": {""value_trace"": [{""full_code"": ""buf[6]"", ""line"": 1077, ""func_name"": ""ReadNextCell""}, {""full_code"": ""buf[6]"", ""line"": 1422, ""func_name"": ""ReadNextStructField""}, {""full_code"": ""buf[6]"", ""line"": 4915, ""func_name"": ""Mat_VarReadNextInfo5""}], ""struct_var"": ""buf"", ""struct_type"": ""mat_uint32_t[6]"", ""struct_definition"": null}}, {""source"": ""func_info(file:mat5.c, line:4915)"", ""result"": [{""code"": ""matvar_t *\nMat_VarReadNextInfo5( mat_t *mat )\n{\n    int err;\n    mat_int32_t data_type, nBytes;\n    long fpos;\n    matvar_t *matvar = NULL;\n    mat_uint32_t array_flags;\n\n    if ( mat == NULL )\n        return NULL;\n\n    fpos = ftell((FILE*)mat->fp);\n    if ( fpos == -1L ) {\n        Mat_Critical(\""Couldn't determine file position\"");\n        return NULL;\n    }\n    err = fread(&data_type,4,1,(FILE*)mat->fp);\n    if ( err == 0 )\n        return NULL;\n    err = fread(&nBytes,4,1,(FILE*)mat->fp);\n    if ( mat->byteswap ) {\n        (void)Mat_int32Swap(&data_type);\n        (void)Mat_int32Swap(&nBytes);\n    }\n    switch ( data_type ) {\n        case MAT_T_COMPRESSED:\n        {\n#if defined(HAVE_ZLIB)\n            mat_uint32_t uncomp_buf[16] = {0,};\n            int      nbytes;\n            long     bytesread = 0;\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\""Couldn't allocate memory\"");\n                break;\n            }\n\n            matvar->compression = MAT_COMPRESSION_ZLIB;\n            matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));\n            err = inflateInit(matvar->internal->z);\n            if ( err != Z_OK ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\""inflateInit returned %s\"",zError(err));\n                break;\n            }\n\n            /* Read variable tag */\n            bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+1);\n            }\n            nbytes = uncomp_buf[1];\n            if ( uncomp_buf[0] != MAT_T_MATRIX ) {\n                (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                Mat_Critical(\""Uncompressed type not MAT_T_MATRIX\"");\n                break;\n            }\n            /* Array flags */\n            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(uncomp_buf);\n                (void)Mat_uint32Swap(uncomp_buf+2);\n                (void)Mat_uint32Swap(uncomp_buf+3);\n            }\n            /* Array flags */\n            if ( uncomp_buf[0] == MAT_T_UINT32 ) {\n                array_flags = uncomp_buf[2];\n                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n                if ( matvar->class_type == MAT_C_SPARSE ) {\n                    /* Need to find a more appropriate place to store nzmax */\n                    matvar->nbytes = uncomp_buf[3];\n                }\n            }\n            if ( matvar->class_type != MAT_C_OPAQUE ) {\n                mat_uint32_t* dims = NULL;\n                int do_clean = 0;\n                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);\n                if ( NULL == dims )\n                    dims = uncomp_buf + 2;\n                else\n                    do_clean = 1;\n                if ( mat->byteswap ) {\n                    (void)Mat_uint32Swap(uncomp_buf);\n                    (void)Mat_uint32Swap(uncomp_buf+1);\n                }\n                /* Rank and dimension */\n                if ( uncomp_buf[0] == MAT_T_INT32 ) {\n                    int j;\n                    nbytes = uncomp_buf[1];\n                    matvar->rank = nbytes / 4;\n                    matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));\n                    if ( mat->byteswap ) {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = Mat_uint32Swap(dims + j);\n                    } else {\n                        for ( j = 0; j < matvar->rank; j++ )\n                            matvar->dims[j] = dims[j];\n                    }\n                }\n                if ( do_clean )\n                    free(dims);\n                /* Variable name tag */\n                bytesread += InflateVarTag(mat,matvar,uncomp_buf);\n                if ( mat->byteswap )\n                    (void)Mat_uint32Swap(uncomp_buf);\n                /* Name of variable */\n                if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                    mat_uint32_t len, len_pad;\n                    if ( mat->byteswap )\n                        len = Mat_uint32Swap(uncomp_buf+1);\n                    else\n                        len = uncomp_buf[1];\n\n                    if ( len % 8 == 0 )\n                        len_pad = len;\n                    else\n                        len_pad = len + 8 - (len % 8);\n                    matvar->name = (char*)malloc(len_pad + 1);\n                    if ( NULL != matvar->name ) {\n                        /* Variable name */\n                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad);\n                        matvar->name[len] = '\\0';\n                    }\n                } else {\n                    mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;\n                    if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                        /* Name packed in tag */\n                        matvar->name = (char*)malloc(len+1);\n                        if ( NULL != matvar->name ) {\n                            memcpy(matvar->name,uncomp_buf+1,len);\n                            matvar->name[len] = '\\0';\n                        }\n                    }\n                }\n                if ( matvar->class_type == MAT_C_STRUCT )\n                    (void)ReadNextStructField(mat,matvar);\n                else if ( matvar->class_type == MAT_C_CELL )\n                    (void)ReadNextCell(mat,matvar);\n                (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);\n                matvar->internal->datapos = ftell((FILE*)mat->fp);\n                if ( matvar->internal->datapos == -1L ) {\n                    Mat_Critical(\""Couldn't determine file position\"");\n                }\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n#else\n            Mat_Critical(\""Compressed variable found in \\\""%s\\\"", but matio was \""\n                         \""built without zlib support\"",mat->filename);\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            return NULL;\n#endif\n        }\n        case MAT_T_MATRIX:\n        {\n            mat_uint32_t buf[6];\n            size_t readresult;\n\n            /* Read array flags and the dimensions tag */\n            readresult = fread(buf, 4, 6, (FILE*)mat->fp);\n            if ( 6 != readresult ) {\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap ) {\n                (void)Mat_uint32Swap(buf);\n                (void)Mat_uint32Swap(buf+1);\n                (void)Mat_uint32Swap(buf+2);\n                (void)Mat_uint32Swap(buf+3);\n                (void)Mat_uint32Swap(buf+4);\n                (void)Mat_uint32Swap(buf+5);\n            }\n\n            matvar = Mat_VarCalloc();\n            if ( NULL == matvar ) {\n                Mat_Critical(\""Couldn't allocate memory\"");\n                break;\n            }\n\n            /* Array flags */\n            if ( buf[0] == MAT_T_UINT32 ) {\n               array_flags = buf[2];\n               matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);\n               matvar->isComplex  = (array_flags & MAT_F_COMPLEX);\n               matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);\n               matvar->isLogical  = (array_flags & MAT_F_LOGICAL);\n               if ( matvar->class_type == MAT_C_SPARSE ) {\n                   /* Need to find a more appropriate place to store nzmax */\n                   matvar->nbytes = buf[3];\n               }\n            }\n            readresult = ReadRankDims(mat, matvar, (enum matio_types)buf[4], buf[5]);\n            if ( 0 == readresult && 0 < matvar->rank ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            /* Variable name tag */\n            readresult = fread(buf, 4, 2, (FILE*)mat->fp);\n            if ( 2 != readresult ) {\n                Mat_VarFree(matvar);\n                matvar = NULL;\n                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                break;\n            }\n            if ( mat->byteswap )\n                (void)Mat_uint32Swap(buf);\n            /* Name of variable */\n            if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */\n                mat_uint32_t len, len_pad;\n                if ( mat->byteswap )\n                    len = Mat_uint32Swap(buf+1);\n                else\n                    len = buf[1];\n                if ( len % 8 == 0 )\n                    len_pad = len;\n                else\n                    len_pad = len + 8 - (len % 8);\n                matvar->name = (char*)malloc(len_pad + 1);\n                if ( NULL != matvar->name ) {\n                    readresult = fread(matvar->name, 1, len_pad, (FILE*)mat->fp);\n                    if ( readresult == len_pad ) {\n                        matvar->name[len] = '\\0';\n                    } else {\n                        Mat_VarFree(matvar);\n                        matvar = NULL;\n                        (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);\n                        break;\n                    }\n                }\n            } else {\n                mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;\n                if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {\n                    /* Name packed in tag */\n                    matvar->name = (char*)malloc(len+1);\n                    if ( NULL != matvar->name ) {\n                        memcpy(matvar->name, buf+1, len);\n                        matvar->name[len] = '\\0';\n                    }\n                }\n            }\n            if ( matvar->class_type == MAT_C_STRUCT )\n                (void)ReadNextStructField(mat,matvar);\n            else if ( matvar->class_type == MAT_C_CELL )\n                (void)ReadNextCell(mat,matvar);\n            else if ( matvar->class_type == MAT_C_FUNCTION )\n                (void)ReadNextFunctionHandle(mat,matvar);\n            matvar->internal->datapos = ftell((FILE*)mat->fp);\n            if ( matvar->internal->datapos == -1L ) {\n                Mat_Critical(\""Couldn't determine file position\"");\n            }\n            (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);\n            break;\n        }\n        default:\n            Mat_Critical(\""%d is not valid (MAT_T_MATRIX or MAT_T_COMPRESSED)\"",\n                         data_type);\n            return NULL;\n    }\n\n    return matvar;\n}\n"", ""start_line"": 4751, ""end_line"": 5022, ""full_name"": ""Mat_VarReadNextInfo5"", ""file_path"": ""src/mat5.c""}]}, {""source"": ""value_info(file:mat5.c, value:buf)"", ""result"": {""value_trace"": [{""full_code"": ""buf[6]"", ""line"": 1077, ""func_name"": ""ReadNextCell""}, {""full_code"": ""buf[6]"", ""line"": 1422, ""func_name"": ""ReadNextStructField""}, {""full_code"": ""buf[6]"", ""line"": 4915, ""func_name"": ""Mat_VarReadNextInfo5""}], ""struct_var"": ""buf"", ""struct_type"": ""mat_uint32_t[6]"", ""struct_definition"": null}}]","In src/mat5.c:4873-4980 (Mat_VarReadNextInfo5) and src/mat5.c:1010-1162 (ReadNextCell), 'len' is derived from 'buf[1]' (src/mat5.c:4915) which is populated via fread(buf, 4, 6, (FILE*)mat->fp). The original code calculated 'len_pad = len + 8 - (len % 8)' without overflow checks, risking integer overflow. The patch adds 'len < UINT32_MAX - 8 + (len % 8)' checks to prevent overflow. 'buf' is confirmed to be user-controlled via file input (mat->fp).",0.95,./github/other_context/CVE-2020-19497
67,CVE-2020-27790,CWE-369,c_cpp,A floating point exception issue was discovered in UPX in PackLinuxElf64::invert_pt_dynamic() function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger this issue that could cause a crash leading to a denial of service. The highest impact is to Availability.,https://github.com/upx/upx/commit/eb90eab6325d009004ffb155e3e33f22d4d3ca26,Detect bogus DT_SYMENT.\n\nhttps://github.com/upx/upx/issues/331\n	modified:   p_lx_elf.cpp,2,"[{""func_name"": ""PackLinuxElf64::invert_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)\n{\n    if (dt_table[Elf64_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf64_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 1+ 0;\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        upx_uint64_t const d_tag = get_te64(&dynp->d_tag);\n        if (d_tag>>32) { // outrageous\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad Elf64_Dyn[%d].d_tag %#lx\"", -1+ ndx, (long unsigned)d_tag);\n            throwCantPack(msg);\n        }\n        if (d_tag < DT_NUM) {\n            if (Elf64_Dyn::DT_NEEDED != d_tag\n            &&  dt_table[d_tag]\n            &&    get_te64(&dynp->d_val)\n               != get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {\n                char msg[50]; snprintf(msg, sizeof(msg),\n                    \""duplicate DT_%#x: [%#x] [%#x]\"",\n                    (unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);\n                throwCantPack(msg);\n            }\n            dt_table[d_tag] = ndx;\n        }\n        if (Elf64_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;\n    else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te64(&dynp0[-1+ z_str].d_val);\n        if ((u64_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad DT_STRSZ %#x\"", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    // DT_SYMTAB has no designated length.\n    // End it when next area else starts; often DT_STRTAB.  (FIXME)\n    unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)\n            : get_te64(&dynp0[-1+ z_sym].d_val);\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_HASH %#x\"", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_HASH nbucket=%#x  len=%#x\"",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        if (!gashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_GNU_HASH %#x\"", v_gsh);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(upx_uint64_t) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)  // FIXME: weak\n        // FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*n_bucket  // hasharr\n            ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx\"",\n                n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh));\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \""bad .e_shstrndx %d >= .e_shnum %d\"", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}"", ""target"": 1}, {""func_name"": ""PackLinuxElf32::invert_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)\n{\n    if (dt_table[Elf32_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf32_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 1+ 0;\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        unsigned const d_tag = get_te32(&dynp->d_tag);\n        if (d_tag < DT_NUM) {\n            if (Elf32_Dyn::DT_NEEDED != d_tag\n            &&  dt_table[d_tag]\n            &&    get_te32(&dynp->d_val)\n               != get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) {\n                char msg[50]; snprintf(msg, sizeof(msg),\n                    \""duplicate DT_%#x: [%#x] [%#x]\"",\n                    d_tag, -1+ dt_table[d_tag], -1+ ndx);\n                throwCantPack(msg);\n            }\n            dt_table[d_tag] = ndx;\n        }\n        if (Elf32_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;\n    else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te32(&dynp0[-1+ z_str].d_val);\n        if ((u32_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad DT_STRSZ %#x\"", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)\n            : get_te32(&dynp0[-1+ z_sym].d_val);\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_HASH %#x\"", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_HASH nbucket=%#x  len=%#x\"",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        if (!gashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_GNU_HASH %#x\"", v_gsh);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(unsigned) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)  // FIXME: weak\n        // FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*n_bucket  // hasharr\n            ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x\"",\n                n_bucket, n_bitmask, v_sym - v_gsh);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \""bad .e_shstrndx %d >= .e_shnum %d\"", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}"", ""target"": 0}]","[{""func_name"": ""PackLinuxElf64::invert_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp)\n{\n    if (dt_table[Elf64_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf64_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 1+ 0;\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        upx_uint64_t const d_tag = get_te64(&dynp->d_tag);\n        if (d_tag>>32) { // outrageous\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad Elf64_Dyn[%d].d_tag %#lx\"", -1+ ndx, (long unsigned)d_tag);\n            throwCantPack(msg);\n        }\n        if (d_tag < DT_NUM) {\n            if (Elf64_Dyn::DT_NEEDED != d_tag\n            &&  dt_table[d_tag]\n            &&    get_te64(&dynp->d_val)\n               != get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {\n                char msg[50]; snprintf(msg, sizeof(msg),\n                    \""duplicate DT_%#x: [%#x] [%#x]\"",\n                    (unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);\n                throwCantPack(msg);\n            }\n            dt_table[d_tag] = ndx;\n        }\n        if (Elf64_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;\n    else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te64(&dynp0[-1+ z_str].d_val);\n        if ((u64_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad DT_STRSZ %#x\"", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    // DT_SYMTAB has no designated length.\n    // End it when next area else starts; often DT_STRTAB.  (FIXME)\n    unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)\n            : get_te64(&dynp0[-1+ z_sym].d_val);\n        if (sz_sym < sizeof(Elf64_Sym)) {\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad DT_SYMENT %x\"", sz_sym);\n            throwCantPack(msg);\n        }\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n        if (symnum_end < 1) {\n            throwCantPack(\""bad DT_SYMTAB\"");\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_HASH %#x\"", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_HASH nbucket=%#x  len=%#x\"",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        if (!gashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_GNU_HASH %#x\"", v_gsh);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(upx_uint64_t) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)  // FIXME: weak\n        // FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*n_bucket  // hasharr\n            ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx\"",\n                n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh));\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \""bad .e_shstrndx %d >= .e_shnum %d\"", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}""}, {""func_name"": ""PackLinuxElf32::invert_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp)\n{\n    if (dt_table[Elf32_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf32_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 1+ 0;\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        unsigned const d_tag = get_te32(&dynp->d_tag);\n        if (d_tag < DT_NUM) {\n            if (Elf32_Dyn::DT_NEEDED != d_tag\n            &&  dt_table[d_tag]\n            &&    get_te32(&dynp->d_val)\n               != get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) {\n                char msg[50]; snprintf(msg, sizeof(msg),\n                    \""duplicate DT_%#x: [%#x] [%#x]\"",\n                    d_tag, -1+ dt_table[d_tag], -1+ ndx);\n                throwCantPack(msg);\n            }\n            dt_table[d_tag] = ndx;\n        }\n        if (Elf32_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;\n    else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te32(&dynp0[-1+ z_str].d_val);\n        if ((u32_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad DT_STRSZ %#x\"", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)\n            : get_te32(&dynp0[-1+ z_sym].d_val);\n        if (sz_sym < sizeof(Elf32_Sym)) {\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad DT_SYMENT %x\"", sz_sym);\n            throwCantPack(msg);\n        }\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n        if (symnum_end < 1) {\n            throwCantPack(\""bad DT_SYMTAB\"");\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_HASH %#x\"", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_HASH nbucket=%#x  len=%#x\"",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        if (!gashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_GNU_HASH %#x\"", v_gsh);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(unsigned) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)  // FIXME: weak\n        // FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*n_bucket  // hasharr\n            ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x\"",\n                n_bucket, n_bitmask, v_sym - v_gsh);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \""bad .e_shstrndx %d >= .e_shnum %d\"", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}""}]","{""code"": 1, ""value"": 1, ""function"": 1}","[{""source"": ""code_info(file:p_lx_elf.cpp, lines:1600-1630)"", ""result"": ""    unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te32(&dynp0[-1+ z_str].d_val);\n        if ((u32_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \""bad DT_STRSZ %#x\"", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)\n            : get_te32(&dynp0[-1+ z_sym].d_val);\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \""bad DT_HASH %#x\"", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:dt_table)"", ""result"": {""value_trace"": [{""full_code"": ""dt_table[d_tag] = ndx"", ""line"": 1589, ""func_name"": ""PackLinuxElf32.invert_pt_dynamic:void(Elf32_Dyn*)""}, {""full_code"": ""dt_table[d_tag] = ndx"", ""line"": 5077, ""func_name"": ""PackLinuxElf64.invert_pt_dynamic:void(Elf64_Dyn*)""}], ""struct_var"": ""dt_table"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:get_te32)"", ""result"": [{""code"": ""unsigned get_te32(const void *p) const { return bele->get32(p); }"", ""start_line"": 111, ""end_line"": 111, ""full_name"": ""ElfLinker.get_te32:unsigned int(void*)<const>"", ""file_path"": ""src/linker.h""}, {""code"": ""unsigned get_te32(const void *p)       const { return bele->get32(p); }"", ""start_line"": 296, ""end_line"": 296, ""full_name"": ""Packer.get_te32:unsigned int(void*)<const>"", ""file_path"": ""src/packer.h""}]}]","src/p_lx_elf.cpp:1615-1625: DT_SYMENT is parsed from `dt_table` (built in src/p_lx_elf.cpp:1589 and 5077). If the DT_SYMENT value in the ELF dynamic section is invalid (e.g., zero or non-canonical), `sz_sym` becomes zero or insufficient. This invalid value is used in `symnum_end = (v_str - v_sym) / sz_sym`, causing a division by zero or invalid operation, leading to a floating-point exception. The patch adds guards to reject invalid `sz_sym` and `symnum_end < 1`.",0.95,./github/other_context/CVE-2020-27790
68,CVE-2020-28248,"CWE-190, CWE-787",c_cpp,An integer overflow in the PngImg::InitStorage_() function of png-img before 3.1.0 leads to an under-allocation of heap memory and subsequently an exploitable heap-based buffer overflow when loading a crafted PNG file.,https://github.com/gemini-testing/png-img/commit/14ac462a32ca4b3b78f56502ac976d5b0222ce3d,Handle image size overflow,1,"[{""func_name"": ""PngImg::InitStorage_"", ""file_path"": ""src/PngImg.cc"", ""func_code"": ""void PngImg::InitStorage_() {\n    rowPtrs_.resize(info_.height, nullptr);\n    data_ = new png_byte[info_.height * info_.rowbytes];\n\n    for(size_t i = 0; i < info_.height; ++i) {\n        rowPtrs_[i] = data_ + i * info_.rowbytes;\n    }\n}"", ""target"": 0}]","[{""func_name"": ""PngImg::InitStorage_"", ""file_path"": ""src/PngImg.cc"", ""func_code"": ""void PngImg::InitStorage_() {\n    rowPtrs_.resize(info_.height, nullptr);\n    // Extend height and rowbytes from uint32_t to size_t to avoid multiplication overflow when size_t is larger\n    size_t h = info_.height;\n    size_t rb = info_.rowbytes;\n    // We need to make sure that info_.height * info_.rowbytes will not overflow size_t\n    // Unfotunately, there's no simple and portable way to do this in C++\n    // For integer division of positive numbers a * b > c <==> a > c / b holds\n    if (h > std::numeric_limits<size_t>::max() / rb) {\n        // TODO Propagate this exception to JS, and test it\n        throw std::runtime_error(\""Image is too large to allocate single buffer\"");\n    }\n    data_ = new png_byte[h * rb];\n\n    for(size_t i = 0; i < info_.height; ++i) {\n        rowPtrs_[i] = data_ + i * rb;\n    }\n}""}]","{""value"": 2}","[{""source"": ""value_info(file:PngImg.cc, value:info_.height)"", ""result"": {""value_trace"": [{""full_code"": ""info_.height = png_get_image_height(rs.pngPtr, rs.infoPtr)"", ""line"": 50, ""func_name"": ""PngImg.ReadInfo_:void(PngReadStruct&)""}, {""full_code"": ""info_.height = height"", ""line"": 134, ""func_name"": ""PngImg.Crop:bool(png_uint_32,png_uint_32,png_uint_32,png_uint_32)""}, {""full_code"": ""info_.height = height"", ""line"": 160, ""func_name"": ""PngImg.SetSize:void(png_uint_32,png_uint_32)""}, {""full_code"": ""info_.height = oldInfo.width"", ""line"": 218, ""func_name"": ""PngImg.Rotate_:void(function)""}], ""struct_var"": ""info_"", ""struct_type"": ""ImgInfo"", ""struct_definition"": ""struct ImgInfo {\n    png_uint_32 width;\n    png_uint_32 height;\n    png_uint_32 bit_depth;\n    png_uint_32 color_type;\n    png_uint_32 interlace_type;\n    png_uint_32 compression_type;\n    png_uint_32 filter_type;\n    png_uint_32 rowbytes;\n    short pxlsize;\n}""}}, {""source"": ""value_info(file:PngImg.cc, value:info_.rowbytes)"", ""result"": {""value_trace"": [{""full_code"": ""info_.rowbytes = png_get_rowbytes(rs.pngPtr, rs.infoPtr)"", ""line"": 56, ""func_name"": ""PngImg.ReadInfo_:void(PngReadStruct&)""}, {""full_code"": ""info_.rowbytes = info_.pxlsize * width"", ""line"": 135, ""func_name"": ""PngImg.Crop:bool(png_uint_32,png_uint_32,png_uint_32,png_uint_32)""}, {""full_code"": ""info_.rowbytes = info_.pxlsize * width"", ""line"": 161, ""func_name"": ""PngImg.SetSize:void(png_uint_32,png_uint_32)""}, {""full_code"": ""info_.rowbytes = info_.pxlsize * info_.width"", ""line"": 219, ""func_name"": ""PngImg.Rotate_:void(function)""}], ""struct_var"": ""info_"", ""struct_type"": ""ImgInfo"", ""struct_definition"": ""struct ImgInfo {\n    png_uint_32 width;\n    png_uint_32 height;\n    png_uint_32 bit_depth;\n    png_uint_32 color_type;\n    png_uint_32 interlace_type;\n    png_uint_32 compression_type;\n    png_uint_32 filter_type;\n    png_uint_32 rowbytes;\n    short pxlsize;\n}""}}]",src/PngImg.cc:62-63: Multiplication of info_.height (png_uint_32) and info_.rowbytes (png_uint_32) in 'new png_byte[info_.height * info_.rowbytes]' can overflow size_t due to 32-bit type limits. Values are set via:\n- info_.height = png_get_image_height(...) (src/PngImg.cc:50)\n- info_.rowbytes = png_get_rowbytes(...) (src/PngImg.cc:56)\nStruct ImgInfo defines both as png_uint_32 (src/PngImg.cc:struct ImgInfo).,0.95,./github/other_context/CVE-2020-28248
69,CVE-2021-30014,"CWE-787, CWE-190",c_cpp,There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC from v0.9.0-preview to 1.0.1 which results in a crash.,https://github.com/gpac/gpac/commit/51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,add safety in avc/hevc/vvc sps/pps/vps ID check - cf #1720 #1721 #1722,10,"[{""func_name"": ""hevc_parse_slice_segment"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static\ns32 hevc_parse_slice_segment(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si)\n{\n\tu32 i, j;\n\tu32 num_ref_idx_l0_active = 0, num_ref_idx_l1_active = 0;\n\tHEVC_PPS *pps;\n\tHEVC_SPS *sps;\n\ts32 pps_id;\n\tBool RapPicFlag = GF_FALSE;\n\tBool IDRPicFlag = GF_FALSE;\n\n\tsi->first_slice_segment_in_pic_flag = gf_bs_read_int_log(bs, 1, \""first_slice_segment_in_pic_flag\"");\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tIDRPicFlag = GF_TRUE;\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\t}\n\n\tif (RapPicFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \""no_output_of_prior_pics_flag\"");\n\t}\n\n\tpps_id = gf_bs_read_ue_log(bs, \""pps_id\"");\n\tif (pps_id >= 64)\n\t\treturn -1;\n\n\tpps = &hevc->pps[pps_id];\n\tsps = &hevc->sps[pps->sps_id];\n\tsi->sps = sps;\n\tsi->pps = pps;\n\n\tif (!si->first_slice_segment_in_pic_flag && pps->dependent_slice_segments_enabled_flag) {\n\t\tsi->dependent_slice_segment_flag = gf_bs_read_int_log(bs, 1, \""dependent_slice_segment_flag\"");\n\t}\n\telse {\n\t\tsi->dependent_slice_segment_flag = GF_FALSE;\n\t}\n\n\tif (!si->first_slice_segment_in_pic_flag) {\n\t\tsi->slice_segment_address = gf_bs_read_int_log(bs, sps->bitsSliceSegmentAddress, \""slice_segment_address\"");\n\t}\n\telse {\n\t\tsi->slice_segment_address = 0;\n\t}\n\n\tif (!si->dependent_slice_segment_flag) {\n\t\tBool deblocking_filter_override_flag = 0;\n\t\tBool slice_temporal_mvp_enabled_flag = 0;\n\t\tBool slice_sao_luma_flag = 0;\n\t\tBool slice_sao_chroma_flag = 0;\n\t\tBool slice_deblocking_filter_disabled_flag = 0;\n\n\t\t//\""slice_reserved_undetermined_flag[]\""\n\t\tgf_bs_read_int_log(bs, pps->num_extra_slice_header_bits, \""slice_reserved_undetermined_flag\"");\n\n\t\tsi->slice_type = gf_bs_read_ue_log(bs, \""slice_type\"");\n\n\t\tif (pps->output_flag_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \""pic_output_flag\"");\n\n\t\tif (sps->separate_colour_plane_flag == 1)\n\t\t\tgf_bs_read_int_log(bs, 2, \""colour_plane_id\"");\n\n\t\tif (IDRPicFlag) {\n\t\t\tsi->poc_lsb = 0;\n\n\t\t\t//if not asked to parse full header, abort since we know the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t}\n\t\telse {\n\t\t\tsi->poc_lsb = gf_bs_read_int_log(bs, sps->log2_max_pic_order_cnt_lsb, \""poc_lsb\"");\n\n\t\t\t//if not asked to parse full header, abort once we have the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \""short_term_ref_pic_set_sps_flag\"") == 0) {\n\t\t\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, sps->num_short_term_ref_pic_sets);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (sps->num_short_term_ref_pic_sets > 1) {\n\t\t\t\tu32 numbits = 0;\n\n\t\t\t\twhile ((u32)(1 << numbits) < sps->num_short_term_ref_pic_sets)\n\t\t\t\t\tnumbits++;\n\t\t\t\tif (numbits > 0)\n\t\t\t\t\tgf_bs_read_int_log(bs, numbits, \""short_term_ref_pic_set_idx\"");\n\t\t\t\t/*else\n\t\t\t\t\tshort_term_ref_pic_set_idx = 0;*/\n\t\t\t}\n\t\t\tif (sps->long_term_ref_pics_present_flag) {\n\t\t\t\tu8 DeltaPocMsbCycleLt[32];\n\t\t\t\tu32 num_long_term_sps = 0;\n\t\t\t\tu32 num_long_term_pics = 0;\n\n\t\t\t\tmemset(DeltaPocMsbCycleLt, 0, sizeof(u8) * 32);\n\t\t\t\t\n\t\t\t\tif (sps->num_long_term_ref_pic_sps > 0) {\n\t\t\t\t\tnum_long_term_sps = gf_bs_read_ue_log(bs, \""num_long_term_sps\"");\n\t\t\t\t}\n\t\t\t\tnum_long_term_pics = gf_bs_read_ue_log(bs, \""num_long_term_pics\"");\n\n\t\t\t\tfor (i = 0; i < num_long_term_sps + num_long_term_pics; i++) {\n\t\t\t\t\tif (i < num_long_term_sps) {\n\t\t\t\t\t\tif (sps->num_long_term_ref_pic_sps > 1)\n\t\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, gf_get_bit_size(sps->num_long_term_ref_pic_sps), \""lt_idx_sps\"", i);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \""PocLsbLt\"", i);\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \""UsedByCurrPicLt\"", i);\n\t\t\t\t\t}\n\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \""delta_poc_msb_present_flag\"", i)) {\n\t\t\t\t\t\tif (i == 0 || i == num_long_term_sps)\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \""DeltaPocMsbCycleLt\"", i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \""DeltaPocMsbCycleLt\"", i) + DeltaPocMsbCycleLt[i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->temporal_mvp_enable_flag)\n\t\t\t\tslice_temporal_mvp_enabled_flag = gf_bs_read_int_log(bs, 1, \""slice_temporal_mvp_enabled_flag\"");\n\t\t}\n\t\tif (sps->sample_adaptive_offset_enabled_flag) {\n\t\t\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\t\t\tslice_sao_luma_flag = gf_bs_read_int_log(bs, 1, \""slice_sao_luma_flag\"");\n\t\t\tif (ChromaArrayType != 0)\n\t\t\t\tslice_sao_chroma_flag = gf_bs_read_int_log(bs, 1, \""slice_sao_chroma_flag\"");\n\t\t}\n\n\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_P || si->slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\t\t//u32 NumPocTotalCurr;\n\t\t\tnum_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;\n\t\t\tnum_ref_idx_l1_active = 0;\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tnum_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \""num_ref_idx_active_override_flag\"")) {\n\t\t\t\tnum_ref_idx_l0_active = 1 + gf_bs_read_ue_log(bs, \""num_ref_idx_l0_active\"");\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tnum_ref_idx_l1_active = 1 + gf_bs_read_ue_log(bs, \""num_ref_idx_l1_active\"");\n\t\t\t}\n\n\t\t\tif (pps->lists_modification_present_flag /*TODO: && NumPicTotalCurr > 1*/) {\n\t\t\t\tif (!ref_pic_lists_modification(bs, si->slice_type, num_ref_idx_l0_active, num_ref_idx_l1_active)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\""[hevc] ref_pic_lists_modification( ) not implemented\\n\""));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \""mvd_l1_zero_flag\"");\n\t\t\tif (pps->cabac_init_present_flag)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \""cabac_init_flag\"");\n\n\t\t\tif (slice_temporal_mvp_enabled_flag) {\n\t\t\t\t// When collocated_from_l0_flag is not present, it is inferred to be equal to 1.\n\t\t\t\tBool collocated_from_l0_flag = 1;\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tcollocated_from_l0_flag = gf_bs_read_int_log(bs, 1, \""collocated_from_l0_flag\"");\n\n\t\t\t\tif ((collocated_from_l0_flag && (num_ref_idx_l0_active > 1))\n\t\t\t\t\t|| (!collocated_from_l0_flag && (num_ref_idx_l1_active > 1))\n\t\t\t\t) {\n\t\t\t\t\tgf_bs_read_ue_log(bs, \""collocated_ref_idx\"");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((pps->weighted_pred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_P)\n\t\t\t\t|| (pps->weighted_bipred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t) {\n\t\t\t\thevc_pred_weight_table(bs, hevc, si, pps, sps, num_ref_idx_l0_active, num_ref_idx_l1_active);\n\t\t\t}\n\t\t\tgf_bs_read_ue_log(bs, \""five_minus_max_num_merge_cand\"");\n\t\t}\n\t\tsi->slice_qp_delta_start_bits = (s32) (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\t\tsi->slice_qp_delta = gf_bs_read_se_log(bs, \""slice_qp_delta\"");\n\n\t\tif (pps->slice_chroma_qp_offsets_present_flag) {\n\t\t\tgf_bs_read_se_log(bs, \""slice_cb_qp_offset\"");\n\t\t\tgf_bs_read_se_log(bs, \""slice_cr_qp_offset\"");\n\t\t}\n\t\tif (pps->deblocking_filter_override_enabled_flag) {\n\t\t\tdeblocking_filter_override_flag = gf_bs_read_int_log(bs, 1, \""deblocking_filter_override_flag\"");\n\t\t}\n\n\t\tif (deblocking_filter_override_flag) {\n\t\t\tslice_deblocking_filter_disabled_flag = gf_bs_read_int_log(bs, 1, \""slice_deblocking_filter_disabled_flag\"");\n\t\t\tif (!slice_deblocking_filter_disabled_flag) {\n\t\t\t\tgf_bs_read_se_log(bs, \""slice_beta_offset_div2\"");\n\t\t\t\tgf_bs_read_se_log(bs, \""slice_tc_offset_div2\"");\n\t\t\t}\n\t\t}\n\t\tif (pps->loop_filter_across_slices_enabled_flag\n\t\t\t&& (slice_sao_luma_flag || slice_sao_chroma_flag || !slice_deblocking_filter_disabled_flag)\n\t\t) {\n\t\t\tgf_bs_read_int_log(bs, 1, \""slice_loop_filter_across_slices_enabled_flag\"");\n\t\t}\n\t}\n\t//dependent slice segment\n\telse {\n\t\t//if not asked to parse full header, abort\n\t\tif (!hevc->full_slice_header_parse) return 0;\n\t}\n\n\tsi->entry_point_start_bits = ((u32)gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\n\tif (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {\n\t\tu32 num_entry_point_offsets = gf_bs_read_ue_log(bs, \""num_entry_point_offsets\"");\n\t\tif (num_entry_point_offsets > 0) {\n\t\t\tu32 offset = gf_bs_read_ue_log(bs, \""offset\"") + 1;\n\t\t\tu32 segments = offset >> 4;\n\t\t\ts32 remain = (offset & 15);\n\n\t\t\tfor (i = 0; i < num_entry_point_offsets; i++) {\n\t\t\t\t//u32 res = 0;\n\t\t\t\tfor (j = 0; j < segments; j++) {\n\t\t\t\t\t//res <<= 16;\n\t\t\t\t\t/*res +=*/ gf_bs_read_int(bs, 16);\n\t\t\t\t}\n\t\t\t\tif (remain) {\n\t\t\t\t\t//res <<= remain;\n\t\t\t\t\t/* res += */ gf_bs_read_int(bs, remain);\n\t\t\t\t}\n\t\t\t\t// entry_point_offset = val + 1; // +1; // +1 to get the size\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pps->slice_segment_header_extension_present_flag) {\n\t\tu32 size_ext = gf_bs_read_ue_log(bs, \""size_ext\"");\n\t\twhile (size_ext) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tsize_ext--;\n\t\t}\n\t}\n\n\tsi->header_size_bits = (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs); // av_parser.c modified on 16 jan. 2019 \n\n\tif (gf_bs_read_int_log(bs, 1, \""byte_align\"") == 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\""Error parsing slice header: byte_align not found at end of header !\\n\""));\n\t}\n\n\tgf_bs_align(bs);\n\tsi->payload_start_offset = (s32)gf_bs_get_position(bs);\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""gf_hevc_read_pps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_hevc_read_pps_bs_internal(GF_BitStream *bs, HEVCState *hevc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tHEVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_ue_log(bs, \""pps_id\"");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] wrong PPS ID %d in PPS\\n\"", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &hevc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_ue_log(bs, \""sps_id\"");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] wrong SPS ID %d in PPS\\n\"", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\thevc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->dependent_slice_segments_enabled_flag = gf_bs_read_int_log(bs, 1, \""dependent_slice_segments_enabled_flag\"");\n\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \""output_flag_present_flag\"");\n\tpps->num_extra_slice_header_bits = gf_bs_read_int_log(bs, 3, \""num_extra_slice_header_bits\"");\n\tpps->sign_data_hiding_flag = gf_bs_read_int_log(bs, 1, \""sign_data_hiding_flag\"");\n\tpps->cabac_init_present_flag = gf_bs_read_int_log(bs, 1, \""cabac_init_present_flag\"");\n\tpps->num_ref_idx_l0_default_active = 1 + gf_bs_read_ue_log(bs, \""num_ref_idx_l0_default_active\"");\n\tpps->num_ref_idx_l1_default_active = 1 + gf_bs_read_ue_log(bs, \""num_ref_idx_l1_default_active\"");\n\tpps->pic_init_qp_minus26 = gf_bs_read_se_log(bs, \""pic_init_qp_minus26\"");\n\tpps->constrained_intra_pred_flag = gf_bs_read_int_log(bs, 1, \""constrained_intra_pred_flag\"");\n\tpps->transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \""transform_skip_enabled_flag\"");\n\tif ((pps->cu_qp_delta_enabled_flag = gf_bs_read_int_log(bs, 1, \""cu_qp_delta_enabled_flag\"")))\n\t\tpps->diff_cu_qp_delta_depth = gf_bs_read_ue_log(bs, \""diff_cu_qp_delta_depth\"");\n\n\tpps->pic_cb_qp_offset = gf_bs_read_se_log(bs, \""pic_cb_qp_offset\"");\n\tpps->pic_cr_qp_offset = gf_bs_read_se_log(bs, \""pic_cr_qp_offset\"");\n\tpps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int_log(bs, 1, \""slice_chroma_qp_offsets_present_flag\"");\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \""weighted_pred_flag\"");\n\tpps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, \""weighted_bipred_flag\"");\n\tpps->transquant_bypass_enable_flag = gf_bs_read_int_log(bs, 1, \""transquant_bypass_enable_flag\"");\n\tpps->tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \""tiles_enabled_flag\"");\n\tpps->entropy_coding_sync_enabled_flag = gf_bs_read_int_log(bs, 1, \""entropy_coding_sync_enabled_flag\"");\n\tif (pps->tiles_enabled_flag) {\n\t\tpps->num_tile_columns = 1 + gf_bs_read_ue_log(bs, \""num_tile_columns_minus1\"");\n\t\tpps->num_tile_rows = 1 + gf_bs_read_ue_log(bs, \""num_tile_rows_minus1\"");\n\t\tpps->uniform_spacing_flag = gf_bs_read_int_log(bs, 1, \""uniform_spacing_flag\"");\n\t\tif (!pps->uniform_spacing_flag) {\n\t\t\tfor (i = 0; i < pps->num_tile_columns - 1; i++) {\n\t\t\t\tpps->column_width[i] = 1 + gf_bs_read_ue_log_idx(bs, \""column_width_minus1\"", i);\n\t\t\t}\n\t\t\tfor (i = 0; i < pps->num_tile_rows - 1; i++) {\n\t\t\t\tpps->row_height[i] = 1 + gf_bs_read_ue_log_idx(bs, \""row_height_minus1\"", i);\n\t\t\t}\n\t\t}\n\t\tpps->loop_filter_across_tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \""loop_filter_across_tiles_enabled_flag\"");\n\t}\n\tpps->loop_filter_across_slices_enabled_flag = gf_bs_read_int_log(bs, 1, \""loop_filter_across_slices_enabled_flag\"");\n\tif ((pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \""deblocking_filter_control_present_flag\""))) {\n\t\tpps->deblocking_filter_override_enabled_flag = gf_bs_read_int_log(bs, 1, \""deblocking_filter_override_enabled_flag\"");\n\t\tif (! (pps->pic_disable_deblocking_filter_flag = gf_bs_read_int_log(bs, 1, \""pic_disable_deblocking_filter_flag\""))) {\n\t\t\tpps->beta_offset_div2 = gf_bs_read_se_log(bs, \""beta_offset_div2\"");\n\t\t\tpps->tc_offset_div2 = gf_bs_read_se_log(bs, \""tc_offset_div2\"");\n\t\t}\n\t}\n\tif ((pps->pic_scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \""pic_scaling_list_data_present_flag\""))) {\n\t\thevc_scaling_list_data(bs);\n\t}\n\tpps->lists_modification_present_flag = gf_bs_read_int_log(bs, 1, \""lists_modification_present_flag\"");\n\tpps->log2_parallel_merge_level_minus2 = gf_bs_read_ue_log(bs, \""log2_parallel_merge_level_minus2\"");\n\tpps->slice_segment_header_extension_present_flag = gf_bs_read_int_log(bs, 1, \""slice_segment_header_extension_present_flag\"");\n\tif (gf_bs_read_int_log(bs, 1, \""pps_extension_flag\"")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*pps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\treturn pps_id;\n}"", ""target"": 0}, {""func_name"": ""gf_hevc_read_vps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_hevc_read_vps_bs_internal(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)\n{\n\tu8 vps_sub_layer_ordering_info_present_flag, vps_extension_flag;\n\tu32 i, j;\n\ts32 vps_id;\n\tHEVC_VPS *vps;\n\tu8 layer_id_included_flag[MAX_LHVC_LAYERS][64];\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \""vps_id\"");\n\n\tif (vps_id >= 16) return -1;\n\n\tvps = &hevc->vps[vps_id];\n\tvps->bit_pos_vps_extensions = -1;\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\n\tvps->base_layer_internal_flag = gf_bs_read_int_log(bs, 1, \""base_layer_internal_flag\"");\n\tvps->base_layer_available_flag = gf_bs_read_int_log(bs, 1, \""base_layer_available_flag\"");\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \""max_layers_minus1\"");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] sorry, %d layers in VPS but only %d supported\\n\"", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \""max_sub_layers_minus1\"") + 1;\n\tvps->temporal_id_nesting = gf_bs_read_int_log(bs, 1, \""temporal_id_nesting\"");\n\tgf_bs_read_int_log(bs, 16, \""vps_reserved_ffff_16bits\"");\n\thevc_profile_tier_level(bs, 1, vps->max_sub_layers - 1, &vps->ptl, 0);\n\n\tvps_sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \""vps_sub_layer_ordering_info_present_flag\"");\n\tfor (i = (vps_sub_layer_ordering_info_present_flag ? 0 : vps->max_sub_layers - 1); i < vps->max_sub_layers; i++) {\n\t\tgf_bs_read_ue_log_idx(bs, \""vps_max_dec_pic_buffering_minus1\"", i);\n\t\tgf_bs_read_ue_log_idx(bs, \""vps_max_num_reorder_pics\"", i);\n\t\tgf_bs_read_ue_log_idx(bs, \""vps_max_latency_increase_plus1\"", i);\n\t}\n\tvps->max_layer_id = gf_bs_read_int_log(bs, 6, \""max_layer_id\"");\n\tif (vps->max_layer_id > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] VPS max layer ID %u but GPAC only supports %u\\n\"", vps->max_layer_id, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->num_layer_sets = gf_bs_read_ue_log(bs, \""num_layer_sets_minus1\"") + 1;\n\tif (vps->num_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] Wrong number of layer sets in VPS %d\\n\"", vps->num_layer_sets));\n\t\treturn -1;\n\t}\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tfor (j = 0; j <= vps->max_layer_id; j++) {\n\t\t\tlayer_id_included_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \""layer_id_included_flag\"", i, j);\n\t\t}\n\t}\n\tvps->num_layers_in_id_list[0] = 1;\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tu32 n, m;\n\t\tn = 0;\n\t\tfor (m = 0; m <= vps->max_layer_id; m++) {\n\t\t\tif (layer_id_included_flag[i][m]) {\n\t\t\t\tvps->LayerSetLayerIdList[i][n++] = m;\n\t\t\t\tif (vps->LayerSetLayerIdListMax[i] < m)\n\t\t\t\t\tvps->LayerSetLayerIdListMax[i] = m;\n\t\t\t}\n\t\t}\n\t\tvps->num_layers_in_id_list[i] = n;\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \""vps_timing_info_present_flag\"")) {\n\t\tu32 vps_num_hrd_parameters;\n\t\tgf_bs_read_int_log(bs, 32, \""vps_num_units_in_tick\"");\n\t\tgf_bs_read_int_log(bs, 32, \""vps_time_scale\"");\n\t\tif (gf_bs_read_int_log(bs, 1, \""vps_poc_proportional_to_timing_flag\"")) {\n\t\t\tgf_bs_read_ue_log(bs, \""vps_num_ticks_poc_diff_one_minus1\"");\n\t\t}\n\t\tvps_num_hrd_parameters = gf_bs_read_ue_log(bs, \""vps_num_hrd_parameters\"");\n\t\tfor (i = 0; i < vps_num_hrd_parameters; i++) {\n\t\t\tBool cprms_present_flag = GF_TRUE;\n\t\t\tgf_bs_read_ue_log_idx(bs, \""hrd_layer_set_idx\"", i);\n\t\t\tif (i > 0)\n\t\t\t\tcprms_present_flag = gf_bs_read_int_log(bs, 1, \""cprms_present_flag\"");\n\t\t\thevc_parse_hrd_parameters(bs, cprms_present_flag, vps->max_sub_layers - 1, i);\n\t\t}\n\t}\n\tif (stop_at_vps_ext) {\n\t\treturn vps_id;\n\t}\n\n\tvps_extension_flag = gf_bs_read_int_log(bs, 1, \""vps_extension_flag\"");\n\tif (vps_extension_flag) {\n\t\tBool res;\n\t\tgf_bs_align(bs);\n\t\tres = hevc_parse_vps_extension(vps, bs);\n\t\tif (res != GF_TRUE) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] Failed to parse VPS extensions\\n\""));\n\t\t\treturn -1;\n\t\t}\n\t\tif (gf_bs_read_int_log(bs, 1, \""vps_extension2_flag\"")) {\n#if 0\n\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t/*vps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t\t}\n#endif\n\n\t\t}\n\t}\n\treturn vps_id;\n}"", ""target"": 0}, {""func_name"": ""gf_avc_read_sps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \""forbidden_zero_bit\"");\n\t\tgf_bs_read_int_log(bs, 2, \""nal_ref_idc\"");\n\t\tgf_bs_read_int_log(bs, 5, \""nal_unit_type\"");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \""profile_idc\"");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \""profile_compatibility\"");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \""level_idc\"");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \""sps_id\"") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif (sps_id >= 32) {\n\t\treturn -1;\n\t}\n\tif (sps_id < 0) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \""chroma_format_idc\"");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \""separate_colour_plane_flag\"");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \""luma_bit_depth\"");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \""chroma_bit_depth\"");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \""qpprime_y_zero_transform_bypass_flag\"");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \""seq_scaling_matrix_present_flag\"")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \""seq_scaling_list_present_flag\"", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \""log2_max_frame_num\"") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \""poc_type\"");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \""log2_max_poc_lsb\"") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \""delta_pic_order_always_zero_flag\"");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \""offset_for_non_ref_pic\"");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \""offset_for_top_to_bottom_field\"");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \""poc_cycle_length\"");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\""));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \""offset_for_ref_frame\"", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \""max_num_ref_frames\"");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \""gaps_in_frame_num_value_allowed_flag\"");\n\tmb_width = gf_bs_read_ue_log(bs, \""pic_width_in_mbs_minus1\"") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \""pic_height_in_map_units_minus1\"") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \""frame_mbs_only_flag\"");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \""mb_adaptive_frame_field_flag\"");\n\tgf_bs_read_int_log(bs, 1, \""direct_8x8_inference_flag\"");\n\n\tif (gf_bs_read_int_log(bs, 1, \""frame_cropping_flag\"")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \""frame_crop_left_offset\"");\n\t\tcr = gf_bs_read_ue_log(bs, \""frame_crop_right_offset\"");\n\t\tct = gf_bs_read_ue_log(bs, \""frame_crop_top_offset\"");\n\t\tcb = gf_bs_read_ue_log(bs, \""frame_crop_bottom_offset\"");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""vui_parameters_present_flag\"");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \""aspect_ratio_info_present_flag\"");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \""aspect_ratio_idc\"");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \""aspect_ratio_num\"");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \""aspect_ratio_den\"");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\""));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \""overscan_info_present_flag\"");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \""overscan_appropriate_flag\"");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \""video_signal_type_present_flag\"");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \""video_format\"");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \""video_full_range_flag\"");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \""colour_description_present_flag\"");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \""colour_primaries\"");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \""transfer_characteristics\"");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \""matrix_coefficients\"");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \""chroma_location_info_present_flag\"")) {\n\t\t\tgf_bs_read_ue_log(bs, \""chroma_sample_location_type_top_field\"");\n\t\t\tgf_bs_read_ue_log(bs, \""chroma_sample_location_type_bottom_field\"");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \""timing_info_present_flag\"");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \""num_units_in_tick\"");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \""time_scale\"");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \""fixed_frame_rate_flag\"");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""nal_hrd_parameters_present_flag\"");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""vcl_hrd_parameters_present_flag\"");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \""low_delay_hrd_flag\"");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \""pic_struct_present_flag\"");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \""inter_layer_deblocking_filter_control_present_flag\"");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \""extended_spatial_scalability_idc\"");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \""chroma_phase_x_plus1_flag\"");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \""chroma_phase_y_plus1\"");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""seq_ref_layer_chroma_phase_x_plus1_flag\"");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \""seq_ref_layer_chroma_phase_y_plus1\"");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \""seq_scaled_ref_layer_left_offset\"");\n\t\t\t\tgf_bs_read_se_log(bs, \""seq_scaled_ref_layer_top_offset\"");\n\t\t\t\tgf_bs_read_se_log(bs, \""seq_scaled_ref_layer_right_offset\"");\n\t\t\t\tgf_bs_read_se_log(bs, \""seq_scaled_ref_layer_bottom_offset\"");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \""seq_tcoeff_level_prediction_flag\"")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \""adaptive_tcoeff_level_prediction_flag\"");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \""slice_header_restriction_flag\"");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \""svc_vui_parameters_present\"")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \""vui_ext_num_entries_minus1\"");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \""vui_ext_dependency_id\"");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \""vui_ext_quality_id\"");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \""vui_ext_temporal_id\"");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \""vui_ext_timing_info_present_flag\"");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \""vui_ext_num_units_in_tick\"");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \""vui_ext_time_scale\"");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""vui_ext_fixed_frame_rate_flag\"");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""vui_ext_nal_hrd_parameters_present_flag\"");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""vui_ext_vcl_hrd_parameters_present_flag\"");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""vui_ext_low_delay_hrd_flag\"");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""vui_ext_pic_struct_present_flag\"");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\""));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \""additional_extension2\"")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\""));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}"", ""target"": 0}, {""func_name"": ""gf_media_vvc_read_vps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)\n{\n\tu32 i, j;\n\ts32 vps_id;\n\tVVC_VPS *vps;\n\tBool vps_default_ptl_dpb_hrd_max_tid_flag=0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \""vps_id\"");\n\tif (vps_id >= 16) return -1;\n\tif (!vps_id) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[VVC] VPS ID 0 is forbidden\\n\""));\n\t\treturn -1;\n\t}\n\tvps = &vvc->vps[vps_id];\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \""max_layers\"");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[VVC] sorry, %d layers in VPS but only %d supported\\n\"", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \""max_sub_layers_minus1\"") + 1;\n\n\tif ((vps->max_layers>1) && (vps->max_sub_layers>1))\n\t\tvps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, \""vps_default_ptl_dpb_hrd_max_tid_flag\"");\n\n\tif (vps->max_layers>1)\n\t\tvps->all_layers_independent = gf_bs_read_int_log(bs, 1, \""all_layers_independent\"");\n\n\tfor (i=0; i<vps->max_layers; i++) {\n\t\tu32 layer_id = gf_bs_read_int_log_idx(bs, 6, \""layer_id\"", i);\n\t\tif (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id;\n\t\tif (i && !vps->all_layers_independent) {\n\t\t\tBool layer_indep = gf_bs_read_int_log_idx(bs, 1, \""layer_independent\"", i);\n\t\t\tif (!layer_indep) {\n\t\t\t\tBool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, \""vps_max_tid_ref_present_flag\"", i);\n\t\t\t\tfor (j=0; j<i; j++) {\n\t\t\t\t\tBool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, \""vps_direct_ref_layer_flag\"", i, j);\n\t\t\t\t\tif (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \""vps_max_tid_il_ref_pics_plus1\"", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvps->num_ptl = 1;\n\tif (vps->max_layers > 1) {\n\t\tif (vps->all_layers_independent) {\n\t\t\tvps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, \""each_layer_is_ols\"");\n\t\t}\n\t\tif (!vps->each_layer_is_ols) {\n\t\t\tu32 vps_ols_mode_idc = 2;\n\t\t\tif (!vps->all_layers_independent) {\n\t\t\t\tvps_ols_mode_idc = gf_bs_read_int_log(bs, 2, \""vps_ols_mode_idc\"");\n\t\t\t}\n\t\t\tif (vps_ols_mode_idc==2) {\n\t\t\t\tu8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, \""vps_num_output_layer_sets_minus2\"");\n\t\t\t\tfor (i=0; i<vps_num_output_layer_sets; i++) {\n\t\t\t\t\tfor (j=0; j<vps->max_layers; j++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 1, \""vps_ols_output_layer_flag\"", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, \""num_ptl_minus1\"");\n\t}\n\tvps->ptl[0].pt_present = 1;\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tif (i)\n\t\t\tvps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, \""pt_present\"", i);\n\t\tif (!vps_default_ptl_dpb_hrd_max_tid_flag)\n\t\t\tvps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, \""ptl_max_tid\"", i);\n\t\telse\n\t\t\tvps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;;\n\t}\n\t//align\n\tgf_bs_align(bs);\n\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tvvc_profile_tier_level(bs, &vps->ptl[i], i);\n\t}\n\n\t//TODO, parse multilayer stuff\n\treturn vps_id;\n}"", ""target"": 0}, {""func_name"": ""gf_avc_read_pps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)\n{\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \""forbidden_zero_bit\"");\n\t\tgf_bs_read_int_log(bs, 2, \""nal_ref_idc\"");\n\t\tgf_bs_read_int_log(bs, 5, \""nal_unit_type\"");\n\t}\n\tpps_id = gf_bs_read_ue_log(bs, \""pps_id\"");\n\tif (pps_id >= 255) {\n\t\treturn -1;\n\t}\n\tpps = &avc->pps[pps_id];\n\tpps->id = pps_id;\n\n\tif (!pps->status) pps->status = 1;\n\tpps->sps_id = gf_bs_read_ue_log(bs, \""sps_id\"");\n\tif (pps->sps_id >= 32) {\n\t\tpps->sps_id = 0;\n\t\treturn -1;\n\t}\n\t/*sps_id may be refer to regular SPS or subseq sps, depending on the coded slice referring to the pps*/\n\tif (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\treturn -1;\n\t}\n\tavc->pps_active_idx = pps->id; /*set active sps*/\n\tavc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, \""entropy_coding_mode_flag\"");\n\tpps->pic_order_present = gf_bs_read_int_log(bs, 1, \""pic_order_present\"");\n\tpps->slice_group_count = gf_bs_read_ue_log(bs, \""slice_group_count_minus1\"") + 1;\n\tif (pps->slice_group_count > 1) {\n\t\tu32 iGroup;\n\t\tpps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, \""mb_slice_group_map_type\"");\n\t\tif (pps->mb_slice_group_map_type == 0) {\n\t\t\tfor (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++)\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \""run_length_minus1\"", iGroup);\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 2) {\n\t\t\tfor (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \""top_left\"", iGroup);\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \""bottom_right\"", iGroup);\n\t\t\t}\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) {\n\t\t\tgf_bs_read_int_log(bs, 1, \""slice_group_change_direction_flag\"");\n\t\t\tgf_bs_read_ue_log(bs, \""slice_group_change_rate_minus1\"");\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 6) {\n\t\t\tu32 i;\n\t\t\tpps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, \""pic_size_in_map_units_minus1\"");\n\t\t\tfor (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), \""slice_group_id\"", i);\n\t\t\t}\n\t\t}\n\t}\n\tpps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, \""num_ref_idx_l0_default_active_minus1\"");\n\tpps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, \""num_ref_idx_l1_default_active_minus1\"");\n\n\t/*\n\tif ((pps->ref_count[0] > 32) || (pps->ref_count[1] > 32)) goto exit;\n\t*/\n\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \""weighted_pred_flag\"");\n\tgf_bs_read_int_log(bs, 2, \""weighted_bipred_idc\"");\n\tgf_bs_read_se_log(bs, \""init_qp_minus26\"");\n\tgf_bs_read_se_log(bs, \""init_qs_minus26\"");\n\tgf_bs_read_se_log(bs, \""chroma_qp_index_offset\"");\n\tpps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \""deblocking_filter_control_present_flag\"");\n\tgf_bs_read_int_log(bs, 1, \""constrained_intra_pred\"");\n\tpps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, \""redundant_pic_cnt_present\"");\n\n\treturn pps_id;\n}"", ""target"": 0}, {""func_name"": ""vvc_parse_picture_header"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static\ns32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)\n{\n\tu32 pps_id;\n\n\tsi->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, \""irap_or_gdr_pic\"");\n\tsi->non_ref_pic = gf_bs_read_int_log(bs, 1, \""non_ref_pic\"");\n\tif (si->irap_or_gdr_pic)\n\t\tsi->gdr_pic = gf_bs_read_int_log(bs, 1, \""gdr_pic\"");\n\tif ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \""inter_slice_allowed_flag\"")))\n\t\tsi->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \""intra_slice_allowed_flag\"");\n\n\tpps_id = gf_bs_read_ue_log(bs, \""pps_id\"");\n\tif (pps_id >= 64)\n\t\treturn -1;\n\tsi->pps = &vvc->pps[pps_id];\n\tsi->sps = &vvc->sps[si->pps->sps_id];\n\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \""poc_lsb\"");\n\n\tsi->recovery_point_valid = 0;\n\tsi->gdr_recovery_count = 0;\n\tif (si->gdr_pic) {\n\t\tsi->recovery_point_valid = 1;\n\t\tsi->gdr_recovery_count = gf_bs_read_ue_log(bs, \""gdr_recovery_count\"");\n\t}\n\tgf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, \""ph_extra_bits\"");\n\n\tif (si->sps->poc_msb_cycle_flag) {\n\t\tif ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, \""poc_msb_cycle_present_flag\""))) {\n\t\t\tsi->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, \""poc_msb_cycle\"");\n\t\t}\n\t}\n\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""gf_media_vvc_read_pps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tVVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_int_log(bs, 6, \""pps_id\"");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[VVC] wrong PPS ID %d in PPS\\n\"", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \""sps_id\"");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[VVC] wrong SPS ID %d in PPS\\n\"", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \""mixed_nal_types\"");\n\tpps->width = gf_bs_read_ue_log(bs, \""width\"");\n\tpps->height = gf_bs_read_ue_log(bs, \""height\"");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \""conformance_window_flag\"");\n\tif (pps->conf_window) {\n\t\tpps->cw_left = gf_bs_read_ue_log(bs, \""conf_win_left_offset\"");\n\t\tpps->cw_right = gf_bs_read_ue_log(bs, \""conf_win_right_offset\"");\n\t\tpps->cw_top = gf_bs_read_ue_log(bs, \""conf_win_top_offset\"");\n\t\tpps->cw_bottom = gf_bs_read_ue_log(bs, \""conf_win_bottom_offset\"");\n\t}\n\t//scaling window\n\tif (gf_bs_read_int_log(bs, 1, \""scaling_window_explicit_signalling_flag\"")) {\n\t\tgf_bs_read_se_log(bs, \""scaling_win_left_offset\"");\n\t\tgf_bs_read_se_log(bs, \""scaling_win_right_offset\"");\n\t\tgf_bs_read_se_log(bs, \""scaling_win_top_offset\"");\n\t\tgf_bs_read_se_log(bs, \""scaling_win_bottom_offset\"");\n\t}\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \""output_flag_present_flag\"");\n\tpps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, \""no_pic_partition_flag\"");\n\tpps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, \""subpic_id_mapping_present_flag\"");\n\tif (pps->subpic_id_mapping_present_flag) {\n\t\tu32 pps_subpic_id_len, pps_num_subpics=0;\n\t\tif (!pps->no_pic_partition_flag) {\n\t\t\tpps_num_subpics = 1+gf_bs_read_ue_log(bs, \""pps_num_subpics_minus1\"");\n\t\t}\n\t\tpps_subpic_id_len = 1 + gf_bs_read_ue(bs);\n\t\tfor (i=0; i<pps_num_subpics; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, pps_subpic_id_len, \""subpic_id\"", i);\n\t\t}\n\t}\n\tif (!pps->no_pic_partition_flag) {\n\t\tgf_bs_read_int_log(bs, 2, \""pps_log2_ctu_size_minus5\"");\n\t\tu32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, \""num_exp_tile_columns_minus1\"");\n\t\tu32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, \""num_exp_tile_rows_minus1\"");\n\t\tfor (i=0; i<num_exp_tile_columns; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \""tile_column_width_minus1\"", i);\n\t\tfor (i=0; i<num_exp_tile_rows; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \""tile_row_height_minus1\"", i);\n\n\t\t//todo parse the rest\n\t\treturn pps_id;\n\t}\n\n\n\t//todo parse the rest\n\n\treturn pps_id;\n}"", ""target"": 0}, {""func_name"": ""gf_hevc_read_sps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id = -1;\n\tu32 i, nb_CTUs, depth;\n\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tBool multiLayerExtSpsFlag;\n\tu8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \""vps_id\"");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \""max_sub_layers_minus1\"");\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \""sps_ext_or_max_sub_layers_minus1\"");\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);\n\tif (!multiLayerExtSpsFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \""temporal_id_nesting_flag\"");\n\t\thevc_profile_tier_level(bs, 1, max_sub_layers_minus1, &ptl, 0);\n\t}\n\n\tsps_id = gf_bs_read_ue_log(bs, \""sps_id\"");\n\tif ((sps_id < 0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\n\tsps = &hevc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->ptl = ptl;\n\tvps = &hevc->vps[vps_id];\n\tsps->max_sub_layers_minus1 = 0;\n\tsps->sps_ext_or_max_sub_layers_minus1 = 0;\n\n\t/* default values */\n\tsps->colour_primaries = 2;\n\tsps->transfer_characteristic = 2;\n\tsps->matrix_coeffs = 2;\n\n\t//sps_rep_format_idx = 0;\n\tif (multiLayerExtSpsFlag) {\n\t\tsps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, \""update_rep_format_flag\"");\n\t\tif (sps->update_rep_format_flag) {\n\t\t\tsps->rep_format_idx = gf_bs_read_int_log(bs, 8, \""rep_format_idx\"");\n\t\t}\n\t\telse {\n\t\t\tsps->rep_format_idx = vps->rep_format_idx[layer_id];\n\t\t}\n\t\tsps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;\n\t\tsps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;\n\t\tsps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;\n\t\tsps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;\n\t\tsps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;\n\t\tsps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;\n\n\t\t//TODO this is crude ...\n\t\tsps->ptl = vps->ext_ptl[0];\n\t}\n\telse {\n\t\tsps->chroma_format_idc = gf_bs_read_ue_log(bs, \""chroma_format_idc\"");\n\t\tif (sps->chroma_format_idc == 3)\n\t\t\tsps->separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \""separate_colour_plane_flag\"");\n\t\tsps->width = gf_bs_read_ue_log(bs, \""width\"");\n\t\tsps->height = gf_bs_read_ue_log(bs, \""height\"");\n\t\tif ((sps->cw_flag = gf_bs_read_int_log(bs, 1, \""conformance_window_flag\""))) {\n\t\t\tu32 SubWidthC, SubHeightC;\n\n\t\t\tif (sps->chroma_format_idc == 1) {\n\t\t\t\tSubWidthC = SubHeightC = 2;\n\t\t\t}\n\t\t\telse if (sps->chroma_format_idc == 2) {\n\t\t\t\tSubWidthC = 2;\n\t\t\t\tSubHeightC = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSubWidthC = SubHeightC = 1;\n\t\t\t}\n\n\t\t\tsps->cw_left = gf_bs_read_ue_log(bs, \""conformance_window_left\"");\n\t\t\tsps->cw_right = gf_bs_read_ue_log(bs, \""conformance_window_right\"");\n\t\t\tsps->cw_top = gf_bs_read_ue_log(bs, \""conformance_window_top\"");\n\t\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \""conformance_window_bottom\"");\n\n\t\t\tsps->width -= SubWidthC * (sps->cw_left + sps->cw_right);\n\t\t\tsps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);\n\t\t}\n\t\tsps->bit_depth_luma = 8 + gf_bs_read_ue_log(bs, \""bit_depth_luma_minus8\"");\n\t\tsps->bit_depth_chroma = 8 + gf_bs_read_ue_log(bs, \""bit_depth_chroma_minus8\"");\n\t}\n\n\tsps->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(bs, \""log2_max_pic_order_cnt_lsb_minus4\"");\n\n\tif (!multiLayerExtSpsFlag) {\n\t\tsps->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \""sub_layer_ordering_info_present_flag\"");\n\t\tfor (i = sps->sub_layer_ordering_info_present_flag ? 0 : sps->max_sub_layers_minus1; i <= sps->max_sub_layers_minus1; i++) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \""max_dec_pic_buffering\"", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \""num_reorder_pics\"", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \""max_latency_increase\"", i);\n\t\t}\n\t}\n\n\tsps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, \""log2_min_luma_coding_block_size_minus3\"");\n\tsps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, \""log2_diff_max_min_luma_coding_block_size\"");\n\tsps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\tsps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\n\tsps->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(bs, \""log2_min_transform_block_size_minus2\"");\n\tsps->log2_max_transform_block_size = sps->log2_min_transform_block_size  + gf_bs_read_ue_log(bs, \""log2_max_transform_block_size\"");\n\n\tdepth = 0;\n\tsps->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(bs, \""max_transform_hierarchy_depth_inter\"");\n\tsps->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(bs, \""max_transform_hierarchy_depth_intra\"");\n\twhile ((u32)(sps->max_CU_width >> sps->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (sps->log2_min_transform_block_size + depth)))\n\t{\n\t\tdepth++;\n\t}\n\tsps->max_CU_depth = sps->log2_diff_max_min_luma_coding_block_size + depth;\n\n\tnb_CTUs = ((sps->width + sps->max_CU_width - 1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height - 1) / sps->max_CU_height);\n\tsps->bitsSliceSegmentAddress = 0;\n\twhile (nb_CTUs > (u32)(1 << sps->bitsSliceSegmentAddress)) {\n\t\tsps->bitsSliceSegmentAddress++;\n\t}\n\n\tsps->scaling_list_enable_flag = gf_bs_read_int_log(bs, 1, \""scaling_list_enable_flag\"");\n\tif (sps->scaling_list_enable_flag) {\n\t\tsps->infer_scaling_list_flag = 0;\n\t\tsps->scaling_list_ref_layer_id = 0;\n\t\tif (multiLayerExtSpsFlag) {\n\t\t\tsps->infer_scaling_list_flag = gf_bs_read_int_log(bs, 1, \""infer_scaling_list_flag\"");\n\t\t}\n\t\tif (sps->infer_scaling_list_flag) {\n\t\t\tsps->scaling_list_ref_layer_id = gf_bs_read_int_log(bs, 6, \""scaling_list_ref_layer_id\"");\n\t\t}\n\t\telse {\n\t\t\tsps->scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \""scaling_list_data_present_flag\"");\n\t\t\tif (sps->scaling_list_data_present_flag) {\n\t\t\t\thevc_scaling_list_data(bs);\n\t\t\t}\n\t\t}\n\t}\n\tsps->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(bs, 1, \""asymmetric_motion_partitions_enabled_flag\"");\n\tsps->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(bs, 1, \""sample_adaptive_offset_enabled_flag\"");\n\tif ( (sps->pcm_enabled_flag = gf_bs_read_int_log(bs, 1, \""pcm_enabled_flag\"")) ) {\n\t\tsps->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(bs, 4, \""pcm_sample_bit_depth_luma_minus1\"");\n\t\tsps->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(bs, 4, \""pcm_sample_bit_depth_chroma_minus1\"");\n\t\tsps->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(bs, \""log2_min_pcm_luma_coding_block_size_minus3\"");\n\t\tsps->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(bs, \""log2_diff_max_min_pcm_luma_coding_block_size\"");\n\t\tsps->pcm_loop_filter_disable_flag = gf_bs_read_int_log(bs, 1, \""pcm_loop_filter_disable_flag\"");\n\t}\n\tsps->num_short_term_ref_pic_sets = gf_bs_read_ue_log(bs, \""num_short_term_ref_pic_sets\"");\n\tif (sps->num_short_term_ref_pic_sets > 64) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] Invalid number of short term reference picture sets %d\\n\"", sps->num_short_term_ref_pic_sets));\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sps->num_short_term_ref_pic_sets; i++) {\n\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, i);\n\t\t/*cannot parse short_term_ref_pic_set, skip VUI parsing*/\n\t\tif (!ret) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] Invalid short_term_ref_pic_set\\n\""));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tsps->long_term_ref_pics_present_flag = gf_bs_read_int_log(bs, 1, \""long_term_ref_pics_present_flag\"");\n\tif (sps->long_term_ref_pics_present_flag) {\n\t\tsps->num_long_term_ref_pic_sps = gf_bs_read_ue_log(bs, \""num_long_term_ref_pic_sps\"");\n\t\tfor (i = 0; i < sps->num_long_term_ref_pic_sps; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \""lt_ref_pic_poc_lsb_sps\"", i);\n\t\t\tgf_bs_read_int_log_idx(bs, 1, \""used_by_curr_pic_lt_sps_flag\"", i);\n\t\t}\n\t}\n\tsps->temporal_mvp_enable_flag = gf_bs_read_int_log(bs, 1, \""temporal_mvp_enable_flag\"");\n\tsps->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(bs, 1, \""strong_intra_smoothing_enable_flag\"");\n\n\tif (vui_flag_pos)\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\n\tif ((sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""vui_parameters_present_flag\"")) ) {\n\t\tsps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \""aspect_ratio_info_present_flag\"");\n\t\tif (sps->aspect_ratio_info_present_flag) {\n\t\t\tsps->sar_idc = gf_bs_read_int_log(bs, 8, \""aspect_ratio_idc\"");\n\t\t\tif (sps->sar_idc == 255) {\n\t\t\t\tsps->sar_width = gf_bs_read_int_log(bs, 16, \""aspect_ratio_width\"");\n\t\t\t\tsps->sar_height = gf_bs_read_int_log(bs, 16, \""aspect_ratio_height\"");\n\t\t\t}\n\t\t\telse if (sps->sar_idc < 17) {\n\t\t\t\tsps->sar_width = hevc_sar[sps->sar_idc].w;\n\t\t\t\tsps->sar_height = hevc_sar[sps->sar_idc].h;\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->overscan_info_present = gf_bs_read_int_log(bs, 1, \""overscan_info_present\"")))\n\t\t\tsps->overscan_appropriate = gf_bs_read_int_log(bs, 1, \""overscan_appropriate\"");\n\n\t\tsps->video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \""video_signal_type_present_flag\"");\n\t\tif (sps->video_signal_type_present_flag) {\n\t\t\tsps->video_format = gf_bs_read_int_log(bs, 3, \""video_format\"");\n\t\t\tsps->video_full_range_flag = gf_bs_read_int_log(bs, 1, \""video_full_range_flag\"");\n\t\t\tif ((sps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, \""colour_description_present_flag\""))) {\n\t\t\t\tsps->colour_primaries = gf_bs_read_int_log(bs, 8, \""colour_primaries\"");\n\t\t\t\tsps->transfer_characteristic = gf_bs_read_int_log(bs, 8, \""transfer_characteristic\"");\n\t\t\t\tsps->matrix_coeffs = gf_bs_read_int_log(bs, 8, \""matrix_coefficients\"");\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->chroma_loc_info_present_flag = gf_bs_read_int_log(bs, 1, \""chroma_loc_info_present_flag\""))) {\n\t\t\tsps->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(bs, \""chroma_sample_loc_type_top_field\"");\n\t\t\tsps->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(bs, \""chroma_sample_loc_type_bottom_field\"");\n\t\t}\n\n\t\tsps->neutra_chroma_indication_flag = gf_bs_read_int_log(bs, 1, \""neutra_chroma_indication_flag\"");\n\t\tsps->field_seq_flag = gf_bs_read_int_log(bs, 1, \""field_seq_flag\"");\n\t\tsps->frame_field_info_present_flag = gf_bs_read_int_log(bs, 1, \""frame_field_info_present_flag\"");\n\n\t\tif ((sps->default_display_window_flag = gf_bs_read_int_log(bs, 1, \""default_display_window_flag\""))) {\n\t\t\tsps->left_offset = gf_bs_read_ue_log(bs, \""display_window_left_offset\"");\n\t\t\tsps->right_offset = gf_bs_read_ue_log(bs, \""display_window_right_offset\"");\n\t\t\tsps->top_offset = gf_bs_read_ue_log(bs, \""display_window_top_offset\"");\n\t\t\tsps->bottom_offset = gf_bs_read_ue_log(bs, \""display_window_bottom_offset\"");\n\t\t}\n\n\t\tsps->has_timing_info = gf_bs_read_int_log(bs, 1, \""has_timing_info\"");\n\t\tif (sps->has_timing_info) {\n\t\t\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \""num_units_in_tick\"");\n\t\t\tsps->time_scale = gf_bs_read_int_log(bs, 32, \""time_scale\"");\n\t\t\tsps->poc_proportional_to_timing_flag = gf_bs_read_int_log(bs, 1, \""poc_proportional_to_timing_flag\"");\n\t\t\tif (sps->poc_proportional_to_timing_flag)\n\t\t\t\tsps->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(bs, \""num_ticks_poc_diff_one_minus1\"");\n\t\t\tif ((sps->hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""hrd_parameters_present_flag\""))) {\n\t\t\t\t//\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\""[HEVC] HRD param parsing not implemented\\n\""));\n\t\t\t\treturn sps_id;\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \""bitstream_restriction_flag\"")) {\n\t\t\tgf_bs_read_int_log(bs, 1, \""tiles_fixed_structure_flag\"");\n\t\t\tgf_bs_read_int_log(bs, 1, \""motion_vectors_over_pic_boundaries_flag\"");\n\t\t\tgf_bs_read_int_log(bs, 1, \""restricted_ref_pic_lists_flag\"");\n\t\t\tgf_bs_read_ue_log(bs, \""min_spatial_segmentation_idc\"");\n\t\t\tgf_bs_read_ue_log(bs, \""max_bytes_per_pic_denom\"");\n\t\t\tgf_bs_read_ue_log(bs, \""max_bits_per_min_cu_denom\"");\n\t\t\tgf_bs_read_ue_log(bs, \""log2_max_mv_length_horizontal\"");\n\t\t\tgf_bs_read_ue_log(bs, \""log2_max_mv_length_vertical\"");\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \""sps_extension_flag\"")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*sps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\n\treturn sps_id;\n}"", ""target"": 0}, {""func_name"": ""gf_media_vvc_read_sps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \""sps_id\"");\n\tif (sps_id >= 16) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \""vps_id\"");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, \""max_sublayers_minus1\"");\n\tsps->chroma_format_idc = gf_bs_read_int_log(bs, 2, \""chroma_format_idc\"");\n\tsps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, \""log2_ctu_size_minus5\"");\n\tCtbSizeY = 1<<sps->log2_ctu_size;\n\n\tsps_ptl_dpb_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \""sps_ptl_dpb_hrd_params_present_flag\"");\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tVVC_ProfileTierLevel ptl, *p_ptl;\n\t\tif (sps->vps_id) {\n\t\t\tp_ptl = &ptl;\n\t\t} else {\n\t\t\tp_ptl = &vvc->vps[0].ptl[0];\n\t\t}\n\t\tmemset(p_ptl, 0, sizeof(VVC_ProfileTierLevel));\n\t\tp_ptl->pt_present = 1;\n\t\tp_ptl->ptl_max_tid = sps->max_sublayers;\n\t\tvvc_profile_tier_level(bs, p_ptl, 0);\n\t}\n\tsps->gdr_enabled = gf_bs_read_int_log(bs, 1, \""gdr_enabled\"");\n\tsps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, \""ref_pic_resampling\"");\n\tif (sps->ref_pic_resampling)\n\t\tsps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, \""res_change_in_clvs\"");\n\tsps->width = gf_bs_read_ue_log(bs, \""width\"");\n\tsps->height = gf_bs_read_ue_log(bs, \""height\"");\n\tsps->conf_window = gf_bs_read_int_log(bs, 1, \""conformance_window_present_flag\"");\n\tif (sps->conf_window) {\n\t\tsps->cw_left = gf_bs_read_ue_log(bs, \""conformance_window_left\"");\n\t\tsps->cw_right = gf_bs_read_ue_log(bs, \""conformance_window_right\"");\n\t\tsps->cw_top = gf_bs_read_ue_log(bs, \""conformance_window_top\"");\n\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \""conformance_window_bottom\"");\n\t}\n\tsps->subpic_info_present = gf_bs_read_int_log(bs, 1, \""subpic_info_present\"");\n\tif (sps->subpic_info_present) {\n\t\tsps->nb_subpics = 1 + gf_bs_read_ue_log(bs, \""nb_subpics_minus1\"");\n\t\tif (sps->nb_subpics>1) {\n\t\t\tu32 tmpWidthVal, tmpHeightVal;\n\t\t\tsps->independent_subpic_flags = gf_bs_read_int_log(bs, 1, \""independent_subpic_flags\"");\n\t\t\tsps->subpic_same_size = gf_bs_read_int_log(bs, 1, \""subpic_same_size\"");\n\n\t\t\ttmpWidthVal = (sps->width + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpWidthVal = gf_get_bit_size(tmpWidthVal);\n\t\t\ttmpHeightVal = (sps->height + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpHeightVal = gf_get_bit_size(tmpHeightVal);\n\n\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\tif( !sps->subpic_same_size || !i) {\n\t\t\t\t\tif (i && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \""subpic_ctu_top_left_x\"");\n\t\t\t\t\tif (i && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \""subpic_ctu_top_left_y\"");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \""subpic_width_minus1\"");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \""subpic_height_minus1\"");\n\t\t\t\t}\n\t\t\t\tif (!sps->independent_subpic_flags) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""subpic_treated_as_pic_flag\"");\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""loop_filter_across_subpic_enabled_flag\"");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsps->subpicid_len = gf_bs_read_ue_log(bs, \""subpic_id_len_minus1\"") + 1;\n\t\t\tsps->subpicid_mapping_explicit = gf_bs_read_int_log(bs, 1, \""subpic_id_mapping_explicitly_signalled_flag\"");\n\t\t\tif (sps->subpicid_mapping_explicit) {\n\t\t\t\tsps->subpicid_mapping_present = gf_bs_read_int_log(bs, 1, \""subpic_id_mapping_present_flag\"");\n\t\t\t\tif (sps->subpicid_mapping_present) {\n\t\t\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\t\t\tgf_bs_read_ue_log(bs, \""subpic_id\"");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsps->bitdepth = gf_bs_read_ue_log(bs, \""bitdepth_minus8\"") + 8;\n\tgf_bs_read_int_log(bs, 1, \""entropy_coding_sync_enabled_flag\"");\n\tgf_bs_read_int_log(bs, 1, \""entry_point_offsets_present_flag\"");\n\tsps->log2_max_poc_lsb = 4 + gf_bs_read_int_log(bs, 4, \""log2_max_poc_lsb_minus4\"");\n\tif ((sps->poc_msb_cycle_flag = gf_bs_read_int_log(bs, 1, \""poc_msb_cycle_flag\"")))\n\t\tsps->poc_msb_cycle_len = 1 + gf_bs_read_ue_log(bs, \""poc_msb_cycle_len_minus1\"");\n\n\tu8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, \""sps_num_extra_ph_bytes\"");\n\tfor (i=0; i<sps_num_extra_ph_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \""extra_ph_bit_present_flag\"", 1))\n\t\t\tsps->ph_num_extra_bits++;\n\t}\n\tu8 sps_num_extra_sh_bits = 8 * gf_bs_read_int_log(bs, 2, \""num_extra_sh_bytes\"");\n\tfor (i=0; i<sps_num_extra_sh_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \""extra_sh_bit_present_flag\"", i))\n\t\t\tsps->sh_num_extra_bits++;\n\t}\n\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tu8 sps_sublayer_dpb_params_flag = 0;\n\t\tif (sps->max_sublayers>1) {\n\t\t\tsps_sublayer_dpb_params_flag = gf_bs_read_int_log(bs, 1, \""sps_sublayer_dpb_params_flag\"");\n\t\t}\n\t\tfor (i=(sps_sublayer_dpb_params_flag ? 0 : sps->max_sublayers-1); i < sps->max_sublayers; i++ ) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \""dpb_max_dec_pic_buffering_minus1\"", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \""dpb_max_num_reorder_pics\"", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \""dpb_max_latency_increase_plus1\"", i);\n\t\t}\n\t}\n\tgf_bs_read_ue_log(bs, \""sps_log2_min_luma_coding_block_size_minus2\"");\n\tgf_bs_read_int_log(bs, 1, \""sps_partition_constraints_override_enabled_flag\"");\n\tgf_bs_read_ue_log(bs, \""sps_log2_min_luma_coding_block_size_minus2\"");\n\tu8 sps_max_mtt_hierarchy_depth_intra_slice_luma = gf_bs_read_ue_log(bs, \""sps_max_mtt_hierarchy_depth_intra_slice_luma\"");\n\tif (sps_max_mtt_hierarchy_depth_intra_slice_luma != 0) {\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_bt_min_qt_intra_slice_luma\"");\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_tt_min_qt_intra_slice_luma\"");\n\t}\n\tu8 sps_qtbtt_dual_tree_intra_flag = 0;\n\tif (sps->chroma_format_idc) {\n\t\tsps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, \""sps_qtbtt_dual_tree_intra_flag\"");\n\t}\n\tif (sps_qtbtt_dual_tree_intra_flag) {\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_min_qt_min_cb_intra_slice_chroma\"");\n\t\tu8 sps_max_mtt_hierarchy_depth_intra_slice_chroma = gf_bs_read_ue_log(bs, \""sps_max_mtt_hierarchy_depth_intra_slice_chroma\"");\n\t\tif( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0) {\n\t\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_bt_min_qt_intra_slice_chroma\"");\n\t\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_tt_min_qt_intra_slice_chroma\"");\n\t\t}\n\t}\n\n\tgf_bs_read_ue_log(bs, \""sps_log2_diff_min_qt_min_cb_inter_slice\"");\n\tu8 sps_max_mtt_hierarchy_depth_inter_slice = gf_bs_read_ue_log(bs, \""sps_max_mtt_hierarchy_depth_inter_slice\"");\n\tif (sps_max_mtt_hierarchy_depth_inter_slice != 0) {\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_bt_min_qt_inter_slice\"");\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_tt_min_qt_inter_slice\"");\n\t}\n\t//u8 sps_max_luma_transform_size_64_flag = 0;\n\tif (CtbSizeY > 32) {\n\t\t/*sps_max_luma_transform_size_64_flag = */gf_bs_read_int_log(bs, 1, \""sps_max_luma_transform_size_64_flag\"");\n\t}\n\tu8 sps_transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \""sps_transform_skip_enabled_flag\"");\n\n\tif (sps_transform_skip_enabled_flag) {\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_transform_skip_max_size_minus2\"");\n\t\tgf_bs_read_int_log(bs, 1, \""sps_bdpcm_enabled_flag\"");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \""sps_mts_enabled_flag\"")) {\n\t\tgf_bs_read_int_log(bs, 1, \""sps_explicit_mts_intra_enabled_flag\"");\n\t\tgf_bs_read_int_log(bs, 1, \""sps_explicit_mts_inter_enabled_flag\"");\n\t}\n\tgf_bs_read_int_log(bs, 1, \""sps_lfnst_enabled_flag\"");\n\tif (sps->chroma_format_idc) {\n\t\tu8 sps_joint_cbcr_enabled_flag = gf_bs_read_int_log(bs, 1, \""sps_joint_cbcr_enabled_flag\"");\n\t\tu8 sps_same_qp_table_for_chroma_flag = gf_bs_read_int_log(bs, 1, \""sps_same_qp_table_for_chroma_flag\"");\n\t\tu32 numQpTables = sps_same_qp_table_for_chroma_flag ? 1 : (sps_joint_cbcr_enabled_flag ? 3 : 2);\n\t\tfor (i=0; i<numQpTables; i++) {\n\t\t\tgf_bs_read_se_log_idx(bs, \""sps_qp_table_start_minus26\"", i);\n\t\t\tu32 j, sps_num_points_in_qp_table = 1 + gf_bs_read_ue_log_idx(bs, \""sps_num_points_in_qp_table_minus1\"", i);\n\t\t\tfor (j=0; j<sps_num_points_in_qp_table; j++) {\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \""sps_delta_qp_in_val_minus1\"", i, j);\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \""sps_delta_qp_diff_val\"", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \""sps_sao_enabled_flag\"");\n\tsps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, \""sps_alf_enabled_flag\"");\n\tif (sps->alf_enabled_flag && sps->chroma_format_idc) {\n\t\tgf_bs_read_int_log(bs, 1, \""sps_ccalf_enabled_flag\"");\n\t}\n\t/*! TODO parse the rest !*/\n\n\treturn sps_id;\n}"", ""target"": 0}]","[{""func_name"": ""hevc_parse_slice_segment"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static\ns32 hevc_parse_slice_segment(GF_BitStream *bs, HEVCState *hevc, HEVCSliceInfo *si)\n{\n\tu32 i, j;\n\tu32 num_ref_idx_l0_active = 0, num_ref_idx_l1_active = 0;\n\tHEVC_PPS *pps;\n\tHEVC_SPS *sps;\n\ts32 pps_id;\n\tBool RapPicFlag = GF_FALSE;\n\tBool IDRPicFlag = GF_FALSE;\n\n\tsi->first_slice_segment_in_pic_flag = gf_bs_read_int_log(bs, 1, \""first_slice_segment_in_pic_flag\"");\n\n\tswitch (si->nal_unit_type) {\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\tIDRPicFlag = GF_TRUE;\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\tRapPicFlag = GF_TRUE;\n\t\tbreak;\n\t}\n\n\tif (RapPicFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \""no_output_of_prior_pics_flag\"");\n\t}\n\n\tpps_id = gf_bs_read_ue_log(bs, \""pps_id\"");\n\tif ((pps_id<0) || (pps_id >= 64))\n\t\treturn -1;\n\n\tpps = &hevc->pps[pps_id];\n\tsps = &hevc->sps[pps->sps_id];\n\tsi->sps = sps;\n\tsi->pps = pps;\n\n\tif (!si->first_slice_segment_in_pic_flag && pps->dependent_slice_segments_enabled_flag) {\n\t\tsi->dependent_slice_segment_flag = gf_bs_read_int_log(bs, 1, \""dependent_slice_segment_flag\"");\n\t}\n\telse {\n\t\tsi->dependent_slice_segment_flag = GF_FALSE;\n\t}\n\n\tif (!si->first_slice_segment_in_pic_flag) {\n\t\tsi->slice_segment_address = gf_bs_read_int_log(bs, sps->bitsSliceSegmentAddress, \""slice_segment_address\"");\n\t}\n\telse {\n\t\tsi->slice_segment_address = 0;\n\t}\n\n\tif (!si->dependent_slice_segment_flag) {\n\t\tBool deblocking_filter_override_flag = 0;\n\t\tBool slice_temporal_mvp_enabled_flag = 0;\n\t\tBool slice_sao_luma_flag = 0;\n\t\tBool slice_sao_chroma_flag = 0;\n\t\tBool slice_deblocking_filter_disabled_flag = 0;\n\n\t\t//\""slice_reserved_undetermined_flag[]\""\n\t\tgf_bs_read_int_log(bs, pps->num_extra_slice_header_bits, \""slice_reserved_undetermined_flag\"");\n\n\t\tsi->slice_type = gf_bs_read_ue_log(bs, \""slice_type\"");\n\n\t\tif (pps->output_flag_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \""pic_output_flag\"");\n\n\t\tif (sps->separate_colour_plane_flag == 1)\n\t\t\tgf_bs_read_int_log(bs, 2, \""colour_plane_id\"");\n\n\t\tif (IDRPicFlag) {\n\t\t\tsi->poc_lsb = 0;\n\n\t\t\t//if not asked to parse full header, abort since we know the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t}\n\t\telse {\n\t\t\tsi->poc_lsb = gf_bs_read_int_log(bs, sps->log2_max_pic_order_cnt_lsb, \""poc_lsb\"");\n\n\t\t\t//if not asked to parse full header, abort once we have the poc\n\t\t\tif (!hevc->full_slice_header_parse) return 0;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \""short_term_ref_pic_set_sps_flag\"") == 0) {\n\t\t\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, sps->num_short_term_ref_pic_sets);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (sps->num_short_term_ref_pic_sets > 1) {\n\t\t\t\tu32 numbits = 0;\n\n\t\t\t\twhile ((u32)(1 << numbits) < sps->num_short_term_ref_pic_sets)\n\t\t\t\t\tnumbits++;\n\t\t\t\tif (numbits > 0)\n\t\t\t\t\tgf_bs_read_int_log(bs, numbits, \""short_term_ref_pic_set_idx\"");\n\t\t\t\t/*else\n\t\t\t\t\tshort_term_ref_pic_set_idx = 0;*/\n\t\t\t}\n\t\t\tif (sps->long_term_ref_pics_present_flag) {\n\t\t\t\tu8 DeltaPocMsbCycleLt[32];\n\t\t\t\tu32 num_long_term_sps = 0;\n\t\t\t\tu32 num_long_term_pics = 0;\n\n\t\t\t\tmemset(DeltaPocMsbCycleLt, 0, sizeof(u8) * 32);\n\t\t\t\t\n\t\t\t\tif (sps->num_long_term_ref_pic_sps > 0) {\n\t\t\t\t\tnum_long_term_sps = gf_bs_read_ue_log(bs, \""num_long_term_sps\"");\n\t\t\t\t}\n\t\t\t\tnum_long_term_pics = gf_bs_read_ue_log(bs, \""num_long_term_pics\"");\n\n\t\t\t\tfor (i = 0; i < num_long_term_sps + num_long_term_pics; i++) {\n\t\t\t\t\tif (i < num_long_term_sps) {\n\t\t\t\t\t\tif (sps->num_long_term_ref_pic_sps > 1)\n\t\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, gf_get_bit_size(sps->num_long_term_ref_pic_sps), \""lt_idx_sps\"", i);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \""PocLsbLt\"", i);\n\t\t\t\t\t\tgf_bs_read_int_log_idx(bs, 1, \""UsedByCurrPicLt\"", i);\n\t\t\t\t\t}\n\t\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \""delta_poc_msb_present_flag\"", i)) {\n\t\t\t\t\t\tif (i == 0 || i == num_long_term_sps)\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \""DeltaPocMsbCycleLt\"", i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tDeltaPocMsbCycleLt[i] = gf_bs_read_ue_log_idx(bs, \""DeltaPocMsbCycleLt\"", i) + DeltaPocMsbCycleLt[i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->temporal_mvp_enable_flag)\n\t\t\t\tslice_temporal_mvp_enabled_flag = gf_bs_read_int_log(bs, 1, \""slice_temporal_mvp_enabled_flag\"");\n\t\t}\n\t\tif (sps->sample_adaptive_offset_enabled_flag) {\n\t\t\tu32 ChromaArrayType = sps->separate_colour_plane_flag ? 0 : sps->chroma_format_idc;\n\t\t\tslice_sao_luma_flag = gf_bs_read_int_log(bs, 1, \""slice_sao_luma_flag\"");\n\t\t\tif (ChromaArrayType != 0)\n\t\t\t\tslice_sao_chroma_flag = gf_bs_read_int_log(bs, 1, \""slice_sao_chroma_flag\"");\n\t\t}\n\n\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_P || si->slice_type == GF_HEVC_SLICE_TYPE_B) {\n\t\t\t//u32 NumPocTotalCurr;\n\t\t\tnum_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;\n\t\t\tnum_ref_idx_l1_active = 0;\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tnum_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \""num_ref_idx_active_override_flag\"")) {\n\t\t\t\tnum_ref_idx_l0_active = 1 + gf_bs_read_ue_log(bs, \""num_ref_idx_l0_active\"");\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tnum_ref_idx_l1_active = 1 + gf_bs_read_ue_log(bs, \""num_ref_idx_l1_active\"");\n\t\t\t}\n\n\t\t\tif (pps->lists_modification_present_flag /*TODO: && NumPicTotalCurr > 1*/) {\n\t\t\t\tif (!ref_pic_lists_modification(bs, si->slice_type, num_ref_idx_l0_active, num_ref_idx_l1_active)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\""[hevc] ref_pic_lists_modification( ) not implemented\\n\""));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \""mvd_l1_zero_flag\"");\n\t\t\tif (pps->cabac_init_present_flag)\n\t\t\t\tgf_bs_read_int_log(bs, 1, \""cabac_init_flag\"");\n\n\t\t\tif (slice_temporal_mvp_enabled_flag) {\n\t\t\t\t// When collocated_from_l0_flag is not present, it is inferred to be equal to 1.\n\t\t\t\tBool collocated_from_l0_flag = 1;\n\t\t\t\tif (si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t\tcollocated_from_l0_flag = gf_bs_read_int_log(bs, 1, \""collocated_from_l0_flag\"");\n\n\t\t\t\tif ((collocated_from_l0_flag && (num_ref_idx_l0_active > 1))\n\t\t\t\t\t|| (!collocated_from_l0_flag && (num_ref_idx_l1_active > 1))\n\t\t\t\t) {\n\t\t\t\t\tgf_bs_read_ue_log(bs, \""collocated_ref_idx\"");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((pps->weighted_pred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_P)\n\t\t\t\t|| (pps->weighted_bipred_flag && si->slice_type == GF_HEVC_SLICE_TYPE_B)\n\t\t\t\t) {\n\t\t\t\thevc_pred_weight_table(bs, hevc, si, pps, sps, num_ref_idx_l0_active, num_ref_idx_l1_active);\n\t\t\t}\n\t\t\tgf_bs_read_ue_log(bs, \""five_minus_max_num_merge_cand\"");\n\t\t}\n\t\tsi->slice_qp_delta_start_bits = (s32) (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\t\tsi->slice_qp_delta = gf_bs_read_se_log(bs, \""slice_qp_delta\"");\n\n\t\tif (pps->slice_chroma_qp_offsets_present_flag) {\n\t\t\tgf_bs_read_se_log(bs, \""slice_cb_qp_offset\"");\n\t\t\tgf_bs_read_se_log(bs, \""slice_cr_qp_offset\"");\n\t\t}\n\t\tif (pps->deblocking_filter_override_enabled_flag) {\n\t\t\tdeblocking_filter_override_flag = gf_bs_read_int_log(bs, 1, \""deblocking_filter_override_flag\"");\n\t\t}\n\n\t\tif (deblocking_filter_override_flag) {\n\t\t\tslice_deblocking_filter_disabled_flag = gf_bs_read_int_log(bs, 1, \""slice_deblocking_filter_disabled_flag\"");\n\t\t\tif (!slice_deblocking_filter_disabled_flag) {\n\t\t\t\tgf_bs_read_se_log(bs, \""slice_beta_offset_div2\"");\n\t\t\t\tgf_bs_read_se_log(bs, \""slice_tc_offset_div2\"");\n\t\t\t}\n\t\t}\n\t\tif (pps->loop_filter_across_slices_enabled_flag\n\t\t\t&& (slice_sao_luma_flag || slice_sao_chroma_flag || !slice_deblocking_filter_disabled_flag)\n\t\t) {\n\t\t\tgf_bs_read_int_log(bs, 1, \""slice_loop_filter_across_slices_enabled_flag\"");\n\t\t}\n\t}\n\t//dependent slice segment\n\telse {\n\t\t//if not asked to parse full header, abort\n\t\tif (!hevc->full_slice_header_parse) return 0;\n\t}\n\n\tsi->entry_point_start_bits = ((u32)gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs);\n\n\tif (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {\n\t\tu32 num_entry_point_offsets = gf_bs_read_ue_log(bs, \""num_entry_point_offsets\"");\n\t\tif (num_entry_point_offsets > 0) {\n\t\t\tu32 offset = gf_bs_read_ue_log(bs, \""offset\"") + 1;\n\t\t\tu32 segments = offset >> 4;\n\t\t\ts32 remain = (offset & 15);\n\n\t\t\tfor (i = 0; i < num_entry_point_offsets; i++) {\n\t\t\t\t//u32 res = 0;\n\t\t\t\tfor (j = 0; j < segments; j++) {\n\t\t\t\t\t//res <<= 16;\n\t\t\t\t\t/*res +=*/ gf_bs_read_int(bs, 16);\n\t\t\t\t}\n\t\t\t\tif (remain) {\n\t\t\t\t\t//res <<= remain;\n\t\t\t\t\t/* res += */ gf_bs_read_int(bs, remain);\n\t\t\t\t}\n\t\t\t\t// entry_point_offset = val + 1; // +1; // +1 to get the size\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pps->slice_segment_header_extension_present_flag) {\n\t\tu32 size_ext = gf_bs_read_ue_log(bs, \""size_ext\"");\n\t\twhile (size_ext) {\n\t\t\tgf_bs_read_int(bs, 8);\n\t\t\tsize_ext--;\n\t\t}\n\t}\n\n\tsi->header_size_bits = (gf_bs_get_position(bs) - 1) * 8 + gf_bs_get_bit_position(bs); // av_parser.c modified on 16 jan. 2019 \n\n\tif (gf_bs_read_int_log(bs, 1, \""byte_align\"") == 0) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\""Error parsing slice header: byte_align not found at end of header !\\n\""));\n\t}\n\n\tgf_bs_align(bs);\n\tsi->payload_start_offset = (s32)gf_bs_get_position(bs);\n\treturn 0;\n}""}, {""func_name"": ""gf_hevc_read_pps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_hevc_read_pps_bs_internal(GF_BitStream *bs, HEVCState *hevc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tHEVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_ue_log(bs, \""pps_id\"");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] wrong PPS ID %d in PPS\\n\"", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &hevc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_ue_log(bs, \""sps_id\"");\n\tif ((pps->sps_id<0) || (pps->sps_id >= 16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] wrong SPS ID %d in PPS\\n\"", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\thevc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->dependent_slice_segments_enabled_flag = gf_bs_read_int_log(bs, 1, \""dependent_slice_segments_enabled_flag\"");\n\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \""output_flag_present_flag\"");\n\tpps->num_extra_slice_header_bits = gf_bs_read_int_log(bs, 3, \""num_extra_slice_header_bits\"");\n\tpps->sign_data_hiding_flag = gf_bs_read_int_log(bs, 1, \""sign_data_hiding_flag\"");\n\tpps->cabac_init_present_flag = gf_bs_read_int_log(bs, 1, \""cabac_init_present_flag\"");\n\tpps->num_ref_idx_l0_default_active = 1 + gf_bs_read_ue_log(bs, \""num_ref_idx_l0_default_active\"");\n\tpps->num_ref_idx_l1_default_active = 1 + gf_bs_read_ue_log(bs, \""num_ref_idx_l1_default_active\"");\n\tpps->pic_init_qp_minus26 = gf_bs_read_se_log(bs, \""pic_init_qp_minus26\"");\n\tpps->constrained_intra_pred_flag = gf_bs_read_int_log(bs, 1, \""constrained_intra_pred_flag\"");\n\tpps->transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \""transform_skip_enabled_flag\"");\n\tif ((pps->cu_qp_delta_enabled_flag = gf_bs_read_int_log(bs, 1, \""cu_qp_delta_enabled_flag\"")))\n\t\tpps->diff_cu_qp_delta_depth = gf_bs_read_ue_log(bs, \""diff_cu_qp_delta_depth\"");\n\n\tpps->pic_cb_qp_offset = gf_bs_read_se_log(bs, \""pic_cb_qp_offset\"");\n\tpps->pic_cr_qp_offset = gf_bs_read_se_log(bs, \""pic_cr_qp_offset\"");\n\tpps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int_log(bs, 1, \""slice_chroma_qp_offsets_present_flag\"");\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \""weighted_pred_flag\"");\n\tpps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, \""weighted_bipred_flag\"");\n\tpps->transquant_bypass_enable_flag = gf_bs_read_int_log(bs, 1, \""transquant_bypass_enable_flag\"");\n\tpps->tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \""tiles_enabled_flag\"");\n\tpps->entropy_coding_sync_enabled_flag = gf_bs_read_int_log(bs, 1, \""entropy_coding_sync_enabled_flag\"");\n\tif (pps->tiles_enabled_flag) {\n\t\tpps->num_tile_columns = 1 + gf_bs_read_ue_log(bs, \""num_tile_columns_minus1\"");\n\t\tpps->num_tile_rows = 1 + gf_bs_read_ue_log(bs, \""num_tile_rows_minus1\"");\n\t\tpps->uniform_spacing_flag = gf_bs_read_int_log(bs, 1, \""uniform_spacing_flag\"");\n\t\tif (!pps->uniform_spacing_flag) {\n\t\t\tfor (i = 0; i < pps->num_tile_columns - 1; i++) {\n\t\t\t\tpps->column_width[i] = 1 + gf_bs_read_ue_log_idx(bs, \""column_width_minus1\"", i);\n\t\t\t}\n\t\t\tfor (i = 0; i < pps->num_tile_rows - 1; i++) {\n\t\t\t\tpps->row_height[i] = 1 + gf_bs_read_ue_log_idx(bs, \""row_height_minus1\"", i);\n\t\t\t}\n\t\t}\n\t\tpps->loop_filter_across_tiles_enabled_flag = gf_bs_read_int_log(bs, 1, \""loop_filter_across_tiles_enabled_flag\"");\n\t}\n\tpps->loop_filter_across_slices_enabled_flag = gf_bs_read_int_log(bs, 1, \""loop_filter_across_slices_enabled_flag\"");\n\tif ((pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \""deblocking_filter_control_present_flag\""))) {\n\t\tpps->deblocking_filter_override_enabled_flag = gf_bs_read_int_log(bs, 1, \""deblocking_filter_override_enabled_flag\"");\n\t\tif (! (pps->pic_disable_deblocking_filter_flag = gf_bs_read_int_log(bs, 1, \""pic_disable_deblocking_filter_flag\""))) {\n\t\t\tpps->beta_offset_div2 = gf_bs_read_se_log(bs, \""beta_offset_div2\"");\n\t\t\tpps->tc_offset_div2 = gf_bs_read_se_log(bs, \""tc_offset_div2\"");\n\t\t}\n\t}\n\tif ((pps->pic_scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \""pic_scaling_list_data_present_flag\""))) {\n\t\thevc_scaling_list_data(bs);\n\t}\n\tpps->lists_modification_present_flag = gf_bs_read_int_log(bs, 1, \""lists_modification_present_flag\"");\n\tpps->log2_parallel_merge_level_minus2 = gf_bs_read_ue_log(bs, \""log2_parallel_merge_level_minus2\"");\n\tpps->slice_segment_header_extension_present_flag = gf_bs_read_int_log(bs, 1, \""slice_segment_header_extension_present_flag\"");\n\tif (gf_bs_read_int_log(bs, 1, \""pps_extension_flag\"")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*pps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\treturn pps_id;\n}""}, {""func_name"": ""gf_hevc_read_vps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_hevc_read_vps_bs_internal(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)\n{\n\tu8 vps_sub_layer_ordering_info_present_flag, vps_extension_flag;\n\tu32 i, j;\n\ts32 vps_id;\n\tHEVC_VPS *vps;\n\tu8 layer_id_included_flag[MAX_LHVC_LAYERS][64];\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \""vps_id\"");\n\n\tif ((vps_id<0) || (vps_id >= 16)) return -1;\n\n\tvps = &hevc->vps[vps_id];\n\tvps->bit_pos_vps_extensions = -1;\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\n\tvps->base_layer_internal_flag = gf_bs_read_int_log(bs, 1, \""base_layer_internal_flag\"");\n\tvps->base_layer_available_flag = gf_bs_read_int_log(bs, 1, \""base_layer_available_flag\"");\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \""max_layers_minus1\"");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] sorry, %d layers in VPS but only %d supported\\n\"", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \""max_sub_layers_minus1\"") + 1;\n\tvps->temporal_id_nesting = gf_bs_read_int_log(bs, 1, \""temporal_id_nesting\"");\n\tgf_bs_read_int_log(bs, 16, \""vps_reserved_ffff_16bits\"");\n\thevc_profile_tier_level(bs, 1, vps->max_sub_layers - 1, &vps->ptl, 0);\n\n\tvps_sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \""vps_sub_layer_ordering_info_present_flag\"");\n\tfor (i = (vps_sub_layer_ordering_info_present_flag ? 0 : vps->max_sub_layers - 1); i < vps->max_sub_layers; i++) {\n\t\tgf_bs_read_ue_log_idx(bs, \""vps_max_dec_pic_buffering_minus1\"", i);\n\t\tgf_bs_read_ue_log_idx(bs, \""vps_max_num_reorder_pics\"", i);\n\t\tgf_bs_read_ue_log_idx(bs, \""vps_max_latency_increase_plus1\"", i);\n\t}\n\tvps->max_layer_id = gf_bs_read_int_log(bs, 6, \""max_layer_id\"");\n\tif (vps->max_layer_id > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] VPS max layer ID %u but GPAC only supports %u\\n\"", vps->max_layer_id, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->num_layer_sets = gf_bs_read_ue_log(bs, \""num_layer_sets_minus1\"") + 1;\n\tif (vps->num_layer_sets > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] Wrong number of layer sets in VPS %d\\n\"", vps->num_layer_sets));\n\t\treturn -1;\n\t}\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tfor (j = 0; j <= vps->max_layer_id; j++) {\n\t\t\tlayer_id_included_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \""layer_id_included_flag\"", i, j);\n\t\t}\n\t}\n\tvps->num_layers_in_id_list[0] = 1;\n\tfor (i = 1; i < vps->num_layer_sets; i++) {\n\t\tu32 n, m;\n\t\tn = 0;\n\t\tfor (m = 0; m <= vps->max_layer_id; m++) {\n\t\t\tif (layer_id_included_flag[i][m]) {\n\t\t\t\tvps->LayerSetLayerIdList[i][n++] = m;\n\t\t\t\tif (vps->LayerSetLayerIdListMax[i] < m)\n\t\t\t\t\tvps->LayerSetLayerIdListMax[i] = m;\n\t\t\t}\n\t\t}\n\t\tvps->num_layers_in_id_list[i] = n;\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \""vps_timing_info_present_flag\"")) {\n\t\tu32 vps_num_hrd_parameters;\n\t\tgf_bs_read_int_log(bs, 32, \""vps_num_units_in_tick\"");\n\t\tgf_bs_read_int_log(bs, 32, \""vps_time_scale\"");\n\t\tif (gf_bs_read_int_log(bs, 1, \""vps_poc_proportional_to_timing_flag\"")) {\n\t\t\tgf_bs_read_ue_log(bs, \""vps_num_ticks_poc_diff_one_minus1\"");\n\t\t}\n\t\tvps_num_hrd_parameters = gf_bs_read_ue_log(bs, \""vps_num_hrd_parameters\"");\n\t\tfor (i = 0; i < vps_num_hrd_parameters; i++) {\n\t\t\tBool cprms_present_flag = GF_TRUE;\n\t\t\tgf_bs_read_ue_log_idx(bs, \""hrd_layer_set_idx\"", i);\n\t\t\tif (i > 0)\n\t\t\t\tcprms_present_flag = gf_bs_read_int_log(bs, 1, \""cprms_present_flag\"");\n\t\t\thevc_parse_hrd_parameters(bs, cprms_present_flag, vps->max_sub_layers - 1, i);\n\t\t}\n\t}\n\tif (stop_at_vps_ext) {\n\t\treturn vps_id;\n\t}\n\n\tvps_extension_flag = gf_bs_read_int_log(bs, 1, \""vps_extension_flag\"");\n\tif (vps_extension_flag) {\n\t\tBool res;\n\t\tgf_bs_align(bs);\n\t\tres = hevc_parse_vps_extension(vps, bs);\n\t\tif (res != GF_TRUE) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] Failed to parse VPS extensions\\n\""));\n\t\t\treturn -1;\n\t\t}\n\t\tif (gf_bs_read_int_log(bs, 1, \""vps_extension2_flag\"")) {\n#if 0\n\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t/*vps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t\t}\n#endif\n\n\t\t}\n\t}\n\treturn vps_id;\n}""}, {""func_name"": ""gf_avc_read_sps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \""forbidden_zero_bit\"");\n\t\tgf_bs_read_int_log(bs, 2, \""nal_ref_idc\"");\n\t\tgf_bs_read_int_log(bs, 5, \""nal_unit_type\"");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \""profile_idc\"");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \""profile_compatibility\"");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \""level_idc\"");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \""sps_id\"") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif ((sps_id < 0) || (sps_id >= 32)) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \""chroma_format_idc\"");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \""separate_colour_plane_flag\"");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \""luma_bit_depth\"");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \""chroma_bit_depth\"");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \""qpprime_y_zero_transform_bypass_flag\"");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \""seq_scaling_matrix_present_flag\"")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \""seq_scaling_list_present_flag\"", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \""log2_max_frame_num\"") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \""poc_type\"");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \""log2_max_poc_lsb\"") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \""delta_pic_order_always_zero_flag\"");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \""offset_for_non_ref_pic\"");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \""offset_for_top_to_bottom_field\"");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \""poc_cycle_length\"");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\""));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \""offset_for_ref_frame\"", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \""max_num_ref_frames\"");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \""gaps_in_frame_num_value_allowed_flag\"");\n\tmb_width = gf_bs_read_ue_log(bs, \""pic_width_in_mbs_minus1\"") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \""pic_height_in_map_units_minus1\"") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \""frame_mbs_only_flag\"");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \""mb_adaptive_frame_field_flag\"");\n\tgf_bs_read_int_log(bs, 1, \""direct_8x8_inference_flag\"");\n\n\tif (gf_bs_read_int_log(bs, 1, \""frame_cropping_flag\"")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \""frame_crop_left_offset\"");\n\t\tcr = gf_bs_read_ue_log(bs, \""frame_crop_right_offset\"");\n\t\tct = gf_bs_read_ue_log(bs, \""frame_crop_top_offset\"");\n\t\tcb = gf_bs_read_ue_log(bs, \""frame_crop_bottom_offset\"");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""vui_parameters_present_flag\"");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \""aspect_ratio_info_present_flag\"");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \""aspect_ratio_idc\"");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \""aspect_ratio_num\"");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \""aspect_ratio_den\"");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\""));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \""overscan_info_present_flag\"");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \""overscan_appropriate_flag\"");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \""video_signal_type_present_flag\"");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \""video_format\"");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \""video_full_range_flag\"");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \""colour_description_present_flag\"");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \""colour_primaries\"");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \""transfer_characteristics\"");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \""matrix_coefficients\"");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \""chroma_location_info_present_flag\"")) {\n\t\t\tgf_bs_read_ue_log(bs, \""chroma_sample_location_type_top_field\"");\n\t\t\tgf_bs_read_ue_log(bs, \""chroma_sample_location_type_bottom_field\"");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \""timing_info_present_flag\"");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \""num_units_in_tick\"");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \""time_scale\"");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \""fixed_frame_rate_flag\"");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""nal_hrd_parameters_present_flag\"");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""vcl_hrd_parameters_present_flag\"");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \""low_delay_hrd_flag\"");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \""pic_struct_present_flag\"");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \""inter_layer_deblocking_filter_control_present_flag\"");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \""extended_spatial_scalability_idc\"");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \""chroma_phase_x_plus1_flag\"");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \""chroma_phase_y_plus1\"");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""seq_ref_layer_chroma_phase_x_plus1_flag\"");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \""seq_ref_layer_chroma_phase_y_plus1\"");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \""seq_scaled_ref_layer_left_offset\"");\n\t\t\t\tgf_bs_read_se_log(bs, \""seq_scaled_ref_layer_top_offset\"");\n\t\t\t\tgf_bs_read_se_log(bs, \""seq_scaled_ref_layer_right_offset\"");\n\t\t\t\tgf_bs_read_se_log(bs, \""seq_scaled_ref_layer_bottom_offset\"");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \""seq_tcoeff_level_prediction_flag\"")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \""adaptive_tcoeff_level_prediction_flag\"");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \""slice_header_restriction_flag\"");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \""svc_vui_parameters_present\"")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \""vui_ext_num_entries_minus1\"");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \""vui_ext_dependency_id\"");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \""vui_ext_quality_id\"");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \""vui_ext_temporal_id\"");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \""vui_ext_timing_info_present_flag\"");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \""vui_ext_num_units_in_tick\"");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \""vui_ext_time_scale\"");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""vui_ext_fixed_frame_rate_flag\"");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""vui_ext_nal_hrd_parameters_present_flag\"");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""vui_ext_vcl_hrd_parameters_present_flag\"");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""vui_ext_low_delay_hrd_flag\"");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""vui_ext_pic_struct_present_flag\"");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\""));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \""additional_extension2\"")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\""));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}""}, {""func_name"": ""gf_media_vvc_read_vps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)\n{\n\tu32 i, j;\n\ts32 vps_id;\n\tVVC_VPS *vps;\n\tBool vps_default_ptl_dpb_hrd_max_tid_flag=0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \""vps_id\"");\n\tif ((vps_id<0) || (vps_id >= 16)) return -1;\n\tif (!vps_id) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[VVC] VPS ID 0 is forbidden\\n\""));\n\t\treturn -1;\n\t}\n\tvps = &vvc->vps[vps_id];\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \""max_layers\"");\n\tif (vps->max_layers > MAX_LHVC_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[VVC] sorry, %d layers in VPS but only %d supported\\n\"", vps->max_layers, MAX_LHVC_LAYERS));\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \""max_sub_layers_minus1\"") + 1;\n\n\tif ((vps->max_layers>1) && (vps->max_sub_layers>1))\n\t\tvps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, \""vps_default_ptl_dpb_hrd_max_tid_flag\"");\n\n\tif (vps->max_layers>1)\n\t\tvps->all_layers_independent = gf_bs_read_int_log(bs, 1, \""all_layers_independent\"");\n\n\tfor (i=0; i<vps->max_layers; i++) {\n\t\tu32 layer_id = gf_bs_read_int_log_idx(bs, 6, \""layer_id\"", i);\n\t\tif (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id;\n\t\tif (i && !vps->all_layers_independent) {\n\t\t\tBool layer_indep = gf_bs_read_int_log_idx(bs, 1, \""layer_independent\"", i);\n\t\t\tif (!layer_indep) {\n\t\t\t\tBool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, \""vps_max_tid_ref_present_flag\"", i);\n\t\t\t\tfor (j=0; j<i; j++) {\n\t\t\t\t\tBool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, \""vps_direct_ref_layer_flag\"", i, j);\n\t\t\t\t\tif (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \""vps_max_tid_il_ref_pics_plus1\"", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvps->num_ptl = 1;\n\tif (vps->max_layers > 1) {\n\t\tif (vps->all_layers_independent) {\n\t\t\tvps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, \""each_layer_is_ols\"");\n\t\t}\n\t\tif (!vps->each_layer_is_ols) {\n\t\t\tu32 vps_ols_mode_idc = 2;\n\t\t\tif (!vps->all_layers_independent) {\n\t\t\t\tvps_ols_mode_idc = gf_bs_read_int_log(bs, 2, \""vps_ols_mode_idc\"");\n\t\t\t}\n\t\t\tif (vps_ols_mode_idc==2) {\n\t\t\t\tu8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, \""vps_num_output_layer_sets_minus2\"");\n\t\t\t\tfor (i=0; i<vps_num_output_layer_sets; i++) {\n\t\t\t\t\tfor (j=0; j<vps->max_layers; j++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 1, \""vps_ols_output_layer_flag\"", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, \""num_ptl_minus1\"");\n\t}\n\tvps->ptl[0].pt_present = 1;\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tif (i)\n\t\t\tvps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, \""pt_present\"", i);\n\t\tif (!vps_default_ptl_dpb_hrd_max_tid_flag)\n\t\t\tvps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, \""ptl_max_tid\"", i);\n\t\telse\n\t\t\tvps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;;\n\t}\n\t//align\n\tgf_bs_align(bs);\n\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tvvc_profile_tier_level(bs, &vps->ptl[i], i);\n\t}\n\n\t//TODO, parse multilayer stuff\n\treturn vps_id;\n}""}, {""func_name"": ""gf_avc_read_pps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)\n{\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \""forbidden_zero_bit\"");\n\t\tgf_bs_read_int_log(bs, 2, \""nal_ref_idc\"");\n\t\tgf_bs_read_int_log(bs, 5, \""nal_unit_type\"");\n\t}\n\tpps_id = gf_bs_read_ue_log(bs, \""pps_id\"");\n\tif ((pps_id<0) || (pps_id >= 255)) {\n\t\treturn -1;\n\t}\n\tpps = &avc->pps[pps_id];\n\tpps->id = pps_id;\n\n\tif (!pps->status) pps->status = 1;\n\tpps->sps_id = gf_bs_read_ue_log(bs, \""sps_id\"");\n\tif ((pps->sps_id<0) || (pps->sps_id >= 32)) {\n\t\tpps->sps_id = 0;\n\t\treturn -1;\n\t}\n\t/*sps_id may be refer to regular SPS or subseq sps, depending on the coded slice referring to the pps*/\n\tif (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\treturn -1;\n\t}\n\tavc->pps_active_idx = pps->id; /*set active sps*/\n\tavc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, \""entropy_coding_mode_flag\"");\n\tpps->pic_order_present = gf_bs_read_int_log(bs, 1, \""pic_order_present\"");\n\tpps->slice_group_count = gf_bs_read_ue_log(bs, \""slice_group_count_minus1\"") + 1;\n\tif (pps->slice_group_count > 1) {\n\t\tu32 iGroup;\n\t\tpps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, \""mb_slice_group_map_type\"");\n\t\tif (pps->mb_slice_group_map_type == 0) {\n\t\t\tfor (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++)\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \""run_length_minus1\"", iGroup);\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 2) {\n\t\t\tfor (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \""top_left\"", iGroup);\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \""bottom_right\"", iGroup);\n\t\t\t}\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) {\n\t\t\tgf_bs_read_int_log(bs, 1, \""slice_group_change_direction_flag\"");\n\t\t\tgf_bs_read_ue_log(bs, \""slice_group_change_rate_minus1\"");\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 6) {\n\t\t\tu32 i;\n\t\t\tpps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, \""pic_size_in_map_units_minus1\"");\n\t\t\tfor (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), \""slice_group_id\"", i);\n\t\t\t}\n\t\t}\n\t}\n\tpps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, \""num_ref_idx_l0_default_active_minus1\"");\n\tpps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, \""num_ref_idx_l1_default_active_minus1\"");\n\n\t/*\n\tif ((pps->ref_count[0] > 32) || (pps->ref_count[1] > 32)) goto exit;\n\t*/\n\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \""weighted_pred_flag\"");\n\tgf_bs_read_int_log(bs, 2, \""weighted_bipred_idc\"");\n\tgf_bs_read_se_log(bs, \""init_qp_minus26\"");\n\tgf_bs_read_se_log(bs, \""init_qs_minus26\"");\n\tgf_bs_read_se_log(bs, \""chroma_qp_index_offset\"");\n\tpps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \""deblocking_filter_control_present_flag\"");\n\tgf_bs_read_int_log(bs, 1, \""constrained_intra_pred\"");\n\tpps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, \""redundant_pic_cnt_present\"");\n\n\treturn pps_id;\n}""}, {""func_name"": ""vvc_parse_picture_header"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static\ns32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)\n{\n\tu32 pps_id;\n\n\tsi->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, \""irap_or_gdr_pic\"");\n\tsi->non_ref_pic = gf_bs_read_int_log(bs, 1, \""non_ref_pic\"");\n\tif (si->irap_or_gdr_pic)\n\t\tsi->gdr_pic = gf_bs_read_int_log(bs, 1, \""gdr_pic\"");\n\tif ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \""inter_slice_allowed_flag\"")))\n\t\tsi->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, \""intra_slice_allowed_flag\"");\n\n\tpps_id = gf_bs_read_ue_log(bs, \""pps_id\"");\n\tif ((pps_id<0) || (pps_id >= 64))\n\t\treturn -1;\n\tsi->pps = &vvc->pps[pps_id];\n\tsi->sps = &vvc->sps[si->pps->sps_id];\n\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \""poc_lsb\"");\n\n\tsi->recovery_point_valid = 0;\n\tsi->gdr_recovery_count = 0;\n\tif (si->gdr_pic) {\n\t\tsi->recovery_point_valid = 1;\n\t\tsi->gdr_recovery_count = gf_bs_read_ue_log(bs, \""gdr_recovery_count\"");\n\t}\n\tgf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, \""ph_extra_bits\"");\n\n\tif (si->sps->poc_msb_cycle_flag) {\n\t\tif ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, \""poc_msb_cycle_present_flag\""))) {\n\t\t\tsi->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, \""poc_msb_cycle\"");\n\t\t}\n\t}\n\n\treturn 0;\n}""}, {""func_name"": ""gf_media_vvc_read_pps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tVVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_int_log(bs, 6, \""pps_id\"");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[VVC] wrong PPS ID %d in PPS\\n\"", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \""sps_id\"");\n\tif ((pps->sps_id<0) || (pps->sps_id >= 16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[VVC] wrong SPS ID %d in PPS\\n\"", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \""mixed_nal_types\"");\n\tpps->width = gf_bs_read_ue_log(bs, \""width\"");\n\tpps->height = gf_bs_read_ue_log(bs, \""height\"");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \""conformance_window_flag\"");\n\tif (pps->conf_window) {\n\t\tpps->cw_left = gf_bs_read_ue_log(bs, \""conf_win_left_offset\"");\n\t\tpps->cw_right = gf_bs_read_ue_log(bs, \""conf_win_right_offset\"");\n\t\tpps->cw_top = gf_bs_read_ue_log(bs, \""conf_win_top_offset\"");\n\t\tpps->cw_bottom = gf_bs_read_ue_log(bs, \""conf_win_bottom_offset\"");\n\t}\n\t//scaling window\n\tif (gf_bs_read_int_log(bs, 1, \""scaling_window_explicit_signalling_flag\"")) {\n\t\tgf_bs_read_se_log(bs, \""scaling_win_left_offset\"");\n\t\tgf_bs_read_se_log(bs, \""scaling_win_right_offset\"");\n\t\tgf_bs_read_se_log(bs, \""scaling_win_top_offset\"");\n\t\tgf_bs_read_se_log(bs, \""scaling_win_bottom_offset\"");\n\t}\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \""output_flag_present_flag\"");\n\tpps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, \""no_pic_partition_flag\"");\n\tpps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, \""subpic_id_mapping_present_flag\"");\n\tif (pps->subpic_id_mapping_present_flag) {\n\t\tu32 pps_subpic_id_len, pps_num_subpics=0;\n\t\tif (!pps->no_pic_partition_flag) {\n\t\t\tpps_num_subpics = 1+gf_bs_read_ue_log(bs, \""pps_num_subpics_minus1\"");\n\t\t}\n\t\tpps_subpic_id_len = 1 + gf_bs_read_ue(bs);\n\t\tfor (i=0; i<pps_num_subpics; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, pps_subpic_id_len, \""subpic_id\"", i);\n\t\t}\n\t}\n\tif (!pps->no_pic_partition_flag) {\n\t\tgf_bs_read_int_log(bs, 2, \""pps_log2_ctu_size_minus5\"");\n\t\tu32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, \""num_exp_tile_columns_minus1\"");\n\t\tu32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, \""num_exp_tile_rows_minus1\"");\n\t\tfor (i=0; i<num_exp_tile_columns; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \""tile_column_width_minus1\"", i);\n\t\tfor (i=0; i<num_exp_tile_rows; i++)\n\t\t\tgf_bs_read_ue_log_idx(bs, \""tile_row_height_minus1\"", i);\n\n\t\t//todo parse the rest\n\t\treturn pps_id;\n\t}\n\n\n\t//todo parse the rest\n\n\treturn pps_id;\n}""}, {""func_name"": ""gf_hevc_read_sps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id = -1;\n\tu32 i, nb_CTUs, depth;\n\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tBool multiLayerExtSpsFlag;\n\tu8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \""vps_id\"");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \""max_sub_layers_minus1\"");\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \""sps_ext_or_max_sub_layers_minus1\"");\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);\n\tif (!multiLayerExtSpsFlag) {\n\t\tgf_bs_read_int_log(bs, 1, \""temporal_id_nesting_flag\"");\n\t\thevc_profile_tier_level(bs, 1, max_sub_layers_minus1, &ptl, 0);\n\t}\n\n\tsps_id = gf_bs_read_ue_log(bs, \""sps_id\"");\n\tif ((sps_id < 0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\n\tsps = &hevc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->ptl = ptl;\n\tvps = &hevc->vps[vps_id];\n\tsps->max_sub_layers_minus1 = 0;\n\tsps->sps_ext_or_max_sub_layers_minus1 = 0;\n\n\t/* default values */\n\tsps->colour_primaries = 2;\n\tsps->transfer_characteristic = 2;\n\tsps->matrix_coeffs = 2;\n\n\t//sps_rep_format_idx = 0;\n\tif (multiLayerExtSpsFlag) {\n\t\tsps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, \""update_rep_format_flag\"");\n\t\tif (sps->update_rep_format_flag) {\n\t\t\tsps->rep_format_idx = gf_bs_read_int_log(bs, 8, \""rep_format_idx\"");\n\t\t}\n\t\telse {\n\t\t\tsps->rep_format_idx = vps->rep_format_idx[layer_id];\n\t\t}\n\t\tsps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;\n\t\tsps->height = vps->rep_formats[sps->rep_format_idx].pic_height_luma_samples;\n\t\tsps->chroma_format_idc = vps->rep_formats[sps->rep_format_idx].chroma_format_idc;\n\t\tsps->bit_depth_luma = vps->rep_formats[sps->rep_format_idx].bit_depth_luma;\n\t\tsps->bit_depth_chroma = vps->rep_formats[sps->rep_format_idx].bit_depth_chroma;\n\t\tsps->separate_colour_plane_flag = vps->rep_formats[sps->rep_format_idx].separate_colour_plane_flag;\n\n\t\t//TODO this is crude ...\n\t\tsps->ptl = vps->ext_ptl[0];\n\t}\n\telse {\n\t\tsps->chroma_format_idc = gf_bs_read_ue_log(bs, \""chroma_format_idc\"");\n\t\tif (sps->chroma_format_idc == 3)\n\t\t\tsps->separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \""separate_colour_plane_flag\"");\n\t\tsps->width = gf_bs_read_ue_log(bs, \""width\"");\n\t\tsps->height = gf_bs_read_ue_log(bs, \""height\"");\n\t\tif ((sps->cw_flag = gf_bs_read_int_log(bs, 1, \""conformance_window_flag\""))) {\n\t\t\tu32 SubWidthC, SubHeightC;\n\n\t\t\tif (sps->chroma_format_idc == 1) {\n\t\t\t\tSubWidthC = SubHeightC = 2;\n\t\t\t}\n\t\t\telse if (sps->chroma_format_idc == 2) {\n\t\t\t\tSubWidthC = 2;\n\t\t\t\tSubHeightC = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSubWidthC = SubHeightC = 1;\n\t\t\t}\n\n\t\t\tsps->cw_left = gf_bs_read_ue_log(bs, \""conformance_window_left\"");\n\t\t\tsps->cw_right = gf_bs_read_ue_log(bs, \""conformance_window_right\"");\n\t\t\tsps->cw_top = gf_bs_read_ue_log(bs, \""conformance_window_top\"");\n\t\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \""conformance_window_bottom\"");\n\n\t\t\tsps->width -= SubWidthC * (sps->cw_left + sps->cw_right);\n\t\t\tsps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);\n\t\t}\n\t\tsps->bit_depth_luma = 8 + gf_bs_read_ue_log(bs, \""bit_depth_luma_minus8\"");\n\t\tsps->bit_depth_chroma = 8 + gf_bs_read_ue_log(bs, \""bit_depth_chroma_minus8\"");\n\t}\n\n\tsps->log2_max_pic_order_cnt_lsb = 4 + gf_bs_read_ue_log(bs, \""log2_max_pic_order_cnt_lsb_minus4\"");\n\n\tif (!multiLayerExtSpsFlag) {\n\t\tsps->sub_layer_ordering_info_present_flag = gf_bs_read_int_log(bs, 1, \""sub_layer_ordering_info_present_flag\"");\n\t\tfor (i = sps->sub_layer_ordering_info_present_flag ? 0 : sps->max_sub_layers_minus1; i <= sps->max_sub_layers_minus1; i++) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \""max_dec_pic_buffering\"", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \""num_reorder_pics\"", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \""max_latency_increase\"", i);\n\t\t}\n\t}\n\n\tsps->log2_min_luma_coding_block_size = 3 + gf_bs_read_ue_log(bs, \""log2_min_luma_coding_block_size_minus3\"");\n\tsps->log2_diff_max_min_luma_coding_block_size = gf_bs_read_ue_log(bs, \""log2_diff_max_min_luma_coding_block_size\"");\n\tsps->max_CU_width = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\tsps->max_CU_height = (1 << (sps->log2_min_luma_coding_block_size + sps->log2_diff_max_min_luma_coding_block_size));\n\n\tsps->log2_min_transform_block_size = 2 + gf_bs_read_ue_log(bs, \""log2_min_transform_block_size_minus2\"");\n\tsps->log2_max_transform_block_size = sps->log2_min_transform_block_size  + gf_bs_read_ue_log(bs, \""log2_max_transform_block_size\"");\n\n\tdepth = 0;\n\tsps->max_transform_hierarchy_depth_inter = gf_bs_read_ue_log(bs, \""max_transform_hierarchy_depth_inter\"");\n\tsps->max_transform_hierarchy_depth_intra = gf_bs_read_ue_log(bs, \""max_transform_hierarchy_depth_intra\"");\n\twhile ((u32)(sps->max_CU_width >> sps->log2_diff_max_min_luma_coding_block_size) > (u32)(1 << (sps->log2_min_transform_block_size + depth)))\n\t{\n\t\tdepth++;\n\t}\n\tsps->max_CU_depth = sps->log2_diff_max_min_luma_coding_block_size + depth;\n\n\tnb_CTUs = ((sps->width + sps->max_CU_width - 1) / sps->max_CU_width) * ((sps->height + sps->max_CU_height - 1) / sps->max_CU_height);\n\tsps->bitsSliceSegmentAddress = 0;\n\twhile (nb_CTUs > (u32)(1 << sps->bitsSliceSegmentAddress)) {\n\t\tsps->bitsSliceSegmentAddress++;\n\t}\n\n\tsps->scaling_list_enable_flag = gf_bs_read_int_log(bs, 1, \""scaling_list_enable_flag\"");\n\tif (sps->scaling_list_enable_flag) {\n\t\tsps->infer_scaling_list_flag = 0;\n\t\tsps->scaling_list_ref_layer_id = 0;\n\t\tif (multiLayerExtSpsFlag) {\n\t\t\tsps->infer_scaling_list_flag = gf_bs_read_int_log(bs, 1, \""infer_scaling_list_flag\"");\n\t\t}\n\t\tif (sps->infer_scaling_list_flag) {\n\t\t\tsps->scaling_list_ref_layer_id = gf_bs_read_int_log(bs, 6, \""scaling_list_ref_layer_id\"");\n\t\t}\n\t\telse {\n\t\t\tsps->scaling_list_data_present_flag = gf_bs_read_int_log(bs, 1, \""scaling_list_data_present_flag\"");\n\t\t\tif (sps->scaling_list_data_present_flag) {\n\t\t\t\thevc_scaling_list_data(bs);\n\t\t\t}\n\t\t}\n\t}\n\tsps->asymmetric_motion_partitions_enabled_flag = gf_bs_read_int_log(bs, 1, \""asymmetric_motion_partitions_enabled_flag\"");\n\tsps->sample_adaptive_offset_enabled_flag = gf_bs_read_int_log(bs, 1, \""sample_adaptive_offset_enabled_flag\"");\n\tif ( (sps->pcm_enabled_flag = gf_bs_read_int_log(bs, 1, \""pcm_enabled_flag\"")) ) {\n\t\tsps->pcm_sample_bit_depth_luma_minus1 = gf_bs_read_int_log(bs, 4, \""pcm_sample_bit_depth_luma_minus1\"");\n\t\tsps->pcm_sample_bit_depth_chroma_minus1 = gf_bs_read_int_log(bs, 4, \""pcm_sample_bit_depth_chroma_minus1\"");\n\t\tsps->log2_min_pcm_luma_coding_block_size_minus3 = gf_bs_read_ue_log(bs, \""log2_min_pcm_luma_coding_block_size_minus3\"");\n\t\tsps->log2_diff_max_min_pcm_luma_coding_block_size = gf_bs_read_ue_log(bs, \""log2_diff_max_min_pcm_luma_coding_block_size\"");\n\t\tsps->pcm_loop_filter_disable_flag = gf_bs_read_int_log(bs, 1, \""pcm_loop_filter_disable_flag\"");\n\t}\n\tsps->num_short_term_ref_pic_sets = gf_bs_read_ue_log(bs, \""num_short_term_ref_pic_sets\"");\n\tif (sps->num_short_term_ref_pic_sets > 64) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] Invalid number of short term reference picture sets %d\\n\"", sps->num_short_term_ref_pic_sets));\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < sps->num_short_term_ref_pic_sets; i++) {\n\t\tBool ret = hevc_parse_short_term_ref_pic_set(bs, sps, i);\n\t\t/*cannot parse short_term_ref_pic_set, skip VUI parsing*/\n\t\tif (!ret) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\""[HEVC] Invalid short_term_ref_pic_set\\n\""));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tsps->long_term_ref_pics_present_flag = gf_bs_read_int_log(bs, 1, \""long_term_ref_pics_present_flag\"");\n\tif (sps->long_term_ref_pics_present_flag) {\n\t\tsps->num_long_term_ref_pic_sps = gf_bs_read_ue_log(bs, \""num_long_term_ref_pic_sps\"");\n\t\tfor (i = 0; i < sps->num_long_term_ref_pic_sps; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, sps->log2_max_pic_order_cnt_lsb, \""lt_ref_pic_poc_lsb_sps\"", i);\n\t\t\tgf_bs_read_int_log_idx(bs, 1, \""used_by_curr_pic_lt_sps_flag\"", i);\n\t\t}\n\t}\n\tsps->temporal_mvp_enable_flag = gf_bs_read_int_log(bs, 1, \""temporal_mvp_enable_flag\"");\n\tsps->strong_intra_smoothing_enable_flag = gf_bs_read_int_log(bs, 1, \""strong_intra_smoothing_enable_flag\"");\n\n\tif (vui_flag_pos)\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\n\tif ((sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""vui_parameters_present_flag\"")) ) {\n\t\tsps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \""aspect_ratio_info_present_flag\"");\n\t\tif (sps->aspect_ratio_info_present_flag) {\n\t\t\tsps->sar_idc = gf_bs_read_int_log(bs, 8, \""aspect_ratio_idc\"");\n\t\t\tif (sps->sar_idc == 255) {\n\t\t\t\tsps->sar_width = gf_bs_read_int_log(bs, 16, \""aspect_ratio_width\"");\n\t\t\t\tsps->sar_height = gf_bs_read_int_log(bs, 16, \""aspect_ratio_height\"");\n\t\t\t}\n\t\t\telse if (sps->sar_idc < 17) {\n\t\t\t\tsps->sar_width = hevc_sar[sps->sar_idc].w;\n\t\t\t\tsps->sar_height = hevc_sar[sps->sar_idc].h;\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->overscan_info_present = gf_bs_read_int_log(bs, 1, \""overscan_info_present\"")))\n\t\t\tsps->overscan_appropriate = gf_bs_read_int_log(bs, 1, \""overscan_appropriate\"");\n\n\t\tsps->video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \""video_signal_type_present_flag\"");\n\t\tif (sps->video_signal_type_present_flag) {\n\t\t\tsps->video_format = gf_bs_read_int_log(bs, 3, \""video_format\"");\n\t\t\tsps->video_full_range_flag = gf_bs_read_int_log(bs, 1, \""video_full_range_flag\"");\n\t\t\tif ((sps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, \""colour_description_present_flag\""))) {\n\t\t\t\tsps->colour_primaries = gf_bs_read_int_log(bs, 8, \""colour_primaries\"");\n\t\t\t\tsps->transfer_characteristic = gf_bs_read_int_log(bs, 8, \""transfer_characteristic\"");\n\t\t\t\tsps->matrix_coeffs = gf_bs_read_int_log(bs, 8, \""matrix_coefficients\"");\n\t\t\t}\n\t\t}\n\n\t\tif ((sps->chroma_loc_info_present_flag = gf_bs_read_int_log(bs, 1, \""chroma_loc_info_present_flag\""))) {\n\t\t\tsps->chroma_sample_loc_type_top_field = gf_bs_read_ue_log(bs, \""chroma_sample_loc_type_top_field\"");\n\t\t\tsps->chroma_sample_loc_type_bottom_field = gf_bs_read_ue_log(bs, \""chroma_sample_loc_type_bottom_field\"");\n\t\t}\n\n\t\tsps->neutra_chroma_indication_flag = gf_bs_read_int_log(bs, 1, \""neutra_chroma_indication_flag\"");\n\t\tsps->field_seq_flag = gf_bs_read_int_log(bs, 1, \""field_seq_flag\"");\n\t\tsps->frame_field_info_present_flag = gf_bs_read_int_log(bs, 1, \""frame_field_info_present_flag\"");\n\n\t\tif ((sps->default_display_window_flag = gf_bs_read_int_log(bs, 1, \""default_display_window_flag\""))) {\n\t\t\tsps->left_offset = gf_bs_read_ue_log(bs, \""display_window_left_offset\"");\n\t\t\tsps->right_offset = gf_bs_read_ue_log(bs, \""display_window_right_offset\"");\n\t\t\tsps->top_offset = gf_bs_read_ue_log(bs, \""display_window_top_offset\"");\n\t\t\tsps->bottom_offset = gf_bs_read_ue_log(bs, \""display_window_bottom_offset\"");\n\t\t}\n\n\t\tsps->has_timing_info = gf_bs_read_int_log(bs, 1, \""has_timing_info\"");\n\t\tif (sps->has_timing_info) {\n\t\t\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \""num_units_in_tick\"");\n\t\t\tsps->time_scale = gf_bs_read_int_log(bs, 32, \""time_scale\"");\n\t\t\tsps->poc_proportional_to_timing_flag = gf_bs_read_int_log(bs, 1, \""poc_proportional_to_timing_flag\"");\n\t\t\tif (sps->poc_proportional_to_timing_flag)\n\t\t\t\tsps->num_ticks_poc_diff_one_minus1 = gf_bs_read_ue_log(bs, \""num_ticks_poc_diff_one_minus1\"");\n\t\t\tif ((sps->hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \""hrd_parameters_present_flag\""))) {\n\t\t\t\t//\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\""[HEVC] HRD param parsing not implemented\\n\""));\n\t\t\t\treturn sps_id;\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \""bitstream_restriction_flag\"")) {\n\t\t\tgf_bs_read_int_log(bs, 1, \""tiles_fixed_structure_flag\"");\n\t\t\tgf_bs_read_int_log(bs, 1, \""motion_vectors_over_pic_boundaries_flag\"");\n\t\t\tgf_bs_read_int_log(bs, 1, \""restricted_ref_pic_lists_flag\"");\n\t\t\tgf_bs_read_ue_log(bs, \""min_spatial_segmentation_idc\"");\n\t\t\tgf_bs_read_ue_log(bs, \""max_bytes_per_pic_denom\"");\n\t\t\tgf_bs_read_ue_log(bs, \""max_bits_per_min_cu_denom\"");\n\t\t\tgf_bs_read_ue_log(bs, \""log2_max_mv_length_horizontal\"");\n\t\t\tgf_bs_read_ue_log(bs, \""log2_max_mv_length_vertical\"");\n\t\t}\n\t}\n\n\tif (gf_bs_read_int_log(bs, 1, \""sps_extension_flag\"")) {\n#if 0\n\t\twhile (gf_bs_available(bs)) {\n\t\t\t/*sps_extension_data_flag */ gf_bs_read_int(bs, 1);\n\t\t}\n#endif\n\n\t}\n\n\treturn sps_id;\n}""}, {""func_name"": ""gf_media_vvc_read_sps_bs_internal"", ""file_path"": ""src/media_tools/av_parsers.c"", ""func_code"": ""static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \""sps_id\"");\n\tif ((sps_id<0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \""vps_id\"");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, \""max_sublayers_minus1\"");\n\tsps->chroma_format_idc = gf_bs_read_int_log(bs, 2, \""chroma_format_idc\"");\n\tsps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, \""log2_ctu_size_minus5\"");\n\tCtbSizeY = 1<<sps->log2_ctu_size;\n\n\tsps_ptl_dpb_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \""sps_ptl_dpb_hrd_params_present_flag\"");\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tVVC_ProfileTierLevel ptl, *p_ptl;\n\t\tif (sps->vps_id) {\n\t\t\tp_ptl = &ptl;\n\t\t} else {\n\t\t\tp_ptl = &vvc->vps[0].ptl[0];\n\t\t}\n\t\tmemset(p_ptl, 0, sizeof(VVC_ProfileTierLevel));\n\t\tp_ptl->pt_present = 1;\n\t\tp_ptl->ptl_max_tid = sps->max_sublayers;\n\t\tvvc_profile_tier_level(bs, p_ptl, 0);\n\t}\n\tsps->gdr_enabled = gf_bs_read_int_log(bs, 1, \""gdr_enabled\"");\n\tsps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, \""ref_pic_resampling\"");\n\tif (sps->ref_pic_resampling)\n\t\tsps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, \""res_change_in_clvs\"");\n\tsps->width = gf_bs_read_ue_log(bs, \""width\"");\n\tsps->height = gf_bs_read_ue_log(bs, \""height\"");\n\tsps->conf_window = gf_bs_read_int_log(bs, 1, \""conformance_window_present_flag\"");\n\tif (sps->conf_window) {\n\t\tsps->cw_left = gf_bs_read_ue_log(bs, \""conformance_window_left\"");\n\t\tsps->cw_right = gf_bs_read_ue_log(bs, \""conformance_window_right\"");\n\t\tsps->cw_top = gf_bs_read_ue_log(bs, \""conformance_window_top\"");\n\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \""conformance_window_bottom\"");\n\t}\n\tsps->subpic_info_present = gf_bs_read_int_log(bs, 1, \""subpic_info_present\"");\n\tif (sps->subpic_info_present) {\n\t\tsps->nb_subpics = 1 + gf_bs_read_ue_log(bs, \""nb_subpics_minus1\"");\n\t\tif (sps->nb_subpics>1) {\n\t\t\tu32 tmpWidthVal, tmpHeightVal;\n\t\t\tsps->independent_subpic_flags = gf_bs_read_int_log(bs, 1, \""independent_subpic_flags\"");\n\t\t\tsps->subpic_same_size = gf_bs_read_int_log(bs, 1, \""subpic_same_size\"");\n\n\t\t\ttmpWidthVal = (sps->width + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpWidthVal = gf_get_bit_size(tmpWidthVal);\n\t\t\ttmpHeightVal = (sps->height + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpHeightVal = gf_get_bit_size(tmpHeightVal);\n\n\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\tif( !sps->subpic_same_size || !i) {\n\t\t\t\t\tif (i && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \""subpic_ctu_top_left_x\"");\n\t\t\t\t\tif (i && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \""subpic_ctu_top_left_y\"");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \""subpic_width_minus1\"");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \""subpic_height_minus1\"");\n\t\t\t\t}\n\t\t\t\tif (!sps->independent_subpic_flags) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""subpic_treated_as_pic_flag\"");\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \""loop_filter_across_subpic_enabled_flag\"");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsps->subpicid_len = gf_bs_read_ue_log(bs, \""subpic_id_len_minus1\"") + 1;\n\t\t\tsps->subpicid_mapping_explicit = gf_bs_read_int_log(bs, 1, \""subpic_id_mapping_explicitly_signalled_flag\"");\n\t\t\tif (sps->subpicid_mapping_explicit) {\n\t\t\t\tsps->subpicid_mapping_present = gf_bs_read_int_log(bs, 1, \""subpic_id_mapping_present_flag\"");\n\t\t\t\tif (sps->subpicid_mapping_present) {\n\t\t\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\t\t\tgf_bs_read_ue_log(bs, \""subpic_id\"");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsps->bitdepth = gf_bs_read_ue_log(bs, \""bitdepth_minus8\"") + 8;\n\tgf_bs_read_int_log(bs, 1, \""entropy_coding_sync_enabled_flag\"");\n\tgf_bs_read_int_log(bs, 1, \""entry_point_offsets_present_flag\"");\n\tsps->log2_max_poc_lsb = 4 + gf_bs_read_int_log(bs, 4, \""log2_max_poc_lsb_minus4\"");\n\tif ((sps->poc_msb_cycle_flag = gf_bs_read_int_log(bs, 1, \""poc_msb_cycle_flag\"")))\n\t\tsps->poc_msb_cycle_len = 1 + gf_bs_read_ue_log(bs, \""poc_msb_cycle_len_minus1\"");\n\n\tu8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, \""sps_num_extra_ph_bytes\"");\n\tfor (i=0; i<sps_num_extra_ph_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \""extra_ph_bit_present_flag\"", 1))\n\t\t\tsps->ph_num_extra_bits++;\n\t}\n\tu8 sps_num_extra_sh_bits = 8 * gf_bs_read_int_log(bs, 2, \""num_extra_sh_bytes\"");\n\tfor (i=0; i<sps_num_extra_sh_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \""extra_sh_bit_present_flag\"", i))\n\t\t\tsps->sh_num_extra_bits++;\n\t}\n\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tu8 sps_sublayer_dpb_params_flag = 0;\n\t\tif (sps->max_sublayers>1) {\n\t\t\tsps_sublayer_dpb_params_flag = gf_bs_read_int_log(bs, 1, \""sps_sublayer_dpb_params_flag\"");\n\t\t}\n\t\tfor (i=(sps_sublayer_dpb_params_flag ? 0 : sps->max_sublayers-1); i < sps->max_sublayers; i++ ) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \""dpb_max_dec_pic_buffering_minus1\"", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \""dpb_max_num_reorder_pics\"", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \""dpb_max_latency_increase_plus1\"", i);\n\t\t}\n\t}\n\tgf_bs_read_ue_log(bs, \""sps_log2_min_luma_coding_block_size_minus2\"");\n\tgf_bs_read_int_log(bs, 1, \""sps_partition_constraints_override_enabled_flag\"");\n\tgf_bs_read_ue_log(bs, \""sps_log2_min_luma_coding_block_size_minus2\"");\n\tu8 sps_max_mtt_hierarchy_depth_intra_slice_luma = gf_bs_read_ue_log(bs, \""sps_max_mtt_hierarchy_depth_intra_slice_luma\"");\n\tif (sps_max_mtt_hierarchy_depth_intra_slice_luma != 0) {\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_bt_min_qt_intra_slice_luma\"");\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_tt_min_qt_intra_slice_luma\"");\n\t}\n\tu8 sps_qtbtt_dual_tree_intra_flag = 0;\n\tif (sps->chroma_format_idc) {\n\t\tsps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, \""sps_qtbtt_dual_tree_intra_flag\"");\n\t}\n\tif (sps_qtbtt_dual_tree_intra_flag) {\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_min_qt_min_cb_intra_slice_chroma\"");\n\t\tu8 sps_max_mtt_hierarchy_depth_intra_slice_chroma = gf_bs_read_ue_log(bs, \""sps_max_mtt_hierarchy_depth_intra_slice_chroma\"");\n\t\tif( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0) {\n\t\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_bt_min_qt_intra_slice_chroma\"");\n\t\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_tt_min_qt_intra_slice_chroma\"");\n\t\t}\n\t}\n\n\tgf_bs_read_ue_log(bs, \""sps_log2_diff_min_qt_min_cb_inter_slice\"");\n\tu8 sps_max_mtt_hierarchy_depth_inter_slice = gf_bs_read_ue_log(bs, \""sps_max_mtt_hierarchy_depth_inter_slice\"");\n\tif (sps_max_mtt_hierarchy_depth_inter_slice != 0) {\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_bt_min_qt_inter_slice\"");\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_diff_max_tt_min_qt_inter_slice\"");\n\t}\n\t//u8 sps_max_luma_transform_size_64_flag = 0;\n\tif (CtbSizeY > 32) {\n\t\t/*sps_max_luma_transform_size_64_flag = */gf_bs_read_int_log(bs, 1, \""sps_max_luma_transform_size_64_flag\"");\n\t}\n\tu8 sps_transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \""sps_transform_skip_enabled_flag\"");\n\n\tif (sps_transform_skip_enabled_flag) {\n\t\tgf_bs_read_ue_log(bs, \""sps_log2_transform_skip_max_size_minus2\"");\n\t\tgf_bs_read_int_log(bs, 1, \""sps_bdpcm_enabled_flag\"");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \""sps_mts_enabled_flag\"")) {\n\t\tgf_bs_read_int_log(bs, 1, \""sps_explicit_mts_intra_enabled_flag\"");\n\t\tgf_bs_read_int_log(bs, 1, \""sps_explicit_mts_inter_enabled_flag\"");\n\t}\n\tgf_bs_read_int_log(bs, 1, \""sps_lfnst_enabled_flag\"");\n\tif (sps->chroma_format_idc) {\n\t\tu8 sps_joint_cbcr_enabled_flag = gf_bs_read_int_log(bs, 1, \""sps_joint_cbcr_enabled_flag\"");\n\t\tu8 sps_same_qp_table_for_chroma_flag = gf_bs_read_int_log(bs, 1, \""sps_same_qp_table_for_chroma_flag\"");\n\t\tu32 numQpTables = sps_same_qp_table_for_chroma_flag ? 1 : (sps_joint_cbcr_enabled_flag ? 3 : 2);\n\t\tfor (i=0; i<numQpTables; i++) {\n\t\t\tgf_bs_read_se_log_idx(bs, \""sps_qp_table_start_minus26\"", i);\n\t\t\tu32 j, sps_num_points_in_qp_table = 1 + gf_bs_read_ue_log_idx(bs, \""sps_num_points_in_qp_table_minus1\"", i);\n\t\t\tfor (j=0; j<sps_num_points_in_qp_table; j++) {\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \""sps_delta_qp_in_val_minus1\"", i, j);\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \""sps_delta_qp_diff_val\"", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \""sps_sao_enabled_flag\"");\n\tsps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, \""sps_alf_enabled_flag\"");\n\tif (sps->alf_enabled_flag && sps->chroma_format_idc) {\n\t\tgf_bs_read_int_log(bs, 1, \""sps_ccalf_enabled_flag\"");\n\t}\n\t/*! TODO parse the rest !*/\n\n\treturn sps_id;\n}""}]","{""value"": 3, ""query"": 2, ""code"": 2}","[{""source"": ""value_info(file:av_parsers.c, value:pps_id)"", ""result"": {""value_trace"": [{""full_code"": ""pps_id = gf_bs_read_ue_log(bs, \""pps_id\"")"", ""line"": 5449, ""func_name"": ""gf_avc_read_pps_bs_internal""}, {""full_code"": ""pps_id = gf_avc_read_pps_bs(bs, avc)"", ""line"": 5533, ""func_name"": ""gf_avc_read_pps""}, {""full_code"": ""pps_id = gf_bs_read_ue_log(bs, \""pps_id\"")"", ""line"": 5672, ""func_name"": ""avc_parse_slice""}, {""full_code"": ""pps_id = gf_bs_read_ue_log(bs, \""pps_id\"")"", ""line"": 5781, ""func_name"": ""svc_parse_slice""}, {""full_code"": ""pps_id = gf_bs_read_ue_log(bs, \""pps_id\"")"", ""line"": 6845, ""func_name"": ""hevc_parse_slice_segment""}], ""struct_var"": ""pps_id"", ""struct_type"": ""s32"", ""struct_definition"": ""typedef int s32;\n\ntypedef int s32;\n\ntypedef int32_t s32;""}}, {""source"": ""value_info(file:av_parsers.c, value:sps_id)"", ""result"": {""value_trace"": [{""full_code"": ""sps_id = -1"", ""line"": 5088, ""func_name"": ""gf_avc_read_sps_bs_internal""}, {""full_code"": ""sps_id = gf_bs_read_ue_log(bs, \""sps_id\"") + GF_SVC_SSPS_ID_SHIFT * subseq_sps"", ""line"": 5117, ""func_name"": ""gf_avc_read_sps_bs_internal""}, {""full_code"": ""sps_id = -1"", ""line"": 5407, ""func_name"": ""gf_avc_read_sps""}, {""full_code"": ""sps_id = -1"", ""line"": 5425, ""func_name"": ""gf_avc_read_sps""}, {""full_code"": ""sps_id = gf_avc_read_sps_bs(bs, avc, subseq_sps, vui_flag_pos)"", ""line"": 5429, ""func_name"": ""gf_avc_read_sps""}], ""struct_var"": ""sps_id"", ""struct_type"": ""s32"", ""struct_definition"": ""typedef int s32;\n\ntypedef int s32;\n\ntypedef int32_t s32;""}}, {""source"": ""value_info(file:av_parsers.c, value:vps_id)"", ""result"": {""value_trace"": [{""full_code"": ""vps_id = gf_bs_read_int_log(bs, 4, \""vps_id\"")"", ""line"": 7667, ""func_name"": ""gf_hevc_read_vps_bs_internal""}, {""full_code"": ""vps_id = -1"", ""line"": 7771, ""func_name"": ""gf_hevc_read_vps_ex""}, {""full_code"": ""vps_id = gf_hevc_read_vps_bs_internal(bs, hevc, remove_extensions)"", ""line"": 7790, ""func_name"": ""gf_hevc_read_vps_ex""}, {""full_code"": ""vps_id = gf_bs_read_int_log(bs, 4, \""vps_id\"")"", ""line"": 7897, ""func_name"": ""gf_hevc_read_sps_bs_internal""}, {""full_code"": ""vps_id = gf_bs_read_int_log(bs, 4, \""vps_id\"")"", ""line"": 9362, ""func_name"": ""gf_media_vvc_read_vps_bs_internal""}], ""struct_var"": ""vps_id"", ""struct_type"": ""s32"", ""struct_definition"": ""typedef int s32;\n\ntypedef int s32;\n\ntypedef int32_t s32;""}}, {""source"": ""query_info(query:cpg.method.name(\""gf_bs_read_ue_log\"").l)"", ""result"": [{""name"": ""gf_bs_read_ue_log"", ""signature"": """", ""lineNumberEnd"": 4717, ""fullName"": ""src/media_tools/av_parsers.c:4717:4717:gf_bs_read_ue_log:2"", ""code"": ""<empty>"", ""lineNumber"": 4717, ""filename"": ""src/media_tools/av_parsers.c""}]}, {""source"": ""query_info(query:cpg.method.name(\""gf_bs_read_int_log\"").l)"", ""result"": [{""name"": ""gf_bs_read_int_log"", ""signature"": """", ""lineNumberEnd"": 51, ""fullName"": ""src/media_tools/av_parsers.c:51:51:gf_bs_read_int_log:3"", ""code"": ""<empty>"", ""lineNumber"": 51, ""filename"": ""src/media_tools/av_parsers.c""}]}, {""source"": ""code_info(file:av_parsers.c, lines:4717-4737)"", ""result"": ""#define gf_bs_read_ue_log(_bs, _fname) gf_bs_read_ue_log_idx3(_bs, _fname, -1, -1, -1)\n\n\nu32 gf_bs_read_ue(GF_BitStream *bs)\n{\n\treturn gf_bs_read_ue_log(bs, NULL);\n}\n\ns32 gf_bs_read_se(GF_BitStream *bs)\n{\n\tu32 v = gf_bs_read_ue(bs);\n\tif ((v & 0x1) == 0) return (s32)(0 - (v >> 1));\n\treturn (v + 1) >> 1;\n}\n\ns32 gf_bs_read_se_log_idx2(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2)\n{\n\ts32 res = gf_bs_read_se(bs);\n\tif (fname)\n\t\tgf_bs_log_idx(bs, -1, fname, res, idx1, idx2, -1);\n\treturn res;\n""}, {""source"": ""code_info(file:av_parsers.c, lines:51-71)"", ""result"": ""#define gf_bs_read_int_log(_bs, _nBits, _fname) gf_bs_read_int_log_idx3(_bs, _nBits, _fname, -1, -1, -1)\n#define gf_bs_read_int_log_idx(_bs, _nBits, _fname, _idx) gf_bs_read_int_log_idx3(_bs, _nBits, _fname, _idx, -1, -1)\n#define gf_bs_read_int_log_idx2(_bs, _nBits, _fname, _idx1, _idx2) gf_bs_read_int_log_idx3(_bs, _nBits, _fname, (s32) _idx1, (s32) _idx2, -1)\n\n\n#else\n\n#define gf_bs_log(_bs, _nBits, _fname, _val)\n#define gf_bs_log_idx(_bs, _nBits, _fname, _val, _idx1, _idx2, _idx3)\n\n#define gf_bs_read_int_log(_bs, _nbb, _f) gf_bs_read_int(_bs, _nbb)\n#define gf_bs_read_int_log_idx(_bs, _nbb, _f, _idx) gf_bs_read_int(_bs, _nbb)\n#define gf_bs_read_int_log_idx2(_bs, _nbb, _f, _idx1, _idx2) gf_bs_read_int(_bs, _nbb)\n#define gf_bs_read_int_log_idx3(_bs, _nbb, _f, _idx1, _idx2, _idx3) gf_bs_read_int(_bs, _nbb)\n\n#endif\n\n\n\n\nstatic const struct {\n""}]","1. Malformed input triggers `gf_bs_read_ue_log`/`gf_bs_read_int_log` to parse excessively large values (e.g., UE/INT fields exceeding valid ranges). \n2. These values are stored in `s32` variables (e.g., `pps_id`, `sps_id`, `vps_id`). \n3. Integer overflow converts large unsigned values (u32) to negative `s32` (e.g., `0x80000000`  -2147483648). \n4. Original code only validated upper bounds (e.g., `pps_id >= 64`), leaving negative values unchecked. \n5. Negative IDs are used as array indices (e.g., `hevc->pps[pps_id]`), causing out-of-bounds memory access and a crash. \n6. Patch adds explicit negative checks (e.g., `if (pps_id < 0 || pps_id >= 64)` in `hevc_parse_slice_segment` at `src/media_tools/av_parsers.c:6844`).",0.95,./github/other_context/CVE-2021-30014
70,CVE-2021-31875,"CWE-787, CWE-193",c_cpp,"In mjs_json.c in Cesanta MongooseOS mJS 1.26, a maliciously formed JSON string can trigger an off-by-one heap-based buffer overflow in mjs_json_parse, which can potentially lead to redirection of control flow. NOTE: the original reporter disputes the significance of this finding because ""there isnt very much of an opportunity to exploit this reliably for an information leak, so there isnt any real security impact.""",https://github.com/418sec/mjs/commit/a883c9ae6a140c226d21188dbc993671ada4c088,Fix culprit for JSON heap overflow,1,"[{""func_name"": ""mjs_json_parse"", ""file_path"": ""mjs/src/mjs_json.c"", ""func_code"": ""MJS_PRIVATE mjs_err_t\nmjs_json_parse(struct mjs *mjs, const char *str, size_t len, mjs_val_t *res) {\n  struct json_parse_ctx *ctx =\n      (struct json_parse_ctx *) calloc(sizeof(struct json_parse_ctx), 1);\n  int json_res;\n  enum mjs_err rcode = MJS_OK;\n\n  ctx->mjs = mjs;\n  ctx->result = MJS_UNDEFINED;\n  ctx->frame = NULL;\n  ctx->rcode = MJS_OK;\n\n  mjs_own(mjs, &ctx->result);\n\n  {\n    /*\n     * We have to reallocate the buffer before invoking json_walk, because\n     * frozen_cb can create new strings, which can result in the reallocation\n     * of mjs string mbuf, invalidating the `str` pointer.\n     */\n    char *stmp = malloc(len);\n    memcpy(stmp, str, len);\n    json_res = json_walk(stmp, len, frozen_cb, ctx);\n    free(stmp);\n    stmp = NULL;\n\n    /* str might have been invalidated, so null it out */\n    str = NULL;\n  }\n\n  if (ctx->rcode != MJS_OK) {\n    rcode = ctx->rcode;\n    mjs_prepend_errorf(mjs, rcode, \""invalid JSON string\"");\n  } else if (json_res < 0) {\n    /* There was an error during parsing */\n    rcode = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, rcode, \""invalid JSON string\"");\n  } else {\n    /* Expression is parsed successfully */\n    *res = ctx->result;\n\n    /* There should be no allocated frames */\n    assert(ctx->frame == NULL);\n  }\n\n  if (rcode != MJS_OK) {\n    /* There might be some allocated frames in case of malformed JSON */\n    while (ctx->frame != NULL) {\n      ctx->frame = free_json_frame(ctx, ctx->frame);\n    }\n  }\n\n  mjs_disown(mjs, &ctx->result);\n  free(ctx);\n\n  return rcode;\n}"", ""target"": 0}]","[{""func_name"": ""mjs_json_parse"", ""file_path"": ""mjs/src/mjs_json.c"", ""func_code"": ""MJS_PRIVATE mjs_err_t\nmjs_json_parse(struct mjs *mjs, const char *str, size_t len, mjs_val_t *res) {\n  struct json_parse_ctx *ctx =\n      (struct json_parse_ctx *) calloc(sizeof(struct json_parse_ctx), 1);\n  int json_res;\n  enum mjs_err rcode = MJS_OK;\n\n  ctx->mjs = mjs;\n  ctx->result = MJS_UNDEFINED;\n  ctx->frame = NULL;\n  ctx->rcode = MJS_OK;\n\n  mjs_own(mjs, &ctx->result);\n\n  {\n    /*\n     * We have to reallocate the buffer before invoking json_walk, because\n     * frozen_cb can create new strings, which can result in the reallocation\n     * of mjs string mbuf, invalidating the `str` pointer.\n     */\n    char *stmp = malloc(len + 1);\n    memcpy(stmp, str, len);\n    stmp[len] = '\\0';\n\n    json_res = json_walk(stmp, len, frozen_cb, ctx);\n    free(stmp);\n    stmp = NULL;\n\n    /* str might have been invalidated, so null it out */\n    str = NULL;\n  }\n\n  if (ctx->rcode != MJS_OK) {\n    rcode = ctx->rcode;\n    mjs_prepend_errorf(mjs, rcode, \""invalid JSON string\"");\n  } else if (json_res < 0) {\n    /* There was an error during parsing */\n    rcode = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, rcode, \""invalid JSON string\"");\n  } else {\n    /* Expression is parsed successfully */\n    *res = ctx->result;\n\n    /* There should be no allocated frames */\n    assert(ctx->frame == NULL);\n  }\n\n  if (rcode != MJS_OK) {\n    /* There might be some allocated frames in case of malformed JSON */\n    while (ctx->frame != NULL) {\n      ctx->frame = free_json_frame(ctx, ctx->frame);\n    }\n  }\n\n  mjs_disown(mjs, &ctx->result);\n  free(ctx);\n\n  return rcode;\n}""}]","{""value"": 2, ""function"": 1, ""caller"": 1}","[{""source"": ""value_info(file:mjs_json.c, value:len)"", ""result"": {""value_trace"": [{""full_code"": ""len = 0"", ""line"": 120, ""func_name"": ""to_json_or_debug<duplicate>0""}, {""full_code"": ""len = 10"", ""line"": 136, ""func_name"": ""to_json_or_debug<duplicate>0""}, {""full_code"": ""len = snquote(buf, size, str, n)"", ""line"": 167, ""func_name"": ""to_json_or_debug<duplicate>0""}, {""full_code"": ""len = b - buf"", ""line"": 206, ""func_name"": ""to_json_or_debug<duplicate>0""}, {""full_code"": ""len = b - buf"", ""line"": 238, ""func_name"": ""to_json_or_debug<duplicate>0""}], ""struct_var"": ""len"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}, {""source"": ""func_info(file:mjs_json.c, func:mjs_json_parse)"", ""result"": [{""code"": ""MJS_PRIVATE mjs_err_t\nmjs_json_parse(struct mjs *mjs, const char *str, size_t len, mjs_val_t *res) {\n  struct json_parse_ctx *ctx =\n      (struct json_parse_ctx *) calloc(sizeof(struct json_parse_ctx), 1);\n  int json_res;\n  enum mjs_err rcode = MJS_OK;\n\n  ctx->mjs = mjs;\n  ctx->result = MJS_UNDEFINED;\n  ctx->frame = NULL;\n  ctx->rcode = MJS_OK;\n\n  mjs_own(mjs, &ctx->result);\n\n  {\n    /*\n     * We have to reallocate the buffer before invoking json_walk, because\n     * frozen_cb can create new strings, which can result in the reallocation\n     * of mjs string mbuf, invalidating the `str` pointer.\n     */\n    char *stmp = malloc(len);\n    memcpy(stmp, str, len);\n    json_res = json_walk(stmp, len, frozen_cb, ctx);\n    free(stmp);\n    stmp = NULL;\n\n    /* str might have been invalidated, so null it out */\n    str = NULL;\n  }\n\n  if (ctx->rcode != MJS_OK) {\n    rcode = ctx->rcode;\n    mjs_prepend_errorf(mjs, rcode, \""invalid JSON string\"");\n  } else if (json_res < 0) {\n    /* There was an error during parsing */\n    rcode = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, rcode, \""invalid JSON string\"");\n  } else {\n    /* Expression is parsed successfully */\n    *res = ctx->result;\n\n    /* There should be no allocated frames */\n    assert(ctx->frame == NULL);\n  }\n\n  if (rcode != MJS_OK) {\n    /* There might be some allocated frames in case of malformed JSON */\n    while (ctx->frame != NULL) {\n      ctx->frame = free_json_frame(ctx, ctx->frame);\n    }\n  }\n\n  mjs_disown(mjs, &ctx->result);\n  free(ctx);\n\n  return rcode;\n}\n"", ""start_line"": 428, ""end_line"": 484, ""full_name"": ""mjs_json_parse<duplicate>0"", ""file_path"": ""mjs/src/mjs_json.c""}]}, {""source"": ""value_info(file:mjs_json.c, value:len)"", ""result"": {""value_trace"": [{""full_code"": ""len = 0"", ""line"": 120, ""func_name"": ""to_json_or_debug<duplicate>0""}, {""full_code"": ""len = 10"", ""line"": 136, ""func_name"": ""to_json_or_debug<duplicate>0""}, {""full_code"": ""len = snquote(buf, size, str, n)"", ""line"": 167, ""func_name"": ""to_json_or_debug<duplicate>0""}, {""full_code"": ""len = b - buf"", ""line"": 206, ""func_name"": ""to_json_or_debug<duplicate>0""}, {""full_code"": ""len = b - buf"", ""line"": 238, ""func_name"": ""to_json_or_debug<duplicate>0""}], ""struct_var"": ""len"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}, {""source"": ""caller_info(file:mjs_json.c, func:mjs_json_parse)"", ""result"": [{""call_line"": 510, ""call_code"": ""mjs_json_parse(mjs, str, len, &ret)"", ""caller_code"": ""MJS_PRIVATE void mjs_op_json_parse(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t arg0 = mjs_arg(mjs, 0);\n\n  if (mjs_is_string(arg0)) {\n    size_t len;\n    const char *str = mjs_get_string(mjs, &arg0, &len);\n    mjs_json_parse(mjs, str, len, &ret);\n  } else {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \""string argument required\"");\n  }\n\n  mjs_return(mjs, ret);\n}"", ""caller_start"": 503, ""file_path"": ""mjs/src/mjs_json.c""}, {""call_line"": 12193, ""call_code"": ""mjs_json_parse(mjs, str, len, &ret)"", ""caller_code"": ""MJS_PRIVATE void mjs_op_json_parse(struct mjs *mjs) {\n  mjs_val_t ret = MJS_UNDEFINED;\n  mjs_val_t arg0 = mjs_arg(mjs, 0);\n\n  if (mjs_is_string(arg0)) {\n    size_t len;\n    const char *str = mjs_get_string(mjs, &arg0, &len);\n    mjs_json_parse(mjs, str, len, &ret);\n  } else {\n    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, \""string argument required\"");\n  }\n\n  mjs_return(mjs, ret);\n}"", ""caller_start"": 12186, ""file_path"": ""mjs.c""}]}]","Heap overflow in `mjs_json_parse` (file:mjs/src/mjs_json.c:428-484) due to insufficient buffer allocation (`malloc(len)`) without null-termination. The `len` parameter is derived from user input via `mjs_get_string` in `mjs_op_json_parse` (file:mjs/src/mjs_json.c:503-510, mjs.c:12186-12193). The patch fixes this by allocating `len + 1` and null-terminating the buffer.",0.95,./github/other_context/CVE-2021-31875
71,CVE-2021-41222,CWE-682,c_cpp,"TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SplitV` can trigger a segfault is an attacker supplies negative arguments. This occurs whenever `size_splits` contains more than one value and at least one value is negative. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",https://github.com/tensorflow/tensorflow/commit/25d622ffc432acc736b14ca3904177579e733cc6,"A negative size in one of the split sizes allowed the computed size of another\nto exceed the total dimension, leading to a segfault and security vulnerability.\nAdding a check for negative sizes prevents this.\n\nPiperOrigin-RevId: 401035665\nChange-Id: I79bbe329787dac82aa4bf60397a9129b716aedab",1,"[{""func_name"": ""ComputeEasyCases"", ""file_path"": ""tensorflow/core/kernels/split_v_op.cc"", ""func_code"": ""void ComputeEasyCases(OpKernelContext* context, bool* done,\n                        std::vector<Tlen>* split_sizes_vec) {\n    const int32_t num_split = context->num_outputs();\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const Tensor& split_tensor = context->input(1);\n    const Tensor& split_dim_tensor = context->input(2);\n\n    OP_REQUIRES(context, split_dim_tensor.NumElements() == 1,\n                errors::InvalidArgument(\""split_dim_tensor must have \""\n                                        \""exactly one element.\""));\n\n    const int32_t split_dim_orig = split_dim_tensor.flat<int32>()(0);\n    const int32_t split_dim =\n        split_dim_orig < 0 ? split_dim_orig + input.dims() : split_dim_orig;\n\n    OP_REQUIRES(\n        context,\n        split_tensor.dims() == 1 && split_tensor.NumElements() == num_split,\n        errors::InvalidArgument(\""size of the split_tensor must be 1-D and have \""\n                                \""the same elements as outputs got \"",\n                                split_tensor.dims(), \"" -D and \"",\n                                split_tensor.NumElements(), \"" elements\""));\n\n    auto split_sizes_d = split_tensor.vec<Tlen>();\n\n    split_sizes_vec->resize(split_sizes_d.size());\n\n    std::copy(split_sizes_d.data(), split_sizes_d.data() + split_sizes_d.size(),\n              split_sizes_vec->begin());\n\n    OP_REQUIRES(\n        context, num_split > 0,\n        errors::InvalidArgument(\n            \""Number of ways to split should be > 0, but got \"", num_split));\n\n    OP_REQUIRES(\n        context, 0 <= split_dim && split_dim < input.dims(),\n        errors::InvalidArgument(\""-input rank(-\"", input.dims(),\n                                \"") <= split_dim < input rank (\"", input.dims(),\n                                \""), but got \"", split_dim_orig));\n\n    Tlen input_size_split_dim = input_shape.dim_size(split_dim);\n\n    // Special case 1: num_split == 1. Nothing to do.\n    if (num_split == 1) {\n      context->set_output(0, context->input(0));\n      OP_REQUIRES(\n          context, (*split_sizes_vec)[0] == input_size_split_dim,\n          errors::InvalidArgument(\""If there is only one output, it must have \""\n                                  \""the same size as the input. Input size: \"",\n                                  input_size_split_dim,\n                                  \"" output size: \"", (*split_sizes_vec)[0]));\n      *done = true;\n      return;\n    }\n\n    // Determine sizes of output, in case of a -1 input value\n    int neg_one_dim = -1;\n    Tlen determined_size = 0;\n    for (int d = 0; d < split_sizes_vec->size(); ++d) {\n      Tlen size = (*split_sizes_vec)[d];\n\n      if (size == -1) {\n        OP_REQUIRES(context, neg_one_dim == -1,\n                    errors::InvalidArgument(\""There can only be one -1 in the \""\n                                            \""input.\""));\n        neg_one_dim = d;\n      } else {\n        determined_size += size;\n      }\n    }\n\n    OP_REQUIRES(\n        context,\n        (neg_one_dim == -1 && determined_size == input_size_split_dim) ||\n            (neg_one_dim >= 0 && determined_size <= input_size_split_dim),\n        errors::InvalidArgument(\""Determined shape must either match \""\n                                \""input shape along split_dim exactly if \""\n                                \""fully specified, or be less than the size of \""\n                                \""the input along split_dim if not fully \""\n                                \""specified.  Got: \"",\n                                determined_size));\n\n    if (neg_one_dim >= 0) {\n      (*split_sizes_vec)[neg_one_dim] = input_size_split_dim - determined_size;\n    }\n\n    // Special case 2: split along the 1st dimension. The requirements are that\n    // either we are splitting the outer dimension of two or more such that\n    // every outer subpart is aligned or that the split sizes mean that they are\n    // always aligned. In these cases, we can share the underlying buffer.\n    //\n    // Apply this optimization conservatively: if input is aligned,\n    // the resulting tensors must be aligned. It's conservative\n    // because if the immediate consumer of the resulting tensors are\n    // not using eigen for computation, its perfectly fine to avoid\n    // the copying.\n    if (SplitHasAlignedOutputsInFirstDimension(\n            input_shape, split_dim, absl::MakeConstSpan(*split_sizes_vec))) {\n      Tlen start = 0;\n      for (int i = 0; i < num_split; ++i) {\n        context->set_output(i,\n                            input.Slice(start, start + (*split_sizes_vec)[i]));\n        start += (*split_sizes_vec)[i];\n      }\n      *done = true;\n      return;\n    }\n  }"", ""target"": 0}]","[{""func_name"": ""ComputeEasyCases"", ""file_path"": ""tensorflow/core/kernels/split_v_op.cc"", ""func_code"": ""void ComputeEasyCases(OpKernelContext* context, bool* done,\n                        std::vector<Tlen>* split_sizes_vec) {\n    const int32_t num_split = context->num_outputs();\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const Tensor& split_tensor = context->input(1);\n    const Tensor& split_dim_tensor = context->input(2);\n\n    OP_REQUIRES(context, split_dim_tensor.NumElements() == 1,\n                errors::InvalidArgument(\""split_dim_tensor must have \""\n                                        \""exactly one element.\""));\n\n    const int32_t split_dim_orig = split_dim_tensor.flat<int32>()(0);\n    const int32_t split_dim =\n        split_dim_orig < 0 ? split_dim_orig + input.dims() : split_dim_orig;\n\n    OP_REQUIRES(\n        context,\n        split_tensor.dims() == 1 && split_tensor.NumElements() == num_split,\n        errors::InvalidArgument(\""size of the split_tensor must be 1-D and have \""\n                                \""the same elements as outputs got \"",\n                                split_tensor.dims(), \"" -D and \"",\n                                split_tensor.NumElements(), \"" elements\""));\n\n    auto split_sizes_d = split_tensor.vec<Tlen>();\n\n    split_sizes_vec->resize(split_sizes_d.size());\n\n    std::copy(split_sizes_d.data(), split_sizes_d.data() + split_sizes_d.size(),\n              split_sizes_vec->begin());\n\n    OP_REQUIRES(\n        context, num_split > 0,\n        errors::InvalidArgument(\n            \""Number of ways to split should be > 0, but got \"", num_split));\n\n    OP_REQUIRES(\n        context, 0 <= split_dim && split_dim < input.dims(),\n        errors::InvalidArgument(\""-input rank(-\"", input.dims(),\n                                \"") <= split_dim < input rank (\"", input.dims(),\n                                \""), but got \"", split_dim_orig));\n\n    Tlen input_size_split_dim = input_shape.dim_size(split_dim);\n\n    // Special case 1: num_split == 1. Nothing to do.\n    if (num_split == 1) {\n      context->set_output(0, context->input(0));\n      OP_REQUIRES(\n          context, (*split_sizes_vec)[0] == input_size_split_dim,\n          errors::InvalidArgument(\""If there is only one output, it must have \""\n                                  \""the same size as the input. Input size: \"",\n                                  input_size_split_dim,\n                                  \"" output size: \"", (*split_sizes_vec)[0]));\n      *done = true;\n      return;\n    }\n\n    // Determine sizes of output, in case of a -1 input value\n    int neg_one_dim = -1;\n    Tlen determined_size = 0;\n    for (int d = 0; d < split_sizes_vec->size(); ++d) {\n      Tlen size = (*split_sizes_vec)[d];\n\n      if (size == -1) {\n        OP_REQUIRES(context, neg_one_dim == -1,\n                    errors::InvalidArgument(\""There can only be one -1 in the \""\n                                            \""input.\""));\n        neg_one_dim = d;\n      } else {\n        determined_size += size;\n      }\n    }\n\n    OP_REQUIRES(\n        context,\n        (neg_one_dim == -1 && determined_size == input_size_split_dim) ||\n            (neg_one_dim >= 0 && determined_size <= input_size_split_dim),\n        errors::InvalidArgument(\""Determined shape must either match \""\n                                \""input shape along split_dim exactly if \""\n                                \""fully specified, or be less than the size of \""\n                                \""the input along split_dim if not fully \""\n                                \""specified.  Got: \"",\n                                determined_size));\n\n    if (neg_one_dim >= 0) {\n      (*split_sizes_vec)[neg_one_dim] = input_size_split_dim - determined_size;\n    }\n\n    for (int i = 0; i < split_sizes_vec->size(); ++i) {\n      const Tlen& split_size = (*split_sizes_vec)[i];\n      OP_REQUIRES(context, split_size >= Tlen(0),\n                  errors::InvalidArgument(\""Split size at index \"", i,\n                                          \"" must be >= 0. Got: \"", split_size));\n    }\n\n    // Special case 2: split along the 1st dimension. The requirements are that\n    // either we are splitting the outer dimension of two or more such that\n    // every outer subpart is aligned or that the split sizes mean that they are\n    // always aligned. In these cases, we can share the underlying buffer.\n    //\n    // Apply this optimization conservatively: if input is aligned,\n    // the resulting tensors must be aligned. It's conservative\n    // because if the immediate consumer of the resulting tensors are\n    // not using eigen for computation, its perfectly fine to avoid\n    // the copying.\n    if (SplitHasAlignedOutputsInFirstDimension(\n            input_shape, split_dim, absl::MakeConstSpan(*split_sizes_vec))) {\n      Tlen start = 0;\n      for (int i = 0; i < num_split; ++i) {\n        context->set_output(i,\n                            input.Slice(start, start + (*split_sizes_vec)[i]));\n        start += (*split_sizes_vec)[i];\n      }\n      *done = true;\n      return;\n    }\n  }""}]","{""caller"": 1, ""code"": 1, ""value"": 1}","[{""source"": ""caller_info(file:split_v_op.cc, func:ComputeEasyCases)"", ""result"": [{""call_line"": 353, ""call_code"": ""Base::ComputeEasyCases(context, &done, &split_sizes_vec)"", ""caller_code"": ""  void Compute(OpKernelContext* context) override {\n    bool done = false;\n    std::vector<Tlen> split_sizes_vec;\n    Base::ComputeEasyCases(context, &done, &split_sizes_vec);\n    if (!context->status().ok() || done) {\n      return;\n    }\n    const int32_t num_split = Base::num_outputs();\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const int32_t split_dim_orig = context->input(2).flat<int32>()(0);\n    const int32_t split_dim =\n        split_dim_orig < 0 ? split_dim_orig + input.dims() : split_dim_orig;\n\n    // Android also uses int32 indexing, so check here also.\n    OP_REQUIRES(\n        context,\n        FastBoundsCheck(input.NumElements(),\n                        std::numeric_limits<Eigen::DenseIndex>::max()),\n        errors::InvalidArgument(\""Split requires input size < \"",\n                                std::numeric_limits<Eigen::DenseIndex>::max()));\n\n    Eigen::DenseIndex prefix_dim_size;\n    Eigen::DenseIndex split_dim_size;\n    Eigen::DenseIndex suffix_dim_size;\n\n    std::tie(prefix_dim_size, split_dim_size, suffix_dim_size) =\n        Base::template SetDims<Eigen::DenseIndex>(input_shape, split_dim);\n    std::vector<int64_t> split_start_points(num_split);\n    for (int i = 0; i < num_split; ++i) {\n      if (i == 0) {\n        split_start_points[i] = 0;\n      } else {\n        split_start_points[i] =\n            split_start_points[i - 1] + split_sizes_vec[i - 1];\n      }\n    }\n\n    if (prefix_dim_size == 1) {\n      auto input_reshaped =\n          input.shaped<T, 2>({split_dim_size, suffix_dim_size});\n      auto make_sizes = [&](Eigen::DenseIndex split_size) {\n        return Eigen::DSizes<Eigen::DenseIndex, 2>{split_size, suffix_dim_size};\n      };\n      auto reshape_result = [&](Tensor* result, Tlen split_size) {\n        return result->shaped<T, 2>({split_size, suffix_dim_size});\n      };\n      SplitVOpCPUImpl<T, Tlen, decltype(input_reshaped), 2>{}(\n          context, input_reshaped, split_start_points, input_shape, split_dim,\n          prefix_dim_size, split_dim_size, suffix_dim_size, split_sizes_vec,\n          make_sizes, reshape_result);\n    } else {\n      auto input_reshaped = input.shaped<T, 3>(\n          {prefix_dim_size, split_dim_size, suffix_dim_size});\n      auto make_sizes = [&](Eigen::DenseIndex split_size) {\n        return Eigen::DSizes<Eigen::DenseIndex, 3>{prefix_dim_size, split_size,\n                                                   suffix_dim_size};\n      };\n      auto reshape_result = [&](Tensor* result, Tlen split_size) {\n        return result->shaped<T, 3>(\n            {prefix_dim_size, split_size, suffix_dim_size});\n      };\n      SplitVOpCPUImpl<T, Tlen, decltype(input_reshaped), 3>{}(\n          context, input_reshaped, split_start_points, input_shape, split_dim,\n          prefix_dim_size, split_dim_size, suffix_dim_size, split_sizes_vec,\n          make_sizes, reshape_result);\n    }\n  }\n"", ""caller_start"": 350, ""file_path"": ""tensorflow/core/kernels/split_v_op.cc""}, {""call_line"": 206, ""call_code"": ""Base::ComputeEasyCases(context, &done)"", ""caller_code"": ""  void Compute(OpKernelContext* context) override {\n    bool done = false;\n    Base::ComputeEasyCases(context, &done);\n    if (!context->status().ok() || done) {\n      return;\n    }\n    const int32_t num_split = Base::num_outputs();\n    const Tensor& input = context->input(1);\n    const TensorShape& input_shape = input.shape();\n    const int32_t split_dim_orig = context->input(0).flat<int32>()(0);\n    const int32_t split_dim =\n        split_dim_orig < 0 ? split_dim_orig + input.dims() : split_dim_orig;\n\n    // Android also uses int32 indexing, so check here also.\n    OP_REQUIRES(\n        context,\n        FastBoundsCheck(input.NumElements(),\n                        std::numeric_limits<Eigen::DenseIndex>::max()),\n        errors::InvalidArgument(\""Split requires input size < \"",\n                                std::numeric_limits<Eigen::DenseIndex>::max()));\n\n    Eigen::DenseIndex prefix_dim_size;\n    Eigen::DenseIndex split_dim_size;\n    Eigen::DenseIndex suffix_dim_size;\n\n    std::tie(prefix_dim_size, split_dim_size, suffix_dim_size) =\n        Base::template SetDims<Eigen::DenseIndex>(input_shape, split_dim);\n\n    const int64_t split_dim_output_size = split_dim_size / num_split;\n\n    if (prefix_dim_size == 1) {\n      auto input_reshaped =\n          input.shaped<T, 2>({split_dim_size, suffix_dim_size});\n      auto make_sizes = [&](Eigen::DenseIndex split_size) {\n        return Eigen::DSizes<Eigen::DenseIndex, 2>{split_size, suffix_dim_size};\n      };\n      auto reshape_result = [&](Tensor* result, Eigen::DenseIndex split_size) {\n        return result->shaped<T, 2>({split_size, suffix_dim_size});\n      };\n      SplitOpCPUImpl<T, decltype(input_reshaped), 2>{}(\n          context, input_reshaped, input_shape, split_dim, prefix_dim_size,\n          split_dim_size, suffix_dim_size, make_sizes, reshape_result,\n          num_split, split_dim_output_size);\n    } else {\n      auto input_reshaped = input.shaped<T, 3>(\n          {prefix_dim_size, split_dim_size, suffix_dim_size});\n      auto make_sizes = [&](Eigen::DenseIndex split_size) {\n        return Eigen::DSizes<Eigen::DenseIndex, 3>{prefix_dim_size, split_size,\n                                                   suffix_dim_size};\n      };\n      auto reshape_result = [&](Tensor* result, Eigen::DenseIndex split_size) {\n        return result->shaped<T, 3>(\n            {prefix_dim_size, split_size, suffix_dim_size});\n      };\n      SplitOpCPUImpl<T, decltype(input_reshaped), 3>{}(\n          context, input_reshaped, input_shape, split_dim, prefix_dim_size,\n          split_dim_size, suffix_dim_size, make_sizes, reshape_result,\n          num_split, split_dim_output_size);\n    }\n  }\n"", ""caller_start"": 204, ""file_path"": ""tensorflow/core/kernels/split_op.cc""}]}, {""source"": ""code_info(file:split_v_op.cc, lines:145-160)"", ""result"": ""    //\n    // Apply this optimization conservatively: if input is aligned,\n    // the resulting tensors must be aligned. It's conservative\n    // because if the immediate consumer of the resulting tensors are\n    // not using eigen for computation, its perfectly fine to avoid\n    // the copying.\n    if (SplitHasAlignedOutputsInFirstDimension(\n            input_shape, split_dim, absl::MakeConstSpan(*split_sizes_vec))) {\n      Tlen start = 0;\n      for (int i = 0; i < num_split; ++i) {\n        context->set_output(i,\n                            input.Slice(start, start + (*split_sizes_vec)[i]));\n        start += (*split_sizes_vec)[i];\n      }\n      *done = true;\n      return;\n""}, {""source"": ""value_info(file:split_v_op.cc, value:split_sizes_vec)"", ""result"": {""value_trace"": [{""full_code"": ""split_sizes_vec"", ""line"": 352, ""func_name"": null}, {""full_code"": ""split_sizes_vec"", ""line"": 292, ""func_name"": null}, {""full_code"": ""split_sizes_vec"", ""line"": 243, ""func_name"": null}], ""struct_var"": ""split_sizes_vec"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}]","In `tensorflow/core/kernels/split_v_op.cc:352`, `split_sizes_vec` is passed to `ComputeEasyCases`, which previously did not validate for negative values. If `size_splits` contains negative values (e.g., from user input), `split_sizes_vec` retains them. These values are later used in `tensorflow/core/kernels/split_v_op.cc:145-160` to compute `split_start_points` via `split_start_points[i] = split_start_points[i - 1] + split_sizes_vec[i - 1]`. A negative `split_size` can cause `split_start_points` to exceed the input tensor's bounds, leading to a segfault during `input.Slice(...)`. The fix in `ComputeEasyCases:133-140` now enforces non-negative `split_sizes_vec`.",0.95,./github/other_context/CVE-2021-41222
72,CVE-2021-4327,CWE-190,c_cpp,"A vulnerability was found in SerenityOS. It has been rated as critical. Affected by this issue is the function initialize_typed_array_from_array_buffer in the library Userland/Libraries/LibJS/Runtime/TypedArray.cpp. The manipulation leads to integer overflow. The exploit has been disclosed to the public and may be used. Continious delivery with rolling releases is used by this product. Therefore, no version details of affected nor updated releases are available. The patch is identified as f6c6047e49f1517778f5565681fb64750b14bf60. It is recommended to apply a patch to fix this issue. VDB-222074 is the identifier assigned to this vulnerability.",https://github.com/SerenityOS/serenity/commit/f6c6047e49f1517778f5565681fb64750b14bf60,LibJS: Add overflow checks when creating TypedArray from ArrayBuffer\n\nThanks to Iliad for finding this! :^),1,"[{""func_name"": ""initialize_typed_array_from_array_buffer"", ""file_path"": ""Userland/Libraries/LibJS/Runtime/TypedArray.cpp"", ""func_code"": ""static void initialize_typed_array_from_array_buffer(GlobalObject& global_object, TypedArrayBase& typed_array, ArrayBuffer& array_buffer, Value byte_offset, Value length)\n{\n    // 22.2.5.1.3 InitializeTypedArrayFromArrayBuffer, https://tc39.es/ecma262/#sec-initializetypedarrayfromarraybuffer\n\n    auto& vm = global_object.vm();\n    auto element_size = typed_array.element_size();\n    auto offset = byte_offset.to_index(global_object);\n    if (vm.exception())\n        return;\n    if (offset % element_size != 0) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);\n        return;\n    }\n    size_t new_length { 0 };\n    if (!length.is_undefined()) {\n        new_length = length.to_index(global_object);\n        if (vm.exception())\n            return;\n    }\n    // FIXME: 8. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n    auto buffer_byte_length = array_buffer.byte_length();\n    size_t new_byte_length;\n    if (length.is_undefined()) {\n        if (buffer_byte_length % element_size != 0) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size, buffer_byte_length);\n            return;\n        }\n        if (offset > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset, offset, buffer_byte_length);\n            return;\n        }\n        new_byte_length = buffer_byte_length - offset;\n    } else {\n        new_byte_length = new_length * element_size;\n        if (offset + new_byte_length > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength, offset, offset + new_byte_length, buffer_byte_length);\n            return;\n        }\n    }\n    typed_array.set_viewed_array_buffer(&array_buffer);\n    typed_array.set_byte_length(new_byte_length);\n    typed_array.set_byte_offset(offset);\n    typed_array.set_array_length(new_byte_length / element_size);\n}"", ""target"": 0}]","[{""func_name"": ""initialize_typed_array_from_array_buffer"", ""file_path"": ""Userland/Libraries/LibJS/Runtime/TypedArray.cpp"", ""func_code"": ""static void initialize_typed_array_from_array_buffer(GlobalObject& global_object, TypedArrayBase& typed_array, ArrayBuffer& array_buffer, Value byte_offset, Value length)\n{\n    // 22.2.5.1.3 InitializeTypedArrayFromArrayBuffer, https://tc39.es/ecma262/#sec-initializetypedarrayfromarraybuffer\n\n    auto& vm = global_object.vm();\n    auto element_size = typed_array.element_size();\n    auto offset = byte_offset.to_index(global_object);\n    if (vm.exception())\n        return;\n    if (offset % element_size != 0) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);\n        return;\n    }\n    size_t new_length { 0 };\n    if (!length.is_undefined()) {\n        new_length = length.to_index(global_object);\n        if (vm.exception())\n            return;\n    }\n    // FIXME: 8. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n    auto buffer_byte_length = array_buffer.byte_length();\n    Checked<size_t> new_byte_length;\n    if (length.is_undefined()) {\n        if (buffer_byte_length % element_size != 0) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size, buffer_byte_length);\n            return;\n        }\n        if (offset > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset, offset, buffer_byte_length);\n            return;\n        }\n        new_byte_length = buffer_byte_length;\n        new_byte_length -= offset;\n    } else {\n        new_byte_length = new_length;\n        new_byte_length *= element_size;\n\n        Checked<size_t> new_byte_end = new_byte_length;\n        new_byte_end += offset;\n\n        if (new_byte_end.has_overflow()) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::InvalidLength, \""typed array\"");\n            return;\n        }\n\n        if (new_byte_end.value() > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength, offset, new_byte_end.value(), buffer_byte_length);\n            return;\n        }\n    }\n    if (new_byte_length.has_overflow()) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::InvalidLength, \""typed array\"");\n        return;\n    }\n\n    typed_array.set_viewed_array_buffer(&array_buffer);\n    typed_array.set_byte_length(new_byte_length.value());\n    typed_array.set_byte_offset(offset);\n    typed_array.set_array_length(new_byte_length.value() / element_size);\n}""}]","{""value"": 6, ""code"": 2}","[{""source"": ""value_info(file:TypedArray.cpp, value:element_size)"", ""result"": {""value_trace"": [{""full_code"": ""auto element_size"", ""line"": 41, ""func_name"": null}], ""struct_var"": ""element_size"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:TypedArray.cpp, value:new_length)"", ""result"": {""value_trace"": [{""full_code"": ""size_t new_length"", ""line"": 49, ""func_name"": null}], ""struct_var"": ""new_length"", ""struct_type"": ""size_t"", ""struct_definition"": ""using size_t = __SIZE_TYPE__;\n\ntypedef __SIZE_TYPE__ size_t;""}}, {""source"": ""value_info(file:TypedArray.cpp, value:element_size)"", ""result"": {""value_trace"": [{""full_code"": ""auto element_size"", ""line"": 41, ""func_name"": null}], ""struct_var"": ""element_size"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:TypedArray.cpp, value:new_length)"", ""result"": {""value_trace"": [{""full_code"": ""size_t new_length"", ""line"": 49, ""func_name"": null}], ""struct_var"": ""new_length"", ""struct_type"": ""size_t"", ""struct_definition"": ""using size_t = __SIZE_TYPE__;\n\ntypedef __SIZE_TYPE__ size_t;""}}, {""source"": ""value_info(file:TypedArray.cpp, value:element_size)"", ""result"": {""value_trace"": [{""full_code"": ""auto element_size"", ""line"": 41, ""func_name"": null}], ""struct_var"": ""element_size"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:TypedArray.cpp, value:new_length)"", ""result"": {""value_trace"": [{""full_code"": ""size_t new_length"", ""line"": 49, ""func_name"": null}], ""struct_var"": ""new_length"", ""struct_type"": ""size_t"", ""struct_definition"": ""using size_t = __SIZE_TYPE__;\n\ntypedef __SIZE_TYPE__ size_t;""}}, {""source"": ""code_info(file:TypedArray.cpp, lines:40-45)"", ""result"": ""    auto& vm = global_object.vm();\n    auto element_size = typed_array.element_size();\n    auto offset = byte_offset.to_index(global_object);\n    if (vm.exception())\n        return;\n    if (offset % element_size != 0) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);\n""}, {""source"": ""code_info(file:TypedArray.cpp, lines:48-52)"", ""result"": ""    }\n    size_t new_length { 0 };\n    if (!length.is_undefined()) {\n        new_length = length.to_index(global_object);\n        if (vm.exception())\n            return;\n""}]","The vulnerability arises from unchecked integer arithmetic in `initialize_typed_array_from_array_buffer` (file:TypedArray.cpp:55-79). Specifically: (1) `new_byte_length = new_length * element_size` (file:65-67) could overflow if `new_length` (user-provided via `length.to_index`) and `element_size` (fixed per TypedArray type) produce a product exceeding `size_t` bounds. (2) `new_byte_end = new_byte_length + offset` (file:69-71) could overflow, leading to incorrect buffer boundary checks. (3) The final `new_byte_length` (file:77-79) might overflow before being used to set the TypedArray's byte length. These unchecked operations allowed invalid buffer configurations, enabling out-of-bounds memory access.",0.95,./github/other_context/CVE-2021-4327
73,CVE-2022-23575,CWE-190,c_cpp,"Tensorflow is an Open Source Machine Learning Framework. The implementation of `OpLevelCostEstimator::CalculateTensorSize` is vulnerable to an integer overflow if an attacker can create an operation which would involve a tensor with large enough number of elements. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",https://github.com/tensorflow/tensorflow/commit/fcd18ce3101f245b083b30655c27b239dc72221e,"Prevent integer overflow in `OpLevelCostEstimator::CalculateTensorSize`.\n\nIn order to not change the API, we return a negative value in case of overflow. A better fix is to change the API to return a status instead.\n\nPiperOrigin-RevId: 408713061\nChange-Id: I3771475b0c72a2844a3854086966562fd33f2da5",1,"[{""func_name"": ""OpLevelCostEstimator::CalculateTensorSize"", ""file_path"": ""tensorflow/core/grappler/costs/op_level_cost_estimator.cc"", ""func_code"": ""int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \""Count: \"" << count << \"" DataTypeSize: \"" << size;\n  return count * size;\n}"", ""target"": 0}]","[{""func_name"": ""OpLevelCostEstimator::CalculateTensorSize"", ""file_path"": ""tensorflow/core/grappler/costs/op_level_cost_estimator.cc"", ""func_code"": ""int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \""Count: \"" << count << \"" DataTypeSize: \"" << size;\n  int64_t tensor_size = MultiplyWithoutOverflow(count, size);\n  if (tensor_size < 0) {\n    VLOG(1) << \""Overflow encountered when computing tensor size, multiplying \""\n            << count << \"" with \"" << size;\n    return -1;\n  }\n  return tensor_size;\n}""}]","{""function"": 1, ""value"": 2}","[{""source"": ""func_info(func:MultiplyWithoutOverflow)"", ""result"": [{""code"": ""inline int64_t MultiplyWithoutOverflow(const int64_t x, const int64_t y) {\n  // Multiply in uint64 rather than int64_t since signed overflow is undefined.\n  // Negative values will wrap around to large unsigned values in the casts\n  // (see section 4.7 [conv.integral] of the C++14 standard).\n  const uint64 ux = x;\n  const uint64 uy = y;\n  const uint64 uxy = ux * uy;\n\n  // Check if we overflow uint64, using a cheap check if both inputs are small\n  if (TF_PREDICT_FALSE((ux | uy) >> 32 != 0)) {\n    // Ensure nonnegativity.  Note that negative numbers will appear \""large\""\n    // to the unsigned comparisons above.\n    CHECK(x >= 0 && y >= 0);\n\n    // Otherwise, detect overflow using a division\n    if (ux != 0 && uxy / ux != uy) return -1;\n  }\n\n  // Cast back to signed.  Any negative value will signal an error.\n  return static_cast<int64_t>(uxy);\n}"", ""start_line"": 30, ""end_line"": 50, ""full_name"": ""xla.MultiplyWithoutOverflow:int64_t(int64_t,int64_t)"", ""file_path"": ""tensorflow/compiler/xla/overflow_util.h""}, {""code"": ""inline int64_t MultiplyWithoutOverflow(const int64_t x, const int64_t y) {\n  if (TF_PREDICT_FALSE(x < 0)) return -1;\n  if (TF_PREDICT_FALSE(y < 0)) return -1;\n  if (TF_PREDICT_FALSE(x == 0)) return 0;\n\n  // Multiply in uint64 rather than int64 since signed overflow is undefined.\n  // Negative values will wrap around to large unsigned values in the casts\n  // (see section 4.7 [conv.integral] of the C++14 standard).\n  const uint64 ux = x;\n  const uint64 uy = y;\n  const uint64 uxy = ux * uy;\n\n  // Check if we overflow uint64, using a cheap check if both inputs are small\n  if (TF_PREDICT_FALSE((ux | uy) >> 32 != 0)) {\n    // Otherwise, detect overflow using a division\n    if (uxy / ux != uy) return -1;\n  }\n\n  // Cast back to signed. A negative value will signal an error.\n  return static_cast<int64_t>(uxy);\n}"", ""start_line"": 27, ""end_line"": 47, ""full_name"": ""tensorflow.MultiplyWithoutOverflow:int64_t(int64_t,int64_t)"", ""file_path"": ""tensorflow/core/util/overflow.h""}]}, {""source"": ""value_info(file:op_level_cost_estimator.cc, value:count)"", ""result"": {""value_trace"": [{""full_code"": ""int64_t count"", ""line"": 231, ""func_name"": null}, {""full_code"": ""int64_t count"", ""line"": 1555, ""func_name"": null}], ""struct_var"": ""count"", ""struct_type"": ""int64_t"", ""struct_definition"": ""int64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t\n\nint64_t""}}, {""source"": ""value_info(file:op_level_cost_estimator.cc, value:size)"", ""result"": {""value_trace"": [{""full_code"": ""int size"", ""line"": 1556, ""func_name"": null}], ""struct_var"": ""size"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}]","Original code (tensorflow/core/grappler/costs/op_level_cost_estimator.cc:1559) directly multiplied 'count' (int64_t) and 'size' (int) without overflow checking. Patch introduces 'MultiplyWithoutOverflow' (line 1560) to prevent this. The helper function (tensorflow/core/util/overflow.h:27-47) checks for negative inputs and uses uint64_t arithmetic to detect overflow via division. If overflow occurs, returns -1, which is handled by the caller to return -1.",0.95,./github/other_context/CVE-2022-23575
