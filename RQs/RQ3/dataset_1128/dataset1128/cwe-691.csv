id,cve_id,cwe_id,language,description,commit_url,commit_msg,patch_nums,func_before,func_after,context_nums,context_data,root_cause,confidence_score,other_context_path
1,CVE-2021-20286,CWE-617,c_cpp,A flaw was found in libnbd 1.7.3. An assertion failure in nbd_unlocked_opt_go in ilb/opt.c may lead to denial of service.,https://gitlab.com/nbdkit/libnbd/-/commit/fb4440de9cc76e9c14bd3ddf3333e78621f40ad0,"opt_go: Tolerate unplanned server death\n\nWhile debugging some experimental nbdkit code that was triggering an\nassertion failure in nbdkit, I noticed a secondary failure of nbdsh\nalso dying from an assertion:\n\nlibnbd: debug: nbdsh: nbd_opt_go: transition: NEWSTYLE.OPT_GO.SEND -> DEAD\nlibnbd: debug: nbdsh: nbd_opt_go: option queued, ignoring state machine failure\nnbdsh: opt.c:86: nbd_unlocked_opt_go: Assertion `nbd_internal_is_state_negotiating (get_next_state (h))' failed.\n\nAlthough my trigger was from non-production nbdkit code, libnbd should\nnever die from an assertion failure merely because a server\ndisappeared at the wrong moment during an incomplete reply to\nNBD_OPT_GO or NBD_OPT_INFO.  If this is assigned a CVE, a followup\npatch will add mention of it in docs/libnbd-security.pod.\n\nFixes: bbf1c51392 (api: Give aio_opt_go a completion callback)\n",2,"[{""func_name"": ""nbd_unlocked_opt_info"", ""file_path"": ""lib/opt.c"", ""func_code"": ""int\nnbd_unlocked_opt_info (struct nbd_handle *h)\n{\n  int err;\n  nbd_completion_callback c = { .callback = go_complete, .user_data = &err };\n  int r = nbd_unlocked_aio_opt_info (h, &c);\n\n  if (r == -1)\n    return r;\n\n  r = wait_for_option (h);\n  if (r == 0 && err) {\n    assert (nbd_internal_is_state_negotiating (get_next_state (h)));\n    set_error (err, \""server replied with error to opt_info request\"");\n    return -1;\n  }\n  return r;\n}"", ""target"": 0}, {""func_name"": ""nbd_unlocked_opt_go"", ""file_path"": ""lib/opt.c"", ""func_code"": ""int\nnbd_unlocked_opt_go (struct nbd_handle *h)\n{\n  int err;\n  nbd_completion_callback c = { .callback = go_complete, .user_data = &err };\n  int r = nbd_unlocked_aio_opt_go (h, &c);\n\n  if (r == -1)\n    return r;\n\n  r = wait_for_option (h);\n  if (r == 0 && err) {\n    assert (nbd_internal_is_state_negotiating (get_next_state (h)));\n    set_error (err, \""server replied with error to opt_go request\"");\n    return -1;\n  }\n  if (r == 0)\n    assert (nbd_internal_is_state_ready (get_next_state (h)));\n  return r;\n}"", ""target"": 1}]","[{""func_name"": ""nbd_unlocked_opt_info"", ""file_path"": ""lib/opt.c"", ""func_code"": ""int\nnbd_unlocked_opt_info (struct nbd_handle *h)\n{\n  int err;\n  nbd_completion_callback c = { .callback = go_complete, .user_data = &err };\n  int r = nbd_unlocked_aio_opt_info (h, &c);\n\n  if (r == -1)\n    return r;\n\n  r = wait_for_option (h);\n  if (r == 0 && err) {\n    assert (nbd_internal_is_state_negotiating (get_next_state (h)) ||\n            nbd_internal_is_state_dead (get_next_state (h)));\n    set_error (err, \""server replied with error to opt_info request\"");\n    return -1;\n  }\n  return r;\n}""}, {""func_name"": ""nbd_unlocked_opt_go"", ""file_path"": ""lib/opt.c"", ""func_code"": ""int\nnbd_unlocked_opt_go (struct nbd_handle *h)\n{\n  int err;\n  nbd_completion_callback c = { .callback = go_complete, .user_data = &err };\n  int r = nbd_unlocked_aio_opt_go (h, &c);\n\n  if (r == -1)\n    return r;\n\n  r = wait_for_option (h);\n  if (r == 0 && err) {\n    assert (nbd_internal_is_state_negotiating (get_next_state (h)) ||\n            nbd_internal_is_state_dead (get_next_state (h)));\n    set_error (err, \""server replied with error to opt_go request\"");\n    return -1;\n  }\n  if (r == 0)\n    assert (nbd_internal_is_state_ready (get_next_state (h)));\n  return r;\n}""}]","{""function"": 1, ""code"": 2}","[{""source"": ""func_info(file:opt.c, func:nbd_unlocked_opt_go)"", ""result"": [{""code"": ""int\nnbd_unlocked_opt_go (struct nbd_handle *h)\n{\n  int err;\n  nbd_completion_callback c = { .callback = go_complete, .user_data = &err };\n  int r = nbd_unlocked_aio_opt_go (h, &c);\n\n  if (r == -1)\n    return r;\n\n  r = wait_for_option (h);\n  if (r == 0 && err) {\n    assert (nbd_internal_is_state_negotiating (get_next_state (h)));\n    set_error (err, \""server replied with error to opt_go request\"");\n    return -1;\n  }\n  if (r == 0)\n    assert (nbd_internal_is_state_ready (get_next_state (h)));\n  return r;\n}"", ""start_line"": 74, ""end_line"": 93, ""full_name"": ""nbd_unlocked_opt_go"", ""file_path"": ""lib/opt.c""}]}, {""source"": ""code_info(file:opt.c, lines:80-100)"", ""result"": ""\n  if (r == -1)\n    return r;\n\n  r = wait_for_option (h);\n  if (r == 0 && err) {\n    assert (nbd_internal_is_state_negotiating (get_next_state (h)));\n    set_error (err, \""server replied with error to opt_go request\"");\n    return -1;\n  }\n  if (r == 0)\n    assert (nbd_internal_is_state_ready (get_next_state (h)));\n  return r;\n}\n\n/* Issue NBD_OPT_INFO and wait for the reply. */\nint\nnbd_unlocked_opt_info (struct nbd_handle *h)\n{\n  int err;\n  nbd_completion_callback c = { .callback = go_complete, .user_data = &err };\n""}, {""source"": ""code_info(file:opt.c, lines:90-100)"", ""result"": ""  if (r == 0)\n    assert (nbd_internal_is_state_ready (get_next_state (h)));\n  return r;\n}\n\n/* Issue NBD_OPT_INFO and wait for the reply. */\nint\nnbd_unlocked_opt_info (struct nbd_handle *h)\n{\n  int err;\n  nbd_completion_callback c = { .callback = go_complete, .user_data = &err };\n""}]",Trigger Chain:\n1. Server disconnects during NBD_OPT_GO negotiation (commit message)\n2. State transitions to DEAD (lib/opt.c:91 assertion check)\n3. Assertion `nbd_internal_is_state_negotiating(get_next_state(h))` in nbd_unlocked_opt_go (lib/opt.c:91) fails because DEAD is not allowed\n4. Denial of service occurs via assertion failure\n\nCode Evidence:\n- Assertion in nbd_unlocked_opt_go (lib/opt.c:91) lacks DEAD state check\n- Patch for NBD_OPT_INFO (lib/opt.c:106-108) adds DEAD check but not for NBD_OPT_GO,0.95,./gitlab/other_context/CVE-2021-20286
2,CVE-2015-6569,"CWE-362, CWE-476",java,Race condition in the LoadBalancer module in the Atlassian Floodlight Controller before 1.2 allows remote attackers to cause a denial of service (NULL pointer dereference and thread crash) via a state manipulation attack.,https://github.com/floodlight/floodlight/commit/7f5bedb625eec3ff4d29987c31cef2553a962b36,fix data races bug in LoadBalancer module,2,"[{""func_name"": ""processPacketIn"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx) {\n        \n        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);\n        IPacket pkt = eth.getPayload(); \n \n        if (eth.isBroadcast() || eth.isMulticast()) {\n            // handle ARP for VIP\n            if (pkt instanceof ARP) {\n                // retrieve arp to determine target IP address                                                       \n                ARP arpRequest = (ARP) eth.getPayload();\n\n                IPv4Address targetProtocolAddress = arpRequest.getTargetProtocolAddress();\n\n                if (vipIpToId.containsKey(targetProtocolAddress.getInt())) {\n                    String vipId = vipIpToId.get(targetProtocolAddress.getInt());\n                    vipProxyArpReply(sw, pi, cntx, vipId);\n                    return Command.STOP;\n                }\n            }\n        } else {\n            // currently only load balance IPv4 packets - no-op for other traffic \n            if (pkt instanceof IPv4) {\n                IPv4 ip_pkt = (IPv4) pkt;\n                \n                // If match Vip and port, check pool and choose member\n                int destIpAddress = ip_pkt.getDestinationAddress().getInt();\n                \n                if (vipIpToId.containsKey(destIpAddress)){\n                    IPClient client = new IPClient();\n                    client.ipAddress = ip_pkt.getSourceAddress();\n                    client.nw_proto = ip_pkt.getProtocol();\n                    if (ip_pkt.getPayload() instanceof TCP) {\n                        TCP tcp_pkt = (TCP) ip_pkt.getPayload();\n                        client.srcPort = tcp_pkt.getSourcePort();\n                        client.targetPort = tcp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof UDP) {\n                        UDP udp_pkt = (UDP) ip_pkt.getPayload();\n                        client.srcPort = udp_pkt.getSourcePort();\n                        client.targetPort = udp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof ICMP) {\n                        client.srcPort = TransportPort.of(8); \n                        client.targetPort = TransportPort.of(0); \n                    }\n                    \n                    LBVip vip = vips.get(vipIpToId.get(destIpAddress));\n                    LBPool pool = pools.get(vip.pickPool(client));\n                    LBMember member = members.get(pool.pickMember(client));\n\n                    // for chosen member, check device manager and find and push routes, in both directions                    \n                    pushBidirectionalVipRoutes(sw, pi, cntx, client, member);\n                   \n                    // packet out based on table rule\n                    pushPacket(pkt, sw, pi.getBufferId(), (pi.getVersion().compareTo(OFVersion.OF_12) < 0) ? pi.getInPort() : pi.getMatch().get(MatchField.IN_PORT), OFPort.TABLE,\n                                cntx, true);\n\n                    return Command.STOP;\n                }\n            }\n        }\n        // bypass non-load-balanced traffic for normal processing (forwarding)\n        return Command.CONTINUE;\n    }"", ""target"": 0}, {""func_name"": ""removePool"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""@Override\n    public int removePool(String poolId) {\n        LBPool pool;\n        if (pools != null) {\n            pool = pools.get(poolId);\n            if (pool.vipId != null)\n                vips.get(pool.vipId).pools.remove(poolId);\n            pools.remove(poolId);\n            return 0;\n        } else {\n            return -1;\n        }\n    }"", ""target"": 0}]","[{""func_name"": ""processPacketIn"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx) {\n        \n        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);\n        IPacket pkt = eth.getPayload(); \n \n        if (eth.isBroadcast() || eth.isMulticast()) {\n            // handle ARP for VIP\n            if (pkt instanceof ARP) {\n                // retrieve arp to determine target IP address                                                       \n                ARP arpRequest = (ARP) eth.getPayload();\n\n                IPv4Address targetProtocolAddress = arpRequest.getTargetProtocolAddress();\n\n                if (vipIpToId.containsKey(targetProtocolAddress.getInt())) {\n                    String vipId = vipIpToId.get(targetProtocolAddress.getInt());\n                    vipProxyArpReply(sw, pi, cntx, vipId);\n                    return Command.STOP;\n                }\n            }\n        } else {\n            // currently only load balance IPv4 packets - no-op for other traffic \n            if (pkt instanceof IPv4) {\n                IPv4 ip_pkt = (IPv4) pkt;\n                \n                // If match Vip and port, check pool and choose member\n                int destIpAddress = ip_pkt.getDestinationAddress().getInt();\n                \n                if (vipIpToId.containsKey(destIpAddress)){\n                    IPClient client = new IPClient();\n                    client.ipAddress = ip_pkt.getSourceAddress();\n                    client.nw_proto = ip_pkt.getProtocol();\n                    if (ip_pkt.getPayload() instanceof TCP) {\n                        TCP tcp_pkt = (TCP) ip_pkt.getPayload();\n                        client.srcPort = tcp_pkt.getSourcePort();\n                        client.targetPort = tcp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof UDP) {\n                        UDP udp_pkt = (UDP) ip_pkt.getPayload();\n                        client.srcPort = udp_pkt.getSourcePort();\n                        client.targetPort = udp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof ICMP) {\n                        client.srcPort = TransportPort.of(8); \n                        client.targetPort = TransportPort.of(0); \n                    }\n                    \n                    LBVip vip = vips.get(vipIpToId.get(destIpAddress));\n                    if (vip == null)\t\t\t// fix deference violations           \n                    \treturn Command.CONTINUE;\n                    LBPool pool = pools.get(vip.pickPool(client));\n                    if (pool == null)\t\t\t// fix deference violations\n                    \treturn Command.CONTINUE;\n                    LBMember member = members.get(pool.pickMember(client));\n                    if(member == null)\t\t\t//fix deference violations\n                    \treturn Command.CONTINUE;\n                    \n                    // for chosen member, check device manager and find and push routes, in both directions                    \n                    pushBidirectionalVipRoutes(sw, pi, cntx, client, member);\n                   \n                    // packet out based on table rule\n                    pushPacket(pkt, sw, pi.getBufferId(), (pi.getVersion().compareTo(OFVersion.OF_12) < 0) ? pi.getInPort() : pi.getMatch().get(MatchField.IN_PORT), OFPort.TABLE,\n                                cntx, true);\n\n                    return Command.STOP;\n                }\n            }\n        }\n        // bypass non-load-balanced traffic for normal processing (forwarding)\n        return Command.CONTINUE;\n    }""}, {""func_name"": ""removePool"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""@Override\n    public int removePool(String poolId) {\n        LBPool pool;\n        if (pools != null) {\n            pool = pools.get(poolId);\n            if (pool == null)\t// fix deference violations\n            \treturn -1;\n            if (pool.vipId != null)\n                vips.get(pool.vipId).pools.remove(poolId);\n            pools.remove(poolId);\n            return 0;\n        } else {\n            return -1;\n        }\n    }""}]","{""code"": 3, ""value"": 3, ""caller"": 1}","[{""source"": ""code_info(file:LoadBalancer.java, lines:100-150)"", ""result"": ""    protected IFloodlightProviderService floodlightProviderService;\n    protected IRestApiService restApiService;\n    \n    protected IDebugCounterService debugCounterService;\n    private IDebugCounter counterPacketOut;\n    protected IDeviceService deviceManagerService;\n    protected IRoutingService routingEngineService;\n    protected ITopologyService topologyService;\n    protected IStaticFlowEntryPusherService sfpService;\n    protected IOFSwitchService switchService;\n    \n    protected HashMap<String, LBVip> vips;\n    protected HashMap<String, LBPool> pools;\n    protected HashMap<String, LBMember> members;\n    protected HashMap<Integer, String> vipIpToId;\n    protected HashMap<Integer, MacAddress> vipIpToMac;\n    protected HashMap<Integer, String> memberIpToId;\n    protected HashMap<IPClient, LBMember> clientToMember;\n    \n    //Copied from Forwarding with message damper routine for pushing proxy Arp \n    protected static int OFMESSAGE_DAMPER_CAPACITY = 10000; // ms. \n    protected static int OFMESSAGE_DAMPER_TIMEOUT = 250; // ms \n    protected static String LB_ETHER_TYPE = \""0x800\"";\n    protected static int LB_PRIORITY = 32768;\n    \n    // Comparator for sorting by SwitchCluster\n    public Comparator<SwitchPort> clusterIdComparator =\n            new Comparator<SwitchPort>() {\n                @Override\n                public int compare(SwitchPort d1, SwitchPort d2) {\n                    DatapathId d1ClusterId = topologyService.getL2DomainId(d1.getSwitchDPID());\n                    DatapathId d2ClusterId = topologyService.getL2DomainId(d2.getSwitchDPID());\n                    return d1ClusterId.compareTo(d2ClusterId);\n                }\n            };\n\n    // data structure for storing connected\n    public class IPClient {\n        IPv4Address ipAddress;\n        IpProtocol nw_proto;\n        TransportPort srcPort; // tcp/udp src port. icmp type (OFMatch convention)\n        TransportPort targetPort; // tcp/udp dst port, icmp code (OFMatch convention)\n        \n        public IPClient() {\n            ipAddress = IPv4Address.NONE;\n            nw_proto = IpProtocol.NONE;\n            srcPort = TransportPort.NONE;\n            targetPort = TransportPort.NONE;\n        }\n    }\n    \n    @Override\n""}, {""source"": ""value_info(file:LoadBalancer.java, value:vips)"", ""result"": {""value_trace"": [{""full_code"": ""this.vips = new HashMap<String, LBVip>()"", ""line"": 810, ""func_name"": ""net.floodlightcontroller.loadbalancer.LoadBalancer.init:void(net.floodlightcontroller.core.module.FloodlightModuleContext)""}], ""struct_var"": ""vips"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:LoadBalancer.java, value:pools)"", ""result"": {""value_trace"": [{""full_code"": ""this.pools = new HashMap<String, LBPool>()"", ""line"": 811, ""func_name"": ""net.floodlightcontroller.loadbalancer.LoadBalancer.init:void(net.floodlightcontroller.core.module.FloodlightModuleContext)""}], ""struct_var"": ""pools"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:LoadBalancer.java, value:members)"", ""result"": {""value_trace"": [{""full_code"": ""this.members = new HashMap<String, LBMember>()"", ""line"": 812, ""func_name"": ""net.floodlightcontroller.loadbalancer.LoadBalancer.init:void(net.floodlightcontroller.core.module.FloodlightModuleContext)""}], ""struct_var"": ""members"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:LoadBalancer.java, lines:800-820)"", ""result"": ""                                                 throws FloodlightModuleException {\n        floodlightProviderService = context.getServiceImpl(IFloodlightProviderService.class);\n        restApiService = context.getServiceImpl(IRestApiService.class);\n        debugCounterService = context.getServiceImpl(IDebugCounterService.class);\n        deviceManagerService = context.getServiceImpl(IDeviceService.class);\n        routingEngineService = context.getServiceImpl(IRoutingService.class);\n        topologyService = context.getServiceImpl(ITopologyService.class);\n        sfpService = context.getServiceImpl(IStaticFlowEntryPusherService.class);\n        switchService = context.getServiceImpl(IOFSwitchService.class);\n        \n        vips = new HashMap<String, LBVip>();\n        pools = new HashMap<String, LBPool>();\n        members = new HashMap<String, LBMember>();\n        vipIpToId = new HashMap<Integer, String>();\n        vipIpToMac = new HashMap<Integer, MacAddress>();\n        memberIpToId = new HashMap<Integer, String>();\n    }\n\n    @Override\n    public void startUp(FloodlightModuleContext context) {\n        floodlightProviderService.addOFMessageListener(OFType.PACKET_IN, this);\n        restApiService.addRestletRoutable(new LoadBalancerWebRoutable());\n""}, {""source"": ""caller_info(file:LoadBalancer.java, func:processPacketIn)"", ""result"": [{""call_line"": 174, ""call_code"": ""processPacketIn(sw, (OFPacketIn) msg, cntx)"", ""caller_code"": ""    @Override\n    public net.floodlightcontroller.core.IListener.Command\n            receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {\n        switch (msg.getType()) {\n            case PACKET_IN:\n                return processPacketIn(sw, (OFPacketIn)msg, cntx);\n            default:\n                break;\n        }\n        log.warn(\""Received unexpected message {}\"", msg);\n        return Command.CONTINUE;\n    }\n"", ""caller_start"": 169, ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java""}, {""call_line"": 347, ""call_code"": ""processPacketIn(sw, (OFPacketIn) msg, cntx)"", ""caller_code"": ""\t@Override\n\tpublic Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {\n\t\tswitch (msg.getType()) {\n\t\tcase PACKET_IN:\n\t\t\treturn processPacketIn(sw, (OFPacketIn)msg, cntx);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tlog.warn(\""Received unexpected message {}\"", msg);\n\t\treturn Command.CONTINUE;\n\t}\n"", ""caller_start"": 343, ""file_path"": ""src/main/java/net/floodlightcontroller/virtualnetwork/VirtualNetworkFilter.java""}]}, {""source"": ""code_info(file:LoadBalancer.java, lines:150-200)"", ""result"": ""    \n    @Override\n    public String getName() {\n        return \""loadbalancer\"";\n    }\n\n    @Override\n    public boolean isCallbackOrderingPrereq(OFType type, String name) {\n        return (type.equals(OFType.PACKET_IN) && \n                (name.equals(\""topology\"") || \n                 name.equals(\""devicemanager\"") ||\n                 name.equals(\""virtualizer\"")));\n    }\n\n    @Override\n    public boolean isCallbackOrderingPostreq(OFType type, String name) {\n        return (type.equals(OFType.PACKET_IN) && name.equals(\""forwarding\""));\n   }\n\n    @Override\n    public net.floodlightcontroller.core.IListener.Command\n            receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {\n        switch (msg.getType()) {\n            case PACKET_IN:\n                return processPacketIn(sw, (OFPacketIn)msg, cntx);\n            default:\n                break;\n        }\n        log.warn(\""Received unexpected message {}\"", msg);\n        return Command.CONTINUE;\n    }\n\n    private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx) {\n        \n        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);\n        IPacket pkt = eth.getPayload(); \n \n        if (eth.isBroadcast() || eth.isMulticast()) {\n            // handle ARP for VIP\n            if (pkt instanceof ARP) {\n                // retrieve arp to determine target IP address                                                       \n                ARP arpRequest = (ARP) eth.getPayload();\n\n                IPv4Address targetProtocolAddress = arpRequest.getTargetProtocolAddress();\n\n                if (vipIpToId.containsKey(targetProtocolAddress.getInt())) {\n                    String vipId = vipIpToId.get(targetProtocolAddress.getInt());\n                    vipProxyArpReply(sw, pi, cntx, vipId);\n                    return Command.STOP;\n                }\n            }\n        } else {\n""}]","Race condition in concurrent access of shared HashMaps (vips, pools, members) in LoadBalancer.java. These collections are initialized as non-thread-safe HashMaps (LoadBalancer.java:810-812) and accessed/modified without synchronization. For example: \n1. `processPacketIn` (LoadBalancer.java:227-233) accesses `vips`, `pools`, and `members` without synchronization. \n2. `removePool` (LoadBalancer.java:90-92) modifies `pools` and `vips` without synchronization. \nConcurrent execution of these functions can lead to NULL dereference when entries are removed during access.",0.95,./github/other_context/CVE-2015-6569
3,CVE-2016-10027,CWE-362,java,"Race condition in the XMPP library in Smack before 4.1.9, when the SecurityMode.required TLS setting has been set, allows man-in-the-middle attackers to bypass TLS protections and trigger use of cleartext for client authentication by stripping the ""starttls"" feature from a server response.",https://github.com/igniterealtime/Smack/commit/a9d5cd4a611f47123f9561bc5a81a4555fe7cb04,Move TLS Required check at the end of connect()\n\nIt was a *very* bad idea to perform the SecurityMode.Required check in\nthe connection's reader thread and not at the end of\nAbstractXMPPConnectin's connect(). :/\n\nThis behavior dates back to 8e750912a765f77a4f178a4f307a8b42c2afb5ae\n\nFixes SMACK-739,2,"[{""func_name"": ""afterFeaturesReceived"", ""file_path"": ""smack-tcp/src/main/java/org/jivesoftware/smack/tcp/XMPPTCPConnection.java"", ""func_code"": ""@Override\n    protected void afterFeaturesReceived() throws SecurityRequiredException, NotConnectedException, InterruptedException {\n        StartTls startTlsFeature = getFeature(StartTls.ELEMENT, StartTls.NAMESPACE);\n        if (startTlsFeature != null) {\n            if (startTlsFeature.required() && config.getSecurityMode() == SecurityMode.disabled) {\n                notifyConnectionError(new SecurityRequiredByServerException());\n                return;\n            }\n\n            if (config.getSecurityMode() != ConnectionConfiguration.SecurityMode.disabled) {\n                sendNonza(new StartTls());\n            }\n        }\n        // If TLS is required but the server doesn't offer it, disconnect\n        // from the server and throw an error. First check if we've already negotiated TLS\n        // and are secure, however (features get parsed a second time after TLS is established).\n        if (!isSecureConnection() && startTlsFeature == null\n                        && getConfiguration().getSecurityMode() == SecurityMode.required) {\n            throw new SecurityRequiredByClientException();\n        }\n\n        if (getSASLAuthentication().authenticationSuccessful()) {\n            // If we have received features after the SASL has been successfully completed, then we\n            // have also *maybe* received, as it is an optional feature, the compression feature\n            // from the server.\n            maybeCompressFeaturesReceived.reportSuccess();\n        }\n    }"", ""target"": 0}, {""func_name"": ""connect"", ""file_path"": ""smack-core/src/main/java/org/jivesoftware/smack/AbstractXMPPConnection.java"", ""func_code"": ""public synchronized AbstractXMPPConnection connect() throws SmackException, IOException, XMPPException, InterruptedException {\n        // Check if not already connected\n        throwAlreadyConnectedExceptionIfAppropriate();\n\n        // Reset the connection state\n        saslAuthentication.init();\n        saslFeatureReceived.init();\n        lastFeaturesReceived.init();\n        streamId = null;\n\n        // Perform the actual connection to the XMPP service\n        connectInternal();\n\n        // Wait with SASL auth until the SASL mechanisms have been received\n        saslFeatureReceived.checkIfSuccessOrWaitOrThrow();\n\n        // Make note of the fact that we're now connected.\n        connected = true;\n        callConnectionConnectedListener();\n\n        return this;\n    }"", ""target"": 0}]","[{""func_name"": ""afterFeaturesReceived"", ""file_path"": ""smack-tcp/src/main/java/org/jivesoftware/smack/tcp/XMPPTCPConnection.java"", ""func_code"": ""@Override\n    protected void afterFeaturesReceived() throws NotConnectedException, InterruptedException {\n        StartTls startTlsFeature = getFeature(StartTls.ELEMENT, StartTls.NAMESPACE);\n        if (startTlsFeature != null) {\n            if (startTlsFeature.required() && config.getSecurityMode() == SecurityMode.disabled) {\n                notifyConnectionError(new SecurityRequiredByServerException());\n                return;\n            }\n\n            if (config.getSecurityMode() != ConnectionConfiguration.SecurityMode.disabled) {\n                sendNonza(new StartTls());\n            }\n        }\n\n        if (getSASLAuthentication().authenticationSuccessful()) {\n            // If we have received features after the SASL has been successfully completed, then we\n            // have also *maybe* received, as it is an optional feature, the compression feature\n            // from the server.\n            maybeCompressFeaturesReceived.reportSuccess();\n        }\n    }""}, {""func_name"": ""connect"", ""file_path"": ""smack-core/src/main/java/org/jivesoftware/smack/AbstractXMPPConnection.java"", ""func_code"": ""public synchronized AbstractXMPPConnection connect() throws SmackException, IOException, XMPPException, InterruptedException {\n        // Check if not already connected\n        throwAlreadyConnectedExceptionIfAppropriate();\n\n        // Reset the connection state\n        saslAuthentication.init();\n        saslFeatureReceived.init();\n        lastFeaturesReceived.init();\n        streamId = null;\n\n        // Perform the actual connection to the XMPP service\n        connectInternal();\n\n        // Wait with SASL auth until the SASL mechanisms have been received\n        saslFeatureReceived.checkIfSuccessOrWaitOrThrow();\n\n        // If TLS is required but the server doesn't offer it, disconnect\n        // from the server and throw an error. First check if we've already negotiated TLS\n        // and are secure, however (features get parsed a second time after TLS is established).\n        if (!isSecureConnection() && getConfiguration().getSecurityMode() == SecurityMode.required) {\n            throw new SecurityRequiredByClientException();\n        }\n\n        // Make note of the fact that we're now connected.\n        connected = true;\n        callConnectionConnectedListener();\n\n        return this;\n    }""}]","{""caller"": 2, ""code"": 5, ""function"": 2}","[{""source"": ""caller_info(file:AbstractXMPPConnection.java, func:connect)"", ""result"": [{""call_line"": 43, ""call_code"": ""connect()"", ""caller_code"": ""    public void testSASLAnonymousLogin() {\n        if (!isTestAnonymousLogin()) return;\n\n        try {\n            XMPPTCPConnection conn1 = createConnection();\n            XMPPTCPConnection conn2 = createConnection();\n            conn1.connect();\n            conn2.connect();\n            try {\n                // Try to login anonymously\n                conn1.loginAnonymously();\n                conn2.loginAnonymously();\n\n                assertNotNull(\""Resource is null\"", StringUtils.parseResource(conn1.getUser()));\n                assertNotNull(\""Resource is null\"", StringUtils.parseResource(conn2.getUser()));\n\n                assertNotNull(\""Username is null\"", StringUtils.parseName(conn1.getUser()));\n                assertNotNull(\""Username is null\"", StringUtils.parseName(conn2.getUser()));\n            }\n            catch (XMPPException e) {\n                fail(e.getMessage());\n            }\n            finally {\n                // Close the connection\n                conn1.disconnect();\n                conn2.disconnect();\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }\n"", ""caller_start"": 37, ""file_path"": ""smack-core/src/integration-test/java/org/jivesoftware/smack/LoginTest.java""}, {""call_line"": 44, ""call_code"": ""connect()"", ""caller_code"": ""    public void testSASLAnonymousLogin() {\n        if (!isTestAnonymousLogin()) return;\n\n        try {\n            XMPPTCPConnection conn1 = createConnection();\n            XMPPTCPConnection conn2 = createConnection();\n            conn1.connect();\n            conn2.connect();\n            try {\n                // Try to login anonymously\n                conn1.loginAnonymously();\n                conn2.loginAnonymously();\n\n                assertNotNull(\""Resource is null\"", StringUtils.parseResource(conn1.getUser()));\n                assertNotNull(\""Resource is null\"", StringUtils.parseResource(conn2.getUser()));\n\n                assertNotNull(\""Username is null\"", StringUtils.parseName(conn1.getUser()));\n                assertNotNull(\""Username is null\"", StringUtils.parseName(conn2.getUser()));\n            }\n            catch (XMPPException e) {\n                fail(e.getMessage());\n            }\n            finally {\n                // Close the connection\n                conn1.disconnect();\n                conn2.disconnect();\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }\n"", ""caller_start"": 37, ""file_path"": ""smack-core/src/integration-test/java/org/jivesoftware/smack/LoginTest.java""}, {""call_line"": 81, ""call_code"": ""connect()"", ""caller_code"": ""    public void testNonSASLAnonymousLogin() {\n        if (!isTestAnonymousLogin()) return;\n\n        try {\n            ConnectionConfiguration config = new ConnectionConfiguration(getHost(), getPort());\n            config.setSASLAuthenticationEnabled(false);\n            XMPPTCPConnection conn1 = new XMPPConnection(config);\n            conn1.connect();\n\n            config = new ConnectionConfiguration(getHost(), getPort());\n            config.setSASLAuthenticationEnabled(false);\n            XMPPTCPConnection conn2 = new XMPPConnection(config);\n            conn2.connect();\n\n            try {\n                // Try to login anonymously\n                conn1.loginAnonymously();\n                conn2.loginAnonymously();\n\n                assertNotNull(\""Resource is null\"", StringUtils.parseResource(conn1.getUser()));\n                assertNotNull(\""Resource is null\"", StringUtils.parseResource(conn2.getUser()));\n\n                assertNotNull(\""Username is null\"", StringUtils.parseName(conn1.getUser()));\n                assertNotNull(\""Username is null\"", StringUtils.parseName(conn2.getUser()));\n            }\n            catch (XMPPException e) {\n                fail(e.getMessage());\n            }\n            // Close the connection\n            conn1.disconnect();\n            conn2.disconnect();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }\n"", ""caller_start"": 74, ""file_path"": ""smack-core/src/integration-test/java/org/jivesoftware/smack/LoginTest.java""}, {""call_line"": 86, ""call_code"": ""connect()"", ""caller_code"": ""    public void testNonSASLAnonymousLogin() {\n        if (!isTestAnonymousLogin()) return;\n\n        try {\n            ConnectionConfiguration config = new ConnectionConfiguration(getHost(), getPort());\n            config.setSASLAuthenticationEnabled(false);\n            XMPPTCPConnection conn1 = new XMPPConnection(config);\n            conn1.connect();\n\n            config = new ConnectionConfiguration(getHost(), getPort());\n            config.setSASLAuthenticationEnabled(false);\n            XMPPTCPConnection conn2 = new XMPPConnection(config);\n            conn2.connect();\n\n            try {\n                // Try to login anonymously\n                conn1.loginAnonymously();\n                conn2.loginAnonymously();\n\n                assertNotNull(\""Resource is null\"", StringUtils.parseResource(conn1.getUser()));\n                assertNotNull(\""Resource is null\"", StringUtils.parseResource(conn2.getUser()));\n\n                assertNotNull(\""Username is null\"", StringUtils.parseName(conn1.getUser()));\n                assertNotNull(\""Username is null\"", StringUtils.parseName(conn2.getUser()));\n            }\n            catch (XMPPException e) {\n                fail(e.getMessage());\n            }\n            // Close the connection\n            conn1.disconnect();\n            conn2.disconnect();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }\n"", ""caller_start"": 74, ""file_path"": ""smack-core/src/integration-test/java/org/jivesoftware/smack/LoginTest.java""}]}, {""source"": ""code_info(file:XMPPTCPConnection.java, lines:1400-1450)"", ""result"": ""                            final long waitStart = System.currentTimeMillis();\n                            synchronized (bundlingAndDeferringStopped) {\n                                while (!bundlingAndDeferringStopped.get() && remainingWait > 0) {\n                                    bundlingAndDeferringStopped.wait(remainingWait);\n                                    remainingWait = bundleAndDeferMillis\n                                                    - (System.currentTimeMillis() - waitStart);\n                                }\n                            }\n                        }\n                    }\n\n                    Stanza packet = null;\n                    if (element instanceof Stanza) {\n                        packet = (Stanza) element;\n                    }\n                    else if (element instanceof Enable) {\n                        // The client needs to add messages to the unacknowledged stanzas queue\n                        // right after it sent 'enabled'. Stanza will be added once\n                        // unacknowledgedStanzas is not null.\n                        unacknowledgedStanzas = new ArrayBlockingQueue<>(QUEUE_SIZE);\n                    }\n                    // Check if the stream element should be put to the unacknowledgedStanza\n                    // queue. Note that we can not do the put() in sendStanzaInternal() and the\n                    // packet order is not stable at this point (sendStanzaInternal() can be\n                    // called concurrently).\n                    if (unacknowledgedStanzas != null && packet != null) {\n                        // If the unacknowledgedStanza queue is nearly full, request an new ack\n                        // from the server in order to drain it\n                        if (unacknowledgedStanzas.size() == 0.8 * XMPPTCPConnection.QUEUE_SIZE) {\n                            writer.write(AckRequest.INSTANCE.toXML().toString());\n                            writer.flush();\n                        }\n                        try {\n                            // It is important the we put the stanza in the unacknowledged stanza\n                            // queue before we put it on the wire\n                            unacknowledgedStanzas.put(packet);\n                        }\n                        catch (InterruptedException e) {\n                            throw new IllegalStateException(e);\n                        }\n                    }\n\n                    CharSequence elementXml = element.toXML();\n                    if (elementXml instanceof XmlStringBuilder) {\n                        ((XmlStringBuilder) elementXml).write(writer);\n                    }\n                    else {\n                        writer.write(elementXml.toString());\n                    }\n\n                    if (queue.isEmpty()) {\n                        writer.flush();\n""}, {""source"": ""code_info(file:XMPPTCPConnection.java, lines:1412-1430)"", ""result"": ""                    if (element instanceof Stanza) {\n                        packet = (Stanza) element;\n                    }\n                    else if (element instanceof Enable) {\n                        // The client needs to add messages to the unacknowledged stanzas queue\n                        // right after it sent 'enabled'. Stanza will be added once\n                        // unacknowledgedStanzas is not null.\n                        unacknowledgedStanzas = new ArrayBlockingQueue<>(QUEUE_SIZE);\n                    }\n                    // Check if the stream element should be put to the unacknowledgedStanza\n                    // queue. Note that we can not do the put() in sendStanzaInternal() and the\n                    // packet order is not stable at this point (sendStanzaInternal() can be\n                    // called concurrently).\n                    if (unacknowledgedStanzas != null && packet != null) {\n                        // If the unacknowledgedStanza queue is nearly full, request an new ack\n                        // from the server in order to drain it\n                        if (unacknowledgedStanzas.size() == 0.8 * XMPPTCPConnection.QUEUE_SIZE) {\n                            writer.write(AckRequest.INSTANCE.toXML().toString());\n                            writer.flush();\n                        }\n""}, {""source"": ""caller_info(file:XMPPTCPConnection.java, func:afterFeaturesReceived)"", ""result"": [{""call_line"": 1408, ""call_code"": ""this.afterFeaturesReceived()"", ""caller_code"": ""    protected final void parseFeatures(XmlPullParser parser) throws Exception {\n        streamFeatures.clear();\n        final int initialDepth = parser.getDepth();\n        while (true) {\n            int eventType = parser.next();\n\n            if (eventType == XmlPullParser.START_TAG && parser.getDepth() == initialDepth + 1) {\n                ExtensionElement streamFeature = null;\n                String name = parser.getName();\n                String namespace = parser.getNamespace();\n                switch (name) {\n                case StartTls.ELEMENT:\n                    streamFeature = PacketParserUtils.parseStartTlsFeature(parser);\n                    break;\n                case Mechanisms.ELEMENT:\n                    streamFeature = new Mechanisms(PacketParserUtils.parseMechanisms(parser));\n                    break;\n                case Bind.ELEMENT:\n                    streamFeature = Bind.Feature.INSTANCE;\n                    break;\n                case Session.ELEMENT:\n                    streamFeature = PacketParserUtils.parseSessionFeature(parser);\n                    break;\n                case Compress.Feature.ELEMENT:\n                    streamFeature = PacketParserUtils.parseCompressionFeature(parser);\n                    break;\n                default:\n                    ExtensionElementProvider<ExtensionElement> provider = ProviderManager.getStreamFeatureProvider(name, namespace);\n                    if (provider != null) {\n                        streamFeature = provider.parse(parser);\n                    }\n                    break;\n                }\n                if (streamFeature != null) {\n                    addStreamFeature(streamFeature);\n                }\n            }\n            else if (eventType == XmlPullParser.END_TAG && parser.getDepth() == initialDepth) {\n                break;\n            }\n        }\n\n        if (hasFeature(Mechanisms.ELEMENT, Mechanisms.NAMESPACE)) {\n            // Only proceed with SASL auth if TLS is disabled or if the server doesn't announce it\n            if (!hasFeature(StartTls.ELEMENT, StartTls.NAMESPACE)\n                            || config.getSecurityMode() == SecurityMode.disabled) {\n                saslFeatureReceived.reportSuccess();\n            }\n        }\n\n        // If the server reported the bind feature then we are that that we did SASL and maybe\n        // STARTTLS. We can then report that the last 'stream:features' have been parsed\n        if (hasFeature(Bind.ELEMENT, Bind.NAMESPACE)) {\n            if (!hasFeature(Compress.Feature.ELEMENT, Compress.NAMESPACE)\n                            || !config.isCompressionEnabled()) {\n                // This was was last features from the server is either it did not contain\n                // compression or if we disabled it\n                lastFeaturesReceived.reportSuccess();\n            }\n        }\n        afterFeaturesReceived();\n    }\n"", ""caller_start"": 1348, ""file_path"": ""smack-core/src/main/java/org/jivesoftware/smack/AbstractXMPPConnection.java""}]}, {""source"": ""code_info(file:AbstractXMPPConnection.java, lines:300-400)"", ""result"": ""        }\n    }\n\n    /**\n     * Get the connection configuration used by this connection.\n     *\n     * @return the connection configuration.\n     */\n    public ConnectionConfiguration getConfiguration() {\n        return config;\n    }\n\n    @SuppressWarnings(\""deprecation\"")\n    @Override\n    public DomainBareJid getServiceName() {\n        return getXMPPServiceDomain();\n    }\n\n    @Override\n    public DomainBareJid getXMPPServiceDomain() {\n        if (xmppServiceDomain != null) {\n            return xmppServiceDomain;\n        }\n        return config.getXMPPServiceDomain();\n    }\n\n    @Override\n    public String getHost() {\n        return host;\n    }\n\n    @Override\n    public int getPort() {\n        return port;\n    }\n\n    @Override\n    public abstract boolean isSecureConnection();\n\n    protected abstract void sendStanzaInternal(Stanza packet) throws NotConnectedException, InterruptedException;\n\n    @Override\n    public abstract void sendNonza(Nonza element) throws NotConnectedException, InterruptedException;\n\n    @Override\n    public abstract boolean isUsingCompression();\n\n    /**\n     * Establishes a connection to the XMPP server. It basically\n     * creates and maintains a connection to the server.\n     * <p>\n     * Listeners will be preserved from a previous connection.\n     * </p>\n     * \n     * @throws XMPPException if an error occurs on the XMPP protocol level.\n     * @throws SmackException if an error occurs somewhere else besides XMPP protocol level.\n     * @throws IOException \n     * @return a reference to this object, to chain <code>connect()</code> with <code>login()</code>.\n     * @throws InterruptedException \n     */\n    public synchronized AbstractXMPPConnection connect() throws SmackException, IOException, XMPPException, InterruptedException {\n        // Check if not already connected\n        throwAlreadyConnectedExceptionIfAppropriate();\n\n        // Reset the connection state\n        saslAuthentication.init();\n        saslFeatureReceived.init();\n        lastFeaturesReceived.init();\n        streamId = null;\n\n        // Perform the actual connection to the XMPP service\n        connectInternal();\n\n        // Wait with SASL auth until the SASL mechanisms have been received\n        saslFeatureReceived.checkIfSuccessOrWaitOrThrow();\n\n        // Make note of the fact that we're now connected.\n        connected = true;\n        callConnectionConnectedListener();\n\n        return this;\n    }\n\n    /**\n     * Abstract method that concrete subclasses of XMPPConnection need to implement to perform their\n     * way of XMPP connection establishment. Implementations are required to perform an automatic\n     * login if the previous connection state was logged (authenticated).\n     * \n     * @throws SmackException\n     * @throws IOException\n     * @throws XMPPException\n     * @throws InterruptedException \n     */\n    protected abstract void connectInternal() throws SmackException, IOException, XMPPException, InterruptedException;\n\n    private String usedUsername, usedPassword;\n\n    /**\n     * The resourcepart used for this connection. May not be the resulting resourcepart if it's null or overridden by the XMPP service.\n     */\n    private Resourcepart usedResource;\n\n""}, {""source"": ""func_info(file:XMPPTCPConnection.java, func:connectInternal)"", ""result"": [{""code"": ""    @Override\n    protected void connectInternal() throws SmackException, IOException, XMPPException, InterruptedException {\n        closingStreamReceived.init();\n        // Establishes the TCP connection to the server and does setup the reader and writer. Throws an exception if\n        // there is an error establishing the connection\n        connectUsingConfiguration();\n\n        // We connected successfully to the servers TCP port\n        initConnection();\n    }\n"", ""start_line"": 879, ""end_line"": 888, ""full_name"": ""org.jivesoftware.smack.tcp.XMPPTCPConnection.connectInternal:void()"", ""file_path"": ""smack-tcp/src/main/java/org/jivesoftware/smack/tcp/XMPPTCPConnection.java""}]}, {""source"": ""code_info(file:XMPPTCPConnection.java, lines:500-600)"", ""result"": ""                packetReader.shutdown();\n        }\n        LOGGER.finer(\""PacketReader has been shut down\"");\n\n        try {\n                socket.close();\n        } catch (Exception e) {\n                LOGGER.log(Level.WARNING, \""shutdown\"", e);\n        }\n\n        setWasAuthenticated();\n        // If we are able to resume the stream, then don't set\n        // connected/authenticated/usingTLS to false since we like behave like we are still\n        // connected (e.g. sendStanza should not throw a NotConnectedException).\n        if (isSmResumptionPossible() && instant) {\n            disconnectedButResumeable = true;\n        } else {\n            disconnectedButResumeable = false;\n            // Reset the stream management session id to null, since if the stream is cleanly closed, i.e. sending a closing\n            // stream tag, there is no longer a stream to resume.\n            smSessionId = null;\n        }\n        authenticated = false;\n        connected = false;\n        usingTLS = false;\n        reader = null;\n        writer = null;\n\n        maybeCompressFeaturesReceived.init();\n        compressSyncPoint.init();\n        smResumedSyncPoint.init();\n        smEnabledSyncPoint.init();\n        initalOpenStreamSend.init();\n    }\n\n    @Override\n    public void sendNonza(Nonza element) throws NotConnectedException, InterruptedException {\n        packetWriter.sendStreamElement(element);\n    }\n\n    @Override\n    protected void sendStanzaInternal(Stanza packet) throws NotConnectedException, InterruptedException {\n        packetWriter.sendStreamElement(packet);\n        if (isSmEnabled()) {\n            for (StanzaFilter requestAckPredicate : requestAckPredicates) {\n                if (requestAckPredicate.accept(packet)) {\n                    requestSmAcknowledgementInternal();\n                    break;\n                }\n            }\n        }\n    }\n\n    private void connectUsingConfiguration() throws ConnectionException, IOException {\n        List<HostAddress> failedAddresses = populateHostAddresses();\n        SocketFactory socketFactory = config.getSocketFactory();\n        ProxyInfo proxyInfo = config.getProxyInfo();\n        int timeout = config.getConnectTimeout();\n        if (socketFactory == null) {\n            socketFactory = SocketFactory.getDefault();\n        }\n        for (HostAddress hostAddress : hostAddresses) {\n            Iterator<InetAddress> inetAddresses = null;\n            String host = hostAddress.getFQDN();\n            int port = hostAddress.getPort();\n            if (proxyInfo == null) {\n                inetAddresses = hostAddress.getInetAddresses().iterator();\n                assert(inetAddresses.hasNext());\n\n                innerloop: while (inetAddresses.hasNext()) {\n                    // Create a *new* Socket before every connection attempt, i.e. connect() call, since Sockets are not\n                    // re-usable after a failed connection attempt. See also SMACK-724.\n                    socket = socketFactory.createSocket();\n\n                    final InetAddress inetAddress = inetAddresses.next();\n                    final String inetAddressAndPort = inetAddress + \"" at port \"" + port;\n                    LOGGER.finer(\""Trying to establish TCP connection to \"" + inetAddressAndPort);\n                    try {\n                        socket.connect(new InetSocketAddress(inetAddress, port), timeout);\n                    } catch (Exception e) {\n                        hostAddress.setException(inetAddress, e);\n                        if (inetAddresses.hasNext()) {\n                            continue innerloop;\n                        } else {\n                            break innerloop;\n                        }\n                    }\n                    LOGGER.finer(\""Established TCP connection to \"" + inetAddressAndPort);\n                    // We found a host to connect to, return here\n                    this.host = host;\n                    this.port = port;\n                    return;\n                }\n                failedAddresses.add(hostAddress);\n            } else {\n                final String hostAndPort = host + \"" at port \"" + port;\n                LOGGER.finer(\""Trying to establish TCP connection via Proxy to \"" + hostAndPort);\n                try {\n                    proxyInfo.getProxySocketConnection().connect(socket, host, port, timeout);\n                } catch (IOException e) {\n                    hostAddress.setException(e);\n                    continue;\n""}, {""source"": ""func_info(file:XMPPTCPConnection.java, func:initConnection)"", ""result"": [{""code"": ""    private void initConnection() throws IOException {\n        boolean isFirstInitialization = packetReader == null || packetWriter == null;\n        compressionHandler = null;\n\n        // Set the reader and writer instance variables\n        initReaderAndWriter();\n\n        if (isFirstInitialization) {\n            packetWriter = new PacketWriter();\n            packetReader = new PacketReader();\n\n            // If debugging is enabled, we should start the thread that will listen for\n            // all packets and then log them.\n            if (config.isDebuggerEnabled()) {\n                addAsyncStanzaListener(debugger.getReaderListener(), null);\n                if (debugger.getWriterListener() != null) {\n                    addPacketSendingListener(debugger.getWriterListener(), null);\n                }\n            }\n        }\n        // Start the packet writer. This will open an XMPP stream to the server\n        packetWriter.init();\n        // Start the packet reader. The startup() method will block until we\n        // get an opening stream packet back from server\n        packetReader.init();\n    }\n"", ""start_line"": 624, ""end_line"": 649, ""full_name"": ""org.jivesoftware.smack.tcp.XMPPTCPConnection.initConnection:void()"", ""file_path"": ""smack-tcp/src/main/java/org/jivesoftware/smack/tcp/XMPPTCPConnection.java""}]}, {""source"": ""code_info(file:XMPPTCPConnection.java, lines:800-900)"", ""result"": ""                throw new IllegalStateException(\""No HostnameVerifier set. Use connectionConfiguration.setHostnameVerifier() to configure.\"");\n        } else if (!verifier.verify(getXMPPServiceDomain().toString(), sslSocket.getSession())) {\n            throw new CertificateException(\""Hostname verification of certificate failed. Certificate does not authenticate \"" + getXMPPServiceDomain());\n        }\n\n        // Set that TLS was successful\n        usingTLS = true;\n    }\n\n    /**\n     * Returns the compression handler that can be used for one compression methods offered by the server.\n     * \n     * @return a instance of XMPPInputOutputStream or null if no suitable instance was found\n     * \n     */\n    private static XMPPInputOutputStream maybeGetCompressionHandler(Compress.Feature compression) {\n        for (XMPPInputOutputStream handler : SmackConfiguration.getCompresionHandlers()) {\n                String method = handler.getCompressionMethod();\n                if (compression.getMethods().contains(method))\n                    return handler;\n        }\n        return null;\n    }\n\n    @Override\n    public boolean isUsingCompression() {\n        return compressionHandler != null && compressSyncPoint.wasSuccessful();\n    }\n\n    /**\n     * <p>\n     * Starts using stream compression that will compress network traffic. Traffic can be\n     * reduced up to 90%. Therefore, stream compression is ideal when using a slow speed network\n     * connection. However, the server and the client will need to use more CPU time in order to\n     * un/compress network data so under high load the server performance might be affected.\n     * </p>\n     * <p>\n     * Stream compression has to have been previously offered by the server. Currently only the\n     * zlib method is supported by the client. Stream compression negotiation has to be done\n     * before authentication took place.\n     * </p>\n     *\n     * @throws NotConnectedException \n     * @throws SmackException\n     * @throws NoResponseException \n     * @throws InterruptedException \n     */\n    private void maybeEnableCompression() throws NotConnectedException, NoResponseException, SmackException, InterruptedException {\n        if (!config.isCompressionEnabled()) {\n            return;\n        }\n        maybeCompressFeaturesReceived.checkIfSuccessOrWait();\n        Compress.Feature compression = getFeature(Compress.Feature.ELEMENT, Compress.NAMESPACE);\n        if (compression == null) {\n            // Server does not support compression\n            return;\n        }\n        // If stream compression was offered by the server and we want to use\n        // compression then send compression request to the server\n        if ((compressionHandler = maybeGetCompressionHandler(compression)) != null) {\n            compressSyncPoint.sendAndWaitForResponseOrThrow(new Compress(compressionHandler.getCompressionMethod()));\n        } else {\n            LOGGER.warning(\""Could not enable compression because no matching handler/method pair was found\"");\n        }\n    }\n\n    /**\n     * Establishes a connection to the XMPP server. It basically\n     * creates and maintains a socket connection to the server.\n     * <p>\n     * Listeners will be preserved from a previous connection if the reconnection\n     * occurs after an abrupt termination.\n     * </p>\n     *\n     * @throws XMPPException if an error occurs while trying to establish the connection.\n     * @throws SmackException \n     * @throws IOException \n     * @throws InterruptedException \n     */\n    @Override\n    protected void connectInternal() throws SmackException, IOException, XMPPException, InterruptedException {\n        closingStreamReceived.init();\n        // Establishes the TCP connection to the server and does setup the reader and writer. Throws an exception if\n        // there is an error establishing the connection\n        connectUsingConfiguration();\n\n        // We connected successfully to the servers TCP port\n        initConnection();\n    }\n\n    /**\n     * Sends out a notification that there was an error with the connection\n     * and closes the connection. Also prints the stack trace of the given exception\n     *\n     * @param e the exception that causes the connection close event.\n     */\n    private synchronized void notifyConnectionError(Exception e) {\n        // Listeners were already notified of the exception, return right here.\n        if ((packetReader == null || packetReader.done) &&\n                (packetWriter == null || packetWriter.done())) return;\n\n        // Closes the connection temporary. A reconnection is possible\n""}]","Original TLS check in XMPPTCPConnection.afterFeaturesReceived (smack-tcp/src/main/java/org/jivesoftware/smack/tcp/XMPPTCPConnection.java:1412-1422) occurred during stream feature parsing in parseFeatures (AbstractXMPPConnection.java:1408), which is invoked during XMPPTCPConnection.connectInternal() (AbstractXMPPConnection.java:374-381). The fix moves the check to AbstractXMPPConnection.connect() after SASL completion (AbstractXMPPConnection.java:374-381), ensuring TLS validation occurs after SASL and closing the race window.",0.95,./github/other_context/CVE-2016-10027
4,CVE-2017-12670,"CWE-20, CWE-617",c_cpp,"In ImageMagick 7.0.6-3, missing validation was found in coders/mat.c, leading to an assertion failure in the function DestroyImage in MagickCore/image.c, which allows attackers to cause a denial of service.",https://github.com/ImageMagick/ImageMagick/commit/ab440f9ea11e0dbefb7a808cbb9441198758b0cb,https://github.com/ImageMagick/ImageMagick/issues/610,1,"[{""func_name"": ""ReadMATImage"", ""file_path"": ""coders/mat.c"", ""func_code"": ""static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\""enter\"");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  if (strncmp(MATLAB_HDR.identific,\""MATLAB\"",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""  Endian %c%c\"",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \""IM\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \""MI\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \""MATLAB\"", 6))\n    {\nMATLAB_KO:\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\""pos=%X\\n\"",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n         break;\n      default: ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""MATLAB_HDR.StructureClass %d\"",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\""UnsupportedCellTypeInTheMatrix\"");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \""MATLAB_HDR.CellType: %.20g\"",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\""quantum:format\"",\""floating-point\"");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\""quantum:format\"",\""floating-point\"");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \""IncompatibleSizeOfDouble\"");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \""UnsupportedCellTypeInTheMatrix\"");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  MAT set image pixels returns unexpected NULL on a row %u.\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \""  MAT cannot read scanrow %u from a file.\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  MAT failed to ImportQuantumPixels for a row %u\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""  MAT failed to sync image pixels for a row %u\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""return\"");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  return (image);\n}"", ""target"": 0}]","[{""func_name"": ""ReadMATImage"", ""file_path"": ""coders/mat.c"", ""func_code"": ""static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\""enter\"");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  if (strncmp(MATLAB_HDR.identific,\""MATLAB\"",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""  Endian %c%c\"",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \""IM\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \""MI\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \""MATLAB\"", 6))\n    {\nMATLAB_KO:\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\""pos=%X\\n\"",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n         break;\n      default: ThrowReaderException(CoderError, \""MultidimensionalMatricesAreNotSupported\"");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \""MATLAB_HDR.StructureClass %d\"",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\""UnsupportedCellTypeInTheMatrix\"");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \""MATLAB_HDR.CellType: %.20g\"",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\""quantum:format\"",\""floating-point\"");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\""quantum:format\"",\""floating-point\"");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \""IncompatibleSizeOfDouble\"");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \""UnsupportedCellTypeInTheMatrix\"");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  MAT set image pixels returns unexpected NULL on a row %u.\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \""  MAT cannot read scanrow %u from a file.\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \""  MAT failed to ImportQuantumPixels for a row %u\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \""  MAT failed to sync image pixels for a row %u\"", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""return\"");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}""}]","{""code"": 4, ""value"": 3, ""function"": 2}","[{""source"": ""code_info(file:mat.c, lines:1350-1370)"", ""result"": ""    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""return\"");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  return (image);\n}\n""}, {""source"": ""value_info(file:mat.c, value:image2)"", ""result"": {""value_trace"": [{""full_code"": ""*image2=NULL"", ""line"": 851, ""func_name"": ""ReadMATImage""}, {""full_code"": ""image2=ReadMATImageV4(image_info,image,exception)"", ""line"": 906, ""func_name"": ""ReadMATImage""}, {""full_code"": ""image2 = image"", ""line"": 961, ""func_name"": ""ReadMATImage""}, {""full_code"": ""image2=DestroyImage(image2)"", ""line"": 1103, ""func_name"": ""ReadMATImage""}, {""full_code"": ""image2 = NULL"", ""line"": 1247, ""func_name"": ""ReadMATImage""}], ""struct_var"": ""image2"", ""struct_type"": ""Image*"", ""struct_definition"": ""Magick.Image.Image:ANY(void)\n\nMagick.Image.Image:ANY(Magick.Blob&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t,std.string&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,std.string&)\n\nMagick.Image.Image:ANY(Magick.Geometry&,Magick.Color&)\n\nMagick.Image.Image:ANY(Magick.Image&)\n\nMagick.Image.Image:ANY(Magick.Image&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(size_t,size_t,std.string&,StorageType,void*)\n\nMagick.Image.Image:ANY(std.string&)\n\nMagick.Image.Image:ANY(MagickCore.Image*)\n\nclass Image\n\nclass MagickPPExport Image\n\nclass MagickPPExport Image\n  {\n  public:\n\n    // Obtain image statistics. Statistics are normalized to the range\n    // of 0.0 to 1.0 and are output to the specified ImageStatistics\n    // structure.\n    typedef struct _ImageChannelStatistics\n    {\n      /* Minimum value observed */\n      double maximum;\n      /* Maximum value observed */\n      double minimum;\n      /* Average (mean) value observed */\n      double mean;\n      /* Standard deviation, sqrt(variance) */\n      double standard_deviation;\n      /* Variance */\n      double variance;\n      /* Kurtosis */\n      double kurtosis;\n      /* Skewness */\n      double skewness;\n    } ImageChannelStatistics;\n\n    typedef struct _ImageStatistics\n    {\n      ImageChannelStatistics red;\n      ImageChannelStatistics green;\n      ImageChannelStatistics blue;\n      ImageChannelStatistics opacity;\n    } ImageStatistics;\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n  ...\n\nfriend class Image\n\nclass Image\n\nfriend class Image\n\ntypedef struct _Image Image;""}}, {""source"": ""code_info(file:mat.c, lines:800-950)"", ""result"": ""    /*\n      Allocate next image structure.\n    */\n    AcquireNextImage(image_info,image);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A T L A B i m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMATImage() reads an MAT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMATImage method is:\n%\n%      Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadMATImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\""enter\"");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  if (strncmp(MATLAB_HDR.identific,\""MATLAB\"",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\""  Endian %c%c\"",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \""IM\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \""MI\"", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \""MATLAB\"", 6))\n    {\nMATLAB_KO:\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\""pos=%X\\n\"",TellBlob(image)); */\n\n""}, {""source"": ""value_info(file:mat.c, value:image)"", ""result"": {""value_trace"": [{""full_code"": ""image=DestroyImage(image)"", ""line"": 785, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=rotate_image"", ""line"": 786, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=DestroyImageList(image)"", ""line"": 806, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=SyncNextImageInList(image)"", ""line"": 809, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image = AcquireImage(image_info)"", ""line"": 890, ""func_name"": ""ReadMATImage""}], ""struct_var"": ""image"", ""struct_type"": ""Image*"", ""struct_definition"": ""Magick.Image.Image:ANY(void)\n\nMagick.Image.Image:ANY(Magick.Blob&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t,std.string&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,std.string&)\n\nMagick.Image.Image:ANY(Magick.Geometry&,Magick.Color&)\n\nMagick.Image.Image:ANY(Magick.Image&)\n\nMagick.Image.Image:ANY(Magick.Image&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(size_t,size_t,std.string&,StorageType,void*)\n\nMagick.Image.Image:ANY(std.string&)\n\nMagick.Image.Image:ANY(MagickCore.Image*)\n\nclass Image\n\nclass MagickPPExport Image\n\nclass MagickPPExport Image\n  {\n  public:\n\n    // Obtain image statistics. Statistics are normalized to the range\n    // of 0.0 to 1.0 and are output to the specified ImageStatistics\n    // structure.\n    typedef struct _ImageChannelStatistics\n    {\n      /* Minimum value observed */\n      double maximum;\n      /* Maximum value observed */\n      double minimum;\n      /* Average (mean) value observed */\n      double mean;\n      /* Standard deviation, sqrt(variance) */\n      double standard_deviation;\n      /* Variance */\n      double variance;\n      /* Kurtosis */\n      double kurtosis;\n      /* Skewness */\n      double skewness;\n    } ImageChannelStatistics;\n\n    typedef struct _ImageStatistics\n    {\n      ImageChannelStatistics red;\n      ImageChannelStatistics green;\n      ImageChannelStatistics blue;\n      ImageChannelStatistics opacity;\n    } ImageStatistics;\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n  ...\n\nfriend class Image\n\nclass Image\n\nfriend class Image\n\ntypedef struct _Image Image;""}}, {""source"": ""func_info(file:mat.c, func:ReadMATImageV4)"", ""result"": [{""code"": ""static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotate_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n      Object parser.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      break;\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n   ..."", ""start_line"": 592, ""end_line"": 817, ""full_name"": ""ReadMATImageV4"", ""file_path"": ""coders/mat.c""}]}, {""source"": ""code_info(file:mat.c, lines:750-850)"", ""result"": ""        exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(q,image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(unsigned char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow((double *) pixels,y,image,0,0);\n        else\n          InsertComplexFloatRow((float *) pixels,y,image,0,0);\n      }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\n    AcquireNextImage(image_info,image);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d M A T L A B i m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMATImage() reads an MAT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadMATImage method is:\n%\n%      Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadMATImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n""}, {""source"": ""value_info(file:mat.c, value:image)"", ""result"": {""value_trace"": [{""full_code"": ""image=DestroyImage(image)"", ""line"": 785, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=rotate_image"", ""line"": 786, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=DestroyImageList(image)"", ""line"": 806, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image=SyncNextImageInList(image)"", ""line"": 809, ""func_name"": ""ReadMATImageV4""}, {""full_code"": ""image = AcquireImage(image_info)"", ""line"": 890, ""func_name"": ""ReadMATImage""}], ""struct_var"": ""image"", ""struct_type"": ""Image*"", ""struct_definition"": ""Magick.Image.Image:ANY(void)\n\nMagick.Image.Image:ANY(Magick.Blob&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,size_t,std.string&)\n\nMagick.Image.Image:ANY(Magick.Blob&,Magick.Geometry&,std.string&)\n\nMagick.Image.Image:ANY(Magick.Geometry&,Magick.Color&)\n\nMagick.Image.Image:ANY(Magick.Image&)\n\nMagick.Image.Image:ANY(Magick.Image&,Magick.Geometry&)\n\nMagick.Image.Image:ANY(size_t,size_t,std.string&,StorageType,void*)\n\nMagick.Image.Image:ANY(std.string&)\n\nMagick.Image.Image:ANY(MagickCore.Image*)\n\nclass Image\n\nclass MagickPPExport Image\n\nclass MagickPPExport Image\n  {\n  public:\n\n    // Obtain image statistics. Statistics are normalized to the range\n    // of 0.0 to 1.0 and are output to the specified ImageStatistics\n    // structure.\n    typedef struct _ImageChannelStatistics\n    {\n      /* Minimum value observed */\n      double maximum;\n      /* Maximum value observed */\n      double minimum;\n      /* Average (mean) value observed */\n      double mean;\n      /* Standard deviation, sqrt(variance) */\n      double standard_deviation;\n      /* Variance */\n      double variance;\n      /* Kurtosis */\n      double kurtosis;\n      /* Skewness */\n      double skewness;\n    } ImageChannelStatistics;\n\n    typedef struct _ImageStatistics\n    {\n      ImageChannelStatistics red;\n      ImageChannelStatistics green;\n      ImageChannelStatistics blue;\n      ImageChannelStatistics opacity;\n    } ImageStatistics;\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n  ...\n\nfriend class Image\n\nclass Image\n\nfriend class Image\n\ntypedef struct _Image Image;""}}, {""source"": ""code_info(file:mat.c, lines:700-750)"", ""result"": ""    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      return((Image *) NULL);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return((Image *) NULL);\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register PixelPacket\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(unsigned char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (PixelPacket *) NULL)\n""}, {""source"": ""func_info(file:mat.c, func:ReadMATImageV4)"", ""result"": [{""code"": ""static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotate_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n      Object parser.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      break;\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n   ..."", ""start_line"": 592, ""end_line"": 817, ""full_name"": ""ReadMATImageV4"", ""file_path"": ""coders/mat.c""}]}]","In `coders/mat.c:1364-1369`, `image2` is destroyed unconditionally before checking if `image` is NULL. If `image` becomes NULL (e.g., due to an error in `ReadMATImageV4`), `DestroyImage(image2)` may be called on an invalid or already-freed resource, triggering an assertion in `DestroyImage`. The patch moves the destruction of `image2` under an `else` block tied to `image != NULL`, ensuring it is only destroyed when `image` is valid. The root cause is the missing validation of `image` before destroying `image2`.",0.95,./github/other_context/CVE-2017-12670
5,CVE-2017-12995,CWE-835,c_cpp,The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().,https://github.com/the-tcpdump-group/tcpdump/commit/3a76fd7c95fced2c2f8c8148a9055c3a542eff29,"CVE-2017-12995/Check for DNS compression pointers that don't point backwards.\n\nThis is what BIND 9.11.0-P2 does; it not only detects pointers that\nloop, as ""point backwards"" means ""point before anything we've processed\nso far, including what we're processing right now"", so the pointer can't\npoint to itself (as that's what we're processing right now).\n\nThis fixes an infinite loop discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levomki.\n\nAdd a test using the capture file supplied by the reporter(s).\n\nAlso, add some infinite-pointer-loop captures.\n\nMore checks should be done.  We might, for example, want to make sure\nthe upper 2 bits of the label length/pointer byte are 00 or 11, and that\nif we encounter a pointer and jump backwards to what we think is a label\nthe label ends before the beginning of the last label we processed, to\nmake sure the pointer doesn't point backwards into the *middle* of a\nlabel, and also make sure the entire name is <= 255 bytes long.",1,"[{""func_name"": ""ns_nprint"", ""file_path"": ""print-domain.c"", ""func_code"": ""const u_char *\nns_nprint(netdissect_options *ndo,\n          register const u_char *cp, register const u_char *bp)\n{\n\tregister u_int i, l;\n\tregister const u_char *rp = NULL;\n\tregister int compress = 0;\n\tint chars_processed;\n\tint elt;\n\tint data_size = ndo->ndo_snapend - bp;\n\n\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\treturn(NULL);\n\tif (!ND_TTEST2(*cp, 1))\n\t\treturn(NULL);\n\tchars_processed = 1;\n\tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n\t\tcompress = 0;\n\t\trp = cp + l;\n\t}\n\n\tif (i != 0)\n\t\twhile (i && cp < ndo->ndo_snapend) {\n\t\t\tif ((i & INDIR_MASK) == INDIR_MASK) {\n\t\t\t\tif (!compress) {\n\t\t\t\t\trp = cp + 1;\n\t\t\t\t\tcompress = 1;\n\t\t\t\t}\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);\n\t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\t\treturn(NULL);\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\ti = *cp++;\n\t\t\t\tchars_processed++;\n\n\t\t\t\t/*\n\t\t\t\t * If we've looked at every character in\n\t\t\t\t * the message, this pointer will make\n\t\t\t\t * us look at some character again,\n\t\t\t\t * which means we're looping.\n\t\t\t\t */\n\t\t\t\tif (chars_processed >= data_size) {\n\t\t\t\t\tND_PRINT((ndo, \""<LOOP>\""));\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n\t\t\t\telt = (i & ~INDIR_MASK);\n\t\t\t\tswitch(elt) {\n\t\t\t\tcase EDNS0_ELT_BITLABEL:\n\t\t\t\t\tif (blabel_print(ndo, cp) == NULL)\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* unknown ELT */\n\t\t\t\t\tND_PRINT((ndo, \""<ELT %d>\"", elt));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fn_printn(ndo, cp, l, ndo->ndo_snapend))\n\t\t\t\t\treturn(NULL);\n\t\t\t}\n\n\t\t\tcp += l;\n\t\t\tchars_processed += l;\n\t\t\tND_PRINT((ndo, \"".\""));\n\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\treturn(NULL);\n\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\treturn(NULL);\n\t\t\ti = *cp++;\n\t\t\tchars_processed++;\n\t\t\tif (!compress)\n\t\t\t\trp += l + 1;\n\t\t}\n\telse\n\t\tND_PRINT((ndo, \"".\""));\n\treturn (rp);\n}"", ""target"": 0}]","[{""func_name"": ""ns_nprint"", ""file_path"": ""print-domain.c"", ""func_code"": ""const u_char *\nns_nprint(netdissect_options *ndo,\n          register const u_char *cp, register const u_char *bp)\n{\n\tregister u_int i, l;\n\tregister const u_char *rp = NULL;\n\tregister int compress = 0;\n\tint elt;\n\tu_int offset, max_offset;\n\n\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\treturn(NULL);\n\tif (!ND_TTEST2(*cp, 1))\n\t\treturn(NULL);\n\tmax_offset = (u_int)(cp - bp);\n\tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n\t\tcompress = 0;\n\t\trp = cp + l;\n\t}\n\n\tif (i != 0)\n\t\twhile (i && cp < ndo->ndo_snapend) {\n\t\t\tif ((i & INDIR_MASK) == INDIR_MASK) {\n\t\t\t\tif (!compress) {\n\t\t\t\t\trp = cp + 1;\n\t\t\t\t\tcompress = 1;\n\t\t\t\t}\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\toffset = (((i << 8) | *cp) & 0x3fff);\n\t\t\t\t/*\n\t\t\t\t * This must move backwards in the packet.\n\t\t\t\t * No RFC explicitly says that, but BIND's\n\t\t\t\t * name decompression code requires it,\n\t\t\t\t * as a way of preventing infinite loops\n\t\t\t\t * and other bad behavior, and it's probably\n\t\t\t\t * what was intended (compress by pointing\n\t\t\t\t * to domain name suffixes already seen in\n\t\t\t\t * the packet).\n\t\t\t\t */\n\t\t\t\tif (offset >= max_offset) {\n\t\t\t\t\tND_PRINT((ndo, \""<BAD PTR>\""));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t\tmax_offset = offset;\n\t\t\t\tcp = bp + offset;\n\t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\t\treturn(NULL);\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\ti = *cp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n\t\t\t\telt = (i & ~INDIR_MASK);\n\t\t\t\tswitch(elt) {\n\t\t\t\tcase EDNS0_ELT_BITLABEL:\n\t\t\t\t\tif (blabel_print(ndo, cp) == NULL)\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* unknown ELT */\n\t\t\t\t\tND_PRINT((ndo, \""<ELT %d>\"", elt));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fn_printn(ndo, cp, l, ndo->ndo_snapend))\n\t\t\t\t\treturn(NULL);\n\t\t\t}\n\n\t\t\tcp += l;\n\t\t\tND_PRINT((ndo, \"".\""));\n\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\treturn(NULL);\n\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\treturn(NULL);\n\t\t\ti = *cp++;\n\t\t\tif (!compress)\n\t\t\t\trp += l + 1;\n\t\t}\n\telse\n\t\tND_PRINT((ndo, \"".\""));\n\treturn (rp);\n}""}]","{""function"": 1, ""code"": 1, ""value"": 2}","[{""source"": ""func_info(file:print-domain.c, func:labellen)"", ""result"": [{""code"": ""static int\nlabellen(netdissect_options *ndo,\n         const u_char *cp)\n{\n\tregister u_int i;\n\n\tif (!ND_TTEST2(*cp, 1))\n\t\treturn(-1);\n\ti = *cp;\n\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n\t\tint bitlen, elt;\n\t\tif ((elt = (i & ~INDIR_MASK)) != EDNS0_ELT_BITLABEL) {\n\t\t\tND_PRINT((ndo, \""<ELT %d>\"", elt));\n\t\t\treturn(-1);\n\t\t}\n\t\tif (!ND_TTEST2(*(cp + 1), 1))\n\t\t\treturn(-1);\n\t\tif ((bitlen = *(cp + 1)) == 0)\n\t\t\tbitlen = 256;\n\t\treturn(((bitlen + 7) / 8) + 1);\n\t} else\n\t\treturn(i);\n}"", ""start_line"": 123, ""end_line"": 145, ""full_name"": ""labellen"", ""file_path"": ""print-domain.c""}]}, {""source"": ""code_info(file:print-domain.c, lines:145-155)"", ""result"": ""}\n\nconst u_char *\nns_nprint(netdissect_options *ndo,\n          register const u_char *cp, register const u_char *bp)\n{\n\tregister u_int i, l;\n\tregister const u_char *rp = NULL;\n\tregister int compress = 0;\n\tint chars_processed;\n\tint elt;\n\tint data_size = ndo->ndo_snapend - bp;\n""}, {""source"": ""value_info(file:print-domain.c, value:cp)"", ""result"": {""value_trace"": [{""full_code"": ""cp++"", ""line"": 61, ""func_name"": ""ns_nskip""}, {""full_code"": ""cp++"", ""line"": 72, ""func_name"": ""ns_nskip""}], ""struct_var"": ""cp"", ""struct_type"": ""u_char*"", ""struct_definition"": ""u_char""}}, {""source"": ""value_info(file:print-domain.c, value:bp)"", ""result"": {""value_trace"": [{""full_code"": ""bp += sizeof(*lp)"", ""line"": 112, ""func_name"": ""llap_print""}, {""full_code"": ""bp += ddpSSize"", ""line"": 131, ""func_name"": ""llap_print""}, {""full_code"": ""bp += ddpSize"", ""line"": 153, ""func_name"": ""llap_print""}, {""full_code"": ""bp += ddpSize"", ""line"": 203, ""func_name"": ""atalk_print""}, {""full_code"": ""bp = (const struct bootp *)cp"", ""line"": 290, ""func_name"": ""bootp_print""}], ""struct_var"": ""bp"", ""struct_type"": ""bootp*"", ""struct_definition"": ""struct bootp {\n\tuint8_t\t\tbp_op;\t\t/* packet opcode type */\n\tuint8_t\t\tbp_htype;\t/* hardware addr type */\n\tuint8_t\t\tbp_hlen;\t/* hardware addr length */\n\tuint8_t\t\tbp_hops;\t/* gateway hops */\n\tuint32_t\tbp_xid;\t\t/* transaction ID */\n\tuint16_t\tbp_secs;\t/* seconds since boot began */\n\tuint16_t\tbp_flags;\t/* flags - see bootp_flag_values[]\n\t\t\t\t\t   in print-bootp.c */\n\tstruct in_addr\tbp_ciaddr;\t/* client IP address */\n\tstruct in_addr\tbp_yiaddr;\t/* 'your' IP address */\n\tstruct in_addr\tbp_siaddr;\t/* server IP address */\n\tstruct in_addr\tbp_giaddr;\t/* gateway IP address */\n\tuint8_t\t\tbp_chaddr[16];\t/* client hardware address */\n\tuint8_t\t\tbp_sname[64];\t/* server host name */\n\tuint8_t\t\tbp_file[128];\t/* boot file name */\n\tuint8_t\t\tbp_vend[64];\t/* vendor-specific area */\n}""}}]","print-domain.c: The infinite loop vulnerability stems from improper validation of DNS compression pointers in ns_nprint(). The original logic (lines 175-180) used 'chars_processed' to track processed characters, but this failed to prevent pointers from referencing the middle of labels. The patch (lines 184-186) introduces 'max_offset' to enforce backward-only jumps: each pointer's offset must be strictly less than the previous maximum. When a pointer references an offset  max_offset, it is rejected as '<BAD PTR>'. This replaces the flawed character-count logic, which could be bypassed by overlapping label pointers. The root cause is the absence of position-based bounds checks, allowing malicious DNS packets to create infinite loops by reprocessing overlapping label sections.",0.95,./github/other_context/CVE-2017-12995
6,CVE-2017-14054,CWE-834,c_cpp,"In libavformat/rmdec.c in FFmpeg 3.3.3, a DoS in ivr_read_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted IVR file, which claims a large ""len"" field in the header but does not contain sufficient backing data, is provided, the first type==4 loop would consume huge CPU resources, since there is no EOF check inside the loop.",https://github.com/FFmpeg/FFmpeg/commit/124eb202e70678539544f6268efc98131f19fa49,avformat/rmdec: Fix DoS due to lack of eof check\n\nFixes: loop.ivr\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>,1,"[{""func_name"": ""ivr_read_header"", ""file_path"": ""libavformat/rmdec.c"", ""func_code"": ""static int ivr_read_header(AVFormatContext *s)\n{\n    unsigned tag, type, len, tlen, value;\n    int i, j, n, count, nb_streams = 0, ret;\n    uint8_t key[256], val[256];\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    int64_t pos, offset, temp;\n\n    pos = avio_tell(pb);\n    tag = avio_rl32(pb);\n    if (tag == MKTAG('.','R','1','M')) {\n        if (avio_rb16(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        avio_skip(pb, 5);\n        temp = avio_rb64(pb);\n        while (!avio_feof(pb) && temp) {\n            offset = temp;\n            temp = avio_rb64(pb);\n        }\n        avio_skip(pb, offset - avio_tell(pb));\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        if (avio_r8(pb) != 2)\n            return AVERROR_INVALIDDATA;\n        avio_skip(pb, 16);\n        pos = avio_tell(pb);\n        tag = avio_rl32(pb);\n    }\n\n    if (tag != MKTAG('.','R','E','C'))\n        return AVERROR_INVALIDDATA;\n\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    count = avio_rb32(pb);\n    for (i = 0; i < count; i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        type = avio_r8(pb);\n        tlen = avio_rb32(pb);\n        avio_get_str(pb, tlen, key, sizeof(key));\n        len = avio_rb32(pb);\n        if (type == 5) {\n            avio_get_str(pb, len, val, sizeof(val));\n            av_log(s, AV_LOG_DEBUG, \""%s = '%s'\\n\"", key, val);\n        } else if (type == 4) {\n            av_log(s, AV_LOG_DEBUG, \""%s = '0x\"", key);\n            for (j = 0; j < len; j++)\n                av_log(s, AV_LOG_DEBUG, \""%X\"", avio_r8(pb));\n            av_log(s, AV_LOG_DEBUG, \""'\\n\"");\n        } else if (len == 4 && type == 3 && !strncmp(key, \""StreamCount\"", tlen)) {\n            nb_streams = value = avio_rb32(pb);\n        } else if (len == 4 && type == 3) {\n            value = avio_rb32(pb);\n            av_log(s, AV_LOG_DEBUG, \""%s = %d\\n\"", key, value);\n        } else {\n            av_log(s, AV_LOG_DEBUG, \""Skipping unsupported key: %s\\n\"", key);\n            avio_skip(pb, len);\n        }\n    }\n\n    for (n = 0; n < nb_streams; n++) {\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        st->priv_data = ff_rm_alloc_rmstream();\n        if (!st->priv_data)\n            return AVERROR(ENOMEM);\n\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n\n        count = avio_rb32(pb);\n        for (i = 0; i < count; i++) {\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n\n            type = avio_r8(pb);\n            tlen  = avio_rb32(pb);\n            avio_get_str(pb, tlen, key, sizeof(key));\n            len  = avio_rb32(pb);\n            if (type == 5) {\n                avio_get_str(pb, len, val, sizeof(val));\n                av_log(s, AV_LOG_DEBUG, \""%s = '%s'\\n\"", key, val);\n            } else if (type == 4 && !strncmp(key, \""OpaqueData\"", tlen)) {\n                ret = ffio_ensure_seekback(pb, 4);\n                if (ret < 0)\n                    return ret;\n                if (avio_rb32(pb) == MKBETAG('M', 'L', 'T', 'I')) {\n                    ret = rm_read_multi(s, pb, st, NULL);\n                } else {\n                    avio_seek(pb, -4, SEEK_CUR);\n                    ret = ff_rm_read_mdpr_codecdata(s, pb, st, st->priv_data, len, NULL);\n                }\n\n                if (ret < 0)\n                    return ret;\n            } else if (type == 4) {\n                int j;\n\n                av_log(s, AV_LOG_DEBUG, \""%s = '0x\"", key);\n                for (j = 0; j < len; j++)\n                    av_log(s, AV_LOG_DEBUG, \""%X\"", avio_r8(pb));\n                av_log(s, AV_LOG_DEBUG, \""'\\n\"");\n            } else if (len == 4 && type == 3 && !strncmp(key, \""Duration\"", tlen)) {\n                st->duration = avio_rb32(pb);\n            } else if (len == 4 && type == 3) {\n                value = avio_rb32(pb);\n                av_log(s, AV_LOG_DEBUG, \""%s = %d\\n\"", key, value);\n            } else {\n                av_log(s, AV_LOG_DEBUG, \""Skipping unsupported key: %s\\n\"", key);\n                avio_skip(pb, len);\n            }\n        }\n    }\n\n    if (avio_r8(pb) != 6)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 12);\n    avio_skip(pb, avio_rb64(pb) + pos - avio_tell(s->pb));\n    if (avio_r8(pb) != 8)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 8);\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""ivr_read_header"", ""file_path"": ""libavformat/rmdec.c"", ""func_code"": ""static int ivr_read_header(AVFormatContext *s)\n{\n    unsigned tag, type, len, tlen, value;\n    int i, j, n, count, nb_streams = 0, ret;\n    uint8_t key[256], val[256];\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    int64_t pos, offset, temp;\n\n    pos = avio_tell(pb);\n    tag = avio_rl32(pb);\n    if (tag == MKTAG('.','R','1','M')) {\n        if (avio_rb16(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        avio_skip(pb, 5);\n        temp = avio_rb64(pb);\n        while (!avio_feof(pb) && temp) {\n            offset = temp;\n            temp = avio_rb64(pb);\n        }\n        avio_skip(pb, offset - avio_tell(pb));\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        if (avio_r8(pb) != 2)\n            return AVERROR_INVALIDDATA;\n        avio_skip(pb, 16);\n        pos = avio_tell(pb);\n        tag = avio_rl32(pb);\n    }\n\n    if (tag != MKTAG('.','R','E','C'))\n        return AVERROR_INVALIDDATA;\n\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    count = avio_rb32(pb);\n    for (i = 0; i < count; i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        type = avio_r8(pb);\n        tlen = avio_rb32(pb);\n        avio_get_str(pb, tlen, key, sizeof(key));\n        len = avio_rb32(pb);\n        if (type == 5) {\n            avio_get_str(pb, len, val, sizeof(val));\n            av_log(s, AV_LOG_DEBUG, \""%s = '%s'\\n\"", key, val);\n        } else if (type == 4) {\n            av_log(s, AV_LOG_DEBUG, \""%s = '0x\"", key);\n            for (j = 0; j < len; j++) {\n                if (avio_feof(pb))\n                    return AVERROR_INVALIDDATA;\n                av_log(s, AV_LOG_DEBUG, \""%X\"", avio_r8(pb));\n            }\n            av_log(s, AV_LOG_DEBUG, \""'\\n\"");\n        } else if (len == 4 && type == 3 && !strncmp(key, \""StreamCount\"", tlen)) {\n            nb_streams = value = avio_rb32(pb);\n        } else if (len == 4 && type == 3) {\n            value = avio_rb32(pb);\n            av_log(s, AV_LOG_DEBUG, \""%s = %d\\n\"", key, value);\n        } else {\n            av_log(s, AV_LOG_DEBUG, \""Skipping unsupported key: %s\\n\"", key);\n            avio_skip(pb, len);\n        }\n    }\n\n    for (n = 0; n < nb_streams; n++) {\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        st->priv_data = ff_rm_alloc_rmstream();\n        if (!st->priv_data)\n            return AVERROR(ENOMEM);\n\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n\n        count = avio_rb32(pb);\n        for (i = 0; i < count; i++) {\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n\n            type = avio_r8(pb);\n            tlen  = avio_rb32(pb);\n            avio_get_str(pb, tlen, key, sizeof(key));\n            len  = avio_rb32(pb);\n            if (type == 5) {\n                avio_get_str(pb, len, val, sizeof(val));\n                av_log(s, AV_LOG_DEBUG, \""%s = '%s'\\n\"", key, val);\n            } else if (type == 4 && !strncmp(key, \""OpaqueData\"", tlen)) {\n                ret = ffio_ensure_seekback(pb, 4);\n                if (ret < 0)\n                    return ret;\n                if (avio_rb32(pb) == MKBETAG('M', 'L', 'T', 'I')) {\n                    ret = rm_read_multi(s, pb, st, NULL);\n                } else {\n                    avio_seek(pb, -4, SEEK_CUR);\n                    ret = ff_rm_read_mdpr_codecdata(s, pb, st, st->priv_data, len, NULL);\n                }\n\n                if (ret < 0)\n                    return ret;\n            } else if (type == 4) {\n                int j;\n\n                av_log(s, AV_LOG_DEBUG, \""%s = '0x\"", key);\n                for (j = 0; j < len; j++)\n                    av_log(s, AV_LOG_DEBUG, \""%X\"", avio_r8(pb));\n                av_log(s, AV_LOG_DEBUG, \""'\\n\"");\n            } else if (len == 4 && type == 3 && !strncmp(key, \""Duration\"", tlen)) {\n                st->duration = avio_rb32(pb);\n            } else if (len == 4 && type == 3) {\n                value = avio_rb32(pb);\n                av_log(s, AV_LOG_DEBUG, \""%s = %d\\n\"", key, value);\n            } else {\n                av_log(s, AV_LOG_DEBUG, \""Skipping unsupported key: %s\\n\"", key);\n                avio_skip(pb, len);\n            }\n        }\n    }\n\n    if (avio_r8(pb) != 6)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 12);\n    avio_skip(pb, avio_rb64(pb) + pos - avio_tell(s->pb));\n    if (avio_r8(pb) != 8)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 8);\n\n    return 0;\n}""}]","{""value"": 1, ""code"": 1, ""function"": 1}","[{""source"": ""value_info(file:rmdec.c, value:len)"", ""result"": {""value_trace"": [{""full_code"": ""len = wide ? avio_rb16(pb) : avio_r8(pb)"", ""line"": 107, ""func_name"": ""rm_read_metadata""}, {""full_code"": ""len= rm->remaining_len"", ""line"": 696, ""func_name"": ""rm_sync""}, {""full_code"": ""len = avio_rb32(pb)"", ""line"": 704, ""func_name"": ""rm_sync""}, {""full_code"": ""len = expected_len"", ""line"": 710, ""func_name"": ""rm_sync""}, {""full_code"": ""len -= 14"", ""line"": 715, ""func_name"": ""rm_sync""}], ""struct_var"": ""len"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""code_info(file:rmdec.c, lines:1200-1250)"", ""result"": ""        if (avio_r8(pb) != 2)\n            return AVERROR_INVALIDDATA;\n        avio_skip(pb, 16);\n        pos = avio_tell(pb);\n        tag = avio_rl32(pb);\n    }\n\n    if (tag != MKTAG('.','R','E','C'))\n        return AVERROR_INVALIDDATA;\n\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    count = avio_rb32(pb);\n    for (i = 0; i < count; i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        type = avio_r8(pb);\n        tlen = avio_rb32(pb);\n        avio_get_str(pb, tlen, key, sizeof(key));\n        len = avio_rb32(pb);\n        if (type == 5) {\n            avio_get_str(pb, len, val, sizeof(val));\n            av_log(s, AV_LOG_DEBUG, \""%s = '%s'\\n\"", key, val);\n        } else if (type == 4) {\n            av_log(s, AV_LOG_DEBUG, \""%s = '0x\"", key);\n            for (j = 0; j < len; j++)\n                av_log(s, AV_LOG_DEBUG, \""%X\"", avio_r8(pb));\n            av_log(s, AV_LOG_DEBUG, \""'\\n\"");\n        } else if (len == 4 && type == 3 && !strncmp(key, \""StreamCount\"", tlen)) {\n            nb_streams = value = avio_rb32(pb);\n        } else if (len == 4 && type == 3) {\n            value = avio_rb32(pb);\n            av_log(s, AV_LOG_DEBUG, \""%s = %d\\n\"", key, value);\n        } else {\n            av_log(s, AV_LOG_DEBUG, \""Skipping unsupported key: %s\\n\"", key);\n            avio_skip(pb, len);\n        }\n    }\n\n    for (n = 0; n < nb_streams; n++) {\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        st->priv_data = ff_rm_alloc_rmstream();\n        if (!st->priv_data)\n            return AVERROR(ENOMEM);\n\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n\n        count = avio_rb32(pb);\n""}, {""source"": ""func_info(file:rmdec.c, func:ivr_read_header)"", ""result"": [{""code"": ""static int ivr_read_header(AVFormatContext *s)\n{\n    unsigned tag, type, len, tlen, value;\n    int i, j, n, count, nb_streams = 0, ret;\n    uint8_t key[256], val[256];\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    int64_t pos, offset, temp;\n\n    pos = avio_tell(pb);\n    tag = avio_rl32(pb);\n    if (tag == MKTAG('.','R','1','M')) {\n        if (avio_rb16(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        avio_skip(pb, 5);\n        temp = avio_rb64(pb);\n        while (!avio_feof(pb) && temp) {\n            offset = temp;\n            temp = avio_rb64(pb);\n        }\n        avio_skip(pb, offset - avio_tell(pb));\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        if (avio_r8(pb) != 2)\n            return AVERROR_INVALIDDATA;\n        avio_skip(pb, 16);\n        pos = avio_te..."", ""start_line"": 1171, ""end_line"": 1304, ""full_name"": ""ivr_read_header"", ""file_path"": ""libavformat/rmdec.c""}]}]","libavformat/rmdec.c:1224-1228 - Loop processes 'len' bytes without EOF check. 'len' is initialized in libavformat/rmdec.c:1224-1250 via 'len = avio_rb32(pb)', directly reading from untrusted input. No EOF validation exists for 'len', allowing attackers to trigger CPU exhaustion.",0.95,./github/other_context/CVE-2017-14054
7,CVE-2017-14059,CWE-834,c_cpp,"In FFmpeg 3.3.3, a DoS in cine_read_header() due to lack of an EOF check might cause huge CPU and memory consumption. When a crafted CINE file, which claims a large ""duration"" field in the header but does not contain sufficient backing data, is provided, the image-offset parsing loop would consume huge CPU and memory resources, since there is no EOF check inside the loop.",https://github.com/FFmpeg/FFmpeg/commit/7e80b63ecd259d69d383623e75b318bf2bd491f6,avformat/cinedec: Fix DoS due to lack of eof check\n\nFixes: loop.cine\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>,1,"[{""func_name"": ""cine_read_header"", ""file_path"": ""libavformat/cinedec.c"", ""func_code"": ""static int cine_read_header(AVFormatContext *avctx)\n{\n    AVIOContext *pb = avctx->pb;\n    AVStream *st;\n    unsigned int version, compression, offImageHeader, offSetup, offImageOffsets, biBitCount, length, CFA;\n    int vflip;\n    char *description;\n    uint64_t i;\n\n    st = avformat_new_stream(avctx, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = AV_CODEC_ID_RAWVIDEO;\n    st->codecpar->codec_tag  = 0;\n\n    /* CINEFILEHEADER structure */\n    avio_skip(pb, 4); // Type, Headersize\n\n    compression = avio_rl16(pb);\n    version     = avio_rl16(pb);\n    if (version != 1) {\n        avpriv_request_sample(avctx, \""unknown version %i\"", version);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 12); // FirstMovieImage, TotalImageCount, FirstImageNumber\n\n    st->duration    = avio_rl32(pb);\n    offImageHeader  = avio_rl32(pb);\n    offSetup        = avio_rl32(pb);\n    offImageOffsets = avio_rl32(pb);\n\n    avio_skip(pb, 8); // TriggerTime\n\n    /* BITMAPINFOHEADER structure */\n    avio_seek(pb, offImageHeader, SEEK_SET);\n    avio_skip(pb, 4); //biSize\n    st->codecpar->width      = avio_rl32(pb);\n    st->codecpar->height     = avio_rl32(pb);\n\n    if (avio_rl16(pb) != 1) // biPlanes\n        return AVERROR_INVALIDDATA;\n\n    biBitCount = avio_rl16(pb);\n    if (biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48) {\n        avpriv_request_sample(avctx, \""unsupported biBitCount %i\"", biBitCount);\n        return AVERROR_INVALIDDATA;\n    }\n\n    switch (avio_rl32(pb)) {\n    case BMP_RGB:\n        vflip = 0;\n        break;\n    case 0x100: /* BI_PACKED */\n        st->codecpar->codec_tag = MKTAG('B', 'I', 'T', 0);\n        vflip = 1;\n        break;\n    default:\n        avpriv_request_sample(avctx, \""unknown bitmap compression\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 4); // biSizeImage\n\n    /* parse SETUP structure */\n    avio_seek(pb, offSetup, SEEK_SET);\n    avio_skip(pb, 140); // FrameRatae16 .. descriptionOld\n    if (avio_rl16(pb) != 0x5453)\n        return AVERROR_INVALIDDATA;\n    length = avio_rl16(pb);\n    if (length < 0x163C) {\n        avpriv_request_sample(avctx, \""short SETUP header\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 616); // Binning .. bFlipH\n    if (!avio_rl32(pb) ^ vflip) {\n        st->codecpar->extradata  = av_strdup(\""BottomUp\"");\n        st->codecpar->extradata_size  = 9;\n    }\n\n    avio_skip(pb, 4); // Grid\n\n    avpriv_set_pts_info(st, 64, 1, avio_rl32(pb));\n\n    avio_skip(pb, 20); // Shutter .. bEnableColor\n\n    set_metadata_int(&st->metadata, \""camera_version\"", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \""firmware_version\"", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \""software_version\"", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \""recording_timezone\"", avio_rl32(pb), 0);\n\n    CFA = avio_rl32(pb);\n\n    set_metadata_int(&st->metadata, \""brightness\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""contrast\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""gamma\"", avio_rl32(pb), 1);\n\n    avio_skip(pb, 12 + 16); // Reserved1 .. AutoExpRect\n    set_metadata_float(&st->metadata, \""wbgain[0].r\"", av_int2float(avio_rl32(pb)), 1);\n    set_metadata_float(&st->metadata, \""wbgain[0].b\"", av_int2float(avio_rl32(pb)), 1);\n    avio_skip(pb, 36); // WBGain[1].. WBView\n\n    st->codecpar->bits_per_coded_sample = avio_rl32(pb);\n\n    if (compression == CC_RGB) {\n        if (biBitCount == 8) {\n            st->codecpar->format = AV_PIX_FMT_GRAY8;\n        } else if (biBitCount == 16) {\n            st->codecpar->format = AV_PIX_FMT_GRAY16LE;\n        } else if (biBitCount == 24) {\n            st->codecpar->format = AV_PIX_FMT_BGR24;\n        } else if (biBitCount == 48) {\n            st->codecpar->format = AV_PIX_FMT_BGR48LE;\n        } else {\n            avpriv_request_sample(avctx, \""unsupported biBitCount %i\"", biBitCount);\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (compression == CC_UNINT) {\n        switch (CFA & 0xFFFFFF) {\n        case CFA_BAYER:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG16LE;\n            } else {\n                avpriv_request_sample(avctx, \""unsupported biBitCount %i\"", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        case CFA_BAYERFLIP:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB16LE;\n            } else {\n                avpriv_request_sample(avctx, \""unsupported biBitCount %i\"", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        default:\n           avpriv_request_sample(avctx, \""unsupported Color Field Array (CFA) %i\"", CFA & 0xFFFFFF);\n            return AVERROR_INVALIDDATA;\n        }\n    } else { //CC_LEAD\n        avpriv_request_sample(avctx, \""unsupported compression %i\"", compression);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 668); // Conv8Min ... Sensor\n\n    set_metadata_int(&st->metadata, \""shutter_ns\"", avio_rl32(pb), 0);\n\n    avio_skip(pb, 24); // EDRShutterNs ... ImHeightAcq\n\n#define DESCRIPTION_SIZE 4096\n    description = av_malloc(DESCRIPTION_SIZE + 1);\n    if (!description)\n        return AVERROR(ENOMEM);\n    i = avio_get_str(pb, DESCRIPTION_SIZE, description, DESCRIPTION_SIZE + 1);\n    if (i < DESCRIPTION_SIZE)\n        avio_skip(pb, DESCRIPTION_SIZE - i);\n    if (description[0])\n        av_dict_set(&st->metadata, \""description\"", description, AV_DICT_DONT_STRDUP_VAL);\n    else\n        av_free(description);\n\n    avio_skip(pb, 1176); // RisingEdge ... cmUser\n\n    set_metadata_int(&st->metadata, \""enable_crop\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""crop_left\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""crop_top\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""crop_right\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""crop_bottom\"", avio_rl32(pb), 1);\n\n    /* parse image offsets */\n    avio_seek(pb, offImageOffsets, SEEK_SET);\n    for (i = 0; i < st->duration; i++)\n        av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME);\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""cine_read_header"", ""file_path"": ""libavformat/cinedec.c"", ""func_code"": ""static int cine_read_header(AVFormatContext *avctx)\n{\n    AVIOContext *pb = avctx->pb;\n    AVStream *st;\n    unsigned int version, compression, offImageHeader, offSetup, offImageOffsets, biBitCount, length, CFA;\n    int vflip;\n    char *description;\n    uint64_t i;\n\n    st = avformat_new_stream(avctx, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = AV_CODEC_ID_RAWVIDEO;\n    st->codecpar->codec_tag  = 0;\n\n    /* CINEFILEHEADER structure */\n    avio_skip(pb, 4); // Type, Headersize\n\n    compression = avio_rl16(pb);\n    version     = avio_rl16(pb);\n    if (version != 1) {\n        avpriv_request_sample(avctx, \""unknown version %i\"", version);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 12); // FirstMovieImage, TotalImageCount, FirstImageNumber\n\n    st->duration    = avio_rl32(pb);\n    offImageHeader  = avio_rl32(pb);\n    offSetup        = avio_rl32(pb);\n    offImageOffsets = avio_rl32(pb);\n\n    avio_skip(pb, 8); // TriggerTime\n\n    /* BITMAPINFOHEADER structure */\n    avio_seek(pb, offImageHeader, SEEK_SET);\n    avio_skip(pb, 4); //biSize\n    st->codecpar->width      = avio_rl32(pb);\n    st->codecpar->height     = avio_rl32(pb);\n\n    if (avio_rl16(pb) != 1) // biPlanes\n        return AVERROR_INVALIDDATA;\n\n    biBitCount = avio_rl16(pb);\n    if (biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48) {\n        avpriv_request_sample(avctx, \""unsupported biBitCount %i\"", biBitCount);\n        return AVERROR_INVALIDDATA;\n    }\n\n    switch (avio_rl32(pb)) {\n    case BMP_RGB:\n        vflip = 0;\n        break;\n    case 0x100: /* BI_PACKED */\n        st->codecpar->codec_tag = MKTAG('B', 'I', 'T', 0);\n        vflip = 1;\n        break;\n    default:\n        avpriv_request_sample(avctx, \""unknown bitmap compression\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 4); // biSizeImage\n\n    /* parse SETUP structure */\n    avio_seek(pb, offSetup, SEEK_SET);\n    avio_skip(pb, 140); // FrameRatae16 .. descriptionOld\n    if (avio_rl16(pb) != 0x5453)\n        return AVERROR_INVALIDDATA;\n    length = avio_rl16(pb);\n    if (length < 0x163C) {\n        avpriv_request_sample(avctx, \""short SETUP header\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 616); // Binning .. bFlipH\n    if (!avio_rl32(pb) ^ vflip) {\n        st->codecpar->extradata  = av_strdup(\""BottomUp\"");\n        st->codecpar->extradata_size  = 9;\n    }\n\n    avio_skip(pb, 4); // Grid\n\n    avpriv_set_pts_info(st, 64, 1, avio_rl32(pb));\n\n    avio_skip(pb, 20); // Shutter .. bEnableColor\n\n    set_metadata_int(&st->metadata, \""camera_version\"", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \""firmware_version\"", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \""software_version\"", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \""recording_timezone\"", avio_rl32(pb), 0);\n\n    CFA = avio_rl32(pb);\n\n    set_metadata_int(&st->metadata, \""brightness\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""contrast\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""gamma\"", avio_rl32(pb), 1);\n\n    avio_skip(pb, 12 + 16); // Reserved1 .. AutoExpRect\n    set_metadata_float(&st->metadata, \""wbgain[0].r\"", av_int2float(avio_rl32(pb)), 1);\n    set_metadata_float(&st->metadata, \""wbgain[0].b\"", av_int2float(avio_rl32(pb)), 1);\n    avio_skip(pb, 36); // WBGain[1].. WBView\n\n    st->codecpar->bits_per_coded_sample = avio_rl32(pb);\n\n    if (compression == CC_RGB) {\n        if (biBitCount == 8) {\n            st->codecpar->format = AV_PIX_FMT_GRAY8;\n        } else if (biBitCount == 16) {\n            st->codecpar->format = AV_PIX_FMT_GRAY16LE;\n        } else if (biBitCount == 24) {\n            st->codecpar->format = AV_PIX_FMT_BGR24;\n        } else if (biBitCount == 48) {\n            st->codecpar->format = AV_PIX_FMT_BGR48LE;\n        } else {\n            avpriv_request_sample(avctx, \""unsupported biBitCount %i\"", biBitCount);\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (compression == CC_UNINT) {\n        switch (CFA & 0xFFFFFF) {\n        case CFA_BAYER:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG16LE;\n            } else {\n                avpriv_request_sample(avctx, \""unsupported biBitCount %i\"", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        case CFA_BAYERFLIP:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB16LE;\n            } else {\n                avpriv_request_sample(avctx, \""unsupported biBitCount %i\"", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        default:\n           avpriv_request_sample(avctx, \""unsupported Color Field Array (CFA) %i\"", CFA & 0xFFFFFF);\n            return AVERROR_INVALIDDATA;\n        }\n    } else { //CC_LEAD\n        avpriv_request_sample(avctx, \""unsupported compression %i\"", compression);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 668); // Conv8Min ... Sensor\n\n    set_metadata_int(&st->metadata, \""shutter_ns\"", avio_rl32(pb), 0);\n\n    avio_skip(pb, 24); // EDRShutterNs ... ImHeightAcq\n\n#define DESCRIPTION_SIZE 4096\n    description = av_malloc(DESCRIPTION_SIZE + 1);\n    if (!description)\n        return AVERROR(ENOMEM);\n    i = avio_get_str(pb, DESCRIPTION_SIZE, description, DESCRIPTION_SIZE + 1);\n    if (i < DESCRIPTION_SIZE)\n        avio_skip(pb, DESCRIPTION_SIZE - i);\n    if (description[0])\n        av_dict_set(&st->metadata, \""description\"", description, AV_DICT_DONT_STRDUP_VAL);\n    else\n        av_free(description);\n\n    avio_skip(pb, 1176); // RisingEdge ... cmUser\n\n    set_metadata_int(&st->metadata, \""enable_crop\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""crop_left\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""crop_top\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""crop_right\"", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \""crop_bottom\"", avio_rl32(pb), 1);\n\n    /* parse image offsets */\n    avio_seek(pb, offImageOffsets, SEEK_SET);\n    for (i = 0; i < st->duration; i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME);\n    }\n\n    return 0;\n}""}]","{""value"": 1}","[{""source"": ""value_info(file:cinedec.c, value:st->duration)"", ""result"": {""value_trace"": [{""full_code"": ""st->duration    = avio_rl32(pb)"", ""line"": 120, ""func_name"": ""cine_read_header""}], ""struct_var"": ""st"", ""struct_type"": ""AVStream*"", ""struct_definition"": ""typedef struct AVStream {\n    int index;    /**< stream index in AVFormatContext */\n    /**\n     * Format-specific stream ID.\n     * decoding: set by libavformat\n     * encoding: set by the user, replaced by libavformat if left unset\n     */\n    int id;\n#if FF_API_LAVF_AVCTX\n    /**\n     * @deprecated use the codecpar struct instead\n     */\n    attribute_deprecated\n    AVCodecContext *codec;\n#endif\n    void *priv_data;\n\n#if FF_API_LAVF_FRAC\n    /**\n     * @deprecated this field is unused\n     */\n    attribute_deprecated\n    struct AVFrac pts;\n#endif\n\n    /**\n     * This is the fundamental unit of time (in seconds) in terms\n     * of which frame timestamps are represented.\n     *\n     * decoding: set by libavformat\n     * encoding: May be set by the caller before avformat_write_header() to\n     *           provide a hint to the muxer about the desired timebase. In\n     *           avformat_write_header(), the muxer will overwrite this field\n     *           with the timebase that wil...\n\ntypedef struct AVStream {\n    int index;    /**< stream index in AVFormatContext */\n    /**\n     * Format-specific stream ID.\n     * decoding: set by libavformat\n     * encoding: set by the user, replaced by libavformat if left unset\n     */\n    int id;\n#if FF_API_LAVF_AVCTX\n    /**\n     * @deprecated use the codecpar struct instead\n     */\n    attribute_deprecated\n    AVCodecContext *codec;\n#endif\n    void *priv_data;\n\n#if FF_API_LAVF_FRAC\n    /**\n     * @deprecated this field is unused\n     */\n    attribute_deprecated\n    struct AVFrac pts;\n#endif\n\n    /**\n     * This is the fundamental unit of time (in seconds) in terms\n     * of which frame timestamps are represented.\n     *\n     * decoding: set by libavformat\n     * encoding: May be set by the caller before avformat_write_header() to\n     *           provide a hint to the muxer about the desired timebase. In\n     *           avformat_write_header(), the muxer will overwrite this field\n     *           with the timebase that wil...\n\ntypedef struct AVStream {\n    int index;    /**< stream index in AVFormatContext */\n    /**\n     * Format-specific stream ID.\n     * decoding: set by libavformat\n     * encoding: set by the user, replaced by libavformat if left unset\n     */\n    int id;\n#if FF_API_LAVF_AVCTX\n    /**\n     * @deprecated use the codecpar struct instead\n     */\n    attribute_deprecated\n    AVCodecContext *codec;\n#endif\n    void *priv_data;\n\n#if FF_API_LAVF_FRAC\n    /**\n     * @deprecated this field is unused\n     */\n    attribute_deprecated\n    struct AVFrac pts;\n#endif\n\n    /**\n     * This is the fundamental unit of time (in seconds) in terms\n     * of which frame timestamps are represented.\n     *\n     * decoding: set by libavformat\n     * encoding: May be set by the caller before avformat_write_header() to\n     *           provide a hint to the muxer about the desired timebase. In\n     *           avformat_write_header(), the muxer will overwrite this field\n     *           with the timebase that wil...\n\ntypedef struct AVStream {\n    int index;    /**< stream index in AVFormatContext */\n    /**\n     * Format-specific stream ID.\n     * decoding: set by libavformat\n     * encoding: set by the user, replaced by libavformat if left unset\n     */\n    int id;\n#if FF_API_LAVF_AVCTX\n    /**\n     * @deprecated use the codecpar struct instead\n     */\n    attribute_deprecated\n    AVCodecContext *codec;\n#endif\n    void *priv_data;\n\n#if FF_API_LAVF_FRAC\n    /**\n     * @deprecated this field is unused\n     */\n    attribute_deprecated\n    struct AVFrac pts;\n#endif\n\n    /**\n     * This is the fundamental unit of time (in seconds) in terms\n     * of which frame timestamps are represented.\n     *\n     * decoding: set by libavformat\n     * encoding: May be set by the caller before avformat_write_header() to\n     *           provide a hint to the muxer about the desired timebase. In\n     *           avformat_write_header(), the muxer will overwrite this field\n     *           with the timebase that wil...\n\ntypedef struct AVStream {\n    int index;    /**< stream index in AVFormatContext */\n    /**\n     * Format-specific stream ID.\n     * decoding: set by libavformat\n     * encoding: set by the user, replaced by libavformat if left unset\n     */\n    int id;\n#if FF_API_LAVF_AVCTX\n    /**\n     * @deprecated use the codecpar struct instead\n     */\n    attribute_deprecated\n    AVCodecContext *codec;\n#endif\n    void *priv_data;\n\n#if FF_API_LAVF_FRAC\n    /**\n     * @deprecated this field is unused\n     */\n    attribute_deprecated\n    struct AVFrac pts;\n#endif\n\n    /**\n     * This is the fundamental unit of time (in seconds) in terms\n     * of which frame timestamps are represented.\n     *\n     * decoding: set by libavformat\n     * encoding: May be set by the caller before avformat_write_header() to\n     *           provide a hint to the muxer about the desired timebase. In\n     *           avformat_write_header(), the muxer will overwrite this field\n     *           with the timebase that wil...\n\ntypedef struct AVStream {\n    int index;    /**< stream index in AVFormatContext */\n    /**\n     * Format-specific stream ID.\n     * decoding: set by libavformat\n     * encoding: set by the user, replaced by libavformat if left unset\n     */\n    int id;\n#if FF_API_LAVF_AVCTX\n    /**\n     * @deprecated use the codecpar struct instead\n     */\n    attribute_deprecated\n    AVCodecContext *codec;\n#endif\n    void *priv_data;\n\n#if FF_API_LAVF_FRAC\n    /**\n     * @deprecated this field is unused\n     */\n    attribute_deprecated\n    struct AVFrac pts;\n#endif\n\n    /**\n     * This is the fundamental unit of time (in seconds) in terms\n     * of which frame timestamps are represented.\n     *\n     * decoding: set by libavformat\n     * encoding: May be set by the caller before avformat_write_header() to\n     *           provide a hint to the muxer about the desired timebase. In\n     *           avformat_write_header(), the muxer will overwrite this field\n     *           with the timebase that wil...\n\ntypedef struct AVStream {\n    int index;    /**< stream index in AVFormatContext */\n    /**\n     * Format-specific stream ID.\n     * decoding: set by libavformat\n     * encoding: set by the user, replaced by libavformat if left unset\n     */\n    int id;\n#if FF_API_LAVF_AVCTX\n    /**\n     * @deprecated use the codecpar struct instead\n     */\n    attribute_deprecated\n    AVCodecContext *codec;\n#endif\n    void *priv_data;\n\n#if FF_API_LAVF_FRAC\n    /**\n     * @deprecated this field is unused\n     */\n    attribute_deprecated\n    struct AVFrac pts;\n#endif\n\n    /**\n     * This is the fundamental unit of time (in seconds) in terms\n     * of which frame timestamps are represented.\n     *\n     * decoding: set by libavformat\n     * encoding: May be set by the caller before avformat_write_header() to\n     *           provide a hint to the muxer about the desired timebase. In\n     *           avformat_write_header(), the muxer will overwrite this field\n     *           with the timebase that wil...\n\ntypedef struct AVStream {\n    int index;    /**< stream index in AVFormatContext */\n    /**\n     * Format-specific stream ID.\n     * decoding: set by libavformat\n     * encoding: set by the user, replaced by libavformat if left unset\n     */\n    int id;\n#if FF_API_LAVF_AVCTX\n    /**\n     * @deprecated use the codecpar struct instead\n     */\n    attribute_deprecated\n    AVCodecContext *codec;\n#endif\n    void *priv_data;\n\n#if FF_API_LAVF_FRAC\n    /**\n     * @deprecated this field is unused\n     */\n    attribute_deprecated\n    struct AVFrac pts;\n#endif\n\n    /**\n     * This is the fundamental unit of time (in seconds) in terms\n     * of which frame timestamps are represented.\n     *\n     * decoding: set by libavformat\n     * encoding: May be set by the caller before avformat_write_header() to\n     *           provide a hint to the muxer about the desired timebase. In\n     *           avformat_write_header(), the muxer will overwrite this field\n     *           with the timebase that wil...\n\ntypedef struct AVStream {\n    int index;    /**< stream index in AVFormatContext */\n    /**\n     * Format-specific stream ID.\n     * decoding: set by libavformat\n     * encoding: set by the user, replaced by libavformat if left unset\n     */\n    int id;\n#if FF_API_LAVF_AVCTX\n    /**\n     * @deprecated use the codecpar struct instead\n     */\n    attribute_deprecated\n    AVCodecContext *codec;\n#endif\n    void *priv_data;\n\n#if FF_API_LAVF_FRAC\n    /**\n     * @deprecated this field is unused\n     */\n    attribute_deprecated\n    struct AVFrac pts;\n#endif\n\n    /**\n     * This is the fundamental unit of time (in seconds) in terms\n     * of which frame timestamps are represented.\n     *\n     * decoding: set by libavformat\n     * encoding: May be set by the caller before avformat_write_header() to\n     *           provide a hint to the muxer about the desired timebase. In\n     *           avformat_write_header(), the muxer will overwrite this field\n     *           with the timebase that wil...\n\ntypedef struct AVStream {\n    int index;    /**< stream index in AVFormatContext */\n    /**\n     * Format-specific stream ID.\n     * decoding: set by libavformat\n     * encoding: set by the user, replaced by libavformat if left unset\n     */\n    int id;\n#if FF_API_LAVF_AVCTX\n    /**\n     * @deprecated use the codecpar struct instead\n     */\n    attribute_deprecated\n    AVCodecContext *codec;\n#endif\n    void *priv_data;\n\n#if FF_API_LAVF_FRAC\n    /**\n     * @deprecated this field is unused\n     */\n    attribute_deprecated\n    struct AVFrac pts;\n#endif\n\n    /**\n     * This is the fundamental unit of time (in seconds) in terms\n     * of which frame timestamps are represented.\n     *\n     * decoding: set by libavformat\n     * encoding: May be set by the caller before avformat_write_header() to\n     *           provide a hint to the muxer about the desired timebase. In\n     *           avformat_write_header(), the muxer will overwrite this field\n     *           with the timebase that wil...""}}]",The loop in libavformat/cinedec.c:268 iterates 'st->duration' times without EOF checks. 'st->duration' is initialized from untrusted input via avio_rl32(pb) at libavformat/cinedec.c:120 without validation. A crafted CINE file with an oversized 'duration' field and insufficient backing data causes the loop to consume excessive CPU/memory until EOF is reached. The patch adds an EOF check (libavformat/cinedec.c:269-271) to prevent infinite looping but does not validate 'st->duration'.,0.95,./github/other_context/CVE-2017-14059
8,CVE-2017-14172,CWE-834,c_cpp,"In coders/ps.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSImage() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large ""extent"" field in the header but does not contain sufficient backing data, is provided, the loop over ""length"" would consume huge CPU resources, since there is no EOF check inside the loop.",https://github.com/ImageMagick/ImageMagick/commit/bdbbb13f1fe9b7e2465502c500561720f7456aac,https://github.com/ImageMagick/ImageMagick/issues/715,2,"[{""func_name"": ""ReadPSImage"", ""file_path"": ""coders/ps.c"", ""func_code"": ""static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \""BoundingBox:\""\n#define BeginDocument  \""BeginDocument:\""\n#define BeginXMPPacket  \""<?xpacket begin=\""\n#define EndXMPPacket  \""<?xpacket end=\""\n#define ICCProfile \""BeginICCProfile:\""\n#define CMYKCustomColor  \""CMYKCustomColor:\""\n#define CMYKProcessColor  \""CMYKProcessColor:\""\n#define DocumentMedia  \""DocumentMedia:\""\n#define DocumentCustomColors  \""DocumentCustomColors:\""\n#define DocumentProcessColors  \""DocumentProcessColors:\""\n#define EndDocument  \""EndDocument:\""\n#define HiResBoundingBox  \""HiResBoundingBox:\""\n#define ImageData  \""ImageData:\""\n#define PageBoundingBox  \""PageBoundingBox:\""\n#define LanguageLevel  \""LanguageLevel:\""\n#define PageMedia  \""PageMedia:\""\n#define Pages  \""Pages:\""\n#define PhotoshopProfile  \""BeginPhotoshop:\""\n#define PostscriptLevel  \""!PS-\""\n#define RenderPostscriptText  \""  Rendering Postscript...  \""\n#define SpotColor  \""+ \""\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *postscript_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    fitPage,\n    skip,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution;\n\n  RectangleInfo\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  short int\n    hex_digits[256];\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    priority;\n\n  StringInfo\n    *profile;\n\n  unsigned long\n    columns,\n    extent,\n    language_level,\n    pages,\n    rows,\n    scene,\n    spotcolor;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\""UnableToCreateTemporaryFile\"",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize hex values.\n  */\n  (void) ResetMagickMemory(hex_digits,0,sizeof(hex_digits));\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  resolution=image->resolution;\n  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);\n  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);\n  /*\n    Determine page geometry from the Postscript bounding box.\n  */\n  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));\n  (void) ResetMagickMemory(command,0,sizeof(command));\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  (void) ResetMagickMemory(&hires_bounds,0,sizeof(hires_bounds));\n  columns=0;\n  rows=0;\n  priority=0;\n  rows=0;\n  extent=0;\n  spotcolor=0;\n  language_level=1;\n  pages=(~0UL);\n  skip=MagickFalse;\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\""\\n\\r%\"",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\""ps:Level\"",command+4,exception);\n        if (GlobExpression(command,\""*EPSF-*\"",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \"" %lu\"",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \"" %lu\"",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \"" %lu %lu\"",&columns,&rows);\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MagickPathExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\""icc\"",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *q;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \"" %lu\"",&extent);\n        if (count != 1)\n          continue;\n        length=extent;\n        profile=BlobToStringInfo((const void *) NULL,length);\n        if (profile != (StringInfo *) NULL)\n          {\n            q=GetStringInfoDatum(profile);\n            for (i=0; i < (ssize_t) length; i++)\n              *q++=(unsigned char) ProfileInteger(image,hex_digits);\n            (void) SetImageProfile(image,\""8bim\"",profile,exception);\n            profile=DestroyStringInfo(profile);\n          }\n        continue;\n      }\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,i+1);\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\""\\n\\r%\"",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MagickPathExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,i);\n        (void) SetImageProfile(image,\""xmp\"",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    /*\n      Is this a CMYK document?\n    */\n    length=strlen(DocumentProcessColors);\n    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)\n      {\n        if ((GlobExpression(command,\""*Cyan*\"",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\""*Magenta*\"",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\""*Yellow*\"",MagickTrue) != MagickFalse))\n          cmyk=MagickTrue;\n      }\n    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    length=strlen(DocumentCustomColors);\n    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||\n        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||\n        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))\n      {\n        char\n          property[MagickPathExtent],\n          *value;\n\n        register char\n          *q;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MagickPathExtent,\""ps:SpotColor-%.20g\"",\n          (double) (spotcolor++));\n        for (q=command; *q != '\\0'; q++)\n          if (isspace((int) (unsigned char) *q) != 0)\n            break;\n        value=AcquireString(q);\n        (void) SubstituteString(&value,\""(\"",\""\"");\n        (void) SubstituteString(&value,\"")\"",\""\"");\n        (void) StripString(value);\n        (void) SetImageProperty(image,property,value,exception);\n        value=DestroyString(value);\n        continue;\n      }\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note region defined by bounding box.\n    */\n    count=0;\n    i=0;\n    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,BoundingBox \"" %lf %lf %lf %lf\"",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=2;\n      }\n    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,DocumentMedia \"" %lf %lf %lf %lf\"",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,HiResBoundingBox \"" %lf %lf %lf %lf\"",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=3;\n      }\n    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageBoundingBox \"" %lf %lf %lf %lf\"",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageMedia \"" %lf %lf %lf %lf\"",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if ((count != 4) || (i < (ssize_t) priority))\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      if (i ==  (ssize_t) priority)\n        continue;\n    hires_bounds=bounds;\n    priority=i;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) && \n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set Postscript render geometry.\n      */\n      (void) FormatLocaleString(geometry,MagickPathExtent,\""%gx%g%+.15g%+.15g\"",\n        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\""ps:HiResBoundingBox\"",geometry,exception);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\""eps:fit-page\"");\n  if (option != (char *) NULL)\n  {\n    char\n      *page_geometry;\n\n    page_geometry=GetPageGeometry(option);\n    flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n      &page.height);\n    if (flags == NoValue)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \""InvalidGeometry\"",\""`%s'\"",option);\n        image=DestroyImage(image);\n        return((Image *) NULL);\n      }\n    page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)\n      -0.5);\n    page.height=(size_t) ceil((double) (page.height*image->resolution.y/\n      delta.y) -0.5);\n    page_geometry=DestroyString(page_geometry);\n    fitPage=MagickTrue;\n  }\n  (void) CloseBlob(image);\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(exception,FileOpenError,\""UnableToOpenFile\"",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(command,\""/setpagedevice {pop} bind 1 index where {\""\n    \""dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\\n\""\n    \""<</UseCIEColor true>>setpagedevice\\n\"",MagickPathExtent);\n  count=write(file,command,(unsigned int) strlen(command));\n  if (image_info->page == (char *) NULL)\n    {\n      char\n        translate_geometry[MagickPathExtent];\n\n      (void) FormatLocaleString(translate_geometry,MagickPathExtent,\n        \""%g %g translate\\n\"",-bounds.x1,-bounds.y1);\n      count=write(file,translate_geometry,(unsigned int)\n        strlen(translate_geometry));\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\""ps:mono\"",(char *) NULL,exception);\n  else\n    if (cmyk != MagickFalse)\n      delegate_info=GetDelegateInfo(\""ps:cmyk\"",(char *) NULL,exception);\n    else\n      delegate_info=GetDelegateInfo(\""ps:alpha\"",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\""\"");\n  options=AcquireString(\""\"");\n  (void) FormatLocaleString(density,MagickPathExtent,\""%gx%g\"",resolution.x,\n    resolution.y);\n  (void) FormatLocaleString(options,MagickPathExtent,\""-g%.20gx%.20g \"",(double)\n    page.width,(double) page.height);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\""-dFirstPage=%.20g \""\n        \""-dLastPage=%.20g \"",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  if (*image_info->magick == 'E')\n    {\n      option=GetImageOption(image_info,\""eps:use-cropbox\"");\n      if ((option == (const char *) NULL) ||\n          (IsStringTrue(option) != MagickFalse))\n        (void) ConcatenateMagickString(options,\""-dEPSCrop \"",MagickPathExtent);\n      if (fitPage != MagickFalse)\n        (void) ConcatenateMagickString(options,\""-dEPSFitPage \"",MagickPathExtent);\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\""%d\"",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);\n  (void) InterpretImageFilename(image_info,image,filename,1,\n    read_info->filename,exception);\n  if ((status == MagickFalse) ||\n      (IsPostscriptRendered(read_info->filename) == MagickFalse))\n    {\n      (void) ConcatenateMagickString(command,\"" -c showpage\"",MagickPathExtent);\n      status=InvokePostscriptDelegate(read_info->verbose,command,message,\n        exception);\n    }\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  postscript_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&postscript_image,next);\n    }\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (postscript_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          DelegateError,\""PostscriptDelegateFailed\"",\""`%s'\"",message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(postscript_image->magick,\""BMP\"") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          postscript_image=DestroyImageList(postscript_image);\n          postscript_image=cmyk_image;\n        }\n    }\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&postscript_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(postscript_image->filename,filename,\n      MagickPathExtent);\n    (void) CopyMagickString(postscript_image->magick,image->magick,\n      MagickPathExtent);\n    if (columns != 0)\n      postscript_image->magick_columns=columns;\n    if (rows != 0)\n      postscript_image->magick_rows=rows;\n    postscript_image->page=page;\n    (void) CloneImageProfiles(postscript_image,image);\n    (void) CloneImageProperties(postscript_image,image);\n    next=SyncNextImageInList(postscript_image);\n    if (next != (Image *) NULL)\n      postscript_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImageList(image);\n  scene=0;\n  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(postscript_image));\n}"", ""target"": 0}, {""func_name"": ""RegisterPSImage"", ""file_path"": ""coders/ps.c"", ""func_code"": ""ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\""PS\"",\""EPI\"",\n    \""Encapsulated PostScript Interchange format\"");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\""application/postscript\"");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\""PS\"",\""EPS\"",\""Encapsulated PostScript\"");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\""application/postscript\"");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\""PS\"",\""EPSF\"",\""Encapsulated PostScript\"");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\""application/postscript\"");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\""PS\"",\""EPSI\"",\n    \""Encapsulated PostScript Interchange format\"");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\""application/postscript\"");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\""PS\"",\""PS\"",\""PostScript\"");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\""application/postscript\"");\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}"", ""target"": 1}]","[{""func_name"": ""ReadPSImage"", ""file_path"": ""coders/ps.c"", ""func_code"": ""static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \""BoundingBox:\""\n#define BeginDocument  \""BeginDocument:\""\n#define BeginXMPPacket  \""<?xpacket begin=\""\n#define EndXMPPacket  \""<?xpacket end=\""\n#define ICCProfile \""BeginICCProfile:\""\n#define CMYKCustomColor  \""CMYKCustomColor:\""\n#define CMYKProcessColor  \""CMYKProcessColor:\""\n#define DocumentMedia  \""DocumentMedia:\""\n#define DocumentCustomColors  \""DocumentCustomColors:\""\n#define DocumentProcessColors  \""DocumentProcessColors:\""\n#define EndDocument  \""EndDocument:\""\n#define HiResBoundingBox  \""HiResBoundingBox:\""\n#define ImageData  \""ImageData:\""\n#define PageBoundingBox  \""PageBoundingBox:\""\n#define LanguageLevel  \""LanguageLevel:\""\n#define PageMedia  \""PageMedia:\""\n#define Pages  \""Pages:\""\n#define PhotoshopProfile  \""BeginPhotoshop:\""\n#define PostscriptLevel  \""!PS-\""\n#define RenderPostscriptText  \""  Rendering Postscript...  \""\n#define SpotColor  \""+ \""\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *postscript_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    fitPage,\n    skip,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution;\n\n  RectangleInfo\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  short int\n    hex_digits[256];\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    priority;\n\n  StringInfo\n    *profile;\n\n  unsigned long\n    columns,\n    extent,\n    language_level,\n    pages,\n    rows,\n    scene,\n    spotcolor;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\""UnableToCreateTemporaryFile\"",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize hex values.\n  */\n  (void) ResetMagickMemory(hex_digits,0,sizeof(hex_digits));\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  resolution=image->resolution;\n  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);\n  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);\n  /*\n    Determine page geometry from the Postscript bounding box.\n  */\n  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));\n  (void) ResetMagickMemory(command,0,sizeof(command));\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  (void) ResetMagickMemory(&hires_bounds,0,sizeof(hires_bounds));\n  columns=0;\n  rows=0;\n  priority=0;\n  rows=0;\n  extent=0;\n  spotcolor=0;\n  language_level=1;\n  pages=(~0UL);\n  skip=MagickFalse;\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\""\\n\\r%\"",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\""ps:Level\"",command+4,exception);\n        if (GlobExpression(command,\""*EPSF-*\"",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \"" %lu\"",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \"" %lu\"",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \"" %lu %lu\"",&columns,&rows);\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MagickPathExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\""icc\"",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *q;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \"" %lu\"",&extent);\n        if (count != 1)\n          continue;\n        length=extent;\n        if (length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\""InsufficientImageDataInFile\"");\n        profile=BlobToStringInfo((const void *) NULL,length);\n        if (profile != (StringInfo *) NULL)\n          {\n            q=GetStringInfoDatum(profile);\n            for (i=0; i < (ssize_t) length; i++)\n              *q++=(unsigned char) ProfileInteger(image,hex_digits);\n            (void) SetImageProfile(image,\""8bim\"",profile,exception);\n            profile=DestroyStringInfo(profile);\n          }\n        continue;\n      }\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,i+1);\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\""\\n\\r%\"",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MagickPathExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,i);\n        (void) SetImageProfile(image,\""xmp\"",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    /*\n      Is this a CMYK document?\n    */\n    length=strlen(DocumentProcessColors);\n    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)\n      {\n        if ((GlobExpression(command,\""*Cyan*\"",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\""*Magenta*\"",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\""*Yellow*\"",MagickTrue) != MagickFalse))\n          cmyk=MagickTrue;\n      }\n    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    length=strlen(DocumentCustomColors);\n    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||\n        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||\n        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))\n      {\n        char\n          property[MagickPathExtent],\n          *value;\n\n        register char\n          *q;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MagickPathExtent,\n          \""ps:SpotColor-%.20g\"",(double) (spotcolor++));\n        for (q=command; *q != '\\0'; q++)\n          if (isspace((int) (unsigned char) *q) != 0)\n            break;\n        value=AcquireString(q);\n        (void) SubstituteString(&value,\""(\"",\""\"");\n        (void) SubstituteString(&value,\"")\"",\""\"");\n        (void) StripString(value);\n        (void) SetImageProperty(image,property,value,exception);\n        value=DestroyString(value);\n        continue;\n      }\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note region defined by bounding box.\n    */\n    count=0;\n    i=0;\n    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,BoundingBox \"" %lf %lf %lf %lf\"",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=2;\n      }\n    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,DocumentMedia \"" %lf %lf %lf %lf\"",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,HiResBoundingBox \"" %lf %lf %lf %lf\"",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=3;\n      }\n    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageBoundingBox \"" %lf %lf %lf %lf\"",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageMedia \"" %lf %lf %lf %lf\"",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if ((count != 4) || (i < (ssize_t) priority))\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      if (i ==  (ssize_t) priority)\n        continue;\n    hires_bounds=bounds;\n    priority=i;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) && \n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set Postscript render geometry.\n      */\n      (void) FormatLocaleString(geometry,MagickPathExtent,\""%gx%g%+.15g%+.15g\"",\n        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\""ps:HiResBoundingBox\"",geometry,exception);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\""eps:fit-page\"");\n  if (option != (char *) NULL)\n  {\n    char\n      *page_geometry;\n\n    page_geometry=GetPageGeometry(option);\n    flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n      &page.height);\n    if (flags == NoValue)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \""InvalidGeometry\"",\""`%s'\"",option);\n        image=DestroyImage(image);\n        return((Image *) NULL);\n      }\n    page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)\n      -0.5);\n    page.height=(size_t) ceil((double) (page.height*image->resolution.y/\n      delta.y) -0.5);\n    page_geometry=DestroyString(page_geometry);\n    fitPage=MagickTrue;\n  }\n  (void) CloseBlob(image);\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(exception,FileOpenError,\""UnableToOpenFile\"",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(command,\""/setpagedevice {pop} bind 1 index where {\""\n    \""dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\\n\""\n    \""<</UseCIEColor true>>setpagedevice\\n\"",MagickPathExtent);\n  count=write(file,command,(unsigned int) strlen(command));\n  if (image_info->page == (char *) NULL)\n    {\n      char\n        translate_geometry[MagickPathExtent];\n\n      (void) FormatLocaleString(translate_geometry,MagickPathExtent,\n        \""%g %g translate\\n\"",-bounds.x1,-bounds.y1);\n      count=write(file,translate_geometry,(unsigned int)\n        strlen(translate_geometry));\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\""ps:mono\"",(char *) NULL,exception);\n  else\n    if (cmyk != MagickFalse)\n      delegate_info=GetDelegateInfo(\""ps:cmyk\"",(char *) NULL,exception);\n    else\n      delegate_info=GetDelegateInfo(\""ps:alpha\"",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\""\"");\n  options=AcquireString(\""\"");\n  (void) FormatLocaleString(density,MagickPathExtent,\""%gx%g\"",resolution.x,\n    resolution.y);\n  (void) FormatLocaleString(options,MagickPathExtent,\""-g%.20gx%.20g \"",(double)\n    page.width,(double) page.height);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\""-dFirstPage=%.20g \""\n        \""-dLastPage=%.20g \"",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  if (*image_info->magick == 'E')\n    {\n      option=GetImageOption(image_info,\""eps:use-cropbox\"");\n      if ((option == (const char *) NULL) ||\n          (IsStringTrue(option) != MagickFalse))\n        (void) ConcatenateMagickString(options,\""-dEPSCrop \"",MagickPathExtent);\n      if (fitPage != MagickFalse)\n        (void) ConcatenateMagickString(options,\""-dEPSFitPage \"",\n          MagickPathExtent);\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\""%d\"",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);\n  (void) InterpretImageFilename(image_info,image,filename,1,\n    read_info->filename,exception);\n  if ((status == MagickFalse) ||\n      (IsPostscriptRendered(read_info->filename) == MagickFalse))\n    {\n      (void) ConcatenateMagickString(command,\"" -c showpage\"",MagickPathExtent);\n      status=InvokePostscriptDelegate(read_info->verbose,command,message,\n        exception);\n    }\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  postscript_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&postscript_image,next);\n    }\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (postscript_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          DelegateError,\""PostscriptDelegateFailed\"",\""`%s'\"",message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(postscript_image->magick,\""BMP\"") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          postscript_image=DestroyImageList(postscript_image);\n          postscript_image=cmyk_image;\n        }\n    }\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&postscript_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(postscript_image->filename,filename,\n      MagickPathExtent);\n    (void) CopyMagickString(postscript_image->magick,image->magick,\n      MagickPathExtent);\n    if (columns != 0)\n      postscript_image->magick_columns=columns;\n    if (rows != 0)\n      postscript_image->magick_rows=rows;\n    postscript_image->page=page;\n    (void) CloneImageProfiles(postscript_image,image);\n    (void) CloneImageProperties(postscript_image,image);\n    next=SyncNextImageInList(postscript_image);\n    if (next != (Image *) NULL)\n      postscript_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImageList(image);\n  scene=0;\n  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(postscript_image));\n}""}, {""func_name"": ""RegisterPSImage"", ""file_path"": ""coders/ps.c"", ""func_code"": ""ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\""PS\"",\""EPI\"",\n    \""Encapsulated PostScript Interchange format\"");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\""application/postscript\"");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\""PS\"",\""EPS\"",\""Encapsulated PostScript\"");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\""application/postscript\"");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\""PS\"",\""EPSF\"",\""Encapsulated PostScript\"");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\""application/postscript\"");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\""PS\"",\""EPSI\"",\n    \""Encapsulated PostScript Interchange format\"");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\""application/postscript\"");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\""PS\"",\""PS\"",\""PostScript\"");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\""application/postscript\"");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}""}]","{""value"": 1, ""code"": 1}","[{""source"": ""value_info(file:ps.c, value:extent)"", ""result"": {""value_trace"": [{""full_code"": ""extent=0"", ""line"": 586, ""func_name"": ""ReadPSImage""}], ""struct_var"": ""extent"", ""struct_type"": ""longunsigned"", ""struct_definition"": ""longunsigned""}}, {""source"": ""code_info(file:ps.c, lines:586-658)"", ""result"": ""  extent=0;\n  spotcolor=0;\n  language_level=1;\n  pages=(~0UL);\n  skip=MagickFalse;\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\""\\n\\r%\"",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\""ps:Level\"",command+4,exception);\n        if (GlobExpression(command,\""*EPSF-*\"",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \"" %lu\"",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \"" %lu\"",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \"" %lu %lu\"",&columns,&rows);\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MagickPathExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\""icc\"",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *q;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \"" %lu\"",&extent);\n        if (count != 1)\n          continue;\n        length=extent;\n""}]","1. 'extent' is initialized to 0 in coders/ps.c:586. 2. The code reads bytes from the input blob into 'command' (coders/ps.c:586-658). 3. When parsing the PhotoshopProfile line, 'extent' is read via sscanf from the command string (coders/ps.c:896-898). 4. If the 'extent' is large but the blob data is insufficient, 'length=extent' (coders/ps.c:658) triggers a loop without EOF checks. 5. The patch adds a blob size check at coders/ps.c:658 to prevent this.",0.95,./github/other_context/CVE-2017-14172
9,CVE-2017-14175,CWE-834,c_cpp,"In coders/xbm.c in ImageMagick 7.0.6-1 Q16, a DoS in ReadXBMImage() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted XBM file, which claims large rows and columns fields in the header but does not contain sufficient backing data, is provided, the loop over the rows would consume huge CPU resources, since there is no EOF check inside the loop.",https://github.com/ImageMagick/ImageMagick/commit/d9a8234d211da30baf9526fbebe9a8438ea7e11c,https://github.com/ImageMagick/ImageMagick/issues/712,2,"[{""func_name"": ""XBMInteger"", ""file_path"": ""coders/xbm.c"", ""func_code"": ""static unsigned int XBMInteger(Image *image,short int *hex_digits)\n{ \n  int\n    c;\n  \n  unsigned int\n    value;\n  \n  /*\n    Skip any leading whitespace.\n  */\n  do\n  { \n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(0);\n  } while ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'));\n  /*\n    Evaluate number.\n  */\n  value=0;\n  do\n  { \n    if (value > (unsigned int) (INT_MAX/10))\n      break;\n    value*=16;\n    c&=0xff;\n    if (value > (unsigned int) (INT_MAX-hex_digits[c]))\n      break;\n    value+=hex_digits[c];\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(0);\n  } while (hex_digits[c] >= 0);\n  return(value);\n}"", ""target"": 1}, {""func_name"": ""ReadXBMImage"", ""file_path"": ""coders/xbm.c"", ""func_code"": ""static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    name[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  short int\n    hex_digits[256];\n\n  ssize_t\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned int\n    bit,\n    byte,\n    bytes_per_line,\n    height,\n    length,\n    padding,\n    value,\n    version,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read X bitmap header.\n  */\n  width=0;\n  height=0;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\""#define %32s %u\"",name,&width) == 2)\n      if ((strlen(name) >= 6) &&\n          (LocaleCompare(name+strlen(name)-6,\""_width\"") == 0))\n        break;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\""#define %32s %u\"",name,&height) == 2)\n      if ((strlen(name) >= 7) &&\n          (LocaleCompare(name+strlen(name)-7,\""_height\"") == 0))\n        break;\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  image->colors=2;\n  /*\n    Scan until hex digits.\n  */\n  version=11;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n  {\n    if (sscanf(buffer,\""static short %32s = {\"",name) == 1)\n      version=10;\n    else\n      if (sscanf(buffer,\""static unsigned char %32s = {\"",name) == 1)\n        version=11;\n      else\n        if (sscanf(buffer,\""static char %32s = {\"",name) == 1)\n          version=11;\n        else\n          continue;\n    p=(unsigned char *) strrchr(name,'_');\n    if (p == (unsigned char *) NULL)\n      p=(unsigned char *) name;\n    else\n      p++;\n    if (LocaleCompare(\""bits[]\"",(char *) p) == 0)\n      break;\n  }\n  if ((image->columns == 0) || (image->rows == 0) ||\n      (EOFBlob(image) != MagickFalse))\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  /*\n    Initialize image structure.\n  */\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n  /*\n    Initialize colormap.\n  */\n  image->colormap[0].red=QuantumRange;\n  image->colormap[0].green=QuantumRange;\n  image->colormap[0].blue=QuantumRange;\n  image->colormap[1].red=(Quantum) 0;\n  image->colormap[1].green=(Quantum) 0;\n  image->colormap[1].blue=(Quantum) 0;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Initialize hex values.\n  */\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'x']=0;\n  hex_digits[(int) ' ']=(-1);\n  hex_digits[(int) ',']=(-1);\n  hex_digits[(int) '}']=(-1);\n  hex_digits[(int) '\\n']=(-1);\n  hex_digits[(int) '\\t']=(-1);\n  /*\n    Read hex image data.\n  */\n  padding=0;\n  if (((image->columns % 16) != 0) && ((image->columns % 16) < 9) &&\n      (version == 10))\n    padding=1;\n  bytes_per_line=(unsigned int) (image->columns+7)/8+padding;\n  length=(unsigned int) image->rows;\n  data=(unsigned char *) AcquireQuantumMemory(length,bytes_per_line*\n    sizeof(*data));\n  if (data == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n  p=data;\n  if (version == 10)\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); (i+=2))\n    {\n      value=XBMInteger(image,hex_digits);\n      *p++=(unsigned char) value;\n      if ((padding == 0) || (((i+2) % bytes_per_line) != 0))\n        *p++=(unsigned char) (value >> 8);\n    }\n  else\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); i++)\n    {\n      value=XBMInteger(image,hex_digits);\n      *p++=(unsigned char) value;\n    }\n  /*\n    Convert X bitmap image to pixel packets.\n  */\n  p=data;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (bit == 0)\n        byte=(size_t) (*p++);\n      SetPixelIndex(image,(Quantum) ((byte & 0x01) != 0 ? 0x01 : 0x00),q);\n      bit++;\n      byte>>=1;\n      if (bit == 8)\n        bit=0;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  data=(unsigned char *) RelinquishMagickMemory(data);\n  (void) SyncImage(image,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"", ""target"": 0}]","[{""func_name"": ""XBMInteger"", ""file_path"": ""coders/xbm.c"", ""func_code"": ""static int XBMInteger(Image *image,short int *hex_digits)\n{ \n  int\n    c;\n  \n  unsigned int\n    value;\n  \n  /*\n    Skip any leading whitespace.\n  */\n  do\n  { \n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(-1);\n  } while ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'));\n  /*\n    Evaluate number.\n  */\n  value=0;\n  do\n  { \n    if (value > (unsigned int) (INT_MAX/10))\n      break;\n    value*=16;\n    c&=0xff;\n    if (value > (unsigned int) (INT_MAX-hex_digits[c]))\n      break;\n    value+=hex_digits[c];\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(-1);\n  } while (hex_digits[c] >= 0);\n  return((int) value);\n}""}, {""func_name"": ""ReadXBMImage"", ""file_path"": ""coders/xbm.c"", ""func_code"": ""static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    name[MagickPathExtent];\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  short int\n    hex_digits[256];\n\n  ssize_t\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned int\n    bit,\n    byte,\n    bytes_per_line,\n    height,\n    length,\n    padding,\n    version,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read X bitmap header.\n  */\n  width=0;\n  height=0;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\""#define %32s %u\"",name,&width) == 2)\n      if ((strlen(name) >= 6) &&\n          (LocaleCompare(name+strlen(name)-6,\""_width\"") == 0))\n        break;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\""#define %32s %u\"",name,&height) == 2)\n      if ((strlen(name) >= 7) &&\n          (LocaleCompare(name+strlen(name)-7,\""_height\"") == 0))\n        break;\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  image->colors=2;\n  /*\n    Scan until hex digits.\n  */\n  version=11;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n  {\n    if (sscanf(buffer,\""static short %32s = {\"",name) == 1)\n      version=10;\n    else\n      if (sscanf(buffer,\""static unsigned char %32s = {\"",name) == 1)\n        version=11;\n      else\n        if (sscanf(buffer,\""static char %32s = {\"",name) == 1)\n          version=11;\n        else\n          continue;\n    p=(unsigned char *) strrchr(name,'_');\n    if (p == (unsigned char *) NULL)\n      p=(unsigned char *) name;\n    else\n      p++;\n    if (LocaleCompare(\""bits[]\"",(char *) p) == 0)\n      break;\n  }\n  if ((image->columns == 0) || (image->rows == 0) ||\n      (EOFBlob(image) != MagickFalse))\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  /*\n    Initialize image structure.\n  */\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n  /*\n    Initialize colormap.\n  */\n  image->colormap[0].red=(MagickRealType) QuantumRange;\n  image->colormap[0].green=(MagickRealType) QuantumRange;\n  image->colormap[0].blue=(MagickRealType) QuantumRange;\n  image->colormap[1].red=0.0;\n  image->colormap[1].green=0.0;\n  image->colormap[1].blue=0.0;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Initialize hex values.\n  */\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'x']=0;\n  hex_digits[(int) ' ']=(-1);\n  hex_digits[(int) ',']=(-1);\n  hex_digits[(int) '}']=(-1);\n  hex_digits[(int) '\\n']=(-1);\n  hex_digits[(int) '\\t']=(-1);\n  /*\n    Read hex image data.\n  */\n  padding=0;\n  if (((image->columns % 16) != 0) && ((image->columns % 16) < 9) &&\n      (version == 10))\n    padding=1;\n  bytes_per_line=(unsigned int) (image->columns+7)/8+padding;\n  length=(unsigned int) image->rows;\n  data=(unsigned char *) AcquireQuantumMemory(length,bytes_per_line*\n    sizeof(*data));\n  if (data == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n  p=data;\n  if (version == 10)\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); (i+=2))\n    {\n      c=XBMInteger(image,hex_digits);\n      if (c < 0)\n        break;\n      *p++=(unsigned char) c;\n      if ((padding == 0) || (((i+2) % bytes_per_line) != 0))\n        *p++=(unsigned char) (c >> 8);\n    }\n  else\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); i++)\n    {\n      c=XBMInteger(image,hex_digits);\n      if (c < 0)\n        break;\n      *p++=(unsigned char) c;\n    }\n  if (EOFBlob(image) != MagickFalse)\n    {\n      data=(unsigned char *) RelinquishMagickMemory(data);\n      ThrowReaderException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    }\n  /*\n    Convert X bitmap image to pixel packets.\n  */\n  p=data;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (bit == 0)\n        byte=(unsigned int) (*p++);\n      SetPixelIndex(image,(Quantum) ((byte & 0x01) != 0 ? 0x01 : 0x00),q);\n      bit++;\n      byte>>=1;\n      if (bit == 8)\n        bit=0;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  data=(unsigned char *) RelinquishMagickMemory(data);\n  (void) SyncImage(image,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}""}]","{""function"": 2, ""value"": 1, ""code"": 1}","[{""source"": ""func_info(file:xbm.c, func:XBMInteger)"", ""result"": [{""code"": ""static unsigned int XBMInteger(Image *image,short int *hex_digits)\n{ \n  int\n    c;\n  \n  unsigned int\n    value;\n  \n  /*\n    Skip any leading whitespace.\n  */\n  do\n  { \n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(0);\n  } while ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'));\n  /*\n    Evaluate number.\n  */\n  value=0;\n  do\n  { \n    if (value > (unsigned int) (INT_MAX/10))\n      break;\n    value*=16;\n    c&=0xff;\n    if (value > (unsigned int) (INT_MAX-hex_digits[c]))\n      break;\n    value+=hex_digits[c];\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(0);\n  } while (hex_digits[c] >= 0);\n  return(value);\n}"", ""start_line"": 134, ""end_line"": 169, ""full_name"": ""XBMInteger"", ""file_path"": ""coders/xbm.c""}]}, {""source"": ""func_info(func:ReadBlobByte)"", ""result"": [{""code"": ""int ReadBlobByte(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[1];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  p=(const unsigned char *) ReadBlobStream(image,1,buffer,&count);\n  if (count != 1)\n    return(EOF);\n  return((int) (*p));\n}"", ""start_line"": 3415, ""end_line"": 3432, ""full_name"": ""ReadBlobByte"", ""file_path"": ""MagickCore/blob.c""}]}, {""source"": ""value_info(file:xbm.c, value:EOF)"", ""result"": {""value_trace"": [{""full_code"": ""EOF"", ""line"": 148, ""func_name"": null}], ""struct_var"": ""EOF"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""code_info(file:xbm.c, lines:159-169)"", ""result"": ""    value*=16;\n    c&=0xff;\n    if (value > (unsigned int) (INT_MAX-hex_digits[c]))\n      break;\n    value+=hex_digits[c];\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(0);\n  } while (hex_digits[c] >= 0);\n  return(value);\n}\n\n""}]","1. **Trigger**: A crafted XBM file with oversized `rows`/`columns` in the header is processed by `ReadXBMImage()` (coders/xbm.c:345-375). 2. **Loop Execution**: The loop iterates based on the header's dimensions (coders/xbm.c:345, 365), calling `XBMInteger()` to read data. 3. **EOF Handling**: `XBMInteger()` returns 0 on EOF (coders/xbm.c:159) instead of signaling an error. 4. **Misleading Value**: The returned 0 is treated as valid input, causing the loop to continue processing until all claimed rows/columns are exhausted (coders/xbm.c:347-355, 367-375). 5. **CPU Exhaustion**: The loop runs for an excessive number of iterations, consuming CPU resources. 6. **Patch Flaw**: The `c < 0` check in the patch is ineffective because `XBMInteger()` returns an `unsigned int`, making `c` (an `int`) never negative even on EOF.",0.92,./github/other_context/CVE-2017-14175
10,CVE-2018-11597,CWE-674,c_cpp,Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via a Buffer Overflow during syntax parsing because of a missing check for stack exhaustion with many '{' characters in jsparse.c.,https://github.com/espruino/Espruino/commit/51380baf17241728b6d48cdb84140b931e3e3cc5,Fix stack overflow if interpreting a file full of '{' (fix #1448),1,"[{""func_name"": ""jspeStatement"", ""file_path"": ""src/jsparse.c"", ""func_code"": ""NO_INLINE JsVar *jspeStatement() {\n#ifdef USE_DEBUGGER\n  if (execInfo.execute&EXEC_DEBUGGER_NEXT_LINE &&\n      lex->tk!=';' &&\n      JSP_SHOULD_EXECUTE) {\n    lex->tokenLastStart = jsvStringIteratorGetIndex(&lex->tokenStart.it)-1;\n    jsiDebuggerLoop();\n  }\n#endif\n  if (lex->tk==LEX_ID ||\n      lex->tk==LEX_INT ||\n      lex->tk==LEX_FLOAT ||\n      lex->tk==LEX_STR ||\n      lex->tk==LEX_TEMPLATE_LITERAL ||\n      lex->tk==LEX_REGEX ||\n      lex->tk==LEX_R_NEW ||\n      lex->tk==LEX_R_NULL ||\n      lex->tk==LEX_R_UNDEFINED ||\n      lex->tk==LEX_R_TRUE ||\n      lex->tk==LEX_R_FALSE ||\n      lex->tk==LEX_R_THIS ||\n      lex->tk==LEX_R_DELETE ||\n      lex->tk==LEX_R_TYPEOF ||\n      lex->tk==LEX_R_VOID ||\n      lex->tk==LEX_R_SUPER ||\n      lex->tk==LEX_PLUSPLUS ||\n      lex->tk==LEX_MINUSMINUS ||\n      lex->tk=='!' ||\n      lex->tk=='-' ||\n      lex->tk=='+' ||\n      lex->tk=='~' ||\n      lex->tk=='[' ||\n      lex->tk=='(') {\n    /* Execute a simple statement that only contains basic arithmetic... */\n    return jspeExpression();\n  } else if (lex->tk=='{') {\n    /* A block of code */\n    jspeBlock();\n    return 0;\n  } else if (lex->tk==';') {\n    /* Empty statement - to allow things like ;;; */\n    JSP_ASSERT_MATCH(';');\n    return 0;\n  } else if (lex->tk==LEX_R_VAR ||\n            lex->tk==LEX_R_LET ||\n            lex->tk==LEX_R_CONST) {\n    return jspeStatementVar();\n  } else if (lex->tk==LEX_R_IF) {\n    return jspeStatementIf();\n  } else if (lex->tk==LEX_R_DO) {\n    return jspeStatementDoOrWhile(false);\n  } else if (lex->tk==LEX_R_WHILE) {\n    return jspeStatementDoOrWhile(true);\n  } else if (lex->tk==LEX_R_FOR) {\n    return jspeStatementFor();\n  } else if (lex->tk==LEX_R_TRY) {\n    return jspeStatementTry();\n  } else if (lex->tk==LEX_R_RETURN) {\n    return jspeStatementReturn();\n  } else if (lex->tk==LEX_R_THROW) {\n    return jspeStatementThrow();\n  } else if (lex->tk==LEX_R_FUNCTION) {\n    return jspeStatementFunctionDecl(false/* function */);\n#ifndef SAVE_ON_FLASH\n  } else if (lex->tk==LEX_R_CLASS) {\n      return jspeStatementFunctionDecl(true/* class */);\n#endif\n  } else if (lex->tk==LEX_R_CONTINUE) {\n    JSP_ASSERT_MATCH(LEX_R_CONTINUE);\n    if (JSP_SHOULD_EXECUTE) {\n      if (!(execInfo.execute & EXEC_IN_LOOP))\n        jsExceptionHere(JSET_SYNTAXERROR, \""CONTINUE statement outside of FOR or WHILE loop\"");\n      else\n        execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_CONTINUE;\n    }\n  } else if (lex->tk==LEX_R_BREAK) {\n    JSP_ASSERT_MATCH(LEX_R_BREAK);\n    if (JSP_SHOULD_EXECUTE) {\n      if (!(execInfo.execute & (EXEC_IN_LOOP|EXEC_IN_SWITCH)))\n        jsExceptionHere(JSET_SYNTAXERROR, \""BREAK statement outside of SWITCH, FOR or WHILE loop\"");\n      else\n        execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_BREAK;\n    }\n  } else if (lex->tk==LEX_R_SWITCH) {\n    return jspeStatementSwitch();\n  } else if (lex->tk==LEX_R_DEBUGGER) {\n    JSP_ASSERT_MATCH(LEX_R_DEBUGGER);\n#ifdef USE_DEBUGGER\n    if (JSP_SHOULD_EXECUTE)\n      jsiDebuggerLoop();\n#endif\n  } else JSP_MATCH(LEX_EOF);\n  return 0;\n}"", ""target"": 0}]","[{""func_name"": ""jspeStatement"", ""file_path"": ""src/jsparse.c"", ""func_code"": ""NO_INLINE JsVar *jspeStatement() {\n#ifdef USE_DEBUGGER\n  if (execInfo.execute&EXEC_DEBUGGER_NEXT_LINE &&\n      lex->tk!=';' &&\n      JSP_SHOULD_EXECUTE) {\n    lex->tokenLastStart = jsvStringIteratorGetIndex(&lex->tokenStart.it)-1;\n    jsiDebuggerLoop();\n  }\n#endif\n  if (lex->tk==LEX_ID ||\n      lex->tk==LEX_INT ||\n      lex->tk==LEX_FLOAT ||\n      lex->tk==LEX_STR ||\n      lex->tk==LEX_TEMPLATE_LITERAL ||\n      lex->tk==LEX_REGEX ||\n      lex->tk==LEX_R_NEW ||\n      lex->tk==LEX_R_NULL ||\n      lex->tk==LEX_R_UNDEFINED ||\n      lex->tk==LEX_R_TRUE ||\n      lex->tk==LEX_R_FALSE ||\n      lex->tk==LEX_R_THIS ||\n      lex->tk==LEX_R_DELETE ||\n      lex->tk==LEX_R_TYPEOF ||\n      lex->tk==LEX_R_VOID ||\n      lex->tk==LEX_R_SUPER ||\n      lex->tk==LEX_PLUSPLUS ||\n      lex->tk==LEX_MINUSMINUS ||\n      lex->tk=='!' ||\n      lex->tk=='-' ||\n      lex->tk=='+' ||\n      lex->tk=='~' ||\n      lex->tk=='[' ||\n      lex->tk=='(') {\n    /* Execute a simple statement that only contains basic arithmetic... */\n    return jspeExpression();\n  } else if (lex->tk=='{') {\n    /* A block of code */\n    if (!jspCheckStackPosition()) return 0;\n    jspeBlock();\n    return 0;\n  } else if (lex->tk==';') {\n    /* Empty statement - to allow things like ;;; */\n    JSP_ASSERT_MATCH(';');\n    return 0;\n  } else if (lex->tk==LEX_R_VAR ||\n            lex->tk==LEX_R_LET ||\n            lex->tk==LEX_R_CONST) {\n    return jspeStatementVar();\n  } else if (lex->tk==LEX_R_IF) {\n    return jspeStatementIf();\n  } else if (lex->tk==LEX_R_DO) {\n    return jspeStatementDoOrWhile(false);\n  } else if (lex->tk==LEX_R_WHILE) {\n    return jspeStatementDoOrWhile(true);\n  } else if (lex->tk==LEX_R_FOR) {\n    return jspeStatementFor();\n  } else if (lex->tk==LEX_R_TRY) {\n    return jspeStatementTry();\n  } else if (lex->tk==LEX_R_RETURN) {\n    return jspeStatementReturn();\n  } else if (lex->tk==LEX_R_THROW) {\n    return jspeStatementThrow();\n  } else if (lex->tk==LEX_R_FUNCTION) {\n    return jspeStatementFunctionDecl(false/* function */);\n#ifndef SAVE_ON_FLASH\n  } else if (lex->tk==LEX_R_CLASS) {\n      return jspeStatementFunctionDecl(true/* class */);\n#endif\n  } else if (lex->tk==LEX_R_CONTINUE) {\n    JSP_ASSERT_MATCH(LEX_R_CONTINUE);\n    if (JSP_SHOULD_EXECUTE) {\n      if (!(execInfo.execute & EXEC_IN_LOOP))\n        jsExceptionHere(JSET_SYNTAXERROR, \""CONTINUE statement outside of FOR or WHILE loop\"");\n      else\n        execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_CONTINUE;\n    }\n  } else if (lex->tk==LEX_R_BREAK) {\n    JSP_ASSERT_MATCH(LEX_R_BREAK);\n    if (JSP_SHOULD_EXECUTE) {\n      if (!(execInfo.execute & (EXEC_IN_LOOP|EXEC_IN_SWITCH)))\n        jsExceptionHere(JSET_SYNTAXERROR, \""BREAK statement outside of SWITCH, FOR or WHILE loop\"");\n      else\n        execInfo.execute = (execInfo.execute & (JsExecFlags)~EXEC_RUN_MASK) | EXEC_BREAK;\n    }\n  } else if (lex->tk==LEX_R_SWITCH) {\n    return jspeStatementSwitch();\n  } else if (lex->tk==LEX_R_DEBUGGER) {\n    JSP_ASSERT_MATCH(LEX_R_DEBUGGER);\n#ifdef USE_DEBUGGER\n    if (JSP_SHOULD_EXECUTE)\n      jsiDebuggerLoop();\n#endif\n  } else JSP_MATCH(LEX_EOF);\n  return 0;\n}""}]","{""function"": 3}","[{""source"": ""func_info(file:jsparse.c, func:jspCheckStackPosition)"", ""result"": [{""code"": ""bool jspCheckStackPosition() {\n  if (jsuGetFreeStack() < 512) { // giving us 512 bytes leeway\n    jsExceptionHere(JSET_ERROR, \""Too much recursion - the stack is about to overflow\"");\n    jspSetInterrupted(true);\n    return false;\n  }\n  return true;\n}"", ""start_line"": 218, ""end_line"": 225, ""full_name"": ""jspCheckStackPosition"", ""file_path"": ""src/jsparse.c""}]}, {""source"": ""func_info(file:jsparse.c, func:jspeBlock)"", ""result"": [{""code"": ""NO_INLINE void jspeBlock() {\n  JSP_MATCH_WITH_RETURN('{',);\n  jspeBlockNoBrackets();\n  if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN('}',);\n  return;\n}"", ""start_line"": 2093, ""end_line"": 2098, ""full_name"": ""jspeBlock"", ""file_path"": ""src/jsparse.c""}]}, {""source"": ""func_info(file:jsparse.c, func:jspeBlockNoBrackets)"", ""result"": [{""code"": ""NO_INLINE void jspeBlockNoBrackets() {\n  if (JSP_SHOULD_EXECUTE) {\n    while (lex->tk && lex->tk!='}') {\n      JsVar *a = jspeStatement();\n      jsvCheckReferenceError(a);\n      jsvUnLock(a);\n      if (JSP_HAS_ERROR) {\n        if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {\n          execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);\n          JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);\n          if (stackTrace) {\n            jsvAppendPrintf(stackTrace, \""at \"");\n            jspAppendStackTrace(stackTrace);\n            jsvUnLock(stackTrace);\n          }\n        }\n      }\n      if (JSP_SHOULDNT_PARSE)\n        return;\n      if (!JSP_SHOULD_EXECUTE) {\n        jspeSkipBlock();\n        return;\n      }\n    }\n  } else {\n    jspeSkipBlock();\n  }\n  return;\n}"", ""start_line"": 2062, ""end_line"": 2090, ""full_name"": ""jspeBlockNoBrackets"", ""file_path"": ""src/jsparse.c""}]}]","src/jsparse.c:2721: Missing stack check in jspeStatement() before calling jspeBlock() allowed excessive recursion. src/jsparse.c:2093: jspeBlock() calls jspeBlockNoBrackets(). src/jsparse.c:2062: jspeBlockNoBrackets() loops, calling jspeStatement() for each statement, which can re-trigger jspeBlock() on nested '{', creating recursion. Stack exhaustion occurs when many '{' are parsed without checks.",0.95,./github/other_context/CVE-2018-11597
11,CVE-2018-16789,CWE-835,c_cpp,"libhttp/url.c in shellinabox through 2.20 has an implementation flaw in the HTTP request parsing logic. By sending a crafted multipart/form-data HTTP request, an attacker could exploit this to force shellinaboxd into an infinite loop, exhausting available CPU resources and taking the service down.",https://github.com/shellinabox/shellinabox/commit/4f0ecc31ac6f985e0dd3f5a52cbfc0e9251f6361,Rolling code for version 2.21,1,"[{""func_name"": ""urlParsePostBody"", ""file_path"": ""libhttp/url.c"", ""func_code"": ""static void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \""content-type\"");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \""application/x-www-form-urlencoded\"")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \""multipart/form-data\"")) {\n    const char *boundary   = getFromHashMap(&contentType, \""boundary\"");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \""--\"")) != NULL) ||\n            (ptr = urlMemstr(part, len, \""\\r\\n--\"")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \""\\r\\n\"")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\""[http] Ignoring prologue before \\\""multipart/form-data\\\""!\"");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \""--\\r\\n\"")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\""[http] Ignoring epilogue past end of \\\""multipart/\""\n\t\t\t\t     \""form-data\\\""!\"");\n              }\n            }\n          }\n        }\n      }\n      if (lastPart) {\n        warn(\""[http] Missing final \\\""boundary\\\"" for \\\""multipart/form-data\\\""!\"");\n      }\n    } else {\n      warn(\""[http] Missing \\\""boundary\\\"" information for \\\""multipart/form-data\\\""!\"");\n    }\n  }\n  destroyHashMap(&contentType);\n}"", ""target"": 0}]","[{""func_name"": ""urlParsePostBody"", ""file_path"": ""libhttp/url.c"", ""func_code"": ""static void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \""content-type\"");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \""application/x-www-form-urlencoded\"")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \""multipart/form-data\"")) {\n    const char *boundary   = getFromHashMap(&contentType, \""boundary\"");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \""--\"")) != NULL) ||\n            (ptr = urlMemstr(part, len, \""\\r\\n--\"")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \""\\r\\n\"")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\""[http] Ignoring prologue before \\\""multipart/form-data\\\""!\"");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \""--\\r\\n\"")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\""[http] Ignoring epilogue past end of \\\""multipart/\""\n\t\t\t\t     \""form-data\\\""!\"");\n              }\n            }\n          }\n        }\n        /* elf-2018.09.09: Detection of broken multipart/form-data\n           fixes DoS vulnerability.\n\n           On 9/9/18 10:43 AM, Imre Rad wrote:\n           Hi Markus, Marc!\n\n           I identified a vulnerability today in Shellinabox, it is\n           remote a denial of service, shellinaboxd eating up 100% cpu\n           and not processing subsequent requests after the attack was\n           mounted.\n        */\n        else {\n          warn (\""[http] Ignorning broken multipart/form-data\"");\n          break;\n        }\n      }\n      if (lastPart) {\n        warn(\""[http] Missing final \\\""boundary\\\"" for \\\""multipart/form-data\\\""!\"");\n      }\n    } else {\n      warn(\""[http] Missing \\\""boundary\\\"" information for \\\""multipart/form-data\\\""!\"");\n    }\n  }\n  destroyHashMap(&contentType);\n}""}]","{""code"": 1}","[{""source"": ""code_info(file:url.c, lines:300-330)"", ""result"": ""                  info(\""[http] Ignoring prologue before \\\""multipart/form-data\\\""!\"");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \""--\\r\\n\"")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\""[http] Ignoring epilogue past end of \\\""multipart/\""\n\t\t\t\t     \""form-data\\\""!\"");\n              }\n            }\n          }\n        }\n      }\n      if (lastPart) {\n        warn(\""[http] Missing final \\\""boundary\\\"" for \\\""multipart/form-data\\\""!\"");\n      }\n    } else {\n      warn(\""[http] Missing \\\""boundary\\\"" information for \\\""multipart/form-data\\\""!\"");\n    }\n  }\n  destroyHashMap(&contentType);\n}\n\nstruct URL *newURL(const struct HttpConnection *http,\n                   const char *buf, int len) {\n  struct URL *url;\n  check(url = malloc(sizeof(struct URL)));\n  initURL(url, http, buf, len);\n""}]","The infinite loop occurs due to incomplete validation of multipart/form-data boundaries during HTTP request parsing. The original code (libhttp/url.c:300-330) processes multipart data by checking for expected boundaries (e.g., ""--\r\n"") but lacks a safeguard to terminate processing when invalid data is encountered. This allows crafted requests to bypass boundary checks, causing the loop to run indefinitely. The patch (libhttp/url.c:314-325) adds an `else` clause to detect and break processing of malformed data, preventing the infinite loop.",1.0,./github/other_context/CVE-2018-16789
12,CVE-2018-19963,CWE-617,c_cpp,An issue was discovered in Xen 4.11 allowing HVM guest OS users to cause a denial of service (host OS crash) or possibly gain host OS privileges because x86 IOREQ server resource accounting (for external emulators) was mishandled.,https://github.com/xen-project/xen/commit/f6b6ae78679b363ff670a9c125077c436dabd608,"x86/hvm/ioreq: fix page referencing\n\nThe code does not take a page reference in hvm_alloc_ioreq_mfn(), only a\ntype reference. This can lead to a situation where a malicious domain with\nXSM_DM_PRIV can engineer a sequence as follows:\n\n- create IOREQ server: no pages as yet.\n- acquire resource: page allocated, total 0.\n- decrease reservation: -1 ref, total -1.\n\nThis will cause Xen to hit a BUG_ON() in free_domheap_pages().\n\nThis patch fixes the issue by changing the call to get_page_type() in\nhvm_alloc_ioreq_mfn() to a call to get_page_and_type(). This change\nin turn requires an extra put_page() in hvm_free_ioreq_mfn() in the case\nthat _PGC_allocated is still set (i.e. a decrease reservation has not\noccurred) to avoid the page being leaked.\n\nThis is part of XSA-276.\n\nReported-by: Julien Grall <julien.grall@arm.com>\nSigned-off-by: Paul Durrant <paul.durrant@citrix.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>",2,"[{""func_name"": ""hvm_free_ioreq_mfn"", ""file_path"": ""xen/arch/x86/hvm/ioreq.c"", ""func_code"": ""static void hvm_free_ioreq_mfn(struct hvm_ioreq_server *s, bool buf)\n{\n    struct hvm_ioreq_page *iorp = buf ? &s->bufioreq : &s->ioreq;\n\n    if ( !iorp->page )\n        return;\n\n    unmap_domain_page_global(iorp->va);\n    iorp->va = NULL;\n\n    put_page_and_type(iorp->page);\n    iorp->page = NULL;\n}"", ""target"": 0}, {""func_name"": ""hvm_alloc_ioreq_mfn"", ""file_path"": ""xen/arch/x86/hvm/ioreq.c"", ""func_code"": ""static int hvm_alloc_ioreq_mfn(struct hvm_ioreq_server *s, bool buf)\n{\n    struct hvm_ioreq_page *iorp = buf ? &s->bufioreq : &s->ioreq;\n\n    if ( iorp->page )\n    {\n        /*\n         * If a guest frame has already been mapped (which may happen\n         * on demand if hvm_get_ioreq_server_info() is called), then\n         * allocating a page is not permitted.\n         */\n        if ( !gfn_eq(iorp->gfn, INVALID_GFN) )\n            return -EPERM;\n\n        return 0;\n    }\n\n    /*\n     * Allocated IOREQ server pages are assigned to the emulating\n     * domain, not the target domain. This is safe because the emulating\n     * domain cannot be destroyed until the ioreq server is destroyed.\n     * Also we must use MEMF_no_refcount otherwise page allocation\n     * could fail if the emulating domain has already reached its\n     * maximum allocation.\n     */\n    iorp->page = alloc_domheap_page(s->emulator, MEMF_no_refcount);\n\n    if ( !iorp->page )\n        return -ENOMEM;\n\n    if ( !get_page_type(iorp->page, PGT_writable_page) )\n        goto fail1;\n\n    iorp->va = __map_domain_page_global(iorp->page);\n    if ( !iorp->va )\n        goto fail2;\n\n    clear_page(iorp->va);\n    return 0;\n\n fail2:\n    put_page_type(iorp->page);\n\n fail1:\n    put_page(iorp->page);\n    iorp->page = NULL;\n\n    return -ENOMEM;\n}"", ""target"": 0}]","[{""func_name"": ""hvm_free_ioreq_mfn"", ""file_path"": ""xen/arch/x86/hvm/ioreq.c"", ""func_code"": ""static void hvm_free_ioreq_mfn(struct hvm_ioreq_server *s, bool buf)\n{\n    struct hvm_ioreq_page *iorp = buf ? &s->bufioreq : &s->ioreq;\n    struct page_info *page = iorp->page;\n\n    if ( !page )\n        return;\n\n    iorp->page = NULL;\n\n    unmap_domain_page_global(iorp->va);\n    iorp->va = NULL;\n\n    /*\n     * Check whether we need to clear the allocation reference before\n     * dropping the explicit references taken by get_page_and_type().\n     */\n    if ( test_and_clear_bit(_PGC_allocated, &page->count_info) )\n        put_page(page);\n\n    put_page_and_type(page);\n}""}, {""func_name"": ""hvm_alloc_ioreq_mfn"", ""file_path"": ""xen/arch/x86/hvm/ioreq.c"", ""func_code"": ""static int hvm_alloc_ioreq_mfn(struct hvm_ioreq_server *s, bool buf)\n{\n    struct hvm_ioreq_page *iorp = buf ? &s->bufioreq : &s->ioreq;\n    struct page_info *page;\n\n    if ( iorp->page )\n    {\n        /*\n         * If a guest frame has already been mapped (which may happen\n         * on demand if hvm_get_ioreq_server_info() is called), then\n         * allocating a page is not permitted.\n         */\n        if ( !gfn_eq(iorp->gfn, INVALID_GFN) )\n            return -EPERM;\n\n        return 0;\n    }\n\n    /*\n     * Allocated IOREQ server pages are assigned to the emulating\n     * domain, not the target domain. This is safe because the emulating\n     * domain cannot be destroyed until the ioreq server is destroyed.\n     * Also we must use MEMF_no_refcount otherwise page allocation\n     * could fail if the emulating domain has already reached its\n     * maximum allocation.\n     */\n    page = alloc_domheap_page(s->emulator, MEMF_no_refcount);\n\n    if ( !page )\n        return -ENOMEM;\n\n    if ( !get_page_and_type(page, s->emulator, PGT_writable_page) )\n    {\n        /*\n         * The domain can't possibly know about this page yet, so failure\n         * here is a clear indication of something fishy going on.\n         */\n        domain_crash(s->emulator);\n        return -ENODATA;\n    }\n\n    iorp->va = __map_domain_page_global(page);\n    if ( !iorp->va )\n        goto fail;\n\n    iorp->page = page;\n    clear_page(iorp->va);\n    return 0;\n\n fail:\n    if ( test_and_clear_bit(_PGC_allocated, &page->count_info) )\n        put_page(page);\n    put_page_and_type(page);\n\n    return -ENOMEM;\n}""}]","{""function"": 2, ""caller"": 1}","[{""source"": ""func_info(func:get_page_type)"", ""result"": [{""code"": ""int get_page_type(struct page_info *page, unsigned long type)\n{\n    return 1;\n}"", ""start_line"": 1388, ""end_line"": 1391, ""full_name"": ""get_page_type"", ""file_path"": ""xen/arch/arm/mm.c""}, {""code"": ""int get_page_type(struct page_info *page, unsigned long type)\n{\n    int rc = _get_page_type(page, type, false);\n\n    if ( likely(rc == 0) )\n        return 1;\n    ASSERT(rc != -EINTR && rc != -ERESTART);\n    return 0;\n}"", ""start_line"": 2848, ""end_line"": 2856, ""full_name"": ""get_page_type<duplicate>0"", ""file_path"": ""xen/arch/x86/mm.c""}]}, {""source"": ""func_info(func:get_page_and_type)"", ""result"": [{""code"": ""static inline int get_page_and_type(struct page_info *page,\n                                    struct domain *domain,\n                                    unsigned long type)\n{\n    int rc = get_page(page, domain);\n\n    if ( likely(rc) && unlikely(!get_page_type(page, type)) )\n    {\n        put_page(page);\n        rc = 0;\n    }\n\n    return rc;\n}"", ""start_line"": 310, ""end_line"": 323, ""full_name"": ""get_page_and_type"", ""file_path"": ""xen/include/asm-arm/p2m.h""}, {""code"": ""static inline int get_page_and_type(struct page_info *page,\n                                    struct domain *domain,\n                                    unsigned long type)\n{\n    int rc = get_page(page, domain);\n\n    if ( likely(rc) && unlikely(!get_page_type(page, type)) )\n    {\n        put_page(page);\n        rc = 0;\n    }\n\n    return rc;\n}"", ""start_line"": 412, ""end_line"": 425, ""full_name"": ""get_page_and_type<duplicate>0"", ""file_path"": ""xen/include/asm-x86/mm.h""}]}, {""source"": ""caller_info(file:ioreq.c, func:hvm_alloc_ioreq_mfn)"", ""result"": [{""call_line"": 623, ""call_code"": ""hvm_alloc_ioreq_mfn(s, false)"", ""caller_code"": ""static int hvm_ioreq_server_alloc_pages(struct hvm_ioreq_server *s)\n{\n    int rc;\n\n    rc = hvm_alloc_ioreq_mfn(s, false);\n\n    if ( !rc && (s->bufioreq_handling != HVM_IOREQSRV_BUFIOREQ_OFF) )\n        rc = hvm_alloc_ioreq_mfn(s, true);\n\n    if ( rc )\n        hvm_free_ioreq_mfn(s, false);\n\n    return rc;\n}"", ""caller_start"": 619, ""file_path"": ""xen/arch/x86/hvm/ioreq.c""}, {""call_line"": 626, ""call_code"": ""hvm_alloc_ioreq_mfn(s, true)"", ""caller_code"": ""static int hvm_ioreq_server_alloc_pages(struct hvm_ioreq_server *s)\n{\n    int rc;\n\n    rc = hvm_alloc_ioreq_mfn(s, false);\n\n    if ( !rc && (s->bufioreq_handling != HVM_IOREQSRV_BUFIOREQ_OFF) )\n        rc = hvm_alloc_ioreq_mfn(s, true);\n\n    if ( rc )\n        hvm_free_ioreq_mfn(s, false);\n\n    return rc;\n}"", ""caller_start"": 619, ""file_path"": ""xen/arch/x86/hvm/ioreq.c""}]}]","xen/arch/x86/hvm/ioreq.c:380 (original use of get_page_type() without page reference). The function alloc_domheap_page() with MEMF_no_refcount avoids initial reference increment, and get_page_type() (xen/arch/x86/mm.c:2848) does not increment the page reference count. This allows a malicious domain to decrement the reservation count beyond zero, causing a negative reference count. The fix in hvm_alloc_ioreq_mfn() now uses get_page_and_type() (xen/include/asm-x86/mm.h:412), which first calls get_page() to increment the reference count, preventing underflow.",0.95,./github/other_context/CVE-2018-19963
13,CVE-2019-1000020,CWE-835,c_cpp,"libarchive version commit 5a98dcf8a86364b3c2c469c85b93647dfb139961 onwards (version v2.8.0 onwards) contains a CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop') vulnerability in ISO9660 parser, archive_read_support_format_iso9660.c, read_CE()/parse_rockridge() that can result in DoS by infinite loop. This attack appears to be exploitable via the victim opening a specially crafted ISO9660 file.",https://github.com/libarchive/libarchive/commit/8312eaa576014cd9b965012af51bc1f967b12423,"iso9660: Fail when expected Rockridge extensions is missing\n\nA corrupted or malicious ISO9660 image can cause read_CE() to loop\nforever.\n\nread_CE() calls parse_rockridge(), expecting a Rockridge extension\nto be read. However, parse_rockridge() is structured as a while\nloop starting with a sanity check, and if the sanity check fails\nbefore the loop has run, the function returns ARCHIVE_OK without\nadvancing the position in the file. This causes read_CE() to retry\nindefinitely.\n\nMake parse_rockridge() return ARCHIVE_WARN if it didn't read an\nextension. As someone with no real knowledge of the format, this\nseems more apt than ARCHIVE_FATAL, but both the call-sites escalate\nit to a fatal error immediately anyway.\n\nFound with a combination of AFL, afl-rb (FairFuzz) and qsym.",1,"[{""func_name"": ""parse_rockridge"", ""file_path"": ""libarchive/archive_read_support_format_iso9660.c"", ""func_code"": ""static int\nparse_rockridge(struct archive_read *a, struct file_info *file,\n    const unsigned char *p, const unsigned char *end)\n{\n\tstruct iso9660 *iso9660;\n\n\tiso9660 = (struct iso9660 *)(a->format->data);\n\n\twhile (p + 4 <= end  /* Enough space for another entry. */\n\t    && p[0] >= 'A' && p[0] <= 'Z' /* Sanity-check 1st char of name. */\n\t    && p[1] >= 'A' && p[1] <= 'Z' /* Sanity-check 2nd char of name. */\n\t    && p[2] >= 4 /* Sanity-check length. */\n\t    && p + p[2] <= end) { /* Sanity-check length. */\n\t\tconst unsigned char *data = p + 4;\n\t\tint data_length = p[2] - 4;\n\t\tint version = p[3];\n\n\t\tswitch(p[0]) {\n\t\tcase 'C':\n\t\t\tif (p[1] == 'E') {\n\t\t\t\tif (version == 1 && data_length == 24) {\n\t\t\t\t\t/*\n\t\t\t\t\t * CE extension comprises:\n\t\t\t\t\t *   8 byte sector containing extension\n\t\t\t\t\t *   8 byte offset w/in above sector\n\t\t\t\t\t *   8 byte length of continuation\n\t\t\t\t\t */\n\t\t\t\t\tint32_t location =\n\t\t\t\t\t    archive_le32dec(data);\n\t\t\t\t\tfile->ce_offset =\n\t\t\t\t\t    archive_le32dec(data+8);\n\t\t\t\t\tfile->ce_size =\n\t\t\t\t\t    archive_le32dec(data+16);\n\t\t\t\t\tif (register_CE(a, location, file)\n\t\t\t\t\t    != ARCHIVE_OK)\n\t\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'L') {\n\t\t\t\tif (version == 1 && data_length == 8) {\n\t\t\t\t\tfile->cl_offset = (uint64_t)\n\t\t\t\t\t    iso9660->logical_block_size *\n\t\t\t\t\t    (uint64_t)archive_le32dec(data);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tif (p[1] == 'M') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_NM1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\t/*\n\t\t\t * PD extension is padding;\n\t\t\t * contents are always ignored.\n\t\t\t *\n\t\t\t * PL extension won't appear;\n\t\t\t * contents are always ignored.\n\t\t\t */\n\t\t\tif (p[1] == 'N') {\n\t\t\t\tif (version == 1 && data_length == 16) {\n\t\t\t\t\tfile->rdev = toi(data,4);\n\t\t\t\t\tfile->rdev <<= 32;\n\t\t\t\t\tfile->rdev |= toi(data + 8, 4);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'X') {\n\t\t\t\t/*\n\t\t\t\t * PX extension comprises:\n\t\t\t\t *   8 bytes for mode,\n\t\t\t\t *   8 bytes for nlinks,\n\t\t\t\t *   8 bytes for uid,\n\t\t\t\t *   8 bytes for gid,\n\t\t\t\t *   8 bytes for inode.\n\t\t\t\t */\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tif (data_length >= 8)\n\t\t\t\t\t\tfile->mode\n\t\t\t\t\t\t    = toi(data, 4);\n\t\t\t\t\tif (data_length >= 16)\n\t\t\t\t\t\tfile->nlinks\n\t\t\t\t\t\t    = toi(data + 8, 4);\n\t\t\t\t\tif (data_length >= 24)\n\t\t\t\t\t\tfile->uid\n\t\t\t\t\t\t    = toi(data + 16, 4);\n\t\t\t\t\tif (data_length >= 32)\n\t\t\t\t\t\tfile->gid\n\t\t\t\t\t\t    = toi(data + 24, 4);\n\t\t\t\t\tif (data_length >= 40)\n\t\t\t\t\t\tfile->number\n\t\t\t\t\t\t    = toi(data + 32, 4);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif (p[1] == 'E' && version == 1) {\n\t\t\t\tfile->re = 1;\n\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t}\n\t\t\telse if (p[1] == 'R' && version == 1) {\n\t\t\t\t/*\n\t\t\t\t * RR extension comprises:\n\t\t\t\t *    one byte flag value\n\t\t\t\t * This extension is obsolete,\n\t\t\t\t * so contents are always ignored.\n\t\t\t\t */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (p[1] == 'L') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_SL1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'T'\n\t\t\t    && data_length == 0 && version == 1) {\n\t\t\t\t/*\n\t\t\t\t * ST extension marks end of this\n\t\t\t\t * block of SUSP entries.\n\t\t\t\t *\n\t\t\t\t * It allows SUSP to coexist with\n\t\t\t\t * non-SUSP uses of the System\n\t\t\t\t * Use Area by placing non-SUSP data\n\t\t\t\t * after SUSP data.\n\t\t\t\t */\n\t\t\t\tiso9660->seenSUSP = 0;\n\t\t\t\tiso9660->seenRockridge = 0;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tif (p[1] == 'F') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_TF1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tif (p[1] == 'F') {\n\t\t\t\tif (version == 1)\n\t\t\t\t\tparse_rockridge_ZF1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tp += p[2];\n\t}\n\treturn (ARCHIVE_OK);\n}"", ""target"": 0}]","[{""func_name"": ""parse_rockridge"", ""file_path"": ""libarchive/archive_read_support_format_iso9660.c"", ""func_code"": ""static int\nparse_rockridge(struct archive_read *a, struct file_info *file,\n    const unsigned char *p, const unsigned char *end)\n{\n\tstruct iso9660 *iso9660;\n\tint entry_seen = 0;\n\n\tiso9660 = (struct iso9660 *)(a->format->data);\n\n\twhile (p + 4 <= end  /* Enough space for another entry. */\n\t    && p[0] >= 'A' && p[0] <= 'Z' /* Sanity-check 1st char of name. */\n\t    && p[1] >= 'A' && p[1] <= 'Z' /* Sanity-check 2nd char of name. */\n\t    && p[2] >= 4 /* Sanity-check length. */\n\t    && p + p[2] <= end) { /* Sanity-check length. */\n\t\tconst unsigned char *data = p + 4;\n\t\tint data_length = p[2] - 4;\n\t\tint version = p[3];\n\n\t\tswitch(p[0]) {\n\t\tcase 'C':\n\t\t\tif (p[1] == 'E') {\n\t\t\t\tif (version == 1 && data_length == 24) {\n\t\t\t\t\t/*\n\t\t\t\t\t * CE extension comprises:\n\t\t\t\t\t *   8 byte sector containing extension\n\t\t\t\t\t *   8 byte offset w/in above sector\n\t\t\t\t\t *   8 byte length of continuation\n\t\t\t\t\t */\n\t\t\t\t\tint32_t location =\n\t\t\t\t\t    archive_le32dec(data);\n\t\t\t\t\tfile->ce_offset =\n\t\t\t\t\t    archive_le32dec(data+8);\n\t\t\t\t\tfile->ce_size =\n\t\t\t\t\t    archive_le32dec(data+16);\n\t\t\t\t\tif (register_CE(a, location, file)\n\t\t\t\t\t    != ARCHIVE_OK)\n\t\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'L') {\n\t\t\t\tif (version == 1 && data_length == 8) {\n\t\t\t\t\tfile->cl_offset = (uint64_t)\n\t\t\t\t\t    iso9660->logical_block_size *\n\t\t\t\t\t    (uint64_t)archive_le32dec(data);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tif (p[1] == 'M') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_NM1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\t/*\n\t\t\t * PD extension is padding;\n\t\t\t * contents are always ignored.\n\t\t\t *\n\t\t\t * PL extension won't appear;\n\t\t\t * contents are always ignored.\n\t\t\t */\n\t\t\tif (p[1] == 'N') {\n\t\t\t\tif (version == 1 && data_length == 16) {\n\t\t\t\t\tfile->rdev = toi(data,4);\n\t\t\t\t\tfile->rdev <<= 32;\n\t\t\t\t\tfile->rdev |= toi(data + 8, 4);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'X') {\n\t\t\t\t/*\n\t\t\t\t * PX extension comprises:\n\t\t\t\t *   8 bytes for mode,\n\t\t\t\t *   8 bytes for nlinks,\n\t\t\t\t *   8 bytes for uid,\n\t\t\t\t *   8 bytes for gid,\n\t\t\t\t *   8 bytes for inode.\n\t\t\t\t */\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tif (data_length >= 8)\n\t\t\t\t\t\tfile->mode\n\t\t\t\t\t\t    = toi(data, 4);\n\t\t\t\t\tif (data_length >= 16)\n\t\t\t\t\t\tfile->nlinks\n\t\t\t\t\t\t    = toi(data + 8, 4);\n\t\t\t\t\tif (data_length >= 24)\n\t\t\t\t\t\tfile->uid\n\t\t\t\t\t\t    = toi(data + 16, 4);\n\t\t\t\t\tif (data_length >= 32)\n\t\t\t\t\t\tfile->gid\n\t\t\t\t\t\t    = toi(data + 24, 4);\n\t\t\t\t\tif (data_length >= 40)\n\t\t\t\t\t\tfile->number\n\t\t\t\t\t\t    = toi(data + 32, 4);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif (p[1] == 'E' && version == 1) {\n\t\t\t\tfile->re = 1;\n\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t}\n\t\t\telse if (p[1] == 'R' && version == 1) {\n\t\t\t\t/*\n\t\t\t\t * RR extension comprises:\n\t\t\t\t *    one byte flag value\n\t\t\t\t * This extension is obsolete,\n\t\t\t\t * so contents are always ignored.\n\t\t\t\t */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (p[1] == 'L') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_SL1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'T'\n\t\t\t    && data_length == 0 && version == 1) {\n\t\t\t\t/*\n\t\t\t\t * ST extension marks end of this\n\t\t\t\t * block of SUSP entries.\n\t\t\t\t *\n\t\t\t\t * It allows SUSP to coexist with\n\t\t\t\t * non-SUSP uses of the System\n\t\t\t\t * Use Area by placing non-SUSP data\n\t\t\t\t * after SUSP data.\n\t\t\t\t */\n\t\t\t\tiso9660->seenSUSP = 0;\n\t\t\t\tiso9660->seenRockridge = 0;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tif (p[1] == 'F') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_TF1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tif (p[1] == 'F') {\n\t\t\t\tif (version == 1)\n\t\t\t\t\tparse_rockridge_ZF1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tp += p[2];\n\t\tentry_seen = 1;\n\t}\n\n\tif (entry_seen)\n\t\treturn (ARCHIVE_OK);\n\telse {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t  \""Tried to parse Rockridge extensions, but none found\"");\n\t\treturn (ARCHIVE_WARN);\n\t}\n}""}]","{""caller"": 1, ""function"": 1}","[{""source"": ""caller_info(file:archive_read_support_format_iso9660.c, func:read_CE)"", ""result"": [{""call_line"": 1072, ""call_code"": ""read_CE(a, iso9660)"", ""caller_code"": ""static int\nread_children(struct archive_read *a, struct file_info *parent)\n{\n\tstruct iso9660 *iso9660;\n\tconst unsigned char *b, *p;\n\tstruct file_info *multi;\n\tsize_t step, skip_size;\n\n\tiso9660 = (struct iso9660 *)(a->format->data);\n\t/* flush any remaining bytes from the last round to ensure\n\t * we're positioned */\n\tif (iso9660->entry_bytes_unconsumed) {\n\t\t__archive_read_consume(a, iso9660->entry_bytes_unconsumed);\n\t\tiso9660->entry_bytes_unconsumed = 0;\n\t}\n\tif (iso9660->current_position > parent->offset) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \""Ignoring out-of-order directory (%s) %jd > %jd\"",\n\t\t    parent->name.s,\n\t\t    (intmax_t)iso9660->current_position,\n\t\t    (intmax_t)parent->offset);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (parent->offset + parent->size > iso9660->volume_size) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \""Directory is beyond end-of-media: %s\"",\n\t\t    parent->name.s);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (iso9660->current_position < parent-..."", ""caller_start"": 955, ""file_path"": ""libarchive/archive_read_support_format_iso9660.c""}]}, {""source"": ""func_info(file:archive_read_support_format_iso9660.c, func:read_CE)"", ""result"": [{""code"": ""static int\nread_CE(struct archive_read *a, struct iso9660 *iso9660)\n{\n\tstruct read_ce_queue *heap;\n\tconst unsigned char *b, *p, *end;\n\tstruct file_info *file;\n\tsize_t step;\n\tint r;\n\n\t/* Read data which RRIP \""CE\"" extension points. */\n\theap = &(iso9660->read_ce_req);\n\tstep = iso9660->logical_block_size;\n\twhile (heap->cnt &&\n\t    heap->reqs[0].offset == iso9660->current_position) {\n\t\tb = __archive_read_ahead(a, step, NULL);\n\t\tif (b == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \""Failed to read full block when scanning \""\n\t\t\t    \""ISO9660 directory list\"");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tdo {\n\t\t\tfile = heap->reqs[0].file;\n\t\t\tif (file->ce_offset + file->ce_size > step) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \""Malformed CE information\"");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tp = b + file->ce_offset;\n\t\t\tend = p + file->ce_size;\n\t\t\tnext_CE(heap);\n\t\t\tr = parse_rockridge(a, file, p, end);\n\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\treturn (..."", ""start_line"": 2379, ""end_line"": 2424, ""full_name"": ""read_CE"", ""file_path"": ""libarchive/archive_read_support_format_iso9660.c""}]}]","libarchive/archive_read_support_format_iso9660.c:2103-2259: parse_rockridge() previously returned ARCHIVE_OK without processing any Rockridge extensions. This allowed read_CE() (libarchive/archive_read_support_format_iso9660.c:2379-2424) to retry indefinitely, as it relied on parse_rockridge()'s return value to advance or terminate. The patch adds 'entry_seen' to return ARCHIVE_WARN when no extensions are found, breaking the infinite loop by triggering error handling in read_CE().",0.95,./github/other_context/CVE-2019-1000020
14,CVE-2019-18217,CWE-835,c_cpp,ProFTPD before 1.3.6b and 1.3.7rc before 1.3.7rc2 allows remote unauthenticated denial-of-service due to incorrect handling of overly long commands because main.c in a child process enters an infinite loop.,https://github.com/proftpd/proftpd/commit/518dc1a6e486291fa4f13d2caff0a8aec52d093e,Issue #846: Handle the case where a client tries to send too-large commands\nin an effort to DoS the server.,2,"[{""func_name"": ""pr_netio_read"", ""file_path"": ""src/netio.c"", ""func_code"": ""int pr_netio_read(pr_netio_stream_t *nstrm, char *buf, size_t buflen,\n    int bufmin) {\n  int bread = 0, total = 0;\n  const char *nstrm_mode;\n  pr_buffer_t *pbuf;\n  pool *tmp_pool;\n\n  /* Sanity check. */\n  if (nstrm == NULL ||\n      buf == NULL ||\n      buflen == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (nstrm->strm_fd == -1) {\n    errno = (nstrm->strm_errno ? nstrm->strm_errno : EBADF);\n    return -1;\n  }\n\n  if (bufmin < 1) {\n    bufmin = 1;\n  }\n\n  if (bufmin > 0 &&\n      (size_t) bufmin > buflen) {\n    bufmin = buflen;\n  }\n\n  nstrm_mode = netio_stream_mode(nstrm->strm_mode);\n\n  while (bufmin > 0) {\n    polling:\n\n    switch (pr_netio_poll(nstrm)) {\n      case 1:\n        return -2;\n\n      case -1:\n        return -1;\n\n      default:\n        do {\n          pr_signals_handle();\n\n          run_schedule();\n\n          switch (nstrm->strm_type) {\n            case PR_NETIO_STRM_CTRL:\n              if (ctrl_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for control %s stream\"",\n                  ctrl_netio->owner_name, nstrm_mode);\n                bread = (ctrl_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for control %s stream\"",\n                  default_ctrl_netio->owner_name, nstrm_mode);\n                bread = (default_ctrl_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n\n            case PR_NETIO_STRM_DATA:\n              if (XFER_ABORTED) {\n                break;\n              }\n\n              if (data_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for data %s stream\"", data_netio->owner_name,\n                  nstrm_mode);\n                bread = (data_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for data %s stream\"",\n                  default_data_netio->owner_name, nstrm_mode);\n                bread = (default_data_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n\n            case PR_NETIO_STRM_OTHR:\n              if (othr_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for other %s stream\"",\n                  othr_netio->owner_name, nstrm_mode);\n                bread = (othr_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for other %s stream\"",\n                  default_othr_netio->owner_name, nstrm_mode);\n                bread = (default_othr_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n          }\n\n#ifdef EAGAIN\n\t  if (bread == -1 &&\n              errno == EAGAIN) {\n            int xerrno = EAGAIN;\n\n            /* Treat this as an interrupted call, call pr_signals_handle()\n             * (which will delay for a few msecs because of EINTR), and try\n             * again.\n             *\n             * This should avoid a tightly spinning loop if read(2) returns\n             * EAGAIN, as on a data transfer (Bug#3639).\n             */\n\n            errno = EINTR;\n            pr_signals_handle();\n\n            errno = xerrno;\n            goto polling;\n          }\n#endif\n\n        } while (bread == -1 && errno == EINTR);\n        break;\n    }\n\n    if (bread == -1) {\n      nstrm->strm_errno = errno;\n      return -1;\n    }\n\n    /* EOF? */\n    if (bread == 0) {\n      if (nstrm->strm_type == PR_NETIO_STRM_CTRL) {\n        pr_trace_msg(trace_channel, 7,\n          \""read %d bytes from control stream fd %d, handling as EOF\"", bread,\n          nstrm->strm_fd);\n      }\n\n      nstrm->strm_errno = 0;\n      break;\n    }\n\n    /* Before we provide the data from the client, generate an event\n     * for any listeners which may want to examine this data.  To do this, we\n     * need to allocate a pr_buffer_t for sending the buffer data to the\n     * listeners.\n     *\n     * We could just use nstrm->strm_pool, but for a long-lived control\n     * connection, this would amount to a slow memory increase.  So instead,\n     * we create a subpool from the stream's pool, and allocate the\n     * pr_buffer_t out of that.  Then simply destroy the subpool when done.\n     */\n\n    tmp_pool = make_sub_pool(nstrm->strm_pool);\n    pbuf = pcalloc(tmp_pool, sizeof(pr_buffer_t));\n    pbuf->buf = buf;\n    pbuf->buflen = bread;\n    pbuf->current = pbuf->buf;\n    pbuf->remaining = 0;\n\n    switch (nstrm->strm_type) {\n      case PR_NETIO_STRM_CTRL:\n        pr_event_generate(\""core.ctrl-read\"", pbuf);\n        break;\n\n      case PR_NETIO_STRM_DATA:\n        pr_event_generate(\""core.data-read\"", pbuf);\n        break;\n\n      case PR_NETIO_STRM_OTHR:\n        pr_event_generate(\""core.othr-read\"", pbuf);\n        break;\n    }\n\n    /* The event listeners may have changed the data read in out. */\n    buf = pbuf->buf;\n    bread = pbuf->buflen - pbuf->remaining;\n    destroy_pool(tmp_pool);\n\n    buf += bread;\n    total += bread;\n    bufmin -= bread;\n    buflen -= bread;\n  }\n\n  session.total_raw_in += total;\n  return total;\n}"", ""target"": 0}, {""func_name"": ""pr_cmd_read"", ""file_path"": ""src/main.c"", ""func_code"": ""int pr_cmd_read(cmd_rec **res) {\n  static long cmd_bufsz = -1;\n  static char *cmd_buf = NULL;\n  int cmd_buflen;\n  char *ptr;\n\n  if (res == NULL) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (cmd_bufsz == -1) {\n    cmd_bufsz = get_max_cmd_sz();\n  }\n\n  if (cmd_buf == NULL) {\n    cmd_buf = pcalloc(session.pool, cmd_bufsz + 1);\n  }\n\n  while (TRUE) {\n    pr_signals_handle();\n\n    memset(cmd_buf, '\\0', cmd_bufsz);\n\n    cmd_buflen = pr_netio_telnet_gets2(cmd_buf, cmd_bufsz, session.c->instrm,\n      session.c->outstrm);\n    if (cmd_buflen < 0) {\n      if (errno == E2BIG) {\n        /* The client sent a too-long command which was ignored; give\n         * them another chance?\n         */\n        continue;\n      }\n\n      if (session.c->instrm->strm_errno == 0) {\n        pr_trace_msg(\""command\"", 6,\n          \""client sent EOF, closing control connection\"");\n      }\n\n      return -1;\n    }\n\n    break;\n  }\n\n  /* If the read length is less than the cmd_bufsz, then there is no need to\n   * truncate the buffer by inserting a NUL.\n   */\n  if (cmd_buflen > cmd_bufsz) {\n    pr_log_debug(DEBUG0, \""truncating incoming command length (%d bytes) to \""\n      \""CommandBufferSize %lu; use the CommandBufferSize directive to increase \""\n      \""the allowed command length\"", cmd_buflen, (unsigned long) cmd_bufsz);\n    cmd_buf[cmd_bufsz-1] = '\\0';\n  }\n\n  if (cmd_buflen > 0 &&\n      (cmd_buf[cmd_buflen-1] == '\\n' || cmd_buf[cmd_buflen-1] == '\\r')) {\n    cmd_buf[cmd_buflen-1] = '\\0';\n    cmd_buflen--;\n\n    if (cmd_buflen > 0 &&\n        (cmd_buf[cmd_buflen-1] == '\\n' || cmd_buf[cmd_buflen-1] =='\\r')) {\n      cmd_buf[cmd_buflen-1] = '\\0';\n      cmd_buflen--;\n    }\n  }\n\n  ptr = cmd_buf;\n  if (*ptr == '\\r') {\n    ptr++;\n  }\n\n  if (*ptr) {\n    int flags = 0;\n    cmd_rec *cmd;\n\n    /* If this is a SITE command, preserve embedded whitespace in the\n     * command parameters, in order to handle file names that have multiple\n     * spaces in the names.  Arguably this should be handled in the SITE\n     * command handlers themselves, via cmd->arg.  This small hack\n     * reduces the burden on SITE module developers, however.\n     */\n    if (strncasecmp(ptr, C_SITE, 4) == 0) {\n      flags |= PR_STR_FL_PRESERVE_WHITESPACE;\n    }\n\n    cmd = make_ftp_cmd(session.pool, ptr, cmd_buflen, flags);\n    if (cmd != NULL) {\n      *res = cmd;\n\n      if (pr_cmd_is_http(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \""HTTP\"";\n\n      } else if (pr_cmd_is_ssh2(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \""SSH2\"";\n\n      } else if (pr_cmd_is_smtp(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \""SMTP\"";\n\n      } else {\n        /* Assume that the client is sending valid FTP commands. */\n        cmd->is_ftp = TRUE;\n        cmd->protocol = \""FTP\"";\n      }\n    } \n  }\n\n  return 0;\n}"", ""target"": 0}]","[{""func_name"": ""pr_netio_read"", ""file_path"": ""src/netio.c"", ""func_code"": ""int pr_netio_read(pr_netio_stream_t *nstrm, char *buf, size_t buflen,\n    int bufmin) {\n  int bread = 0, total = 0;\n  const char *nstrm_mode;\n  pr_buffer_t *pbuf;\n  pool *tmp_pool;\n\n  /* Sanity check. */\n  if (nstrm == NULL ||\n      buf == NULL ||\n      buflen == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (nstrm->strm_fd == -1) {\n    errno = (nstrm->strm_errno ? nstrm->strm_errno : EBADF);\n    return -1;\n  }\n\n  if (bufmin < 1) {\n    bufmin = 1;\n  }\n\n  if (bufmin > 0 &&\n      (size_t) bufmin > buflen) {\n    bufmin = buflen;\n  }\n\n  nstrm_mode = netio_stream_mode(nstrm->strm_mode);\n\n  while (bufmin > 0) {\n    polling:\n\n    switch (pr_netio_poll(nstrm)) {\n      case 1:\n        return -2;\n\n      case -1:\n        return -1;\n\n      default:\n        do {\n          pr_signals_handle();\n\n          run_schedule();\n\n          switch (nstrm->strm_type) {\n            case PR_NETIO_STRM_CTRL:\n              if (ctrl_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for control %s stream\"",\n                  ctrl_netio->owner_name, nstrm_mode);\n                bread = (ctrl_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for control %s stream\"",\n                  default_ctrl_netio->owner_name, nstrm_mode);\n                bread = (default_ctrl_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n\n            case PR_NETIO_STRM_DATA:\n              if (XFER_ABORTED) {\n                break;\n              }\n\n              if (data_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for data %s stream\"", data_netio->owner_name,\n                  nstrm_mode);\n                bread = (data_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for data %s stream\"",\n                  default_data_netio->owner_name, nstrm_mode);\n                bread = (default_data_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n\n            case PR_NETIO_STRM_OTHR:\n              if (othr_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for other %s stream\"",\n                  othr_netio->owner_name, nstrm_mode);\n                bread = (othr_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \""using %s read() for other %s stream\"",\n                  default_othr_netio->owner_name, nstrm_mode);\n                bread = (default_othr_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n          }\n\n#ifdef EAGAIN\n\t  if (bread == -1 &&\n              errno == EAGAIN) {\n            int xerrno = EAGAIN;\n\n            /* Treat this as an interrupted call, call pr_signals_handle()\n             * (which will delay for a few msecs because of EINTR), and try\n             * again.\n             *\n             * This should avoid a tightly spinning loop if read(2) returns\n             * EAGAIN, as on a data transfer (Bug#3639).\n             */\n\n            errno = EINTR;\n            pr_signals_handle();\n\n            errno = xerrno;\n            goto polling;\n          }\n#endif\n\n        } while (bread == -1 && errno == EINTR);\n        break;\n    }\n\n    if (bread == -1) {\n      nstrm->strm_errno = errno;\n      return -1;\n    }\n\n    /* EOF? */\n    if (bread == 0) {\n      if (nstrm->strm_type == PR_NETIO_STRM_CTRL) {\n        pr_trace_msg(trace_channel, 7,\n          \""read %d bytes from control stream fd %d, handling as EOF\"", bread,\n          nstrm->strm_fd);\n      }\n\n      nstrm->strm_errno = 0;\n      errno = EOF;\n      break;\n    }\n\n    /* Before we provide the data from the client, generate an event\n     * for any listeners which may want to examine this data.  To do this, we\n     * need to allocate a pr_buffer_t for sending the buffer data to the\n     * listeners.\n     *\n     * We could just use nstrm->strm_pool, but for a long-lived control\n     * connection, this would amount to a slow memory increase.  So instead,\n     * we create a subpool from the stream's pool, and allocate the\n     * pr_buffer_t out of that.  Then simply destroy the subpool when done.\n     */\n\n    tmp_pool = make_sub_pool(nstrm->strm_pool);\n    pbuf = pcalloc(tmp_pool, sizeof(pr_buffer_t));\n    pbuf->buf = buf;\n    pbuf->buflen = bread;\n    pbuf->current = pbuf->buf;\n    pbuf->remaining = 0;\n\n    switch (nstrm->strm_type) {\n      case PR_NETIO_STRM_CTRL:\n        pr_event_generate(\""core.ctrl-read\"", pbuf);\n        break;\n\n      case PR_NETIO_STRM_DATA:\n        pr_event_generate(\""core.data-read\"", pbuf);\n        break;\n\n      case PR_NETIO_STRM_OTHR:\n        pr_event_generate(\""core.othr-read\"", pbuf);\n        break;\n    }\n\n    /* The event listeners may have changed the data read in out. */\n    buf = pbuf->buf;\n    bread = pbuf->buflen - pbuf->remaining;\n    destroy_pool(tmp_pool);\n\n    buf += bread;\n    total += bread;\n    bufmin -= bread;\n    buflen -= bread;\n  }\n\n  session.total_raw_in += total;\n  return total;\n}""}, {""func_name"": ""pr_cmd_read"", ""file_path"": ""src/main.c"", ""func_code"": ""int pr_cmd_read(cmd_rec **res) {\n  static long cmd_bufsz = -1;\n  static char *cmd_buf = NULL;\n  int cmd_buflen;\n  unsigned int too_large_count = 0;\n  char *ptr;\n\n  if (res == NULL) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (cmd_bufsz == -1) {\n    cmd_bufsz = get_max_cmd_sz();\n  }\n\n  if (cmd_buf == NULL) {\n    cmd_buf = pcalloc(session.pool, cmd_bufsz + 1);\n  }\n\n  while (TRUE) {\n    pr_signals_handle();\n\n    memset(cmd_buf, '\\0', cmd_bufsz);\n\n    cmd_buflen = pr_netio_telnet_gets2(cmd_buf, cmd_bufsz, session.c->instrm,\n      session.c->outstrm);\n    if (cmd_buflen < 0) {\n      if (errno == E2BIG) {\n        /* The client sent a too-long command which was ignored; give\n         * them a few more chances, with minor delays?\n         */\n        too_large_count++;\n        pr_timer_usleep(250 * 1000);\n\n        if (too_large_count > 3) {\n          return -1;\n        }\n\n        continue;\n      }\n\n      if (session.c->instrm->strm_errno == 0) {\n        pr_trace_msg(\""command\"", 6,\n          \""client sent EOF, closing control connection\"");\n      }\n\n      return -1;\n    }\n\n    break;\n  }\n\n  /* If the read length is less than the cmd_bufsz, then there is no need to\n   * truncate the buffer by inserting a NUL.\n   */\n  if (cmd_buflen > cmd_bufsz) {\n    pr_log_debug(DEBUG0, \""truncating incoming command length (%d bytes) to \""\n      \""CommandBufferSize %lu; use the CommandBufferSize directive to increase \""\n      \""the allowed command length\"", cmd_buflen, (unsigned long) cmd_bufsz);\n    cmd_buf[cmd_bufsz-1] = '\\0';\n  }\n\n  if (cmd_buflen > 0 &&\n      (cmd_buf[cmd_buflen-1] == '\\n' || cmd_buf[cmd_buflen-1] == '\\r')) {\n    cmd_buf[cmd_buflen-1] = '\\0';\n    cmd_buflen--;\n\n    if (cmd_buflen > 0 &&\n        (cmd_buf[cmd_buflen-1] == '\\n' || cmd_buf[cmd_buflen-1] =='\\r')) {\n      cmd_buf[cmd_buflen-1] = '\\0';\n      cmd_buflen--;\n    }\n  }\n\n  ptr = cmd_buf;\n  if (*ptr == '\\r') {\n    ptr++;\n  }\n\n  if (*ptr) {\n    int flags = 0;\n    cmd_rec *cmd;\n\n    /* If this is a SITE command, preserve embedded whitespace in the\n     * command parameters, in order to handle file names that have multiple\n     * spaces in the names.  Arguably this should be handled in the SITE\n     * command handlers themselves, via cmd->arg.  This small hack\n     * reduces the burden on SITE module developers, however.\n     */\n    if (strncasecmp(ptr, C_SITE, 4) == 0) {\n      flags |= PR_STR_FL_PRESERVE_WHITESPACE;\n    }\n\n    cmd = make_ftp_cmd(session.pool, ptr, cmd_buflen, flags);\n    if (cmd != NULL) {\n      *res = cmd;\n\n      if (pr_cmd_is_http(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \""HTTP\"";\n\n      } else if (pr_cmd_is_ssh2(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \""SSH2\"";\n\n      } else if (pr_cmd_is_smtp(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \""SMTP\"";\n\n      } else {\n        /* Assume that the client is sending valid FTP commands. */\n        cmd->is_ftp = TRUE;\n        cmd->protocol = \""FTP\"";\n      }\n    } \n  }\n\n  return 0;\n}""}]","{""caller"": 1, ""code"": 3, ""value"": 1, ""function"": 3}","[{""source"": ""caller_info(file:netio.c, func:pr_netio_read)"", ""result"": [{""call_line"": 1133, ""call_code"": ""pr_netio_read(session.d->instrm, buf + buflen,\n          session.xfer.bufsize - buflen, 1)"", ""caller_code"": ""int pr_data_xfer(char *cl_buf, size_t cl_size) {\n  int len = 0;\n  int total = 0;\n  int res = 0;\n  pool *tmp_pool = NULL;\n\n  if (cl_buf == NULL ||\n      cl_size == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  /* Poll the control channel for any commands we should handle, like\n   * QUIT or ABOR.\n   */\n  poll_ctrl();\n\n  /* If we don't have a data connection here (e.g. might have been closed\n   * by an ABOR), then return zero (no data transferred).\n   */\n  if (session.d == NULL) {\n    int xerrno;\n\n#if defined(ECONNABORTED)\n    xerrno = ECONNABORTED;\n#elif defined(ENOTCONN)\n    xerrno = ENOTCONN;\n#else\n    xerrno = EIO;\n#endif\n\n    pr_trace_msg(trace_channel, 1,\n      \""data connection is null prior to data transfer (possibly from \""\n      \""aborted transfer), returning '%s' error\"", strerror(xerrno));\n    pr_log_debug(DEBUG5, \n      \""data connection is null prior to data transfer (possibly from \""\n       \""aborted transfer), returning '%s' error\"", strerror(xerrno));\n\n    errno = xerrno;\n   ..."", ""caller_start"": 1072, ""file_path"": ""src/data.c""}, {""call_line"": 1147, ""call_code"": ""pr_netio_read(session.d->instrm, buf + buflen,\n              session.xfer.bufsize - buflen, 1)"", ""caller_code"": ""int pr_data_xfer(char *cl_buf, size_t cl_size) {\n  int len = 0;\n  int total = 0;\n  int res = 0;\n  pool *tmp_pool = NULL;\n\n  if (cl_buf == NULL ||\n      cl_size == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  /* Poll the control channel for any commands we should handle, like\n   * QUIT or ABOR.\n   */\n  poll_ctrl();\n\n  /* If we don't have a data connection here (e.g. might have been closed\n   * by an ABOR), then return zero (no data transferred).\n   */\n  if (session.d == NULL) {\n    int xerrno;\n\n#if defined(ECONNABORTED)\n    xerrno = ECONNABORTED;\n#elif defined(ENOTCONN)\n    xerrno = ENOTCONN;\n#else\n    xerrno = EIO;\n#endif\n\n    pr_trace_msg(trace_channel, 1,\n      \""data connection is null prior to data transfer (possibly from \""\n      \""aborted transfer), returning '%s' error\"", strerror(xerrno));\n    pr_log_debug(DEBUG5, \n      \""data connection is null prior to data transfer (possibly from \""\n       \""aborted transfer), returning '%s' error\"", strerror(xerrno));\n\n    errno = xerrno;\n   ..."", ""caller_start"": 1072, ""file_path"": ""src/data.c""}, {""call_line"": 1255, ""call_code"": ""pr_netio_read(session.d->instrm, cl_buf, cl_size, 1)"", ""caller_code"": ""int pr_data_xfer(char *cl_buf, size_t cl_size) {\n  int len = 0;\n  int total = 0;\n  int res = 0;\n  pool *tmp_pool = NULL;\n\n  if (cl_buf == NULL ||\n      cl_size == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  /* Poll the control channel for any commands we should handle, like\n   * QUIT or ABOR.\n   */\n  poll_ctrl();\n\n  /* If we don't have a data connection here (e.g. might have been closed\n   * by an ABOR), then return zero (no data transferred).\n   */\n  if (session.d == NULL) {\n    int xerrno;\n\n#if defined(ECONNABORTED)\n    xerrno = ECONNABORTED;\n#elif defined(ENOTCONN)\n    xerrno = ENOTCONN;\n#else\n    xerrno = EIO;\n#endif\n\n    pr_trace_msg(trace_channel, 1,\n      \""data connection is null prior to data transfer (possibly from \""\n      \""aborted transfer), returning '%s' error\"", strerror(xerrno));\n    pr_log_debug(DEBUG5, \n      \""data connection is null prior to data transfer (possibly from \""\n       \""aborted transfer), returning '%s' error\"", strerror(xerrno));\n\n    errno = xerrno;\n   ..."", ""caller_start"": 1072, ""file_path"": ""src/data.c""}, {""call_line"": 1268, ""call_code"": ""pr_netio_read(session.d->instrm, cl_buf, cl_size, 1)"", ""caller_code"": ""int pr_data_xfer(char *cl_buf, size_t cl_size) {\n  int len = 0;\n  int total = 0;\n  int res = 0;\n  pool *tmp_pool = NULL;\n\n  if (cl_buf == NULL ||\n      cl_size == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  /* Poll the control channel for any commands we should handle, like\n   * QUIT or ABOR.\n   */\n  poll_ctrl();\n\n  /* If we don't have a data connection here (e.g. might have been closed\n   * by an ABOR), then return zero (no data transferred).\n   */\n  if (session.d == NULL) {\n    int xerrno;\n\n#if defined(ECONNABORTED)\n    xerrno = ECONNABORTED;\n#elif defined(ENOTCONN)\n    xerrno = ENOTCONN;\n#else\n    xerrno = EIO;\n#endif\n\n    pr_trace_msg(trace_channel, 1,\n      \""data connection is null prior to data transfer (possibly from \""\n      \""aborted transfer), returning '%s' error\"", strerror(xerrno));\n    pr_log_debug(DEBUG5, \n      \""data connection is null prior to data transfer (possibly from \""\n       \""aborted transfer), returning '%s' error\"", strerror(xerrno));\n\n    errno = xerrno;\n   ..."", ""caller_start"": 1072, ""file_path"": ""src/data.c""}]}, {""source"": ""code_info(file:main.c, lines:480-490)"", ""result"": ""  while (TRUE) {\n    pr_signals_handle();\n\n    memset(cmd_buf, '\\0', cmd_bufsz);\n\n    cmd_buflen = pr_netio_telnet_gets2(cmd_buf, cmd_bufsz, session.c->instrm,\n      session.c->outstrm);\n    if (cmd_buflen < 0) {\n      if (errno == E2BIG) {\n        /* The client sent a too-long command which was ignored; give\n         * them another chance?\n         */\n""}, {""source"": ""value_info(file:main.c, value:res)"", ""result"": {""value_trace"": [{""full_code"": ""res = PR_DEFAULT_CMD_BUFSZ"", ""line"": 450, ""func_name"": ""get_max_cmd_sz""}, {""full_code"": ""res = *bufsz"", ""line"": 455, ""func_name"": ""get_max_cmd_sz""}, {""full_code"": ""res = 0"", ""line"": 870, ""func_name"": ""cmd_loop""}, {""full_code"": ""res = pr_cmd_read(&cmd)"", ""line"": 875, ""func_name"": ""cmd_loop""}, {""full_code"": ""res = 0"", ""line"": 1783, ""func_name"": ""inetd_main""}], ""struct_var"": ""res"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}, {""source"": ""func_info(file:netio.c, func:pr_netio_telnet_gets2)"", ""result"": [{""code"": ""int pr_netio_telnet_gets2(char *buf, size_t bufsz,\n    pr_netio_stream_t *in_nstrm, pr_netio_stream_t *out_nstrm) {\n  char *bp = buf;\n  unsigned char cp;\n  int toread, handle_iac = TRUE, saw_newline = FALSE;\n  pr_buffer_t *pbuf = NULL;\n  size_t buflen = bufsz;\n\n  if (buflen == 0 ||\n      in_nstrm == NULL ||\n      out_nstrm == NULL) {\n    errno = EINVAL;\n    return -1;\n  }\n\n#ifdef PR_USE_NLS\n  handle_iac = pr_encode_supports_telnet_iac();\n#endif /* PR_USE_NLS */\n\n  buflen--;\n\n  if (in_nstrm->strm_buf) {\n    pbuf = in_nstrm->strm_buf;\n\n  } else {\n    pbuf = pr_netio_buffer_alloc(in_nstrm);\n  }\n\n  while (buflen > 0) {\n    pr_signals_handle();\n\n    /* Is the buffer empty? */\n    if (pbuf->current == NULL ||\n        pbuf->remaining == pbuf->buflen) {\n\n      toread = pr_netio_read(in_nstrm, pbuf->buf,\n        (buflen < pbuf->buflen ? buflen : pbuf->buflen), 1);\n\n      if (toread <= 0) {\n        if (bp != buf) {\n          *bp = '\\0';\n          return (bufsz - buflen - 1);\n        }\n\n      ..."", ""start_line"": 1645, ""end_line"": 1852, ""full_name"": ""pr_netio_telnet_gets2"", ""file_path"": ""src/netio.c""}]}, {""source"": ""code_info(file:netio.c, lines:1430-1460)"", ""result"": ""\n        } while (bread == -1 && errno == EINTR);\n        break;\n    }\n\n    if (bread == -1) {\n      nstrm->strm_errno = errno;\n      return -1;\n    }\n\n    /* EOF? */\n    if (bread == 0) {\n      if (nstrm->strm_type == PR_NETIO_STRM_CTRL) {\n        pr_trace_msg(trace_channel, 7,\n          \""read %d bytes from control stream fd %d, handling as EOF\"", bread,\n          nstrm->strm_fd);\n      }\n\n      nstrm->strm_errno = 0;\n      break;\n    }\n\n    /* Before we provide the data from the client, generate an event\n     * for any listeners which may want to examine this data.  To do this, we\n     * need to allocate a pr_buffer_t for sending the buffer data to the\n     * listeners.\n     *\n     * We could just use nstrm->strm_pool, but for a long-lived control\n     * connection, this would amount to a slow memory increase.  So instead,\n     * we create a subpool from the stream's pool, and allocate the\n     * pr_buffer_t out of that.  Then simply destroy the subpool when done.\n     */\n""}, {""source"": ""func_info(func:pr_netio_telnet_gets2)"", ""result"": [{""code"": ""int pr_netio_telnet_gets2(char *buf, size_t bufsz,\n    pr_netio_stream_t *in_nstrm, pr_netio_stream_t *out_nstrm) {\n  char *bp = buf;\n  unsigned char cp;\n  int toread, handle_iac = TRUE, saw_newline = FALSE;\n  pr_buffer_t *pbuf = NULL;\n  size_t buflen = bufsz;\n\n  if (buflen == 0 ||\n      in_nstrm == NULL ||\n      out_nstrm == NULL) {\n    errno = EINVAL;\n    return -1;\n  }\n\n#ifdef PR_USE_NLS\n  handle_iac = pr_encode_supports_telnet_iac();\n#endif /* PR_USE_NLS */\n\n  buflen--;\n\n  if (in_nstrm->strm_buf) {\n    pbuf = in_nstrm->strm_buf;\n\n  } else {\n    pbuf = pr_netio_buffer_alloc(in_nstrm);\n  }\n\n  while (buflen > 0) {\n    pr_signals_handle();\n\n    /* Is the buffer empty? */\n    if (pbuf->current == NULL ||\n        pbuf->remaining == pbuf->buflen) {\n\n      toread = pr_netio_read(in_nstrm, pbuf->buf,\n        (buflen < pbuf->buflen ? buflen : pbuf->buflen), 1);\n\n      if (toread <= 0) {\n        if (bp != buf) {\n          *bp = '\\0';\n          return (bufsz - buflen - 1);\n        }\n\n      ..."", ""start_line"": 1645, ""end_line"": 1852, ""full_name"": ""pr_netio_telnet_gets2"", ""file_path"": ""src/netio.c""}]}, {""source"": ""func_info(file:netio.c, func:pr_netio_telnet_gets2)"", ""result"": [{""code"": ""int pr_netio_telnet_gets2(char *buf, size_t bufsz,\n    pr_netio_stream_t *in_nstrm, pr_netio_stream_t *out_nstrm) {\n  char *bp = buf;\n  unsigned char cp;\n  int toread, handle_iac = TRUE, saw_newline = FALSE;\n  pr_buffer_t *pbuf = NULL;\n  size_t buflen = bufsz;\n\n  if (buflen == 0 ||\n      in_nstrm == NULL ||\n      out_nstrm == NULL) {\n    errno = EINVAL;\n    return -1;\n  }\n\n#ifdef PR_USE_NLS\n  handle_iac = pr_encode_supports_telnet_iac();\n#endif /* PR_USE_NLS */\n\n  buflen--;\n\n  if (in_nstrm->strm_buf) {\n    pbuf = in_nstrm->strm_buf;\n\n  } else {\n    pbuf = pr_netio_buffer_alloc(in_nstrm);\n  }\n\n  while (buflen > 0) {\n    pr_signals_handle();\n\n    /* Is the buffer empty? */\n    if (pbuf->current == NULL ||\n        pbuf->remaining == pbuf->buflen) {\n\n      toread = pr_netio_read(in_nstrm, pbuf->buf,\n        (buflen < pbuf->buflen ? buflen : pbuf->buflen), 1);\n\n      if (toread <= 0) {\n        if (bp != buf) {\n          *bp = '\\0';\n          return (bufsz - buflen - 1);\n        }\n\n      ..."", ""start_line"": 1645, ""end_line"": 1852, ""full_name"": ""pr_netio_telnet_gets2"", ""file_path"": ""src/netio.c""}]}, {""source"": ""code_info(file:netio.c, lines:1645-1852)"", ""result"": ""int pr_netio_telnet_gets2(char *buf, size_t bufsz,\n    pr_netio_stream_t *in_nstrm, pr_netio_stream_t *out_nstrm) {\n  char *bp = buf;\n  unsigned char cp;\n  int toread, handle_iac = TRUE, saw_newline = FALSE;\n  pr_buffer_t *pbuf = NULL;\n  size_t buflen = bufsz;\n\n  if (buflen == 0 ||\n      in_nstrm == NULL ||\n      out_nstrm == NULL) {\n    errno = EINVAL;\n    return -1;\n  }\n\n#ifdef PR_USE_NLS\n  handle_iac = pr_encode_supports_telnet_iac();\n#endif /* PR_USE_NLS */\n\n  buflen--;\n\n  if (in_nstrm->strm_buf) {\n    pbuf = in_nstrm->strm_buf;\n\n  } else {\n    pbuf = pr_netio_buffer_alloc(in_nstrm);\n  }\n\n  while (buflen > 0) {\n    pr_signals_handle();\n\n    /* Is the buffer empty? */\n    if (pbuf->current == NULL ||\n        pbuf->remaining == pbuf->buflen) {\n\n      toread = pr_netio_read(in_nstrm, pbuf->buf,\n        (buflen < pbuf->buflen ? buflen : pbuf->buflen), 1);\n\n      if (toread <= 0) {\n        if (bp != buf) {\n          *bp = '\\0';\n          return (bufsz - buflen - 1);\n        }\n\n        return -1;\n      }\n\n      pbuf->remaining = pbuf->buflen - toread;\n      pbuf->current = pbuf->buf;\n\n      /* Before we begin iterating through the data read in from the\n       * network, handing any Telnet characters and such, generate an event\n       * for any listeners which may want to examine this data as well.\n       */\n      pr_event_generate(\""core.ctrl-read\"", pbuf);\n    }\n\n    toread = pbuf->buflen - pbuf->remaining;\n\n    while (buflen > 0 &&\n           toread > 0 &&\n           (*pbuf->current != '\\n' ||\n            (*pbuf->current == '\\n' && *(pbuf->current - 1) != '\\r')) &&\n           toread--) {\n      pr_signals_handle();\n\n      cp = *pbuf->current++;\n      pbuf->remaining++;\n\n      if (handle_iac == TRUE) {\n        switch (telnet_mode) {\n          case TELNET_IAC:\n            switch (cp) {\n              case TELNET_WILL:\n              case TELNET_WONT:\n              case TELNET_DO:\n              case TELNET_DONT:\n              case TELNET_IP:\n              case TELNET_DM:\n                /* Why do we do this crazy thing where we set the \""telnet mode\""\n                 * to be the action, and let the while loop, on the next pass,\n                 * handle that action?  It's because we don't know, right now,\n                 * whether there actually a \""next byte\"" in the input buffer.\n                 * There _should_ be -- but we can't be sure.  And that next\n                 * byte is needed for properly responding with WONT/DONT\n                 * responses.\n                 */\n                telnet_mode = cp;\n                continue;\n\n              case TELNET_IAC:\n                /* In this case, we know that the previous byte was TELNET_IAC,\n                 * and that the current byte is another TELNET_IAC.  The\n                 * first TELNET_IAC thus \""escapes\"" the second, telling us\n                 * that the current byte (TELNET_IAC) should be written out\n                 * as is (Bug#3697).\n                 */\n                telnet_mode = 0;\n                break;\n\n              default:\n                /* In this case, we know that the previous byte was TELNET_IAC,\n                 * but the current byte is not a value we care about.  So\n                 * write the TELNET_IAC into the output buffer, break out of\n                 * of the switch, and let that handle the writing of the\n                 * current byte into the output buffer.\n                 */\n                *bp++ = TELNET_IAC;\n                buflen--;\n\n                telnet_mode = 0;\n                break;\n            }\n            break;\n\n          case TELNET_WILL:\n          case TELNET_WONT:\n            pr_netio_printf(out_nstrm, \""%c%c%c\"", TELNET_IAC, TELNET_DONT, cp);\n            telnet_mode = 0;\n            continue;\n\n          case TELNET_DO:\n          case TELNET_DONT:\n            pr_netio_printf(out_nstrm, \""%c%c%c\"", TELNET_IAC, TELNET_WONT, cp);\n            telnet_mode = 0;\n            continue;\n\n          case TELNET_IP:\n          case TELNET_DM:\n          default:\n            if (cp == TELNET_IAC) {\n              telnet_mode = cp;\n              continue;\n            }\n            break;\n        }\n      }\n\n      /* In the situation where the previous byte was an IAC, we wrote IAC\n       * into the output buffer, and decremented buflen (size of the output\n       * buffer remaining).  Thus we need to check here if buflen is zero,\n       * before trying to decrement buflen again (and possibly underflowing\n       * the buflen size_t data type).\n       */\n      if (buflen == 0) {\n        break;\n      }\n\n      *bp++ = cp;\n      buflen--;\n    }\n\n    if (buflen > 0 &&\n        toread > 0 &&\n        *pbuf->current == '\\n') {\n\n      /* If the current character is LF, and the previous character we\n       * copied was a CR, then strip the CR by overwriting it with the LF,\n       * turning the copied data from Telnet CRLF line termination to\n       * Unix LF line termination.\n       */\n      if (*(bp-1) == '\\r') {\n        /* We already decrement the buffer length for the CR; no need to\n         * do it again since we are overwriting that CR.\n         */\n        *(bp-1) = *pbuf->current++;\n\n      } else {\n        *bp++ = *pbuf->current++;\n        buflen--;\n      }\n\n      pbuf->remaining++;\n      toread--;\n      saw_newline = TRUE;\n      break;\n    }\n\n    if (toread == 0) {\n      /* No more input?  Set pbuf->current to null, so that at the top of\n       * the loop, we read more.\n       */\n      pbuf->current = NULL;\n    }\n  }\n\n  if (!saw_newline) {\n    /* If we haven't seen a newline, then assume the client is deliberately\n     * sending a too-long command, trying to exploit buffer sizes and make\n     * the server make some possibly bad assumptions.\n     */\n\n    properly_terminated_prev_command = FALSE;\n    errno = E2BIG;\n    return -1;\n  }\n\n  if (!properly_terminated_prev_command) {\n    properly_terminated_prev_command = TRUE;\n    pr_log_pri(PR_LOG_NOTICE, \""client sent too-long command, ignoring\"");\n    errno = E2BIG;\n    return -1;\n  }\n\n  properly_terminated_prev_command = TRUE;\n  *bp = '\\0';\n  return (bufsz - buflen - 1);\n}\n\n""}]","main.c:489-496: Infinite loop due to unbounded E2BIG retries in pr_cmd_read. Patch adds too_large_count (3 attempts). netio.c:1645-1852: pr_netio_telnet_gets2 sets errno=E2BIG when a command lacks a newline, triggering the retry logic in pr_cmd_read. netio.c:1447 sets errno=EOF for EOF conditions, but this is unrelated to E2BIG handling. The infinite loop is resolved by capping retries and adding delays.",0.95,./github/other_context/CVE-2019-18217
15,CVE-2017-12990,CWE-835,c_cpp,"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.",https://github.com/the-tcpdump-group/tcpdump/commit/c2ef693866beae071a24b45c49f9674af1df4028,"CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.\n\nThe closest thing to a specification for the contents of the payload\ndata is draft-ietf-ipsec-notifymsg-04, and nothing in there says that it\nis ever a complete ISAKMP message, so don't dissect types we don't have\nspecific code for as a complete ISAKMP message.\n\nWhile we're at it, fix a comment, and clean up printing of V1 Nonce,\nV2 Authentication payloads, and v2 Notice payloads.\n\nThis fixes an infinite loop discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levomki.\n\nAdd a test using the capture file supplied by the reporter(s).",4,"[{""func_name"": ""ikev2_auth_print"", ""file_path"": ""print-isakmp.c"", ""func_code"": ""static const u_char *\nikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \""invalid\"", \""rsasig\"",\n\t\t\t\t\""shared-secret\"", \""dsssig\"" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\n\tND_PRINT((ndo,\"" len=%d method=%s\"", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\n\tif (1 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\"" authdata=(\""));\n\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo,\"") \""));\n\t} else if(ndo->ndo_vflag && 4 < len) {\n\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n\t}\n\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\"" [|%s]\"", NPSTR(tpay)));\n\treturn NULL;\n}"", ""target"": 0}, {""func_name"": ""ikev1_n_print"", ""file_path"": ""print-isakmp.c"", ""func_code"": ""static const u_char *\nikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\""INVALID-PAYLOAD-TYPE\"",\n\t\t\""DOI-NOT-SUPPORTED\"",\t\t\""SITUATION-NOT-SUPPORTED\"",\n\t\t\""INVALID-COOKIE\"",\t\t\""INVALID-MAJOR-VERSION\"",\n\t\t\""INVALID-MINOR-VERSION\"",\t\""INVALID-EXCHANGE-TYPE\"",\n\t\t\""INVALID-FLAGS\"",\t\t\""INVALID-MESSAGE-ID\"",\n\t\t\""INVALID-PROTOCOL-ID\"",\t\t\""INVALID-SPI\"",\n\t\t\""INVALID-TRANSFORM-ID\"",\t\t\""ATTRIBUTES-NOT-SUPPORTED\"",\n\t\t\""NO-PROPOSAL-CHOSEN\"",\t\t\""BAD-PROPOSAL-SYNTAX\"",\n\t\t\""PAYLOAD-MALFORMED\"",\t\t\""INVALID-KEY-INFORMATION\"",\n\t\t\""INVALID-ID-INFORMATION\"",\t\""INVALID-CERT-ENCODING\"",\n\t\t\""INVALID-CERTIFICATE\"",\t\t\""CERT-TYPE-UNSUPPORTED\"",\n\t\t\""INVALID-CERT-AUTHORITY\"",\t\""INVALID-HASH-INFORMATION\"",\n\t\t\""AUTHENTICATION-FAILED\"",\t\""INVALID-SIGNATURE\"",\n\t\t\""ADDRESS-NOTIFICATION\"",\t\t\""NOTIFY-SA-LIFETIME\"",\n\t\t\""CERTIFICATE-UNAVAILABLE\"",\t\""UNSUPPORTED-EXCHANGE-TYPE\"",\n\t\t\""UNEQUAL-PAYLOAD-LENGTHS\"",\n\t};\n\tstatic const char *ipsec_notify_error_str[] = {\n\t\t\""RESERVED\"",\n\t};\n\tstatic const char *notify_status_str[] = {\n\t\t\""CONNECTED\"",\n\t};\n\tstatic const char *ipsec_notify_status_str[] = {\n\t\t\""RESPONDER-LIFETIME\"",\t\t\""REPLAY-STATUS\"",\n\t\t\""INITIAL-CONTACT\"",\n\t};\n/* NOTE: these macro must be called with x in proper range */\n\n/* 0 - 8191 */\n#define NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((x), notify_error_str)\n\n/* 8192 - 16383 */\n#define IPSEC_NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)\n\n/* 16384 - 24575 */\n#define NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 16384), notify_status_str)\n\n/* 24576 - 32767 */\n#define IPSEC_NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)\n\n\tND_PRINT((ndo,\""%s:\"", NPSTR(ISAKMP_NPTYPE_N)));\n\n\tp = (const struct ikev1_pl_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tdoi = ntohl(n.doi);\n\tproto = n.prot_id;\n\tif (doi != 1) {\n\t\tND_PRINT((ndo,\"" doi=%d\"", doi));\n\t\tND_PRINT((ndo,\"" proto=%d\"", proto));\n\t\tif (ntohs(n.type) < 8192)\n\t\t\tND_PRINT((ndo,\"" type=%s\"", NOTIFY_ERROR_STR(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 16384)\n\t\t\tND_PRINT((ndo,\"" type=%s\"", numstr(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 24576)\n\t\t\tND_PRINT((ndo,\"" type=%s\"", NOTIFY_STATUS_STR(ntohs(n.type))));\n\t\telse\n\t\t\tND_PRINT((ndo,\"" type=%s\"", numstr(ntohs(n.type))));\n\t\tif (n.spi_size) {\n\t\t\tND_PRINT((ndo,\"" spi=\""));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\treturn (const u_char *)(p + 1) + n.spi_size;\n\t}\n\n\tND_PRINT((ndo,\"" doi=ipsec\""));\n\tND_PRINT((ndo,\"" proto=%s\"", PROTOIDSTR(proto)));\n\tif (ntohs(n.type) < 8192)\n\t\tND_PRINT((ndo,\"" type=%s\"", NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 16384)\n\t\tND_PRINT((ndo,\"" type=%s\"", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 24576)\n\t\tND_PRINT((ndo,\"" type=%s\"", NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 32768)\n\t\tND_PRINT((ndo,\"" type=%s\"", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse\n\t\tND_PRINT((ndo,\"" type=%s\"", numstr(ntohs(n.type))));\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\"" spi=\""));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tND_PRINT((ndo,\"" orig=(\""));\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n\t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n\t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\""replay detection %sabled\"",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \""en\"" : \""dis\""));\n\t\t\tbreak;\n\t\tcase ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:\n\t\t\tif (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,\n\t\t\t\t\t    (const struct isakmp_gen *)cp, ep, phase, doi, proto,\n\t\t\t\t\t    depth) == NULL)\n\t\t\t\treturn NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* NULL is dummy */\n\t\t\tisakmp_print(ndo, cp,\n\t\t\t\t     item_len - sizeof(*p) - n.spi_size,\n\t\t\t\t     NULL);\n\t\t}\n\t\tND_PRINT((ndo,\"")\""));\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\"" [|%s]\"", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}"", ""target"": 0}, {""func_name"": ""ikev1_nonce_print"", ""file_path"": ""print-isakmp.c"", ""func_code"": ""static const u_char *\nikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\""%s:\"", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\"" n len=%d\"", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\"" \""));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\"" \""));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\"" [|%s]\"", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}"", ""target"": 0}, {""func_name"": ""ikev2_n_print"", ""file_path"": ""print-isakmp.c"", ""func_code"": ""static const u_char *\nikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tconst struct ikev2_n *p;\n\tstruct ikev2_n n;\n\tconst u_char *cp;\n\tu_char showspi, showdata, showsomedata;\n\tconst char *notify_name;\n\tuint32_t type;\n\n\tp = (const struct ikev2_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);\n\n\tshowspi = 1;\n\tshowdata = 0;\n\tshowsomedata=0;\n\tnotify_name=NULL;\n\n\tND_PRINT((ndo,\"" prot_id=%s\"", PROTOIDSTR(n.prot_id)));\n\n\ttype = ntohs(n.type);\n\n\t/* notify space is annoying sparse */\n\tswitch(type) {\n\tcase IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD:\n\t\tnotify_name = \""unsupported_critical_payload\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_IKE_SPI:\n\t\tnotify_name = \""invalid_ike_spi\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_MAJOR_VERSION:\n\t\tnotify_name = \""invalid_major_version\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SYNTAX:\n\t\tnotify_name = \""invalid_syntax\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_MESSAGE_ID:\n\t\tnotify_name = \""invalid_message_id\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SPI:\n\t\tnotify_name = \""invalid_spi\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NO_PROPOSAL_CHOSEN:\n\t\tnotify_name = \""no_protocol_chosen\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_KE_PAYLOAD:\n\t\tnotify_name = \""invalid_ke_payload\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_AUTHENTICATION_FAILED:\n\t\tnotify_name = \""authentication_failed\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_SINGLE_PAIR_REQUIRED:\n\t\tnotify_name = \""single_pair_required\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NO_ADDITIONAL_SAS:\n\t\tnotify_name = \""no_additional_sas\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE:\n\t\tnotify_name = \""internal_address_failure\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_FAILED_CP_REQUIRED:\n\t\tnotify_name = \""failed:cp_required\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SELECTORS:\n\t\tnotify_name = \""invalid_selectors\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INITIAL_CONTACT:\n\t\tnotify_name = \""initial_contact\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_SET_WINDOW_SIZE:\n\t\tnotify_name = \""set_window_size\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE:\n\t\tnotify_name = \""additional_ts_possible\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_IPCOMP_SUPPORTED:\n\t\tnotify_name = \""ipcomp_supported\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NAT_DETECTION_SOURCE_IP:\n\t\tnotify_name = \""nat_detection_source_ip\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP:\n\t\tnotify_name = \""nat_detection_destination_ip\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_COOKIE:\n\t\tnotify_name = \""cookie\"";\n\t\tshowspi = 1;\n\t\tshowsomedata= 1;\n\t\tshowdata= 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_USE_TRANSPORT_MODE:\n\t\tnotify_name = \""use_transport_mode\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED:\n\t\tnotify_name = \""http_cert_lookup_supported\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_REKEY_SA:\n\t\tnotify_name = \""rekey_sa\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED:\n\t\tnotify_name = \""tfc_padding_not_supported\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO:\n\t\tnotify_name = \""non_first_fragment_also\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tif (type < 8192) {\n\t\t\tnotify_name=\""error\"";\n\t\t} else if(type < 16384) {\n\t\t\tnotify_name=\""private-error\"";\n\t\t} else if(type < 40960) {\n\t\t\tnotify_name=\""status\"";\n\t\t} else {\n\t\t\tnotify_name=\""private-status\"";\n\t\t}\n\t}\n\n\tif(notify_name) {\n\t\tND_PRINT((ndo,\"" type=%u(%s)\"", type, notify_name));\n\t}\n\n\n\tif (showspi && n.spi_size) {\n\t\tND_PRINT((ndo,\"" spi=\""));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\n\tif(3 < ndo->ndo_vflag) {\n\t\tshowdata = 1;\n\t}\n\n\tif ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {\n\t\tND_PRINT((ndo,\"" data=(\""));\n\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\tgoto trunc;\n\n\t\tND_PRINT((ndo,\"")\""));\n\n\t} else if(showsomedata && cp < ep) {\n\t\tif(!ike_show_somedata(ndo, cp, ep)) goto trunc;\n\t}\n\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\"" [|%s]\"", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}"", ""target"": 0}]","[{""func_name"": ""ikev2_auth_print"", ""file_path"": ""print-isakmp.c"", ""func_code"": ""static const u_char *\nikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \""invalid\"", \""rsasig\"",\n\t\t\t\t\""shared-secret\"", \""dsssig\"" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\n\t/*\n\t * Our caller has ensured that the length is >= 4.\n\t */\n\tND_PRINT((ndo,\"" len=%u method=%s\"", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (len > 4) {\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \"" authdata=(\""));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \"") \""));\n\t\t} else if (ndo->ndo_vflag) {\n\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\"" [|%s]\"", NPSTR(tpay)));\n\treturn NULL;\n}""}, {""func_name"": ""ikev1_n_print"", ""file_path"": ""print-isakmp.c"", ""func_code"": ""static const u_char *\nikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\""INVALID-PAYLOAD-TYPE\"",\n\t\t\""DOI-NOT-SUPPORTED\"",\t\t\""SITUATION-NOT-SUPPORTED\"",\n\t\t\""INVALID-COOKIE\"",\t\t\""INVALID-MAJOR-VERSION\"",\n\t\t\""INVALID-MINOR-VERSION\"",\t\""INVALID-EXCHANGE-TYPE\"",\n\t\t\""INVALID-FLAGS\"",\t\t\""INVALID-MESSAGE-ID\"",\n\t\t\""INVALID-PROTOCOL-ID\"",\t\t\""INVALID-SPI\"",\n\t\t\""INVALID-TRANSFORM-ID\"",\t\t\""ATTRIBUTES-NOT-SUPPORTED\"",\n\t\t\""NO-PROPOSAL-CHOSEN\"",\t\t\""BAD-PROPOSAL-SYNTAX\"",\n\t\t\""PAYLOAD-MALFORMED\"",\t\t\""INVALID-KEY-INFORMATION\"",\n\t\t\""INVALID-ID-INFORMATION\"",\t\""INVALID-CERT-ENCODING\"",\n\t\t\""INVALID-CERTIFICATE\"",\t\t\""CERT-TYPE-UNSUPPORTED\"",\n\t\t\""INVALID-CERT-AUTHORITY\"",\t\""INVALID-HASH-INFORMATION\"",\n\t\t\""AUTHENTICATION-FAILED\"",\t\""INVALID-SIGNATURE\"",\n\t\t\""ADDRESS-NOTIFICATION\"",\t\t\""NOTIFY-SA-LIFETIME\"",\n\t\t\""CERTIFICATE-UNAVAILABLE\"",\t\""UNSUPPORTED-EXCHANGE-TYPE\"",\n\t\t\""UNEQUAL-PAYLOAD-LENGTHS\"",\n\t};\n\tstatic const char *ipsec_notify_error_str[] = {\n\t\t\""RESERVED\"",\n\t};\n\tstatic const char *notify_status_str[] = {\n\t\t\""CONNECTED\"",\n\t};\n\tstatic const char *ipsec_notify_status_str[] = {\n\t\t\""RESPONDER-LIFETIME\"",\t\t\""REPLAY-STATUS\"",\n\t\t\""INITIAL-CONTACT\"",\n\t};\n/* NOTE: these macro must be called with x in proper range */\n\n/* 0 - 8191 */\n#define NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((x), notify_error_str)\n\n/* 8192 - 16383 */\n#define IPSEC_NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)\n\n/* 16384 - 24575 */\n#define NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 16384), notify_status_str)\n\n/* 24576 - 32767 */\n#define IPSEC_NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)\n\n\tND_PRINT((ndo,\""%s:\"", NPSTR(ISAKMP_NPTYPE_N)));\n\n\tp = (const struct ikev1_pl_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tdoi = ntohl(n.doi);\n\tproto = n.prot_id;\n\tif (doi != 1) {\n\t\tND_PRINT((ndo,\"" doi=%d\"", doi));\n\t\tND_PRINT((ndo,\"" proto=%d\"", proto));\n\t\tif (ntohs(n.type) < 8192)\n\t\t\tND_PRINT((ndo,\"" type=%s\"", NOTIFY_ERROR_STR(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 16384)\n\t\t\tND_PRINT((ndo,\"" type=%s\"", numstr(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 24576)\n\t\t\tND_PRINT((ndo,\"" type=%s\"", NOTIFY_STATUS_STR(ntohs(n.type))));\n\t\telse\n\t\t\tND_PRINT((ndo,\"" type=%s\"", numstr(ntohs(n.type))));\n\t\tif (n.spi_size) {\n\t\t\tND_PRINT((ndo,\"" spi=\""));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\treturn (const u_char *)(p + 1) + n.spi_size;\n\t}\n\n\tND_PRINT((ndo,\"" doi=ipsec\""));\n\tND_PRINT((ndo,\"" proto=%s\"", PROTOIDSTR(proto)));\n\tif (ntohs(n.type) < 8192)\n\t\tND_PRINT((ndo,\"" type=%s\"", NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 16384)\n\t\tND_PRINT((ndo,\"" type=%s\"", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 24576)\n\t\tND_PRINT((ndo,\"" type=%s\"", NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 32768)\n\t\tND_PRINT((ndo,\"" type=%s\"", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse\n\t\tND_PRINT((ndo,\"" type=%s\"", numstr(ntohs(n.type))));\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\"" spi=\""));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n\t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n\t\t\tND_PRINT((ndo,\"" attrs=(\""));\n\t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n\t\t\t}\n\t\t\tND_PRINT((ndo,\"")\""));\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\"" status=(\""));\n\t\t\tND_PRINT((ndo,\""replay detection %sabled\"",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \""en\"" : \""dis\""));\n\t\t\tND_PRINT((ndo,\"")\""));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * XXX - fill in more types here; see, for example,\n\t\t\t * draft-ietf-ipsec-notifymsg-04.\n\t\t\t */\n\t\t\tif (ndo->ndo_vflag > 3) {\n\t\t\t\tND_PRINT((ndo,\"" data=(\""));\n\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo,\"")\""));\n\t\t\t} else {\n\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\"" [|%s]\"", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}""}, {""func_name"": ""ikev1_nonce_print"", ""file_path"": ""print-isakmp.c"", ""func_code"": ""static const u_char *\nikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\""%s:\"", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t/*\n\t * Our caller has ensured that the length is >= 4.\n\t */\n\tND_PRINT((ndo,\"" n len=%u\"", ntohs(e.len) - 4));\n\tif (ntohs(e.len) > 4) {\n\t\tif (ndo->ndo_vflag > 2) {\n\t\t\tND_PRINT((ndo, \"" \""));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\t\tgoto trunc;\n\t\t} else if (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \"" \""));\n\t\t\tif (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\"" [|%s]\"", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}""}, {""func_name"": ""ikev2_n_print"", ""file_path"": ""print-isakmp.c"", ""func_code"": ""static const u_char *\nikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tconst struct ikev2_n *p;\n\tstruct ikev2_n n;\n\tconst u_char *cp;\n\tu_char showspi, showsomedata;\n\tconst char *notify_name;\n\tuint32_t type;\n\n\tp = (const struct ikev2_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);\n\n\tshowspi = 1;\n\tshowsomedata=0;\n\tnotify_name=NULL;\n\n\tND_PRINT((ndo,\"" prot_id=%s\"", PROTOIDSTR(n.prot_id)));\n\n\ttype = ntohs(n.type);\n\n\t/* notify space is annoying sparse */\n\tswitch(type) {\n\tcase IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD:\n\t\tnotify_name = \""unsupported_critical_payload\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_IKE_SPI:\n\t\tnotify_name = \""invalid_ike_spi\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_MAJOR_VERSION:\n\t\tnotify_name = \""invalid_major_version\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SYNTAX:\n\t\tnotify_name = \""invalid_syntax\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_MESSAGE_ID:\n\t\tnotify_name = \""invalid_message_id\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SPI:\n\t\tnotify_name = \""invalid_spi\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NO_PROPOSAL_CHOSEN:\n\t\tnotify_name = \""no_protocol_chosen\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_KE_PAYLOAD:\n\t\tnotify_name = \""invalid_ke_payload\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_AUTHENTICATION_FAILED:\n\t\tnotify_name = \""authentication_failed\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_SINGLE_PAIR_REQUIRED:\n\t\tnotify_name = \""single_pair_required\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NO_ADDITIONAL_SAS:\n\t\tnotify_name = \""no_additional_sas\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE:\n\t\tnotify_name = \""internal_address_failure\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_FAILED_CP_REQUIRED:\n\t\tnotify_name = \""failed:cp_required\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SELECTORS:\n\t\tnotify_name = \""invalid_selectors\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INITIAL_CONTACT:\n\t\tnotify_name = \""initial_contact\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_SET_WINDOW_SIZE:\n\t\tnotify_name = \""set_window_size\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE:\n\t\tnotify_name = \""additional_ts_possible\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_IPCOMP_SUPPORTED:\n\t\tnotify_name = \""ipcomp_supported\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NAT_DETECTION_SOURCE_IP:\n\t\tnotify_name = \""nat_detection_source_ip\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP:\n\t\tnotify_name = \""nat_detection_destination_ip\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_COOKIE:\n\t\tnotify_name = \""cookie\"";\n\t\tshowspi = 1;\n\t\tshowsomedata= 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_USE_TRANSPORT_MODE:\n\t\tnotify_name = \""use_transport_mode\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED:\n\t\tnotify_name = \""http_cert_lookup_supported\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_REKEY_SA:\n\t\tnotify_name = \""rekey_sa\"";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED:\n\t\tnotify_name = \""tfc_padding_not_supported\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO:\n\t\tnotify_name = \""non_first_fragment_also\"";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tif (type < 8192) {\n\t\t\tnotify_name=\""error\"";\n\t\t} else if(type < 16384) {\n\t\t\tnotify_name=\""private-error\"";\n\t\t} else if(type < 40960) {\n\t\t\tnotify_name=\""status\"";\n\t\t} else {\n\t\t\tnotify_name=\""private-status\"";\n\t\t}\n\t}\n\n\tif(notify_name) {\n\t\tND_PRINT((ndo,\"" type=%u(%s)\"", type, notify_name));\n\t}\n\n\n\tif (showspi && n.spi_size) {\n\t\tND_PRINT((ndo,\"" spi=\""));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\n\tif (cp < ep) {\n\t\tif (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {\n\t\t\tND_PRINT((ndo,\"" data=(\""));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\tgoto trunc;\n\n\t\t\tND_PRINT((ndo,\"")\""));\n\t\t} else if (showsomedata) {\n\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\"" [|%s]\"", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}""}]","{""function"": 1}","[{""source"": ""func_info(func:isakmp_print)"", ""result"": [{""code"": ""void\nisakmp_print(netdissect_options *ndo,\n\t     const u_char *bp, u_int length,\n\t     const u_char *bp2)\n{\n\tconst struct isakmp *p;\n\tstruct isakmp base;\n\tconst u_char *ep;\n\tint major, minor;\n\n#ifdef HAVE_LIBCRYPTO\n\t/* initialize SAs */\n\tif (ndo->ndo_sa_list_head == NULL) {\n\t\tif (ndo->ndo_espsecret)\n\t\t\tesp_print_decodesecret(ndo);\n\t}\n#endif\n\n\tp = (const struct isakmp *)bp;\n\tep = ndo->ndo_snapend;\n\n\tif ((const struct isakmp *)ep < p + 1) {\n\t\tND_PRINT((ndo,\""[|isakmp]\""));\n\t\treturn;\n\t}\n\n\tUNALIGNED_MEMCPY(&base, p, sizeof(base));\n\n\tND_PRINT((ndo,\""isakmp\""));\n\tmajor = (base.vers & ISAKMP_VERS_MAJOR)\n\t\t>> ISAKMP_VERS_MAJOR_SHIFT;\n\tminor = (base.vers & ISAKMP_VERS_MINOR)\n\t\t>> ISAKMP_VERS_MINOR_SHIFT;\n\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo,\"" %d.%d\"", major, minor));\n\t}\n\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo,\"" msgid \""));\n\t\thexprint(ndo, (const uint8_t *)&base.msgid, sizeof(base.msgid));\n\t}\n\n\tif (1 < ndo->ndo_vflag) {\n\t\tND_PRINT((ndo,\"" cookie \""));\n\t\thexprint(ndo, (const uint8_t *)&base.i_ck, s..."", ""start_line"": 2977, ""end_line"": 3037, ""full_name"": ""isakmp_print"", ""file_path"": ""print-isakmp.c""}]}]","The infinite loop was triggered by the `ikev1_n_print` function (print-isakmp.c:702-711) calling `isakmp_print()` on unknown notification payload data without validation. This caused `isakmp_print` (print-isakmp.c:2977-3037) to recursively parse the data as a nested ISAKMP message, leading to infinite recursion. The patch replaces this with conditional raw data printing, preventing unintended parsing of arbitrary payloads as ISAKMP messages.",0.95,./github/other_context/CVE-2017-12990
16,CVE-2017-12997,CWE-835,c_cpp,The LLDP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-lldp.c:lldp_private_8021_print().,https://github.com/the-tcpdump-group/tcpdump/commit/34cec721d39c76be1e0a600829a7b17bdfb832b6,"CVE-2017-12997/LLDP: Don't use an 8-bit loop counter.\n\nIf you have a\n\n	for (i = 0; i < N; i++)\n\nloop, you'd better make sure that i is big enough to hold N - not N-1,\nN.\n\nThe TLV length here is 9 bits long, not 8 bits long, so an 8-bit loop\ncounter will overflow and you can loop infinitely.\n\nThis fixes an infinite loop discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levomki.\n\nAdd tests using the capture files supplied by the reporter(s).\n\nClean up the output a bit while we're at it.",1,"[{""func_name"": ""lldp_private_8021_print"", ""file_path"": ""print-lldp.c"", ""func_code"": ""static int\nlldp_private_8021_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n    u_int sublen;\n    u_int tval;\n    uint8_t i;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \""\\n\\t  %s Subtype (%u)\"",\n           tok2str(lldp_8021_subtype_values, \""unknown\"", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    port vlan id (PVID): %u\"",\n               EXTRACT_16BITS(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)\"",\n               EXTRACT_16BITS(tptr+5),\n\t       bittok2str(lldp_8021_port_protocol_id_values, \""none\"", *(tptr+4)),\n\t       *(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    vlan id (VID): %u\"", EXTRACT_16BITS(tptr + 4)));\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        sublen = *(tptr+6);\n        if (tlv_len < 7+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    vlan name: \""));\n        safeputs(ndo, tptr + 7, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:\n        if (tlv_len < 5) {\n            return hexdump;\n        }\n        sublen = *(tptr+4);\n        if (tlv_len < 5+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    protocol identity: \""));\n        safeputs(ndo, tptr + 5, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \""\\n\\t    Pre-Priority CNPV Indicator\""));\n        ND_PRINT((ndo, \""\\n\\t     Priority : 0  1  2  3  4  5  6  7\""));\n        ND_PRINT((ndo, \""\\n\\t     Value    : \""));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \""%-2d \"", (tval >> i) & 0x01));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \""\\n\\t    Pre-Priority Ready Indicator\""));\n        ND_PRINT((ndo, \""\\n\\t     Priority : 0  1  2  3  4  5  6  7\""));\n        ND_PRINT((ndo, \""\\n\\t     Value    : \""));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \""%-2d \"", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \""\\n\\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d\"",\n        \ttval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));\n\n        /*Print Priority Assignment Table*/\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n\n        /*Print TC Bandwidth Table*/\n        print_tc_bandwidth_table(ndo, tptr + 9);\n\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    RES: %d\"", *(tptr + 4)));\n        /*Print Priority Assignment Table */\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n        /*Print TC Bandwidth Table */\n        print_tc_bandwidth_table(ndo, tptr + 9);\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \""\\n\\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d \"",\n        \ttval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));\n        ND_PRINT((ndo, \""\\n\\t    PFC Enable\""));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \""\\n\\t     Priority : 0  1  2  3  4  5  6  7\""));\n        ND_PRINT((ndo, \""\\n\\t     Value    : \""));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \""%-2d \"", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    RES: %d\"", *(tptr + 4)));\n        if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        /*  Length of Application Priority Table */\n        sublen=tlv_len-5;\n        if(sublen%3!=0){\n        \treturn hexdump;\n        }\n        i=0;\n        ND_PRINT((ndo, \""\\n\\t    Application Priority Table\""));\n        while(i<sublen) {\n        \ttval=*(tptr+i+5);\n        \tND_PRINT((ndo, \""\\n\\t      Priority: %d, RES: %d, Sel: %d\"",\n        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));\n        \tND_PRINT((ndo, \""Protocol ID: %d\"", EXTRACT_16BITS(tptr + i + 5)));\n        \ti=i+3;\n        }\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_EVB:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    EVB Bridge Status\""));\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \""\\n\\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d\"",\n        \ttval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));\n        ND_PRINT((ndo, \""\\n\\t    EVB Station Status\""));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \""\\n\\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d\"",\n        \ttval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));\n        tval=*(tptr+6);\n        ND_PRINT((ndo, \""\\n\\t    R: %d, RTE: %d, \"",tval >> 5, tval & 0x1f));\n        tval=*(tptr+7);\n        ND_PRINT((ndo, \""EVB Mode: %s [%d]\"",\n        \ttok2str(lldp_evb_mode_values, \""unknown\"", tval >> 6), tval >> 6));\n        ND_PRINT((ndo, \""\\n\\t    ROL: %d, RWD: %d, \"", (tval >> 5) & 0x01, tval & 0x1f));\n        tval=*(tptr+8);\n        ND_PRINT((ndo, \""RES: %d, ROL: %d, RKA: %d\"", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_CDCP:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \""\\n\\t    Role: %d, RES: %d, Scomp: %d \"",\n        \ttval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));\n        ND_PRINT((ndo, \""ChnCap: %d\"", EXTRACT_16BITS(tptr + 6) & 0x0fff));\n        sublen=tlv_len-8;\n        if(sublen%3!=0) {\n        \treturn hexdump;\n        }\n        i=0;\n        while(i<sublen) {\n        \ttval=EXTRACT_24BITS(tptr+i+8);\n        \tND_PRINT((ndo, \""\\n\\t    SCID: %d, SVID: %d\"",\n        \t\ttval >> 12, tval & 0x000fff));\n        \ti=i+3;\n        }\n        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}"", ""target"": 0}]","[{""func_name"": ""lldp_private_8021_print"", ""file_path"": ""print-lldp.c"", ""func_code"": ""static int\nlldp_private_8021_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n    u_int sublen;\n    u_int tval;\n    u_int i;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \""\\n\\t  %s Subtype (%u)\"",\n           tok2str(lldp_8021_subtype_values, \""unknown\"", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    port vlan id (PVID): %u\"",\n               EXTRACT_16BITS(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)\"",\n               EXTRACT_16BITS(tptr+5),\n\t       bittok2str(lldp_8021_port_protocol_id_values, \""none\"", *(tptr+4)),\n\t       *(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    vlan id (VID): %u\"", EXTRACT_16BITS(tptr + 4)));\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        sublen = *(tptr+6);\n        if (tlv_len < 7+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    vlan name: \""));\n        safeputs(ndo, tptr + 7, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:\n        if (tlv_len < 5) {\n            return hexdump;\n        }\n        sublen = *(tptr+4);\n        if (tlv_len < 5+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    protocol identity: \""));\n        safeputs(ndo, tptr + 5, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \""\\n\\t    Pre-Priority CNPV Indicator\""));\n        ND_PRINT((ndo, \""\\n\\t     Priority : 0  1  2  3  4  5  6  7\""));\n        ND_PRINT((ndo, \""\\n\\t     Value    : \""));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \""%-2d \"", (tval >> i) & 0x01));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \""\\n\\t    Pre-Priority Ready Indicator\""));\n        ND_PRINT((ndo, \""\\n\\t     Priority : 0  1  2  3  4  5  6  7\""));\n        ND_PRINT((ndo, \""\\n\\t     Value    : \""));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \""%-2d \"", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \""\\n\\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d\"",\n        \ttval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));\n\n        /*Print Priority Assignment Table*/\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n\n        /*Print TC Bandwidth Table*/\n        print_tc_bandwidth_table(ndo, tptr + 9);\n\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    RES: %d\"", *(tptr + 4)));\n        /*Print Priority Assignment Table */\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n        /*Print TC Bandwidth Table */\n        print_tc_bandwidth_table(ndo, tptr + 9);\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \""\\n\\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d \"",\n        \ttval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));\n        ND_PRINT((ndo, \""\\n\\t    PFC Enable\""));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \""\\n\\t     Priority : 0  1  2  3  4  5  6  7\""));\n        ND_PRINT((ndo, \""\\n\\t     Value    : \""));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \""%-2d \"", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    RES: %d\"", *(tptr + 4)));\n        if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        /*  Length of Application Priority Table */\n        sublen=tlv_len-5;\n        if(sublen%3!=0){\n        \treturn hexdump;\n        }\n        i=0;\n        ND_PRINT((ndo, \""\\n\\t    Application Priority Table\""));\n        while(i<sublen) {\n        \ttval=*(tptr+i+5);\n        \tND_PRINT((ndo, \""\\n\\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u\"",\n        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),\n        \t\t EXTRACT_16BITS(tptr + i + 5)));\n        \ti=i+3;\n        }\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_EVB:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    EVB Bridge Status\""));\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \""\\n\\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d\"",\n        \ttval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));\n        ND_PRINT((ndo, \""\\n\\t    EVB Station Status\""));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \""\\n\\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d\"",\n        \ttval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));\n        tval=*(tptr+6);\n        ND_PRINT((ndo, \""\\n\\t    R: %d, RTE: %d, \"",tval >> 5, tval & 0x1f));\n        tval=*(tptr+7);\n        ND_PRINT((ndo, \""EVB Mode: %s [%d]\"",\n        \ttok2str(lldp_evb_mode_values, \""unknown\"", tval >> 6), tval >> 6));\n        ND_PRINT((ndo, \""\\n\\t    ROL: %d, RWD: %d, \"", (tval >> 5) & 0x01, tval & 0x1f));\n        tval=*(tptr+8);\n        ND_PRINT((ndo, \""RES: %d, ROL: %d, RKA: %d\"", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_CDCP:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \""\\n\\t    Role: %d, RES: %d, Scomp: %d \"",\n        \ttval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));\n        ND_PRINT((ndo, \""ChnCap: %d\"", EXTRACT_16BITS(tptr + 6) & 0x0fff));\n        sublen=tlv_len-8;\n        if(sublen%3!=0) {\n        \treturn hexdump;\n        }\n        i=0;\n        while(i<sublen) {\n        \ttval=EXTRACT_24BITS(tptr+i+8);\n        \tND_PRINT((ndo, \""\\n\\t    SCID: %d, SVID: %d\"",\n        \t\ttval >> 12, tval & 0x000fff));\n        \ti=i+3;\n        }\n        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}""}]","{""value"": 3, ""function"": 2, ""caller"": 1}","[{""source"": ""value_info(file:print-lldp.c, value:sublen)"", ""result"": {""value_trace"": [{""full_code"": ""sublen = *(tptr+6)"", ""line"": 690, ""func_name"": ""lldp_private_8021_print""}, {""full_code"": ""sublen = *(tptr+4)"", ""line"": 701, ""func_name"": ""lldp_private_8021_print""}, {""full_code"": ""sublen=tlv_len-5"", ""line"": 782, ""func_name"": ""lldp_private_8021_print""}, {""full_code"": ""sublen=tlv_len-8"", ""line"": 826, ""func_name"": ""lldp_private_8021_print""}], ""struct_var"": ""sublen"", ""struct_type"": ""u_int"", ""struct_definition"": ""u_int""}}, {""source"": ""value_info(file:print-lldp.c, value:tlv_len)"", ""result"": {""value_trace"": [{""full_code"": ""tlv_len = LLDP_EXTRACT_LEN(tlv)"", ""line"": 1179, ""func_name"": ""lldp_private_dcbx_print""}, {""full_code"": ""tlv_len = LLDP_EXTRACT_LEN(tlv)"", ""line"": 1438, ""func_name"": ""lldp_print""}], ""struct_var"": ""tlv_len"", ""struct_type"": ""u_int"", ""struct_definition"": ""u_int""}}, {""source"": ""func_info(file:print-lldp.c, func:lldp_private_8021_print)"", ""result"": [{""code"": ""static int\nlldp_private_8021_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n    u_int sublen;\n    u_int tval;\n    uint8_t i;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \""\\n\\t  %s Subtype (%u)\"",\n           tok2str(lldp_8021_subtype_values, \""unknown\"", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    port vlan id (PVID): %u\"",\n               EXTRACT_16BITS(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)\"",\n               EXTRACT_16BITS(tptr+5),\n\t       bittok2str(lldp_8021_port_protocol_id_values, \""none\"", *(tptr+4)),\n\t  ..."", ""start_line"": 647, ""end_line"": 845, ""full_name"": ""lldp_private_8021_print"", ""file_path"": ""print-lldp.c""}]}, {""source"": ""value_info(file:print-lldp.c, value:tlv_len)"", ""result"": {""value_trace"": [{""full_code"": ""tlv_len = LLDP_EXTRACT_LEN(tlv)"", ""line"": 1179, ""func_name"": ""lldp_private_dcbx_print""}, {""full_code"": ""tlv_len = LLDP_EXTRACT_LEN(tlv)"", ""line"": 1438, ""func_name"": ""lldp_print""}], ""struct_var"": ""tlv_len"", ""struct_type"": ""u_int"", ""struct_definition"": ""u_int""}}, {""source"": ""caller_info(file:print-lldp.c, func:lldp_private_8021_print)"", ""result"": [{""call_line"": 1614, ""call_code"": ""lldp_private_8021_print(ndo, tptr, tlv_len)"", ""caller_code"": ""void\nlldp_print(netdissect_options *ndo,\n           register const u_char *pptr, register u_int len)\n{\n    uint8_t subtype;\n    uint16_t tlv, cap, ena_cap;\n    u_int oui, tlen, hexdump, tlv_type, tlv_len;\n    const u_char *tptr;\n    char *network_addr;\n\n    tptr = pptr;\n    tlen = len;\n\n    ND_PRINT((ndo, \""LLDP, length %u\"", len));\n\n    while (tlen >= sizeof(tlv)) {\n\n        ND_TCHECK2(*tptr, sizeof(tlv));\n\n        tlv = EXTRACT_16BITS(tptr);\n\n        tlv_type = LLDP_EXTRACT_TYPE(tlv);\n        tlv_len = LLDP_EXTRACT_LEN(tlv);\n        hexdump = FALSE;\n\n        tlen -= sizeof(tlv);\n        tptr += sizeof(tlv);\n\n        if (ndo->ndo_vflag) {\n            ND_PRINT((ndo, \""\\n\\t%s TLV (%u), length %u\"",\n                   tok2str(lldp_tlv_values, \""Unknown\"", tlv_type),\n                   tlv_type, tlv_len));\n        }\n\n        /* infinite loop check */\n        if (!tlv_type || !tlv_len) {\n            break;\n        }\n\n        ND_TCHECK2(*tptr, tlv_len);\n        if (tlen < tlv_len) {\n          ..."", ""caller_start"": 1416, ""file_path"": ""print-lldp.c""}]}, {""source"": ""func_info(file:print-lldp.c, func:lldp_private_8021_print)"", ""result"": [{""code"": ""static int\nlldp_private_8021_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n    u_int sublen;\n    u_int tval;\n    uint8_t i;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \""\\n\\t  %s Subtype (%u)\"",\n           tok2str(lldp_8021_subtype_values, \""unknown\"", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    port vlan id (PVID): %u\"",\n               EXTRACT_16BITS(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \""\\n\\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)\"",\n               EXTRACT_16BITS(tptr+5),\n\t       bittok2str(lldp_8021_port_protocol_id_values, \""none\"", *(tptr+4)),\n\t  ..."", ""start_line"": 647, ""end_line"": 845, ""full_name"": ""lldp_private_8021_print"", ""file_path"": ""print-lldp.c""}]}]","print-lldp.c:788-796: Infinite loop in Application Priority Table parsing due to uint8_t i overflow when sublen (initialized as tlv_len - 5 at line 782) exceeds 255. The loop condition (i < sublen) fails to terminate after i wraps from 255 to 0. tlv_len is passed into lldp_private_8021_print from lldp_print (print-lldp.c:1614), where it is derived from a packet's TLV via tlv_len = LLDP_EXTRACT_LEN(tlv) (print-lldp.c:1438). Since TLV length is a 9-bit field, tlv_len can be up to 511, enabling sublen to exceed 255.",0.95,./github/other_context/CVE-2017-12997
17,CVE-2017-17044,"CWE-755, CWE-835, CWE-754",c_cpp,An issue was discovered in Xen through 4.9.x allowing HVM guest OS users to cause a denial of service (infinite loop and host OS hang) by leveraging the mishandling of Populate on Demand (PoD) errors.,https://github.com/xen-project/xen/commit/a1c6c6768971ea387d7eba0803908ef0928b43ac,"x86/pod: prevent infinite loop when shattering large pages\n\nWhen populating pages, the PoD may need to split large ones using\np2m_set_entry and request the caller to retry (see ept_get_entry for\ninstance).\n\np2m_set_entry may fail to shatter if it is not possible to allocate\nmemory for the new page table. However, the error is not propagated\nresulting to the callers to retry infinitely the PoD.\n\nPrevent the infinite loop by return false when it is not possible to\nshatter the large mapping.\n\nThis is XSA-246.\n\nSigned-off-by: Julien Grall <julien.grall@linaro.org>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: George Dunlap <george.dunlap@citrix.com>",1,"[{""func_name"": ""p2m_pod_demand_populate"", ""file_path"": ""xen/arch/x86/mm/p2m-pod.c"", ""func_code"": ""bool\np2m_pod_demand_populate(struct p2m_domain *p2m, gfn_t gfn,\n                        unsigned int order)\n{\n    struct domain *d = p2m->domain;\n    struct page_info *p = NULL; /* Compiler warnings */\n    gfn_t gfn_aligned = _gfn((gfn_x(gfn) >> order) << order);\n    mfn_t mfn;\n    unsigned long i;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n    pod_lock(p2m);\n\n    /*\n     * This check is done with the pod lock held.  This will make sure that\n     * even if d->is_dying changes under our feet, p2m_pod_empty_cache()\n     * won't start until we're done.\n     */\n    if ( unlikely(d->is_dying) )\n        goto out_fail;\n\n\n    /*\n     * Because PoD does not have cache list for 1GB pages, it has to remap\n     * 1GB region to 2MB chunks for a retry.\n     */\n    if ( order == PAGE_ORDER_1G )\n    {\n        pod_unlock(p2m);\n        /*\n         * Note that we are supposed to call p2m_set_entry() 512 times to\n         * split 1GB into 512 2MB pages here. But We only do once here because\n         * p2m_set_entry() should automatically shatter the 1GB page into\n         * 512 2MB pages. The rest of 511 calls are unnecessary.\n         *\n         * NOTE: In a fine-grained p2m locking scenario this operation\n         * may need to promote its locking from gfn->1g superpage\n         */\n        p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n                      p2m_populate_on_demand, p2m->default_access);\n        return true;\n    }\n\n    /* Only reclaim if we're in actual need of more cache. */\n    if ( p2m->pod.entry_count > p2m->pod.count )\n        pod_eager_reclaim(p2m);\n\n    /*\n     * Only sweep if we're actually out of memory.  Doing anything else\n     * causes unnecessary time and fragmentation of superpages in the p2m.\n     */\n    if ( p2m->pod.count == 0 )\n        p2m_pod_emergency_sweep(p2m);\n\n    /* If the sweep failed, give up. */\n    if ( p2m->pod.count == 0 )\n        goto out_of_memory;\n\n    /* Keep track of the highest gfn demand-populated by a guest fault */\n    p2m->pod.max_guest = gfn_max(gfn, p2m->pod.max_guest);\n\n    /*\n     * Get a page f/ the cache.  A NULL return value indicates that the\n     * 2-meg range should be marked singleton PoD, and retried.\n     */\n    if ( (p = p2m_pod_cache_get(p2m, order)) == NULL )\n        goto remap_and_retry;\n\n    mfn = page_to_mfn(p);\n\n    BUG_ON((mfn_x(mfn) & ((1UL << order) - 1)) != 0);\n\n    p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n                  p2m->default_access);\n\n    for( i = 0; i < (1UL << order); i++ )\n    {\n        set_gpfn_from_mfn(mfn_x(mfn) + i, gfn_x(gfn_aligned) + i);\n        paging_mark_dirty(d, mfn_add(mfn, i));\n    }\n\n    p2m->pod.entry_count -= (1UL << order);\n    BUG_ON(p2m->pod.entry_count < 0);\n\n    pod_eager_record(p2m, gfn_aligned, order);\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn, mfn;\n            int d:16,order:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.mfn = mfn_x(mfn);\n        t.d = d->domain_id;\n        t.order = order;\n\n        __trace_var(TRC_MEM_POD_POPULATE, 0, sizeof(t), &t);\n    }\n\n    pod_unlock(p2m);\n    return true;\nout_of_memory:\n    pod_unlock(p2m);\n\n    printk(\""%s: Dom%d out of PoD memory! (tot=%\""PRIu32\"" ents=%ld dom%d)\\n\"",\n           __func__, d->domain_id, d->tot_pages, p2m->pod.entry_count,\n           current->domain->domain_id);\n    domain_crash(d);\n    return false;\nout_fail:\n    pod_unlock(p2m);\n    return false;\nremap_and_retry:\n    BUG_ON(order != PAGE_ORDER_2M);\n    pod_unlock(p2m);\n\n    /* Remap this 2-meg region in singleton chunks */\n    /*\n     * NOTE: In a p2m fine-grained lock scenario this might\n     * need promoting the gfn lock from gfn->2M superpage.\n     */\n    for ( i = 0; i < (1UL << order); i++ )\n        p2m_set_entry(p2m, gfn_add(gfn_aligned, i), INVALID_MFN, PAGE_ORDER_4K,\n                      p2m_populate_on_demand, p2m->default_access);\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn;\n            int d:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.d = d->domain_id;\n\n        __trace_var(TRC_MEM_POD_SUPERPAGE_SPLINTER, 0, sizeof(t), &t);\n    }\n\n    return true;\n}"", ""target"": 0}]","[{""func_name"": ""p2m_pod_demand_populate"", ""file_path"": ""xen/arch/x86/mm/p2m-pod.c"", ""func_code"": ""bool\np2m_pod_demand_populate(struct p2m_domain *p2m, gfn_t gfn,\n                        unsigned int order)\n{\n    struct domain *d = p2m->domain;\n    struct page_info *p = NULL; /* Compiler warnings */\n    gfn_t gfn_aligned = _gfn((gfn_x(gfn) >> order) << order);\n    mfn_t mfn;\n    unsigned long i;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n    pod_lock(p2m);\n\n    /*\n     * This check is done with the pod lock held.  This will make sure that\n     * even if d->is_dying changes under our feet, p2m_pod_empty_cache()\n     * won't start until we're done.\n     */\n    if ( unlikely(d->is_dying) )\n        goto out_fail;\n\n\n    /*\n     * Because PoD does not have cache list for 1GB pages, it has to remap\n     * 1GB region to 2MB chunks for a retry.\n     */\n    if ( order == PAGE_ORDER_1G )\n    {\n        pod_unlock(p2m);\n        /*\n         * Note that we are supposed to call p2m_set_entry() 512 times to\n         * split 1GB into 512 2MB pages here. But We only do once here because\n         * p2m_set_entry() should automatically shatter the 1GB page into\n         * 512 2MB pages. The rest of 511 calls are unnecessary.\n         *\n         * NOTE: In a fine-grained p2m locking scenario this operation\n         * may need to promote its locking from gfn->1g superpage\n         */\n        return !p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n                              p2m_populate_on_demand, p2m->default_access);\n    }\n\n    /* Only reclaim if we're in actual need of more cache. */\n    if ( p2m->pod.entry_count > p2m->pod.count )\n        pod_eager_reclaim(p2m);\n\n    /*\n     * Only sweep if we're actually out of memory.  Doing anything else\n     * causes unnecessary time and fragmentation of superpages in the p2m.\n     */\n    if ( p2m->pod.count == 0 )\n        p2m_pod_emergency_sweep(p2m);\n\n    /* If the sweep failed, give up. */\n    if ( p2m->pod.count == 0 )\n        goto out_of_memory;\n\n    /* Keep track of the highest gfn demand-populated by a guest fault */\n    p2m->pod.max_guest = gfn_max(gfn, p2m->pod.max_guest);\n\n    /*\n     * Get a page f/ the cache.  A NULL return value indicates that the\n     * 2-meg range should be marked singleton PoD, and retried.\n     */\n    if ( (p = p2m_pod_cache_get(p2m, order)) == NULL )\n        goto remap_and_retry;\n\n    mfn = page_to_mfn(p);\n\n    BUG_ON((mfn_x(mfn) & ((1UL << order) - 1)) != 0);\n\n    if ( p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n                       p2m->default_access) )\n    {\n        p2m_pod_cache_add(p2m, p, order);\n        goto out_fail;\n    }\n\n    for( i = 0; i < (1UL << order); i++ )\n    {\n        set_gpfn_from_mfn(mfn_x(mfn) + i, gfn_x(gfn_aligned) + i);\n        paging_mark_dirty(d, mfn_add(mfn, i));\n    }\n\n    p2m->pod.entry_count -= (1UL << order);\n    BUG_ON(p2m->pod.entry_count < 0);\n\n    pod_eager_record(p2m, gfn_aligned, order);\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn, mfn;\n            int d:16,order:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.mfn = mfn_x(mfn);\n        t.d = d->domain_id;\n        t.order = order;\n\n        __trace_var(TRC_MEM_POD_POPULATE, 0, sizeof(t), &t);\n    }\n\n    pod_unlock(p2m);\n    return true;\nout_of_memory:\n    pod_unlock(p2m);\n\n    printk(\""%s: Dom%d out of PoD memory! (tot=%\""PRIu32\"" ents=%ld dom%d)\\n\"",\n           __func__, d->domain_id, d->tot_pages, p2m->pod.entry_count,\n           current->domain->domain_id);\n    domain_crash(d);\n    return false;\nout_fail:\n    pod_unlock(p2m);\n    return false;\nremap_and_retry:\n    BUG_ON(order != PAGE_ORDER_2M);\n    pod_unlock(p2m);\n\n    /*\n     * Remap this 2-meg region in singleton chunks. See the comment on the\n     * 1G page splitting path above for why a single call suffices.\n     *\n     * NOTE: In a p2m fine-grained lock scenario this might\n     * need promoting the gfn lock from gfn->2M superpage.\n     */\n    if ( p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_4K,\n                       p2m_populate_on_demand, p2m->default_access) )\n        return false;\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn;\n            int d:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.d = d->domain_id;\n\n        __trace_var(TRC_MEM_POD_SUPERPAGE_SPLINTER, 0, sizeof(t), &t);\n    }\n\n    return true;\n}""}]","{""function"": 2, ""caller"": 1, ""code"": 1}","[{""source"": ""func_info(file:p2m.c, func:p2m_set_entry)"", ""result"": [{""code"": ""int p2m_set_entry(struct p2m_domain *p2m, gfn_t gfn, mfn_t mfn,\n                  unsigned int page_order, p2m_type_t p2mt, p2m_access_t p2ma)\n{\n    struct domain *d = p2m->domain;\n    unsigned long todo = 1ul << page_order;\n    unsigned int order;\n    int set_rc, rc = 0;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n\n    while ( todo )\n    {\n        if ( hap_enabled(d) )\n        {\n            unsigned long fn_mask = !mfn_eq(mfn, INVALID_MFN) ? mfn_x(mfn) : 0;\n\n            fn_mask |= gfn_x(gfn) | todo;\n\n            order = (!(fn_mask & ((1ul << PAGE_ORDER_1G) - 1)) &&\n                     hap_has_1gb) ? PAGE_ORDER_1G :\n                    (!(fn_mask & ((1ul << PAGE_ORDER_2M) - 1)) &&\n                     hap_has_2mb) ? PAGE_ORDER_2M : PAGE_ORDER_4K;\n        }\n        else\n            order = 0;\n\n        set_rc = p2m->set_entry(p2m, gfn, mfn, order, p2mt, p2ma, -1);\n        if ( set_rc )\n            rc = set_rc;\n\n        gfn = gfn_add(gfn, 1ul << order);\n        if ( !mfn_eq(mfn, INVALID_..."", ""start_line"": 536, ""end_line"": 573, ""full_name"": ""p2m_set_entry<duplicate>0"", ""file_path"": ""xen/arch/x86/mm/p2m.c""}]}, {""source"": ""caller_info(func:p2m_pod_demand_populate)"", ""result"": [{""call_line"": 969, ""call_code"": ""p2m_pod_demand_populate(p2m, gfn_, i * EPT_TABLE_ORDER)"", ""caller_code"": ""static mfn_t ept_get_entry(struct p2m_domain *p2m,\n                           gfn_t gfn_, p2m_type_t *t, p2m_access_t* a,\n                           p2m_query_t q, unsigned int *page_order,\n                           bool_t *sve)\n{\n    ept_entry_t *table =\n        map_domain_page(pagetable_get_mfn(p2m_get_pagetable(p2m)));\n    unsigned long gfn = gfn_x(gfn_);\n    unsigned long gfn_remainder = gfn;\n    ept_entry_t *ept_entry;\n    u32 index;\n    int i;\n    int ret = 0;\n    bool_t recalc = 0;\n    mfn_t mfn = INVALID_MFN;\n    struct ept_data *ept = &p2m->ept;\n\n    *t = p2m_mmio_dm;\n    *a = p2m_access_n;\n    if ( sve )\n        *sve = 1;\n\n    /* This pfn is higher than the highest the p2m map currently holds */\n    if ( gfn > p2m->max_mapped_pfn )\n    {\n        for ( i = ept->wl; i > 0; --i )\n            if ( (gfn & ~((1UL << (i * EPT_TABLE_ORDER)) - 1)) >\n                 p2m->max_mapped_pfn )\n                break;\n        goto out;\n    }\n\n    /* Should check if gfn obeys GAW here. */\n..."", ""caller_start"": 913, ""file_path"": ""xen/arch/x86/mm/p2m-ept.c""}, {""call_line"": 991, ""call_code"": ""p2m_pod_demand_populate(p2m, gfn_, PAGE_ORDER_4K)"", ""caller_code"": ""static mfn_t ept_get_entry(struct p2m_domain *p2m,\n                           gfn_t gfn_, p2m_type_t *t, p2m_access_t* a,\n                           p2m_query_t q, unsigned int *page_order,\n                           bool_t *sve)\n{\n    ept_entry_t *table =\n        map_domain_page(pagetable_get_mfn(p2m_get_pagetable(p2m)));\n    unsigned long gfn = gfn_x(gfn_);\n    unsigned long gfn_remainder = gfn;\n    ept_entry_t *ept_entry;\n    u32 index;\n    int i;\n    int ret = 0;\n    bool_t recalc = 0;\n    mfn_t mfn = INVALID_MFN;\n    struct ept_data *ept = &p2m->ept;\n\n    *t = p2m_mmio_dm;\n    *a = p2m_access_n;\n    if ( sve )\n        *sve = 1;\n\n    /* This pfn is higher than the highest the p2m map currently holds */\n    if ( gfn > p2m->max_mapped_pfn )\n    {\n        for ( i = ept->wl; i > 0; --i )\n            if ( (gfn & ~((1UL << (i * EPT_TABLE_ORDER)) - 1)) >\n                 p2m->max_mapped_pfn )\n                break;\n        goto out;\n    }\n\n    /* Should check if gfn obeys GAW here. */\n..."", ""caller_start"": 913, ""file_path"": ""xen/arch/x86/mm/p2m-ept.c""}, {""call_line"": 805, ""call_code"": ""p2m_pod_demand_populate(p2m, gfn_, PAGE_ORDER_1G)"", ""caller_code"": ""static mfn_t\np2m_pt_get_entry(struct p2m_domain *p2m, gfn_t gfn_,\n                 p2m_type_t *t, p2m_access_t *a, p2m_query_t q,\n                 unsigned int *page_order, bool_t *sve)\n{\n    mfn_t mfn;\n    unsigned long gfn = gfn_x(gfn_);\n    paddr_t addr = ((paddr_t)gfn) << PAGE_SHIFT;\n    l2_pgentry_t *l2e;\n    l1_pgentry_t *l1e;\n    unsigned int flags;\n    p2m_type_t l1t;\n    bool_t recalc;\n\n    ASSERT(paging_mode_translate(p2m->domain));\n\n    if ( sve )\n        *sve = 1;\n\n    /* XXX This is for compatibility with the old model, where anything not \n     * XXX marked as RAM was considered to be emulated MMIO space.\n     * XXX Once we start explicitly registering MMIO regions in the p2m \n     * XXX we will return p2m_invalid for unmapped gfns */\n    *t = p2m_mmio_dm;\n    /* Not implemented except with EPT */\n    *a = p2m_access_rwx; \n\n    if ( gfn > p2m->max_mapped_pfn )\n    {\n        /* This pfn is higher than the highest the p2m map currently holds */\n        if ( page_order )\n ..."", ""caller_start"": 734, ""file_path"": ""xen/arch/x86/mm/p2m-pt.c""}, {""call_line"": 847, ""call_code"": ""p2m_pod_demand_populate(p2m, gfn_, PAGE_ORDER_2M)"", ""caller_code"": ""static mfn_t\np2m_pt_get_entry(struct p2m_domain *p2m, gfn_t gfn_,\n                 p2m_type_t *t, p2m_access_t *a, p2m_query_t q,\n                 unsigned int *page_order, bool_t *sve)\n{\n    mfn_t mfn;\n    unsigned long gfn = gfn_x(gfn_);\n    paddr_t addr = ((paddr_t)gfn) << PAGE_SHIFT;\n    l2_pgentry_t *l2e;\n    l1_pgentry_t *l1e;\n    unsigned int flags;\n    p2m_type_t l1t;\n    bool_t recalc;\n\n    ASSERT(paging_mode_translate(p2m->domain));\n\n    if ( sve )\n        *sve = 1;\n\n    /* XXX This is for compatibility with the old model, where anything not \n     * XXX marked as RAM was considered to be emulated MMIO space.\n     * XXX Once we start explicitly registering MMIO regions in the p2m \n     * XXX we will return p2m_invalid for unmapped gfns */\n    *t = p2m_mmio_dm;\n    /* Not implemented except with EPT */\n    *a = p2m_access_rwx; \n\n    if ( gfn > p2m->max_mapped_pfn )\n    {\n        /* This pfn is higher than the highest the p2m map currently holds */\n        if ( page_order )\n ..."", ""caller_start"": 734, ""file_path"": ""xen/arch/x86/mm/p2m-pt.c""}]}, {""source"": ""func_info(file:p2m.c, func:p2m_set_entry)"", ""result"": [{""code"": ""int p2m_set_entry(struct p2m_domain *p2m, gfn_t gfn, mfn_t mfn,\n                  unsigned int page_order, p2m_type_t p2mt, p2m_access_t p2ma)\n{\n    struct domain *d = p2m->domain;\n    unsigned long todo = 1ul << page_order;\n    unsigned int order;\n    int set_rc, rc = 0;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n\n    while ( todo )\n    {\n        if ( hap_enabled(d) )\n        {\n            unsigned long fn_mask = !mfn_eq(mfn, INVALID_MFN) ? mfn_x(mfn) : 0;\n\n            fn_mask |= gfn_x(gfn) | todo;\n\n            order = (!(fn_mask & ((1ul << PAGE_ORDER_1G) - 1)) &&\n                     hap_has_1gb) ? PAGE_ORDER_1G :\n                    (!(fn_mask & ((1ul << PAGE_ORDER_2M) - 1)) &&\n                     hap_has_2mb) ? PAGE_ORDER_2M : PAGE_ORDER_4K;\n        }\n        else\n            order = 0;\n\n        set_rc = p2m->set_entry(p2m, gfn, mfn, order, p2mt, p2ma, -1);\n        if ( set_rc )\n            rc = set_rc;\n\n        gfn = gfn_add(gfn, 1ul << order);\n        if ( !mfn_eq(mfn, INVALID_..."", ""start_line"": 536, ""end_line"": 573, ""full_name"": ""p2m_set_entry<duplicate>0"", ""file_path"": ""xen/arch/x86/mm/p2m.c""}]}, {""source"": ""code_info(file:p2m.c, lines:574-600)"", ""result"": ""\nmfn_t p2m_alloc_ptp(struct p2m_domain *p2m, unsigned int level)\n{\n    struct page_info *pg;\n\n    ASSERT(p2m);\n    ASSERT(p2m->domain);\n    ASSERT(p2m->domain->arch.paging.alloc_page);\n    pg = p2m->domain->arch.paging.alloc_page(p2m->domain);\n    if ( !pg )\n        return INVALID_MFN;\n\n    page_list_add_tail(pg, &p2m->pages);\n    BUILD_BUG_ON(PGT_l1_page_table * 2 != PGT_l2_page_table);\n    BUILD_BUG_ON(PGT_l1_page_table * 3 != PGT_l3_page_table);\n    BUILD_BUG_ON(PGT_l1_page_table * 4 != PGT_l4_page_table);\n    pg->u.inuse.type_info = (PGT_l1_page_table * level) | 1 | PGT_validated;\n\n    return page_to_mfn(pg);\n}\n\nvoid p2m_free_ptp(struct p2m_domain *p2m, struct page_info *pg)\n{\n    ASSERT(pg);\n    ASSERT(p2m);\n    ASSERT(p2m->domain);\n    ASSERT(p2m->domain->arch.paging.free_page);\n\n""}]","xen/arch/x86/mm/p2m-pod.c:1114-1117: p2m_pod_demand_populate returns true regardless of p2m_set_entry's success/failure. p2m_set_entry (xen/arch/x86/mm/p2m.c:536-573) returns non-zero on failure (e.g., memory allocation errors during page table splitting). Callers like ept_get_entry (xen/arch/x86/mm/p2m-ept.c:969, 991) retry on failure, leading to infinite loops. The patch returns false on p2m_set_entry failure, aborting retries.",0.95,./github/other_context/CVE-2017-17044
18,CVE-2020-25219,CWE-674,c_cpp,url::recvline in url.cpp in libproxy 0.4.x through 0.4.15 allows a remote HTTP server to trigger uncontrolled recursion via a response composed of an infinite stream that lacks a newline character. This leads to stack exhaustion.,https://github.com/libproxy/libproxy/commit/a83dae404feac517695c23ff43ce1e116e2bfbe0,"Rewrite url::recvline to be nonrecursive\n\nThis function processes network input. It's semi-trusted, because the\nPAC ought to be trusted. But we still shouldn't allow it to control how\nfar we recurse. A malicious PAC can cause us to overflow the stack by\nsending a sufficiently-long line without any '\n' character.\n\nAlso, this function failed to properly handle EINTR, so let's fix that\ntoo, for good measure.\n\nFixes #134",1,"[{""func_name"": ""recvline"", ""file_path"": ""libproxy/url.cpp"", ""func_code"": ""static inline string recvline(int fd) {\n\t// Read a character.\n\t// If we don't get a character, return empty string.\n\t// If we are at the end of the line, return empty string.\n\tchar c = '\\0';\n\t\n\tif (recv(fd, &c, 1, 0) != 1 || c == '\\n')\n\t\treturn \""\"";\n\n\treturn string(1, c) + recvline(fd);\n}"", ""target"": 0}]","[{""func_name"": ""recvline"", ""file_path"": ""libproxy/url.cpp"", ""func_code"": ""static string recvline(int fd) {\n\tstring line;\n\tint ret;\n\n\t// Reserve arbitrary amount of space to avoid small memory reallocations.\n\tline.reserve(128);\n\n\tdo {\n\t\tchar c;\n\t\tret = recv(fd, &c, 1, 0);\n\t\tif (ret == 1) {\n\t\t\tif (c == '\\n')\n\t\t\t\treturn line;\n\t\t\tline += c;\n\t\t}\n\t} while (ret == 1 || (ret == -1 && errno == EINTR));\n\n\treturn line;\n}""}]",{},[],"Original root cause: Recursive call in `return string(1, c) + recvline(fd)` (libproxy/url.cpp). Patch replaces this with an iterative loop (libproxy/url.cpp: lines with `do { ... } while (...)`), eliminating unbounded recursion.",0.95,./github/other_context/CVE-2020-25219
19,CVE-2020-27638,CWE-617,c_cpp,receive.c in fastd before v21 allows denial of service (assertion failure) when receiving packets with an invalid type code.,https://github.com/neocturne/fastd/commit/737925113363b6130879729cdff9ccc46c33eaea,"receive: fix buffer leak when receiving invalid packets\n\nFor fastd versions before v20, this was just a memory leak (which could\nstill be used for DoS, as it's remotely triggerable). With the new\nbuffer management of fastd v20, this will trigger an assertion failure\ninstead as soon as the buffer pool is empty.",2,"[{""func_name"": ""handle_socket_receive_known"", ""file_path"": ""src/receive.c"", ""func_code"": ""static inline void handle_socket_receive_known(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_peer_t *peer, fastd_buffer_t *buffer) {\n\tif (!fastd_peer_may_connect(peer)) {\n\t\tfastd_buffer_free(buffer);\n\t\treturn;\n\t}\n\n\tconst uint8_t *packet_type = buffer->data;\n\n\tswitch (*packet_type) {\n\tcase PACKET_DATA:\n\t\tif (!fastd_peer_is_established(peer) || !fastd_peer_address_equal(&peer->local_address, local_addr)) {\n\t\t\tfastd_buffer_free(buffer);\n\n\t\t\tif (!backoff_unknown(remote_addr)) {\n\t\t\t\tpr_debug(\""unexpectedly received payload data from %P[%I]\"", peer, remote_addr);\n\t\t\t\tconf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconf.protocol->handle_recv(peer, buffer);\n\t\tbreak;\n\n\tcase PACKET_HANDSHAKE:\n\t\tfastd_handshake_handle(sock, local_addr, remote_addr, peer, buffer);\n\t}\n}"", ""target"": 0}, {""func_name"": ""handle_socket_receive_unknown"", ""file_path"": ""src/receive.c"", ""func_code"": ""static inline void handle_socket_receive_unknown(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_buffer_t *buffer) {\n\tconst uint8_t *packet_type = buffer->data;\n\n\tswitch (*packet_type) {\n\tcase PACKET_DATA:\n\t\tfastd_buffer_free(buffer);\n\n\t\tif (!backoff_unknown(remote_addr)) {\n\t\t\tpr_debug(\""unexpectedly received payload data from unknown address %I\"", remote_addr);\n\t\t\tconf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);\n\t\t}\n\t\tbreak;\n\n\tcase PACKET_HANDSHAKE:\n\t\tfastd_handshake_handle(sock, local_addr, remote_addr, NULL, buffer);\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""handle_socket_receive_known"", ""file_path"": ""src/receive.c"", ""func_code"": ""static inline void handle_socket_receive_known(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_peer_t *peer, fastd_buffer_t *buffer) {\n\tif (!fastd_peer_may_connect(peer)) {\n\t\tfastd_buffer_free(buffer);\n\t\treturn;\n\t}\n\n\tconst uint8_t *packet_type = buffer->data;\n\n\tswitch (*packet_type) {\n\tcase PACKET_DATA:\n\t\tif (!fastd_peer_is_established(peer) || !fastd_peer_address_equal(&peer->local_address, local_addr)) {\n\t\t\tfastd_buffer_free(buffer);\n\n\t\t\tif (!backoff_unknown(remote_addr)) {\n\t\t\t\tpr_debug(\""unexpectedly received payload data from %P[%I]\"", peer, remote_addr);\n\t\t\t\tconf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconf.protocol->handle_recv(peer, buffer);\n\t\tbreak;\n\n\tcase PACKET_HANDSHAKE:\n\t\tfastd_handshake_handle(sock, local_addr, remote_addr, peer, buffer);\n\t\tbreak;\n\n\tdefault:\n\t\tfastd_buffer_free(buffer);\n\t\tpr_debug(\""received packet with invalid type from %P[%I]\"", peer, remote_addr);\n\t}\n}""}, {""func_name"": ""handle_socket_receive_unknown"", ""file_path"": ""src/receive.c"", ""func_code"": ""static inline void handle_socket_receive_unknown(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_buffer_t *buffer) {\n\tconst uint8_t *packet_type = buffer->data;\n\n\tswitch (*packet_type) {\n\tcase PACKET_DATA:\n\t\tfastd_buffer_free(buffer);\n\n\t\tif (!backoff_unknown(remote_addr)) {\n\t\t\tpr_debug(\""unexpectedly received payload data from unknown address %I\"", remote_addr);\n\t\t\tconf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);\n\t\t}\n\t\tbreak;\n\n\tcase PACKET_HANDSHAKE:\n\t\tfastd_handshake_handle(sock, local_addr, remote_addr, NULL, buffer);\n\t\tbreak;\n\n\tdefault:\n\t\tfastd_buffer_free(buffer);\n\t\tpr_debug(\""received packet with invalid type from unknown address %I\"", remote_addr);\n\t}\n}""}]",{},[],src/receive.c: Missing 'default:' case in switch statements for packet handling allowed invalid types to bypass buffer release logic. Patch adds 'default:' with fastd_buffer_free(buffer) to handle all unhandled packet types.,0.95,./github/other_context/CVE-2020-27638
20,CVE-2020-28196,CWE-674,c_cpp,MIT Kerberos 5 (aka krb5) before 1.17.2 and 1.18.x before 1.18.3 allows unbounded recursion via an ASN.1-encoded Kerberos message because the lib/krb5/asn.1/asn1_encode.c support for BER indefinite lengths lacks a recursion limit.,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,"Add recursion limit for ASN.1 indefinite lengths\n\nThe libkrb5 ASN.1 decoder supports BER indefinite lengths.  It\ncomputes the tag length using recursion; the lack of a recursion limit\nallows an attacker to overrun the stack and cause the process to\ncrash.  Reported by Demi Obenour.\n\nCVE-2020-28196:\n\nIn MIT krb5 releases 1.11 and later, an unauthenticated attacker can\ncause a denial of service for any client or server to which it can\nsend an ASN.1-encoded Kerberos message of sufficient length.\n\nticket: 8959 (new)\ntags: pullup\ntarget_version: 1.18-next\ntarget_version: 1.17-next",6,"[{""func_name"": ""get_tag"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""static krb5_error_code\nget_tag(const uint8_t *asn1, size_t len, taginfo *tag_out,\n        const uint8_t **contents_out, size_t *clen_out,\n        const uint8_t **remainder_out, size_t *rlen_out)\n{\n    krb5_error_code ret;\n    uint8_t o;\n    const uint8_t *c, *p, *tag_start = asn1;\n    size_t clen, llen, i;\n    taginfo t;\n\n    *contents_out = *remainder_out = NULL;\n    *clen_out = *rlen_out = 0;\n    if (len == 0)\n        return ASN1_OVERRUN;\n    o = *asn1++;\n    len--;\n    tag_out->asn1class = o & 0xC0;\n    tag_out->construction = o & 0x20;\n    if ((o & 0x1F) != 0x1F) {\n        tag_out->tagnum = o & 0x1F;\n    } else {\n        tag_out->tagnum = 0;\n        do {\n            if (len == 0)\n                return ASN1_OVERRUN;\n            o = *asn1++;\n            len--;\n            tag_out->tagnum = (tag_out->tagnum << 7) | (o & 0x7F);\n        } while (o & 0x80);\n    }\n\n    if (len == 0)\n        return ASN1_OVERRUN;\n    o = *asn1++;\n    len--;\n\n    if (o == 0x80) {\n        /* Indefinite form (should not be present in DER, but we accept it). */\n        if (tag_out->construction != CONSTRUCTED)\n            return ASN1_MISMATCH_INDEF;\n        p = asn1;\n        while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {\n            ret = get_tag(p, len, &t, &c, &clen, &p, &len);\n            if (ret)\n                return ret;\n        }\n        tag_out->tag_end_len = 2;\n        *contents_out = asn1;\n        *clen_out = p - asn1;\n        *remainder_out = p + 2;\n        *rlen_out = len - 2;\n    } else if ((o & 0x80) == 0) {\n        /* Short form (first octet gives content length). */\n        if (o > len)\n            return ASN1_OVERRUN;\n        tag_out->tag_end_len = 0;\n        *contents_out = asn1;\n        *clen_out = o;\n        *remainder_out = asn1 + *clen_out;\n        *rlen_out = len - (*remainder_out - asn1);\n    } else {\n        /* Long form (first octet gives number of base-256 length octets). */\n        llen = o & 0x7F;\n        if (llen > len)\n            return ASN1_OVERRUN;\n        if (llen > sizeof(*clen_out))\n            return ASN1_OVERFLOW;\n        for (i = 0, clen = 0; i < llen; i++)\n            clen = (clen << 8) | asn1[i];\n        if (clen > len - llen)\n            return ASN1_OVERRUN;\n        tag_out->tag_end_len = 0;\n        *contents_out = asn1 + llen;\n        *clen_out = clen;\n        *remainder_out = *contents_out + clen;\n        *rlen_out = len - (*remainder_out - asn1);\n    }\n    tag_out->tag_len = *contents_out - tag_start;\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""k5_asn1_full_decode"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""krb5_error_code\nk5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    /* rlen should be 0, but we don't check it (and due to padding in\n     * non-length-preserving enctypes, it will sometimes be nonzero). */\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}"", ""target"": 0}, {""func_name"": ""decode_sequence_of"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""static krb5_error_code\ndecode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\n\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}"", ""target"": 0}, {""func_name"": ""split_der"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""static krb5_error_code\nsplit_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""decode_sequence"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""static krb5_error_code\ndecode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        /*\n         * Find the applicable sequence field.  This logic is a little\n         * oversimplified; we could match an element to an optional extensible\n         * choice or optional stored-DER type when we ought to match a\n         * subsequent non-optional field.  But it's unwise and (hopefully) very\n         * rare for ASN.1 modules to require such precision.\n         */\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        /* We currently model all sequences as extensible.  We should consider\n         * changing this before making the encoder visible to plugins. */\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    /* Initialize any fields in the C object which were not accounted for in\n     * the sequence.  Error out if any of them aren't optional. */\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\n\nerror:\n    /* Free what we've decoded so far.  Free pointers in a second pass in\n     * case multiple fields refer to the same pointer. */\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}"", ""target"": 0}, {""func_name"": ""decode_atype"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""static krb5_error_code\ndecode_atype(const taginfo *t, const uint8_t *asn1, size_t len,\n             const struct atype_info *a, void *val)\n{\n    krb5_error_code ret;\n\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        assert(fn->dec != NULL);\n        return fn->dec(t, asn1, len, val);\n    }\n    case atype_sequence:\n        return decode_sequence(asn1, len, a->tinfo, val);\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *ptr = LOADPTR(val, ptrinfo);\n        assert(ptrinfo->basetype != NULL);\n        if (ptr != NULL) {\n            /* Container was already allocated by a previous sequence field. */\n            return decode_atype(t, asn1, len, ptrinfo->basetype, ptr);\n        } else {\n            ret = decode_atype_to_ptr(t, asn1, len, ptrinfo->basetype, &ptr);\n            if (ret)\n                return ret;\n            STOREPTR(ptr, ptrinfo, val);\n            break;\n        }\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        return decode_atype(t, asn1, len, off->basetype,\n                            (char *)val + off->dataoff);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        return decode_atype(t, asn1, len, opt->basetype, val);\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        void *dataptr = (char *)val + counted->dataoff;\n        size_t count;\n        assert(counted->basetype != NULL);\n        ret = decode_cntype(t, asn1, len, counted->basetype, dataptr, &count);\n        if (ret)\n            return ret;\n        return store_count(count, counted, val);\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        taginfo inner_tag;\n        const taginfo *tp = t;\n        const uint8_t *rem;\n        size_t rlen;\n        if (!tag->implicit) {\n            ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen);\n            if (ret)\n                return ret;\n            /* Note: we don't check rlen (it should be 0). */\n            tp = &inner_tag;\n            if (!check_atype_tag(tag->basetype, tp))\n                return ASN1_BAD_ID;\n        }\n        return decode_atype(tp, asn1, len, tag->basetype, val);\n    }\n    case atype_bool: {\n        intmax_t intval;\n        ret = k5_asn1_decode_bool(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_int: {\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_uint: {\n        uintmax_t intval;\n        ret = k5_asn1_decode_uint(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_uint(intval, a->size, val);\n    }\n    case atype_int_immediate: {\n        const struct immediate_info *imm = a->tinfo;\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        if (intval != imm->val && imm->err != 0)\n            return imm->err;\n        break;\n    }\n    default:\n        /* Null-terminated sequence types are handled in decode_atype_to_ptr,\n         * since they create variable-sized objects. */\n        assert(a->type != atype_nullterm_sequence_of);\n        assert(a->type != atype_nonempty_nullterm_sequence_of);\n        assert(a->type > atype_min);\n        assert(a->type < atype_max);\n        abort();\n    }\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""get_tag"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""static krb5_error_code\nget_tag(const uint8_t *asn1, size_t len, taginfo *tag_out,\n        const uint8_t **contents_out, size_t *clen_out,\n        const uint8_t **remainder_out, size_t *rlen_out, int recursion)\n{\n    krb5_error_code ret;\n    uint8_t o;\n    const uint8_t *c, *p, *tag_start = asn1;\n    size_t clen, llen, i;\n    taginfo t;\n\n    *contents_out = *remainder_out = NULL;\n    *clen_out = *rlen_out = 0;\n    if (len == 0)\n        return ASN1_OVERRUN;\n    o = *asn1++;\n    len--;\n    tag_out->asn1class = o & 0xC0;\n    tag_out->construction = o & 0x20;\n    if ((o & 0x1F) != 0x1F) {\n        tag_out->tagnum = o & 0x1F;\n    } else {\n        tag_out->tagnum = 0;\n        do {\n            if (len == 0)\n                return ASN1_OVERRUN;\n            o = *asn1++;\n            len--;\n            tag_out->tagnum = (tag_out->tagnum << 7) | (o & 0x7F);\n        } while (o & 0x80);\n    }\n\n    if (len == 0)\n        return ASN1_OVERRUN;\n    o = *asn1++;\n    len--;\n\n    if (o == 0x80) {\n        /* Indefinite form (should not be present in DER, but we accept it). */\n        if (tag_out->construction != CONSTRUCTED)\n            return ASN1_MISMATCH_INDEF;\n        if (recursion >= 32)\n            return ASN1_OVERFLOW;\n        p = asn1;\n        while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {\n            ret = get_tag(p, len, &t, &c, &clen, &p, &len, recursion + 1);\n            if (ret)\n                return ret;\n        }\n        tag_out->tag_end_len = 2;\n        *contents_out = asn1;\n        *clen_out = p - asn1;\n        *remainder_out = p + 2;\n        *rlen_out = len - 2;\n    } else if ((o & 0x80) == 0) {\n        /* Short form (first octet gives content length). */\n        if (o > len)\n            return ASN1_OVERRUN;\n        tag_out->tag_end_len = 0;\n        *contents_out = asn1;\n        *clen_out = o;\n        *remainder_out = asn1 + *clen_out;\n        *rlen_out = len - (*remainder_out - asn1);\n    } else {\n        /* Long form (first octet gives number of base-256 length octets). */\n        llen = o & 0x7F;\n        if (llen > len)\n            return ASN1_OVERRUN;\n        if (llen > sizeof(*clen_out))\n            return ASN1_OVERFLOW;\n        for (i = 0, clen = 0; i < llen; i++)\n            clen = (clen << 8) | asn1[i];\n        if (clen > len - llen)\n            return ASN1_OVERRUN;\n        tag_out->tag_end_len = 0;\n        *contents_out = asn1 + llen;\n        *clen_out = clen;\n        *remainder_out = *contents_out + clen;\n        *rlen_out = len - (*remainder_out - asn1);\n    }\n    tag_out->tag_len = *contents_out - tag_start;\n    return 0;\n}""}, {""func_name"": ""k5_asn1_full_decode"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""krb5_error_code\nk5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    /* rlen should be 0, but we don't check it (and due to padding in\n     * non-length-preserving enctypes, it will sometimes be nonzero). */\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}""}, {""func_name"": ""decode_sequence_of"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""static krb5_error_code\ndecode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\n\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}""}, {""func_name"": ""split_der"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""static krb5_error_code\nsplit_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}""}, {""func_name"": ""decode_sequence"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""static krb5_error_code\ndecode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);\n        if (ret)\n            goto error;\n        /*\n         * Find the applicable sequence field.  This logic is a little\n         * oversimplified; we could match an element to an optional extensible\n         * choice or optional stored-DER type when we ought to match a\n         * subsequent non-optional field.  But it's unwise and (hopefully) very\n         * rare for ASN.1 modules to require such precision.\n         */\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        /* We currently model all sequences as extensible.  We should consider\n         * changing this before making the encoder visible to plugins. */\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    /* Initialize any fields in the C object which were not accounted for in\n     * the sequence.  Error out if any of them aren't optional. */\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\n\nerror:\n    /* Free what we've decoded so far.  Free pointers in a second pass in\n     * case multiple fields refer to the same pointer. */\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}""}, {""func_name"": ""decode_atype"", ""file_path"": ""src/lib/krb5/asn.1/asn1_encode.c"", ""func_code"": ""static krb5_error_code\ndecode_atype(const taginfo *t, const uint8_t *asn1, size_t len,\n             const struct atype_info *a, void *val)\n{\n    krb5_error_code ret;\n\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        assert(fn->dec != NULL);\n        return fn->dec(t, asn1, len, val);\n    }\n    case atype_sequence:\n        return decode_sequence(asn1, len, a->tinfo, val);\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *ptr = LOADPTR(val, ptrinfo);\n        assert(ptrinfo->basetype != NULL);\n        if (ptr != NULL) {\n            /* Container was already allocated by a previous sequence field. */\n            return decode_atype(t, asn1, len, ptrinfo->basetype, ptr);\n        } else {\n            ret = decode_atype_to_ptr(t, asn1, len, ptrinfo->basetype, &ptr);\n            if (ret)\n                return ret;\n            STOREPTR(ptr, ptrinfo, val);\n            break;\n        }\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        return decode_atype(t, asn1, len, off->basetype,\n                            (char *)val + off->dataoff);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        return decode_atype(t, asn1, len, opt->basetype, val);\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        void *dataptr = (char *)val + counted->dataoff;\n        size_t count;\n        assert(counted->basetype != NULL);\n        ret = decode_cntype(t, asn1, len, counted->basetype, dataptr, &count);\n        if (ret)\n            return ret;\n        return store_count(count, counted, val);\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        taginfo inner_tag;\n        const taginfo *tp = t;\n        const uint8_t *rem;\n        size_t rlen;\n        if (!tag->implicit) {\n            ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0);\n            if (ret)\n                return ret;\n            /* Note: we don't check rlen (it should be 0). */\n            tp = &inner_tag;\n            if (!check_atype_tag(tag->basetype, tp))\n                return ASN1_BAD_ID;\n        }\n        return decode_atype(tp, asn1, len, tag->basetype, val);\n    }\n    case atype_bool: {\n        intmax_t intval;\n        ret = k5_asn1_decode_bool(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_int: {\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_uint: {\n        uintmax_t intval;\n        ret = k5_asn1_decode_uint(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_uint(intval, a->size, val);\n    }\n    case atype_int_immediate: {\n        const struct immediate_info *imm = a->tinfo;\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        if (intval != imm->val && imm->err != 0)\n            return imm->err;\n        break;\n    }\n    default:\n        /* Null-terminated sequence types are handled in decode_atype_to_ptr,\n         * since they create variable-sized objects. */\n        assert(a->type != atype_nullterm_sequence_of);\n        assert(a->type != atype_nonempty_nullterm_sequence_of);\n        assert(a->type > atype_min);\n        assert(a->type < atype_max);\n        abort();\n    }\n    return 0;\n}""}]",{},[],Unbounded recursion in 'get_tag' (src/lib/krb5/asn.1/asn1_encode.c) during ASN.1 indefinite-length parsing. The patch adds a 'recursion' parameter (src/lib/krb5/asn.1/asn1_encode.c:357) and enforces a 32-level limit (src/lib/krb5/asn.1/asn1_encode.c:397) to prevent stack overflow.,0.95,./github/other_context/CVE-2020-28196
21,CVE-2020-29385,CWE-835,c_cpp,"GNOME gdk-pixbuf (aka GdkPixbuf) before 2.42.2 allows a denial of service (infinite loop) in lzw.c in the function write_indexes. if c->self_code equals 10, self->code_table[10].extends will assign the value 11 to c. The next execution in the loop will assign self->code_table[11].extends to c, which will give the value of 10. This will make the loop run infinitely. This bug can, for example, be triggered by calling this function with a GIF image with LZW compression that is crafted in a special way.",https://github.com/GNOME/gdk-pixbuf/commit/bdd3acbd48a575d418ba6bf1b32d7bda2fae1c81,"gif: Fix LZW decoder accepting invalid LZW code.\n\nThe code value after a reset wasn't being validated, which means we would\naccept invalid codes. This could cause an infinite loop in the decoder.\n\nFixes CVE-2020-29385\n\nFixes https://gitlab.gnome.org/GNOME/gdk-pixbuf/-/issues/164",1,"[{""func_name"": ""lzw_decoder_feed"", ""file_path"": ""gdk-pixbuf/lzw.c"", ""func_code"": ""gsize\nlzw_decoder_feed (LZWDecoder *self,\n                  guint8     *input,\n                  gsize       input_length,\n                  guint8     *output,\n                  gsize       output_length)\n{\n        gsize i, n_written = 0;\n\n        g_return_val_if_fail (LZW_IS_DECODER (self), 0);\n\n        /* Ignore data after \""end of information\"" codeword */\n        if (self->last_code == self->eoi_code)\n                return 0;\n\n        /* Processes each octet of input */\n        for (i = 0; i < input_length; i++) {\n                guint8 d = input[i];\n                int n_available;\n\n                /* Process the bits of the octet into codewords */\n                for (n_available = 8; n_available > 0; ) {\n                        int n_bits, new_bits;\n\n                        /* Extract up the the required number of bits from the octet */\n                        n_bits = MIN (self->code_size - self->code_bits, n_available);\n                        new_bits = d & ((1 << n_bits) - 1);\n                        d = d >> n_bits;\n                        n_available -= n_bits;\n\n                        /* Add the new bits to the code until we have a full codeword */\n                        self->code = new_bits << self->code_bits | self->code;\n                        self->code_bits += n_bits;\n                        if (self->code_bits < self->code_size)\n                                continue;\n\n                        /* Stop on \""end of information\"" codeword */\n                        if (self->code == self->eoi_code) {\n                                self->last_code = self->code;\n                                return n_written;\n                        }\n\n                        /* Reset the code table on \""clear\"" */\n                        if (self->code == self->clear_code) {\n                                self->code_table_size = self->eoi_code + 1;\n                                self->code_size = self->min_code_size;\n                        } else {\n                                /* Add a new code word if space.\n                                 * The first code after a clear is skipped */\n                                if (self->last_code != self->clear_code && self->code_table_size < MAX_CODES) {\n                                        if (self->code < self->code_table_size)\n                                                add_code (self, self->code);\n                                        else if (self->code == self->code_table_size)\n                                                add_code (self, self->last_code);\n                                        else {\n                                                /* Invalid code received - just stop here */\n                                                self->last_code = self->eoi_code;\n                                                return output_length;\n                                        }\n\n                                        /* When table is full increase code size */\n                                        if (self->code_table_size == (1 << self->code_size) && self->code_size < LZW_CODE_MAX)\n                                                self->code_size++;\n                                }\n\n                                /* Convert codeword into indexes */\n                                n_written += write_indexes (self, output + n_written, output_length - n_written);\n                        }\n\n                        self->last_code = self->code;\n                        self->code = 0;\n                        self->code_bits = 0;\n\n                        /* Out of space */\n                        if (n_written >= output_length)\n                                return output_length;\n                }\n        }\n\n        return n_written;\n}"", ""target"": 0}]","[{""func_name"": ""lzw_decoder_feed"", ""file_path"": ""gdk-pixbuf/lzw.c"", ""func_code"": ""gsize\nlzw_decoder_feed (LZWDecoder *self,\n                  guint8     *input,\n                  gsize       input_length,\n                  guint8     *output,\n                  gsize       output_length)\n{\n        gsize i, n_written = 0;\n\n        g_return_val_if_fail (LZW_IS_DECODER (self), 0);\n\n        /* Ignore data after \""end of information\"" codeword */\n        if (self->last_code == self->eoi_code)\n                return 0;\n\n        /* Processes each octet of input */\n        for (i = 0; i < input_length; i++) {\n                guint8 d = input[i];\n                int n_available;\n\n                /* Process the bits of the octet into codewords */\n                for (n_available = 8; n_available > 0; ) {\n                        int n_bits, new_bits;\n\n                        /* Extract up the the required number of bits from the octet */\n                        n_bits = MIN (self->code_size - self->code_bits, n_available);\n                        new_bits = d & ((1 << n_bits) - 1);\n                        d = d >> n_bits;\n                        n_available -= n_bits;\n\n                        /* Add the new bits to the code until we have a full codeword */\n                        self->code = new_bits << self->code_bits | self->code;\n                        self->code_bits += n_bits;\n                        if (self->code_bits < self->code_size)\n                                continue;\n\n                        /* Stop on \""end of information\"" codeword */\n                        if (self->code == self->eoi_code) {\n                                self->last_code = self->code;\n                                return n_written;\n                        }\n\n                        /* Reset the code table on \""clear\"" */\n                        if (self->code == self->clear_code) {\n                                self->code_table_size = self->eoi_code + 1;\n                                self->code_size = self->min_code_size;\n                        } else {\n                                /* Add a new code word if space.\n                                 * The first code after a clear is skipped */\n                                if (self->last_code != self->clear_code && self->code_table_size < MAX_CODES) {\n                                        if (self->code < self->code_table_size)\n                                                add_code (self, self->code);\n                                        else\n                                                add_code (self, self->last_code);\n\n                                        /* When table is full increase code size */\n                                        if (self->code_table_size == (1 << self->code_size) && self->code_size < LZW_CODE_MAX)\n                                                self->code_size++;\n                                }\n\n                                /* Invalid code received - just stop here */\n                                if (self->code >= self->code_table_size) {\n                                        self->last_code = self->eoi_code;\n                                        return output_length;\n                                }\n\n                                /* Convert codeword into indexes */\n                                n_written += write_indexes (self, output + n_written, output_length - n_written);\n                        }\n\n                        self->last_code = self->code;\n                        self->code = 0;\n                        self->code_bits = 0;\n\n                        /* Out of space */\n                        if (n_written >= output_length)\n                                return output_length;\n                }\n        }\n\n        return n_written;\n}""}]","{""value"": 5, ""caller"": 1, ""code"": 4}","[{""source"": ""value_info(file:lzw.c, value:self->code)"", ""result"": {""value_trace"": [{""full_code"": ""self->code = 0"", ""line"": 140, ""func_name"": ""lzw_decoder_new""}, {""full_code"": ""self->code = new_bits << self->code_bits | self->code"", ""line"": 177, ""func_name"": ""lzw_decoder_feed""}, {""full_code"": ""self->code = 0"", ""line"": 216, ""func_name"": ""lzw_decoder_feed""}], ""struct_var"": ""self"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:lzw.c, value:self->code_table)"", ""result"": {""value_trace"": [{""full_code"": ""self->code_table[self->code_table_size].index = self->code_table[c].index"", ""line"": 69, ""func_name"": ""add_code""}, {""full_code"": ""self->code_table[self->code_table_size].extends = self->last_code"", ""line"": 70, ""func_name"": ""add_code""}, {""full_code"": ""self->code_table_size++"", ""line"": 71, ""func_name"": ""add_code""}, {""full_code"": ""self->code_table[i].index = i"", ""line"": 134, ""func_name"": ""lzw_decoder_new""}, {""full_code"": ""self->code_table[i].extends = self->eoi_code"", ""line"": 135, ""func_name"": ""lzw_decoder_new""}], ""struct_var"": ""self"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:lzw.c, func:lzw_decoder_feed)"", ""result"": [{""call_line"": 367, ""call_code"": ""lzw_decoder_feed (lzw_decoder, frame->lzw_data->data, frame->lzw_data->len, index_buffer, frame->width * frame->height)"", ""caller_code"": ""static void\ncomposite_frame (GdkPixbufGifAnim *anim, GdkPixbufFrame *frame)\n{\n        LZWDecoder *lzw_decoder = NULL;\n        guint8 *index_buffer = NULL;\n        gsize n_indexes, i;\n        guint16 *interlace_rows = NULL;\n        guchar *pixels;\n\n        anim->last_frame = frame;\n\n        /* Store overwritten data if required */\n        g_clear_object (&anim->last_frame_revert_data);\n        if (frame->action == GDK_PIXBUF_FRAME_REVERT) {\n                anim->last_frame_revert_data = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, frame->width, frame->height);\n                if (anim->last_frame_revert_data != NULL)\n                        gdk_pixbuf_copy_area (anim->last_frame_data,\n                                              frame->x_offset, frame->y_offset, frame->width, frame->height,\n                                              anim->last_frame_revert_data,\n                                              0, 0);\n        }\n\n        lzw_decoder = lzw_decoder_new (frame->lzw_code_size + 1);\n        index_buffer = g_new (guint8, frame->width * frame->height);\n        if (index_buffer == NULL)\n                goto out;\n\n        interlace_rows = g_new (guint16, frame->height);\n        if (interlace_rows == NULL)\n                goto out;\n        if (frame->interlace) {\n                int row, n = 0;\n                for (row = 0; row < frame->height; row += 8)\n                        interlace_rows[n++] = row;\n                for (row = 4; row < frame->height; row += 8)\n                        interlace_rows[n++] = row;\n                for (row = 2; row < frame->height; row += 4)\n                        interlace_rows[n++] = row;\n                for (row = 1; row < frame->height; row += 2)\n                        interlace_rows[n++] = row;\n        }\n        else {\n                int row;\n                for (row = 0; row < frame->height; row++)\n                        interlace_rows[row] = row;\n        }\n\n        n_indexes = lzw_decoder_feed (lzw_decoder, frame->lzw_data->data, frame->lzw_data->len, index_buffer, frame->width * frame->height);\n        pixels = gdk_pixbuf_get_pixels (anim->last_frame_data);\n        for (i = 0; i < n_indexes; i++) {\n                guint8 index = index_buffer[i];\n                guint x, y;\n                int offset;\n\n                if (index == frame->transparent_index)\n                        continue;\n\n                x = i % frame->width + frame->x_offset;\n                y = interlace_rows[i / frame->width] + frame->y_offset;\n                if (x >= anim->width || y >= anim->height)\n                        continue;\n\n                offset = y * gdk_pixbuf_get_rowstride (anim->last_frame_data) + x * 4;\n                pixels[offset + 0] = frame->color_map[index * 3 + 0];\n                pixels[offset + 1] = frame->color_map[index * 3 + 1];\n                pixels[offset + 2] = frame->color_map[index * 3 + 2];\n                pixels[offset + 3] = 255;\n        }\n\nout:\n        g_clear_object (&lzw_decoder);\n        g_free (index_buffer);\n        g_free (interlace_rows);\n}\n"", ""caller_start"": 320, ""file_path"": ""gdk-pixbuf/io-gif-animation.c""}]}, {""source"": ""code_info(file:lzw.c, lines:170-180)"", ""result"": ""                        /* Extract up the the required number of bits from the octet */\n                        n_bits = MIN (self->code_size - self->code_bits, n_available);\n                        new_bits = d & ((1 << n_bits) - 1);\n                        d = d >> n_bits;\n                        n_available -= n_bits;\n\n                        /* Add the new bits to the code until we have a full codeword */\n                        self->code = new_bits << self->code_bits | self->code;\n                        self->code_bits += n_bits;\n                        if (self->code_bits < self->code_size)\n                                continue;\n\n""}, {""source"": ""code_info(file:lzw.c, lines:160-170)"", ""result"": ""\n        /* Processes each octet of input */\n        for (i = 0; i < input_length; i++) {\n                guint8 d = input[i];\n                int n_available;\n\n                /* Process the bits of the octet into codewords */\n                for (n_available = 8; n_available > 0; ) {\n                        int n_bits, new_bits;\n\n                        /* Extract up the the required number of bits from the octet */\n                        n_bits = MIN (self->code_size - self->code_bits, n_available);\n""}, {""source"": ""value_info(file:lzw.c, value:d)"", ""result"": {""value_trace"": [{""full_code"": ""d = input[i]"", ""line"": 163, ""func_name"": ""lzw_decoder_feed""}, {""full_code"": ""d = d >> n_bits"", ""line"": 173, ""func_name"": ""lzw_decoder_feed""}], ""struct_var"": ""d"", ""struct_type"": ""guint8"", ""struct_definition"": ""guint8""}}, {""source"": ""code_info(file:lzw.c, lines:130-150)"", ""result"": ""        self->clear_code = 1 << (code_size - 1);\n        self->eoi_code = self->clear_code + 1;\n\n        for (i = 0; i <= self->eoi_code; i++) {\n                self->code_table[i].index = i;\n                self->code_table[i].extends = self->eoi_code;\n                self->code_table_size++;\n        }\n\n        /* Start with an empty codeword following an implicit clear codeword */\n        self->code = 0;\n        self->last_code = self->clear_code;\n\n        return self;\n}\n\ngsize\nlzw_decoder_feed (LZWDecoder *self,\n                  guint8     *input,\n                  gsize       input_length,\n                  guint8     *output,\n                  gsize       output_length)\n""}, {""source"": ""value_info(file:lzw.c, value:self->clear_code)"", ""result"": {""value_trace"": [{""full_code"": ""self->clear_code = 1 << (code_size - 1)"", ""line"": 130, ""func_name"": ""lzw_decoder_new""}], ""struct_var"": ""self"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:lzw.c, lines:180-200)"", ""result"": ""                                continue;\n\n                        /* Stop on \""end of information\"" codeword */\n                        if (self->code == self->eoi_code) {\n                                self->last_code = self->code;\n                                return n_written;\n                        }\n\n                        /* Reset the code table on \""clear\"" */\n                        if (self->code == self->clear_code) {\n                                self->code_table_size = self->eoi_code + 1;\n                                self->code_size = self->min_code_size;\n                        } else {\n                                /* Add a new code word if space.\n                                 * The first code after a clear is skipped */\n                                if (self->last_code != self->clear_code && self->code_table_size < MAX_CODES) {\n                                        if (self->code < self->code_table_size)\n                                                add_code (self, self->code);\n                                        else if (self->code == self->code_table_size)\n                                                add_code (self, self->last_code);\n                                        else {\n                                                /* Invalid code received - just stop here */\n""}, {""source"": ""value_info(file:lzw.c, value:self->code_size)"", ""result"": {""value_trace"": [{""full_code"": ""self->code_size = code_size"", ""line"": 127, ""func_name"": ""lzw_decoder_new""}, {""full_code"": ""self->code_size = self->min_code_size"", ""line"": 191, ""func_name"": ""lzw_decoder_feed""}, {""full_code"": ""self->code_size++"", ""line"": 208, ""func_name"": ""lzw_decoder_feed""}], ""struct_var"": ""self"", ""struct_type"": null, ""struct_definition"": null}}]","gdk-pixbuf/lzw.c:177-191: self->code is constructed from input data (d<<code_bits | code) in lzw_decoder_feed:177. After encountering a clear_code (lzw_decoder_feed:191), code_table_size and code_size are reset but self->code is not validated against code_table_size before add_code is called. This allows invalid codes (e.g., 10/11) to create cyclic extends pointers in code_table (add_code:70), triggering infinite loops in write_indexes. The patch (lzw.c:207-212) adds a termination check for self->code >= code_table_size.",0.95,./github/other_context/CVE-2020-29385
22,CVE-2020-36277,CWE-670,c_cpp,Leptonica before 1.80.0 allows a denial of service (application crash) via an incorrect left shift in pixConvert2To8 in pixconv.c.,https://github.com/DanBloomberg/leptonica/commit/3ddd9a35cebc28f2b1a5693c27dcfff58218674a,"Fix heap buffer overflow in selReadStream\n\nselio_reg triggers a heap buffer overflow when sscanf tries to write 201 bytes into a 24 byte string.\nIt can be detected when the code is compiled with the address sanitizer:\n\n    ==19856==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000001288 at pc 0x00000044462b bp 0x7fffffffddf0 sp 0x7fffffffd5a0\n    WRITE of size 201 at 0x603000001288 thread T0\n    0x603000001288 is located 0 bytes to the right of 24-byte region [0x603000001270,0x603000001288)\n\nSigned-off-by: Stefan Weil <sw@weilnetz.de>",1,"[{""func_name"": ""selReadStream"", ""file_path"": ""src/sel1.c"", ""func_code"": ""SEL  *\nselReadStream(FILE  *fp)\n{\nchar    *selname;\nchar     linebuf[256];\nl_int32  sy, sx, cy, cx, i, j, version, ignore;\nSEL     *sel;\n\n    PROCNAME(\""selReadStream\"");\n\n    if (!fp)\n        return (SEL *)ERROR_PTR(\""stream not defined\"", procName, NULL);\n\n    if (fscanf(fp, \""  Sel Version %d\\n\"", &version) != 1)\n        return (SEL *)ERROR_PTR(\""not a sel file\"", procName, NULL);\n    if (version != SEL_VERSION_NUMBER)\n        return (SEL *)ERROR_PTR(\""invalid sel version\"", procName, NULL);\n\n    if (fgets(linebuf, sizeof(linebuf), fp) == NULL)\n        return (SEL *)ERROR_PTR(\""error reading into linebuf\"", procName, NULL);\n    selname = stringNew(linebuf);\n    sscanf(linebuf, \""  ------  %200s  ------\"", selname);\n\n    if (fscanf(fp, \""  sy = %d, sx = %d, cy = %d, cx = %d\\n\"",\n            &sy, &sx, &cy, &cx) != 4) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\""dimensions not read\"", procName, NULL);\n    }\n\n    if ((sel = selCreate(sy, sx, selname)) == NULL) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\""sel not made\"", procName, NULL);\n    }\n    selSetOrigin(sel, cy, cx);\n\n    for (i = 0; i < sy; i++) {\n        ignore = fscanf(fp, \""    \"");\n        for (j = 0; j < sx; j++)\n            ignore = fscanf(fp, \""%1d\"", &sel->data[i][j]);\n        ignore = fscanf(fp, \""\\n\"");\n    }\n    ignore = fscanf(fp, \""\\n\"");\n\n    LEPT_FREE(selname);\n    return sel;\n}"", ""target"": 0}]","[{""func_name"": ""selReadStream"", ""file_path"": ""src/sel1.c"", ""func_code"": ""SEL  *\nselReadStream(FILE  *fp)\n{\nchar     selname[256];\nchar     linebuf[256];\nl_int32  sy, sx, cy, cx, i, j, version, ignore;\nSEL     *sel;\n\n    PROCNAME(\""selReadStream\"");\n\n    if (!fp)\n        return (SEL *)ERROR_PTR(\""stream not defined\"", procName, NULL);\n\n    if (fscanf(fp, \""  Sel Version %d\\n\"", &version) != 1)\n        return (SEL *)ERROR_PTR(\""not a sel file\"", procName, NULL);\n    if (version != SEL_VERSION_NUMBER)\n        return (SEL *)ERROR_PTR(\""invalid sel version\"", procName, NULL);\n\n    if (fgets(linebuf, sizeof(linebuf), fp) == NULL)\n        return (SEL *)ERROR_PTR(\""error reading into linebuf\"", procName, NULL);\n    sscanf(linebuf, \""  ------  %200s  ------\"", selname);\n\n    if (fscanf(fp, \""  sy = %d, sx = %d, cy = %d, cx = %d\\n\"",\n            &sy, &sx, &cy, &cx) != 4) {\n        return (SEL *)ERROR_PTR(\""dimensions not read\"", procName, NULL);\n    }\n\n    if ((sel = selCreate(sy, sx, selname)) == NULL) {\n        return (SEL *)ERROR_PTR(\""sel not made\"", procName, NULL);\n    }\n    selSetOrigin(sel, cy, cx);\n\n    for (i = 0; i < sy; i++) {\n        ignore = fscanf(fp, \""    \"");\n        for (j = 0; j < sx; j++)\n            ignore = fscanf(fp, \""%1d\"", &sel->data[i][j]);\n        ignore = fscanf(fp, \""\\n\"");\n    }\n    ignore = fscanf(fp, \""\\n\"");\n\n    return sel;\n}""}]","{""function"": 1}","[{""source"": ""func_info(func:stringNew)"", ""result"": [{""code"": ""char *\nstringNew(const char  *src)\n{\nl_int32  len;\nchar    *dest;\n\n    PROCNAME(\""stringNew\"");\n\n    if (!src) {\n        L_WARNING(\""src not defined\\n\"", procName);\n        return NULL;\n    }\n\n    len = strlen(src);\n    if ((dest = (char *)LEPT_CALLOC(len + 1, sizeof(char))) == NULL)\n        return (char *)ERROR_PTR(\""dest not made\"", procName, NULL);\n\n    stringCopy(dest, src, len);\n    return dest;\n}"", ""start_line"": 219, ""end_line"": 238, ""full_name"": ""stringNew"", ""file_path"": ""src/utils2.c""}]}]","src/sel1.c:1415: 'selname' was allocated via 'stringNew(linebuf)' (src/utils2.c:219-238), which allocates len(linebuf) + 1 bytes. If linebuf's content is only 23 characters, 'stringNew' allocates 24 bytes. 'sscanf(linebuf, ""  ------  %200s  ------"", selname)' (src/sel1.c:1434) writes 201 bytes into this 24-byte buffer, causing a heap buffer overflow. Patch replaces dynamic allocation with a 256-byte stack buffer.",0.95,./github/other_context/CVE-2020-36277
23,CVE-2021-42715,CWE-835,c_cpp,An issue was discovered in stb stb_image.h 1.33 through 2.27. The HDR loader parsed truncated end-of-file RLE scanlines as an infinite sequence of zero-length runs. An attacker could potentially have caused denial of service in applications using stb_image by submitting crafted HDR files.,https://github.com/nothings/stb/commit/2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6,Fixes two stb_image issues that could occur with specially constructed HDR and PGM files.\n\nSigned-off-by: Neil Bickford <nbickford@nvidia.com>,2,"[{""func_name"": ""stbi__hdr_load"", ""file_path"": ""stb_image.h"", ""func_code"": ""static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int width, height;\n   stbi_uc *scanline;\n   float *hdr_data;\n   int len;\n   unsigned char count, value;\n   int i, j, k, c1,c2, z;\n   const char *headerToken;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   headerToken = stbi__hdr_gettoken(s,buffer);\n   if (strcmp(headerToken, \""#?RADIANCE\"") != 0 && strcmp(headerToken, \""#?RGBE\"") != 0)\n      return stbi__errpf(\""not HDR\"", \""Corrupt HDR image\"");\n\n   // Parse header\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \""FORMAT=32-bit_rle_rgbe\"") == 0) valid = 1;\n   }\n\n   if (!valid)    return stbi__errpf(\""unsupported format\"", \""Unsupported HDR format\"");\n\n   // Parse width and height\n   // can't use sscanf() if we're not using stdio!\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \""-Y \"", 3))  return stbi__errpf(\""unsupported data layout\"", \""Unsupported HDR format\"");\n   token += 3;\n   height = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \""+X \"", 3))  return stbi__errpf(\""unsupported data layout\"", \""Unsupported HDR format\"");\n   token += 3;\n   width = (int) strtol(token, NULL, 10);\n\n   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(\""too large\"",\""Very large image (corrupt?)\"");\n   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(\""too large\"",\""Very large image (corrupt?)\"");\n\n   *x = width;\n   *y = height;\n\n   if (comp) *comp = 3;\n   if (req_comp == 0) req_comp = 3;\n\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\n      return stbi__errpf(\""too large\"", \""HDR image is too large\"");\n\n   // Read data\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\n   if (!hdr_data)\n      return stbi__errpf(\""outofmem\"", \""Out of memory\"");\n\n   // Load image data\n   // image data is stored as some number of sca\n   if ( width < 8 || width >= 32768) {\n      // Read flat data\n      for (j=0; j < height; ++j) {\n         for (i=0; i < width; ++i) {\n            stbi_uc rgbe[4];\n           main_decode_loop:\n            stbi__getn(s, rgbe, 4);\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\n         }\n      }\n   } else {\n      // Read RLE-encoded data\n      scanline = NULL;\n\n      for (j = 0; j < height; ++j) {\n         c1 = stbi__get8(s);\n         c2 = stbi__get8(s);\n         len = stbi__get8(s);\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\n            // not run-length encoded, so we have to actually use THIS data as a decoded\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\n            stbi_uc rgbe[4];\n            rgbe[0] = (stbi_uc) c1;\n            rgbe[1] = (stbi_uc) c2;\n            rgbe[2] = (stbi_uc) len;\n            rgbe[3] = (stbi_uc) stbi__get8(s);\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\n            i = 1;\n            j = 0;\n            STBI_FREE(scanline);\n            goto main_decode_loop; // yes, this makes no sense\n         }\n         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\""invalid decoded scanline length\"", \""corrupt HDR\""); }\n         if (scanline == NULL) {\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\n            if (!scanline) {\n               STBI_FREE(hdr_data);\n               return stbi__errpf(\""outofmem\"", \""Out of memory\"");\n            }\n         }\n\n         for (k = 0; k < 4; ++k) {\n            int nleft;\n            i = 0;\n            while ((nleft = width - i) > 0) {\n               count = stbi__get8(s);\n               if (count > 128) {\n                  // Run\n                  value = stbi__get8(s);\n                  count -= 128;\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\""corrupt\"", \""bad RLE data in HDR\""); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = value;\n               } else {\n                  // Dump\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\""corrupt\"", \""bad RLE data in HDR\""); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = stbi__get8(s);\n               }\n            }\n         }\n         for (i=0; i < width; ++i)\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\n      }\n      if (scanline)\n         STBI_FREE(scanline);\n   }\n\n   return hdr_data;\n}"", ""target"": 0}, {""func_name"": ""stbi__pnm_load"", ""file_path"": ""stb_image.h"", ""func_code"": ""static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);\n   if (ri->bits_per_channel == 0)\n      return 0;\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n\n   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))\n      return stbi__errpuc(\""too large\"", \""PNM too large\"");\n\n   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\n   if (!out) return stbi__errpuc(\""outofmem\"", \""Out of memory\"");\n   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));\n\n   if (req_comp && req_comp != s->img_n) {\n      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n   return out;\n}"", ""target"": 0}]","[{""func_name"": ""stbi__hdr_load"", ""file_path"": ""stb_image.h"", ""func_code"": ""static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int width, height;\n   stbi_uc *scanline;\n   float *hdr_data;\n   int len;\n   unsigned char count, value;\n   int i, j, k, c1,c2, z;\n   const char *headerToken;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   headerToken = stbi__hdr_gettoken(s,buffer);\n   if (strcmp(headerToken, \""#?RADIANCE\"") != 0 && strcmp(headerToken, \""#?RGBE\"") != 0)\n      return stbi__errpf(\""not HDR\"", \""Corrupt HDR image\"");\n\n   // Parse header\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \""FORMAT=32-bit_rle_rgbe\"") == 0) valid = 1;\n   }\n\n   if (!valid)    return stbi__errpf(\""unsupported format\"", \""Unsupported HDR format\"");\n\n   // Parse width and height\n   // can't use sscanf() if we're not using stdio!\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \""-Y \"", 3))  return stbi__errpf(\""unsupported data layout\"", \""Unsupported HDR format\"");\n   token += 3;\n   height = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \""+X \"", 3))  return stbi__errpf(\""unsupported data layout\"", \""Unsupported HDR format\"");\n   token += 3;\n   width = (int) strtol(token, NULL, 10);\n\n   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(\""too large\"",\""Very large image (corrupt?)\"");\n   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(\""too large\"",\""Very large image (corrupt?)\"");\n\n   *x = width;\n   *y = height;\n\n   if (comp) *comp = 3;\n   if (req_comp == 0) req_comp = 3;\n\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\n      return stbi__errpf(\""too large\"", \""HDR image is too large\"");\n\n   // Read data\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\n   if (!hdr_data)\n      return stbi__errpf(\""outofmem\"", \""Out of memory\"");\n\n   // Load image data\n   // image data is stored as some number of sca\n   if ( width < 8 || width >= 32768) {\n      // Read flat data\n      for (j=0; j < height; ++j) {\n         for (i=0; i < width; ++i) {\n            stbi_uc rgbe[4];\n           main_decode_loop:\n            stbi__getn(s, rgbe, 4);\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\n         }\n      }\n   } else {\n      // Read RLE-encoded data\n      scanline = NULL;\n\n      for (j = 0; j < height; ++j) {\n         c1 = stbi__get8(s);\n         c2 = stbi__get8(s);\n         len = stbi__get8(s);\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\n            // not run-length encoded, so we have to actually use THIS data as a decoded\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\n            stbi_uc rgbe[4];\n            rgbe[0] = (stbi_uc) c1;\n            rgbe[1] = (stbi_uc) c2;\n            rgbe[2] = (stbi_uc) len;\n            rgbe[3] = (stbi_uc) stbi__get8(s);\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\n            i = 1;\n            j = 0;\n            STBI_FREE(scanline);\n            goto main_decode_loop; // yes, this makes no sense\n         }\n         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\""invalid decoded scanline length\"", \""corrupt HDR\""); }\n         if (scanline == NULL) {\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\n            if (!scanline) {\n               STBI_FREE(hdr_data);\n               return stbi__errpf(\""outofmem\"", \""Out of memory\"");\n            }\n         }\n\n         for (k = 0; k < 4; ++k) {\n            int nleft;\n            i = 0;\n            while ((nleft = width - i) > 0) {\n               count = stbi__get8(s);\n               if (count > 128) {\n                  // Run\n                  value = stbi__get8(s);\n                  count -= 128;\n                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\""corrupt\"", \""bad RLE data in HDR\""); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = value;\n               } else {\n                  // Dump\n                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\""corrupt\"", \""bad RLE data in HDR\""); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = stbi__get8(s);\n               }\n            }\n         }\n         for (i=0; i < width; ++i)\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\n      }\n      if (scanline)\n         STBI_FREE(scanline);\n   }\n\n   return hdr_data;\n}""}, {""func_name"": ""stbi__pnm_load"", ""file_path"": ""stb_image.h"", ""func_code"": ""static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);\n   if (ri->bits_per_channel == 0)\n      return 0;\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n\n   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))\n      return stbi__errpuc(\""too large\"", \""PNM too large\"");\n\n   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\n   if (!out) return stbi__errpuc(\""outofmem\"", \""Out of memory\"");\n   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {\n      STBI_FREE(out);\n      return stbi__errpuc(\""bad PNM\"", \""PNM file truncated\"");\n   }\n\n   if (req_comp && req_comp != s->img_n) {\n      if (ri->bits_per_channel == 16) {\n         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);\n      } else {\n         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n      }\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n   return out;\n}""}]","{""code"": 1, ""function"": 1}","[{""source"": ""code_info(file:stb_image.h, lines:7170-7180)"", ""result"": ""         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\""invalid decoded scanline length\"", \""corrupt HDR\""); }\n         if (scanline == NULL) {\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\n            if (!scanline) {\n               STBI_FREE(hdr_data);\n               return stbi__errpf(\""outofmem\"", \""Out of memory\"");\n            }\n         }\n\n         for (k = 0; k < 4; ++k) {\n""}, {""source"": ""func_info(file:stb_image.h, func:stbi__getn)"", ""result"": [{""code"": ""static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)\n{\n   if (s->io.read) {\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\n      if (blen < n) {\n         int res, count;\n\n         memcpy(buffer, s->img_buffer, blen);\n\n         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);\n         res = (count == (n-blen));\n         s->img_buffer = s->img_buffer_end;\n         return res;\n      }\n   }\n\n   if (s->img_buffer+n <= s->img_buffer_end) {\n      memcpy(buffer, s->img_buffer, n);\n      s->img_buffer += n;\n      return 1;\n   } else\n      return 0;\n}"", ""start_line"": 1646, ""end_line"": 1668, ""full_name"": ""stbi__getn"", ""file_path"": ""stb_image.h""}]}]",HDR Chain:\n1. Malformed HDR file provides a 'count' value of 0 via `stbi__get8(s)` (stb_image.h:7188-7198)\n2. Unchecked zero-length RLE run triggers infinite loop in scanline processing\n3. Patch adds `count == 0` validation to reject invalid RLE data\n\nPNM Chain:\n1. Truncated PGM/PPM file causes `stbi__getn()` to return 0 (stb_image.h:1646-1668)\n2. Unchecked return value allows use of incomplete `out` buffer data\n3. Patch adds explicit `stbi__getn()` return validation to reject truncated files,0.95,./github/other_context/CVE-2021-42715
24,CVE-2021-45290,CWE-617,c_cpp,A Denial of Service vulnerability exits in Binaryen 103 due to an assertion abort in wasm::handle_unreachable.,https://github.com/WebAssembly/binaryen/commit/859d8996d68b5d279712172669c216569398ae97,fix,1,"[{""func_name"": ""WasmBinaryBuilder::visitRefAs"", ""file_path"": ""src/wasm/wasm-binary.cpp"", ""func_code"": ""void WasmBinaryBuilder::visitRefAs(RefAs* curr, uint8_t code) {\n  BYN_TRACE(\""zz node: RefAs\\n\"");\n  switch (code) {\n    case BinaryConsts::RefAsNonNull:\n      curr->op = RefAsNonNull;\n      break;\n    case BinaryConsts::RefAsFunc:\n      curr->op = RefAsFunc;\n      break;\n    case BinaryConsts::RefAsData:\n      curr->op = RefAsData;\n      break;\n    case BinaryConsts::RefAsI31:\n      curr->op = RefAsI31;\n      break;\n    default:\n      WASM_UNREACHABLE(\""invalid code for ref.as_*\"");\n  }\n  curr->value = popNonVoidExpression();\n  curr->finalize();\n}"", ""target"": 0}]","[{""func_name"": ""WasmBinaryBuilder::visitRefAs"", ""file_path"": ""src/wasm/wasm-binary.cpp"", ""func_code"": ""void WasmBinaryBuilder::visitRefAs(RefAs* curr, uint8_t code) {\n  BYN_TRACE(\""zz node: RefAs\\n\"");\n  switch (code) {\n    case BinaryConsts::RefAsNonNull:\n      curr->op = RefAsNonNull;\n      break;\n    case BinaryConsts::RefAsFunc:\n      curr->op = RefAsFunc;\n      break;\n    case BinaryConsts::RefAsData:\n      curr->op = RefAsData;\n      break;\n    case BinaryConsts::RefAsI31:\n      curr->op = RefAsI31;\n      break;\n    default:\n      WASM_UNREACHABLE(\""invalid code for ref.as_*\"");\n  }\n  curr->value = popNonVoidExpression();\n  if (!curr->value->type.isRef() && curr->value->type != Type::unreachable) {\n    throwError(\""bad input type for ref.as: \"" + curr->value->type.toString());\n  }\n  curr->finalize();\n}""}]","{""caller"": 2, ""value"": 1, ""function"": 1}","[{""source"": ""caller_info(file:wasm-binary.cpp, func:visitRefAs)"", ""result"": [{""call_line"": 3510, ""call_code"": ""visitRefAs((curr = allocator.alloc<RefAs>())->cast<RefAs>(), code)"", ""caller_code"": ""BinaryConsts::ASTNodes WasmBinaryBuilder::readExpression(Expression*& curr) {\n  if (pos == endOfFunction) {\n    throwError(\""Reached function end without seeing End opcode\"");\n  }\n  BYN_TRACE(\""zz recurse into \"" << ++depth << \"" at \"" << pos << std::endl);\n  readNextDebugLocation();\n  std::set<Function::DebugLocation> currDebugLocation;\n  if (debugLocation.size()) {\n    currDebugLocation.insert(*debugLocation.begin());\n  }\n  size_t startPos = pos;\n  uint8_t code = getInt8();\n  BYN_TRACE(\""readExpression seeing \"" << (int)code << std::endl);\n  switch (code) {\n    case BinaryConsts::Block:\n      visitBlock((curr = allocator.alloc<Block>())->cast<Block>());\n      break;\n    case BinaryConsts::If:\n      visitIf((curr = allocator.alloc<If>())->cast<If>());\n      break;\n    case BinaryConsts::Loop:\n      visitLoop((curr = allocator.alloc<Loop>())->cast<Loop>());\n      break;\n    case BinaryConsts::Br:\n    case BinaryConsts::BrIf:\n      visitBreak((curr = allocator.alloc<Break>())->cast<Break>(), code);\n      break; // code distinguishes br from br_if\n    case BinaryConsts::BrTable:\n      visitSwitch((curr = allocator.alloc<Switch>())->cast<Switch>());\n      break;\n    case BinaryConsts::CallFunction:\n      visitCall((curr = allocator.alloc<Call>())->cast<Call>());\n      break;\n    case BinaryConsts::CallIndirect:\n      visitCallIndirect(\n        (curr = allocator.alloc<CallIndirect>())->cast<CallIndirect>());\n      break;\n    case BinaryConsts::RetCallFunction: {\n      auto call = allocator.alloc<Call>();\n      call->isReturn = true;\n      curr = call;\n      visitCall(call);\n      break;\n    }\n    case BinaryConsts::RetCallIndirect: {\n      auto call = allocator.alloc<CallIndirect>();\n      call->isReturn = true;\n      curr = call;\n      visitCallIndirect(call);\n      break;\n    }\n    case BinaryConsts::LocalGet:\n      visitLocalGet((curr = allocator.alloc<LocalGet>())->cast<LocalGet>());\n      break;\n    case BinaryConsts::LocalTee:\n    case BinaryConsts::LocalSet:\n      visitLocalSet((curr = allocator.alloc<LocalSet>())->cast<LocalSet>(),\n                    code);\n      break;\n    case BinaryConsts::GlobalGet:\n      visitGlobalGet((curr = allocator.alloc<GlobalGet>())->cast<GlobalGet>());\n      break;\n    case BinaryConsts::GlobalSet:\n      visitGlobalSet((curr = allocator.alloc<GlobalSet>())->cast<GlobalSet>());\n      break;\n    case BinaryConsts::Select:\n    case BinaryConsts::SelectWithType:\n      visitSelect((curr = allocator.alloc<Select>())->cast<Select>(), code);\n      break;\n    case BinaryConsts::Return:\n      visitReturn((curr = allocator.alloc<Return>())->cast<Return>());\n      break;\n    case BinaryConsts::Nop:\n      visitNop((curr = allocator.alloc<Nop>())->cast<Nop>());\n      break;\n    case BinaryConsts::Unreachable:\n      visitUnreachable(\n        (curr = allocator.alloc<Unreachable>())->cast<Unreachable>());\n      break;\n    case BinaryConsts::Drop:\n      visitDrop((curr = allocator.alloc<Drop>())->cast<Drop>());\n      break;\n    case BinaryConsts::End:\n      curr = nullptr;\n      // Pop the current control flow structure off the stack. If there is none\n      // then this is the \""end\"" of the function itself, which also emits an\n      // \""end\"" byte.\n      if (!controlFlowStack.empty()) {\n        controlFlowStack.pop_back();\n      }\n      break;\n    case BinaryConsts::Else:\n    case BinaryConsts::Catch:\n    case BinaryConsts::CatchAll: {\n      curr = nullptr;\n      if (DWARF && currFunction) {\n        assert(!controlFlowStack.empty());\n        auto currControlFlow = controlFlowStack.back();\n        BinaryLocation delimiterId;\n        if (currControlFlow->is<If>()) {\n          delimiterId = BinaryLocations::Else;\n        } else {\n          // Both Catch and CatchAll can simply append to the list as we go, as\n          // we visit them in the right order in the binary, and like the binary\n          // we store the CatchAll at the end.\n          delimiterId =\n            currFunction->delimiterLocations[currControlFlow].size();\n        }\n        currFunction->delimiterLocations[currControlFlow][delimiterId] =\n          startPos - codeSectionLocation;\n      }\n      break;\n    }\n    case BinaryConsts::Delegate: {\n      curr = nullptr;\n      if (DWARF && currFunction) {\n        assert(!controlFlowStack.empty());\n        controlFlowStack.pop_back();\n      }\n      break;\n    }\n    case BinaryConsts::RefNull:\n      visitRefNull((curr = allocator.alloc<RefNull>())->cast<RefNull>());\n      break;\n    case BinaryConsts::RefIsNull:\n      visitRefIs((curr = allocator.alloc<RefIs>())->cast<RefIs>(), code);\n      break;\n    case BinaryConsts::RefFunc:\n      visitRefFunc((curr = allocator.alloc<RefFunc>())->cast<RefFunc>());\n      break;\n    case BinaryConsts::RefEq:\n      visitRefEq((curr = allocator.alloc<RefEq>())->cast<RefEq>());\n      break;\n    case BinaryConsts::RefAsNonNull:\n      visitRefAs((curr = allocator.alloc<RefAs>())->cast<RefAs>(), code);\n      break;\n    case BinaryConsts::BrOnNull:\n      maybeVisitBrOn(curr, code);\n      break;\n    case BinaryConsts::BrOnNonNull:\n      maybeVisitBrOn(curr, code);\n      break;\n    case BinaryConsts::TableGet:\n      visitTableGet((curr = allocator.alloc<TableGet>())->cast<TableGet>());\n      break;\n    case BinaryConsts::TableSet:\n      visitTableSet((curr = allocator.alloc<TableSet>())->cast<TableSet>());\n      break;\n    case BinaryConsts::Try:\n      visitTryOrTryInBlock(curr);\n      break;\n    case BinaryConsts::Throw:\n      visitThrow((curr = allocator.alloc<Throw>())->cast<Throw>());\n      break;\n    case BinaryConsts::Rethrow:\n      visitRethrow((curr = allocator.alloc<Rethrow>())->cast<Rethrow>());\n      break;\n    case BinaryConsts::MemorySize: {\n      auto size = allocator.alloc<MemorySize>();\n      if (wasm.memory.is64()) {\n        size->make64();\n      }\n      curr = size;\n      visitMemorySize(size);\n      break;\n    }\n    case BinaryConsts::MemoryGrow: {\n      auto grow = allocator.alloc<MemoryGrow>();\n      if (wasm.memory.is64()) {\n        grow->make64();\n      }\n      curr = grow;\n      visitMemoryGrow(grow);\n      break;\n    }\n    case BinaryConsts::CallRef:\n      visitCallRef((curr = allocator.alloc<CallRef>())->cast<CallRef>());\n      break;\n    case BinaryConsts::RetCallRef: {\n      auto call = allocator.alloc<CallRef>();\n      call->isReturn = true;\n      curr = call;\n      visitCallRef(call);\n      break;\n    }\n    case BinaryConsts::Let: {\n      visitLet((curr = allocator.alloc<Block>())->cast<Block>());\n      break;\n    }\n    case BinaryConsts::AtomicPrefix: {\n      code = static_cast<uint8_t>(getU32LEB());\n      if (maybeVisitLoad(curr, code, /*isAtomic=*/true)) {\n        break;\n      }\n      if (maybeVisitStore(curr, code, /*isAtomic=*/true)) {\n        break;\n      }\n      if (maybeVisitAtomicRMW(curr, code)) {\n        break;\n      }\n      if (maybeVisitAtomicCmpxchg(curr, code)) {\n        break;\n      }\n      if (maybeVisitAtomicWait(curr, code)) {\n        break;\n      }\n      if (maybeVisitAtomicNotify(curr, code)) {\n        break;\n      }\n      if (maybeVisitAtomicFence(curr, code)) {\n        break;\n      }\n      throwError(\""invalid code after atomic prefix: \"" + std::to_string(code));\n      break;\n    }\n    case BinaryConsts::MiscPrefix: {\n      auto opcode = getU32LEB();\n      if (maybeVisitTruncSat(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitMemoryInit(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitDataDrop(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitMemoryCopy(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitMemoryFill(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitTableSize(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitTableGrow(curr, opcode)) {\n        break;\n      }\n      throwError(\""invalid code after misc prefix: \"" + std::to_string(opcode));\n      break;\n    }\n    case BinaryConsts::SIMDPrefix: {\n      auto opcode = getU32LEB();\n      if (maybeVisitSIMDBinary(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDUnary(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDConst(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDStore(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDExtract(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDReplace(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDShuffle(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDTernary(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDShift(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDLoad(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDLoadStoreLane(curr, opcode)) {\n        break;\n      }\n      throwError(\""invalid code after SIMD prefix: \"" + std::to_string(opcode));\n      break;\n    }\n    case BinaryConsts::GCPrefix: {\n      auto opcode = getU32LEB();\n      if (maybeVisitI31New(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitI31Get(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitRefTest(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitRefCast(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitBrOn(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitRttCanon(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitRttSub(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitStructNew(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitStructGet(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitStructSet(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArrayNew(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArrayInit(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArrayGet(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArraySet(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArrayLen(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArrayCopy(curr, opcode)) {\n        break;\n      }\n      if (opcode == BinaryConsts::RefIsFunc ||\n          opcode == BinaryConsts::RefIsData ||\n          opcode == BinaryConsts::RefIsI31) {\n        visitRefIs((curr = allocator.alloc<RefIs>())->cast<RefIs>(), opcode);\n        break;\n      }\n      if (opcode == BinaryConsts::RefAsFunc ||\n          opcode == BinaryConsts::RefAsData ||\n          opcode == BinaryConsts::RefAsI31) {\n        visitRefAs((curr = allocator.alloc<RefAs>())->cast<RefAs>(), opcode);\n        break;\n      }\n      throwError(\""invalid code after GC prefix: \"" + std::to_string(opcode));\n      break;\n    }\n    default: {\n      // otherwise, the code is a subcode TODO: optimize\n      if (maybeVisitBinary(curr, code)) {\n        break;\n      }\n      if (maybeVisitUnary(curr, code)) {\n        break;\n      }\n      if (maybeVisitConst(curr, code)) {\n        break;\n      }\n      if (maybeVisitLoad(curr, code, /*isAtomic=*/false)) {\n        break;\n      }\n      if (maybeVisitStore(curr, code, /*isAtomic=*/false)) {\n        break;\n      }\n      throwError(\""bad node code \"" + std::to_string(code));\n      break;\n    }\n  }\n  if (curr) {\n    if (currDebugLocation.size()) {\n      currFunction->debugLocations[curr] = *currDebugLocation.begin();\n    }\n    if (DWARF && currFunction) {\n      currFunction->expressionLocations[curr] =\n        BinaryLocations::Span{BinaryLocation(startPos - codeSectionLocation),\n                              BinaryLocation(pos - codeSectionLocation)};\n    }\n  }\n  BYN_TRACE(\""zz recurse from \"" << depth-- << \"" at \"" << pos << std::endl);\n  return BinaryConsts::ASTNodes(code);\n}\n"", ""caller_start"": 3376, ""file_path"": ""src/wasm/wasm-binary.cpp""}, {""call_line"": 3714, ""call_code"": ""visitRefAs((curr = allocator.alloc<RefAs>())->cast<RefAs>(), opcode)"", ""caller_code"": ""BinaryConsts::ASTNodes WasmBinaryBuilder::readExpression(Expression*& curr) {\n  if (pos == endOfFunction) {\n    throwError(\""Reached function end without seeing End opcode\"");\n  }\n  BYN_TRACE(\""zz recurse into \"" << ++depth << \"" at \"" << pos << std::endl);\n  readNextDebugLocation();\n  std::set<Function::DebugLocation> currDebugLocation;\n  if (debugLocation.size()) {\n    currDebugLocation.insert(*debugLocation.begin());\n  }\n  size_t startPos = pos;\n  uint8_t code = getInt8();\n  BYN_TRACE(\""readExpression seeing \"" << (int)code << std::endl);\n  switch (code) {\n    case BinaryConsts::Block:\n      visitBlock((curr = allocator.alloc<Block>())->cast<Block>());\n      break;\n    case BinaryConsts::If:\n      visitIf((curr = allocator.alloc<If>())->cast<If>());\n      break;\n    case BinaryConsts::Loop:\n      visitLoop((curr = allocator.alloc<Loop>())->cast<Loop>());\n      break;\n    case BinaryConsts::Br:\n    case BinaryConsts::BrIf:\n      visitBreak((curr = allocator.alloc<Break>())->cast<Break>(), code);\n      break; // code distinguishes br from br_if\n    case BinaryConsts::BrTable:\n      visitSwitch((curr = allocator.alloc<Switch>())->cast<Switch>());\n      break;\n    case BinaryConsts::CallFunction:\n      visitCall((curr = allocator.alloc<Call>())->cast<Call>());\n      break;\n    case BinaryConsts::CallIndirect:\n      visitCallIndirect(\n        (curr = allocator.alloc<CallIndirect>())->cast<CallIndirect>());\n      break;\n    case BinaryConsts::RetCallFunction: {\n      auto call = allocator.alloc<Call>();\n      call->isReturn = true;\n      curr = call;\n      visitCall(call);\n      break;\n    }\n    case BinaryConsts::RetCallIndirect: {\n      auto call = allocator.alloc<CallIndirect>();\n      call->isReturn = true;\n      curr = call;\n      visitCallIndirect(call);\n      break;\n    }\n    case BinaryConsts::LocalGet:\n      visitLocalGet((curr = allocator.alloc<LocalGet>())->cast<LocalGet>());\n      break;\n    case BinaryConsts::LocalTee:\n    case BinaryConsts::LocalSet:\n      visitLocalSet((curr = allocator.alloc<LocalSet>())->cast<LocalSet>(),\n                    code);\n      break;\n    case BinaryConsts::GlobalGet:\n      visitGlobalGet((curr = allocator.alloc<GlobalGet>())->cast<GlobalGet>());\n      break;\n    case BinaryConsts::GlobalSet:\n      visitGlobalSet((curr = allocator.alloc<GlobalSet>())->cast<GlobalSet>());\n      break;\n    case BinaryConsts::Select:\n    case BinaryConsts::SelectWithType:\n      visitSelect((curr = allocator.alloc<Select>())->cast<Select>(), code);\n      break;\n    case BinaryConsts::Return:\n      visitReturn((curr = allocator.alloc<Return>())->cast<Return>());\n      break;\n    case BinaryConsts::Nop:\n      visitNop((curr = allocator.alloc<Nop>())->cast<Nop>());\n      break;\n    case BinaryConsts::Unreachable:\n      visitUnreachable(\n        (curr = allocator.alloc<Unreachable>())->cast<Unreachable>());\n      break;\n    case BinaryConsts::Drop:\n      visitDrop((curr = allocator.alloc<Drop>())->cast<Drop>());\n      break;\n    case BinaryConsts::End:\n      curr = nullptr;\n      // Pop the current control flow structure off the stack. If there is none\n      // then this is the \""end\"" of the function itself, which also emits an\n      // \""end\"" byte.\n      if (!controlFlowStack.empty()) {\n        controlFlowStack.pop_back();\n      }\n      break;\n    case BinaryConsts::Else:\n    case BinaryConsts::Catch:\n    case BinaryConsts::CatchAll: {\n      curr = nullptr;\n      if (DWARF && currFunction) {\n        assert(!controlFlowStack.empty());\n        auto currControlFlow = controlFlowStack.back();\n        BinaryLocation delimiterId;\n        if (currControlFlow->is<If>()) {\n          delimiterId = BinaryLocations::Else;\n        } else {\n          // Both Catch and CatchAll can simply append to the list as we go, as\n          // we visit them in the right order in the binary, and like the binary\n          // we store the CatchAll at the end.\n          delimiterId =\n            currFunction->delimiterLocations[currControlFlow].size();\n        }\n        currFunction->delimiterLocations[currControlFlow][delimiterId] =\n          startPos - codeSectionLocation;\n      }\n      break;\n    }\n    case BinaryConsts::Delegate: {\n      curr = nullptr;\n      if (DWARF && currFunction) {\n        assert(!controlFlowStack.empty());\n        controlFlowStack.pop_back();\n      }\n      break;\n    }\n    case BinaryConsts::RefNull:\n      visitRefNull((curr = allocator.alloc<RefNull>())->cast<RefNull>());\n      break;\n    case BinaryConsts::RefIsNull:\n      visitRefIs((curr = allocator.alloc<RefIs>())->cast<RefIs>(), code);\n      break;\n    case BinaryConsts::RefFunc:\n      visitRefFunc((curr = allocator.alloc<RefFunc>())->cast<RefFunc>());\n      break;\n    case BinaryConsts::RefEq:\n      visitRefEq((curr = allocator.alloc<RefEq>())->cast<RefEq>());\n      break;\n    case BinaryConsts::RefAsNonNull:\n      visitRefAs((curr = allocator.alloc<RefAs>())->cast<RefAs>(), code);\n      break;\n    case BinaryConsts::BrOnNull:\n      maybeVisitBrOn(curr, code);\n      break;\n    case BinaryConsts::BrOnNonNull:\n      maybeVisitBrOn(curr, code);\n      break;\n    case BinaryConsts::TableGet:\n      visitTableGet((curr = allocator.alloc<TableGet>())->cast<TableGet>());\n      break;\n    case BinaryConsts::TableSet:\n      visitTableSet((curr = allocator.alloc<TableSet>())->cast<TableSet>());\n      break;\n    case BinaryConsts::Try:\n      visitTryOrTryInBlock(curr);\n      break;\n    case BinaryConsts::Throw:\n      visitThrow((curr = allocator.alloc<Throw>())->cast<Throw>());\n      break;\n    case BinaryConsts::Rethrow:\n      visitRethrow((curr = allocator.alloc<Rethrow>())->cast<Rethrow>());\n      break;\n    case BinaryConsts::MemorySize: {\n      auto size = allocator.alloc<MemorySize>();\n      if (wasm.memory.is64()) {\n        size->make64();\n      }\n      curr = size;\n      visitMemorySize(size);\n      break;\n    }\n    case BinaryConsts::MemoryGrow: {\n      auto grow = allocator.alloc<MemoryGrow>();\n      if (wasm.memory.is64()) {\n        grow->make64();\n      }\n      curr = grow;\n      visitMemoryGrow(grow);\n      break;\n    }\n    case BinaryConsts::CallRef:\n      visitCallRef((curr = allocator.alloc<CallRef>())->cast<CallRef>());\n      break;\n    case BinaryConsts::RetCallRef: {\n      auto call = allocator.alloc<CallRef>();\n      call->isReturn = true;\n      curr = call;\n      visitCallRef(call);\n      break;\n    }\n    case BinaryConsts::Let: {\n      visitLet((curr = allocator.alloc<Block>())->cast<Block>());\n      break;\n    }\n    case BinaryConsts::AtomicPrefix: {\n      code = static_cast<uint8_t>(getU32LEB());\n      if (maybeVisitLoad(curr, code, /*isAtomic=*/true)) {\n        break;\n      }\n      if (maybeVisitStore(curr, code, /*isAtomic=*/true)) {\n        break;\n      }\n      if (maybeVisitAtomicRMW(curr, code)) {\n        break;\n      }\n      if (maybeVisitAtomicCmpxchg(curr, code)) {\n        break;\n      }\n      if (maybeVisitAtomicWait(curr, code)) {\n        break;\n      }\n      if (maybeVisitAtomicNotify(curr, code)) {\n        break;\n      }\n      if (maybeVisitAtomicFence(curr, code)) {\n        break;\n      }\n      throwError(\""invalid code after atomic prefix: \"" + std::to_string(code));\n      break;\n    }\n    case BinaryConsts::MiscPrefix: {\n      auto opcode = getU32LEB();\n      if (maybeVisitTruncSat(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitMemoryInit(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitDataDrop(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitMemoryCopy(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitMemoryFill(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitTableSize(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitTableGrow(curr, opcode)) {\n        break;\n      }\n      throwError(\""invalid code after misc prefix: \"" + std::to_string(opcode));\n      break;\n    }\n    case BinaryConsts::SIMDPrefix: {\n      auto opcode = getU32LEB();\n      if (maybeVisitSIMDBinary(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDUnary(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDConst(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDStore(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDExtract(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDReplace(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDShuffle(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDTernary(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDShift(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDLoad(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitSIMDLoadStoreLane(curr, opcode)) {\n        break;\n      }\n      throwError(\""invalid code after SIMD prefix: \"" + std::to_string(opcode));\n      break;\n    }\n    case BinaryConsts::GCPrefix: {\n      auto opcode = getU32LEB();\n      if (maybeVisitI31New(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitI31Get(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitRefTest(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitRefCast(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitBrOn(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitRttCanon(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitRttSub(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitStructNew(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitStructGet(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitStructSet(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArrayNew(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArrayInit(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArrayGet(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArraySet(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArrayLen(curr, opcode)) {\n        break;\n      }\n      if (maybeVisitArrayCopy(curr, opcode)) {\n        break;\n      }\n      if (opcode == BinaryConsts::RefIsFunc ||\n          opcode == BinaryConsts::RefIsData ||\n          opcode == BinaryConsts::RefIsI31) {\n        visitRefIs((curr = allocator.alloc<RefIs>())->cast<RefIs>(), opcode);\n        break;\n      }\n      if (opcode == BinaryConsts::RefAsFunc ||\n          opcode == BinaryConsts::RefAsData ||\n          opcode == BinaryConsts::RefAsI31) {\n        visitRefAs((curr = allocator.alloc<RefAs>())->cast<RefAs>(), opcode);\n        break;\n      }\n      throwError(\""invalid code after GC prefix: \"" + std::to_string(opcode));\n      break;\n    }\n    default: {\n      // otherwise, the code is a subcode TODO: optimize\n      if (maybeVisitBinary(curr, code)) {\n        break;\n      }\n      if (maybeVisitUnary(curr, code)) {\n        break;\n      }\n      if (maybeVisitConst(curr, code)) {\n        break;\n      }\n      if (maybeVisitLoad(curr, code, /*isAtomic=*/false)) {\n        break;\n      }\n      if (maybeVisitStore(curr, code, /*isAtomic=*/false)) {\n        break;\n      }\n      throwError(\""bad node code \"" + std::to_string(code));\n      break;\n    }\n  }\n  if (curr) {\n    if (currDebugLocation.size()) {\n      currFunction->debugLocations[curr] = *currDebugLocation.begin();\n    }\n    if (DWARF && currFunction) {\n      currFunction->expressionLocations[curr] =\n        BinaryLocations::Span{BinaryLocation(startPos - codeSectionLocation),\n                              BinaryLocation(pos - codeSectionLocation)};\n    }\n  }\n  BYN_TRACE(\""zz recurse from \"" << depth-- << \"" at \"" << pos << std::endl);\n  return BinaryConsts::ASTNodes(code);\n}\n"", ""caller_start"": 3376, ""file_path"": ""src/wasm/wasm-binary.cpp""}, {""call_line"": 87, ""call_code"": ""self->visitRefAs((*currp)->cast<RefAs>())"", ""caller_code"": ""DELEGATE(RefAs);\n"", ""caller_start"": 87, ""file_path"": ""src/wasm-delegations.def""}]}, {""source"": ""value_info(file:wasm-binary.cpp, value:curr->value)"", ""result"": {""value_trace"": [{""full_code"": ""curr->value"", ""line"": 460, ""func_name"": ""wasm.WasmBinaryWriter.writeExports:void()""}, {""full_code"": ""curr->value"", ""line"": 469, ""func_name"": ""wasm.WasmBinaryWriter.writeExports:void()""}, {""full_code"": ""curr->value"", ""line"": 472, ""func_name"": ""wasm.WasmBinaryWriter.writeExports:void()""}, {""full_code"": ""curr->value"", ""line"": 2745, ""func_name"": ""wasm.WasmBinaryBuilder.processNames:void()""}, {""full_code"": ""curr->value"", ""line"": 2749, ""func_name"": ""wasm.WasmBinaryBuilder.processNames:void()""}], ""struct_var"": ""curr"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:wasm-binary.cpp, func:popNonVoidExpression)"", ""result"": [{""code"": ""Expression* WasmBinaryBuilder::popNonVoidExpression() {\n  auto* ret = popExpression();\n  if (ret->type != Type::none) {\n    return ret;\n  }\n  // we found a void, so this is stacky code that we must handle carefully\n  Builder builder(wasm);\n  // add elements until we find a non-void\n  std::vector<Expression*> expressions;\n  expressions.push_back(ret);\n  while (1) {\n    auto* curr = popExpression();\n    expressions.push_back(curr);\n    if (curr->type != Type::none) {\n      break;\n    }\n  }\n  auto* block = builder.makeBlock();\n  while (!expressions.empty()) {\n    block->list.push_back(expressions.back());\n    expressions.pop_back();\n  }\n  requireFunctionContext(\""popping void where we need a new local\"");\n  auto type = block->list[0]->type;\n  if (type.isConcrete()) {\n    auto local = builder.addVar(currFunction, type);\n    block->list[0] = builder.makeLocalSet(local, block->list[0]);\n    block->list.push_back(builder.makeLocalGet(local, type));\n  } else {\n    assert(type == Type::unreachable);\n    // nothing to do here - unreachable anyhow\n  }\n  block->finalize();\n  return block;\n}\n"", ""start_line"": 2650, ""end_line"": 2684, ""full_name"": ""wasm.WasmBinaryBuilder.popNonVoidExpression:wasm.Expression*()"", ""file_path"": ""src/wasm/wasm-binary.cpp""}]}, {""source"": ""caller_info(file:wasm-binary.cpp, func:popNonVoidExpression)"", ""result"": [{""call_line"": 2691, ""call_code"": ""popNonVoidExpression()"", ""caller_code"": ""Expression* WasmBinaryBuilder::popTuple(size_t numElems) {\n  Builder builder(wasm);\n  std::vector<Expression*> elements;\n  elements.resize(numElems);\n  for (size_t i = 0; i < numElems; i++) {\n    auto* elem = popNonVoidExpression();\n    if (elem->type == Type::unreachable) {\n      // All the previously-popped items cannot be reached, so ignore them. We\n      // cannot continue popping because there might not be enough items on the\n      // expression stack after an unreachable expression. Any remaining\n      // elements can stay unperturbed on the stack and will be explicitly\n      // dropped by some parent call to pushBlockElements.\n      return elem;\n    }\n    elements[numElems - i - 1] = elem;\n  }\n  return Builder(wasm).makeTupleMake(std::move(elements));\n}"", ""caller_start"": 2686, ""file_path"": ""src/wasm/wasm-binary.cpp""}, {""call_line"": 2707, ""call_code"": ""popNonVoidExpression()"", ""caller_code"": ""Expression* WasmBinaryBuilder::popTypedExpression(Type type) {\n  if (type.isSingle()) {\n    return popNonVoidExpression();\n  } else if (type.isTuple()) {\n    return popTuple(type.size());\n  } else {\n    WASM_UNREACHABLE(\""Invalid popped type\"");\n  }\n}"", ""caller_start"": 2705, ""file_path"": ""src/wasm/wasm-binary.cpp""}, {""call_line"": 3915, ""call_code"": ""popNonVoidExpression()"", ""caller_code"": ""void WasmBinaryBuilder::visitIf(If* curr) {\n  BYN_TRACE(\""zz node: If\\n\"");\n  startControlFlow(curr);\n  curr->type = getType();\n  curr->condition = popNonVoidExpression();\n  curr->ifTrue = getBlockOrSingleton(curr->type);\n  if (lastSeparator == BinaryConsts::Else) {\n    curr->ifFalse = getBlockOrSingleton(curr->type);\n  }\n  curr->finalize(curr->type);\n  if (lastSeparator != BinaryConsts::End) {\n    throwError(\""if should end with End\"");\n  }\n}"", ""caller_start"": 3911, ""file_path"": ""src/wasm/wasm-binary.cpp""}, {""call_line"": 4004, ""call_code"": ""popNonVoidExpression()"", ""caller_code"": ""void WasmBinaryBuilder::visitBreak(Break* curr, uint8_t code) {\n  BYN_TRACE(\""zz node: Break, code \"" << int32_t(code) << std::endl);\n  BreakTarget target = getBreakTarget(getU32LEB());\n  curr->name = target.name;\n  if (code == BinaryConsts::BrIf) {\n    curr->condition = popNonVoidExpression();\n  }\n  if (target.type.isConcrete()) {\n    curr->value = popTypedExpression(target.type);\n  }\n  curr->finalize();\n}"", ""caller_start"": 3999, ""file_path"": ""src/wasm/wasm-binary.cpp""}]}]","src/wasm/wasm-binary.cpp:191-194: The original assertion in visitRefAs() was triggered by invalid input types for 'ref.as' operations. The invalid type originates from popNonVoidExpression() (src/wasm/wasm-binary.cpp:2650-2684), which does not validate that the popped expression is a reference type. When processing WebAssembly opcodes (e.g., in readExpression() lines 3510 and 3714), visitRefAs() receives curr->value via popNonVoidExpression(), which may have an invalid type. The patch introduces a type check to prevent the assertion abort.",0.95,./github/other_context/CVE-2021-45290
25,CVE-2022-25313,CWE-674,c_cpp,"In Expat (aka libexpat) before 2.4.5, an attacker can trigger stack exhaustion in build_model via a large nesting depth in the DTD element.",https://github.com/libexpat/libexpat/commit/9b4ce651b26557f16103c3a366c91934ecd439ab,"Prevent stack exhaustion in build_model\n\nIt is possible to trigger stack exhaustion in build_model function if\ndepth of nested children in DTD element is large enough. This happens\nbecause build_node is a recursively called function within build_model.\n\nThe code has been adjusted to run iteratively. It uses the already\nallocated heap space as temporary stack (growing from top to bottom).\n\nOutput is identical to recursive version. No new fields in data\nstructures were added, i.e. it keeps full API and ABI compatibility.\nInstead the numchildren variable is used to temporarily keep the\nindex of items (uint vs int).\n\nDocumentation and readability improvements kindly added by Sebastian.\n\nProof of Concept:\n\n1. Compile poc binary which parses XML file line by line\n\n```\ncat > poc.c << EOF\n #include <err.h>\n #include <expat.h>\n #include <stdio.h>\n\n XML_Parser parser;\n\n static void XMLCALL\n dummy_element_decl_handler(void *userData, const XML_Char *name,\n                            XML_Content *model) {\n   XML_FreeContentModel(parser, model);\n }\n\n int main(int argc, char *argv[]) {\n   FILE *fp;\n   char *p = NULL;\n   size_t s = 0;\n   ssize_t l;\n   if (argc != 2)\n     errx(1, ""usage: poc poc.xml"");\n   if ((parser = XML_ParserCreate(NULL)) == NULL)\n     errx(1, ""XML_ParserCreate"");\n   XML_SetElementDeclHandler(parser, dummy_element_decl_handler);\n   if ((fp = fopen(argv[1], ""r"")) == NULL)\n     err(1, ""fopen"");\n   while ((l = getline(&p, &s, fp)) > 0)\n     if (XML_Parse(parser, p, (int)l, XML_FALSE) != XML_STATUS_OK)\n       errx(1, ""XML_Parse"");\n   XML_ParserFree(parser);\n   free(p);\n   fclose(fp);\n   return 0;\n }\nEOF\ncc -std=c11 -D_POSIX_C_SOURCE=200809L -lexpat -o poc poc.c\n```\n\n2. Create XML file with a lot of nested groups in DTD element\n\n```\ncat > poc.xml.zst.b64 << EOF\nKLUv/aQkACAAPAEA+DwhRE9DVFlQRSB1d3UgWwo8IUVMRU1FTlQgdXd1CigBAHv/58AJAgAQKAIA\nECgCABAoAgAQKAIAECgCABAoAgAQKHwAAChvd28KKQIA2/8gV24XBAIAECkCABApAgAQKQIAECkC\nABApAgAQKQIAEClVAAAgPl0+CgEA4A4I2VwwnQ==\nEOF\nbase64 -d poc.xml.zst.b64 | zstd -d > poc.xml\n```\n\n3. Run Proof of Concept\n\n```\n./poc poc.xml\n```\n\nCo-authored-by: Sebastian Pipping <sebastian@pipping.org>",1,"[{""func_name"": ""build_model"", ""file_path"": ""expat/lib/xmlparse.c"", ""func_code"": ""static XML_Content *\nbuild_model(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  XML_Content *ret;\n  XML_Content *cpos;\n  XML_Char *str;\n\n  /* Detect and prevent integer overflow.\n   * The preprocessor guard addresses the \""always false\"" warning\n   * from -Wtype-limits on platforms where\n   * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n\n  str = (XML_Char *)(&ret[dtd->scaffCount]);\n  cpos = &ret[1];\n\n  build_node(parser, 0, ret, &cpos, &str);\n  return ret;\n}"", ""target"": 0}]","[{""func_name"": ""build_model"", ""file_path"": ""expat/lib/xmlparse.c"", ""func_code"": ""static XML_Content *\nbuild_model(XML_Parser parser) {\n  /* Function build_model transforms the existing parser->m_dtd->scaffold\n   * array of CONTENT_SCAFFOLD tree nodes into a new array of\n   * XML_Content tree nodes followed by a gapless list of zero-terminated\n   * strings. */\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  XML_Content *ret;\n  XML_Char *str; /* the current string writing location */\n\n  /* Detect and prevent integer overflow.\n   * The preprocessor guard addresses the \""always false\"" warning\n   * from -Wtype-limits on platforms where\n   * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n\n  /* What follows is an iterative implementation (of what was previously done\n   * recursively in a dedicated function called \""build_node\"".  The old recursive\n   * build_node could be forced into stack exhaustion from input as small as a\n   * few megabyte, and so that was a security issue.  Hence, a function call\n   * stack is avoided now by resolving recursion.)\n   *\n   * The iterative approach works as follows:\n   *\n   * - We use space in the target array for building a temporary stack structure\n   *   while that space is still unused.\n   *   The stack grows from the array's end downwards and the \""actual data\""\n   *   grows from the start upwards, sequentially.\n   *   (Because stack grows downwards, pushing onto the stack is a decrement\n   *   while popping off the stack is an increment.)\n   *\n   * - A stack element appears as a regular XML_Content node on the outside,\n   *   but only uses a single field -- numchildren -- to store the source\n   *   tree node array index.  These are the breadcrumbs leading the way back\n   *   during pre-order (node first) depth-first traversal.\n   *\n   * - The reason we know the stack will never grow into (or overlap with)\n   *   the area with data of value at the start of the array is because\n   *   the overall number of elements to process matches the size of the array,\n   *   and the sum of fully processed nodes and yet-to-be processed nodes\n   *   on the stack, cannot be more than the total number of nodes.\n   *   It is possible for the top of the stack and the about-to-write node\n   *   to meet, but that is safe because we get the source index out\n   *   before doing any writes on that node.\n   */\n  XML_Content *dest = ret; /* tree node writing location, moves upwards */\n  XML_Content *const destLimit = &ret[dtd->scaffCount];\n  XML_Content *const stackBottom = &ret[dtd->scaffCount];\n  XML_Content *stackTop = stackBottom; /* i.e. stack is initially empty */\n  str = (XML_Char *)&ret[dtd->scaffCount];\n\n  /* Push source tree root node index onto the stack */\n  (--stackTop)->numchildren = 0;\n\n  for (; dest < destLimit; dest++) {\n    /* Pop source tree node index off the stack */\n    const int src_node = (int)(stackTop++)->numchildren;\n\n    /* Convert item */\n    dest->type = dtd->scaffold[src_node].type;\n    dest->quant = dtd->scaffold[src_node].quant;\n    if (dest->type == XML_CTYPE_NAME) {\n      const XML_Char *src;\n      dest->name = str;\n      src = dtd->scaffold[src_node].name;\n      for (;;) {\n        *str++ = *src;\n        if (! *src)\n          break;\n        src++;\n      }\n      dest->numchildren = 0;\n      dest->children = NULL;\n    } else {\n      unsigned int i;\n      int cn;\n      dest->name = NULL;\n      dest->numchildren = dtd->scaffold[src_node].childcnt;\n      dest->children = &dest[1];\n\n      /* Push children to the stack\n       * in a way where the first child ends up at the top of the\n       * (downwards growing) stack, in order to be processed first. */\n      stackTop -= dest->numchildren;\n      for (i = 0, cn = dtd->scaffold[src_node].firstchild;\n           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {\n        (stackTop + i)->numchildren = (unsigned int)cn;\n      }\n    }\n  }\n\n  return ret;\n}""}]","{""function"": 1, ""query"": 1}","[{""source"": ""func_info(file:xmlparse.c, func:build_node)"", ""result"": [{""code"": ""static void\nbuild_node(XML_Parser parser, int src_node, XML_Content *dest,\n           XML_Content **contpos, XML_Char **strpos) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  dest->type = dtd->scaffold[src_node].type;\n  dest->quant = dtd->scaffold[src_node].quant;\n  if (dest->type == XML_CTYPE_NAME) {\n    const XML_Char *src;\n    dest->name = *strpos;\n    src = dtd->scaffold[src_node].name;\n    for (;;) {\n      *(*strpos)++ = *src;\n      if (! *src)\n        break;\n      src++;\n    }\n    dest->numchildren = 0;\n    dest->children = NULL;\n  } else {\n    unsigned int i;\n    int cn;\n    dest->numchildren = dtd->scaffold[src_node].childcnt;\n    dest->children = *contpos;\n    *contpos += dest->numchildren;\n    for (i = 0, cn = dtd->scaffold[src_node].firstchild; i < dest->numchildren;\n         i++, cn = dtd->scaffold[cn].nextsib) {\n      build_node(parser, cn, &(dest->children[i]), contpos, strpos);\n    }\n    dest->name = NULL;\n  }\n}"", ""start_line"": 7320, ""end_line"": 7350, ""full_name"": ""build_node"", ""file_path"": ""expat/lib/xmlparse.c""}]}, {""source"": ""query_info(query:cpg.typeDecl.name(\""DTD\"").member.name(\""scaffold\"").l)"", ""result"": [{""name"": ""scaffold"", ""code"": ""*scaffold"", ""typeFullName"": ""CONTENT_SCAFFOLD*"", ""lineNumber"": 385, ""columnNumber"": 20}]}]","expat/lib/xmlparse.c:7350 (recursive `build_node` call)  expat/lib/xmlparse.c:7320-7350 (original `build_node` function)  expat/lib/xmlparse.c:385 (definition of `DTD->scaffold` array). The recursion in `build_node` processes deeply nested DTD elements, leading to stack exhaustion when nesting depth exceeds stack limits.",1.0,./github/other_context/CVE-2022-25313
26,CVE-2022-26356,CWE-667,c_cpp,"Racy interactions between dirty vram tracking and paging log dirty hypercalls Activation of log dirty mode done by XEN_DMOP_track_dirty_vram (was named HVMOP_track_dirty_vram before Xen 4.9) is racy with ongoing log dirty hypercalls. A suitably timed call to XEN_DMOP_track_dirty_vram can enable log dirty while another CPU is still in the process of tearing down the structures related to a previously enabled log dirty mode (XEN_DOMCTL_SHADOW_OP_OFF). This is due to lack of mutually exclusive locking between both operations and can lead to entries being added in already freed slots, resulting in a memory leak.",https://github.com/xen-project/xen/commit/4f4db53784d912c4f409a451c36ebfd4754e0a42,"x86/hap: do not switch on log dirty for VRAM tracking\n\nXEN_DMOP_track_dirty_vram possibly calls into paging_log_dirty_enable\nwhen using HAP mode, and it can interact badly with other ongoing\npaging domctls, as XEN_DMOP_track_dirty_vram is not holding the domctl\nlock.\n\nThis was detected as a result of the following assert triggering when\ndoing repeated migrations of a HAP HVM domain with a stubdom:\n\nAssertion 'd->arch.paging.log_dirty.allocs == 0' failed at paging.c:198\n----[ Xen-4.17-unstable  x86_64  debug=y  Not tainted ]----\nCPU:    34\nRIP:    e008:[<ffff82d040314b3b>] arch/x86/mm/paging.c#paging_free_log_dirty_bitmap+0x606/0x6\nRFLAGS: 0000000000010206   CONTEXT: hypervisor (d0v23)\n[...]\nXen call trace:\n   [<ffff82d040314b3b>] R arch/x86/mm/paging.c#paging_free_log_dirty_bitmap+0x606/0x63a\n   [<ffff82d040279f96>] S xsm/flask/hooks.c#domain_has_perm+0x5a/0x67\n   [<ffff82d04031577f>] F paging_domctl+0x251/0xd41\n   [<ffff82d04031640c>] F paging_domctl_continuation+0x19d/0x202\n   [<ffff82d0403202fa>] F pv_hypercall+0x150/0x2a7\n   [<ffff82d0403a729d>] F lstar_enter+0x12d/0x140\n\nSuch assert triggered because the stubdom used\nXEN_DMOP_track_dirty_vram while dom0 was in the middle of executing\nXEN_DOMCTL_SHADOW_OP_OFF, and so log dirty become enabled while\nretiring the old structures, thus leading to new entries being\npopulated in already clear slots.\n\nFix this by not enabling log dirty for VRAM tracking, similar to what\nis done when using shadow instead of HAP. Call\np2m_enable_hardware_log_dirty when enabling VRAM tracking in order to\nget some hardware assistance if available. As a side effect the memory\npressure on the p2m pool should go down if only VRAM tracking is\nenabled, as the dirty bitmap is no longer allocated.\n\nNote that paging_log_dirty_range (used to get the dirty bitmap for\nVRAM tracking) doesn't use the log dirty bitmap, and instead relies on\nchecking whether each gfn on the range has been switched from\np2m_ram_logdirty to p2m_ram_rw in order to account for dirty pages.\n\nThis is CVE-2022-26356 / XSA-397.\n\nSigned-off-by: Roger Pau Monn <roger.pau@citrix.com>\nReviewed-by: Jan Beulich <jbeulich@suse.com>",2,"[{""func_name"": ""paging_log_dirty_enable"", ""file_path"": ""xen/arch/x86/mm/paging.c"", ""func_code"": ""int paging_log_dirty_enable(struct domain *d, bool log_global)\n{\n    int ret;\n\n    if ( has_arch_pdevs(d) && log_global )\n    {\n        /*\n         * Refuse to turn on global log-dirty mode\n         * if the domain is sharing the P2M with the IOMMU.\n         */\n        return -EINVAL;\n    }\n\n    if ( paging_mode_log_dirty(d) )\n        return -EINVAL;\n\n    domain_pause(d);\n    ret = d->arch.paging.log_dirty.ops->enable(d, log_global);\n    domain_unpause(d);\n\n    return ret;\n}"", ""target"": 0}, {""func_name"": ""hap_track_dirty_vram"", ""file_path"": ""xen/arch/x86/mm/hap/hap.c"", ""func_code"": ""int hap_track_dirty_vram(struct domain *d,\n                         unsigned long begin_pfn,\n                         unsigned int nr_frames,\n                         XEN_GUEST_HANDLE(void) guest_dirty_bitmap)\n{\n    long rc = 0;\n    struct sh_dirty_vram *dirty_vram;\n    uint8_t *dirty_bitmap = NULL;\n\n    if ( nr_frames )\n    {\n        unsigned int size = DIV_ROUND_UP(nr_frames, BITS_PER_BYTE);\n\n        if ( !paging_mode_log_dirty(d) )\n        {\n            rc = paging_log_dirty_enable(d, false);\n            if ( rc )\n                goto out;\n        }\n\n        rc = -ENOMEM;\n        dirty_bitmap = vzalloc(size);\n        if ( !dirty_bitmap )\n            goto out;\n\n        paging_lock(d);\n\n        dirty_vram = d->arch.hvm.dirty_vram;\n        if ( !dirty_vram )\n        {\n            rc = -ENOMEM;\n            if ( (dirty_vram = xzalloc(struct sh_dirty_vram)) == NULL )\n            {\n                paging_unlock(d);\n                goto out;\n            }\n\n            d->arch.hvm.dirty_vram = dirty_vram;\n        }\n\n        if ( begin_pfn != dirty_vram->begin_pfn ||\n             begin_pfn + nr_frames != dirty_vram->end_pfn )\n        {\n            unsigned long ostart = dirty_vram->begin_pfn;\n            unsigned long oend = dirty_vram->end_pfn;\n\n            dirty_vram->begin_pfn = begin_pfn;\n            dirty_vram->end_pfn = begin_pfn + nr_frames;\n\n            paging_unlock(d);\n\n            if ( oend > ostart )\n                p2m_change_type_range(d, ostart, oend,\n                                      p2m_ram_logdirty, p2m_ram_rw);\n\n            /*\n             * Switch vram to log dirty mode, either by setting l1e entries of\n             * P2M table to be read-only, or via hardware-assisted log-dirty.\n             */\n            p2m_change_type_range(d, begin_pfn, begin_pfn + nr_frames,\n                                  p2m_ram_rw, p2m_ram_logdirty);\n\n            guest_flush_tlb_mask(d, d->dirty_cpumask);\n\n            memset(dirty_bitmap, 0xff, size); /* consider all pages dirty */\n        }\n        else\n        {\n            paging_unlock(d);\n\n            domain_pause(d);\n\n            /* Flush dirty GFNs potentially cached by hardware. */\n            p2m_flush_hardware_cached_dirty(d);\n\n            /* get the bitmap */\n            paging_log_dirty_range(d, begin_pfn, nr_frames, dirty_bitmap);\n\n            domain_unpause(d);\n        }\n\n        rc = -EFAULT;\n        if ( copy_to_guest(guest_dirty_bitmap, dirty_bitmap, size) == 0 )\n            rc = 0;\n    }\n    else\n    {\n        paging_lock(d);\n\n        dirty_vram = d->arch.hvm.dirty_vram;\n        if ( dirty_vram )\n        {\n            /*\n             * If zero pages specified while tracking dirty vram\n             * then stop tracking\n             */\n            begin_pfn = dirty_vram->begin_pfn;\n            nr_frames = dirty_vram->end_pfn - dirty_vram->begin_pfn;\n            xfree(dirty_vram);\n            d->arch.hvm.dirty_vram = NULL;\n        }\n\n        paging_unlock(d);\n\n        if ( nr_frames )\n            p2m_change_type_range(d, begin_pfn, begin_pfn + nr_frames,\n                                  p2m_ram_logdirty, p2m_ram_rw);\n    }\nout:\n    vfree(dirty_bitmap);\n\n    return rc;\n}"", ""target"": 0}]","[{""func_name"": ""paging_log_dirty_enable"", ""file_path"": ""xen/arch/x86/mm/paging.c"", ""func_code"": ""static int paging_log_dirty_enable(struct domain *d, bool log_global)\n{\n    int ret;\n\n    if ( has_arch_pdevs(d) && log_global )\n    {\n        /*\n         * Refuse to turn on global log-dirty mode\n         * if the domain is sharing the P2M with the IOMMU.\n         */\n        return -EINVAL;\n    }\n\n    if ( paging_mode_log_dirty(d) )\n        return -EINVAL;\n\n    domain_pause(d);\n    ret = d->arch.paging.log_dirty.ops->enable(d, log_global);\n    domain_unpause(d);\n\n    return ret;\n}""}, {""func_name"": ""hap_track_dirty_vram"", ""file_path"": ""xen/arch/x86/mm/hap/hap.c"", ""func_code"": ""int hap_track_dirty_vram(struct domain *d,\n                         unsigned long begin_pfn,\n                         unsigned int nr_frames,\n                         XEN_GUEST_HANDLE(void) guest_dirty_bitmap)\n{\n    long rc = 0;\n    struct sh_dirty_vram *dirty_vram;\n    uint8_t *dirty_bitmap = NULL;\n\n    if ( nr_frames )\n    {\n        unsigned int size = DIV_ROUND_UP(nr_frames, BITS_PER_BYTE);\n\n        rc = -ENOMEM;\n        dirty_bitmap = vzalloc(size);\n        if ( !dirty_bitmap )\n            goto out;\n\n        paging_lock(d);\n\n        dirty_vram = d->arch.hvm.dirty_vram;\n        if ( !dirty_vram )\n        {\n            rc = -ENOMEM;\n            if ( (dirty_vram = xzalloc(struct sh_dirty_vram)) == NULL )\n            {\n                paging_unlock(d);\n                goto out;\n            }\n\n            d->arch.hvm.dirty_vram = dirty_vram;\n        }\n\n        if ( begin_pfn != dirty_vram->begin_pfn ||\n             begin_pfn + nr_frames != dirty_vram->end_pfn )\n        {\n            unsigned long ostart = dirty_vram->begin_pfn;\n            unsigned long oend = dirty_vram->end_pfn;\n\n            dirty_vram->begin_pfn = begin_pfn;\n            dirty_vram->end_pfn = begin_pfn + nr_frames;\n\n            paging_unlock(d);\n\n            domain_pause(d);\n            p2m_enable_hardware_log_dirty(d);\n            domain_unpause(d);\n\n            if ( oend > ostart )\n                p2m_change_type_range(d, ostart, oend,\n                                      p2m_ram_logdirty, p2m_ram_rw);\n\n            /*\n             * Switch vram to log dirty mode, either by setting l1e entries of\n             * P2M table to be read-only, or via hardware-assisted log-dirty.\n             */\n            p2m_change_type_range(d, begin_pfn, begin_pfn + nr_frames,\n                                  p2m_ram_rw, p2m_ram_logdirty);\n\n            guest_flush_tlb_mask(d, d->dirty_cpumask);\n\n            memset(dirty_bitmap, 0xff, size); /* consider all pages dirty */\n        }\n        else\n        {\n            paging_unlock(d);\n\n            domain_pause(d);\n\n            /* Flush dirty GFNs potentially cached by hardware. */\n            p2m_flush_hardware_cached_dirty(d);\n\n            /* get the bitmap */\n            paging_log_dirty_range(d, begin_pfn, nr_frames, dirty_bitmap);\n\n            domain_unpause(d);\n        }\n\n        rc = -EFAULT;\n        if ( copy_to_guest(guest_dirty_bitmap, dirty_bitmap, size) == 0 )\n            rc = 0;\n    }\n    else\n    {\n        paging_lock(d);\n\n        dirty_vram = d->arch.hvm.dirty_vram;\n        if ( dirty_vram )\n        {\n            /*\n             * If zero pages specified while tracking dirty vram\n             * then stop tracking\n             */\n            begin_pfn = dirty_vram->begin_pfn;\n            nr_frames = dirty_vram->end_pfn - dirty_vram->begin_pfn;\n            xfree(dirty_vram);\n            d->arch.hvm.dirty_vram = NULL;\n        }\n\n        paging_unlock(d);\n\n        if ( nr_frames )\n            p2m_change_type_range(d, begin_pfn, begin_pfn + nr_frames,\n                                  p2m_ram_logdirty, p2m_ram_rw);\n    }\nout:\n    vfree(dirty_bitmap);\n\n    return rc;\n}""}]",{},[],"xen/arch/x86/mm/hap/hap.c:60-91: `hap_track_dirty_vram` calls `paging_log_dirty_enable` (xen/arch/x86/mm/paging.c) without holding the domctl lock. This enables log dirty mode during VRAM tracking while another CPU may be executing XEN_DOMCTL_SHADOW_OP_OFF (which tears down log dirty structures). The race results in `d->arch.paging.log_dirty.allocs` being non-zero when it should be zero, triggering the assert in xen/arch/x86/mm/paging.c:198.",0.95,./github/other_context/CVE-2022-26356
27,CVE-2014-9748,CWE-362,c_cpp,"The uv_rwlock_t fallback implementation for Windows XP and Server 2003 in libuv before 1.7.4 does not properly prevent threads from releasing the locks of other threads, which allows attackers to cause a denial of service (deadlock) or possibly have unspecified other impact by leveraging a race condition.",https://github.com/libuv/libuv/commit/d4ff8fd5c175bc825258da3ffb01bd21bd5a6202,"win: fix unsavory rwlock fallback implementation\n\nBefore this patch an uv_mutex_t (backed by a critical section) could be\nreleased by a tread different from the thread that acquired it, which is\nnot allowed. This is fixed by using a semaphore instead.\n\nNote that the affected code paths were used on Windows XP and Windows\nServer 2003 only.\n\nThis is a back-port of commits 3eb6764, 1ad6ad7, 9a4fd26, 9823922\n85adf43 and bd1777f from the v1.x branch.\n\nFixes: https://github.com/libuv/libuv/issues/515\nRefs: https://github.com/libuv/libuv/pull/525\nPR-URL: https://github.com/libuv/libuv/pull/903\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Bert Belder <bertbelder@gmail.com>",17,"[{""func_name"": ""uv_mutex_trylock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""int uv_mutex_trylock(uv_mutex_t* mutex) {\n  int r;\n\n  r = pthread_mutex_trylock(mutex);\n\n  if (r && r != EBUSY && r != EAGAIN)\n    abort();\n\n  if (r)\n    return -1;\n  else\n    return 0;\n}"", ""target"": 1}, {""func_name"": ""uv_rwlock_tryrdlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock) {\n  int r;\n\n  r = pthread_rwlock_tryrdlock(rwlock);\n\n  if (r && r != EBUSY && r != EAGAIN)\n    abort();\n\n  if (r)\n    return -1;\n  else\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""uv_rwlock_trywrlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""int uv_rwlock_trywrlock(uv_rwlock_t* rwlock) {\n  int r;\n\n  r = pthread_rwlock_trywrlock(rwlock);\n\n  if (r && r != EBUSY && r != EAGAIN)\n    abort();\n\n  if (r)\n    return -1;\n  else\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""uv_mutex_trylock"", ""file_path"": ""src/unix/thread.c"", ""func_code"": ""int uv_mutex_trylock(uv_mutex_t* mutex) {\n  int r;\n\n  r = pthread_mutex_trylock(mutex);\n\n  if (r && r != EBUSY && r != EAGAIN)\n    abort();\n\n  if (r)\n    return -1;\n  else\n    return 0;\n}"", ""target"": 1}, {""func_name"": ""uv_rwlock_tryrdlock"", ""file_path"": ""src/unix/thread.c"", ""func_code"": ""int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock) {\n  int r;\n\n  r = pthread_rwlock_tryrdlock(rwlock);\n\n  if (r && r != EBUSY && r != EAGAIN)\n    abort();\n\n  if (r)\n    return -1;\n  else\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""uv_rwlock_trywrlock"", ""file_path"": ""src/unix/thread.c"", ""func_code"": ""int uv_rwlock_trywrlock(uv_rwlock_t* rwlock) {\n  int r;\n\n  r = pthread_rwlock_trywrlock(rwlock);\n\n  if (r && r != EBUSY && r != EAGAIN)\n    abort();\n\n  if (r)\n    return -1;\n  else\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""uv_winapi_init"", ""file_path"": ""src/win/winapi.c"", ""func_code"": ""void uv_winapi_init() {\n  HMODULE ntdll_module;\n  HMODULE kernel32_module;\n\n  ntdll_module = GetModuleHandleA(\""ntdll.dll\"");\n  if (ntdll_module == NULL) {\n    uv_fatal_error(GetLastError(), \""GetModuleHandleA\"");\n  }\n\n  pRtlNtStatusToDosError = (sRtlNtStatusToDosError) GetProcAddress(\n      ntdll_module,\n      \""RtlNtStatusToDosError\"");\n  if (pRtlNtStatusToDosError == NULL) {\n    uv_fatal_error(GetLastError(), \""GetProcAddress\"");\n  }\n\n  pNtQueryInformationFile = (sNtQueryInformationFile) GetProcAddress(\n      ntdll_module,\n      \""NtQueryInformationFile\"");\n  if (pNtQueryInformationFile == NULL) {\n    uv_fatal_error(GetLastError(), \""GetProcAddress\"");\n  }\n\n  pNtDeviceIoControlFile = (sNtDeviceIoControlFile) GetProcAddress(\n      ntdll_module,\n      \""NtDeviceIoControlFile\"");\n  if (pNtDeviceIoControlFile == NULL) {\n    uv_fatal_error(GetLastError(), \""GetProcAddress\"");\n  }\n\n  pNtSetInformationFile = (sNtSetInformationFile) GetProcAddress(\n      ntdll_module,\n      \""NtSetInformationFile\"");\n  if (pNtSetInformationFile == NULL) {\n    uv_fatal_error(GetLastError(), \""GetProcAddress\"");\n  }\n\n  pNtQuerySystemInformation = (sNtQuerySystemInformation) GetProcAddress(\n      ntdll_module,\n      \""NtQuerySystemInformation\"");\n  if (pNtQuerySystemInformation == NULL) {\n    uv_fatal_error(GetLastError(), \""GetProcAddress\"");\n  }\n\n  kernel32_module = GetModuleHandleA(\""kernel32.dll\"");\n  if (kernel32_module == NULL) {\n    uv_fatal_error(GetLastError(), \""GetModuleHandleA\"");\n  }\n\n  pGetQueuedCompletionStatusEx = (sGetQueuedCompletionStatusEx) GetProcAddress(\n      kernel32_module,\n      \""GetQueuedCompletionStatusEx\"");\n\n  pSetFileCompletionNotificationModes = (sSetFileCompletionNotificationModes)\n    GetProcAddress(kernel32_module, \""SetFileCompletionNotificationModes\"");\n\n  pCreateSymbolicLinkW = (sCreateSymbolicLinkW)\n    GetProcAddress(kernel32_module, \""CreateSymbolicLinkW\"");\n\n  pCancelIoEx = (sCancelIoEx)\n    GetProcAddress(kernel32_module, \""CancelIoEx\"");\n\n  pInitializeSRWLock = (sInitializeSRWLock)\n    GetProcAddress(kernel32_module, \""InitializeSRWLock\"");\n\n  pAcquireSRWLockShared = (sAcquireSRWLockShared)\n    GetProcAddress(kernel32_module, \""AcquireSRWLockShared\"");\n\n  pAcquireSRWLockExclusive = (sAcquireSRWLockExclusive)\n    GetProcAddress(kernel32_module, \""AcquireSRWLockExclusive\"");\n\n  pTryAcquireSRWLockShared = (sTryAcquireSRWLockShared)\n    GetProcAddress(kernel32_module, \""TryAcquireSRWLockShared\"");\n\n  pTryAcquireSRWLockExclusive = (sTryAcquireSRWLockExclusive)\n    GetProcAddress(kernel32_module, \""TryAcquireSRWLockExclusive\"");\n\n  pReleaseSRWLockShared = (sReleaseSRWLockShared)\n    GetProcAddress(kernel32_module, \""ReleaseSRWLockShared\"");\n\n  pReleaseSRWLockExclusive = (sReleaseSRWLockExclusive)\n    GetProcAddress(kernel32_module, \""ReleaseSRWLockExclusive\"");\n\n  pInitializeConditionVariable = (sInitializeConditionVariable)\n    GetProcAddress(kernel32_module, \""InitializeConditionVariable\"");\n\n  pSleepConditionVariableCS = (sSleepConditionVariableCS)\n    GetProcAddress(kernel32_module, \""SleepConditionVariableCS\"");\n\n  pSleepConditionVariableSRW = (sSleepConditionVariableSRW)\n    GetProcAddress(kernel32_module, \""SleepConditionVariableSRW\"");\n\n  pWakeAllConditionVariable = (sWakeAllConditionVariable)\n    GetProcAddress(kernel32_module, \""WakeAllConditionVariable\"");\n\n  pWakeConditionVariable = (sWakeConditionVariable)\n    GetProcAddress(kernel32_module, \""WakeConditionVariable\"");\n}"", ""target"": 1}, {""func_name"": ""crypto_lock_init"", ""file_path"": ""src/node_crypto.cc"", ""func_code"": ""static void crypto_lock_init(void) {\n  int i, n;\n\n  n = CRYPTO_num_locks();\n  locks = new uv_rwlock_t[n];\n\n  for (i = 0; i < n; i++)\n    if (uv_rwlock_init(locks + i))\n      abort();\n}"", ""target"": 0}, {""func_name"": ""crypto_lock_cb"", ""file_path"": ""src/node_crypto.cc"", ""func_code"": ""static void crypto_lock_cb(int mode, int n, const char* file, int line) {\n  CHECK((mode & CRYPTO_LOCK) || (mode & CRYPTO_UNLOCK));\n  CHECK((mode & CRYPTO_READ) || (mode & CRYPTO_WRITE));\n\n  if (mode & CRYPTO_LOCK) {\n    if (mode & CRYPTO_READ)\n      uv_rwlock_rdlock(locks + n);\n    else\n      uv_rwlock_wrlock(locks + n);\n  } else {\n    if (mode & CRYPTO_READ)\n      uv_rwlock_rdunlock(locks + n);\n    else\n      uv_rwlock_wrunlock(locks + n);\n  }\n}"", ""target"": 0}, {""func_name"": ""uv__rwlock_fallback_init"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static int uv__rwlock_fallback_init(uv_rwlock_t* rwlock) {\n  int err;\n\n  err = uv_mutex_init(&rwlock->fallback_.read_mutex_);\n  if (err)\n    return err;\n\n  err = uv_mutex_init(&rwlock->fallback_.write_mutex_);\n  if (err) {\n    uv_mutex_destroy(&rwlock->fallback_.read_mutex_);\n    return err;\n  }\n\n  rwlock->fallback_.num_readers_ = 0;\n\n  return 0;\n}"", ""target"": 0}, {""func_name"": ""uv__rwlock_fallback_trywrlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static int uv__rwlock_fallback_trywrlock(uv_rwlock_t* rwlock) {\n  return uv_mutex_trylock(&rwlock->fallback_.write_mutex_);\n}"", ""target"": 1}, {""func_name"": ""uv__rwlock_fallback_wrunlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static void uv__rwlock_fallback_wrunlock(uv_rwlock_t* rwlock) {\n  uv_mutex_unlock(&rwlock->fallback_.write_mutex_);\n}"", ""target"": 0}, {""func_name"": ""uv__rwlock_fallback_tryrdlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static int uv__rwlock_fallback_tryrdlock(uv_rwlock_t* rwlock) {\n  int err;\n\n  err = uv_mutex_trylock(&rwlock->fallback_.read_mutex_);\n  if (err)\n    goto out;\n\n  err = 0;\n  if (rwlock->fallback_.num_readers_ == 0)\n    err = uv_mutex_trylock(&rwlock->fallback_.write_mutex_);\n\n  if (err == 0)\n    rwlock->fallback_.num_readers_++;\n\n  uv_mutex_unlock(&rwlock->fallback_.read_mutex_);\n\nout:\n  return err;\n}"", ""target"": 0}, {""func_name"": ""uv__rwlock_fallback_rdlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static void uv__rwlock_fallback_rdlock(uv_rwlock_t* rwlock) {\n  uv_mutex_lock(&rwlock->fallback_.read_mutex_);\n\n  if (++rwlock->fallback_.num_readers_ == 1)\n    uv_mutex_lock(&rwlock->fallback_.write_mutex_);\n\n  uv_mutex_unlock(&rwlock->fallback_.read_mutex_);\n}"", ""target"": 0}, {""func_name"": ""uv__rwlock_fallback_destroy"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static void uv__rwlock_fallback_destroy(uv_rwlock_t* rwlock) {\n  uv_mutex_destroy(&rwlock->fallback_.read_mutex_);\n  uv_mutex_destroy(&rwlock->fallback_.write_mutex_);\n}"", ""target"": 0}, {""func_name"": ""uv__rwlock_fallback_wrlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static void uv__rwlock_fallback_wrlock(uv_rwlock_t* rwlock) {\n  uv_mutex_lock(&rwlock->fallback_.write_mutex_);\n}"", ""target"": 1}, {""func_name"": ""uv__rwlock_fallback_rdunlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static void uv__rwlock_fallback_rdunlock(uv_rwlock_t* rwlock) {\n  uv_mutex_lock(&rwlock->fallback_.read_mutex_);\n\n  if (--rwlock->fallback_.num_readers_ == 0)\n    uv_mutex_unlock(&rwlock->fallback_.write_mutex_);\n\n  uv_mutex_unlock(&rwlock->fallback_.read_mutex_);\n}"", ""target"": 1}]","[{""func_name"": ""uv_mutex_trylock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""int uv_mutex_trylock(uv_mutex_t* mutex) {\n  int r;\n\n  r = pthread_mutex_trylock(mutex);\n\n  if (r) {\n    if (r != EBUSY && r != EAGAIN)\n      abort();\n    return -1;\n  }\n  return 0;\n}""}, {""func_name"": ""uv_rwlock_tryrdlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock) {\n  int r;\n\n  r = pthread_rwlock_tryrdlock(rwlock);\n\n  if (r) {\n    if (r != EBUSY && r != EAGAIN)\n      abort();\n    return -1;\n  }\n  return 0;\n}""}, {""func_name"": ""uv_rwlock_trywrlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""int uv_rwlock_trywrlock(uv_rwlock_t* rwlock) {\n  int r;\n\n  r = pthread_rwlock_trywrlock(rwlock);\n\n  if (r) {\n    if (r != EBUSY && r != EAGAIN)\n      abort();\n    return -1;\n  }\n  return 0;\n}""}, {""func_name"": ""uv_mutex_trylock"", ""file_path"": ""src/unix/thread.c"", ""func_code"": ""int uv_mutex_trylock(uv_mutex_t* mutex) {\n  int r;\n\n  r = pthread_mutex_trylock(mutex);\n\n  if (r) {\n    if (r != EBUSY && r != EAGAIN)\n      abort();\n    return -1;\n  }\n  return 0;\n}""}, {""func_name"": ""uv_rwlock_tryrdlock"", ""file_path"": ""src/unix/thread.c"", ""func_code"": ""int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock) {\n  int r;\n\n  r = pthread_rwlock_tryrdlock(rwlock);\n\n  if (r) {\n    if (r != EBUSY && r != EAGAIN)\n      abort();\n    return -1;\n  }\n  return 0;\n}""}, {""func_name"": ""uv_rwlock_trywrlock"", ""file_path"": ""src/unix/thread.c"", ""func_code"": ""int uv_rwlock_trywrlock(uv_rwlock_t* rwlock) {\n  int r;\n\n  r = pthread_rwlock_trywrlock(rwlock);\n\n  if (r) {\n    if (r != EBUSY && r != EAGAIN)\n      abort();\n    return -1;\n  }\n  return 0;\n}""}, {""func_name"": ""uv_winapi_init"", ""file_path"": ""src/win/winapi.c"", ""func_code"": ""void uv_winapi_init() {\n  HMODULE ntdll_module;\n  HMODULE kernel32_module;\n\n  ntdll_module = GetModuleHandleA(\""ntdll.dll\"");\n  if (ntdll_module == NULL) {\n    uv_fatal_error(GetLastError(), \""GetModuleHandleA\"");\n  }\n\n  pRtlNtStatusToDosError = (sRtlNtStatusToDosError) GetProcAddress(\n      ntdll_module,\n      \""RtlNtStatusToDosError\"");\n  if (pRtlNtStatusToDosError == NULL) {\n    uv_fatal_error(GetLastError(), \""GetProcAddress\"");\n  }\n\n  pNtQueryInformationFile = (sNtQueryInformationFile) GetProcAddress(\n      ntdll_module,\n      \""NtQueryInformationFile\"");\n  if (pNtQueryInformationFile == NULL) {\n    uv_fatal_error(GetLastError(), \""GetProcAddress\"");\n  }\n\n  pNtDeviceIoControlFile = (sNtDeviceIoControlFile) GetProcAddress(\n      ntdll_module,\n      \""NtDeviceIoControlFile\"");\n  if (pNtDeviceIoControlFile == NULL) {\n    uv_fatal_error(GetLastError(), \""GetProcAddress\"");\n  }\n\n  pNtSetInformationFile = (sNtSetInformationFile) GetProcAddress(\n      ntdll_module,\n      \""NtSetInformationFile\"");\n  if (pNtSetInformationFile == NULL) {\n    uv_fatal_error(GetLastError(), \""GetProcAddress\"");\n  }\n\n  pNtQuerySystemInformation = (sNtQuerySystemInformation) GetProcAddress(\n      ntdll_module,\n      \""NtQuerySystemInformation\"");\n  if (pNtQuerySystemInformation == NULL) {\n    uv_fatal_error(GetLastError(), \""GetProcAddress\"");\n  }\n\n  kernel32_module = GetModuleHandleA(\""kernel32.dll\"");\n  if (kernel32_module == NULL) {\n    uv_fatal_error(GetLastError(), \""GetModuleHandleA\"");\n  }\n\n  pGetQueuedCompletionStatusEx = (sGetQueuedCompletionStatusEx) GetProcAddress(\n      kernel32_module,\n      \""GetQueuedCompletionStatusEx\"");\n\n  pSetFileCompletionNotificationModes = (sSetFileCompletionNotificationModes)\n    GetProcAddress(kernel32_module, \""SetFileCompletionNotificationModes\"");\n\n  pCreateSymbolicLinkW = (sCreateSymbolicLinkW)\n    GetProcAddress(kernel32_module, \""CreateSymbolicLinkW\"");\n\n  pCancelIoEx = (sCancelIoEx)\n    GetProcAddress(kernel32_module, \""CancelIoEx\"");\n\n  pInitializeConditionVariable = (sInitializeConditionVariable)\n    GetProcAddress(kernel32_module, \""InitializeConditionVariable\"");\n\n  pSleepConditionVariableCS = (sSleepConditionVariableCS)\n    GetProcAddress(kernel32_module, \""SleepConditionVariableCS\"");\n\n  pSleepConditionVariableSRW = (sSleepConditionVariableSRW)\n    GetProcAddress(kernel32_module, \""SleepConditionVariableSRW\"");\n\n  pWakeAllConditionVariable = (sWakeAllConditionVariable)\n    GetProcAddress(kernel32_module, \""WakeAllConditionVariable\"");\n\n  pWakeConditionVariable = (sWakeConditionVariable)\n    GetProcAddress(kernel32_module, \""WakeConditionVariable\"");\n}""}, {""func_name"": ""crypto_lock_init"", ""file_path"": ""src/node_crypto.cc"", ""func_code"": ""static void crypto_lock_init(void) {\n  int i, n;\n\n  n = CRYPTO_num_locks();\n  locks = new uv_mutex_t[n];\n\n  for (i = 0; i < n; i++)\n    if (uv_mutex_init(locks + i))\n      abort();\n}""}, {""func_name"": ""crypto_lock_cb"", ""file_path"": ""src/node_crypto.cc"", ""func_code"": ""static void crypto_lock_cb(int mode, int n, const char* file, int line) {\n  CHECK(!(mode & CRYPTO_LOCK) ^ !(mode & CRYPTO_UNLOCK));\n  CHECK(!(mode & CRYPTO_READ) ^ !(mode & CRYPTO_WRITE));\n\n  if (mode & CRYPTO_LOCK)\n    uv_mutex_lock(locks + n);\n  else\n    uv_mutex_unlock(locks + n);\n}""}, {""func_name"": ""uv__rwlock_fallback_init"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static int uv__rwlock_fallback_init(uv_rwlock_t* rwlock) {\n  /* Initialize the semaphore that acts as the write lock. */\n  HANDLE handle = CreateSemaphoreW(NULL, 1, 1, NULL);\n  if (handle == NULL)\n    return uv_translate_sys_error(GetLastError());\n  rwlock->fallback_.write_lock_.sem = handle;\n\n  /* Initialize the critical section protecting the reader count. */\n  InitializeCriticalSection(&rwlock->fallback_.read_lock_.cs);\n\n  /* Initialize the reader count. */\n  rwlock->fallback_.num_readers_ = 0;\n\n  return 0;\n}""}, {""func_name"": ""uv__rwlock_fallback_trywrlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static int uv__rwlock_fallback_trywrlock(uv_rwlock_t* rwlock) {\n  DWORD r = WaitForSingleObject(rwlock->fallback_.write_lock_.sem, 0);\n  if (r == WAIT_OBJECT_0)\n    return 0;\n  else if (r == WAIT_TIMEOUT)\n    return UV_EAGAIN;\n  else if (r == WAIT_FAILED)\n    return uv_translate_sys_error(GetLastError());\n  else\n    return UV_EIO;\n}""}, {""func_name"": ""uv__rwlock_fallback_wrunlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static void uv__rwlock_fallback_wrunlock(uv_rwlock_t* rwlock) {\n  if (!ReleaseSemaphore(rwlock->fallback_.write_lock_.sem, 1, NULL))\n    uv_fatal_error(GetLastError(), \""ReleaseSemaphore\"");\n}""}, {""func_name"": ""uv__rwlock_fallback_tryrdlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static int uv__rwlock_fallback_tryrdlock(uv_rwlock_t* rwlock) {\n  int err;\n\n  if (!TryEnterCriticalSection(&rwlock->fallback_.read_lock_.cs))\n    return UV_EAGAIN;\n\n  err = 0;\n  if (rwlock->fallback_.num_readers_ == 0) {\n    DWORD r = WaitForSingleObject(rwlock->fallback_.write_lock_.sem, 0);\n    if (r == WAIT_OBJECT_0)\n      rwlock->fallback_.num_readers_++;\n    else if (r == WAIT_TIMEOUT)\n      err = UV_EAGAIN;\n    else if (r == WAIT_FAILED)\n      err = uv_translate_sys_error(GetLastError());\n    else\n      err = UV_EIO;\n  }\n\n  LeaveCriticalSection(&rwlock->fallback_.read_lock_.cs);\n  return err;\n}""}, {""func_name"": ""uv__rwlock_fallback_rdlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static void uv__rwlock_fallback_rdlock(uv_rwlock_t* rwlock) {\n  /* Acquire the lock that protects the reader count. */\n  EnterCriticalSection(&rwlock->fallback_.read_lock_.cs);\n\n  /* Increase the reader count, and lock for write if this is the first\n   * reader.\n   */\n  if (++rwlock->fallback_.num_readers_ == 1) {\n    DWORD r = WaitForSingleObject(rwlock->fallback_.write_lock_.sem, INFINITE);\n    if (r != WAIT_OBJECT_0)\n      uv_fatal_error(GetLastError(), \""WaitForSingleObject\"");\n  }\n\n  /* Release the lock that protects the reader count. */\n  LeaveCriticalSection(&rwlock->fallback_.read_lock_.cs);\n}""}, {""func_name"": ""uv__rwlock_fallback_destroy"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static void uv__rwlock_fallback_destroy(uv_rwlock_t* rwlock) {\n  DeleteCriticalSection(&rwlock->fallback_.read_lock_.cs);\n  CloseHandle(rwlock->fallback_.write_lock_.sem);\n}""}, {""func_name"": ""uv__rwlock_fallback_wrlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static void uv__rwlock_fallback_wrlock(uv_rwlock_t* rwlock) {\n  DWORD r = WaitForSingleObject(rwlock->fallback_.write_lock_.sem, INFINITE);\n  if (r != WAIT_OBJECT_0)\n    uv_fatal_error(GetLastError(), \""WaitForSingleObject\"");\n}""}, {""func_name"": ""uv__rwlock_fallback_rdunlock"", ""file_path"": ""src/win/thread.c"", ""func_code"": ""static void uv__rwlock_fallback_rdunlock(uv_rwlock_t* rwlock) {\n  EnterCriticalSection(&rwlock->fallback_.read_lock_.cs);\n\n  if (--rwlock->fallback_.num_readers_ == 0) {\n    if (!ReleaseSemaphore(rwlock->fallback_.write_lock_.sem, 1, NULL))\n      uv_fatal_error(GetLastError(), \""ReleaseSemaphore\"");\n  }\n\n  LeaveCriticalSection(&rwlock->fallback_.read_lock_.cs);\n}""}]",{},[],"Original code used uv_mutex_t (critical section) for write_lock_, requiring the same thread to unlock it. Patch replaces this with a semaphore (CreateSemaphoreW in uv__rwlock_fallback_init: src/win/thread.c:312-314), enabling thread-agnostic unlocking via ReleaseSemaphore in uv__rwlock_fallback_wrunlock (src/win/thread.c:386-388).",0.95,./github/other_context/CVE-2014-9748
28,CVE-2017-14170,CWE-834,c_cpp,"In libavformat/mxfdec.c in FFmpeg 3.3.3 -> 2.4, a DoS in mxf_read_index_entry_array() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted MXF file, which claims a large ""nb_index_entries"" field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU resources, since there is no EOF check inside the loop. Moreover, this big loop can be invoked multiple times if there is more than one applicable data segment in the crafted MXF file.",https://github.com/FFmpeg/FFmpeg/commit/900f39692ca0337a98a7cf047e4e2611071810c2,"avformat/mxfdec: Fix DoS issues in mxf_read_index_entry_array()\n\nFixes: 20170829A.mxf\n\nCo-Author: ()"" <wangchu.zhl@alibaba-inc.com>\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",1,"[{""func_name"": ""mxf_read_index_entry_array"", ""file_path"": ""libavformat/mxfdec.c"", ""func_code"": ""static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n\n    segment->nb_index_entries = avio_rb32(pb);\n\n    length = avio_rb32(pb);\n\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        /* KeyFrameOffset */\n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""mxf_read_index_entry_array"", ""file_path"": ""libavformat/mxfdec.c"", ""func_code"": ""static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n\n    segment->nb_index_entries = avio_rb32(pb);\n\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        /* KeyFrameOffset */\n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}""}]",{},[],The loop at libavformat/mxfdec.c:910-916 iterates segment->nb_index_entries times (set via avio_rb32(pb) at line 900) without EOF checks. A crafted file with large nb_index_entries and insufficient data would cause the loop to exhaust CPU resources. The patch adds avio_feof(pb) checks (line 913) and data length validation (line 903) to prevent this.,0.95,./github/other_context/CVE-2017-14170
29,CVE-2017-5596,"CWE-190, CWE-835",c_cpp,"In Wireshark 2.2.0 to 2.2.3 and 2.0.0 to 2.0.9, the ASTERIX dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-asterix.c by changing a data type to avoid an integer overflow.",https://github.com/wireshark/wireshark/commit/781f03580c81339513bb1238b202b72469a1240b,ASTERIX: Avoid an integer overflow.\n\nCount using a guint instead of a guint8.\n\nBug: 13344\nChange-Id: Ic7d337dbb29b92ebb8332f50fd47b5ba2aa3f41e\nReviewed-on: https://code.wireshark.org/review/19746\nPetri-Dish: Gerald Combs <gerald@wireshark.org>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Gerald Combs <gerald@wireshark.org>,1,"[{""func_name"": ""asterix_fspec_len"", ""file_path"": ""epan/dissectors/packet-asterix.c"", ""func_code"": ""static guint8 asterix_fspec_len (tvbuff_t *tvb, guint offset)\n{\n    guint8 i;\n    for (i = 0; (tvb_get_guint8 (tvb, offset + i) & 1) && i < tvb_reported_length (tvb) - offset; i++);\n    return i + 1;\n}"", ""target"": 0}]","[{""func_name"": ""asterix_fspec_len"", ""file_path"": ""epan/dissectors/packet-asterix.c"", ""func_code"": ""static guint asterix_fspec_len (tvbuff_t *tvb, guint offset)\n{\n    guint i;\n    guint max_length = tvb_reported_length (tvb) - offset;\n    for (i = 0; (tvb_get_guint8 (tvb, offset + i) & 1) && i < max_length; i++);\n    return i + 1;\n}""}]",{},[],"Original root cause: In epan/dissectors/packet-asterix.c, the loop variable 'i' (guint8) would overflow at 255, leading to an infinite loop if the condition (tvb_get_guint8(...) & 1) remained true. Patch changes 'i' to guint and precomputes 'max_length' to prevent overflow.",0.95,./github/other_context/CVE-2017-5596
30,CVE-2015-8012,CWE-617,c_cpp,lldpd before 0.8.0 allows remote attackers to cause a denial of service (assertion failure and daemon crash) via a malformed packet.,https://github.com/lldpd/lldpd/commit/793526f8884455f43daecd0a2c46772388417a00,protocols: don't use assert on paths that can be reached\n\nMalformed packets should not make lldpd crash. Ensure we can handle them\nby not using assert() in this part.,5,"[{""func_name"": ""cdp_decode"", ""file_path"": ""src/daemon/protocols/cdp.c"", ""func_code"": ""int\ncdp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tstruct in_addr addr;\n#if 0\n\tu_int16_t cksum;\n#endif\n\tu_int8_t *software = NULL, *platform = NULL;\n\tint software_len = 0, platform_len = 0, proto, version, nb, caps;\n\tconst unsigned char cdpaddr[] = CDP_MULTICAST_ADDR;\n#ifdef ENABLE_FDP\n\tconst unsigned char fdpaddr[] = CDP_MULTICAST_ADDR;\n\tint fdp = 0;\n#endif\n\tu_int8_t *pos, *tlv, *pos_address, *pos_next_address;\n\tint length, len_eth, tlv_type, tlv_len, addresses_len, address_len;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan;\n#endif\n\n\tlog_debug(\""cdp\"", \""decode CDP frame received on %s\"",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\""cdp\"", \""failed to allocate remote chassis\"");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\""cdp\"", \""failed to allocate remote port\"");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +\n\t    8 /* LLC */ + 4 /* CDP header */) {\n\t\tlog_warn(\""cdp\"", \""too short CDP/FDP frame received on %s\"", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tif (PEEK_CMP(cdpaddr, sizeof(cdpaddr)) != 0) {\n#ifdef ENABLE_FDP\n\t\tPEEK_RESTORE((u_int8_t*)frame);\n\t\tif (PEEK_CMP(fdpaddr, sizeof(fdpaddr)) != 0)\n\t\t\tfdp = 1;\n\t\telse {\n#endif\n\t\t\tlog_info(\""cdp\"", \""frame not targeted at CDP/FDP multicast address received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n#ifdef ENABLE_FDP\n\t\t}\n#endif\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Don't care of source address */\n\tlen_eth = PEEK_UINT16;\n\tif (len_eth > length) {\n\t\tlog_warnx(\""cdp\"", \""incorrect 802.3 frame size reported on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(6);\t/* Skip beginning of LLC */\n\tproto = PEEK_UINT16;\n\tif (proto != LLC_PID_CDP) {\n\t\tif ((proto != LLC_PID_DRIP) &&\n\t\t    (proto != LLC_PID_PAGP) &&\n\t\t    (proto != LLC_PID_PVSTP) &&\n\t\t    (proto != LLC_PID_UDLD) &&\n\t\t    (proto != LLC_PID_VTP) &&\n\t\t    (proto != LLC_PID_DTP) &&\n\t\t    (proto != LLC_PID_STP))\n\t\t\tlog_debug(\""cdp\"", \""incorrect LLC protocol ID received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n#if 0\n\t/* Check checksum */\n\tcksum = frame_checksum(pos, len_eth - 8,\n#ifdef ENABLE_FDP\n\t    !fdp\t\t/* fdp = 0 -> cisco checksum */\n#else\n\t    1\t\t\t/* cisco checksum */\n#endif\n\t\t);\n\tif (cksum != 0) {\n\t\tlog_info(\""cdp\"", \""incorrect CDP/FDP checksum for frame received on %s (%d)\"",\n\t\t\t  hardware->h_ifname, cksum);\n\t\tgoto malformed;\n\t}\n#endif\n\n\t/* Check version */\n\tversion = PEEK_UINT8;\n\tif ((version != 1) && (version != 2)) {\n\t\tlog_warnx(\""cdp\"", \""incorrect CDP/FDP version (%d) for frame received on %s\"",\n\t\t    version, hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_ttl = PEEK_UINT8; /* TTL */\n\tPEEK_DISCARD_UINT16;\t     /* Checksum, already checked */\n\n\twhile (length) {\n\t\tif (length < 4) {\n\t\t\tlog_warnx(\""cdp\"", \""CDP/FDP TLV header is too large for \""\n\t\t\t    \""frame received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_type = PEEK_UINT16;\n\t\ttlv_len = PEEK_UINT16 - 4;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif ((tlv_len < 0) || (length < tlv_len)) {\n\t\t\tlog_warnx(\""cdp\"", \""incorrect size in CDP/FDP TLV header for frame \""\n\t\t\t    \""received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase CDP_TLV_CHASSIS:\n\t\t\tif ((chassis->c_name = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for chassis name\"");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LOCAL;\n\t\t\tif ((chassis->c_id =  (char *)malloc(tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for chassis ID\"");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(chassis->c_id, chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_ADDRESSES:\n\t\t\tCHECK_TLV_SIZE(4, \""Address\"");\n\t\t\taddresses_len = tlv_len - 4;\n\t\t\tfor (nb = PEEK_UINT32; nb > 0; nb--) {\n\t\t\t\t(void)PEEK_SAVE(pos_address);\n\t\t\t\t/* We first try to get the real length of the packet */\n\t\t\t\tif (addresses_len < 2) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD_UINT8; addresses_len--;\n\t\t\t\taddress_len = PEEK_UINT8; addresses_len--;\n\t\t\t\tif (addresses_len < address_len + 2) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\taddresses_len -= address_len;\n\t\t\t\taddress_len = PEEK_UINT16; addresses_len -= 2;\n\t\t\t\tif (addresses_len < address_len) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\t(void)PEEK_SAVE(pos_next_address);\n\t\t\t\t/* Next, we go back and try to extract\n\t\t\t\t   IPv4 address */\n\t\t\t\tPEEK_RESTORE(pos_address);\n\t\t\t\tif ((PEEK_UINT8 == 1) && (PEEK_UINT8 == 1) &&\n\t\t\t\t    (PEEK_UINT8 == CDP_ADDRESS_PROTO_IP) &&\n\t\t\t\t    (PEEK_UINT16 == sizeof(struct in_addr))) {\n\t\t\t\t\t\tPEEK_BYTES(&addr, sizeof(struct in_addr));\n\t\t\t\t\t\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &addr, \n\t\t\t\t\t\t\t\t\tsizeof(struct in_addr), 0);\n\t\t\t\t\t\tif (mgmt == NULL) {\n\t\t\t\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\t\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for management address\"");\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\t\t}\n\t\t\t\t/* Go to the end of the address */\n\t\t\t\tPEEK_RESTORE(pos_next_address);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CDP_TLV_PORT:\n\t\t\tif (tlv_len == 0) {\n\t\t\t\tlog_warn(\""cd[\"", \""too short port description received\"");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((port->p_descr = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for port description\"");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(port->p_descr, tlv_len);\n\t\t\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\t\t\tif ((port->p_id =  (char *)calloc(1, tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for port ID\"");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(port->p_id, port->p_descr, tlv_len);\n\t\t\tport->p_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_CAPABILITIES:\n#ifdef ENABLE_FDP\n\t\t\tif (fdp) {\n\t\t\t\t/* Capabilities are string with FDP */\n\t\t\t\tif (!strncmp(\""Router\"", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_ROUTER;\n\t\t\t\telse if (!strncmp(\""Switch\"", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_BRIDGE;\n\t\t\t\telse if (!strncmp(\""Bridge\"", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_REPEATER;\n\t\t\t\telse\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tCHECK_TLV_SIZE(4, \""Capabilities\"");\n\t\t\tcaps = PEEK_UINT32;\n\t\t\tif (caps & CDP_CAP_ROUTER)\n\t\t\t\tchassis->c_cap_enabled |= LLDP_CAP_ROUTER;\n\t\t\tif (caps & 0x0e)\n\t\t\t\tchassis->c_cap_enabled |= LLDP_CAP_BRIDGE;\n\t\t\tif (chassis->c_cap_enabled == 0)\n\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\tbreak;\n\t\tcase CDP_TLV_SOFTWARE:\n\t\t\tsoftware_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(software);\n\t\t\tbreak;\n\t\tcase CDP_TLV_PLATFORM:\n\t\t\tplatform_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(platform);\n\t\t\tbreak;\n#ifdef ENABLE_DOT1\n\t\tcase CDP_TLV_NATIVEVLAN:\n\t\t\tCHECK_TLV_SIZE(2, \""Native VLAN\"");\n\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\tsizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to alloc vlan \""\n\t\t\t\t\t  \""structure for \""\n\t\t\t\t\t  \""tlv received on %s\"",\n\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tvlan->v_vid = port->p_pvid = PEEK_UINT16;\n\t\t\tif (asprintf(&vlan->v_name, \""VLAN #%d\"", vlan->v_vid) == -1) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to alloc VLAN name for \""\n\t\t\t\t\t  \""TLV received on %s\"",\n\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\tfree(vlan);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t  vlan, v_entries);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tlog_debug(\""cdp\"", \""unknown CDP/FDP TLV type (%d) received on %s\"",\n\t\t\t    ntohs(tlv_type), hardware->h_ifname);\n\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_len - pos);\n\t}\n\tif (!software && platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    platform_len + 1)) == NULL) {\n\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for chassis description\"");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t} else if (software && !platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    software_len + 1)) == NULL) {\n\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for chassis description\"");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, software, software_len);\n\t} else if (software && platform) {\n#define CONCAT_PLATFORM \"" running on\\n\""\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    software_len + platform_len +\n\t\t\t    strlen(CONCAT_PLATFORM) + 1)) == NULL) {\n\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for chassis description\"");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t\tmemcpy(chassis->c_descr + platform_len,\n\t\t    CONCAT_PLATFORM, strlen(CONCAT_PLATFORM));\n\t\tmemcpy(chassis->c_descr + platform_len + strlen(CONCAT_PLATFORM),\n\t\t    software, software_len);\n\t}\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (chassis->c_name == NULL) ||\n\t    (chassis->c_descr == NULL) ||\n\t    (port->p_descr == NULL) ||\n\t    (chassis->c_ttl == 0) ||\n\t    (chassis->c_cap_enabled == 0)) {\n\t\tlog_warnx(\""cdp\"", \""some mandatory CDP/FDP tlv are missing for frame received on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}"", ""target"": 0}, {""func_name"": ""sonmp_decode"", ""file_path"": ""src/daemon/protocols/sonmp.c"", ""func_code"": ""int\nsonmp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tconst u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tint length, i;\n\tu_int8_t *pos;\n\tu_int8_t seg[3], rchassis;\n\tstruct in_addr address;\n\n\tlog_debug(\""sonmp\"", \""decode SONMP PDU from %s\"",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\""sonmp\"", \""failed to allocate remote chassis\"");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\""sonmp\"", \""failed to allocate remote port\"");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\tif (length < SONMP_SIZE) {\n\t\tlog_warnx(\""sonmp\"", \""too short SONMP frame received on %s\"", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t/* There is two multicast address. We just handle only one of\n\t\t * them. */\n\t\tgoto malformed;\n\t/* We skip to LLC PID */\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);\n\tif (PEEK_UINT16 != LLC_PID_SONMP_HELLO) {\n\t\tlog_debug(\""sonmp\"", \""incorrect LLC protocol ID received for SONMP on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR;\n\tif ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) {\n\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for chassis id on %s\"",\n\t\t\thardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_id_len = sizeof(struct in_addr) + 1;\n\tchassis->c_id[0] = 1;\n\tPEEK_BYTES(&address, sizeof(struct in_addr));\n\tmemcpy(chassis->c_id + 1, &address, sizeof(struct in_addr));\n\tif (asprintf(&chassis->c_name, \""%s\"", inet_ntoa(address)) == -1) {\n\t\tlog_warnx(\""sonmp\"", \""unable to write chassis name for %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_BYTES(seg, sizeof(seg));\n\trchassis = PEEK_UINT8;\n\tfor (i=0; sonmp_chassis_types[i].type != 0; i++) {\n\t\tif (sonmp_chassis_types[i].type == rchassis)\n\t\t\tbreak;\n\t}\n\tif (asprintf(&chassis->c_descr, \""%s\"",\n\t\tsonmp_chassis_types[i].description) == -1) {\n\t\tlog_warnx(\""sonmp\"", \""unable to write chassis description for %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);\n\tif (mgmt == NULL) {\n\t\tassert(errno == ENOMEM);\n\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for management address\"");\n\t\tgoto malformed;\n\t}\n\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\tchassis->c_ttl = cfg?(cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold):\n\t    LLDPD_TTL;\n\n\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL;\n\tif (asprintf(&port->p_id, \""%02x-%02x-%02x\"",\n\t\tseg[0], seg[1], seg[2]) == -1) {\n\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for port id on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tport->p_id_len = strlen(port->p_id);\n\n\t/* Port description depend on the number of segments */\n\tif ((seg[0] == 0) && (seg[1] == 0)) {\n\t\tif (asprintf(&port->p_descr, \""port %d\"",\n\t\t\tseg[2]) == -1) {\n\t\t\tlog_warnx(\""sonmp\"", \""unable to write port description for %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else if (seg[0] == 0) {\n\t\tif (asprintf(&port->p_descr, \""port %d/%d\"",\n\t\t\tseg[1], seg[2]) == -1) {\n\t\t\tlog_warnx(\""sonmp\"", \""unable to write port description for %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else {\n\t\tif (asprintf(&port->p_descr, \""port %x:%x:%x\"",\n\t\t\tseg[0], seg[1], seg[2]) == -1) {\n\t\t\tlog_warnx(\""sonmp\"", \""unable to write port description for %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}"", ""target"": 0}, {""func_name"": ""lldp_decode"", ""file_path"": ""src/daemon/protocols/lldp.c"", ""func_code"": ""int\nlldp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tconst char lldpaddr[] = LLDP_MULTICAST_ADDR;\n\tconst char dot1[] = LLDP_TLV_ORG_DOT1;\n\tconst char dot3[] = LLDP_TLV_ORG_DOT3;\n\tconst char med[] = LLDP_TLV_ORG_MED;\n\tconst char dcbx[] = LLDP_TLV_ORG_DCBX;\n\tunsigned char orgid[3];\n\tint length, gotend = 0, ttl_received = 0;\n\tint tlv_size, tlv_type, tlv_subtype;\n\tu_int8_t *pos, *tlv;\n\tchar *b;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan = NULL;\n\tint vlan_len;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi = NULL;\n#endif\n\tstruct lldpd_mgmt *mgmt;\n\tint af;\n\tu_int8_t addr_str_length, addr_str_buffer[32];\n\tu_int8_t addr_family, addr_length, *addr_ptr, iface_subtype;\n\tu_int32_t iface_number, iface;\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom = NULL;\n#endif\n\n\tlog_debug(\""lldp\"", \""receive LLDP PDU on %s\"",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\""lldp\"", \""failed to allocate remote chassis\"");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\""lldp\"", \""failed to allocate remote port\"");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n\tTAILQ_INIT(&port->p_ppvids);\n\tTAILQ_INIT(&port->p_pids);\n#endif\n#ifdef ENABLE_CUSTOM\n\tTAILQ_INIT(&port->p_custom_list);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\""lldp\"", \""too short frame received on %s\"", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) {\n\t\tlog_info(\""lldp\"", \""frame not targeted at LLDP multicast address received on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Skip source address */\n\tif (PEEK_UINT16 != ETHERTYPE_LLDP) {\n\t\tlog_info(\""lldp\"", \""non LLDP frame received on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\twhile (length && (!gotend)) {\n\t\tif (length < 2) {\n\t\t\tlog_warnx(\""lldp\"", \""tlv header too short received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_size = PEEK_UINT16;\n\t\ttlv_type = tlv_size >> 9;\n\t\ttlv_size = tlv_size & 0x1ff;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif (length < tlv_size) {\n\t\t\tlog_warnx(\""lldp\"", \""frame too short for tlv received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase LLDP_TLV_END:\n\t\t\tif (tlv_size != 0) {\n\t\t\t\tlog_warnx(\""lldp\"", \""lldp end received with size not null on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif (length)\n\t\t\t\tlog_debug(\""lldp\"", \""extra data after lldp end on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_CHASSIS_ID:\n\t\tcase LLDP_TLV_PORT_ID:\n\t\t\tCHECK_TLV_SIZE(2, \""Port Id\"");\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif ((tlv_subtype == 0) || (tlv_subtype > 7)) {\n\t\t\t\tlog_warnx(\""lldp\"", \""unknown subtype for tlv id received on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size - 1)) == NULL) {\n\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate memory for id tlv \""\n\t\t\t\t    \""received on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size - 1);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_ID) {\n\t\t\t\tport->p_id_subtype = tlv_subtype;\n\t\t\t\tport->p_id = b;\n\t\t\t\tport->p_id_len = tlv_size - 1;\n\t\t\t} else {\n\t\t\t\tchassis->c_id_subtype = tlv_subtype;\n\t\t\t\tchassis->c_id = b;\n\t\t\t\tchassis->c_id_len = tlv_size - 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LLDP_TLV_TTL:\n\t\t\tCHECK_TLV_SIZE(2, \""TTL\"");\n\t\t\tchassis->c_ttl = PEEK_UINT16;\n\t\t\tttl_received = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_PORT_DESCR:\n\t\tcase LLDP_TLV_SYSTEM_NAME:\n\t\tcase LLDP_TLV_SYSTEM_DESCR:\n\t\t\tif (tlv_size < 1) {\n\t\t\t\tlog_debug(\""lldp\"", \""empty tlv received on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {\n\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate memory for string tlv \""\n\t\t\t\t    \""received on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_DESCR)\n\t\t\t\tport->p_descr = b;\n\t\t\telse if (tlv_type == LLDP_TLV_SYSTEM_NAME)\n\t\t\t\tchassis->c_name = b;\n\t\t\telse chassis->c_descr = b;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_SYSTEM_CAP:\n\t\t\tCHECK_TLV_SIZE(4, \""System capabilities\"");\n\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \""Management address\"");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {\n\t\t\t\tlog_warnx(\""lldp\"", \""too large management address on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \""Management address\"");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \""Management address\"");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate memory \""\n\t\t\t\t\t\t\t\""for management address\"");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(1 + (int)sizeof(orgid), \""Organisational\"");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot1 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT1_VLANNAME:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \""VLAN\"");\n\t\t\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to alloc vlan \""\n\t\t\t\t\t\t    \""structure for \""\n\t\t\t\t\t\t    \""tlv received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tvlan->v_vid = PEEK_UINT16;\n\t\t\t\t\tvlan_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(7 + vlan_len, \""VLAN\"");\n\t\t\t\t\tif ((vlan->v_name =\n\t\t\t\t\t\t(char *)calloc(1, vlan_len + 1)) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to alloc vlan name for \""\n\t\t\t\t\t\t    \""tlv received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(vlan->v_name, vlan_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t    vlan, v_entries);\n\t\t\t\t\tvlan = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PVID:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \""PVID\"");\n\t\t\t\t\tport->p_pvid = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PPVID:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \""PPVID\"");\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PPVID has to be unique if more than\n\t\t\t\t\t   one PPVID TLVs are received  - \n\t\t\t\t\t   discard if duplicate */\n\t\t\t\t\t/* if support bit is not set and \n\t\t\t\t\t   enabled bit is set - PPVID TLV is\n\t\t\t\t\t   considered error  and discarded */\n\t\t\t\t\t/* if PPVID > 4096 - bad and discard */\n\t\t\t\t\tif ((ppvid = (struct lldpd_ppvid *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_ppvid))) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to alloc ppvid \""\n\t\t\t\t\t\t    \""structure for \""\n\t\t\t\t\t\t    \""tlv received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tppvid->p_cap_status = PEEK_UINT8;\n\t\t\t\t\tppvid->p_ppvid = PEEK_UINT16;\t\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_ppvids,\n\t\t\t\t\t    ppvid, p_entries);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PI:\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PI has to be unique if more than \n\t\t\t\t\t   one PI TLVs are received  - discard\n\t\t\t\t\t   if duplicate ?? */\n\t\t\t\t\tCHECK_TLV_SIZE(5, \""PI\"");\n\t\t\t\t\tif ((pi = (struct lldpd_pi *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_pi))) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to alloc PI \""\n\t\t\t\t\t\t    \""structure for \""\n\t\t\t\t\t\t    \""tlv received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tpi->p_pi_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(5 + pi->p_pi_len, \""PI\"");\n\t\t\t\t\tif ((pi->p_pi =\n\t\t\t\t\t\t(char *)calloc(1, pi->p_pi_len)) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to alloc pid name for \""\n\t\t\t\t\t\t    \""tlv received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(pi->p_pi, pi->p_pi_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_pids,\n\t\t\t\t\t    pi, p_entries);\n\t\t\t\t\tpi = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot1 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT3\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot3 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT3_MAC:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \""MAC/PHY\"");\n\t\t\t\t\tport->p_macphy.autoneg_support = PEEK_UINT8;\n\t\t\t\t\tport->p_macphy.autoneg_enabled =\n\t\t\t\t\t    (port->p_macphy.autoneg_support & 0x2) >> 1;\n\t\t\t\t\tport->p_macphy.autoneg_support =\n\t\t\t\t\t    port->p_macphy.autoneg_support & 0x1;\n\t\t\t\t\tport->p_macphy.autoneg_advertised =\n\t\t\t\t\t    PEEK_UINT16;\n\t\t\t\t\tport->p_macphy.mau_type = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_LA:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \""Link aggregation\"");\n\t\t\t\t\tPEEK_DISCARD_UINT8;\n\t\t\t\t\tport->p_aggregid = PEEK_UINT32;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_MFS:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \""MFS\"");\n\t\t\t\t\tport->p_mfs = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_POWER:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \""Power\"");\n\t\t\t\t\tport->p_power.devicetype = PEEK_UINT8;\n\t\t\t\t\tport->p_power.supported =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x2) >> 1;\n\t\t\t\t\tport->p_power.enabled =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x4) >> 2;\n\t\t\t\t\tport->p_power.paircontrol =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x8) >> 3;\n\t\t\t\t\tport->p_power.devicetype =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x1)?\n\t\t\t\t\t\tLLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD;\n\t\t\t\t\tport->p_power.pairs = PEEK_UINT8;\n\t\t\t\t\tport->p_power.class = PEEK_UINT8;\n\t\t\t\t\t/* 802.3at? */\n\t\t\t\t\tif (tlv_size >= 12) {\n\t\t\t\t\t\tport->p_power.powertype = PEEK_UINT8;\n\t\t\t\t\t\tport->p_power.source =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<5 | 1<<4)) >> 4;\n\t\t\t\t\t\tport->p_power.priority =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<1 | 1<<0));\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<7))?\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE1:\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE2;\n\t\t\t\t\t\tport->p_power.requested = PEEK_UINT16;\n\t\t\t\t\t\tport->p_power.allocated = PEEK_UINT16;\n\t\t\t\t\t} else\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_OFF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot3 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(med, orgid, sizeof(orgid)) == 0) {\n\t\t\t\t/* LLDP-MED */\n#ifndef ENABLE_LLDPMED\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\tu_int32_t policy;\n\t\t\t\tunsigned loctype;\n\t\t\t\tunsigned power;\n\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_MED_CAP:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \""LLDP-MED capabilities\"");\n\t\t\t\t\tchassis->c_med_cap_available = PEEK_UINT16;\n\t\t\t\t\tchassis->c_med_type = PEEK_UINT8;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_CAP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_POLICY:\n\t\t\t\t\tCHECK_TLV_SIZE(8, \""LLDP-MED policy\"");\n\t\t\t\t\tpolicy = PEEK_UINT32;\n\t\t\t\t\tif (((policy >> 24) < 1) ||\n\t\t\t\t\t    ((policy >> 24) > LLDP_MED_APPTYPE_LAST)) {\n\t\t\t\t\t\tlog_info(\""lldp\"", \""unknown policy field %d \""\n\t\t\t\t\t\t    \""received on %s\"",\n\t\t\t\t\t\t    policy,\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].type =\n\t\t\t\t\t    (policy >> 24);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].unknown =\n\t\t\t\t\t    ((policy & 0x800000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].tagged =\n\t\t\t\t\t    ((policy & 0x400000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].vid =\n\t\t\t\t\t    (policy & 0x001FFE00) >> 9;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].priority =\n\t\t\t\t\t    (policy & 0x1C0) >> 6;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].dscp =\n\t\t\t\t\t    policy & 0x3F;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_POLICY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_LOCATION:\n\t\t\t\t\tCHECK_TLV_SIZE(5, \""LLDP-MED Location\"");\n\t\t\t\t\tloctype = PEEK_UINT8;\n\t\t\t\t\tif ((loctype < 1) ||\n\t\t\t\t\t    (loctype > LLDP_MED_LOCFORMAT_LAST)) {\n\t\t\t\t\t\tlog_info(\""lldp\"", \""unknown location type \""\n\t\t\t\t\t\t    \""received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((port->p_med_location[loctype - 1].data =\n\t\t\t\t\t\t(char*)malloc(tlv_size - 5)) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate memory \""\n\t\t\t\t\t\t    \""for LLDP-MED location for \""\n\t\t\t\t\t\t    \""frame received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(port->p_med_location[loctype - 1].data,\n\t\t\t\t\t    tlv_size - 5);\n\t\t\t\t\tport->p_med_location[loctype - 1].data_len =\n\t\t\t\t\t    tlv_size - 5;\n\t\t\t\t\tport->p_med_location[loctype - 1].format = loctype;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_LOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_MDI:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \""LLDP-MED PoE-MDI\"");\n\t\t\t\t\tpower = PEEK_UINT8;\n\t\t\t\t\tswitch (power & 0xC0) {\n\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PSE;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PRIMARY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BACKUP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_RESERVED;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PD;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_LOCAL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BOTH;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tport->p_med_power.devicetype =\n\t\t\t\t\t\t    LLDP_MED_POW_TYPE_RESERVED;\n\t\t\t\t\t}\n\t\t\t\t\tif ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW)\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    LLDP_MED_POW_PRIO_UNKNOWN;\n\t\t\t\t\telse\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    power & 0x0F;\n\t\t\t\t\tport->p_med_power.val = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\tif (tlv_size <= 4)\n\t\t\t\t\t\tb = NULL;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ((b = (char*)malloc(tlv_size - 3)) ==\n\t\t\t\t\t\t    NULL) {\n\t\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate \""\n\t\t\t\t\t\t\t    \""memory for LLDP-MED \""\n\t\t\t\t\t\t\t    \""inventory for frame \""\n\t\t\t\t\t\t\t    \""received on %s\"",\n\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPEEK_BYTES(b, tlv_size - 4);\n\t\t\t\t\t\tb[tlv_size - 4] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\t\t\tchassis->c_med_hw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\t\t\tchassis->c_med_fw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\t\t\tchassis->c_med_sw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\t\t\tchassis->c_med_sn = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\t\t\tchassis->c_med_manuf = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\t\t\tchassis->c_med_model = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\t\tchassis->c_med_asset = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_IV;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown LLDP MED, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif /* ENABLE_LLDPMED */\n\t\t\t} else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) {\n\t\t\t\tlog_debug(\""lldp\"", \""unsupported DCBX tlv received on %s - ignore\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t} else {\n\t\t\t\tlog_debug(\""lldp\"", \""unknown org tlv [%02x:%02x:%02x] received on %s\"",\n\t\t\t\t    orgid[0], orgid[1], orgid[2],\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#ifdef ENABLE_CUSTOM\n\t\t\t\tcustom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom));\n\t\t\t\tif (!custom) {\n\t\t\t\t\tlog_warn(\""lldp\"",\n\t\t\t\t\t    \""unable to allocate memory for custom TLV\"");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tcustom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0;\n\t\t\t\tmemcpy(custom->oui, orgid, sizeof(custom->oui));\n\t\t\t\tcustom->subtype = tlv_subtype;\n\t\t\t\tif (custom->oui_info_len > 0) {\n\t\t\t\t\tcustom->oui_info = malloc(custom->oui_info_len);\n\t\t\t\t\tif (!custom->oui_info) {\n\t\t\t\t\t\tlog_warn(\""lldp\"",\n\t\t\t\t\t\t    \""unable to allocate memory for custom TLV data\"");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(custom->oui_info, custom->oui_info_len);\n\t\t\t\t}\n\t\t\t\tTAILQ_INSERT_TAIL(&port->p_custom_list, custom, next);\n\t\t\t\tcustom = NULL;\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_warnx(\""lldp\"", \""unknown tlv (%d) received on %s\"",\n\t\t\t    tlv_type, hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tif (pos > tlv + tlv_size) {\n\t\t\tlog_warnx(\""lldp\"", \""BUG: already past TLV!\"");\n\t\t\tgoto malformed;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_size - pos);\n\t}\n\n\t/* Some random check */\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (!ttl_received) ||\n\t    (gotend == 0)) {\n\t\tlog_warnx(\""lldp\"", \""some mandatory tlv are missing for frame received on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\nmalformed:\n#ifdef ENABLE_CUSTOM\n\tfree(custom);\n#endif\n#ifdef ENABLE_DOT1\n\tfree(vlan);\n\tfree(pi);\n#endif\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}"", ""target"": 0}, {""func_name"": ""_lldp_send"", ""file_path"": ""src/daemon/protocols/lldp.c"", ""func_code"": ""static int _lldp_send(struct lldpd *global,\n    struct lldpd_hardware *hardware,\n    u_int8_t c_id_subtype,\n    char *c_id,\n    int c_id_len,\n    u_int8_t p_id_subtype,\n    char *p_id,\n    int p_id_len,\n    int shutdown)\n{\n\tstruct lldpd_port *port;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_frame *frame;\n\tint length;\n\tu_int8_t *packet, *pos, *tlv;\n\tstruct lldpd_mgmt *mgmt;\n\tint proto;\n\n\tu_int8_t mcastaddr[] = LLDP_MULTICAST_ADDR;\n#ifdef ENABLE_DOT1\n\tconst u_int8_t dot1[] = LLDP_TLV_ORG_DOT1;\n\tstruct lldpd_vlan *vlan;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi;\n#endif\n#ifdef ENABLE_DOT3\n\tconst u_int8_t dot3[] = LLDP_TLV_ORG_DOT3;\n#endif\n#ifdef ENABLE_LLDPMED\n\tint i;\n\tconst u_int8_t med[] = LLDP_TLV_ORG_MED;\n#endif\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom;\n#endif\n\tport = &hardware->h_lport;\n\tchassis = port->p_chassis;\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\treturn ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(\n\t      /* LLDP multicast address */\n\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t      /* Source MAC address */\n\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t      /* LLDP frame */\n\t      POKE_UINT16(ETHERTYPE_LLDP)))\n\t\tgoto toobig;\n\n\t/* Chassis ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_CHASSIS_ID) &&\n\t      POKE_UINT8(c_id_subtype) &&\n\t      POKE_BYTES(c_id, c_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Port ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_PORT_ID) &&\n\t      POKE_UINT8(p_id_subtype) &&\n\t      POKE_BYTES(p_id, p_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Time to live */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_TTL) &&\n\t      POKE_UINT16(shutdown?0:chassis->c_ttl) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (shutdown)\n\t\tgoto end;\n\n\t/* System name */\n\tif (chassis->c_name && *chassis->c_name != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_NAME) &&\n\t\t\t    POKE_BYTES(chassis->c_name, strlen(chassis->c_name)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System description (skip it if empty) */\n\tif (chassis->c_descr && *chassis->c_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_DESCR) &&\n\t\t\t    POKE_BYTES(chassis->c_descr, strlen(chassis->c_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System capabilities */\n\tif (global->g_config.c_cap_advertise && chassis->c_cap_available) {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_CAP) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_available) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_enabled) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Management addresses */\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tproto = lldpd_af_to_lldp_proto(mgmt->m_family);\n\t\tassert(proto != LLDP_MGMT_ADDR_NONE);\n\t\tif (!(\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_MGMT_ADDR) &&\n\t\t\t  /* Size of the address, including its type */\n\t\t\t  POKE_UINT8(mgmt->m_addrsize + 1) &&\n\t\t\t  POKE_UINT8(proto) &&\n\t\t\t  POKE_BYTES(&mgmt->m_addr, mgmt->m_addrsize)))\n\t\t\tgoto toobig;\n\n\t\t/* Interface port type, OID */\n\t\tif (mgmt->m_iface == 0) {\n\t\t\tif (!(\n\t\t\t\t  /* We don't know the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_UNKNOWN) &&\n\t\t\t\t  POKE_UINT32(0)))\n\t\t\t\tgoto toobig;\n\t\t} else {\n\t\t\tif (!(\n\t\t\t\t  /* We have the index of the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_IFINDEX) &&\n\t\t\t\t  POKE_UINT32(mgmt->m_iface)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(\n\t\t\t  /* We don't provide an OID for management */\n\t\t\t  POKE_UINT8(0) &&\n\t\t\t  POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Port description */\n\tif (port->p_descr && *port->p_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_PORT_DESCR) &&\n\t\t\t    POKE_BYTES(port->p_descr, strlen(port->p_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n#ifdef ENABLE_DOT1\n\t/* Port VLAN ID */\n\tif(port->p_pvid != 0) {\n\t\tif (!(\n\t\t    POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t    POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t    POKE_UINT8(LLDP_TLV_DOT1_PVID) &&\n\t\t    POKE_UINT16(port->p_pvid) &&\n\t\t    POKE_END_LLDP_TLV)) {\n\t\t    goto toobig;\n\t\t}\n\t}\n\t/* Port and Protocol VLAN IDs */\n\tTAILQ_FOREACH(ppvid, &port->p_ppvids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PPVID) &&\n\t\t      POKE_UINT8(ppvid->p_cap_status) &&\n\t\t      POKE_UINT16(ppvid->p_ppvid) &&\n\t\t      POKE_END_LLDP_TLV)) {\n\t\t\tgoto toobig;\n\t\t}\n\t}\n\t/* VLANs */\n\tTAILQ_FOREACH(vlan, &port->p_vlans, v_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_VLANNAME) &&\n\t\t      POKE_UINT16(vlan->v_vid) &&\n\t\t      POKE_UINT8(strlen(vlan->v_name)) &&\n\t\t      POKE_BYTES(vlan->v_name, strlen(vlan->v_name)) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Protocol Identities */\n\tTAILQ_FOREACH(pi, &port->p_pids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PI) &&\n\t\t      POKE_UINT8(pi->p_pi_len) &&\n\t\t      POKE_BYTES(pi->p_pi, pi->p_pi_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_DOT3\n\t/* Aggregation status */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_LA) &&\n\t      /* Bit 0 = capability ; Bit 1 = status */\n\t      POKE_UINT8((port->p_aggregid) ? 3:1) &&\n\t      POKE_UINT32(port->p_aggregid) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MAC/PHY */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_MAC) &&\n\t      POKE_UINT8(port->p_macphy.autoneg_support |\n\t\t\t (port->p_macphy.autoneg_enabled << 1)) &&\n\t      POKE_UINT16(port->p_macphy.autoneg_advertised) &&\n\t      POKE_UINT16(port->p_macphy.mau_type) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MFS */\n\tif (port->p_mfs) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_MFS) &&\n\t\t      POKE_UINT16(port->p_mfs) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Power */\n\tif (port->p_power.devicetype) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_POWER) &&\n\t\t      POKE_UINT8((\n\t\t\t\t  (((2 - port->p_power.devicetype)    %(1<< 1))<<0) |\n\t\t\t\t  (( port->p_power.supported          %(1<< 1))<<1) |\n\t\t\t\t  (( port->p_power.enabled            %(1<< 1))<<2) |\n\t\t\t\t  (( port->p_power.paircontrol        %(1<< 1))<<3))) &&\n\t\t      POKE_UINT8(port->p_power.pairs) &&\n\t\t      POKE_UINT8(port->p_power.class)))\n\t\t\tgoto toobig;\n\t\t/* 802.3at */\n\t\tif (port->p_power.powertype != LLDP_DOT3_POWER_8023AT_OFF) {\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t\t  (((port->p_power.powertype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_8023AT_TYPE1)?1:0) << 7) |\n\t\t\t\t\t   (((port->p_power.devicetype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_PSE)?0:1) << 6) |\n\t\t\t\t\t   ((port->p_power.source   %(1<< 2))<<4) |\n\t\t\t\t\t   ((port->p_power.priority %(1<< 2))<<0))) &&\n\t\t\t      POKE_UINT16(port->p_power.requested) &&\n\t\t\t      POKE_UINT16(port->p_power.allocated)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_LLDPMED\n\tif (port->p_med_cap_enabled) {\n\t\t/* LLDP-MED cap */\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t      POKE_UINT8(LLDP_TLV_MED_CAP) &&\n\t\t      POKE_UINT16(chassis->c_med_cap_available) &&\n\t\t      POKE_UINT8(chassis->c_med_type) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\n\t\t/* LLDP-MED inventory */\n#define LLDP_INVENTORY(value, subtype)\t\t\t\t\t\\\n\t\tif (value) {\t\t\t\t\t\t\\\n\t\t    if (!(\t\t\t\t\t\t\\\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\t\t\\\n\t\t\t  POKE_BYTES(med, sizeof(med)) &&\t\t\\\n\t\t\t  POKE_UINT8(subtype) &&\t\t\t\\\n\t\t\t  POKE_BYTES(value,\t\t\t\t\\\n\t\t\t\t(strlen(value)>32)?32:strlen(value)) &&\t\\\n\t\t\t  POKE_END_LLDP_TLV))\t\t\t\t\\\n\t\t\t    goto toobig;\t\t\t\t\\\n\t\t}\n\n\t\tif (port->p_med_cap_enabled & LLDP_MED_CAP_IV) {\n\t\t\tLLDP_INVENTORY(chassis->c_med_hw,\n\t\t\t    LLDP_TLV_MED_IV_HW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_fw,\n\t\t\t    LLDP_TLV_MED_IV_FW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sw,\n\t\t\t    LLDP_TLV_MED_IV_SW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sn,\n\t\t\t    LLDP_TLV_MED_IV_SN);\n\t\t\tLLDP_INVENTORY(chassis->c_med_manuf,\n\t\t\t    LLDP_TLV_MED_IV_MANUF);\n\t\t\tLLDP_INVENTORY(chassis->c_med_model,\n\t\t\t    LLDP_TLV_MED_IV_MODEL);\n\t\t\tLLDP_INVENTORY(chassis->c_med_asset,\n\t\t\t    LLDP_TLV_MED_IV_ASSET);\n\t\t}\n\n\t\t/* LLDP-MED location */\n\t\tfor (i = 0; i < LLDP_MED_LOCFORMAT_LAST; i++) {\n\t\t\tif (port->p_med_location[i].format == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_LOCATION) &&\n\t\t\t\t      POKE_UINT8(port->p_med_location[i].format) &&\n\t\t\t\t      POKE_BYTES(port->p_med_location[i].data,\n\t\t\t\t\t  port->p_med_location[i].data_len) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED network policy */\n\t\tfor (i = 0; i < LLDP_MED_APPTYPE_LAST; i++) {\n\t\t\tif (port->p_med_policy[i].type == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_POLICY) &&\n\t\t\t\t      POKE_UINT32((\n\t\t\t\t\t((port->p_med_policy[i].type     %(1<< 8))<<24) |\n\t\t\t\t\t((port->p_med_policy[i].unknown  %(1<< 1))<<23) |\n\t\t\t\t\t((port->p_med_policy[i].tagged   %(1<< 1))<<22) |\n\t\t\t\t      /*((0                              %(1<< 1))<<21) |*/\n\t\t\t\t\t((port->p_med_policy[i].vid      %(1<<12))<< 9) |\n\t\t\t\t\t((port->p_med_policy[i].priority %(1<< 3))<< 6) |\n\t\t\t\t\t((port->p_med_policy[i].dscp     %(1<< 6))<< 0) )) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED POE-MDI */\n\t\tif ((port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PSE) ||\n\t\t    (port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PD)) {\n\t\t\tint devicetype = 0, source = 0;\n\t\t\tif (!(\n\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t      POKE_UINT8(LLDP_TLV_MED_MDI)))\n\t\t\t\tgoto toobig;\n\t\t\tswitch (port->p_med_power.devicetype) {\n\t\t\tcase LLDP_MED_POW_TYPE_PSE:\n\t\t\t\tdevicetype = 0;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PRIMARY: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BACKUP: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_RESERVED: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LLDP_MED_POW_TYPE_PD:\n\t\t\t\tdevicetype = 1;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PSE: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_LOCAL: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BOTH: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t((devicetype                   %(1<< 2))<<6) |\n\t\t\t\t((source                       %(1<< 2))<<4) |\n\t\t\t\t((port->p_med_power.priority   %(1<< 4))<<0) )) &&\n\t\t\t      POKE_UINT16(port->p_med_power.val) &&\n\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\tgoto toobig;\n\t\t}\n\t}\n#endif\n\n#ifdef ENABLE_CUSTOM\n\tTAILQ_FOREACH(custom, &port->p_custom_list, next) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(custom->oui, sizeof(custom->oui)) &&\n\t\t      POKE_UINT8(custom->subtype) &&\n\t\t      POKE_BYTES(custom->oui_info, custom->oui_info_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\nend:\n\t/* END */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_END) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, pos - packet) == -1) {\n\t\tlog_warn(\""lldp\"", \""unable to send packet on real device for %s\"",\n\t\t    hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\thardware->h_tx_cnt++;\n\n\t/* We assume that LLDP frame is the reference */\n\tif (!shutdown && (frame = (struct lldpd_frame*)malloc(\n\t\t\tsizeof(int) + pos - packet)) != NULL) {\n\t\tframe->size = pos - packet;\n\t\tmemcpy(&frame->frame, packet, frame->size);\n\t\tif ((hardware->h_lport.p_lastframe == NULL) ||\n\t\t    (hardware->h_lport.p_lastframe->size != frame->size) ||\n\t\t    (memcmp(hardware->h_lport.p_lastframe->frame, frame->frame,\n\t\t\tframe->size) != 0)) {\n\t\t\tfree(hardware->h_lport.p_lastframe);\n\t\t\thardware->h_lport.p_lastframe = frame;\n\t\t\thardware->h_lport.p_lastchange = time(NULL);\n\t\t} else free(frame);\n\t}\n\n\tfree(packet);\n\treturn 0;\n\ntoobig:\n\tfree(packet);\n\treturn E2BIG;\n}"", ""target"": 0}, {""func_name"": ""lldpd_alloc_mgmt"", ""file_path"": ""src/daemon/lldpd.c"", ""func_code"": ""struct lldpd_mgmt *\nlldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\n\tlog_debug(\""alloc\"", \""allocate a new management address (family: %d)\"", family);\n\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tassert(addrsize <= LLDPD_MGMT_MAXADDRSIZE);\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}"", ""target"": 0}]","[{""func_name"": ""cdp_decode"", ""file_path"": ""src/daemon/protocols/cdp.c"", ""func_code"": ""int\ncdp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tstruct in_addr addr;\n#if 0\n\tu_int16_t cksum;\n#endif\n\tu_int8_t *software = NULL, *platform = NULL;\n\tint software_len = 0, platform_len = 0, proto, version, nb, caps;\n\tconst unsigned char cdpaddr[] = CDP_MULTICAST_ADDR;\n#ifdef ENABLE_FDP\n\tconst unsigned char fdpaddr[] = CDP_MULTICAST_ADDR;\n\tint fdp = 0;\n#endif\n\tu_int8_t *pos, *tlv, *pos_address, *pos_next_address;\n\tint length, len_eth, tlv_type, tlv_len, addresses_len, address_len;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan;\n#endif\n\n\tlog_debug(\""cdp\"", \""decode CDP frame received on %s\"",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\""cdp\"", \""failed to allocate remote chassis\"");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\""cdp\"", \""failed to allocate remote port\"");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +\n\t    8 /* LLC */ + 4 /* CDP header */) {\n\t\tlog_warn(\""cdp\"", \""too short CDP/FDP frame received on %s\"", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tif (PEEK_CMP(cdpaddr, sizeof(cdpaddr)) != 0) {\n#ifdef ENABLE_FDP\n\t\tPEEK_RESTORE((u_int8_t*)frame);\n\t\tif (PEEK_CMP(fdpaddr, sizeof(fdpaddr)) != 0)\n\t\t\tfdp = 1;\n\t\telse {\n#endif\n\t\t\tlog_info(\""cdp\"", \""frame not targeted at CDP/FDP multicast address received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n#ifdef ENABLE_FDP\n\t\t}\n#endif\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Don't care of source address */\n\tlen_eth = PEEK_UINT16;\n\tif (len_eth > length) {\n\t\tlog_warnx(\""cdp\"", \""incorrect 802.3 frame size reported on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(6);\t/* Skip beginning of LLC */\n\tproto = PEEK_UINT16;\n\tif (proto != LLC_PID_CDP) {\n\t\tif ((proto != LLC_PID_DRIP) &&\n\t\t    (proto != LLC_PID_PAGP) &&\n\t\t    (proto != LLC_PID_PVSTP) &&\n\t\t    (proto != LLC_PID_UDLD) &&\n\t\t    (proto != LLC_PID_VTP) &&\n\t\t    (proto != LLC_PID_DTP) &&\n\t\t    (proto != LLC_PID_STP))\n\t\t\tlog_debug(\""cdp\"", \""incorrect LLC protocol ID received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n#if 0\n\t/* Check checksum */\n\tcksum = frame_checksum(pos, len_eth - 8,\n#ifdef ENABLE_FDP\n\t    !fdp\t\t/* fdp = 0 -> cisco checksum */\n#else\n\t    1\t\t\t/* cisco checksum */\n#endif\n\t\t);\n\tif (cksum != 0) {\n\t\tlog_info(\""cdp\"", \""incorrect CDP/FDP checksum for frame received on %s (%d)\"",\n\t\t\t  hardware->h_ifname, cksum);\n\t\tgoto malformed;\n\t}\n#endif\n\n\t/* Check version */\n\tversion = PEEK_UINT8;\n\tif ((version != 1) && (version != 2)) {\n\t\tlog_warnx(\""cdp\"", \""incorrect CDP/FDP version (%d) for frame received on %s\"",\n\t\t    version, hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_ttl = PEEK_UINT8; /* TTL */\n\tPEEK_DISCARD_UINT16;\t     /* Checksum, already checked */\n\n\twhile (length) {\n\t\tif (length < 4) {\n\t\t\tlog_warnx(\""cdp\"", \""CDP/FDP TLV header is too large for \""\n\t\t\t    \""frame received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_type = PEEK_UINT16;\n\t\ttlv_len = PEEK_UINT16 - 4;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif ((tlv_len < 0) || (length < tlv_len)) {\n\t\t\tlog_warnx(\""cdp\"", \""incorrect size in CDP/FDP TLV header for frame \""\n\t\t\t    \""received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase CDP_TLV_CHASSIS:\n\t\t\tif ((chassis->c_name = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for chassis name\"");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LOCAL;\n\t\t\tif ((chassis->c_id =  (char *)malloc(tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for chassis ID\"");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(chassis->c_id, chassis->c_name, tlv_len);\n\t\t\tchassis->c_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_ADDRESSES:\n\t\t\tCHECK_TLV_SIZE(4, \""Address\"");\n\t\t\taddresses_len = tlv_len - 4;\n\t\t\tfor (nb = PEEK_UINT32; nb > 0; nb--) {\n\t\t\t\t(void)PEEK_SAVE(pos_address);\n\t\t\t\t/* We first try to get the real length of the packet */\n\t\t\t\tif (addresses_len < 2) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD_UINT8; addresses_len--;\n\t\t\t\taddress_len = PEEK_UINT8; addresses_len--;\n\t\t\t\tif (addresses_len < address_len + 2) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\taddresses_len -= address_len;\n\t\t\t\taddress_len = PEEK_UINT16; addresses_len -= 2;\n\t\t\t\tif (addresses_len < address_len) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\t(void)PEEK_SAVE(pos_next_address);\n\t\t\t\t/* Next, we go back and try to extract\n\t\t\t\t   IPv4 address */\n\t\t\t\tPEEK_RESTORE(pos_address);\n\t\t\t\tif ((PEEK_UINT8 == 1) && (PEEK_UINT8 == 1) &&\n\t\t\t\t    (PEEK_UINT8 == CDP_ADDRESS_PROTO_IP) &&\n\t\t\t\t    (PEEK_UINT16 == sizeof(struct in_addr))) {\n\t\t\t\t\t\tPEEK_BYTES(&addr, sizeof(struct in_addr));\n\t\t\t\t\t\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &addr, \n\t\t\t\t\t\t\t\t\tsizeof(struct in_addr), 0);\n\t\t\t\t\t\tif (mgmt == NULL) {\n\t\t\t\t\t\t\tif (errno == ENOMEM)\n\t\t\t\t\t\t\t\tlog_warn(\""cdp\"",\n\t\t\t\t\t\t\t\t    \""unable to allocate memory for management address\"");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tlog_warn(\""cdp\"",\n\t\t\t\t\t\t\t\t    \""too large management address received on %s\"",\n\t\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\t\t}\n\t\t\t\t/* Go to the end of the address */\n\t\t\t\tPEEK_RESTORE(pos_next_address);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CDP_TLV_PORT:\n\t\t\tif (tlv_len == 0) {\n\t\t\t\tlog_warn(\""cd[\"", \""too short port description received\"");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((port->p_descr = (char *)calloc(1, tlv_len + 1)) == NULL) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for port description\"");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(port->p_descr, tlv_len);\n\t\t\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\t\t\tif ((port->p_id =  (char *)calloc(1, tlv_len)) == NULL) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for port ID\"");\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tmemcpy(port->p_id, port->p_descr, tlv_len);\n\t\t\tport->p_id_len = tlv_len;\n\t\t\tbreak;\n\t\tcase CDP_TLV_CAPABILITIES:\n#ifdef ENABLE_FDP\n\t\t\tif (fdp) {\n\t\t\t\t/* Capabilities are string with FDP */\n\t\t\t\tif (!strncmp(\""Router\"", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_ROUTER;\n\t\t\t\telse if (!strncmp(\""Switch\"", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_BRIDGE;\n\t\t\t\telse if (!strncmp(\""Bridge\"", (char*)pos, tlv_len))\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_REPEATER;\n\t\t\t\telse\n\t\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tCHECK_TLV_SIZE(4, \""Capabilities\"");\n\t\t\tcaps = PEEK_UINT32;\n\t\t\tif (caps & CDP_CAP_ROUTER)\n\t\t\t\tchassis->c_cap_enabled |= LLDP_CAP_ROUTER;\n\t\t\tif (caps & 0x0e)\n\t\t\t\tchassis->c_cap_enabled |= LLDP_CAP_BRIDGE;\n\t\t\tif (chassis->c_cap_enabled == 0)\n\t\t\t\tchassis->c_cap_enabled = LLDP_CAP_STATION;\n\t\t\tchassis->c_cap_available = chassis->c_cap_enabled;\n\t\t\tbreak;\n\t\tcase CDP_TLV_SOFTWARE:\n\t\t\tsoftware_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(software);\n\t\t\tbreak;\n\t\tcase CDP_TLV_PLATFORM:\n\t\t\tplatform_len = tlv_len;\n\t\t\t(void)PEEK_SAVE(platform);\n\t\t\tbreak;\n#ifdef ENABLE_DOT1\n\t\tcase CDP_TLV_NATIVEVLAN:\n\t\t\tCHECK_TLV_SIZE(2, \""Native VLAN\"");\n\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\tsizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to alloc vlan \""\n\t\t\t\t\t  \""structure for \""\n\t\t\t\t\t  \""tlv received on %s\"",\n\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tvlan->v_vid = port->p_pvid = PEEK_UINT16;\n\t\t\tif (asprintf(&vlan->v_name, \""VLAN #%d\"", vlan->v_vid) == -1) {\n\t\t\t\tlog_warn(\""cdp\"", \""unable to alloc VLAN name for \""\n\t\t\t\t\t  \""TLV received on %s\"",\n\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\tfree(vlan);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t  vlan, v_entries);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tlog_debug(\""cdp\"", \""unknown CDP/FDP TLV type (%d) received on %s\"",\n\t\t\t    ntohs(tlv_type), hardware->h_ifname);\n\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_len - pos);\n\t}\n\tif (!software && platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    platform_len + 1)) == NULL) {\n\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for chassis description\"");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t} else if (software && !platform) {\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    software_len + 1)) == NULL) {\n\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for chassis description\"");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, software, software_len);\n\t} else if (software && platform) {\n#define CONCAT_PLATFORM \"" running on\\n\""\n\t\tif ((chassis->c_descr = (char *)calloc(1,\n\t\t\t    software_len + platform_len +\n\t\t\t    strlen(CONCAT_PLATFORM) + 1)) == NULL) {\n\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for chassis description\"");\n\t\t\tgoto malformed;\n\t\t}\n\t\tmemcpy(chassis->c_descr, platform, platform_len);\n\t\tmemcpy(chassis->c_descr + platform_len,\n\t\t    CONCAT_PLATFORM, strlen(CONCAT_PLATFORM));\n\t\tmemcpy(chassis->c_descr + platform_len + strlen(CONCAT_PLATFORM),\n\t\t    software, software_len);\n\t}\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (chassis->c_name == NULL) ||\n\t    (chassis->c_descr == NULL) ||\n\t    (port->p_descr == NULL) ||\n\t    (chassis->c_ttl == 0) ||\n\t    (chassis->c_cap_enabled == 0)) {\n\t\tlog_warnx(\""cdp\"", \""some mandatory CDP/FDP tlv are missing for frame received on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}""}, {""func_name"": ""sonmp_decode"", ""file_path"": ""src/daemon/protocols/sonmp.c"", ""func_code"": ""int\nsonmp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tconst u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tstruct lldpd_mgmt *mgmt;\n\tint length, i;\n\tu_int8_t *pos;\n\tu_int8_t seg[3], rchassis;\n\tstruct in_addr address;\n\n\tlog_debug(\""sonmp\"", \""decode SONMP PDU from %s\"",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\""sonmp\"", \""failed to allocate remote chassis\"");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\""sonmp\"", \""failed to allocate remote port\"");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\tif (length < SONMP_SIZE) {\n\t\tlog_warnx(\""sonmp\"", \""too short SONMP frame received on %s\"", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t/* There is two multicast address. We just handle only one of\n\t\t * them. */\n\t\tgoto malformed;\n\t/* We skip to LLC PID */\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);\n\tif (PEEK_UINT16 != LLC_PID_SONMP_HELLO) {\n\t\tlog_debug(\""sonmp\"", \""incorrect LLC protocol ID received for SONMP on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR;\n\tif ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) {\n\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for chassis id on %s\"",\n\t\t\thardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_id_len = sizeof(struct in_addr) + 1;\n\tchassis->c_id[0] = 1;\n\tPEEK_BYTES(&address, sizeof(struct in_addr));\n\tmemcpy(chassis->c_id + 1, &address, sizeof(struct in_addr));\n\tif (asprintf(&chassis->c_name, \""%s\"", inet_ntoa(address)) == -1) {\n\t\tlog_warnx(\""sonmp\"", \""unable to write chassis name for %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_BYTES(seg, sizeof(seg));\n\trchassis = PEEK_UINT8;\n\tfor (i=0; sonmp_chassis_types[i].type != 0; i++) {\n\t\tif (sonmp_chassis_types[i].type == rchassis)\n\t\t\tbreak;\n\t}\n\tif (asprintf(&chassis->c_descr, \""%s\"",\n\t\tsonmp_chassis_types[i].description) == -1) {\n\t\tlog_warnx(\""sonmp\"", \""unable to write chassis description for %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);\n\tif (mgmt == NULL) {\n\t\tif (errno == ENOMEM)\n\t\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for management address\"");\n\t\telse\n\t\t\tlog_warn(\""sonmp\"", \""too large management address received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\tchassis->c_ttl = cfg?(cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold):\n\t    LLDPD_TTL;\n\n\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL;\n\tif (asprintf(&port->p_id, \""%02x-%02x-%02x\"",\n\t\tseg[0], seg[1], seg[2]) == -1) {\n\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for port id on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tport->p_id_len = strlen(port->p_id);\n\n\t/* Port description depend on the number of segments */\n\tif ((seg[0] == 0) && (seg[1] == 0)) {\n\t\tif (asprintf(&port->p_descr, \""port %d\"",\n\t\t\tseg[2]) == -1) {\n\t\t\tlog_warnx(\""sonmp\"", \""unable to write port description for %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else if (seg[0] == 0) {\n\t\tif (asprintf(&port->p_descr, \""port %d/%d\"",\n\t\t\tseg[1], seg[2]) == -1) {\n\t\t\tlog_warnx(\""sonmp\"", \""unable to write port description for %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t} else {\n\t\tif (asprintf(&port->p_descr, \""port %x:%x:%x\"",\n\t\t\tseg[0], seg[1], seg[2]) == -1) {\n\t\t\tlog_warnx(\""sonmp\"", \""unable to write port description for %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\n\nmalformed:\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}""}, {""func_name"": ""lldp_decode"", ""file_path"": ""src/daemon/protocols/lldp.c"", ""func_code"": ""int\nlldp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tconst char lldpaddr[] = LLDP_MULTICAST_ADDR;\n\tconst char dot1[] = LLDP_TLV_ORG_DOT1;\n\tconst char dot3[] = LLDP_TLV_ORG_DOT3;\n\tconst char med[] = LLDP_TLV_ORG_MED;\n\tconst char dcbx[] = LLDP_TLV_ORG_DCBX;\n\tunsigned char orgid[3];\n\tint length, gotend = 0, ttl_received = 0;\n\tint tlv_size, tlv_type, tlv_subtype;\n\tu_int8_t *pos, *tlv;\n\tchar *b;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan = NULL;\n\tint vlan_len;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi = NULL;\n#endif\n\tstruct lldpd_mgmt *mgmt;\n\tint af;\n\tu_int8_t addr_str_length, addr_str_buffer[32];\n\tu_int8_t addr_family, addr_length, *addr_ptr, iface_subtype;\n\tu_int32_t iface_number, iface;\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom = NULL;\n#endif\n\n\tlog_debug(\""lldp\"", \""receive LLDP PDU on %s\"",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\""lldp\"", \""failed to allocate remote chassis\"");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\""lldp\"", \""failed to allocate remote port\"");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n\tTAILQ_INIT(&port->p_ppvids);\n\tTAILQ_INIT(&port->p_pids);\n#endif\n#ifdef ENABLE_CUSTOM\n\tTAILQ_INIT(&port->p_custom_list);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\""lldp\"", \""too short frame received on %s\"", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) {\n\t\tlog_info(\""lldp\"", \""frame not targeted at LLDP multicast address received on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Skip source address */\n\tif (PEEK_UINT16 != ETHERTYPE_LLDP) {\n\t\tlog_info(\""lldp\"", \""non LLDP frame received on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\twhile (length && (!gotend)) {\n\t\tif (length < 2) {\n\t\t\tlog_warnx(\""lldp\"", \""tlv header too short received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_size = PEEK_UINT16;\n\t\ttlv_type = tlv_size >> 9;\n\t\ttlv_size = tlv_size & 0x1ff;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif (length < tlv_size) {\n\t\t\tlog_warnx(\""lldp\"", \""frame too short for tlv received on %s\"",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase LLDP_TLV_END:\n\t\t\tif (tlv_size != 0) {\n\t\t\t\tlog_warnx(\""lldp\"", \""lldp end received with size not null on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif (length)\n\t\t\t\tlog_debug(\""lldp\"", \""extra data after lldp end on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_CHASSIS_ID:\n\t\tcase LLDP_TLV_PORT_ID:\n\t\t\tCHECK_TLV_SIZE(2, \""Port Id\"");\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif ((tlv_subtype == 0) || (tlv_subtype > 7)) {\n\t\t\t\tlog_warnx(\""lldp\"", \""unknown subtype for tlv id received on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size - 1)) == NULL) {\n\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate memory for id tlv \""\n\t\t\t\t    \""received on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size - 1);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_ID) {\n\t\t\t\tport->p_id_subtype = tlv_subtype;\n\t\t\t\tport->p_id = b;\n\t\t\t\tport->p_id_len = tlv_size - 1;\n\t\t\t} else {\n\t\t\t\tchassis->c_id_subtype = tlv_subtype;\n\t\t\t\tchassis->c_id = b;\n\t\t\t\tchassis->c_id_len = tlv_size - 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LLDP_TLV_TTL:\n\t\t\tCHECK_TLV_SIZE(2, \""TTL\"");\n\t\t\tchassis->c_ttl = PEEK_UINT16;\n\t\t\tttl_received = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_PORT_DESCR:\n\t\tcase LLDP_TLV_SYSTEM_NAME:\n\t\tcase LLDP_TLV_SYSTEM_DESCR:\n\t\t\tif (tlv_size < 1) {\n\t\t\t\tlog_debug(\""lldp\"", \""empty tlv received on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {\n\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate memory for string tlv \""\n\t\t\t\t    \""received on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_DESCR)\n\t\t\t\tport->p_descr = b;\n\t\t\telse if (tlv_type == LLDP_TLV_SYSTEM_NAME)\n\t\t\t\tchassis->c_name = b;\n\t\t\telse chassis->c_descr = b;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_SYSTEM_CAP:\n\t\t\tCHECK_TLV_SIZE(4, \""System capabilities\"");\n\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \""Management address\"");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {\n\t\t\t\tlog_warnx(\""lldp\"", \""too large management address on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \""Management address\"");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \""Management address\"");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tif (errno == ENOMEM)\n\t\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate memory \""\n\t\t\t\t\t    \""for management address\"");\n\t\t\t\telse\n\t\t\t\t\tlog_warn(\""lldp\"", \""too large management address \""\n\t\t\t\t\t    \""received on %s\"", hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(1 + (int)sizeof(orgid), \""Organisational\"");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot1 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT1_VLANNAME:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \""VLAN\"");\n\t\t\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to alloc vlan \""\n\t\t\t\t\t\t    \""structure for \""\n\t\t\t\t\t\t    \""tlv received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tvlan->v_vid = PEEK_UINT16;\n\t\t\t\t\tvlan_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(7 + vlan_len, \""VLAN\"");\n\t\t\t\t\tif ((vlan->v_name =\n\t\t\t\t\t\t(char *)calloc(1, vlan_len + 1)) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to alloc vlan name for \""\n\t\t\t\t\t\t    \""tlv received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(vlan->v_name, vlan_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t    vlan, v_entries);\n\t\t\t\t\tvlan = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PVID:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \""PVID\"");\n\t\t\t\t\tport->p_pvid = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PPVID:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \""PPVID\"");\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PPVID has to be unique if more than\n\t\t\t\t\t   one PPVID TLVs are received  - \n\t\t\t\t\t   discard if duplicate */\n\t\t\t\t\t/* if support bit is not set and \n\t\t\t\t\t   enabled bit is set - PPVID TLV is\n\t\t\t\t\t   considered error  and discarded */\n\t\t\t\t\t/* if PPVID > 4096 - bad and discard */\n\t\t\t\t\tif ((ppvid = (struct lldpd_ppvid *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_ppvid))) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to alloc ppvid \""\n\t\t\t\t\t\t    \""structure for \""\n\t\t\t\t\t\t    \""tlv received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tppvid->p_cap_status = PEEK_UINT8;\n\t\t\t\t\tppvid->p_ppvid = PEEK_UINT16;\t\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_ppvids,\n\t\t\t\t\t    ppvid, p_entries);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PI:\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PI has to be unique if more than \n\t\t\t\t\t   one PI TLVs are received  - discard\n\t\t\t\t\t   if duplicate ?? */\n\t\t\t\t\tCHECK_TLV_SIZE(5, \""PI\"");\n\t\t\t\t\tif ((pi = (struct lldpd_pi *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_pi))) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to alloc PI \""\n\t\t\t\t\t\t    \""structure for \""\n\t\t\t\t\t\t    \""tlv received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tpi->p_pi_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(5 + pi->p_pi_len, \""PI\"");\n\t\t\t\t\tif ((pi->p_pi =\n\t\t\t\t\t\t(char *)calloc(1, pi->p_pi_len)) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to alloc pid name for \""\n\t\t\t\t\t\t    \""tlv received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(pi->p_pi, pi->p_pi_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_pids,\n\t\t\t\t\t    pi, p_entries);\n\t\t\t\t\tpi = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot1 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT3\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot3 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT3_MAC:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \""MAC/PHY\"");\n\t\t\t\t\tport->p_macphy.autoneg_support = PEEK_UINT8;\n\t\t\t\t\tport->p_macphy.autoneg_enabled =\n\t\t\t\t\t    (port->p_macphy.autoneg_support & 0x2) >> 1;\n\t\t\t\t\tport->p_macphy.autoneg_support =\n\t\t\t\t\t    port->p_macphy.autoneg_support & 0x1;\n\t\t\t\t\tport->p_macphy.autoneg_advertised =\n\t\t\t\t\t    PEEK_UINT16;\n\t\t\t\t\tport->p_macphy.mau_type = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_LA:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \""Link aggregation\"");\n\t\t\t\t\tPEEK_DISCARD_UINT8;\n\t\t\t\t\tport->p_aggregid = PEEK_UINT32;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_MFS:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \""MFS\"");\n\t\t\t\t\tport->p_mfs = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_POWER:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \""Power\"");\n\t\t\t\t\tport->p_power.devicetype = PEEK_UINT8;\n\t\t\t\t\tport->p_power.supported =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x2) >> 1;\n\t\t\t\t\tport->p_power.enabled =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x4) >> 2;\n\t\t\t\t\tport->p_power.paircontrol =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x8) >> 3;\n\t\t\t\t\tport->p_power.devicetype =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x1)?\n\t\t\t\t\t\tLLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD;\n\t\t\t\t\tport->p_power.pairs = PEEK_UINT8;\n\t\t\t\t\tport->p_power.class = PEEK_UINT8;\n\t\t\t\t\t/* 802.3at? */\n\t\t\t\t\tif (tlv_size >= 12) {\n\t\t\t\t\t\tport->p_power.powertype = PEEK_UINT8;\n\t\t\t\t\t\tport->p_power.source =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<5 | 1<<4)) >> 4;\n\t\t\t\t\t\tport->p_power.priority =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<1 | 1<<0));\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<7))?\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE1:\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE2;\n\t\t\t\t\t\tport->p_power.requested = PEEK_UINT16;\n\t\t\t\t\t\tport->p_power.allocated = PEEK_UINT16;\n\t\t\t\t\t} else\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_OFF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot3 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(med, orgid, sizeof(orgid)) == 0) {\n\t\t\t\t/* LLDP-MED */\n#ifndef ENABLE_LLDPMED\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\tu_int32_t policy;\n\t\t\t\tunsigned loctype;\n\t\t\t\tunsigned power;\n\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_MED_CAP:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \""LLDP-MED capabilities\"");\n\t\t\t\t\tchassis->c_med_cap_available = PEEK_UINT16;\n\t\t\t\t\tchassis->c_med_type = PEEK_UINT8;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_CAP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_POLICY:\n\t\t\t\t\tCHECK_TLV_SIZE(8, \""LLDP-MED policy\"");\n\t\t\t\t\tpolicy = PEEK_UINT32;\n\t\t\t\t\tif (((policy >> 24) < 1) ||\n\t\t\t\t\t    ((policy >> 24) > LLDP_MED_APPTYPE_LAST)) {\n\t\t\t\t\t\tlog_info(\""lldp\"", \""unknown policy field %d \""\n\t\t\t\t\t\t    \""received on %s\"",\n\t\t\t\t\t\t    policy,\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].type =\n\t\t\t\t\t    (policy >> 24);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].unknown =\n\t\t\t\t\t    ((policy & 0x800000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].tagged =\n\t\t\t\t\t    ((policy & 0x400000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].vid =\n\t\t\t\t\t    (policy & 0x001FFE00) >> 9;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].priority =\n\t\t\t\t\t    (policy & 0x1C0) >> 6;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].dscp =\n\t\t\t\t\t    policy & 0x3F;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_POLICY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_LOCATION:\n\t\t\t\t\tCHECK_TLV_SIZE(5, \""LLDP-MED Location\"");\n\t\t\t\t\tloctype = PEEK_UINT8;\n\t\t\t\t\tif ((loctype < 1) ||\n\t\t\t\t\t    (loctype > LLDP_MED_LOCFORMAT_LAST)) {\n\t\t\t\t\t\tlog_info(\""lldp\"", \""unknown location type \""\n\t\t\t\t\t\t    \""received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((port->p_med_location[loctype - 1].data =\n\t\t\t\t\t\t(char*)malloc(tlv_size - 5)) == NULL) {\n\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate memory \""\n\t\t\t\t\t\t    \""for LLDP-MED location for \""\n\t\t\t\t\t\t    \""frame received on %s\"",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(port->p_med_location[loctype - 1].data,\n\t\t\t\t\t    tlv_size - 5);\n\t\t\t\t\tport->p_med_location[loctype - 1].data_len =\n\t\t\t\t\t    tlv_size - 5;\n\t\t\t\t\tport->p_med_location[loctype - 1].format = loctype;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_LOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_MDI:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \""LLDP-MED PoE-MDI\"");\n\t\t\t\t\tpower = PEEK_UINT8;\n\t\t\t\t\tswitch (power & 0xC0) {\n\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PSE;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PRIMARY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BACKUP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_RESERVED;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PD;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_LOCAL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BOTH;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tport->p_med_power.devicetype =\n\t\t\t\t\t\t    LLDP_MED_POW_TYPE_RESERVED;\n\t\t\t\t\t}\n\t\t\t\t\tif ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW)\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    LLDP_MED_POW_PRIO_UNKNOWN;\n\t\t\t\t\telse\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    power & 0x0F;\n\t\t\t\t\tport->p_med_power.val = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\tif (tlv_size <= 4)\n\t\t\t\t\t\tb = NULL;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ((b = (char*)malloc(tlv_size - 3)) ==\n\t\t\t\t\t\t    NULL) {\n\t\t\t\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate \""\n\t\t\t\t\t\t\t    \""memory for LLDP-MED \""\n\t\t\t\t\t\t\t    \""inventory for frame \""\n\t\t\t\t\t\t\t    \""received on %s\"",\n\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPEEK_BYTES(b, tlv_size - 4);\n\t\t\t\t\t\tb[tlv_size - 4] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\t\t\tchassis->c_med_hw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\t\t\tchassis->c_med_fw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\t\t\tchassis->c_med_sw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\t\t\tchassis->c_med_sn = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\t\t\tchassis->c_med_manuf = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\t\t\tchassis->c_med_model = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\t\tchassis->c_med_asset = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_IV;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown LLDP MED, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif /* ENABLE_LLDPMED */\n\t\t\t} else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) {\n\t\t\t\tlog_debug(\""lldp\"", \""unsupported DCBX tlv received on %s - ignore\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t} else {\n\t\t\t\tlog_debug(\""lldp\"", \""unknown org tlv [%02x:%02x:%02x] received on %s\"",\n\t\t\t\t    orgid[0], orgid[1], orgid[2],\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#ifdef ENABLE_CUSTOM\n\t\t\t\tcustom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom));\n\t\t\t\tif (!custom) {\n\t\t\t\t\tlog_warn(\""lldp\"",\n\t\t\t\t\t    \""unable to allocate memory for custom TLV\"");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tcustom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0;\n\t\t\t\tmemcpy(custom->oui, orgid, sizeof(custom->oui));\n\t\t\t\tcustom->subtype = tlv_subtype;\n\t\t\t\tif (custom->oui_info_len > 0) {\n\t\t\t\t\tcustom->oui_info = malloc(custom->oui_info_len);\n\t\t\t\t\tif (!custom->oui_info) {\n\t\t\t\t\t\tlog_warn(\""lldp\"",\n\t\t\t\t\t\t    \""unable to allocate memory for custom TLV data\"");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(custom->oui_info, custom->oui_info_len);\n\t\t\t\t}\n\t\t\t\tTAILQ_INSERT_TAIL(&port->p_custom_list, custom, next);\n\t\t\t\tcustom = NULL;\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_warnx(\""lldp\"", \""unknown tlv (%d) received on %s\"",\n\t\t\t    tlv_type, hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tif (pos > tlv + tlv_size) {\n\t\t\tlog_warnx(\""lldp\"", \""BUG: already past TLV!\"");\n\t\t\tgoto malformed;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_size - pos);\n\t}\n\n\t/* Some random check */\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (!ttl_received) ||\n\t    (gotend == 0)) {\n\t\tlog_warnx(\""lldp\"", \""some mandatory tlv are missing for frame received on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\nmalformed:\n#ifdef ENABLE_CUSTOM\n\tfree(custom);\n#endif\n#ifdef ENABLE_DOT1\n\tfree(vlan);\n\tfree(pi);\n#endif\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}""}, {""func_name"": ""_lldp_send"", ""file_path"": ""src/daemon/protocols/lldp.c"", ""func_code"": ""static int _lldp_send(struct lldpd *global,\n    struct lldpd_hardware *hardware,\n    u_int8_t c_id_subtype,\n    char *c_id,\n    int c_id_len,\n    u_int8_t p_id_subtype,\n    char *p_id,\n    int p_id_len,\n    int shutdown)\n{\n\tstruct lldpd_port *port;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_frame *frame;\n\tint length;\n\tu_int8_t *packet, *pos, *tlv;\n\tstruct lldpd_mgmt *mgmt;\n\tint proto;\n\n\tu_int8_t mcastaddr[] = LLDP_MULTICAST_ADDR;\n#ifdef ENABLE_DOT1\n\tconst u_int8_t dot1[] = LLDP_TLV_ORG_DOT1;\n\tstruct lldpd_vlan *vlan;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi;\n#endif\n#ifdef ENABLE_DOT3\n\tconst u_int8_t dot3[] = LLDP_TLV_ORG_DOT3;\n#endif\n#ifdef ENABLE_LLDPMED\n\tint i;\n\tconst u_int8_t med[] = LLDP_TLV_ORG_MED;\n#endif\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom;\n#endif\n\tport = &hardware->h_lport;\n\tchassis = port->p_chassis;\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\treturn ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(\n\t      /* LLDP multicast address */\n\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t      /* Source MAC address */\n\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t      /* LLDP frame */\n\t      POKE_UINT16(ETHERTYPE_LLDP)))\n\t\tgoto toobig;\n\n\t/* Chassis ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_CHASSIS_ID) &&\n\t      POKE_UINT8(c_id_subtype) &&\n\t      POKE_BYTES(c_id, c_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Port ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_PORT_ID) &&\n\t      POKE_UINT8(p_id_subtype) &&\n\t      POKE_BYTES(p_id, p_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Time to live */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_TTL) &&\n\t      POKE_UINT16(shutdown?0:chassis->c_ttl) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (shutdown)\n\t\tgoto end;\n\n\t/* System name */\n\tif (chassis->c_name && *chassis->c_name != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_NAME) &&\n\t\t\t    POKE_BYTES(chassis->c_name, strlen(chassis->c_name)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System description (skip it if empty) */\n\tif (chassis->c_descr && *chassis->c_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_DESCR) &&\n\t\t\t    POKE_BYTES(chassis->c_descr, strlen(chassis->c_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System capabilities */\n\tif (global->g_config.c_cap_advertise && chassis->c_cap_available) {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_CAP) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_available) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_enabled) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Management addresses */\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tproto = lldpd_af_to_lldp_proto(mgmt->m_family);\n\t\tif (proto == LLDP_MGMT_ADDR_NONE) continue;\n\t\tif (!(\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_MGMT_ADDR) &&\n\t\t\t  /* Size of the address, including its type */\n\t\t\t  POKE_UINT8(mgmt->m_addrsize + 1) &&\n\t\t\t  POKE_UINT8(proto) &&\n\t\t\t  POKE_BYTES(&mgmt->m_addr, mgmt->m_addrsize)))\n\t\t\tgoto toobig;\n\n\t\t/* Interface port type, OID */\n\t\tif (mgmt->m_iface == 0) {\n\t\t\tif (!(\n\t\t\t\t  /* We don't know the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_UNKNOWN) &&\n\t\t\t\t  POKE_UINT32(0)))\n\t\t\t\tgoto toobig;\n\t\t} else {\n\t\t\tif (!(\n\t\t\t\t  /* We have the index of the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_IFINDEX) &&\n\t\t\t\t  POKE_UINT32(mgmt->m_iface)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(\n\t\t\t  /* We don't provide an OID for management */\n\t\t\t  POKE_UINT8(0) &&\n\t\t\t  POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Port description */\n\tif (port->p_descr && *port->p_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_PORT_DESCR) &&\n\t\t\t    POKE_BYTES(port->p_descr, strlen(port->p_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n#ifdef ENABLE_DOT1\n\t/* Port VLAN ID */\n\tif(port->p_pvid != 0) {\n\t\tif (!(\n\t\t    POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t    POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t    POKE_UINT8(LLDP_TLV_DOT1_PVID) &&\n\t\t    POKE_UINT16(port->p_pvid) &&\n\t\t    POKE_END_LLDP_TLV)) {\n\t\t    goto toobig;\n\t\t}\n\t}\n\t/* Port and Protocol VLAN IDs */\n\tTAILQ_FOREACH(ppvid, &port->p_ppvids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PPVID) &&\n\t\t      POKE_UINT8(ppvid->p_cap_status) &&\n\t\t      POKE_UINT16(ppvid->p_ppvid) &&\n\t\t      POKE_END_LLDP_TLV)) {\n\t\t\tgoto toobig;\n\t\t}\n\t}\n\t/* VLANs */\n\tTAILQ_FOREACH(vlan, &port->p_vlans, v_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_VLANNAME) &&\n\t\t      POKE_UINT16(vlan->v_vid) &&\n\t\t      POKE_UINT8(strlen(vlan->v_name)) &&\n\t\t      POKE_BYTES(vlan->v_name, strlen(vlan->v_name)) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Protocol Identities */\n\tTAILQ_FOREACH(pi, &port->p_pids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PI) &&\n\t\t      POKE_UINT8(pi->p_pi_len) &&\n\t\t      POKE_BYTES(pi->p_pi, pi->p_pi_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_DOT3\n\t/* Aggregation status */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_LA) &&\n\t      /* Bit 0 = capability ; Bit 1 = status */\n\t      POKE_UINT8((port->p_aggregid) ? 3:1) &&\n\t      POKE_UINT32(port->p_aggregid) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MAC/PHY */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_MAC) &&\n\t      POKE_UINT8(port->p_macphy.autoneg_support |\n\t\t\t (port->p_macphy.autoneg_enabled << 1)) &&\n\t      POKE_UINT16(port->p_macphy.autoneg_advertised) &&\n\t      POKE_UINT16(port->p_macphy.mau_type) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MFS */\n\tif (port->p_mfs) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_MFS) &&\n\t\t      POKE_UINT16(port->p_mfs) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Power */\n\tif (port->p_power.devicetype) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_POWER) &&\n\t\t      POKE_UINT8((\n\t\t\t\t  (((2 - port->p_power.devicetype)    %(1<< 1))<<0) |\n\t\t\t\t  (( port->p_power.supported          %(1<< 1))<<1) |\n\t\t\t\t  (( port->p_power.enabled            %(1<< 1))<<2) |\n\t\t\t\t  (( port->p_power.paircontrol        %(1<< 1))<<3))) &&\n\t\t      POKE_UINT8(port->p_power.pairs) &&\n\t\t      POKE_UINT8(port->p_power.class)))\n\t\t\tgoto toobig;\n\t\t/* 802.3at */\n\t\tif (port->p_power.powertype != LLDP_DOT3_POWER_8023AT_OFF) {\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t\t  (((port->p_power.powertype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_8023AT_TYPE1)?1:0) << 7) |\n\t\t\t\t\t   (((port->p_power.devicetype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_PSE)?0:1) << 6) |\n\t\t\t\t\t   ((port->p_power.source   %(1<< 2))<<4) |\n\t\t\t\t\t   ((port->p_power.priority %(1<< 2))<<0))) &&\n\t\t\t      POKE_UINT16(port->p_power.requested) &&\n\t\t\t      POKE_UINT16(port->p_power.allocated)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_LLDPMED\n\tif (port->p_med_cap_enabled) {\n\t\t/* LLDP-MED cap */\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t      POKE_UINT8(LLDP_TLV_MED_CAP) &&\n\t\t      POKE_UINT16(chassis->c_med_cap_available) &&\n\t\t      POKE_UINT8(chassis->c_med_type) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\n\t\t/* LLDP-MED inventory */\n#define LLDP_INVENTORY(value, subtype)\t\t\t\t\t\\\n\t\tif (value) {\t\t\t\t\t\t\\\n\t\t    if (!(\t\t\t\t\t\t\\\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\t\t\\\n\t\t\t  POKE_BYTES(med, sizeof(med)) &&\t\t\\\n\t\t\t  POKE_UINT8(subtype) &&\t\t\t\\\n\t\t\t  POKE_BYTES(value,\t\t\t\t\\\n\t\t\t\t(strlen(value)>32)?32:strlen(value)) &&\t\\\n\t\t\t  POKE_END_LLDP_TLV))\t\t\t\t\\\n\t\t\t    goto toobig;\t\t\t\t\\\n\t\t}\n\n\t\tif (port->p_med_cap_enabled & LLDP_MED_CAP_IV) {\n\t\t\tLLDP_INVENTORY(chassis->c_med_hw,\n\t\t\t    LLDP_TLV_MED_IV_HW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_fw,\n\t\t\t    LLDP_TLV_MED_IV_FW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sw,\n\t\t\t    LLDP_TLV_MED_IV_SW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sn,\n\t\t\t    LLDP_TLV_MED_IV_SN);\n\t\t\tLLDP_INVENTORY(chassis->c_med_manuf,\n\t\t\t    LLDP_TLV_MED_IV_MANUF);\n\t\t\tLLDP_INVENTORY(chassis->c_med_model,\n\t\t\t    LLDP_TLV_MED_IV_MODEL);\n\t\t\tLLDP_INVENTORY(chassis->c_med_asset,\n\t\t\t    LLDP_TLV_MED_IV_ASSET);\n\t\t}\n\n\t\t/* LLDP-MED location */\n\t\tfor (i = 0; i < LLDP_MED_LOCFORMAT_LAST; i++) {\n\t\t\tif (port->p_med_location[i].format == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_LOCATION) &&\n\t\t\t\t      POKE_UINT8(port->p_med_location[i].format) &&\n\t\t\t\t      POKE_BYTES(port->p_med_location[i].data,\n\t\t\t\t\t  port->p_med_location[i].data_len) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED network policy */\n\t\tfor (i = 0; i < LLDP_MED_APPTYPE_LAST; i++) {\n\t\t\tif (port->p_med_policy[i].type == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_POLICY) &&\n\t\t\t\t      POKE_UINT32((\n\t\t\t\t\t((port->p_med_policy[i].type     %(1<< 8))<<24) |\n\t\t\t\t\t((port->p_med_policy[i].unknown  %(1<< 1))<<23) |\n\t\t\t\t\t((port->p_med_policy[i].tagged   %(1<< 1))<<22) |\n\t\t\t\t      /*((0                              %(1<< 1))<<21) |*/\n\t\t\t\t\t((port->p_med_policy[i].vid      %(1<<12))<< 9) |\n\t\t\t\t\t((port->p_med_policy[i].priority %(1<< 3))<< 6) |\n\t\t\t\t\t((port->p_med_policy[i].dscp     %(1<< 6))<< 0) )) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED POE-MDI */\n\t\tif ((port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PSE) ||\n\t\t    (port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PD)) {\n\t\t\tint devicetype = 0, source = 0;\n\t\t\tif (!(\n\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t      POKE_UINT8(LLDP_TLV_MED_MDI)))\n\t\t\t\tgoto toobig;\n\t\t\tswitch (port->p_med_power.devicetype) {\n\t\t\tcase LLDP_MED_POW_TYPE_PSE:\n\t\t\t\tdevicetype = 0;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PRIMARY: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BACKUP: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_RESERVED: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LLDP_MED_POW_TYPE_PD:\n\t\t\t\tdevicetype = 1;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PSE: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_LOCAL: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BOTH: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t((devicetype                   %(1<< 2))<<6) |\n\t\t\t\t((source                       %(1<< 2))<<4) |\n\t\t\t\t((port->p_med_power.priority   %(1<< 4))<<0) )) &&\n\t\t\t      POKE_UINT16(port->p_med_power.val) &&\n\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\tgoto toobig;\n\t\t}\n\t}\n#endif\n\n#ifdef ENABLE_CUSTOM\n\tTAILQ_FOREACH(custom, &port->p_custom_list, next) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(custom->oui, sizeof(custom->oui)) &&\n\t\t      POKE_UINT8(custom->subtype) &&\n\t\t      POKE_BYTES(custom->oui_info, custom->oui_info_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\nend:\n\t/* END */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_END) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, pos - packet) == -1) {\n\t\tlog_warn(\""lldp\"", \""unable to send packet on real device for %s\"",\n\t\t    hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\thardware->h_tx_cnt++;\n\n\t/* We assume that LLDP frame is the reference */\n\tif (!shutdown && (frame = (struct lldpd_frame*)malloc(\n\t\t\tsizeof(int) + pos - packet)) != NULL) {\n\t\tframe->size = pos - packet;\n\t\tmemcpy(&frame->frame, packet, frame->size);\n\t\tif ((hardware->h_lport.p_lastframe == NULL) ||\n\t\t    (hardware->h_lport.p_lastframe->size != frame->size) ||\n\t\t    (memcmp(hardware->h_lport.p_lastframe->frame, frame->frame,\n\t\t\tframe->size) != 0)) {\n\t\t\tfree(hardware->h_lport.p_lastframe);\n\t\t\thardware->h_lport.p_lastframe = frame;\n\t\t\thardware->h_lport.p_lastchange = time(NULL);\n\t\t} else free(frame);\n\t}\n\n\tfree(packet);\n\treturn 0;\n\ntoobig:\n\tfree(packet);\n\treturn E2BIG;\n}""}, {""func_name"": ""lldpd_alloc_mgmt"", ""file_path"": ""src/daemon/lldpd.c"", ""func_code"": ""struct lldpd_mgmt *\nlldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\n\tlog_debug(\""alloc\"", \""allocate a new management address (family: %d)\"", family);\n\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}""}]","{""function"": 1, ""code"": 5, ""value"": 1}","[{""source"": ""func_info(file:lldpd.c, func:lldpd_alloc_mgmt)"", ""result"": [{""code"": ""struct lldpd_mgmt *\nlldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\n\tlog_debug(\""alloc\"", \""allocate a new management address (family: %d)\"", family);\n\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tassert(addrsize <= LLDPD_MGMT_MAXADDRSIZE);\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}"", ""start_line"": 180, ""end_line"": 206, ""full_name"": ""lldpd_alloc_mgmt"", ""file_path"": ""src/daemon/lldpd.c""}]}, {""source"": ""code_info(file:cdp.c, lines:400-450)"", ""result"": ""\t\tcase CDP_TLV_ADDRESSES:\n\t\t\tCHECK_TLV_SIZE(4, \""Address\"");\n\t\t\taddresses_len = tlv_len - 4;\n\t\t\tfor (nb = PEEK_UINT32; nb > 0; nb--) {\n\t\t\t\t(void)PEEK_SAVE(pos_address);\n\t\t\t\t/* We first try to get the real length of the packet */\n\t\t\t\tif (addresses_len < 2) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD_UINT8; addresses_len--;\n\t\t\t\taddress_len = PEEK_UINT8; addresses_len--;\n\t\t\t\tif (addresses_len < address_len + 2) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\taddresses_len -= address_len;\n\t\t\t\taddress_len = PEEK_UINT16; addresses_len -= 2;\n\t\t\t\tif (addresses_len < address_len) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\t(void)PEEK_SAVE(pos_next_address);\n\t\t\t\t/* Next, we go back and try to extract\n\t\t\t\t   IPv4 address */\n\t\t\t\tPEEK_RESTORE(pos_address);\n\t\t\t\tif ((PEEK_UINT8 == 1) && (PEEK_UINT8 == 1) &&\n\t\t\t\t    (PEEK_UINT8 == CDP_ADDRESS_PROTO_IP) &&\n\t\t\t\t    (PEEK_UINT16 == sizeof(struct in_addr))) {\n\t\t\t\t\t\tPEEK_BYTES(&addr, sizeof(struct in_addr));\n\t\t\t\t\t\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &addr, \n\t\t\t\t\t\t\t\t\tsizeof(struct in_addr), 0);\n\t\t\t\t\t\tif (mgmt == NULL) {\n\t\t\t\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\t\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for management address\"");\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\t\t}\n\t\t\t\t/* Go to the end of the address */\n\t\t\t\tPEEK_RESTORE(pos_next_address);\n\t\t\t}\n\t\t\tbreak;\n""}, {""source"": ""code_info(file:sonmp.c, lines:330-380)"", ""result"": ""\t}\n\n\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR;\n\tif ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) {\n\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for chassis id on %s\"",\n\t\t\thardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_id_len = sizeof(struct in_addr) + 1;\n\tchassis->c_id[0] = 1;\n\tPEEK_BYTES(&address, sizeof(struct in_addr));\n\tmemcpy(chassis->c_id + 1, &address, sizeof(struct in_addr));\n\tif (asprintf(&chassis->c_name, \""%s\"", inet_ntoa(address)) == -1) {\n\t\tlog_warnx(\""sonmp\"", \""unable to write chassis name for %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_BYTES(seg, sizeof(seg));\n\trchassis = PEEK_UINT8;\n\tfor (i=0; sonmp_chassis_types[i].type != 0; i++) {\n\t\tif (sonmp_chassis_types[i].type == rchassis)\n\t\t\tbreak;\n\t}\n\tif (asprintf(&chassis->c_descr, \""%s\"",\n\t\tsonmp_chassis_types[i].description) == -1) {\n\t\tlog_warnx(\""sonmp\"", \""unable to write chassis description for %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);\n\tif (mgmt == NULL) {\n\t\tassert(errno == ENOMEM);\n\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for management address\"");\n\t\tgoto malformed;\n\t}\n\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\tchassis->c_ttl = cfg?(cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold):\n\t    LLDPD_TTL;\n\n\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL;\n\tif (asprintf(&port->p_id, \""%02x-%02x-%02x\"",\n\t\tseg[0], seg[1], seg[2]) == -1) {\n\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for port id on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tport->p_id_len = strlen(port->p_id);\n\n\t/* Port description depend on the number of segments */\n\tif ((seg[0] == 0) && (seg[1] == 0)) {\n\t\tif (asprintf(&port->p_descr, \""port %d\"",\n""}, {""source"": ""value_info(file:lldpd.c, value:addrsize)"", ""result"": {""value_trace"": [{""full_code"": ""mgmt->m_addrsize = addrsize"", ""line"": 203, ""func_name"": ""lldpd_alloc_mgmt""}], ""struct_var"": ""addrsize"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:cdp.c, lines:400-450)"", ""result"": ""\t\tcase CDP_TLV_ADDRESSES:\n\t\t\tCHECK_TLV_SIZE(4, \""Address\"");\n\t\t\taddresses_len = tlv_len - 4;\n\t\t\tfor (nb = PEEK_UINT32; nb > 0; nb--) {\n\t\t\t\t(void)PEEK_SAVE(pos_address);\n\t\t\t\t/* We first try to get the real length of the packet */\n\t\t\t\tif (addresses_len < 2) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD_UINT8; addresses_len--;\n\t\t\t\taddress_len = PEEK_UINT8; addresses_len--;\n\t\t\t\tif (addresses_len < address_len + 2) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\taddresses_len -= address_len;\n\t\t\t\taddress_len = PEEK_UINT16; addresses_len -= 2;\n\t\t\t\tif (addresses_len < address_len) {\n\t\t\t\t\tlog_warn(\""cdp\"", \""too short address subframe \""\n\t\t\t\t\t\t  \""received on %s\"",\n\t\t\t\t\t\t  hardware->h_ifname);\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tPEEK_DISCARD(address_len);\n\t\t\t\t(void)PEEK_SAVE(pos_next_address);\n\t\t\t\t/* Next, we go back and try to extract\n\t\t\t\t   IPv4 address */\n\t\t\t\tPEEK_RESTORE(pos_address);\n\t\t\t\tif ((PEEK_UINT8 == 1) && (PEEK_UINT8 == 1) &&\n\t\t\t\t    (PEEK_UINT8 == CDP_ADDRESS_PROTO_IP) &&\n\t\t\t\t    (PEEK_UINT16 == sizeof(struct in_addr))) {\n\t\t\t\t\t\tPEEK_BYTES(&addr, sizeof(struct in_addr));\n\t\t\t\t\t\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &addr, \n\t\t\t\t\t\t\t\t\tsizeof(struct in_addr), 0);\n\t\t\t\t\t\tif (mgmt == NULL) {\n\t\t\t\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\t\t\t\tlog_warn(\""cdp\"", \""unable to allocate memory for management address\"");\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\t\t}\n\t\t\t\t/* Go to the end of the address */\n\t\t\t\tPEEK_RESTORE(pos_next_address);\n\t\t\t}\n\t\t\tbreak;\n""}, {""source"": ""code_info(file:sonmp.c, lines:330-380)"", ""result"": ""\t}\n\n\tchassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR;\n\tif ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) {\n\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for chassis id on %s\"",\n\t\t\thardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tchassis->c_id_len = sizeof(struct in_addr) + 1;\n\tchassis->c_id[0] = 1;\n\tPEEK_BYTES(&address, sizeof(struct in_addr));\n\tmemcpy(chassis->c_id + 1, &address, sizeof(struct in_addr));\n\tif (asprintf(&chassis->c_name, \""%s\"", inet_ntoa(address)) == -1) {\n\t\tlog_warnx(\""sonmp\"", \""unable to write chassis name for %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_BYTES(seg, sizeof(seg));\n\trchassis = PEEK_UINT8;\n\tfor (i=0; sonmp_chassis_types[i].type != 0; i++) {\n\t\tif (sonmp_chassis_types[i].type == rchassis)\n\t\t\tbreak;\n\t}\n\tif (asprintf(&chassis->c_descr, \""%s\"",\n\t\tsonmp_chassis_types[i].description) == -1) {\n\t\tlog_warnx(\""sonmp\"", \""unable to write chassis description for %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0);\n\tif (mgmt == NULL) {\n\t\tassert(errno == ENOMEM);\n\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for management address\"");\n\t\tgoto malformed;\n\t}\n\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\tchassis->c_ttl = cfg?(cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold):\n\t    LLDPD_TTL;\n\n\tport->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL;\n\tif (asprintf(&port->p_id, \""%02x-%02x-%02x\"",\n\t\tseg[0], seg[1], seg[2]) == -1) {\n\t\tlog_warn(\""sonmp\"", \""unable to allocate memory for port id on %s\"",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tport->p_id_len = strlen(port->p_id);\n\n\t/* Port description depend on the number of segments */\n\tif ((seg[0] == 0) && (seg[1] == 0)) {\n\t\tif (asprintf(&port->p_descr, \""port %d\"",\n""}, {""source"": ""code_info(file:lldp.c, lines:700-770)"", ""result"": ""\t\tcase LLDP_TLV_PORT_DESCR:\n\t\tcase LLDP_TLV_SYSTEM_NAME:\n\t\tcase LLDP_TLV_SYSTEM_DESCR:\n\t\t\tif (tlv_size < 1) {\n\t\t\t\tlog_debug(\""lldp\"", \""empty tlv received on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {\n\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate memory for string tlv \""\n\t\t\t\t    \""received on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_DESCR)\n\t\t\t\tport->p_descr = b;\n\t\t\telse if (tlv_type == LLDP_TLV_SYSTEM_NAME)\n\t\t\t\tchassis->c_name = b;\n\t\t\telse chassis->c_descr = b;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_SYSTEM_CAP:\n\t\t\tCHECK_TLV_SIZE(4, \""System capabilities\"");\n\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \""Management address\"");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {\n\t\t\t\tlog_warnx(\""lldp\"", \""too large management address on %s\"",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \""Management address\"");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \""Management address\"");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\tlog_warn(\""lldp\"", \""unable to allocate memory \""\n\t\t\t\t\t\t\t\""for management address\"");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(1 + (int)sizeof(orgid), \""Organisational\"");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot1 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT1_VLANNAME:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \""VLAN\"");\n""}]","Root cause: assert(errno == ENOMEM) in lldp_decode (src/daemon/protocols/lldp.c:750-757) crashes when lldpd_alloc_mgmt() returns NULL with EOVERFLOW (triggered by addrsize > LLDPD_MGMT_MAXADDRSIZE). Trigger chain: Malformed LLDP packet  addr_str_length (from packet)  addr_length = addr_str_length - 1  lldpd_alloc_mgmt() checks addrsize > LLDPD_MGMT_MAXADDRSIZE  sets errno=EOVERFLOW  assert fails  crash. Evidence: lldp_decode (src/daemon/protocols/lldp.c:700-770) parses addr_str_length from packet, computes addr_length without validation, and passes to lldpd_alloc_mgmt().",0.95,./github/other_context/CVE-2015-8012
31,CVE-2017-11188,CWE-834,c_cpp,"The ReadDPXImage function in coders\dpx.c in ImageMagick 7.0.6-0 has a large loop vulnerability that can cause CPU exhaustion via a crafted DPX file, related to lack of an EOF check.",https://github.com/ImageMagick/ImageMagick/commit/42ceb8ee940a4c0bddeaf22e5a9c20cea2e85a8f,https://github.com/ImageMagick/ImageMagick/issues/509,1,"[{""func_name"": ""ReadDPXImage"", ""file_path"": ""coders/dpx.c"", ""func_code"": ""static Image *ReadDPXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[4],\n    value[MaxTextExtent];\n\n  DPXInfo\n    dpx;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent,\n    samples_per_pixel;\n\n  ssize_t\n    count,\n    n,\n    row,\n    y;\n\n  unsigned char\n    component_type;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read DPX file header.\n  */\n  offset=0;\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  offset+=count;\n  if ((count != 4) || ((LocaleNCompare(magick,\""SDPX\"",4) != 0) &&\n      (LocaleNCompare((char *) magick,\""XPDS\"",4) != 0)))\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  image->endian=LSBEndian;\n  if (LocaleNCompare(magick,\""SDPX\"",4) == 0)\n    image->endian=MSBEndian;\n  (void) ResetMagickMemory(&dpx,0,sizeof(dpx));\n  dpx.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.version),(unsigned char *)\n    dpx.file.version);\n  (void) FormatImageProperty(image,\""dpx:file.version\"",\""%.8s\"",dpx.file.version);\n  dpx.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.ditto_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.ditto_key != ~0U)\n    (void) FormatImageProperty(image,\""dpx:file.ditto.key\"",\""%u\"",\n      dpx.file.ditto_key);\n  dpx.file.generic_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.industry_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.user_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.filename),(unsigned char *)\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\""dpx:file.filename\"",\""%.100s\"",\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\""document\"",\""%.100s\"",dpx.file.filename);\n  offset+=ReadBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)\n    dpx.file.timestamp);\n  if (*dpx.file.timestamp != '\\0')\n    (void) FormatImageProperty(image,\""dpx:file.timestamp\"",\""%.24s\"",\n      dpx.file.timestamp);\n  offset+=ReadBlob(image,sizeof(dpx.file.creator),(unsigned char *)\n    dpx.file.creator);\n  if (*dpx.file.creator == '\\0')\n    {\n      char\n        *url;\n\n      url=GetMagickHomeURL();\n      (void) FormatImageProperty(image,\""dpx:file.creator\"",\""%.100s\"",url);\n      (void) FormatImageProperty(image,\""software\"",\""%.100s\"",url);\n      url=DestroyString(url);\n    }\n  else\n    {\n      (void) FormatImageProperty(image,\""dpx:file.creator\"",\""%.100s\"",\n        dpx.file.creator);\n      (void) FormatImageProperty(image,\""software\"",\""%.100s\"",dpx.file.creator);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.project),(unsigned char *)\n    dpx.file.project);\n  if (*dpx.file.project != '\\0')\n    {\n      (void) FormatImageProperty(image,\""dpx:file.project\"",\""%.200s\"",\n        dpx.file.project);\n      (void) FormatImageProperty(image,\""comment\"",\""%.100s\"",dpx.file.project);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.copyright),(unsigned char *)\n    dpx.file.copyright);\n  if (*dpx.file.copyright != '\\0')\n    {\n      (void) FormatImageProperty(image,\""dpx:file.copyright\"",\""%.200s\"",\n        dpx.file.copyright);\n      (void) FormatImageProperty(image,\""copyright\"",\""%.100s\"",\n        dpx.file.copyright);\n    }\n  dpx.file.encrypt_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.encrypt_key != ~0U)\n    (void) FormatImageProperty(image,\""dpx:file.encrypt_key\"",\""%u\"",\n      dpx.file.encrypt_key);\n  offset+=ReadBlob(image,sizeof(dpx.file.reserve),(unsigned char *)\n    dpx.file.reserve);\n  /*\n    Read DPX image header.\n  */\n  dpx.image.orientation=ReadBlobShort(image);\n  if (dpx.image.orientation > 7)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  offset+=2;\n  if (dpx.image.orientation != (unsigned short) ~0)\n    (void) FormatImageProperty(image,\""dpx:image.orientation\"",\""%d\"",\n      dpx.image.orientation);\n  switch (dpx.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  dpx.image.number_elements=ReadBlobShort(image);\n  if (dpx.image.number_elements > MaxNumberImageElements)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  offset+=2;\n  dpx.image.pixels_per_line=ReadBlobLong(image);\n  offset+=4;\n  image->columns=dpx.image.pixels_per_line;\n  dpx.image.lines_per_element=ReadBlobLong(image);\n  offset+=4;\n  image->rows=dpx.image.lines_per_element;\n  for (i=0; i < 8; i++)\n  {\n    char\n      property[MaxTextExtent];\n\n    dpx.image.image_element[i].data_sign=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].high_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].high_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].descriptor=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].transfer_characteristic=(unsigned char)\n      ReadBlobByte(image);\n    (void) FormatLocaleString(property,MaxTextExtent,\n      \""dpx:image.element[%lu].transfer-characteristic\"",(long) i);\n    (void) FormatImageProperty(image,property,\""%s\"",\n      GetImageTransferCharacteristic((DPXTransferCharacteristic)\n      dpx.image.image_element[i].transfer_characteristic));\n    offset++;\n    dpx.image.image_element[i].colorimetric=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].bit_size=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].packing=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].encoding=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].data_offset=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_line_padding=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_image_padding=ReadBlobLong(image);\n    offset+=4;\n    offset+=ReadBlob(image,sizeof(dpx.image.image_element[i].description),\n      (unsigned char *) dpx.image.image_element[i].description);\n  }\n  (void) SetImageColorspace(image,RGBColorspace);\n  offset+=ReadBlob(image,sizeof(dpx.image.reserve),(unsigned char *)\n    dpx.image.reserve);\n  if (dpx.file.image_offset >= 1664U)\n    {\n      /*\n        Read DPX orientation header.\n      */\n      dpx.orientation.x_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_offset != ~0U)\n        (void) FormatImageProperty(image,\""dpx:orientation.x_offset\"",\""%u\"",\n          dpx.orientation.x_offset);\n      dpx.orientation.y_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_offset != ~0U)\n        (void) FormatImageProperty(image,\""dpx:orientation.y_offset\"",\""%u\"",\n          dpx.orientation.y_offset);\n      dpx.orientation.x_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.x_center) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:orientation.x_center\"",\""%g\"",\n          dpx.orientation.x_center);\n      dpx.orientation.y_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.y_center) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:orientation.y_center\"",\""%g\"",\n          dpx.orientation.y_center);\n      dpx.orientation.x_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_size != ~0U)\n        (void) FormatImageProperty(image,\""dpx:orientation.x_size\"",\""%u\"",\n          dpx.orientation.x_size);\n      dpx.orientation.y_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_size != ~0U)\n        (void) FormatImageProperty(image,\""dpx:orientation.y_size\"",\""%u\"",\n          dpx.orientation.y_size);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.filename),(unsigned char *)\n        dpx.orientation.filename);\n      if (*dpx.orientation.filename != '\\0')\n        (void) FormatImageProperty(image,\""dpx:orientation.filename\"",\""%.100s\"",\n          dpx.orientation.filename);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.timestamp),(unsigned char *)\n        dpx.orientation.timestamp);\n      if (*dpx.orientation.timestamp != '\\0')\n        (void) FormatImageProperty(image,\""dpx:orientation.timestamp\"",\""%.24s\"",\n          dpx.orientation.timestamp);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.device),(unsigned char *)\n        dpx.orientation.device);\n      if (*dpx.orientation.device != '\\0')\n        (void) FormatImageProperty(image,\""dpx:orientation.device\"",\""%.32s\"",\n          dpx.orientation.device);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.serial),(unsigned char *)\n        dpx.orientation.serial);\n      if (*dpx.orientation.serial != '\\0')\n        (void) FormatImageProperty(image,\""dpx:orientation.serial\"",\""%.32s\"",\n          dpx.orientation.serial);\n      for (i=0; i < 4; i++)\n      {\n        dpx.orientation.border[i]=ReadBlobShort(image);\n        offset+=2;\n      }\n      if ((dpx.orientation.border[0] != (unsigned short) (~0)) &&\n          (dpx.orientation.border[1] != (unsigned short) (~0)))\n        (void) FormatImageProperty(image,\""dpx:orientation.border\"",\""%dx%d%+d%+d\"",          dpx.orientation.border[0],dpx.orientation.border[1],\n          dpx.orientation.border[2],dpx.orientation.border[3]);\n      for (i=0; i < 2; i++)\n      {\n        dpx.orientation.aspect_ratio[i]=ReadBlobLong(image);\n        offset+=4;\n      }\n      if ((dpx.orientation.aspect_ratio[0] != ~0U) &&\n          (dpx.orientation.aspect_ratio[1] != ~0U))\n        (void) FormatImageProperty(image,\""dpx:orientation.aspect_ratio\"",\n          \""%ux%u\"",dpx.orientation.aspect_ratio[0],\n          dpx.orientation.aspect_ratio[1]);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.reserve),(unsigned char *)\n        dpx.orientation.reserve);\n    }\n  if (dpx.file.image_offset >= 1920U)\n    {\n      /*\n        Read DPX film header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);\n      if (*dpx.film.id != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.id\"",\""%.2s\"",dpx.film.id);\n      offset+=ReadBlob(image,sizeof(dpx.film.type),(unsigned char *)\n        dpx.film.type);\n      if (*dpx.film.type != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.type\"",\""%.2s\"",dpx.film.type);\n      offset+=ReadBlob(image,sizeof(dpx.film.offset),(unsigned char *)\n        dpx.film.offset);\n      if (*dpx.film.offset != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.offset\"",\""%.2s\"",\n          dpx.film.offset);\n      offset+=ReadBlob(image,sizeof(dpx.film.prefix),(unsigned char *)\n        dpx.film.prefix);\n      if (*dpx.film.prefix != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.prefix\"",\""%.6s\"",\n          dpx.film.prefix);\n      offset+=ReadBlob(image,sizeof(dpx.film.count),(unsigned char *)\n        dpx.film.count);\n      if (*dpx.film.count != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.count\"",\""%.4s\"",\n          dpx.film.count);\n      offset+=ReadBlob(image,sizeof(dpx.film.format),(unsigned char *)\n        dpx.film.format);\n      if (*dpx.film.format != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.format\"",\""%.4s\"",\n          dpx.film.format);\n      dpx.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.frame_position != ~0U)\n        (void) FormatImageProperty(image,\""dpx:film.frame_position\"",\""%u\"",\n          dpx.film.frame_position);\n      dpx.film.sequence_extent=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.sequence_extent != ~0U)\n        (void) FormatImageProperty(image,\""dpx:film.sequence_extent\"",\""%u\"",\n          dpx.film.sequence_extent);\n      dpx.film.held_count=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.held_count != ~0U)\n        (void) FormatImageProperty(image,\""dpx:film.held_count\"",\""%u\"",\n          dpx.film.held_count);\n      dpx.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:film.frame_rate\"",\""%g\"",\n          dpx.film.frame_rate);\n      dpx.film.shutter_angle=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.shutter_angle) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:film.shutter_angle\"",\""%g\"",\n          dpx.film.shutter_angle);\n      offset+=ReadBlob(image,sizeof(dpx.film.frame_id),(unsigned char *)\n        dpx.film.frame_id);\n      if (*dpx.film.frame_id != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.frame_id\"",\""%.32s\"",\n          dpx.film.frame_id);\n      offset+=ReadBlob(image,sizeof(dpx.film.slate),(unsigned char *)\n        dpx.film.slate);\n      if (*dpx.film.slate != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.slate\"",\""%.100s\"",\n          dpx.film.slate);\n      offset+=ReadBlob(image,sizeof(dpx.film.reserve),(unsigned char *)\n        dpx.film.reserve);\n    }\n  if (dpx.file.image_offset >= 2048U)\n    {\n      /*\n        Read DPX television header.\n      */\n      dpx.television.time_code=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.time_code,value);\n      (void) SetImageProperty(image,\""dpx:television.time.code\"",value);\n      dpx.television.user_bits=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.user_bits,value);\n      (void) SetImageProperty(image,\""dpx:television.user.bits\"",value);\n      dpx.television.interlace=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.interlace != 0)\n        (void) FormatImageProperty(image,\""dpx:television.interlace\"",\""%.20g\"",\n          (double) dpx.television.interlace);\n      dpx.television.field_number=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.field_number != 0)\n        (void) FormatImageProperty(image,\""dpx:television.field_number\"",\""%.20g\"",\n          (double) dpx.television.field_number);\n      dpx.television.video_signal=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.video_signal != 0)\n        (void) FormatImageProperty(image,\""dpx:television.video_signal\"",\""%.20g\"",\n          (double) dpx.television.video_signal);\n      dpx.television.padding=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.padding != 0)\n        (void) FormatImageProperty(image,\""dpx:television.padding\"",\""%d\"",\n          dpx.television.padding);\n      dpx.television.horizontal_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.horizontal_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\n          \""dpx:television.horizontal_sample_rate\"",\""%g\"",\n          dpx.television.horizontal_sample_rate);\n      dpx.television.vertical_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.vertical_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.vertical_sample_rate\"",\n          \""%g\"",dpx.television.vertical_sample_rate);\n      dpx.television.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.frame_rate\"",\""%g\"",\n          dpx.television.frame_rate);\n      dpx.television.time_offset=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.time_offset) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.time_offset\"",\""%g\"",\n          dpx.television.time_offset);\n      dpx.television.gamma=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.gamma) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.gamma\"",\""%g\"",\n          dpx.television.gamma);\n      dpx.television.black_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_level) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.black_level\"",\""%g\"",\n          dpx.television.black_level);\n      dpx.television.black_gain=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_gain) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.black_gain\"",\""%g\"",\n          dpx.television.black_gain);\n      dpx.television.break_point=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.break_point) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.break_point\"",\""%g\"",\n          dpx.television.break_point);\n      dpx.television.white_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.white_level) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.white_level\"",\""%g\"",\n          dpx.television.white_level);\n      dpx.television.integration_times=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.integration_times) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.integration_times\"",\n          \""%g\"",dpx.television.integration_times);\n      offset+=ReadBlob(image,sizeof(dpx.television.reserve),(unsigned char *)\n        dpx.television.reserve);\n    }\n  if (dpx.file.image_offset > 2080U)\n    {\n      /*\n        Read DPX user header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.user.id),(unsigned char *) dpx.user.id);\n      if (*dpx.user.id != '\\0')\n        (void) FormatImageProperty(image,\""dpx:user.id\"",\""%.32s\"",dpx.user.id);\n      if ((dpx.file.user_size != ~0U) &&\n          ((size_t) dpx.file.user_size > sizeof(dpx.user.id)))\n        {\n          StringInfo\n            *profile;\n\n           profile=BlobToStringInfo((const void *) NULL,\n             dpx.file.user_size-sizeof(dpx.user.id));\n           if (profile == (StringInfo *) NULL)\n             ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n           offset+=ReadBlob(image,GetStringInfoLength(profile),\n             GetStringInfoDatum(profile));\n           (void) SetImageProfile(image,\""dpx:user-data\"",profile);\n           profile=DestroyStringInfo(profile);\n        }\n    }\n  for ( ; offset < (MagickOffsetType) dpx.file.image_offset; offset++)\n    (void) ReadBlobByte(image);\n  /*\n    Read DPX image header.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  for (n=0; n < (ssize_t) dpx.image.number_elements; n++)\n  {\n    /*\n      Convert DPX raster image to pixel packets.\n    */\n    if ((dpx.image.image_element[n].data_offset != ~0U) &&\n        (dpx.image.image_element[n].data_offset != 0U))\n      {\n         MagickOffsetType\n           data_offset;\n\n         data_offset=(MagickOffsetType) dpx.image.image_element[n].data_offset;\n         if (data_offset < offset)\n           offset=SeekBlob(image,data_offset,SEEK_SET);\n         else\n           for ( ; offset < data_offset; offset++)\n             (void) ReadBlobByte(image);\n          if (offset != data_offset)\n            ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n       }\n    SetPrimaryChromaticity((DPXColorimetric)\n      dpx.image.image_element[n].colorimetric,&image->chromaticity);\n    image->depth=dpx.image.image_element[n].bit_size;\n    samples_per_pixel=1;\n    quantum_type=GrayQuantum;\n    component_type=dpx.image.image_element[n].descriptor;\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      {\n        samples_per_pixel=2;\n        quantum_type=CbYCrYQuantum;\n        break;\n      }\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=CbYCrQuantum;\n        break;\n      }\n      case RGBComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=RGBQuantum;\n        break;\n      }\n      case ABGRComponentType:\n      case RGBAComponentType:\n      {\n        image->matte=MagickTrue;\n        samples_per_pixel=4;\n        quantum_type=RGBAQuantum;\n        break;\n      }\n      default:\n        break;\n    }\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        (void) SetImageColorspace(image,Rec709YCbCrColorspace);\n        break;\n      }\n      case LumaComponentType:\n      {\n        (void) SetImageColorspace(image,GRAYColorspace);\n        break;\n      }\n      default:\n      {\n        (void) SetImageColorspace(image,RGBColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == LogarithmicColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == PrintingDensityColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        break;\n      }\n    }\n    extent=GetBytesPerRow(image->columns,samples_per_pixel,image->depth,\n      dpx.image.image_element[n].packing == 0 ? MagickFalse : MagickTrue);\n    /*\n      DPX any-bit pixel format.\n    */\n    status=MagickTrue;\n    row=0;\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    SetQuantumQuantum(quantum_info,32);\n    SetQuantumPack(quantum_info,dpx.image.image_element[n].packing == 0 ?\n      MagickTrue : MagickFalse);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      const unsigned char\n        *pixels;\n\n      MagickBooleanType\n        sync;\n\n      register PixelPacket\n        *q;\n\n      size_t\n        length;\n\n      ssize_t\n        count,\n        offset;\n\n      if (status == MagickFalse)\n        continue;\n      pixels=(const unsigned char *) ReadBlobStream(image,extent,\n        GetQuantumPixels(quantum_info),&count);\n      if (count != (ssize_t) extent)\n        status=MagickFalse;\n      if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n          (image->previous == (Image *) NULL))\n        {\n          MagickBooleanType\n            proceed;\n\n          proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row,\n            image->rows);\n          if (proceed == MagickFalse)\n            status=MagickFalse;\n        }\n      offset=row++;\n      q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        {\n          status=MagickFalse;\n          continue;\n        }\n      length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        quantum_type,pixels,exception);\n      (void) length;\n      sync=SyncAuthenticPixels(image,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (status == MagickFalse)\n      ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n    SetQuantumImageType(image,quantum_type);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n        image->filename);\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"", ""target"": 0}]","[{""func_name"": ""ReadDPXImage"", ""file_path"": ""coders/dpx.c"", ""func_code"": ""static Image *ReadDPXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[4],\n    value[MaxTextExtent];\n\n  DPXInfo\n    dpx;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent,\n    samples_per_pixel;\n\n  ssize_t\n    count,\n    n,\n    row,\n    y;\n\n  unsigned char\n    component_type;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read DPX file header.\n  */\n  offset=0;\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  offset+=count;\n  if ((count != 4) || ((LocaleNCompare(magick,\""SDPX\"",4) != 0) &&\n      (LocaleNCompare((char *) magick,\""XPDS\"",4) != 0)))\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  image->endian=LSBEndian;\n  if (LocaleNCompare(magick,\""SDPX\"",4) == 0)\n    image->endian=MSBEndian;\n  (void) ResetMagickMemory(&dpx,0,sizeof(dpx));\n  dpx.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.version),(unsigned char *)\n    dpx.file.version);\n  (void) FormatImageProperty(image,\""dpx:file.version\"",\""%.8s\"",dpx.file.version);\n  dpx.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.ditto_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.ditto_key != ~0U)\n    (void) FormatImageProperty(image,\""dpx:file.ditto.key\"",\""%u\"",\n      dpx.file.ditto_key);\n  dpx.file.generic_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.industry_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.user_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.filename),(unsigned char *)\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\""dpx:file.filename\"",\""%.100s\"",\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\""document\"",\""%.100s\"",dpx.file.filename);\n  offset+=ReadBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)\n    dpx.file.timestamp);\n  if (*dpx.file.timestamp != '\\0')\n    (void) FormatImageProperty(image,\""dpx:file.timestamp\"",\""%.24s\"",\n      dpx.file.timestamp);\n  offset+=ReadBlob(image,sizeof(dpx.file.creator),(unsigned char *)\n    dpx.file.creator);\n  if (*dpx.file.creator == '\\0')\n    {\n      char\n        *url;\n\n      url=GetMagickHomeURL();\n      (void) FormatImageProperty(image,\""dpx:file.creator\"",\""%.100s\"",url);\n      (void) FormatImageProperty(image,\""software\"",\""%.100s\"",url);\n      url=DestroyString(url);\n    }\n  else\n    {\n      (void) FormatImageProperty(image,\""dpx:file.creator\"",\""%.100s\"",\n        dpx.file.creator);\n      (void) FormatImageProperty(image,\""software\"",\""%.100s\"",dpx.file.creator);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.project),(unsigned char *)\n    dpx.file.project);\n  if (*dpx.file.project != '\\0')\n    {\n      (void) FormatImageProperty(image,\""dpx:file.project\"",\""%.200s\"",\n        dpx.file.project);\n      (void) FormatImageProperty(image,\""comment\"",\""%.100s\"",dpx.file.project);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.copyright),(unsigned char *)\n    dpx.file.copyright);\n  if (*dpx.file.copyright != '\\0')\n    {\n      (void) FormatImageProperty(image,\""dpx:file.copyright\"",\""%.200s\"",\n        dpx.file.copyright);\n      (void) FormatImageProperty(image,\""copyright\"",\""%.100s\"",\n        dpx.file.copyright);\n    }\n  dpx.file.encrypt_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.encrypt_key != ~0U)\n    (void) FormatImageProperty(image,\""dpx:file.encrypt_key\"",\""%u\"",\n      dpx.file.encrypt_key);\n  offset+=ReadBlob(image,sizeof(dpx.file.reserve),(unsigned char *)\n    dpx.file.reserve);\n  /*\n    Read DPX image header.\n  */\n  dpx.image.orientation=ReadBlobShort(image);\n  if (dpx.image.orientation > 7)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  offset+=2;\n  if (dpx.image.orientation != (unsigned short) ~0)\n    (void) FormatImageProperty(image,\""dpx:image.orientation\"",\""%d\"",\n      dpx.image.orientation);\n  switch (dpx.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  dpx.image.number_elements=ReadBlobShort(image);\n  if (dpx.image.number_elements > MaxNumberImageElements)\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  offset+=2;\n  dpx.image.pixels_per_line=ReadBlobLong(image);\n  offset+=4;\n  image->columns=dpx.image.pixels_per_line;\n  dpx.image.lines_per_element=ReadBlobLong(image);\n  offset+=4;\n  image->rows=dpx.image.lines_per_element;\n  for (i=0; i < 8; i++)\n  {\n    char\n      property[MaxTextExtent];\n\n    dpx.image.image_element[i].data_sign=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].high_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].high_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].descriptor=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].transfer_characteristic=(unsigned char)\n      ReadBlobByte(image);\n    (void) FormatLocaleString(property,MaxTextExtent,\n      \""dpx:image.element[%lu].transfer-characteristic\"",(long) i);\n    (void) FormatImageProperty(image,property,\""%s\"",\n      GetImageTransferCharacteristic((DPXTransferCharacteristic)\n      dpx.image.image_element[i].transfer_characteristic));\n    offset++;\n    dpx.image.image_element[i].colorimetric=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].bit_size=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].packing=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].encoding=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].data_offset=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_line_padding=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_image_padding=ReadBlobLong(image);\n    offset+=4;\n    offset+=ReadBlob(image,sizeof(dpx.image.image_element[i].description),\n      (unsigned char *) dpx.image.image_element[i].description);\n  }\n  (void) SetImageColorspace(image,RGBColorspace);\n  offset+=ReadBlob(image,sizeof(dpx.image.reserve),(unsigned char *)\n    dpx.image.reserve);\n  if (dpx.file.image_offset >= 1664U)\n    {\n      /*\n        Read DPX orientation header.\n      */\n      dpx.orientation.x_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_offset != ~0U)\n        (void) FormatImageProperty(image,\""dpx:orientation.x_offset\"",\""%u\"",\n          dpx.orientation.x_offset);\n      dpx.orientation.y_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_offset != ~0U)\n        (void) FormatImageProperty(image,\""dpx:orientation.y_offset\"",\""%u\"",\n          dpx.orientation.y_offset);\n      dpx.orientation.x_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.x_center) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:orientation.x_center\"",\""%g\"",\n          dpx.orientation.x_center);\n      dpx.orientation.y_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.y_center) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:orientation.y_center\"",\""%g\"",\n          dpx.orientation.y_center);\n      dpx.orientation.x_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_size != ~0U)\n        (void) FormatImageProperty(image,\""dpx:orientation.x_size\"",\""%u\"",\n          dpx.orientation.x_size);\n      dpx.orientation.y_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_size != ~0U)\n        (void) FormatImageProperty(image,\""dpx:orientation.y_size\"",\""%u\"",\n          dpx.orientation.y_size);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.filename),(unsigned char *)\n        dpx.orientation.filename);\n      if (*dpx.orientation.filename != '\\0')\n        (void) FormatImageProperty(image,\""dpx:orientation.filename\"",\""%.100s\"",\n          dpx.orientation.filename);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.timestamp),(unsigned char *)\n        dpx.orientation.timestamp);\n      if (*dpx.orientation.timestamp != '\\0')\n        (void) FormatImageProperty(image,\""dpx:orientation.timestamp\"",\""%.24s\"",\n          dpx.orientation.timestamp);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.device),(unsigned char *)\n        dpx.orientation.device);\n      if (*dpx.orientation.device != '\\0')\n        (void) FormatImageProperty(image,\""dpx:orientation.device\"",\""%.32s\"",\n          dpx.orientation.device);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.serial),(unsigned char *)\n        dpx.orientation.serial);\n      if (*dpx.orientation.serial != '\\0')\n        (void) FormatImageProperty(image,\""dpx:orientation.serial\"",\""%.32s\"",\n          dpx.orientation.serial);\n      for (i=0; i < 4; i++)\n      {\n        dpx.orientation.border[i]=ReadBlobShort(image);\n        offset+=2;\n      }\n      if ((dpx.orientation.border[0] != (unsigned short) (~0)) &&\n          (dpx.orientation.border[1] != (unsigned short) (~0)))\n        (void) FormatImageProperty(image,\""dpx:orientation.border\"",\""%dx%d%+d%+d\"",          dpx.orientation.border[0],dpx.orientation.border[1],\n          dpx.orientation.border[2],dpx.orientation.border[3]);\n      for (i=0; i < 2; i++)\n      {\n        dpx.orientation.aspect_ratio[i]=ReadBlobLong(image);\n        offset+=4;\n      }\n      if ((dpx.orientation.aspect_ratio[0] != ~0U) &&\n          (dpx.orientation.aspect_ratio[1] != ~0U))\n        (void) FormatImageProperty(image,\""dpx:orientation.aspect_ratio\"",\n          \""%ux%u\"",dpx.orientation.aspect_ratio[0],\n          dpx.orientation.aspect_ratio[1]);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.reserve),(unsigned char *)\n        dpx.orientation.reserve);\n    }\n  if (dpx.file.image_offset >= 1920U)\n    {\n      /*\n        Read DPX film header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);\n      if (*dpx.film.id != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.id\"",\""%.2s\"",dpx.film.id);\n      offset+=ReadBlob(image,sizeof(dpx.film.type),(unsigned char *)\n        dpx.film.type);\n      if (*dpx.film.type != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.type\"",\""%.2s\"",dpx.film.type);\n      offset+=ReadBlob(image,sizeof(dpx.film.offset),(unsigned char *)\n        dpx.film.offset);\n      if (*dpx.film.offset != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.offset\"",\""%.2s\"",\n          dpx.film.offset);\n      offset+=ReadBlob(image,sizeof(dpx.film.prefix),(unsigned char *)\n        dpx.film.prefix);\n      if (*dpx.film.prefix != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.prefix\"",\""%.6s\"",\n          dpx.film.prefix);\n      offset+=ReadBlob(image,sizeof(dpx.film.count),(unsigned char *)\n        dpx.film.count);\n      if (*dpx.film.count != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.count\"",\""%.4s\"",\n          dpx.film.count);\n      offset+=ReadBlob(image,sizeof(dpx.film.format),(unsigned char *)\n        dpx.film.format);\n      if (*dpx.film.format != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.format\"",\""%.4s\"",\n          dpx.film.format);\n      dpx.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.frame_position != ~0U)\n        (void) FormatImageProperty(image,\""dpx:film.frame_position\"",\""%u\"",\n          dpx.film.frame_position);\n      dpx.film.sequence_extent=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.sequence_extent != ~0U)\n        (void) FormatImageProperty(image,\""dpx:film.sequence_extent\"",\""%u\"",\n          dpx.film.sequence_extent);\n      dpx.film.held_count=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.held_count != ~0U)\n        (void) FormatImageProperty(image,\""dpx:film.held_count\"",\""%u\"",\n          dpx.film.held_count);\n      dpx.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:film.frame_rate\"",\""%g\"",\n          dpx.film.frame_rate);\n      dpx.film.shutter_angle=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.shutter_angle) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:film.shutter_angle\"",\""%g\"",\n          dpx.film.shutter_angle);\n      offset+=ReadBlob(image,sizeof(dpx.film.frame_id),(unsigned char *)\n        dpx.film.frame_id);\n      if (*dpx.film.frame_id != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.frame_id\"",\""%.32s\"",\n          dpx.film.frame_id);\n      offset+=ReadBlob(image,sizeof(dpx.film.slate),(unsigned char *)\n        dpx.film.slate);\n      if (*dpx.film.slate != '\\0')\n        (void) FormatImageProperty(image,\""dpx:film.slate\"",\""%.100s\"",\n          dpx.film.slate);\n      offset+=ReadBlob(image,sizeof(dpx.film.reserve),(unsigned char *)\n        dpx.film.reserve);\n    }\n  if (dpx.file.image_offset >= 2048U)\n    {\n      /*\n        Read DPX television header.\n      */\n      dpx.television.time_code=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.time_code,value);\n      (void) SetImageProperty(image,\""dpx:television.time.code\"",value);\n      dpx.television.user_bits=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.user_bits,value);\n      (void) SetImageProperty(image,\""dpx:television.user.bits\"",value);\n      dpx.television.interlace=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.interlace != 0)\n        (void) FormatImageProperty(image,\""dpx:television.interlace\"",\""%.20g\"",\n          (double) dpx.television.interlace);\n      dpx.television.field_number=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.field_number != 0)\n        (void) FormatImageProperty(image,\""dpx:television.field_number\"",\""%.20g\"",\n          (double) dpx.television.field_number);\n      dpx.television.video_signal=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.video_signal != 0)\n        (void) FormatImageProperty(image,\""dpx:television.video_signal\"",\""%.20g\"",\n          (double) dpx.television.video_signal);\n      dpx.television.padding=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.padding != 0)\n        (void) FormatImageProperty(image,\""dpx:television.padding\"",\""%d\"",\n          dpx.television.padding);\n      dpx.television.horizontal_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.horizontal_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\n          \""dpx:television.horizontal_sample_rate\"",\""%g\"",\n          dpx.television.horizontal_sample_rate);\n      dpx.television.vertical_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.vertical_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.vertical_sample_rate\"",\n          \""%g\"",dpx.television.vertical_sample_rate);\n      dpx.television.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.frame_rate\"",\""%g\"",\n          dpx.television.frame_rate);\n      dpx.television.time_offset=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.time_offset) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.time_offset\"",\""%g\"",\n          dpx.television.time_offset);\n      dpx.television.gamma=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.gamma) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.gamma\"",\""%g\"",\n          dpx.television.gamma);\n      dpx.television.black_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_level) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.black_level\"",\""%g\"",\n          dpx.television.black_level);\n      dpx.television.black_gain=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_gain) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.black_gain\"",\""%g\"",\n          dpx.television.black_gain);\n      dpx.television.break_point=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.break_point) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.break_point\"",\""%g\"",\n          dpx.television.break_point);\n      dpx.television.white_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.white_level) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.white_level\"",\""%g\"",\n          dpx.television.white_level);\n      dpx.television.integration_times=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.integration_times) != MagickFalse)\n        (void) FormatImageProperty(image,\""dpx:television.integration_times\"",\n          \""%g\"",dpx.television.integration_times);\n      offset+=ReadBlob(image,sizeof(dpx.television.reserve),(unsigned char *)\n        dpx.television.reserve);\n    }\n  if (dpx.file.image_offset > 2080U)\n    {\n      /*\n        Read DPX user header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.user.id),(unsigned char *) dpx.user.id);\n      if (*dpx.user.id != '\\0')\n        (void) FormatImageProperty(image,\""dpx:user.id\"",\""%.32s\"",dpx.user.id);\n      if ((dpx.file.user_size != ~0U) &&\n          ((size_t) dpx.file.user_size > sizeof(dpx.user.id)))\n        {\n          StringInfo\n            *profile;\n\n           profile=BlobToStringInfo((const void *) NULL,\n             dpx.file.user_size-sizeof(dpx.user.id));\n           if (profile == (StringInfo *) NULL)\n             ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n           offset+=ReadBlob(image,GetStringInfoLength(profile),\n             GetStringInfoDatum(profile));\n           (void) SetImageProfile(image,\""dpx:user-data\"",profile);\n           profile=DestroyStringInfo(profile);\n        }\n    }\n  for ( ; offset < (MagickOffsetType) dpx.file.image_offset; offset++)\n    if (ReadBlobByte(image) == EOF)\n      break;\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n      image->filename);\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  for (n=0; n < (ssize_t) dpx.image.number_elements; n++)\n  {\n    /*\n      Convert DPX raster image to pixel packets.\n    */\n    if ((dpx.image.image_element[n].data_offset != ~0U) &&\n        (dpx.image.image_element[n].data_offset != 0U))\n      {\n         MagickOffsetType\n           data_offset;\n\n         data_offset=(MagickOffsetType) dpx.image.image_element[n].data_offset;\n         if (data_offset < offset)\n           offset=SeekBlob(image,data_offset,SEEK_SET);\n         else\n           for ( ; offset < data_offset; offset++)\n             (void) ReadBlobByte(image);\n          if (offset != data_offset)\n            ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n       }\n    SetPrimaryChromaticity((DPXColorimetric)\n      dpx.image.image_element[n].colorimetric,&image->chromaticity);\n    image->depth=dpx.image.image_element[n].bit_size;\n    samples_per_pixel=1;\n    quantum_type=GrayQuantum;\n    component_type=dpx.image.image_element[n].descriptor;\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      {\n        samples_per_pixel=2;\n        quantum_type=CbYCrYQuantum;\n        break;\n      }\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=CbYCrQuantum;\n        break;\n      }\n      case RGBComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=RGBQuantum;\n        break;\n      }\n      case ABGRComponentType:\n      case RGBAComponentType:\n      {\n        image->matte=MagickTrue;\n        samples_per_pixel=4;\n        quantum_type=RGBAQuantum;\n        break;\n      }\n      default:\n        break;\n    }\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        (void) SetImageColorspace(image,Rec709YCbCrColorspace);\n        break;\n      }\n      case LumaComponentType:\n      {\n        (void) SetImageColorspace(image,GRAYColorspace);\n        break;\n      }\n      default:\n      {\n        (void) SetImageColorspace(image,RGBColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == LogarithmicColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == PrintingDensityColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        break;\n      }\n    }\n    extent=GetBytesPerRow(image->columns,samples_per_pixel,image->depth,\n      dpx.image.image_element[n].packing == 0 ? MagickFalse : MagickTrue);\n    /*\n      DPX any-bit pixel format.\n    */\n    status=MagickTrue;\n    row=0;\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    SetQuantumQuantum(quantum_info,32);\n    SetQuantumPack(quantum_info,dpx.image.image_element[n].packing == 0 ?\n      MagickTrue : MagickFalse);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      const unsigned char\n        *pixels;\n\n      MagickBooleanType\n        sync;\n\n      register PixelPacket\n        *q;\n\n      size_t\n        length;\n\n      ssize_t\n        count,\n        offset;\n\n      if (status == MagickFalse)\n        continue;\n      pixels=(const unsigned char *) ReadBlobStream(image,extent,\n        GetQuantumPixels(quantum_info),&count);\n      if (count != (ssize_t) extent)\n        status=MagickFalse;\n      if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n          (image->previous == (Image *) NULL))\n        {\n          MagickBooleanType\n            proceed;\n\n          proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row,\n            image->rows);\n          if (proceed == MagickFalse)\n            status=MagickFalse;\n        }\n      offset=row++;\n      q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        {\n          status=MagickFalse;\n          continue;\n        }\n      length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        quantum_type,pixels,exception);\n      (void) length;\n      sync=SyncAuthenticPixels(image,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (status == MagickFalse)\n      ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n    SetQuantumImageType(image,quantum_type);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n        image->filename);\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}""}]","{""function"": 2}","[{""source"": ""func_info(func:ReadBlobByte)"", ""result"": [{""code"": ""int ReadBlobByte(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[1];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  p=(const unsigned char *) ReadBlobStream(image,1,buffer,&count);\n  if (count != 1)\n    return(EOF);\n  return((int) (*p));\n}"", ""start_line"": 3002, ""end_line"": 3019, ""full_name"": ""ReadBlobByte"", ""file_path"": ""magick/blob.c""}]}, {""source"": ""func_info(func:EOFBlob)"", ""result"": [{""code"": ""MagickExport int EOFBlob(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""...\"");\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  switch (image->blob->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      image->blob->eof=feof(image->blob->file_info.file) != 0 ? MagickTrue :\n        MagickFalse;\n      break;\n    }\n    case ZipStream:\n    {\n      image->blob->eof=MagickFalse;\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      int\n        status;\n\n      status=0;\n      (void) BZ2_bzerror(image->blob->file_info.bzfile,&status);\n      image->blob->eof=status == BZ_UNEXPECTED_EOF ? MagickTrue : MagickFalse;\n#endif\n      break;\n    }\n    case FifoStream:\n    {\n      image->blob->eof=MagickFalse;\n      break;\n    }\n    case BlobStream:\n      break;\n  }\n  return((int) image->blob->eof);\n}\n"", ""start_line"": 874, ""end_line"": 920, ""full_name"": ""EOFBlob"", ""file_path"": ""magick/blob.c""}]}]","The loop at coders/dpx.c:1127 skipped bytes via ReadBlobByte without EOF validation. A crafted DPX file with a large image_offset value forces prolonged loop execution. ReadBlobByte (magick/blob.c:3002-3019) returns EOF on read failure, but the original code ignored this, allowing infinite looping. The patch adds EOF checks in coders/dpx.c:1127-1132 to break the loop and validate EOF via EOBlob (magick/blob.c:874-920), which checks stream-specific EOF states (e.g., feof for files).",0.95,./github/other_context/CVE-2017-11188
32,CVE-2017-11410,"CWE-20, CWE-835",c_cpp,"In Wireshark through 2.0.13 and 2.2.x through 2.2.7, the WBXML dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-wbxml.c by adding validation of the relationships between indexes and lengths. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-7702.",https://github.com/wireshark/wireshark/commit/3c7168cc5f044b4da8747d35da0b2b204dabf398,WBXML: Fix some more potential infinite loops.\n\ntvb_get_guintvar can generate some unrealistic values so do some\nsanity checking on them.\n\nBug: 13796\nChange-Id: I2d5f7a48c2e982a419ea6ab3ac0000be3b6bcbc7\nReviewed-on: https://code.wireshark.org/review/22121\nReviewed-by: Michael Mann <mmann78@netscape.net>\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit 50fa2d95833ec2e2b0de3000eda7b290fc23eaeb)\nReviewed-on: https://code.wireshark.org/review/22130,2,"[{""func_name"": ""parse_wbxml_attribute_list_defined"", ""file_path"": ""epan/dissectors/packet-wbxml.c"", ""func_code"": ""static guint32\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,\n\t\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map)\n{\n\tguint32     tvb_len = tvb_reported_length (tvb);\n\tguint32     off     = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint8      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\n\tconst char *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\n\tgchar      *str;\n\n\tDebugLog((\""parse_wbxml_attr_defined (level = %u, offset = %u)\\n\"", level, offset));\n\t/* Parse attributes */\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\""ATTR: (top of while) level = %3u, peek = 0x%02X, \""\n\t\t\t  \""off = %u, tvb_len = %u\\n\"", level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_attr,\n                         \""      |  Attr | A -->%3d | SWITCH_PAGE (Attr code page)    |\"",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \"">\"" or \""/>\""\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\""ATTR: level = %u, Return: len = %u\\n\"",\n\t\t\t\t  level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), ent);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | STR_I (Inline string)           |     %s\\'%s\\'\"",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\t/* ALWAYS means the start of a new attribute,\n\t\t\t * and may only contain the NAME of the attribute.\n\t\t\t */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tattr_save_known = 0;\n\t\t\t\tattr_save_literal = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), attr_save_literal);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | EXT_I_%1x    (Extension Token)    |     %s(%s: \\'%s\\')\"",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \""Inline string extension\""), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map != NULL) {\n\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""EXT_T_%1x (%s)\"", peek & 0x03,\n\t\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""Extension Token, integer value: (%u\"", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s)\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\tif (len <= tvb_len) {\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), str);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \""Single-byte extension\"");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | EXT_%1x      (Extension Token)    |     %s(%s)\"",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (attr_save_known) { /* Knwon attribute */\n\t\t\t\t\t\tif (map->opaque_binary_attr) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL attribute */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t\t         \""  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\"",\n\t\t\t\t\t\t\t         level, *codepage_attr, Indent (level), tmp_str);\n\t\t\t\t\t\toff += 1 + len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\"",\n\t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\"",\n\t\t\t\t\t\t\t     level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\""ATTR: level = %u, Return: len = %u\\n\"",\n\t\t\t\t\t  level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_invalid_token, tvb, off, 1,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | %-10s     (Invalid Token!) | WBXML parsing stops here.\"",\n\t\t\t\t\t     level, *codepage_attr, val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \""(unknown 0x%x)\""));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known atribute token */\n\t\t\tchar* s;\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrValue, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""attrValue_0x%02X\"", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrvalue, tvb, off, 1, s,\n\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    |   Known attrValue 0x%02X          |       %s%s\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrStart, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""attrStart_0x%02X\"", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrstart, tvb, off, 1, s,\n\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    |   Known attrStart 0x%02X          |   %s%s\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t} /* End WHILE */\n\tDebugLog((\""ATTR: level = %u, Return: len = %u (end of function body)\\n\"",\n\t\t  level, off - offset));\n\treturn (off - offset);\n}"", ""target"": 0}, {""func_name"": ""parse_wbxml_tag_defined"", ""file_path"": ""epan/dissectors/packet-wbxml.c"", ""func_code"": ""static guint32\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n\t\t\t const wbxml_decoding *map)\n{\n\tguint32     tvb_len  = tvb_reported_length (tvb);\n\tguint32     off      = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tgchar      *str;\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n\n\tif (*level == 255) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\n\t\treturn tvb_len;\n\t}\n\tDebugLog((\""parse_wbxml_tag_defined (level = %u, offset = %u)\\n\"", *level, offset));\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\""STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\"", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\n\t\t\t\t\t     \""      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\"",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\"",\n\t\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \""\"",\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\"",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_save_literal ? tag_save_literal : \""\"");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\""STAG: level = %u, Return: len = %u\\n\"", *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\"",\n\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (*level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \""Inline string extension\""),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\n\t\t\t\t\t\t\t\t  str_tbl, *level, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (PI)                        | %s?>\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map)\n\t\t\t\t{\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""EXT_T_%1x (%s)\"", peek & 0x03,\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""(Extension Token, integer value: %u)\"", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\"",\n\t\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \""Single-byte extension\"");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\"",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (tag_save_known) { /* Knwon tag */\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\"",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tmp_str);\n\t\t\t\t\toff += 1 + len;\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\"",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), idx);\n\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\"",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\""STAG: level = %u, Return: len = %u\\n\"", *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\""STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\"", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t} else {\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(wmem_packet_scope(), \""Tag_0x%02X\"",\n\t\t\t\t\t\t\ttag_new_known);\n\t\t\t\t}\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\""STAG: Tag in Tag - RECURSE! (off = %u)\\n\"", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\n\t\t\t\t\t\t\t\t       level, codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (attribute list)            | %s>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\""Tag in Tag - No recursion this time! (off = %u)\\n\"", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\""<Tag/> in Tag - No recursion! (off = %u)\\n\"", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \""\"",\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n\t\t\t\t/* TODO: Do I have to reset code page here? */\n\t\t\t}\n\t\t} /* if (tag & 0x3F) >= 5 */\n\t} /* while */\n\tDebugLog((\""STAG: level = %u, Return: len = %u (end of function body)\\n\"", *level, off - offset));\n\treturn (off - offset);\n}"", ""target"": 0}]","[{""func_name"": ""parse_wbxml_attribute_list_defined"", ""file_path"": ""epan/dissectors/packet-wbxml.c"", ""func_code"": ""static guint32\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,\n\t\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map)\n{\n\tguint32     tvb_len = tvb_reported_length (tvb);\n\tguint32     off     = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint8      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\n\tconst char *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\n\tgchar      *str;\n\n\tDebugLog((\""parse_wbxml_attr_defined (level = %u, offset = %u)\\n\"", level, offset));\n\t/* Parse attributes */\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\""ATTR: (top of while) level = %3u, peek = 0x%02X, \""\n\t\t\t  \""off = %u, tvb_len = %u\\n\"", level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_attr,\n                         \""      |  Attr | A -->%3d | SWITCH_PAGE (Attr code page)    |\"",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \"">\"" or \""/>\""\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\""ATTR: level = %u, Return: len = %u\\n\"",\n\t\t\t\t  level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), ent);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | STR_I (Inline string)           |     %s\\'%s\\'\"",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\t/* ALWAYS means the start of a new attribute,\n\t\t\t * and may only contain the NAME of the attribute.\n\t\t\t */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tattr_save_known = 0;\n\t\t\t\tattr_save_literal = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), attr_save_literal);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | EXT_I_%1x    (Extension Token)    |     %s(%s: \\'%s\\')\"",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \""Inline string extension\""), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map != NULL) {\n\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""EXT_T_%1x (%s)\"", peek & 0x03,\n\t\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""Extension Token, integer value: (%u\"", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s)\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\tif (len <= tvb_len) {\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t         \""  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\"",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), str);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \""Single-byte extension\"");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | EXT_%1x      (Extension Token)    |     %s(%s)\"",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (attr_save_known) { /* Knwon attribute */\n\t\t\t\t\t\tif (map->opaque_binary_attr) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL attribute */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t\t         \""  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\"",\n\t\t\t\t\t\t\t         level, *codepage_attr, Indent (level), tmp_str);\n\t\t\t\t\t\toff += 1 + len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len)) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\"",\n\t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\"",\n\t\t\t\t\t\t\t     level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\""ATTR: level = %u, Return: len = %u\\n\"",\n\t\t\t\t\t  level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_invalid_token, tvb, off, 1,\n\t\t\t\t\t     \""  %3d |  Attr | A %3d    | %-10s     (Invalid Token!) | WBXML parsing stops here.\"",\n\t\t\t\t\t     level, *codepage_attr, val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \""(unknown 0x%x)\""));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known atribute token */\n\t\t\tchar* s;\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrValue, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""attrValue_0x%02X\"", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrvalue, tvb, off, 1, s,\n\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    |   Known attrValue 0x%02X          |       %s%s\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrStart, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""attrStart_0x%02X\"", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrstart, tvb, off, 1, s,\n\t\t\t\t\t\t     \""  %3d |  Attr | A %3d    |   Known attrStart 0x%02X          |   %s%s\"",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t} /* End WHILE */\n\tDebugLog((\""ATTR: level = %u, Return: len = %u (end of function body)\\n\"",\n\t\t  level, off - offset));\n\treturn (off - offset);\n}""}, {""func_name"": ""parse_wbxml_tag_defined"", ""file_path"": ""epan/dissectors/packet-wbxml.c"", ""func_code"": ""static guint32\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n\t\t\t const wbxml_decoding *map)\n{\n\tguint32     tvb_len  = tvb_reported_length (tvb);\n\tguint32     off      = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tgchar      *str;\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n\n\tif (*level == 255) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\n\t\treturn tvb_len;\n\t}\n\tDebugLog((\""parse_wbxml_tag_defined (level = %u, offset = %u)\\n\"", *level, offset));\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\""STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\"", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\n\t\t\t\t\t     \""      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\"",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\"",\n\t\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \""\"",\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\"",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_save_literal ? tag_save_literal : \""\"");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\""STAG: level = %u, Return: len = %u\\n\"", *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\"",\n\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (*level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \""Inline string extension\""),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\n\t\t\t\t\t\t\t\t  str_tbl, *level, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (PI)                        | %s?>\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map)\n\t\t\t\t{\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""EXT_T_%1x (%s)\"", peek & 0x03,\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \""(Extension Token, integer value: %u)\"", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\"",\n\t\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\"",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \""Single-byte extension\"");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \""  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\"",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (tag_save_known) { /* Knwon tag */\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\"",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tmp_str);\n\t\t\t\t\toff += 1 + len;\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len))\n\t\t\t\t\t{\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t         \""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\"",\n\t\t\t\t\t\t         *level, *codepage_stag, Indent (*level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\"",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\""STAG: level = %u, Return: len = %u\\n\"", *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\""STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\"", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t} else {\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(wmem_packet_scope(), \""Tag_0x%02X\"",\n\t\t\t\t\t\t\ttag_new_known);\n\t\t\t\t}\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\""STAG: Tag in Tag - RECURSE! (off = %u)\\n\"", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\n\t\t\t\t\t\t\t\t       level, codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (attribute list)            | %s>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\"",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\""Tag in Tag - No recursion this time! (off = %u)\\n\"", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\""<Tag/> in Tag - No recursion! (off = %u)\\n\"", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\""STAG: level = %u, ThrowException: len = %u (short frame)\\n\"", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \""\"",\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \""  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\"",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n\t\t\t\t/* TODO: Do I have to reset code page here? */\n\t\t\t}\n\t\t} /* if (tag & 0x3F) >= 5 */\n\t} /* while */\n\tDebugLog((\""STAG: level = %u, Return: len = %u (end of function body)\\n\"", *level, off - offset));\n\treturn (off - offset);\n}""}]","{""function"": 1, ""value"": 1}","[{""source"": ""func_info(func:tvb_get_guintvar)"", ""result"": [{""code"": ""guint\ntvb_get_guintvar (tvbuff_t *tvb, guint offset, guint *octetCount, packet_info *pinfo, expert_field *ei)\n{\n    guint value   = 0;\n    guint octet;\n    guint counter = 0;\n    char  cont    = 1;\n\n#ifdef DEBUG\n    if (octetCount != NULL)\n    {\n        fprintf (stderr, \""dissect_wap: Starting tvb_get_guintvar at offset %d, count=%d\\n\"", offset, *octetCount);\n        /* counter = *octetCount; */\n    }\n    else\n    {\n        fprintf (stderr, \""dissect_wap: Starting tvb_get_guintvar at offset %d, count=NULL\\n\"", offset);\n    }\n#endif\n\n    while (cont != 0)\n    {\n        value <<= 7;  /* Value only exists in 7 of the 8 bits */\n        octet = tvb_get_guint8 (tvb, offset+counter);\n        counter += 1;\n        value   += (octet & 0x7F);\n        cont = (octet & 0x80);\n#ifdef DEBUG\n        fprintf (stderr, \""dissect_wap: computing: octet is %d (0x%02x), count=%d, value=%d, cont=%d\\n\"",\n                 octet, octet, counter, value, cont);\n#endif\n    }\n\n    if (counter > 5) {\n        proto_tree_add_expert(NULL, pinfo, ei, tvb, offset, counter);\n        value = 0;\n    }\n    if (octetCount != NULL)\n    {\n        *octetCount = counter;\n#ifdef DEBUG\n        fprintf (stderr, \""dissect_wap: Leaving tvb_get_guintvar count=%d, value=%u\\n\"", *octetCount, value);\n#endif\n    }\n\n    return (value);\n}\n"", ""start_line"": 40, ""end_line"": 86, ""full_name"": ""tvb_get_guintvar"", ""file_path"": ""epan/dissectors/packet-wap.c""}]}, {""source"": ""value_info(file:packet-wbxml.c, value:tvb_len)"", ""result"": {""value_trace"": [{""full_code"": ""tvb_len = tvb_reported_length (tvb)"", ""line"": 7056, ""func_name"": ""parse_wbxml_attribute_list_defined""}, {""full_code"": ""tvb_len  = tvb_reported_length (tvb)"", ""line"": 7321, ""func_name"": ""parse_wbxml_tag_defined""}], ""struct_var"": ""tvb_len"", ""struct_type"": ""guint32"", ""struct_definition"": ""static guint32\n\nstatic guint32\n\ntypedef unsigned int guint32;\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32\n\nguint32""}}]","Untrusted input from tvb_get_guintvar (epan/dissectors/packet-wap.c:40-86) returns variable-length integers without validating against tvb_len (derived from tvb_reported_length in epan/dissectors/packet-wbxml.c:7056 and 7321). This allows oversized idx/len values in parse_wbxml_attribute_list_defined (epan/dissectors/packet-wbxml.c:7229) and parse_wbxml_tag_defined (epan/dissectors/packet-wbxml.c:7493), causing infinite loops during data parsing. Patches added idx < tvb_len checks to limit processing to valid buffer ranges.",0.95,./github/other_context/CVE-2017-11410
33,CVE-2017-11409,CWE-834,c_cpp,"In Wireshark 2.0.0 to 2.0.13, the GPRS LLC dissector could go into a large loop. This was addressed in epan/dissectors/packet-gprs-llc.c by using a different integer data type.",https://github.com/wireshark/wireshark/commit/57b83bbbd76f543eb8d108919f13b662910bff9a,GPRS LLC: fix a variable overflow when decoding XID\n\nBug: 13603\nChange-Id: I135c5d6a9edff53ed4b7aa283c7293e22bd377e6\nReviewed-on: https://code.wireshark.org/review/22276\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>,1,"[{""func_name"": ""llc_gprs_dissect_xid"", ""file_path"": ""epan/dissectors/packet-gprs-llc.c"", ""func_code"": ""static void llc_gprs_dissect_xid(tvbuff_t *tvb,\n\t\t\t\t\t\t\t\t packet_info *pinfo,\n\t\t\t\t\t\t\t\t proto_item *llcgprs_tree)\n\n{\n\tguint8 xid_param_len = 0, byte1 = 0, byte2 = 0, item_len = 0, tmp = 0;\n\tguint16 location = 0;\n\tguint16 loop_counter = 0;\n\tproto_tree *uinfo_tree = NULL;\n\tproto_tree *xid_tree = NULL;\n\tguint16 info_len;\n\n\tinfo_len = tvb_reported_length(tvb);\n\n\txid_tree = proto_tree_add_subtree_format(llcgprs_tree, tvb, 0, info_len,\n\t\t\t\tett_ui, NULL, \""Information Field: Length = %u\"", info_len);\n\n\twhile (location < info_len)\n\t{\n\t\t/* parse the XID parameters */\n\t\tbyte1 = tvb_get_guint8(tvb, location);\n\n\t\tif (byte1 & 0x80)\n\t\t{\n\t\t\tguint8 xid_param_len_high = 0;\n\t\t\tguint8 xid_param_len_low = 0;\n\t\t\tbyte2 = tvb_get_guint8(tvb, location + 1);\n\n\t\t\t/* XL bit is set - length is continued in second byte */\n\t\t\txid_param_len_high = byte1 & 0x03;\n\t\t\txid_param_len_low = byte2 & 0xFC;\n\n\t\t\t/* bit shift the rest of the length */\n\t\t\txid_param_len_low = xid_param_len_low >> 2;\n\t\t\txid_param_len_low = xid_param_len_low & 0x3F;\n\n\t\t\txid_param_len_high = xid_param_len_high << 6;\n\t\t\txid_param_len_high = xid_param_len_high & 0xC0;\n\n\t\t\t/* combine the two */\n\t\t\txid_param_len = xid_param_len_high | xid_param_len_low;\n\t\t\titem_len = xid_param_len + 2;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\txid_param_len = byte1 & 0x3;\n\t\t\titem_len = xid_param_len + 1;\n\t\t}\n\n\t\ttmp =  byte1 & 0x7C;\n\t\ttmp = tmp >> 2;\n\n\t\tif (tmp == 0xB) /* L3 XID parameters, call the SNDCP-XID dissector */\n\t\t{\n\t\t\ttvbuff_t\t*sndcp_xid_tvb;\n\t\t\tguint8 sndcp_xid_offset;\n\n\t\t\tuinfo_tree = proto_tree_add_subtree(xid_tree, tvb, location, item_len,\n\t\t\t\tett_ui, NULL, \""XID parameter Type: L3 parameters\"");\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location, 1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location, 1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location, 1, byte1);\n\t\t\tif (byte1 & 0x80) {\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location+1, 1, byte2);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location+1, 1, byte2);\n\t\t\t\tsndcp_xid_offset = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsndcp_xid_offset = 1;\n\t\t\t}\n\n\t\t\tif (xid_param_len) {\n\n\t\t\t\tsndcp_xid_tvb = tvb_new_subset_length (tvb, location+sndcp_xid_offset, xid_param_len);\n\n\t\t\t\tif(sndcp_xid_handle)\n\t\t\t\t{\n\t\t\t\t\tcall_dissector(sndcp_xid_handle, sndcp_xid_tvb, pinfo, uinfo_tree);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlocation += item_len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (( xid_param_len > 0 ) && ( xid_param_len <=4 ))\n\t\t\t{\n\t\t\t\tguint32 value = 0;\n\t\t\t\tguint8 i;\n\t\t\t\tfor (i=1;i<=xid_param_len;i++)\n\t\t\t\t{\n\t\t\t\t\tvalue <<= 8;\n\t\t\t\t\tvalue |= (guint32)tvb_get_guint8(tvb, location+i );\n\t\t\t\t}\n\t\t\t\tuinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,\n\t\t\t\t\tett_ui, NULL, \""XID Parameter Type: %s - Value: %u\"",\n\t\t\t\t\tval_to_str_ext_const(tmp, &xid_param_type_str_ext, \""Reserved Type:%X\""), value);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,\n\t\t\t\t\tett_ui, NULL, \""XID Parameter Type: %s\"",\n\t\t\t\t\tval_to_str_ext_const(tmp, &xid_param_type_str_ext, \""Reserved Type:%X\""));\n\t\t\t}\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location,\n\t\t\t\t1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location,\n\t\t\t\t1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location,\n\t\t\t\t1, byte1);\n\n\t\t\tif (byte1 & 0x80) {\n\t\t\t\t/* length continued into byte 2 */\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location,\n\t\t\t\t\t1, byte2);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location,\n\t\t\t\t\t1, byte2);\n\n\t\t\t\t/* be sure to account for the second byte of length */\n\t\t\t\tlocation++;\n\t\t\t}\n\n\t\t\tlocation++;\n\t\t\tfor (loop_counter = 0; loop_counter < xid_param_len; loop_counter++)\n\t\t\t{\n\t\t\t\t/* grab the information in the XID param */\n\t\t\t\tbyte2 = tvb_get_guint8(tvb, location);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_byte, tvb, location,\n\t\t\t\t\t1, byte2);\n\t\t\t\tlocation++;\n\t\t\t}\n\t\t}\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""llc_gprs_dissect_xid"", ""file_path"": ""epan/dissectors/packet-gprs-llc.c"", ""func_code"": ""static void llc_gprs_dissect_xid(tvbuff_t *tvb,\n\t\t\t\t\t\t\t\t packet_info *pinfo,\n\t\t\t\t\t\t\t\t proto_item *llcgprs_tree)\n\n{\n\tguint8 xid_param_len = 0, byte1 = 0, byte2 = 0, tmp = 0;\n\tguint16 location = 0;\n\tguint16 loop_counter = 0;\n\tproto_tree *uinfo_tree = NULL;\n\tproto_tree *xid_tree = NULL;\n\tguint16 info_len, item_len;\n\n\tinfo_len = tvb_reported_length(tvb);\n\n\txid_tree = proto_tree_add_subtree_format(llcgprs_tree, tvb, 0, info_len,\n\t\t\t\tett_ui, NULL, \""Information Field: Length = %u\"", info_len);\n\n\twhile (location < info_len)\n\t{\n\t\t/* parse the XID parameters */\n\t\tbyte1 = tvb_get_guint8(tvb, location);\n\n\t\tif (byte1 & 0x80)\n\t\t{\n\t\t\tguint8 xid_param_len_high = 0;\n\t\t\tguint8 xid_param_len_low = 0;\n\t\t\tbyte2 = tvb_get_guint8(tvb, location + 1);\n\n\t\t\t/* XL bit is set - length is continued in second byte */\n\t\t\txid_param_len_high = byte1 & 0x03;\n\t\t\txid_param_len_low = byte2 & 0xFC;\n\n\t\t\t/* bit shift the rest of the length */\n\t\t\txid_param_len_low = xid_param_len_low >> 2;\n\t\t\txid_param_len_low = xid_param_len_low & 0x3F;\n\n\t\t\txid_param_len_high = xid_param_len_high << 6;\n\t\t\txid_param_len_high = xid_param_len_high & 0xC0;\n\n\t\t\t/* combine the two */\n\t\t\txid_param_len = xid_param_len_high | xid_param_len_low;\n\t\t\titem_len = xid_param_len + 2;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\txid_param_len = byte1 & 0x3;\n\t\t\titem_len = xid_param_len + 1;\n\t\t}\n\n\t\ttmp =  byte1 & 0x7C;\n\t\ttmp = tmp >> 2;\n\n\t\tif (tmp == 0xB) /* L3 XID parameters, call the SNDCP-XID dissector */\n\t\t{\n\t\t\ttvbuff_t\t*sndcp_xid_tvb;\n\t\t\tguint8 sndcp_xid_offset;\n\n\t\t\tuinfo_tree = proto_tree_add_subtree(xid_tree, tvb, location, item_len,\n\t\t\t\tett_ui, NULL, \""XID parameter Type: L3 parameters\"");\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location, 1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location, 1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location, 1, byte1);\n\t\t\tif (byte1 & 0x80) {\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location+1, 1, byte2);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location+1, 1, byte2);\n\t\t\t\tsndcp_xid_offset = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsndcp_xid_offset = 1;\n\t\t\t}\n\n\t\t\tif (xid_param_len) {\n\n\t\t\t\tsndcp_xid_tvb = tvb_new_subset_length (tvb, location+sndcp_xid_offset, xid_param_len);\n\n\t\t\t\tif(sndcp_xid_handle)\n\t\t\t\t{\n\t\t\t\t\tcall_dissector(sndcp_xid_handle, sndcp_xid_tvb, pinfo, uinfo_tree);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlocation += item_len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (( xid_param_len > 0 ) && ( xid_param_len <=4 ))\n\t\t\t{\n\t\t\t\tguint32 value = 0;\n\t\t\t\tguint8 i;\n\t\t\t\tfor (i=1;i<=xid_param_len;i++)\n\t\t\t\t{\n\t\t\t\t\tvalue <<= 8;\n\t\t\t\t\tvalue |= (guint32)tvb_get_guint8(tvb, location+i );\n\t\t\t\t}\n\t\t\t\tuinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,\n\t\t\t\t\tett_ui, NULL, \""XID Parameter Type: %s - Value: %u\"",\n\t\t\t\t\tval_to_str_ext_const(tmp, &xid_param_type_str_ext, \""Reserved Type:%X\""), value);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,\n\t\t\t\t\tett_ui, NULL, \""XID Parameter Type: %s\"",\n\t\t\t\t\tval_to_str_ext_const(tmp, &xid_param_type_str_ext, \""Reserved Type:%X\""));\n\t\t\t}\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location,\n\t\t\t\t1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location,\n\t\t\t\t1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location,\n\t\t\t\t1, byte1);\n\n\t\t\tif (byte1 & 0x80) {\n\t\t\t\t/* length continued into byte 2 */\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location,\n\t\t\t\t\t1, byte2);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location,\n\t\t\t\t\t1, byte2);\n\n\t\t\t\t/* be sure to account for the second byte of length */\n\t\t\t\tlocation++;\n\t\t\t}\n\n\t\t\tlocation++;\n\t\t\tfor (loop_counter = 0; loop_counter < xid_param_len; loop_counter++)\n\t\t\t{\n\t\t\t\t/* grab the information in the XID param */\n\t\t\t\tbyte2 = tvb_get_guint8(tvb, location);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_byte, tvb, location,\n\t\t\t\t\t1, byte2);\n\t\t\t\tlocation++;\n\t\t\t}\n\t\t}\n\t}\n}""}]","{""code"": 3}","[{""source"": ""code_info(file:packet-gprs-llc.c, lines:330-360)"", ""result"": ""\tguint16 loop_counter = 0;\n\tproto_tree *uinfo_tree = NULL;\n\tproto_tree *xid_tree = NULL;\n\tguint16 info_len;\n\n\tinfo_len = tvb_reported_length(tvb);\n\n\txid_tree = proto_tree_add_subtree_format(llcgprs_tree, tvb, 0, info_len,\n\t\t\t\tett_ui, NULL, \""Information Field: Length = %u\"", info_len);\n\n\twhile (location < info_len)\n\t{\n\t\t/* parse the XID parameters */\n\t\tbyte1 = tvb_get_guint8(tvb, location);\n\n\t\tif (byte1 & 0x80)\n\t\t{\n\t\t\tguint8 xid_param_len_high = 0;\n\t\t\tguint8 xid_param_len_low = 0;\n\t\t\tbyte2 = tvb_get_guint8(tvb, location + 1);\n\n\t\t\t/* XL bit is set - length is continued in second byte */\n\t\t\txid_param_len_high = byte1 & 0x03;\n\t\t\txid_param_len_low = byte2 & 0xFC;\n\n\t\t\t/* bit shift the rest of the length */\n\t\t\txid_param_len_low = xid_param_len_low >> 2;\n\t\t\txid_param_len_low = xid_param_len_low & 0x3F;\n\n\t\t\txid_param_len_high = xid_param_len_high << 6;\n\t\t\txid_param_len_high = xid_param_len_high & 0xC0;\n""}, {""source"": ""code_info(file:packet-gprs-llc.c, lines:361-400)"", ""result"": ""\n\t\t\t/* combine the two */\n\t\t\txid_param_len = xid_param_len_high | xid_param_len_low;\n\t\t\titem_len = xid_param_len + 2;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\txid_param_len = byte1 & 0x3;\n\t\t\titem_len = xid_param_len + 1;\n\t\t}\n\n\t\ttmp =  byte1 & 0x7C;\n\t\ttmp = tmp >> 2;\n\n\t\tif (tmp == 0xB) /* L3 XID parameters, call the SNDCP-XID dissector */\n\t\t{\n\t\t\ttvbuff_t\t*sndcp_xid_tvb;\n\t\t\tguint8 sndcp_xid_offset;\n\n\t\t\tuinfo_tree = proto_tree_add_subtree(xid_tree, tvb, location, item_len,\n\t\t\t\tett_ui, NULL, \""XID parameter Type: L3 parameters\"");\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location, 1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location, 1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location, 1, byte1);\n\t\t\tif (byte1 & 0x80) {\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location+1, 1, byte2);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location+1, 1, byte2);\n\t\t\t\tsndcp_xid_offset = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsndcp_xid_offset = 1;\n\t\t\t}\n\n\t\t\tif (xid_param_len) {\n\n\t\t\t\tsndcp_xid_tvb = tvb_new_subset_length (tvb, location+sndcp_xid_offset, xid_param_len);\n\n\t\t\t\tif(sndcp_xid_handle)\n""}, {""source"": ""code_info(file:packet-gprs-llc.c, lines:401-440)"", ""result"": ""\t\t\t\t{\n\t\t\t\t\tcall_dissector(sndcp_xid_handle, sndcp_xid_tvb, pinfo, uinfo_tree);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlocation += item_len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (( xid_param_len > 0 ) && ( xid_param_len <=4 ))\n\t\t\t{\n\t\t\t\tguint32 value = 0;\n\t\t\t\tguint8 i;\n\t\t\t\tfor (i=1;i<=xid_param_len;i++)\n\t\t\t\t{\n\t\t\t\t\tvalue <<= 8;\n\t\t\t\t\tvalue |= (guint32)tvb_get_guint8(tvb, location+i );\n\t\t\t\t}\n\t\t\t\tuinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,\n\t\t\t\t\tett_ui, NULL, \""XID Parameter Type: %s - Value: %u\"",\n\t\t\t\t\tval_to_str_ext_const(tmp, &xid_param_type_str_ext, \""Reserved Type:%X\""), value);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,\n\t\t\t\t\tett_ui, NULL, \""XID Parameter Type: %s\"",\n\t\t\t\t\tval_to_str_ext_const(tmp, &xid_param_type_str_ext, \""Reserved Type:%X\""));\n\t\t\t}\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location,\n\t\t\t\t1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location,\n\t\t\t\t1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location,\n\t\t\t\t1, byte1);\n\n\t\t\tif (byte1 & 0x80) {\n\t\t\t\t/* length continued into byte 2 */\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location,\n\t\t\t\t\t1, byte2);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location,\n""}]","In epan/dissectors/packet-gprs-llc.c:326-327, 'item_len' was originally declared as guint8. During XID decoding (lines 361-400), 'item_len' is calculated as 'xid_param_len + 2' (XL case) or 'xid_param_len + 1'. If 'xid_param_len' exceeds 253, 'item_len' overflows to a small value (e.g., 255 + 2 = 257  1 as guint8). The loop 'while (location < info_len)' (line 330) increments 'location' by 'item_len' (line 401-440: 'location += item_len;'), but the overflowed 'item_len' causes 'location' to advance too slowly or not at all, leading to an infinite loop. The patch changes 'item_len' to guint16 (line 327) to prevent overflow.",0.95,./github/other_context/CVE-2017-11409
34,CVE-2017-11360,CWE-834,c_cpp,The ReadRLEImage function in coders\rle.c in ImageMagick 7.0.6-1 has a large loop vulnerability via a crafted rle file that triggers a huge number_pixels value.,https://github.com/ImageMagick/ImageMagick/commit/078e9692a257e7a8aa36ccc750927f9617923061,https://github.com/ImageMagick/ImageMagick/issues/518,2,"[{""func_name"": ""ReadRLEImage"", ""file_path"": ""coders/rle.c"", ""func_code"": ""static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n#define ThrowRLEException(exception,message) \\\n{ \\\n  if (colormap != (unsigned char *) NULL) \\\n    colormap=(unsigned char *) RelinquishMagickMemory(colormap); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  colormap=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\""\\122\\314\"",2) != 0))\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=(ssize_t) ReadBlobLSBShort(image);\n    image->page.y=(ssize_t) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 22)\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n          {\n            *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(\n              ReadBlobLSBShort(image)));\n            if (EOFBlob(image) != MagickFalse)\n              ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          }\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\""comment\"",comment,exception);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate RLE pixels.\n    */\n    if (image->alpha_trait != UndefinedPixelTrait)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n      number_planes+1;\n    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n         number_planes_filled))\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n      MagickMax(number_planes_filled,4)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    pixel_info_length=image->columns*image->rows*\n      MagickMax(number_planes_filled,4);\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,pixel_info_length);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    if (opcode == EOF)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n            }\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n            }\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n            }\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n          operand++;\n          if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n            }\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n          operand++;\n          if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n      if (opcode == EOF)\n        ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            ValidateColormapValue(image,(ssize_t) (*p & mask),&index,exception);\n            *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) (x*map_length+\n                  (*p & mask)),&index,exception);\n                *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum(*p);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->alpha_trait == UndefinedPixelTrait)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(image,(Quantum) *p++,q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image,exception);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].red),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].green),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].blue),q);\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n                q+=GetPixelChannels(image);\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelInfo *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\""\\122\\314\"",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\""\\122\\314\"",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}"", ""target"": 0}, {""func_name"": ""RegisterRLEImage"", ""file_path"": ""coders/rle.c"", ""func_code"": ""ModuleExport size_t RegisterRLEImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\""RLE\"",\""RLE\"",\""Utah Run length encoded image\"");\n  entry->decoder=(DecodeImageHandler *) ReadRLEImage;\n  entry->magick=(IsImageFormatHandler *) IsRLE;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}"", ""target"": 1}]","[{""func_name"": ""ReadRLEImage"", ""file_path"": ""coders/rle.c"", ""func_code"": ""static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n#define ThrowRLEException(exception,message) \\\n{ \\\n  if (colormap != (unsigned char *) NULL) \\\n    colormap=(unsigned char *) RelinquishMagickMemory(colormap); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  colormap=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\""\\122\\314\"",2) != 0))\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=(ssize_t) ReadBlobLSBShort(image);\n    image->page.y=(ssize_t) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 22)\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    if (image->alpha_trait != UndefinedPixelTrait)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((GetBlobSize(image) == 0) || ((((MagickSizeType) number_pixels*\n         number_planes*bits_per_pixel/8)/GetBlobSize(image)) > 254.0))\n      ThrowRLEException(CorruptImageError,\""InsufficientImageDataInFile\"")\n    if (((MagickSizeType) number_colormaps*map_length) > GetBlobSize(image))\n      ThrowRLEException(CorruptImageError,\""InsufficientImageDataInFile\"")\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n          {\n            *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(\n              ReadBlobLSBShort(image)));\n            if (EOFBlob(image) != MagickFalse)\n              ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          }\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\""comment\"",comment,exception);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate RLE pixels.\n    */\n    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n      number_planes+1;\n    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n         number_planes_filled))\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n      MagickMax(number_planes_filled,4)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    pixel_info_length=image->columns*image->rows*\n      MagickMax(number_planes_filled,4);\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,pixel_info_length);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    if (opcode == EOF)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n            }\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n            }\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n            }\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n          operand++;\n          if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n            }\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n          operand++;\n          if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n      if (opcode == EOF)\n        ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            ValidateColormapValue(image,(ssize_t) (*p & mask),&index,exception);\n            *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) (x*map_length+\n                  (*p & mask)),&index,exception);\n                *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\""UnableToReadImageData\"");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum(*p);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->alpha_trait == UndefinedPixelTrait)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(image,(Quantum) *p++,q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image,exception);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].red),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].green),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].blue),q);\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n                q+=GetPixelChannels(image);\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelInfo *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\""UnexpectedEndOfFile\"",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\""\\122\\314\"",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\""\\122\\314\"",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}""}, {""func_name"": ""RegisterRLEImage"", ""file_path"": ""coders/rle.c"", ""func_code"": ""ModuleExport size_t RegisterRLEImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\""RLE\"",\""RLE\"",\""Utah Run length encoded image\"");\n  entry->decoder=(DecodeImageHandler *) ReadRLEImage;\n  entry->magick=(IsImageFormatHandler *) IsRLE;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}""}]","{""value"": 5, ""function"": 1, ""code"": 1}","[{""source"": ""value_info(file:rle.c, value:bits_per_pixel)"", ""result"": {""value_trace"": [{""full_code"": ""bits_per_pixel=(size_t) ReadBlobByte(image)"", ""line"": 234, ""func_name"": ""ReadRLEImage""}], ""struct_var"": ""bits_per_pixel"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}, {""source"": ""value_info(file:rle.c, value:number_planes)"", ""result"": {""value_trace"": [{""full_code"": ""number_planes=(size_t) ReadBlobByte(image)"", ""line"": 233, ""func_name"": ""ReadRLEImage""}, {""full_code"": ""number_planes++"", ""line"": 325, ""func_name"": ""ReadRLEImage""}], ""struct_var"": ""number_planes"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}, {""source"": ""value_info(file:rle.c, value:map_length)"", ""result"": {""value_trace"": [{""full_code"": ""map_length=(unsigned char) ReadBlobByte(image)"", ""line"": 236, ""func_name"": ""ReadRLEImage""}, {""full_code"": ""map_length=one << map_length"", ""line"": 242, ""func_name"": ""ReadRLEImage""}, {""full_code"": ""map_length=256"", ""line"": 568, ""func_name"": ""ReadRLEImage""}], ""struct_var"": ""map_length"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}, {""source"": ""func_info(func:GetBlobSize)"", ""result"": [{""code"": ""MagickExport MagickSizeType GetBlobSize(const Image *image)\n{\n  MagickSizeType\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  extent=0;\n  switch (image->blob->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n    {\n      extent=image->blob->size;\n      break;\n    }\n    case FileStream:\n    {\n      if (fstat(fileno(image->blob->file_info.file),&image->blob->properties) == 0)\n        extent=(MagickSizeType) image->blob->properties.st_size;\n      break;\n    }\n    case PipeStream:\n    {\n      extent=image->blob->size;\n      break;\n    }\n    case ZipStream:\n    case BZipStream:\n    {\n      MagickBooleanType\n        status;\n\n      status=GetPathAttributes(image->filename,&image->blob->properties);\n      if (status != MagickFalse)\n        extent=(MagickSizeType) image->blob->properties.st_size;\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      extent=(MagickSizeType) image->blob->length;\n      break;\n    }\n    case CustomStream:\n      break;\n  }\n  return(extent);\n}\n"", ""start_line"": 1471, ""end_line"": 1523, ""full_name"": ""GetBlobSize"", ""file_path"": ""MagickCore/blob.c""}]}, {""source"": ""value_info(file:rle.c, value:columns)"", ""result"": {""value_trace"": [{""full_code"": ""columns=(size_t) (length/cache_info->rows/packet_size)"", ""line"": 3497, ""func_name"": ""OpenPixelCache""}, {""full_code"": ""columns=MagickMax(image->columns,reconstruct_image->columns)"", ""line"": 178, ""func_name"": ""CompareImages""}, {""full_code"": ""columns=MagickMax(image->columns,reconstruct_image->columns)"", ""line"": 385, ""func_name"": ""GetAbsoluteDistortion""}, {""full_code"": ""columns=MagickMax(image->columns,reconstruct_image->columns)"", ""line"": 497, ""func_name"": ""GetFuzzDistortion""}, {""full_code"": ""columns=MagickMax(image->columns,reconstruct_image->columns)"", ""line"": 608, ""func_name"": ""GetMeanAbsoluteDistortion""}], ""struct_var"": ""columns"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}, {""source"": ""value_info(file:rle.c, value:rows)"", ""result"": {""value_trace"": [{""full_code"": ""rows=nexus_info->region.height"", ""line"": 4174, ""func_name"": ""ReadPixelCacheMetacontent""}, {""full_code"": ""rows=1UL"", ""line"": 4192, ""func_name"": ""ReadPixelCacheMetacontent""}, {""full_code"": ""rows=1UL"", ""line"": 4221, ""func_name"": ""ReadPixelCacheMetacontent""}, {""full_code"": ""rows=1UL"", ""line"": 4255, ""func_name"": ""ReadPixelCacheMetacontent""}, {""full_code"": ""rows=nexus_info->region.height"", ""line"": 4348, ""func_name"": ""ReadPixelCachePixels""}], ""struct_var"": ""rows"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}, {""source"": ""code_info(file:rle.c, lines:1-266)"", ""result"": ""/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            RRRR   L      EEEEE                              %\n%                            R   R  L      E                                  %\n%                            RRRR   L      EEE                                %\n%                            R R    L      E                                  %\n%                            R  R   LLLLL  EEEEE                              %\n%                                                                             %\n%                                                                             %\n%                          Read URT RLE Image Format                          %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \""AS IS\"" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \""MagickCore/studio.h\""\n#include \""MagickCore/blob.h\""\n#include \""MagickCore/blob-private.h\""\n#include \""MagickCore/cache.h\""\n#include \""MagickCore/colormap.h\""\n#include \""MagickCore/colormap-private.h\""\n#include \""MagickCore/exception.h\""\n#include \""MagickCore/exception-private.h\""\n#include \""MagickCore/image.h\""\n#include \""MagickCore/image-private.h\""\n#include \""MagickCore/list.h\""\n#include \""MagickCore/magick.h\""\n#include \""MagickCore/memory_.h\""\n#include \""MagickCore/monitor.h\""\n#include \""MagickCore/monitor-private.h\""\n#include \""MagickCore/pixel-accessor.h\""\n#include \""MagickCore/pixel.h\""\n#include \""MagickCore/property.h\""\n#include \""MagickCore/quantum-private.h\""\n#include \""MagickCore/static.h\""\n#include \""MagickCore/string_.h\""\n#include \""MagickCore/module.h\""\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s R L E                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsRLE() returns MagickTrue if the image format type, identified by the\n%  magick string, is RLE.\n%\n%  The format of the ReadRLEImage method is:\n%\n%      MagickBooleanType IsRLE(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n%\n*/\nstatic MagickBooleanType IsRLE(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\""\\122\\314\"",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d R L E I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadRLEImage() reads a run-length encoded Utah Raster Toolkit\n%  image file and returns it.  It allocates the memory necessary for the new\n%  Image structure and returns a pointer to the new image.\n%\n%  The format of the ReadRLEImage method is:\n%\n%      Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%\n*/\nstatic Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n#define ThrowRLEException(exception,message) \\\n{ \\\n  if (colormap != (unsigned char *) NULL) \\\n    colormap=(unsigned char *) RelinquishMagickMemory(colormap); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  colormap=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\""\\122\\314\"",2) != 0))\n    ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=(ssize_t) ReadBlobLSBShort(image);\n    image->page.y=(ssize_t) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 22)\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\""UnexpectedEndOfFile\"");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n""}]","coders/rle.c: In ReadRLEImage, 'columns' and 'rows' are read from the RLE header via ReadBlobLSBShort without validation (lines where image->columns=ReadBlobLSBShort(image); image->rows=ReadBlobLSBShort(image)). This allows crafted RLE files to set arbitrarily large values. The original code calculated number_pixels = columns * rows (coders/rle.c:267-274) without comparing against the blob size, leading to excessive loop iterations during processing. The patch added checks for number_pixels against GetBlobSize, but the vulnerability existed due to missing input validation on columns/rows.",0.95,./github/other_context/CVE-2017-11360
35,CVE-2017-12136,CWE-362,c_cpp,Race condition in the grant table code in Xen 4.6.x through 4.9.x allows local guest OS administrators to cause a denial of service (free list corruption and host crash) or gain privileges on the host via vectors involving maptrack free list handling.,https://github.com/xen-project/xen/commit/02cbeeb6207508b0f04a2c6181445c8eb3f1e117,"gnttab: split maptrack lock to make it fulfill its purpose again\n\nThe way the lock is currently being used in get_maptrack_handle(), it\nprotects only the maptrack limit: The function acts on current's list\nonly, so races on list accesses are impossible even without the lock.\n\nOtoh list access races are possible between __get_maptrack_handle() and\nput_maptrack_handle(), due to the invocation of the former for other\nthan current from steal_maptrack_handle(). Introduce a per-vCPU lock\nfor list accesses to become race free again. This lock will be\nuncontended except when it becomes necessary to take the steal path,\ni.e. in the common case there should be no meaningful performance\nimpact.\n\nWhen in get_maptrack_handle adds a stolen entry to a fresh, empty,\nfreelist, we think that there is probably no concurrency.  However,\nthis is not a fast path and adding the locking there makes the code\nclearly correct.\n\nAlso, while we are here: the stolen maptrack_entry's tail pointer was\nnot properly set.  Set it.\n\nThis is CVE-2017-12136 / XSA-228.\n\nReported-by: Ian Jackson <ian.jackson@eu.citrix.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nSigned-off-by: Ian Jackson <Ian.Jackson@eu.citrix.com>",4,"[{""func_name"": ""__get_maptrack_handle"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""static inline int\n__get_maptrack_handle(\n    struct grant_table *t,\n    struct vcpu *v)\n{\n    unsigned int head, next, prev_head;\n\n    do {\n        /* No maptrack pages allocated for this VCPU yet? */\n        head = read_atomic(&v->maptrack_head);\n        if ( unlikely(head == MAPTRACK_TAIL) )\n            return -1;\n\n        /*\n         * Always keep one entry in the free list to make it easier to\n         * add free entries to the tail.\n         */\n        next = read_atomic(&maptrack_entry(t, head).ref);\n        if ( unlikely(next == MAPTRACK_TAIL) )\n            return -1;\n\n        prev_head = head;\n        head = cmpxchg(&v->maptrack_head, prev_head, next);\n    } while ( head != prev_head );\n\n    return head;\n}"", ""target"": 0}, {""func_name"": ""grant_table_init_vcpu"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""void grant_table_init_vcpu(struct vcpu *v)\n{\n    v->maptrack_head = MAPTRACK_TAIL;\n    v->maptrack_tail = MAPTRACK_TAIL;\n}"", ""target"": 0}, {""func_name"": ""put_maptrack_handle"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""static inline void\nput_maptrack_handle(\n    struct grant_table *t, int handle)\n{\n    struct domain *currd = current->domain;\n    struct vcpu *v;\n    unsigned int prev_tail, cur_tail;\n\n    /* 1. Set entry to be a tail. */\n    maptrack_entry(t, handle).ref = MAPTRACK_TAIL;\n\n    /* 2. Add entry to the tail of the list on the original VCPU. */\n    v = currd->vcpu[maptrack_entry(t, handle).vcpu];\n\n    cur_tail = read_atomic(&v->maptrack_tail);\n    do {\n        prev_tail = cur_tail;\n        cur_tail = cmpxchg(&v->maptrack_tail, prev_tail, handle);\n    } while ( cur_tail != prev_tail );\n\n    /* 3. Update the old tail entry to point to the new entry. */\n    write_atomic(&maptrack_entry(t, prev_tail).ref, handle);\n}"", ""target"": 0}, {""func_name"": ""get_maptrack_handle"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""static inline int\nget_maptrack_handle(\n    struct grant_table *lgt)\n{\n    struct vcpu          *curr = current;\n    unsigned int          i, head;\n    grant_handle_t        handle;\n    struct grant_mapping *new_mt;\n\n    handle = __get_maptrack_handle(lgt, curr);\n    if ( likely(handle != -1) )\n        return handle;\n\n    spin_lock(&lgt->maptrack_lock);\n\n    /*\n     * If we've run out of frames, try stealing an entry from another\n     * VCPU (in case the guest isn't mapping across its VCPUs evenly).\n     */\n    if ( nr_maptrack_frames(lgt) >= max_maptrack_frames )\n    {\n        /*\n         * Can drop the lock since no other VCPU can be adding a new\n         * frame once they've run out.\n         */\n        spin_unlock(&lgt->maptrack_lock);\n\n        /*\n         * Uninitialized free list? Steal an extra entry for the tail\n         * sentinel.\n         */\n        if ( curr->maptrack_tail == MAPTRACK_TAIL )\n        {\n            handle = steal_maptrack_handle(lgt, curr);\n            if ( handle == -1 )\n                return -1;\n            curr->maptrack_tail = handle;\n            write_atomic(&curr->maptrack_head, handle);\n        }\n        return steal_maptrack_handle(lgt, curr);\n    }\n\n    new_mt = alloc_xenheap_page();\n    if ( !new_mt )\n    {\n        spin_unlock(&lgt->maptrack_lock);\n        return -1;\n    }\n    clear_page(new_mt);\n\n    /*\n     * Use the first new entry and add the remaining entries to the\n     * head of the free list.\n     */\n    handle = lgt->maptrack_limit;\n\n    for ( i = 0; i < MAPTRACK_PER_PAGE; i++ )\n    {\n        new_mt[i].ref = handle + i + 1;\n        new_mt[i].vcpu = curr->vcpu_id;\n    }\n\n    /* Set tail directly if this is the first page for this VCPU. */\n    if ( curr->maptrack_tail == MAPTRACK_TAIL )\n        curr->maptrack_tail = handle + MAPTRACK_PER_PAGE - 1;\n\n    lgt->maptrack[nr_maptrack_frames(lgt)] = new_mt;\n    smp_wmb();\n    lgt->maptrack_limit += MAPTRACK_PER_PAGE;\n\n    do {\n        new_mt[i - 1].ref = read_atomic(&curr->maptrack_head);\n        head = cmpxchg(&curr->maptrack_head, new_mt[i - 1].ref, handle + 1);\n    } while ( head != new_mt[i - 1].ref );\n\n    spin_unlock(&lgt->maptrack_lock);\n\n    return handle;\n}"", ""target"": 0}]","[{""func_name"": ""__get_maptrack_handle"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""static inline int\n__get_maptrack_handle(\n    struct grant_table *t,\n    struct vcpu *v)\n{\n    unsigned int head, next, prev_head;\n\n    spin_lock(&v->maptrack_freelist_lock);\n\n    do {\n        /* No maptrack pages allocated for this VCPU yet? */\n        head = read_atomic(&v->maptrack_head);\n        if ( unlikely(head == MAPTRACK_TAIL) )\n        {\n            spin_unlock(&v->maptrack_freelist_lock);\n            return -1;\n        }\n\n        /*\n         * Always keep one entry in the free list to make it easier to\n         * add free entries to the tail.\n         */\n        next = read_atomic(&maptrack_entry(t, head).ref);\n        if ( unlikely(next == MAPTRACK_TAIL) )\n        {\n            spin_unlock(&v->maptrack_freelist_lock);\n            return -1;\n        }\n\n        prev_head = head;\n        head = cmpxchg(&v->maptrack_head, prev_head, next);\n    } while ( head != prev_head );\n\n    spin_unlock(&v->maptrack_freelist_lock);\n\n    return head;\n}""}, {""func_name"": ""grant_table_init_vcpu"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""void grant_table_init_vcpu(struct vcpu *v)\n{\n    spin_lock_init(&v->maptrack_freelist_lock);\n    v->maptrack_head = MAPTRACK_TAIL;\n    v->maptrack_tail = MAPTRACK_TAIL;\n}""}, {""func_name"": ""put_maptrack_handle"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""static inline void\nput_maptrack_handle(\n    struct grant_table *t, int handle)\n{\n    struct domain *currd = current->domain;\n    struct vcpu *v;\n    unsigned int prev_tail, cur_tail;\n\n    /* 1. Set entry to be a tail. */\n    maptrack_entry(t, handle).ref = MAPTRACK_TAIL;\n\n    /* 2. Add entry to the tail of the list on the original VCPU. */\n    v = currd->vcpu[maptrack_entry(t, handle).vcpu];\n\n    spin_lock(&v->maptrack_freelist_lock);\n\n    cur_tail = read_atomic(&v->maptrack_tail);\n    do {\n        prev_tail = cur_tail;\n        cur_tail = cmpxchg(&v->maptrack_tail, prev_tail, handle);\n    } while ( cur_tail != prev_tail );\n\n    /* 3. Update the old tail entry to point to the new entry. */\n    write_atomic(&maptrack_entry(t, prev_tail).ref, handle);\n\n    spin_unlock(&v->maptrack_freelist_lock);\n}""}, {""func_name"": ""get_maptrack_handle"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""static inline int\nget_maptrack_handle(\n    struct grant_table *lgt)\n{\n    struct vcpu          *curr = current;\n    unsigned int          i, head;\n    grant_handle_t        handle;\n    struct grant_mapping *new_mt;\n\n    handle = __get_maptrack_handle(lgt, curr);\n    if ( likely(handle != -1) )\n        return handle;\n\n    spin_lock(&lgt->maptrack_lock);\n\n    /*\n     * If we've run out of frames, try stealing an entry from another\n     * VCPU (in case the guest isn't mapping across its VCPUs evenly).\n     */\n    if ( nr_maptrack_frames(lgt) >= max_maptrack_frames )\n    {\n        spin_unlock(&lgt->maptrack_lock);\n\n        /*\n         * Uninitialized free list? Steal an extra entry for the tail\n         * sentinel.\n         */\n        if ( curr->maptrack_tail == MAPTRACK_TAIL )\n        {\n            handle = steal_maptrack_handle(lgt, curr);\n            if ( handle == -1 )\n                return -1;\n            spin_lock(&curr->maptrack_freelist_lock);\n            maptrack_entry(lgt, handle).ref = MAPTRACK_TAIL;\n            curr->maptrack_tail = handle;\n            if ( curr->maptrack_head == MAPTRACK_TAIL )\n                write_atomic(&curr->maptrack_head, handle);\n            spin_unlock(&curr->maptrack_freelist_lock);\n        }\n        return steal_maptrack_handle(lgt, curr);\n    }\n\n    new_mt = alloc_xenheap_page();\n    if ( !new_mt )\n    {\n        spin_unlock(&lgt->maptrack_lock);\n        return -1;\n    }\n    clear_page(new_mt);\n\n    /*\n     * Use the first new entry and add the remaining entries to the\n     * head of the free list.\n     */\n    handle = lgt->maptrack_limit;\n\n    for ( i = 0; i < MAPTRACK_PER_PAGE; i++ )\n    {\n        new_mt[i].ref = handle + i + 1;\n        new_mt[i].vcpu = curr->vcpu_id;\n    }\n\n    /* Set tail directly if this is the first page for this VCPU. */\n    if ( curr->maptrack_tail == MAPTRACK_TAIL )\n        curr->maptrack_tail = handle + MAPTRACK_PER_PAGE - 1;\n\n    lgt->maptrack[nr_maptrack_frames(lgt)] = new_mt;\n    smp_wmb();\n    lgt->maptrack_limit += MAPTRACK_PER_PAGE;\n\n    spin_unlock(&lgt->maptrack_lock);\n    spin_lock(&curr->maptrack_freelist_lock);\n\n    do {\n        new_mt[i - 1].ref = read_atomic(&curr->maptrack_head);\n        head = cmpxchg(&curr->maptrack_head, new_mt[i - 1].ref, handle + 1);\n    } while ( head != new_mt[i - 1].ref );\n\n    spin_unlock(&curr->maptrack_freelist_lock);\n\n    return handle;\n}""}]","{""function"": 1}","[{""source"": ""func_info(func:steal_maptrack_handle)"", ""result"": [{""code"": ""static int steal_maptrack_handle(struct grant_table *t,\n                                 const struct vcpu *curr)\n{\n    const struct domain *currd = curr->domain;\n    unsigned int first, i;\n\n    /* Find an initial victim. */\n    first = i = get_random() % currd->max_vcpus;\n\n    do {\n        if ( currd->vcpu[i] )\n        {\n            int handle;\n\n            handle = __get_maptrack_handle(t, currd->vcpu[i]);\n            if ( handle != -1 )\n            {\n                maptrack_entry(t, handle).vcpu = curr->vcpu_id;\n                return handle;\n            }\n        }\n\n        i++;\n        if ( i == currd->max_vcpus )\n            i = 0;\n    } while ( i != first );\n\n    /* No free handles on any VCPU. */\n    return -1;\n}"", ""start_line"": 338, ""end_line"": 367, ""full_name"": ""steal_maptrack_handle"", ""file_path"": ""xen/common/grant_table.c""}]}]","Prior to the patch, `__get_maptrack_handle()` and `put_maptrack_handle()` modified shared `maptrack_head`/`maptrack_tail` without proper locking when called concurrently (e.g., via `steal_maptrack_handle()`). This allowed race conditions during free list allocation/freeing, leading to corruption. The fix adds `spin_lock(&v->maptrack_freelist_lock)` in both functions (grant_table.c:305-322, 381-391). `steal_maptrack_handle()` (grant_table.c:338-367) triggers the race by invoking `__get_maptrack_handle()` on non-current vCPUs, which now acquires the per-vCPU lock.",0.95,./github/other_context/CVE-2017-12136
36,CVE-2017-14055,CWE-834,c_cpp,"In libavformat/mvdec.c in FFmpeg 3.3.3, a DoS in mv_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MV file, which claims a large ""nb_frames"" field in the header but does not contain sufficient backing data, is provided, the loop over the frames would consume huge CPU and memory resources, since there is no EOF check inside the loop.",https://github.com/FFmpeg/FFmpeg/commit/4f05e2e2dc1a89f38cd9f0960a6561083d714f1e,avformat/mvdec: Fix DoS due to lack of eof check\n\nFixes: loop.mv\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>,1,"[{""func_name"": ""mv_read_header"", ""file_path"": ""libavformat/mvdec.c"", ""func_code"": ""static int mv_read_header(AVFormatContext *avctx)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    AVStream *ast = NULL, *vst = NULL; //initialization to suppress warning\n    int version, i;\n    int ret;\n\n    avio_skip(pb, 4);\n\n    version = avio_rb16(pb);\n    if (version == 2) {\n        uint64_t timestamp;\n        int v;\n        avio_skip(pb, 22);\n\n        /* allocate audio track first to prevent unnecessary seeking\n         * (audio packet always precede video packet for a given frame) */\n        ast = avformat_new_stream(avctx, NULL);\n        if (!ast)\n            return AVERROR(ENOMEM);\n\n        vst = avformat_new_stream(avctx, NULL);\n        if (!vst)\n            return AVERROR(ENOMEM);\n        avpriv_set_pts_info(vst, 64, 1, 15);\n        vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        vst->avg_frame_rate    = av_inv_q(vst->time_base);\n        vst->nb_frames         = avio_rb32(pb);\n        v = avio_rb32(pb);\n        switch (v) {\n        case 1:\n            vst->codecpar->codec_id = AV_CODEC_ID_MVC1;\n            break;\n        case 2:\n            vst->codecpar->format = AV_PIX_FMT_ARGB;\n            vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;\n            break;\n        default:\n            avpriv_request_sample(avctx, \""Video compression %i\"", v);\n            break;\n        }\n        vst->codecpar->codec_tag = 0;\n        vst->codecpar->width     = avio_rb32(pb);\n        vst->codecpar->height    = avio_rb32(pb);\n        avio_skip(pb, 12);\n\n        ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n        ast->nb_frames          = vst->nb_frames;\n        ast->codecpar->sample_rate = avio_rb32(pb);\n        if (ast->codecpar->sample_rate <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \""Invalid sample rate %d\\n\"", ast->codecpar->sample_rate);\n            return AVERROR_INVALIDDATA;\n        }\n        avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);\n        if (set_channels(avctx, ast, avio_rb32(pb)) < 0)\n            return AVERROR_INVALIDDATA;\n\n        v = avio_rb32(pb);\n        if (v == AUDIO_FORMAT_SIGNED) {\n            ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        } else {\n            avpriv_request_sample(avctx, \""Audio compression (format %i)\"", v);\n        }\n\n        avio_skip(pb, 12);\n        var_read_metadata(avctx, \""title\"", 0x80);\n        var_read_metadata(avctx, \""comment\"", 0x100);\n        avio_skip(pb, 0x80);\n\n        timestamp = 0;\n        for (i = 0; i < vst->nb_frames; i++) {\n            uint32_t pos   = avio_rb32(pb);\n            uint32_t asize = avio_rb32(pb);\n            uint32_t vsize = avio_rb32(pb);\n            avio_skip(pb, 8);\n            av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n            av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);\n            timestamp += asize / (ast->codecpar->channels * 2);\n        }\n    } else if (!version && avio_rb16(pb) == 3) {\n        avio_skip(pb, 4);\n\n        if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)\n            return ret;\n\n        if (mv->nb_audio_tracks > 1) {\n            avpriv_request_sample(avctx, \""Multiple audio streams support\"");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_audio_tracks) {\n            ast = avformat_new_stream(avctx, NULL);\n            if (!ast)\n                return AVERROR(ENOMEM);\n            ast->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n            if ((read_table(avctx, ast, parse_audio_var)) < 0)\n                return ret;\n            if (mv->acompression == 100 &&\n                mv->aformat == AUDIO_FORMAT_SIGNED &&\n                ast->codecpar->bits_per_coded_sample == 16) {\n                ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n            } else {\n                avpriv_request_sample(avctx,\n                                      \""Audio compression %i (format %i, sr %i)\"",\n                                      mv->acompression, mv->aformat,\n                                      ast->codecpar->bits_per_coded_sample);\n                ast->codecpar->codec_id = AV_CODEC_ID_NONE;\n            }\n            if (ast->codecpar->channels <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \""No valid channel count found.\\n\"");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        if (mv->nb_video_tracks > 1) {\n            avpriv_request_sample(avctx, \""Multiple video streams support\"");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_video_tracks) {\n            vst = avformat_new_stream(avctx, NULL);\n            if (!vst)\n                return AVERROR(ENOMEM);\n            vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            if ((ret = read_table(avctx, vst, parse_video_var))<0)\n                return ret;\n        }\n\n        if (mv->nb_audio_tracks)\n            read_index(pb, ast);\n\n        if (mv->nb_video_tracks)\n            read_index(pb, vst);\n    } else {\n        avpriv_request_sample(avctx, \""Version %i\"", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""mv_read_header"", ""file_path"": ""libavformat/mvdec.c"", ""func_code"": ""static int mv_read_header(AVFormatContext *avctx)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    AVStream *ast = NULL, *vst = NULL; //initialization to suppress warning\n    int version, i;\n    int ret;\n\n    avio_skip(pb, 4);\n\n    version = avio_rb16(pb);\n    if (version == 2) {\n        uint64_t timestamp;\n        int v;\n        avio_skip(pb, 22);\n\n        /* allocate audio track first to prevent unnecessary seeking\n         * (audio packet always precede video packet for a given frame) */\n        ast = avformat_new_stream(avctx, NULL);\n        if (!ast)\n            return AVERROR(ENOMEM);\n\n        vst = avformat_new_stream(avctx, NULL);\n        if (!vst)\n            return AVERROR(ENOMEM);\n        avpriv_set_pts_info(vst, 64, 1, 15);\n        vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        vst->avg_frame_rate    = av_inv_q(vst->time_base);\n        vst->nb_frames         = avio_rb32(pb);\n        v = avio_rb32(pb);\n        switch (v) {\n        case 1:\n            vst->codecpar->codec_id = AV_CODEC_ID_MVC1;\n            break;\n        case 2:\n            vst->codecpar->format = AV_PIX_FMT_ARGB;\n            vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;\n            break;\n        default:\n            avpriv_request_sample(avctx, \""Video compression %i\"", v);\n            break;\n        }\n        vst->codecpar->codec_tag = 0;\n        vst->codecpar->width     = avio_rb32(pb);\n        vst->codecpar->height    = avio_rb32(pb);\n        avio_skip(pb, 12);\n\n        ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n        ast->nb_frames          = vst->nb_frames;\n        ast->codecpar->sample_rate = avio_rb32(pb);\n        if (ast->codecpar->sample_rate <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \""Invalid sample rate %d\\n\"", ast->codecpar->sample_rate);\n            return AVERROR_INVALIDDATA;\n        }\n        avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);\n        if (set_channels(avctx, ast, avio_rb32(pb)) < 0)\n            return AVERROR_INVALIDDATA;\n\n        v = avio_rb32(pb);\n        if (v == AUDIO_FORMAT_SIGNED) {\n            ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        } else {\n            avpriv_request_sample(avctx, \""Audio compression (format %i)\"", v);\n        }\n\n        avio_skip(pb, 12);\n        var_read_metadata(avctx, \""title\"", 0x80);\n        var_read_metadata(avctx, \""comment\"", 0x100);\n        avio_skip(pb, 0x80);\n\n        timestamp = 0;\n        for (i = 0; i < vst->nb_frames; i++) {\n            uint32_t pos   = avio_rb32(pb);\n            uint32_t asize = avio_rb32(pb);\n            uint32_t vsize = avio_rb32(pb);\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n            avio_skip(pb, 8);\n            av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n            av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);\n            timestamp += asize / (ast->codecpar->channels * 2);\n        }\n    } else if (!version && avio_rb16(pb) == 3) {\n        avio_skip(pb, 4);\n\n        if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)\n            return ret;\n\n        if (mv->nb_audio_tracks > 1) {\n            avpriv_request_sample(avctx, \""Multiple audio streams support\"");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_audio_tracks) {\n            ast = avformat_new_stream(avctx, NULL);\n            if (!ast)\n                return AVERROR(ENOMEM);\n            ast->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n            if ((read_table(avctx, ast, parse_audio_var)) < 0)\n                return ret;\n            if (mv->acompression == 100 &&\n                mv->aformat == AUDIO_FORMAT_SIGNED &&\n                ast->codecpar->bits_per_coded_sample == 16) {\n                ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n            } else {\n                avpriv_request_sample(avctx,\n                                      \""Audio compression %i (format %i, sr %i)\"",\n                                      mv->acompression, mv->aformat,\n                                      ast->codecpar->bits_per_coded_sample);\n                ast->codecpar->codec_id = AV_CODEC_ID_NONE;\n            }\n            if (ast->codecpar->channels <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \""No valid channel count found.\\n\"");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        if (mv->nb_video_tracks > 1) {\n            avpriv_request_sample(avctx, \""Multiple video streams support\"");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_video_tracks) {\n            vst = avformat_new_stream(avctx, NULL);\n            if (!vst)\n                return AVERROR(ENOMEM);\n            vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            if ((ret = read_table(avctx, vst, parse_video_var))<0)\n                return ret;\n        }\n\n        if (mv->nb_audio_tracks)\n            read_index(pb, ast);\n\n        if (mv->nb_video_tracks)\n            read_index(pb, vst);\n    } else {\n        avpriv_request_sample(avctx, \""Version %i\"", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}""}]","{""code"": 3, ""value"": 1}","[{""source"": ""code_info(file:mvdec.c, lines:330-360)"", ""result"": ""            ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        } else {\n            avpriv_request_sample(avctx, \""Audio compression (format %i)\"", v);\n        }\n\n        avio_skip(pb, 12);\n        var_read_metadata(avctx, \""title\"", 0x80);\n        var_read_metadata(avctx, \""comment\"", 0x100);\n        avio_skip(pb, 0x80);\n\n        timestamp = 0;\n        for (i = 0; i < vst->nb_frames; i++) {\n            uint32_t pos   = avio_rb32(pb);\n            uint32_t asize = avio_rb32(pb);\n            uint32_t vsize = avio_rb32(pb);\n            avio_skip(pb, 8);\n            av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n            av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);\n            timestamp += asize / (ast->codecpar->channels * 2);\n        }\n    } else if (!version && avio_rb16(pb) == 3) {\n        avio_skip(pb, 4);\n\n        if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)\n            return ret;\n\n        if (mv->nb_audio_tracks > 1) {\n            avpriv_request_sample(avctx, \""Multiple audio streams support\"");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_audio_tracks) {\n            ast = avformat_new_stream(avctx, NULL);\n            if (!ast)\n""}, {""source"": ""value_info(file:mvdec.c, value:nb_frames)"", ""result"": {""value_trace"": [{""full_code"": ""nb_frames = duration * INPUT_SAMPLERATE / FRAME_SIZE"", ""line"": 286, ""func_name"": ""main<duplicate>7""}, {""full_code"": ""nb_frames = mid_pred(ost->last_nb0_frames[0],\n                                          ost->last_nb0_frames[1],\n                                          ost->last_nb0_frames[2])"", ""line"": 1072, ""func_name"": ""do_video_out""}, {""full_code"": ""nb_frames = 1"", ""line"": 1081, ""func_name"": ""do_video_out""}, {""full_code"": ""nb_frames = 0"", ""line"": 1125, ""func_name"": ""do_video_out""}], ""struct_var"": ""nb_frames"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}, {""source"": ""code_info(file:mvdec.c, lines:300-330)"", ""result"": ""        switch (v) {\n        case 1:\n            vst->codecpar->codec_id = AV_CODEC_ID_MVC1;\n            break;\n        case 2:\n            vst->codecpar->format = AV_PIX_FMT_ARGB;\n            vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;\n            break;\n        default:\n            avpriv_request_sample(avctx, \""Video compression %i\"", v);\n            break;\n        }\n        vst->codecpar->codec_tag = 0;\n        vst->codecpar->width     = avio_rb32(pb);\n        vst->codecpar->height    = avio_rb32(pb);\n        avio_skip(pb, 12);\n\n        ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n        ast->nb_frames          = vst->nb_frames;\n        ast->codecpar->sample_rate = avio_rb32(pb);\n        if (ast->codecpar->sample_rate <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \""Invalid sample rate %d\\n\"", ast->codecpar->sample_rate);\n            return AVERROR_INVALIDDATA;\n        }\n        avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);\n        if (set_channels(avctx, ast, avio_rb32(pb)) < 0)\n            return AVERROR_INVALIDDATA;\n\n        v = avio_rb32(pb);\n        if (v == AUDIO_FORMAT_SIGNED) {\n            ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        } else {\n""}, {""source"": ""code_info(file:mvdec.c, lines:250-300)"", ""result"": ""    return 0;\n}\n\nstatic void read_index(AVIOContext *pb, AVStream *st)\n{\n    uint64_t timestamp = 0;\n    int i;\n    for (i = 0; i < st->nb_frames; i++) {\n        uint32_t pos  = avio_rb32(pb);\n        uint32_t size = avio_rb32(pb);\n        avio_skip(pb, 8);\n        av_add_index_entry(st, pos, timestamp, size, 0, AVINDEX_KEYFRAME);\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            timestamp += size / (st->codecpar->channels * 2);\n        } else {\n            timestamp++;\n        }\n    }\n}\n\nstatic int mv_read_header(AVFormatContext *avctx)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    AVStream *ast = NULL, *vst = NULL; //initialization to suppress warning\n    int version, i;\n    int ret;\n\n    avio_skip(pb, 4);\n\n    version = avio_rb16(pb);\n    if (version == 2) {\n        uint64_t timestamp;\n        int v;\n        avio_skip(pb, 22);\n\n        /* allocate audio track first to prevent unnecessary seeking\n         * (audio packet always precede video packet for a given frame) */\n        ast = avformat_new_stream(avctx, NULL);\n        if (!ast)\n            return AVERROR(ENOMEM);\n\n        vst = avformat_new_stream(avctx, NULL);\n        if (!vst)\n            return AVERROR(ENOMEM);\n        avpriv_set_pts_info(vst, 64, 1, 15);\n        vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        vst->avg_frame_rate    = av_inv_q(vst->time_base);\n        vst->nb_frames         = avio_rb32(pb);\n        v = avio_rb32(pb);\n        switch (v) {\n        case 1:\n""}]","The vulnerability arises from the lack of validation for `vst->nb_frames` in `mv_read_header()` (libavformat/mvdec.c:286), which is directly read from the file header without an EOF check. This unbounded value triggers a loop (libavformat/mvdec.c:350) that processes frame data without ensuring sufficient file data exists. The patch adds an EOF check during loop iteration (libavformat/mvdec.c:343-345) but does not address the initial lack of validation for `vst->nb_frames`.",0.95,./github/other_context/CVE-2017-14055
37,CVE-2017-14057,CWE-834,c_cpp,"In FFmpeg 3.3.3, a DoS in asf_read_marker() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted ASF file, which claims a large ""name_len"" or ""count"" field in the header but does not contain sufficient backing data, is provided, the loops over the name and markers would consume huge CPU and memory resources, since there is no EOF check inside these loops.",https://github.com/FFmpeg/FFmpeg/commit/7f9ec5593e04827249e7aeb466da06a98a0d7329,avformat/asfdec: Fix DoS due to lack of eof check\n\nFixes: loop.asf\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>,1,"[{""func_name"": ""asf_read_marker"", ""file_path"": ""libavformat/asfdec_f.c"", ""func_code"": ""static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); // skip the name\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        avio_rl64(pb);             // offset, 8 bytes\n        pres_time = avio_rl64(pb); // presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length\n        avio_rl32(pb);             // send time\n        avio_rl32(pb);             // flags\n        name_len = avio_rl32(pb);  // name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""asf_read_marker"", ""file_path"": ""libavformat/asfdec_f.c"", ""func_code"": ""static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    avio_skip(pb, name_len);\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        avio_rl64(pb);             // offset, 8 bytes\n        pres_time = avio_rl64(pb); // presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length\n        avio_rl32(pb);             // send time\n        avio_rl32(pb);             // flags\n        name_len = avio_rl32(pb);  // name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n\n    return 0;\n}""}]","{""function"": 4, ""code"": 1}","[{""source"": ""func_info(file:avio.h, func:avio_rl16)"", ""result"": [{""code"": ""unsigned int avio_rl16(AVIOContext *s);"", ""start_line"": 601, ""end_line"": 601, ""full_name"": ""avio_rl16:unsigned int(AVIOContext*)"", ""file_path"": ""libavformat/avio.h""}]}, {""source"": ""func_info(file:avio.h, func:avio_skip)"", ""result"": [{""code"": ""int64_t avio_skip(AVIOContext *s, int64_t offset);"", ""start_line"": 542, ""end_line"": 542, ""full_name"": ""avio_skip:ANY(AVIOContext*,int64_t)"", ""file_path"": ""libavformat/avio.h""}]}, {""source"": ""code_info(file:asfdec_f.c, lines:745-755)"", ""result"": ""    char name[1024];\n\n    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); // skip the name\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n""}, {""source"": ""func_info(func:avio_rl16)"", ""result"": [{""code"": ""unsigned int avio_rl16(AVIOContext *s)\n{\n    unsigned int val;\n    val = avio_r8(s);\n    val |= avio_r8(s) << 8;\n    return val;\n}"", ""start_line"": 738, ""end_line"": 744, ""full_name"": ""avio_rl16"", ""file_path"": ""libavformat/aviobuf.c""}, {""code"": ""unsigned int avio_rl16(AVIOContext *s);"", ""start_line"": 601, ""end_line"": 601, ""full_name"": ""avio_rl16:unsigned int(AVIOContext*)"", ""file_path"": ""libavformat/avio.h""}]}, {""source"": ""func_info(func:avio_skip)"", ""result"": [{""code"": ""int64_t avio_skip(AVIOContext *s, int64_t offset)\n{\n    return avio_seek(s, offset, SEEK_CUR);\n}"", ""start_line"": 324, ""end_line"": 327, ""full_name"": ""avio_skip"", ""file_path"": ""libavformat/aviobuf.c""}, {""code"": ""int64_t avio_skip(AVIOContext *s, int64_t offset);"", ""start_line"": 542, ""end_line"": 542, ""full_name"": ""avio_skip:ANY(AVIOContext*,int64_t)"", ""file_path"": ""libavformat/avio.h""}]}]","The vulnerability arises from unbounded loops in asf_read_marker() (libavformat/asfdec_f.c:750-752, 758-760) due to missing EOF checks. 'name_len' is read via avio_rl16(pb) (libavformat/aviobuf.c:738-744), which calls avio_r8() twice without EOF validation. avio_skip(pb, name_len) (libavformat/aviobuf.c:324-327) uses avio_seek() without EOF checks, allowing resource exhaustion if 'name_len' exceeds available data. The 'count' loop added an EOF check via avio_feof(), but the 'name_len' handling remains vulnerable. The patch addresses part of the issue but leaves a gap in 'name_len' processing.",0.95,./github/other_context/CVE-2017-14057
38,CVE-2017-14171,CWE-834,c_cpp,"In libavformat/nsvdec.c in FFmpeg 2.4 and 3.3.3, a DoS in nsv_parse_NSVf_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted NSV file, which claims a large ""table_entries_used"" field in the header but does not contain sufficient backing data, is provided, the loop over 'table_entries_used' would consume huge CPU resources, since there is no EOF check inside the loop.",https://github.com/FFmpeg/FFmpeg/commit/c24bcb553650b91e9eff15ef6e54ca73de2453b7,"avformat/nsvdec: Fix DoS due to lack of eof check in nsvs_file_offset loop.\n\nFixes: 20170829.nsv\n\nCo-Author: ()"" <wangchu.zhl@alibaba-inc.com>\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",1,"[{""func_name"": ""nsv_parse_NSVf_header"", ""file_path"": ""libavformat/nsvdec.c"", ""func_code"": ""static int nsv_parse_NSVf_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    unsigned int av_unused file_size;\n    unsigned int size;\n    int64_t duration;\n    int strings_size;\n    int table_entries;\n    int table_entries_used;\n\n    nsv->state = NSV_UNSYNC; /* in case we fail */\n\n    size = avio_rl32(pb);\n    if (size < 28)\n        return -1;\n    nsv->NSVf_end = size;\n\n    file_size = (uint32_t)avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf chunk_size %u\\n\"", size);\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf file_size %u\\n\"", file_size);\n\n    nsv->duration = duration = avio_rl32(pb); /* in ms */\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf duration %\""PRId64\"" ms\\n\"", duration);\n    // XXX: store it in AVStreams\n\n    strings_size = avio_rl32(pb);\n    table_entries = avio_rl32(pb);\n    table_entries_used = avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\"",\n            strings_size, table_entries, table_entries_used);\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \""NSV got header; filepos %\""PRId64\""\\n\"", avio_tell(pb));\n\n    if (strings_size > 0) {\n        char *strings; /* last byte will be '\\0' to play safe with str*() */\n        char *p, *endp;\n        char *token, *value;\n        char quote;\n\n        p = strings = av_mallocz((size_t)strings_size + 1);\n        if (!p)\n            return AVERROR(ENOMEM);\n        endp = strings + strings_size;\n        avio_read(pb, strings, strings_size);\n        while (p < endp) {\n            while (*p == ' ')\n                p++; /* strip out spaces */\n            if (p >= endp-2)\n                break;\n            token = p;\n            p = strchr(p, '=');\n            if (!p || p >= endp-2)\n                break;\n            *p++ = '\\0';\n            quote = *p++;\n            value = p;\n            p = strchr(p, quote);\n            if (!p || p >= endp)\n                break;\n            *p++ = '\\0';\n            av_log(s, AV_LOG_TRACE, \""NSV NSVf INFO: %s='%s'\\n\"", token, value);\n            av_dict_set(&s->metadata, token, value, 0);\n        }\n        av_free(strings);\n    }\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \""NSV got infos; filepos %\""PRId64\""\\n\"", avio_tell(pb));\n\n    if (table_entries_used > 0) {\n        int i;\n        nsv->index_entries = table_entries_used;\n        if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))\n            return -1;\n        nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n        if (!nsv->nsvs_file_offset)\n            return AVERROR(ENOMEM);\n\n        for(i=0;i<table_entries_used;i++)\n            nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n\n        if(table_entries > table_entries_used &&\n           avio_rl32(pb) == MKTAG('T','O','C','2')) {\n            nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n            if (!nsv->nsvs_timestamps)\n                return AVERROR(ENOMEM);\n            for(i=0;i<table_entries_used;i++) {\n                nsv->nsvs_timestamps[i] = avio_rl32(pb);\n            }\n        }\n    }\n\n    av_log(s, AV_LOG_TRACE, \""NSV got index; filepos %\""PRId64\""\\n\"", avio_tell(pb));\n\n    avio_seek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */\n\n    if (avio_feof(pb))\n        return -1;\n    nsv->state = NSV_HAS_READ_NSVF;\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""nsv_parse_NSVf_header"", ""file_path"": ""libavformat/nsvdec.c"", ""func_code"": ""static int nsv_parse_NSVf_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    unsigned int av_unused file_size;\n    unsigned int size;\n    int64_t duration;\n    int strings_size;\n    int table_entries;\n    int table_entries_used;\n\n    nsv->state = NSV_UNSYNC; /* in case we fail */\n\n    size = avio_rl32(pb);\n    if (size < 28)\n        return -1;\n    nsv->NSVf_end = size;\n\n    file_size = (uint32_t)avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf chunk_size %u\\n\"", size);\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf file_size %u\\n\"", file_size);\n\n    nsv->duration = duration = avio_rl32(pb); /* in ms */\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf duration %\""PRId64\"" ms\\n\"", duration);\n    // XXX: store it in AVStreams\n\n    strings_size = avio_rl32(pb);\n    table_entries = avio_rl32(pb);\n    table_entries_used = avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\"",\n            strings_size, table_entries, table_entries_used);\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \""NSV got header; filepos %\""PRId64\""\\n\"", avio_tell(pb));\n\n    if (strings_size > 0) {\n        char *strings; /* last byte will be '\\0' to play safe with str*() */\n        char *p, *endp;\n        char *token, *value;\n        char quote;\n\n        p = strings = av_mallocz((size_t)strings_size + 1);\n        if (!p)\n            return AVERROR(ENOMEM);\n        endp = strings + strings_size;\n        avio_read(pb, strings, strings_size);\n        while (p < endp) {\n            while (*p == ' ')\n                p++; /* strip out spaces */\n            if (p >= endp-2)\n                break;\n            token = p;\n            p = strchr(p, '=');\n            if (!p || p >= endp-2)\n                break;\n            *p++ = '\\0';\n            quote = *p++;\n            value = p;\n            p = strchr(p, quote);\n            if (!p || p >= endp)\n                break;\n            *p++ = '\\0';\n            av_log(s, AV_LOG_TRACE, \""NSV NSVf INFO: %s='%s'\\n\"", token, value);\n            av_dict_set(&s->metadata, token, value, 0);\n        }\n        av_free(strings);\n    }\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \""NSV got infos; filepos %\""PRId64\""\\n\"", avio_tell(pb));\n\n    if (table_entries_used > 0) {\n        int i;\n        nsv->index_entries = table_entries_used;\n        if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))\n            return -1;\n        nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n        if (!nsv->nsvs_file_offset)\n            return AVERROR(ENOMEM);\n\n        for(i=0;i<table_entries_used;i++) {\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n            nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n        }\n\n        if(table_entries > table_entries_used &&\n           avio_rl32(pb) == MKTAG('T','O','C','2')) {\n            nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n            if (!nsv->nsvs_timestamps)\n                return AVERROR(ENOMEM);\n            for(i=0;i<table_entries_used;i++) {\n                nsv->nsvs_timestamps[i] = avio_rl32(pb);\n            }\n        }\n    }\n\n    av_log(s, AV_LOG_TRACE, \""NSV got index; filepos %\""PRId64\""\\n\"", avio_tell(pb));\n\n    avio_seek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */\n\n    if (avio_feof(pb))\n        return -1;\n    nsv->state = NSV_HAS_READ_NSVF;\n    return 0;\n}""}]","{""function"": 1, ""code"": 1, ""value"": 1}","[{""source"": ""func_info(file:nsvdec.c, func:nsv_parse_NSVf_header)"", ""result"": [{""code"": ""static int nsv_parse_NSVf_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    unsigned int av_unused file_size;\n    unsigned int size;\n    int64_t duration;\n    int strings_size;\n    int table_entries;\n    int table_entries_used;\n\n    nsv->state = NSV_UNSYNC; /* in case we fail */\n\n    size = avio_rl32(pb);\n    if (size < 28)\n        return -1;\n    nsv->NSVf_end = size;\n\n    file_size = (uint32_t)avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf chunk_size %u\\n\"", size);\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf file_size %u\\n\"", file_size);\n\n    nsv->duration = duration = avio_rl32(pb); /* in ms */\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf duration %\""PRId64\"" ms\\n\"", duration);\n    // XXX: store it in AVStreams\n\n    strings_size = avio_rl32(pb);\n    table_entries = avio_rl32(pb);\n    table_entries_used = avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \""NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\"",\n            strings_size, table_entries, table_entries_used);\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \""NSV got header; filepos %\""PRId64\""\\n\"", avio_tell(pb));\n\n    if (strings_size > 0) {\n        char *strings; /* last byte will be '\\0' to play safe with str*() */\n        char *p, *endp;\n        char *token, *value;\n        char quote;\n\n        p = strings = av_mallocz((size_t)strings_size + 1);\n        if (!p)\n            return AVERROR(ENOMEM);\n        endp = strings + strings_size;\n        avio_read(pb, strings, strings_size);\n        while (p < endp) {\n            while (*p == ' ')\n                p++; /* strip out spaces */\n            if (p >= endp-2)\n                break;\n            token = p;\n            p = strchr(p, '=');\n            if (!p || p >= endp-2)\n                break;\n            *p++ = '\\0';\n            quote = *p++;\n            value = p;\n            p = strchr(p, quote);\n            if (!p || p >= endp)\n                break;\n            *p++ = '\\0';\n            av_log(s, AV_LOG_TRACE, \""NSV NSVf INFO: %s='%s'\\n\"", token, value);\n            av_dict_set(&s->metadata, token, value, 0);\n        }\n        av_free(strings);\n    }\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \""NSV got infos; filepos %\""PRId64\""\\n\"", avio_tell(pb));\n\n    if (table_entries_used > 0) {\n        int i;\n        nsv->index_entries = table_entries_used;\n        if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))\n            return -1;\n        nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n        if (!nsv->nsvs_file_offset)\n            return AVERROR(ENOMEM);\n\n        for(i=0;i<table_entries_used;i++)\n            nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n\n        if(table_entries > table_entries_used &&\n           avio_rl32(pb) == MKTAG('T','O','C','2')) {\n            nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n            if (!nsv->nsvs_timestamps)\n                return AVERROR(ENOMEM);\n            for(i=0;i<table_entries_used;i++) {\n                nsv->nsvs_timestamps[i] = avio_rl32(pb);\n            }\n        }\n    }\n\n    av_log(s, AV_LOG_TRACE, \""NSV got index; filepos %\""PRId64\""\\n\"", avio_tell(pb));\n\n    avio_seek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */\n\n    if (avio_feof(pb))\n        return -1;\n    nsv->state = NSV_HAS_READ_NSVF;\n    return 0;\n}\n"", ""start_line"": 256, ""end_line"": 360, ""full_name"": ""nsv_parse_NSVf_header"", ""file_path"": ""libavformat/nsvdec.c""}]}, {""source"": ""code_info(file:nsvdec.c, lines:320-340)"", ""result"": ""            av_dict_set(&s->metadata, token, value, 0);\n        }\n        av_free(strings);\n    }\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \""NSV got infos; filepos %\""PRId64\""\\n\"", avio_tell(pb));\n\n    if (table_entries_used > 0) {\n        int i;\n        nsv->index_entries = table_entries_used;\n        if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))\n            return -1;\n        nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n        if (!nsv->nsvs_file_offset)\n            return AVERROR(ENOMEM);\n\n        for(i=0;i<table_entries_used;i++)\n            nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n\n""}, {""source"": ""value_info(file:nsvdec.c, value:table_entries_used)"", ""result"": {""value_trace"": [{""full_code"": ""table_entries_used = avio_rl32(pb)"", ""line"": 284, ""func_name"": ""nsv_parse_NSVf_header""}], ""struct_var"": ""table_entries_used"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}]","libavformat/nsvdec.c: Loop over 'table_entries_used' (line 339) lacks EOF check, allowing unbounded iteration. 'table_entries_used' is sourced from avio_rl32(pb) (line 284), making it attacker-controlled. GAP: No further gaps exist; source of 'table_entries_used' is confirmed in the code.",0.95,./github/other_context/CVE-2017-14171
39,CVE-2017-15908,CWE-835,c_cpp,"In systemd 223 through 235, a remote DNS server can respond with a custom crafted DNS NSEC resource record to trigger an infinite loop in the dns_packet_read_type_window() function of the 'systemd-resolved' service and cause a DoS of the affected service.",https://github.com/systemd/systemd/commit/9f939335a07085aa9a9663efd1dca06ef6405d62,resolved: fix loop on packets with pseudo dns types\n\nReported by Karim Hossen & Thomas Imbert from Sogeti ESEC R&D.\n\nhttps://bugs.launchpad.net/ubuntu/+source/systemd/+bug/1725351,1,"[{""func_name"": ""dns_packet_read_type_window"", ""file_path"": ""src/resolve/resolved-dns-packet.c"", ""func_code"": ""static int dns_packet_read_type_window(DnsPacket *p, Bitmap **types, size_t *start) {\n        uint8_t window;\n        uint8_t length;\n        const uint8_t *bitmap;\n        uint8_t bit = 0;\n        unsigned i;\n        bool found = false;\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        int r;\n\n        assert(p);\n        assert(types);\n        INIT_REWINDER(rewinder, p);\n\n        r = bitmap_ensure_allocated(types);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &window, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &length, NULL);\n        if (r < 0)\n                return r;\n\n        if (length == 0 || length > 32)\n                return -EBADMSG;\n\n        r = dns_packet_read(p, length, (const void **)&bitmap, NULL);\n        if (r < 0)\n                return r;\n\n        for (i = 0; i < length; i++) {\n                uint8_t bitmask = 1 << 7;\n\n                if (!bitmap[i]) {\n                        found = false;\n                        bit += 8;\n                        continue;\n                }\n\n                found = true;\n\n                while (bitmask) {\n                        if (bitmap[i] & bitmask) {\n                                uint16_t n;\n\n                                n = (uint16_t) window << 8 | (uint16_t) bit;\n\n                                /* Ignore pseudo-types. see RFC4034 section 4.1.2 */\n                                if (dns_type_is_pseudo(n))\n                                        continue;\n\n                                r = bitmap_set(*types, n);\n                                if (r < 0)\n                                        return r;\n                        }\n\n                        bit++;\n                        bitmask >>= 1;\n                }\n        }\n\n        if (!found)\n                return -EBADMSG;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}"", ""target"": 0}]","[{""func_name"": ""dns_packet_read_type_window"", ""file_path"": ""src/resolve/resolved-dns-packet.c"", ""func_code"": ""static int dns_packet_read_type_window(DnsPacket *p, Bitmap **types, size_t *start) {\n        uint8_t window;\n        uint8_t length;\n        const uint8_t *bitmap;\n        uint8_t bit = 0;\n        unsigned i;\n        bool found = false;\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        int r;\n\n        assert(p);\n        assert(types);\n        INIT_REWINDER(rewinder, p);\n\n        r = bitmap_ensure_allocated(types);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &window, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &length, NULL);\n        if (r < 0)\n                return r;\n\n        if (length == 0 || length > 32)\n                return -EBADMSG;\n\n        r = dns_packet_read(p, length, (const void **)&bitmap, NULL);\n        if (r < 0)\n                return r;\n\n        for (i = 0; i < length; i++) {\n                uint8_t bitmask = 1 << 7;\n\n                if (!bitmap[i]) {\n                        found = false;\n                        bit += 8;\n                        continue;\n                }\n\n                found = true;\n\n                for (; bitmask; bit++, bitmask >>= 1)\n                        if (bitmap[i] & bitmask) {\n                                uint16_t n;\n\n                                n = (uint16_t) window << 8 | (uint16_t) bit;\n\n                                /* Ignore pseudo-types. see RFC4034 section 4.1.2 */\n                                if (dns_type_is_pseudo(n))\n                                        continue;\n\n                                r = bitmap_set(*types, n);\n                                if (r < 0)\n                                        return r;\n                        }\n        }\n\n        if (!found)\n                return -EBADMSG;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}""}]","{""code"": 1, ""value"": 1}","[{""source"": ""code_info(file:resolved-dns-packet.c, lines:1500-1550)"", ""result"": ""                return -EBADMSG;\n\n        r = dns_packet_read(p, length, (const void **)&bitmap, NULL);\n        if (r < 0)\n                return r;\n\n        for (i = 0; i < length; i++) {\n                uint8_t bitmask = 1 << 7;\n\n                if (!bitmap[i]) {\n                        found = false;\n                        bit += 8;\n                        continue;\n                }\n\n                found = true;\n\n                while (bitmask) {\n                        if (bitmap[i] & bitmask) {\n                                uint16_t n;\n\n                                n = (uint16_t) window << 8 | (uint16_t) bit;\n\n                                /* Ignore pseudo-types. see RFC4034 section 4.1.2 */\n                                if (dns_type_is_pseudo(n))\n                                        continue;\n\n                                r = bitmap_set(*types, n);\n                                if (r < 0)\n                                        return r;\n                        }\n\n                        bit++;\n                        bitmask >>= 1;\n                }\n        }\n\n        if (!found)\n                return -EBADMSG;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}\n\nstatic int dns_packet_read_type_windows(DnsPacket *p, Bitmap **types, size_t size, size_t *start) {\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        int r;\n\n""}, {""source"": ""value_info(file:resolved-dns-packet.c, value:bitmask)"", ""result"": {""value_trace"": [{""full_code"": ""bitmask = 1 << 7"", ""line"": 1507, ""func_name"": ""dns_packet_read_type_window""}, {""full_code"": ""bitmask >>= 1"", ""line"": 1533, ""func_name"": ""dns_packet_read_type_window""}], ""struct_var"": ""bitmask"", ""struct_type"": ""uint8_t"", ""struct_definition"": ""typedef unsigned char uint8_t;""}}]","In `dns_packet_read_type_window` (src/resolve/resolved-dns-packet.c:1515), the while loop processes DNS bitmap bits. The loop condition checks `bitmask`, but the update (`bitmask >>= 1`) occurs only after processing a bit. If an error occurs (e.g., `r < 0` during `bitmap_set`) and the function returns early, the `bitmask` is not updated, remaining non-zero. This causes infinite iteration. The patch replaces the while loop with a for loop (src/resolve/resolved-dns-packet.c:1515) to ensure `bitmask` is shifted unconditionally in the loop header, preventing the infinite loop.",0.95,./github/other_context/CVE-2017-15908
40,CVE-2017-16932,CWE-835,c_cpp,parser.c in libxml2 before 2.9.5 does not prevent infinite recursion in parameter entities.,https://github.com/GNOME/libxml2/commit/899a5d9f0ed13b8e32449a08a361e0de127dd961,"Detect infinite recursion in parameter entities\n\nWhen expanding a parameter entity in a DTD, infinite recursion could\nlead to an infinite loop or memory exhaustion.\n\nThanks to Wei Lei for the first of many reports.\n\nFixes bug 759579.",2,"[{""func_name"": ""xmlParsePEReference"", ""file_path"": ""parser.c"", ""func_code"": ""void\nxmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n    const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n    if (RAW != '%')\n        return;\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \""PEReference: no name\\n\"");\n\treturn;\n    }\n    if (xmlParserDebugEntities)\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\""PEReference: %s\\n\"", name);\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);\n        return;\n    }\n\n    NEXT;\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Request the entity from SAX\n     */\n    if ((ctxt->sax != NULL) &&\n\t(ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n    if (entity == NULL) {\n\t/*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \""standalone='yes'\"", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t */\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t\t      \""PEReference: %%%s; not found\\n\"",\n\t\t\t      name);\n\t} else {\n\t    /*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \""standalone='no'\"", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     */\n            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {\n                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                                 \""PEReference: %%%s; not found\\n\"",\n                                 name, NULL);\n            } else\n                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                              \""PEReference: %%%s; not found\\n\"",\n                              name, NULL);\n            ctxt->valid = 0;\n\t}\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n    } else {\n\t/*\n\t * Internal checking in case the entity quest barfed\n\t */\n\tif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n\t    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t  \""Internal: %%%s; is not a parameter entity\\n\"",\n\t\t\t  name, NULL);\n\t} else {\n            xmlChar start[4];\n            xmlCharEncoding enc;\n\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n\t\t(ctxt->replaceEntities == 0) &&\n\t\t(ctxt->validate == 0))\n\t\treturn;\n\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0)\n\t\treturn;\n\n\t    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n                /*\n                 * Get the 4 first bytes and decode the charset\n                 * if enc != XML_CHAR_ENCODING_NONE\n                 * plug some encoding conversion routines.\n                 * Note that, since we may have some non-UTF8\n                 * encoding (like UTF16, bug 135229), the 'length'\n                 * is not known, but we can calculate based upon\n                 * the amount of data in the buffer.\n                 */\n                GROW\n                if (ctxt->instate == XML_PARSER_EOF)\n                    return;\n                if ((ctxt->input->end - ctxt->input->cur)>=4) {\n                    start[0] = RAW;\n                    start[1] = NXT(1);\n                    start[2] = NXT(2);\n                    start[3] = NXT(3);\n                    enc = xmlDetectCharEncoding(start, 4);\n                    if (enc != XML_CHAR_ENCODING_NONE) {\n                        xmlSwitchEncoding(ctxt, enc);\n                    }\n                }\n\n                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n                    (IS_BLANK_CH(NXT(5)))) {\n                    xmlParseTextDecl(ctxt);\n                }\n            }\n\t}\n    }\n    ctxt->hasPErefs = 1;\n}"", ""target"": 0}, {""func_name"": ""xmlPushInput"", ""file_path"": ""parser.c"", ""func_code"": ""int\nxmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \""%s(%d): \"", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\""Pushing input %d : %.30s\\n\"", ctxt->inputNr+1, input->cur);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}"", ""target"": 0}]","[{""func_name"": ""xmlParsePEReference"", ""file_path"": ""parser.c"", ""func_code"": ""void\nxmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n    const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n    if (RAW != '%')\n        return;\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \""PEReference: no name\\n\"");\n\treturn;\n    }\n    if (xmlParserDebugEntities)\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\""PEReference: %s\\n\"", name);\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);\n        return;\n    }\n\n    NEXT;\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Request the entity from SAX\n     */\n    if ((ctxt->sax != NULL) &&\n\t(ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n    if (entity == NULL) {\n\t/*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \""standalone='yes'\"", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t */\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t\t      \""PEReference: %%%s; not found\\n\"",\n\t\t\t      name);\n\t} else {\n\t    /*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \""standalone='no'\"", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     */\n            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {\n                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                                 \""PEReference: %%%s; not found\\n\"",\n                                 name, NULL);\n            } else\n                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                              \""PEReference: %%%s; not found\\n\"",\n                              name, NULL);\n            ctxt->valid = 0;\n\t}\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n    } else {\n\t/*\n\t * Internal checking in case the entity quest barfed\n\t */\n\tif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n\t    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t  \""Internal: %%%s; is not a parameter entity\\n\"",\n\t\t\t  name, NULL);\n\t} else {\n            xmlChar start[4];\n            xmlCharEncoding enc;\n\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n\t\t(ctxt->replaceEntities == 0) &&\n\t\t(ctxt->validate == 0))\n\t\treturn;\n\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0) {\n                xmlFreeInputStream(input);\n\t\treturn;\n            }\n\n\t    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n                /*\n                 * Get the 4 first bytes and decode the charset\n                 * if enc != XML_CHAR_ENCODING_NONE\n                 * plug some encoding conversion routines.\n                 * Note that, since we may have some non-UTF8\n                 * encoding (like UTF16, bug 135229), the 'length'\n                 * is not known, but we can calculate based upon\n                 * the amount of data in the buffer.\n                 */\n                GROW\n                if (ctxt->instate == XML_PARSER_EOF)\n                    return;\n                if ((ctxt->input->end - ctxt->input->cur)>=4) {\n                    start[0] = RAW;\n                    start[1] = NXT(1);\n                    start[2] = NXT(2);\n                    start[3] = NXT(3);\n                    enc = xmlDetectCharEncoding(start, 4);\n                    if (enc != XML_CHAR_ENCODING_NONE) {\n                        xmlSwitchEncoding(ctxt, enc);\n                    }\n                }\n\n                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n                    (IS_BLANK_CH(NXT(5)))) {\n                    xmlParseTextDecl(ctxt);\n                }\n            }\n\t}\n    }\n    ctxt->hasPErefs = 1;\n}""}, {""func_name"": ""xmlPushInput"", ""file_path"": ""parser.c"", ""func_code"": ""int\nxmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \""%s(%d): \"", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\""Pushing input %d : %.30s\\n\"", ctxt->inputNr+1, input->cur);\n    }\n    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (ctxt->inputNr > 1024)) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        while (ctxt->inputNr > 1)\n            xmlFreeInputStream(inputPop(ctxt));\n\treturn(-1);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}""}]","{""function"": 1, ""value"": 1, ""caller"": 1}","[{""source"": ""func_info(file:parser.c, func:inputPush)"", ""result"": [{""code"": ""int\ninputPush(xmlParserCtxtPtr ctxt, xmlParserInputPtr value)\n{\n    if ((ctxt == NULL) || (value == NULL))\n        return(-1);\n    if (ctxt->inputNr >= ctxt->inputMax) {\n        ctxt->inputMax *= 2;\n        ctxt->inputTab =\n            (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,\n                                             ctxt->inputMax *\n                                             sizeof(ctxt->inputTab[0]));\n        if (ctxt->inputTab == NULL) {\n            xmlErrMemory(ctxt, NULL);\n\t    xmlFreeInputStream(value);\n\t    ctxt->inputMax /= 2;\n\t    value = NULL;\n            return (-1);\n        }\n    }\n    ctxt->inputTab[ctxt->inputNr] = value;\n    ctxt->input = value;\n    return (ctxt->inputNr++);\n}"", ""start_line"": 1709, ""end_line"": 1731, ""full_name"": ""inputPush"", ""file_path"": ""parser.c""}]}, {""source"": ""value_info(file:parser.c, value:ctxt->inputNr)"", ""result"": {""value_trace"": [{""full_code"": ""ctxt->inputNr++"", ""line"": 1730, ""func_name"": ""inputPush""}, {""full_code"": ""ctxt->inputNr = 0"", ""line"": 14804, ""func_name"": ""xmlCtxtReset""}], ""struct_var"": ""ctxt"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:parser.c, func:xmlParsePEReference)"", ""result"": [{""call_line"": 2178, ""call_code"": ""xmlParsePEReference(ctxt)"", ""caller_code"": ""int\nxmlSkipBlankChars(xmlParserCtxtPtr ctxt) {\n    int res = 0;\n\n    /*\n     * It's Okay to use CUR/NEXT here since all the blanks are on\n     * the ASCII range.\n     */\n    if ((ctxt->inputNr == 1) && (ctxt->instate != XML_PARSER_DTD)) {\n\tconst xmlChar *cur;\n\t/*\n\t * if we are in the document content, go really fast\n\t */\n\tcur = ctxt->input->cur;\n\twhile (IS_BLANK_CH(*cur)) {\n\t    if (*cur == '\\n') {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t    } else {\n\t\tctxt->input->col++;\n\t    }\n\t    cur++;\n\t    res++;\n\t    if (*cur == 0) {\n\t\tctxt->input->cur = cur;\n\t\txmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n\t\tcur = ctxt->input->cur;\n\t    }\n\t}\n\tctxt->input->cur = cur;\n    } else {\n        int expandPE = ((ctxt->external != 0) || (ctxt->inputNr != 1));\n\n\twhile (1) {\n            if (IS_BLANK_CH(CUR)) { /* CHECKED tstblanks.xml */\n\t\tNEXT;\n\t    } else if (CUR == '%') {\n                /*\n                 * Need to handle support of entities branching here\n                 */\n\t        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))\n                    break;\n\t        xmlParsePEReference(ctxt);\n            } else if (CUR == 0) {\n                if (ctxt->inputNr <= 1)\n                    break;\n                xmlPopInput(ctxt);\n            } else {\n                break;\n            }\n\n            /*\n             * Also increase the counter when entering or exiting a PERef.\n             * The spec says: \""When a parameter-entity reference is recognized\n             * in the DTD and included, its replacement text MUST be enlarged\n             * by the attachment of one leading and one following space (#x20)\n             * character.\""\n             */\n\t    res++;\n        }\n    }\n    return(res);\n}\n"", ""caller_start"": 2137, ""file_path"": ""parser.c""}, {""call_line"": 2545, ""call_code"": ""xmlParsePEReference(ctxt)"", ""caller_code"": ""void\nxmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {\n    switch(ctxt->instate) {\n\tcase XML_PARSER_CDATA_SECTION:\n\t    return;\n        case XML_PARSER_COMMENT:\n\t    return;\n\tcase XML_PARSER_START_TAG:\n\t    return;\n\tcase XML_PARSER_END_TAG:\n\t    return;\n        case XML_PARSER_EOF:\n\t    xmlFatalErr(ctxt, XML_ERR_PEREF_AT_EOF, NULL);\n\t    return;\n        case XML_PARSER_PROLOG:\n\tcase XML_PARSER_START:\n\tcase XML_PARSER_MISC:\n\t    xmlFatalErr(ctxt, XML_ERR_PEREF_IN_PROLOG, NULL);\n\t    return;\n\tcase XML_PARSER_ENTITY_DECL:\n        case XML_PARSER_CONTENT:\n        case XML_PARSER_ATTRIBUTE_VALUE:\n        case XML_PARSER_PI:\n\tcase XML_PARSER_SYSTEM_LITERAL:\n\tcase XML_PARSER_PUBLIC_LITERAL:\n\t    /* we just ignore it there */\n\t    return;\n        case XML_PARSER_EPILOG:\n\t    xmlFatalErr(ctxt, XML_ERR_PEREF_IN_EPILOG, NULL);\n\t    return;\n\tcase XML_PARSER_ENTITY_VALUE:\n\t    /*\n\t     * NOTE: in the case of entity values, we don't do the\n\t     *       substitution here since we need the literal\n\t     *       entity value to be able to save the internal\n\t     *       subset of the document.\n\t     *       This will be handled by xmlStringDecodeEntities\n\t     */\n\t    return;\n        case XML_PARSER_DTD:\n\t    /*\n\t     * [WFC: Well-Formedness Constraint: PEs in Internal Subset]\n\t     * In the internal DTD subset, parameter-entity references\n\t     * can occur only where markup declarations can occur, not\n\t     * within markup declarations.\n\t     * In that case this is handled in xmlParseMarkupDecl\n\t     */\n\t    if ((ctxt->external == 0) && (ctxt->inputNr == 1))\n\t\treturn;\n\t    if (IS_BLANK_CH(NXT(1)) || NXT(1) == 0)\n\t\treturn;\n            break;\n        case XML_PARSER_IGNORE:\n            return;\n    }\n\n    xmlParsePEReference(ctxt);\n}\n"", ""caller_start"": 2489, ""file_path"": ""parser.c""}, {""call_line"": 8279, ""call_code"": ""xmlParsePEReference(ctxt)"", ""caller_code"": ""static void\nxmlParseInternalSubset(xmlParserCtxtPtr ctxt) {\n    /*\n     * Is there any DTD definition ?\n     */\n    if (RAW == '[') {\n        ctxt->instate = XML_PARSER_DTD;\n        NEXT;\n\t/*\n\t * Parse the succession of Markup declarations and\n\t * PEReferences.\n\t * Subsequence (markupdecl | PEReference | S)*\n\t */\n\twhile (((RAW != ']') || (ctxt->inputNr > 1)) &&\n               (ctxt->instate != XML_PARSER_EOF)) {\n\t    const xmlChar *check = CUR_PTR;\n\t    unsigned int cons = ctxt->input->consumed;\n\n\t    SKIP_BLANKS;\n\t    xmlParseMarkupDecl(ctxt);\n\t    xmlParsePEReference(ctxt);\n\n\t    if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {\n\t\txmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t     \""xmlParseInternalSubset: error detected in Markup declaration\\n\"");\n                if (ctxt->inputNr > 1)\n                    xmlPopInput(ctxt);\n                else\n\t\t    break;\n\t    }\n\t}\n\tif (RAW == ']') {\n\t    NEXT;\n\t    SKIP_BLANKS;\n\t}\n    }\n\n    /*\n     * We should be at the end of the DOCTYPE declaration.\n     */\n    if (RAW != '>') {\n\txmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n\treturn;\n    }\n    NEXT;\n}\n"", ""caller_start"": 8259, ""file_path"": ""parser.c""}]}]","The vulnerability stems from unbounded recursion during parameter entity expansion. The `inputNr` counter in the parser context (`ctxt->inputNr`) is incremented in `inputPush` (parser.c:1730) each time a new input stream is added. Before the patch, there was no check on `inputNr` to limit recursion depth. The patch adds a check in `xmlPushInput` (parser.c:2251-2261) to trigger an error if `inputNr` exceeds 40 (or 1024 with `XML_PARSE_HUGE`), preventing infinite recursion. `xmlParsePEReference` (parser.c:7917-7921) ensures cleanup on failure. The recursion is triggered by nested parameter entity expansions, which increment `inputNr` via `inputPush` during each expansion.",0.95,./github/other_context/CVE-2017-16932
41,CVE-2017-9094,CWE-835,c_cpp,The lzw_add_to_dict function in imagew-gif.c in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (infinite loop) via a crafted image.,https://github.com/jsummers/imageworsener/commit/a75fd4879c55c89651f7f247293a61eef3e51be1,"Fixed a bug related to decoding invalid GIF files\n\nThe bug could cause an infinite loop, and possibly other problems.\nFixes issue #27",2,"[{""func_name"": ""lzw_process_code"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static int lzw_process_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int code)\n{\n\tif(code==d->eoi_code) {\n\t\td->eoi_flag=1;\n\t\treturn 1;\n\t}\n\n\tif(code==d->clear_code) {\n\t\tlzw_clear(d);\n\t\treturn 1;\n\t}\n\n\td->ncodes_since_clear++;\n\n\tif(d->ncodes_since_clear==1) {\n\t\t// Special case for the first code.\n\t\tlzw_emit_code(rctx,d,code);\n\t\td->oldcode = code;\n\t\treturn 1;\n\t}\n\n\t// Is code in code table?\n\tif(code < d->ct_used) {\n\t\t// Yes, code is in table.\n\t\tlzw_emit_code(rctx,d,code);\n\n\t\t// Let k = the first character of the translation of the code.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tlzw_add_to_dict(d,d->oldcode,d->ct[code].firstchar);\n\t}\n\telse {\n\t\t// No, code is not in table.\n\t\tif(d->oldcode>=d->ct_used) {\n\t\t\tiw_set_error(rctx->ctx,\""GIF decoding error\"");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Let k = the first char of the translation of oldcode.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tif(lzw_add_to_dict(d,d->oldcode,d->ct[d->oldcode].firstchar)) {\n\t\t\t// Write <oldcode>k to the output stream.\n\t\t\tlzw_emit_code(rctx,d,d->last_code_added);\n\t\t}\n\t}\n\td->oldcode = code;\n\n\treturn 1;\n}"", ""target"": 0}, {""func_name"": ""lzw_add_to_dict"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static int lzw_add_to_dict(struct lzwdeccontext *d, unsigned int oldcode, iw_byte val)\n{\n\tstatic const unsigned int last_code_of_size[] = {\n\t\t// The first 3 values are unused.\n\t\t0,0,0,7,15,31,63,127,255,511,1023,2047,4095\n\t};\n\tunsigned int newpos;\n\n\tif(d->ct_used>=4096) {\n\t\td->last_code_added = 0;\n\t\treturn 0;\n\t}\n\n\tnewpos = d->ct_used;\n\td->ct_used++;\n\n\td->ct[newpos].parent = (iw_uint16)oldcode;\n\td->ct[newpos].length = d->ct[oldcode].length + 1;\n\td->ct[newpos].firstchar = d->ct[oldcode].firstchar;\n\td->ct[newpos].lastchar = val;\n\n\t// If we've used the last code of this size, we need to increase the codesize.\n\tif(newpos == last_code_of_size[d->current_codesize]) {\n\t\tif(d->current_codesize<12) {\n\t\t\td->current_codesize++;\n\t\t}\n\t}\n\n\td->last_code_added = newpos;\n\treturn 1;\n}"", ""target"": 0}]","[{""func_name"": ""lzw_process_code"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static int lzw_process_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int code)\n{\n\tint ret;\n\n\tif(code==d->eoi_code) {\n\t\td->eoi_flag=1;\n\t\treturn 1;\n\t}\n\n\tif(code==d->clear_code) {\n\t\tlzw_clear(d);\n\t\treturn 1;\n\t}\n\n\td->ncodes_since_clear++;\n\n\tif(d->ncodes_since_clear==1) {\n\t\t// Special case for the first code.\n\t\tlzw_emit_code(rctx,d,code);\n\t\td->oldcode = code;\n\t\treturn 1;\n\t}\n\n\t// Is code in code table?\n\tif(code < d->ct_used) {\n\t\t// Yes, code is in table.\n\t\tlzw_emit_code(rctx,d,code);\n\n\t\t// Let k = the first character of the translation of the code.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tret = lzw_add_to_dict(rctx,d,d->oldcode,d->ct[code].firstchar);\n\t\tif(ret==0) return 0;\n\t}\n\telse {\n\t\t// No, code is not in table.\n\t\tif(d->oldcode>=d->ct_used) {\n\t\t\tiw_set_error(rctx->ctx,\""GIF decoding error\"");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Let k = the first char of the translation of oldcode.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tret = lzw_add_to_dict(rctx,d,d->oldcode,d->ct[d->oldcode].firstchar);\n\t\tif(ret==0) return 0;\n\t\tif(ret==1) {\n\t\t\t// Write <oldcode>k to the output stream.\n\t\t\tlzw_emit_code(rctx,d,d->last_code_added);\n\t\t}\n\t}\n\td->oldcode = code;\n\n\treturn 1;\n}""}, {""func_name"": ""lzw_add_to_dict"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static int lzw_add_to_dict(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\tunsigned int oldcode, iw_byte val)\n{\n\tstatic const unsigned int last_code_of_size[] = {\n\t\t// The first 3 values are unused.\n\t\t0,0,0,7,15,31,63,127,255,511,1023,2047,4095\n\t};\n\tunsigned int newpos;\n\n\tif(d->ct_used>=4096) {\n\t\td->last_code_added = 0;\n\t\treturn 2;\n\t}\n\n\tnewpos = d->ct_used;\n\n\tif(oldcode >= newpos) {\n\t\tiw_set_error(rctx->ctx, \""GIF decoding error\"");\n\t\treturn 0;\n\t}\n\n\td->ct_used++;\n\n\td->ct[newpos].parent = (iw_uint16)oldcode;\n\td->ct[newpos].length = d->ct[oldcode].length + 1;\n\td->ct[newpos].firstchar = d->ct[oldcode].firstchar;\n\td->ct[newpos].lastchar = val;\n\n\t// If we've used the last code of this size, we need to increase the codesize.\n\tif(newpos == last_code_of_size[d->current_codesize]) {\n\t\tif(d->current_codesize<12) {\n\t\t\td->current_codesize++;\n\t\t}\n\t}\n\n\td->last_code_added = newpos;\n\treturn 1;\n}""}]","{""value"": 8, ""caller"": 2, ""code"": 8, ""function"": 3}","[{""source"": ""value_info(file:imagew-gif.c, value:newpos)"", ""result"": {""value_trace"": [{""full_code"": ""newpos = d->ct_used"", ""line"": 341, ""func_name"": ""lzw_add_to_dict""}], ""struct_var"": ""newpos"", ""struct_type"": ""unsigned int"", ""struct_definition"": ""unsigned int""}}, {""source"": ""value_info(value:d->oldcode)"", ""result"": {""value_trace"": [{""full_code"": ""d->oldcode=0"", ""line"": 300, ""func_name"": ""lzw_clear""}, {""full_code"": ""d->oldcode = code"", ""line"": 379, ""func_name"": ""lzw_process_code""}, {""full_code"": ""d->oldcode = code"", ""line"": 406, ""func_name"": ""lzw_process_code""}], ""struct_var"": ""d"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:imagew-gif.c, func:lzw_process_code)"", ""result"": [{""call_line"": 435, ""call_code"": ""lzw_process_code(rctx,d,d->pending_code)"", ""caller_code"": ""static int lzw_process_bytes(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\tiw_byte *data, size_t data_size)\n{\n\tsize_t i;\n\tint b;\n\tint retval=0;\n\n\tfor(i=0;i<data_size;i++) {\n\t\t// Look at the bits one at a time.\n\t\tfor(b=0;b<8;b++) {\n\t\t\tif(d->eoi_flag) { // Stop if we've seen an EOI (end of image) code.\n\t\t\t\tretval=1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif(data[i]&(1<<b))\n\t\t\t\td->pending_code |= 1<<d->bits_in_pending_code;\n\t\t\td->bits_in_pending_code++;\n\n\t\t\t// When we get enough bits to form a complete LZW code, process it.\n\t\t\tif(d->bits_in_pending_code >= d->current_codesize) {\n\t\t\t\tif(!lzw_process_code(rctx,d,d->pending_code)) goto done;\n\t\t\t\td->pending_code=0;\n\t\t\t\td->bits_in_pending_code=0;\n\t\t\t}\n\t\t}\n\t}\n\tretval=1;\n\ndone:\n\treturn retval;\n}"", ""caller_start"": 414, ""file_path"": ""src/imagew-gif.c""}]}, {""source"": ""code_info(file:imagew-gif.c, lines:300-380)"", ""result"": ""\td->oldcode=0;\n}\n\n// Decode an LZW code to one or more pixels, and record it in the image.\nstatic void lzw_emit_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int first_code)\n{\n\tunsigned int code;\n\tcode = first_code;\n\n\t// An LZW code may decode to more than one pixel. Note that the pixels for\n\t// an LZW code are decoded in reverse order (right to left).\n\n\twhile(1) {\n\t\tiwgif_record_pixel(rctx, (unsigned int)d->ct[code].lastchar, (int)(d->ct[code].length-1));\n\t\tif(d->ct[code].length<=1) break;\n\t\t// The codes are structured as a \""forest\"" (multiple trees).\n\t\t// Go to the parent code, which will have a length 1 less than this one.\n\t\tcode = (unsigned int)d->ct[code].parent;\n\t}\n\n\t// Track the total number of pixels decoded in this image.\n\trctx->pixels_set += d->ct[first_code].length;\n}\n\n// Add a code to the dictionary.\n// Sets d->last_code_added to the position where it was added.\n// Returns 1 if successful, 0 if table is full.\nstatic int lzw_add_to_dict(struct lzwdeccontext *d, unsigned int oldcode, iw_byte val)\n{\n\tstatic const unsigned int last_code_of_size[] = {\n\t\t// The first 3 values are unused.\n\t\t0,0,0,7,15,31,63,127,255,511,1023,2047,4095\n\t};\n\tunsigned int newpos;\n\n\tif(d->ct_used>=4096) {\n\t\td->last_code_added = 0;\n\t\treturn 0;\n\t}\n\n\tnewpos = d->ct_used;\n\td->ct_used++;\n\n\td->ct[newpos].parent = (iw_uint16)oldcode;\n\td->ct[newpos].length = d->ct[oldcode].length + 1;\n\td->ct[newpos].firstchar = d->ct[oldcode].firstchar;\n\td->ct[newpos].lastchar = val;\n\n\t// If we've used the last code of this size, we need to increase the codesize.\n\tif(newpos == last_code_of_size[d->current_codesize]) {\n\t\tif(d->current_codesize<12) {\n\t\t\td->current_codesize++;\n\t\t}\n\t}\n\n\td->last_code_added = newpos;\n\treturn 1;\n}\n\n// Process a single LZW code that was read from the input stream.\nstatic int lzw_process_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int code)\n{\n\tif(code==d->eoi_code) {\n\t\td->eoi_flag=1;\n\t\treturn 1;\n\t}\n\n\tif(code==d->clear_code) {\n\t\tlzw_clear(d);\n\t\treturn 1;\n\t}\n\n\td->ncodes_since_clear++;\n\n\tif(d->ncodes_since_clear==1) {\n\t\t// Special case for the first code.\n\t\tlzw_emit_code(rctx,d,code);\n\t\td->oldcode = code;\n\t\treturn 1;\n""}, {""source"": ""value_info(file:imagew-gif.c, value:d->current_codesize)"", ""result"": {""value_trace"": [{""full_code"": ""d->current_codesize = d->root_codesize+1"", ""line"": 298, ""func_name"": ""lzw_clear""}, {""full_code"": ""d->current_codesize++"", ""line"": 352, ""func_name"": ""lzw_add_to_dict""}], ""struct_var"": ""d"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:imagew-gif.c, func:lzw_process_bytes)"", ""result"": [{""call_line"": 675, ""call_code"": ""lzw_process_bytes(rctx,&d,rctx->rbuf,subblocksize)"", ""caller_code"": ""static int iwgif_read_image(struct iwgifrcontext *rctx)\n{\n\tint retval=0;\n\tstruct lzwdeccontext d;\n\tsize_t subblocksize;\n\tint has_local_ct;\n\tint local_ct_size;\n\n\tunsigned int root_codesize;\n\n\t// Read image header information\n\tif(!iwgif_read(rctx,rctx->rbuf,9)) goto done;\n\n\trctx->image_left = (int)iw_get_ui16le(&rctx->rbuf[0]);\n\trctx->image_top = (int)iw_get_ui16le(&rctx->rbuf[2]);\n\t// image_left and _top may be updated in iwgif_init_screen().\n\n\trctx->image_width = (int)iw_get_ui16le(&rctx->rbuf[4]);\n\trctx->image_height = (int)iw_get_ui16le(&rctx->rbuf[6]);\n\tif(rctx->image_width<1 || rctx->image_height<1) {\n\t\tiw_set_error(rctx->ctx, \""Invalid image dimensions\"");\n\t\tgoto done;\n\t}\n\n\trctx->interlaced = (int)((rctx->rbuf[8]>>6)&0x01);\n\n\thas_local_ct = (int)((rctx->rbuf[8]>>7)&0x01);\n\tif(has_local_ct) {\n\t\tlocal_ct_size = (int)(rctx->rbuf[8]&0x07);\n\t\trctx->colortable.num_entries = 1<<(1+local_ct_size);\n\t}\n\n\tif(has_local_ct) {\n\t\t// We only support one image, so we don't need to keep both a global and a\n\t\t// local color table. If an image has both, the local table will overwrite\n\t\t// the global one.\n\t\tif(!iwgif_read_color_table(rctx,&rctx->colortable)) goto done;\n\t}\n\n\t// Make the transparent color transparent.\n\tif(rctx->has_transparency) {\n\t    rctx->colortable.entry[rctx->trans_color_index].a = 0;\n\t}\n\n\t// Read LZW code size\n\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\troot_codesize = (unsigned int)rctx->rbuf[0];\n\n\t// The spec does not allow the \""minimum code size\"" to be less than 2.\n\t// Sizes >=12 are impossible to support.\n\t// There's no reason for the size to be larger than 8, but the spec\n\t// does not seem to forbid it.\n\tif(root_codesize<2 || root_codesize>11) {\n\t\tiw_set_error(rctx->ctx,\""Invalid LZW minimum code size\"");\n\t\tgoto done;\n\t}\n\n\t// The creation of the global \""screen\"" was deferred until now, to wait until\n\t// we know whether the image has transparency.\n\t// (And if !rctx->include_screen, to wait until we know the size of the image.)\n\tif(!iwgif_init_screen(rctx)) goto done;\n\n\trctx->total_npixels = (size_t)rctx->image_width * (size_t)rctx->image_height;\n\n\tif(!iwgif_make_row_pointers(rctx)) goto done;\n\n\tlzw_init(&d,root_codesize);\n\tlzw_clear(&d);\n\n\twhile(1) {\n\t\t// Read size of next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\t\tsubblocksize = (size_t)rctx->rbuf[0];\n\t\tif(subblocksize==0) break;\n\n\t\t// Read next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,subblocksize)) goto done;\n\t\tif(!lzw_process_bytes(rctx,&d,rctx->rbuf,subblocksize)) goto done;\n\n\t\tif(d.eoi_flag) break;\n\n\t\t// Stop if we reached the end of the image. We don't care if we've read an\n\t\t// EOI code or not.\n\t\tif(rctx->pixels_set >= rctx->total_npixels) break;\n\t}\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}\n"", ""caller_start"": 598, ""file_path"": ""src/imagew-gif.c""}]}, {""source"": ""code_info(file:imagew-gif.c, lines:414-435)"", ""result"": ""static int lzw_process_bytes(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\tiw_byte *data, size_t data_size)\n{\n\tsize_t i;\n\tint b;\n\tint retval=0;\n\n\tfor(i=0;i<data_size;i++) {\n\t\t// Look at the bits one at a time.\n\t\tfor(b=0;b<8;b++) {\n\t\t\tif(d->eoi_flag) { // Stop if we've seen an EOI (end of image) code.\n\t\t\t\tretval=1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif(data[i]&(1<<b))\n\t\t\t\td->pending_code |= 1<<d->bits_in_pending_code;\n\t\t\td->bits_in_pending_code++;\n\n\t\t\t// When we get enough bits to form a complete LZW code, process it.\n\t\t\tif(d->bits_in_pending_code >= d->current_codesize) {\n\t\t\t\tif(!lzw_process_code(rctx,d,d->pending_code)) goto done;\n""}, {""source"": ""code_info(file:imagew-gif.c, lines:379-406)"", ""result"": ""\t\td->oldcode = code;\n\t\treturn 1;\n\t}\n\n\t// Is code in code table?\n\tif(code < d->ct_used) {\n\t\t// Yes, code is in table.\n\t\tlzw_emit_code(rctx,d,code);\n\n\t\t// Let k = the first character of the translation of the code.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tlzw_add_to_dict(d,d->oldcode,d->ct[code].firstchar);\n\t}\n\telse {\n\t\t// No, code is not in table.\n\t\tif(d->oldcode>=d->ct_used) {\n\t\t\tiw_set_error(rctx->ctx,\""GIF decoding error\"");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Let k = the first char of the translation of oldcode.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tif(lzw_add_to_dict(d,d->oldcode,d->ct[d->oldcode].firstchar)) {\n\t\t\t// Write <oldcode>k to the output stream.\n\t\t\tlzw_emit_code(rctx,d,d->last_code_added);\n\t\t}\n\t}\n\td->oldcode = code;\n""}, {""source"": ""value_info(file:imagew-gif.c, value:code)"", ""result"": {""value_trace"": [{""full_code"": ""code = first_code"", ""line"": 308, ""func_name"": ""lzw_emit_code""}, {""full_code"": ""code = (unsigned int)d->ct[code].parent"", ""line"": 318, ""func_name"": ""lzw_emit_code""}], ""struct_var"": ""code"", ""struct_type"": ""unsigned int"", ""struct_definition"": ""unsigned int""}}, {""source"": ""code_info(file:imagew-gif.c, lines:350-370)"", ""result"": ""\tif(newpos == last_code_of_size[d->current_codesize]) {\n\t\tif(d->current_codesize<12) {\n\t\t\td->current_codesize++;\n\t\t}\n\t}\n\n\td->last_code_added = newpos;\n\treturn 1;\n}\n\n// Process a single LZW code that was read from the input stream.\nstatic int lzw_process_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int code)\n{\n\tif(code==d->eoi_code) {\n\t\td->eoi_flag=1;\n\t\treturn 1;\n\t}\n\n\tif(code==d->clear_code) {\n\t\tlzw_clear(d);\n""}, {""source"": ""value_info(file:imagew-gif.c, value:d->pending_code)"", ""result"": {""value_trace"": [{""full_code"": ""d->pending_code |= 1<<d->bits_in_pending_code"", ""line"": 430, ""func_name"": ""lzw_process_bytes""}, {""full_code"": ""d->pending_code=0"", ""line"": 436, ""func_name"": ""lzw_process_bytes""}], ""struct_var"": ""d"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:lzw_process_bytes)"", ""result"": [{""code"": ""static int lzw_process_bytes(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\tiw_byte *data, size_t data_size)\n{\n\tsize_t i;\n\tint b;\n\tint retval=0;\n\n\tfor(i=0;i<data_size;i++) {\n\t\t// Look at the bits one at a time.\n\t\tfor(b=0;b<8;b++) {\n\t\t\tif(d->eoi_flag) { // Stop if we've seen an EOI (end of image) code.\n\t\t\t\tretval=1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif(data[i]&(1<<b))\n\t\t\t\td->pending_code |= 1<<d->bits_in_pending_code;\n\t\t\td->bits_in_pending_code++;\n\n\t\t\t// When we get enough bits to form a complete LZW code, process it.\n\t\t\tif(d->bits_in_pending_code >= d->current_codesize) {\n\t\t\t\tif(!lzw_process_code(rctx,d,d->pending_code)) goto done;\n\t\t\t\td->pending_code=0;\n\t\t\t\td->bits_in_pending_code=0;\n\t\t\t}\n\t\t}\n\t}\n\tretval=1;\n\ndone:\n\treturn retval;\n}"", ""start_line"": 414, ""end_line"": 445, ""full_name"": ""lzw_process_bytes"", ""file_path"": ""src/imagew-gif.c""}]}, {""source"": ""code_info(file:imagew-gif.c, lines:280-300)"", ""result"": ""\n\tiw_zeromem(d,sizeof(struct lzwdeccontext));\n\n\td->root_codesize = root_codesize;\n\td->num_root_codes = 1<<d->root_codesize;\n\td->clear_code = d->num_root_codes;\n\td->eoi_code = d->num_root_codes+1;\n\tfor(i=0;i<d->num_root_codes;i++) {\n\t\td->ct[i].parent = 0;\n\t\td->ct[i].length = 1;\n\t\td->ct[i].lastchar = (iw_byte)i;\n\t\td->ct[i].firstchar = (iw_byte)i;\n\t}\n}\n\nstatic void lzw_clear(struct lzwdeccontext *d)\n{\n\td->ct_used = d->num_root_codes+2;\n\td->current_codesize = d->root_codesize+1;\n\td->ncodes_since_clear=0;\n\td->oldcode=0;\n""}, {""source"": ""value_info(file:imagew-gif.c, value:d->bits_in_pending_code)"", ""result"": {""value_trace"": [{""full_code"": ""d->bits_in_pending_code++"", ""line"": 431, ""func_name"": ""lzw_process_bytes""}, {""full_code"": ""d->bits_in_pending_code=0"", ""line"": 437, ""func_name"": ""lzw_process_bytes""}], ""struct_var"": ""d"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:imagew-gif.c, lines:200-250)"", ""result"": ""{\n\tstruct iw_image *img;\n\tunsigned int r,g,b,a;\n\tsize_t pixnum;\n\tsize_t xi,yi; // position in image coordinates\n\tsize_t xs,ys; // position in screen coordinates\n\tiw_byte *ptr;\n\n\timg = rctx->img;\n\n\t// Figure out which pixel to set.\n\n\tpixnum = rctx->pixels_set + offset;\n\txi = pixnum%rctx->image_width;\n\tyi = pixnum/rctx->image_width;\n\txs = rctx->image_left + xi;\n\tys = rctx->image_top + yi;\n\n\t// Make sure the coordinate is within the image, and on the screen.\n\tif(yi>=(size_t)rctx->image_height) return;\n\tif(xs>=(size_t)rctx->screen_width) return;\n\tif(ys>=(size_t)rctx->screen_height) return;\n\n\t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n\t// is on the screen. The easiest way is to check if the row pointer is NULL.\n\tif(rctx->row_pointers[yi]==NULL) return;\n\n\t// Figure out what color to set the pixel to.\n\n\tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n\t\tr=rctx->colortable.entry[coloridx].r;\n\t\tg=rctx->colortable.entry[coloridx].g;\n\t\tb=rctx->colortable.entry[coloridx].b;\n\t\ta=rctx->colortable.entry[coloridx].a;\n\t}\n\telse {\n\t\treturn; // Illegal palette index\n\t}\n\n\t// Set the pixel.\n\n\tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n\tptr[0]=r; ptr[1]=g; ptr[2]=b;\n\tif(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tptr[3]=a;\n\t}\n}\n\n////////////////////////////////////////////////////////\n//                    LZW decoder\n////////////////////////////////////////////////////////\n""}, {""source"": ""code_info(file:imagew-gif.c, lines:430-440)"", ""result"": ""\t\t\t\td->pending_code |= 1<<d->bits_in_pending_code;\n\t\t\td->bits_in_pending_code++;\n\n\t\t\t// When we get enough bits to form a complete LZW code, process it.\n\t\t\tif(d->bits_in_pending_code >= d->current_codesize) {\n\t\t\t\tif(!lzw_process_code(rctx,d,d->pending_code)) goto done;\n\t\t\t\td->pending_code=0;\n\t\t\t\td->bits_in_pending_code=0;\n\t\t\t}\n\t\t}\n\t}\n""}, {""source"": ""value_info(file:imagew-gif.c, value:d->current_codesize)"", ""result"": {""value_trace"": [{""full_code"": ""d->current_codesize = d->root_codesize+1"", ""line"": 298, ""func_name"": ""lzw_clear""}, {""full_code"": ""d->current_codesize++"", ""line"": 352, ""func_name"": ""lzw_add_to_dict""}], ""struct_var"": ""d"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:imagew-gif.c, func:lzw_init)"", ""result"": [{""code"": ""static void lzw_init(struct lzwdeccontext *d, unsigned int root_codesize)\n{\n\tunsigned int i;\n\n\tiw_zeromem(d,sizeof(struct lzwdeccontext));\n\n\td->root_codesize = root_codesize;\n\td->num_root_codes = 1<<d->root_codesize;\n\td->clear_code = d->num_root_codes;\n\td->eoi_code = d->num_root_codes+1;\n\tfor(i=0;i<d->num_root_codes;i++) {\n\t\td->ct[i].parent = 0;\n\t\td->ct[i].length = 1;\n\t\td->ct[i].lastchar = (iw_byte)i;\n\t\td->ct[i].firstchar = (iw_byte)i;\n\t}\n}"", ""start_line"": 277, ""end_line"": 293, ""full_name"": ""lzw_init"", ""file_path"": ""src/imagew-gif.c""}]}, {""source"": ""code_info(file:imagew-gif.c, lines:420-440)"", ""result"": ""\n\tfor(i=0;i<data_size;i++) {\n\t\t// Look at the bits one at a time.\n\t\tfor(b=0;b<8;b++) {\n\t\t\tif(d->eoi_flag) { // Stop if we've seen an EOI (end of image) code.\n\t\t\t\tretval=1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif(data[i]&(1<<b))\n\t\t\t\td->pending_code |= 1<<d->bits_in_pending_code;\n\t\t\td->bits_in_pending_code++;\n\n\t\t\t// When we get enough bits to form a complete LZW code, process it.\n\t\t\tif(d->bits_in_pending_code >= d->current_codesize) {\n\t\t\t\tif(!lzw_process_code(rctx,d,d->pending_code)) goto done;\n\t\t\t\td->pending_code=0;\n\t\t\t\td->bits_in_pending_code=0;\n\t\t\t}\n\t\t}\n\t}\n""}, {""source"": ""value_info(file:imagew-gif.c, value:d->pending_code)"", ""result"": {""value_trace"": [{""full_code"": ""d->pending_code |= 1<<d->bits_in_pending_code"", ""line"": 430, ""func_name"": ""lzw_process_bytes""}, {""full_code"": ""d->pending_code=0"", ""line"": 436, ""func_name"": ""lzw_process_bytes""}], ""struct_var"": ""d"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:imagew-gif.c, func:lzw_process_code)"", ""result"": [{""code"": ""static int lzw_process_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int code)\n{\n\tif(code==d->eoi_code) {\n\t\td->eoi_flag=1;\n\t\treturn 1;\n\t}\n\n\tif(code==d->clear_code) {\n\t\tlzw_clear(d);\n\t\treturn 1;\n\t}\n\n\td->ncodes_since_clear++;\n\n\tif(d->ncodes_since_clear==1) {\n\t\t// Special case for the first code.\n\t\tlzw_emit_code(rctx,d,code);\n\t\td->oldcode = code;\n\t\treturn 1;\n\t}\n\n\t// Is code in code table?\n\tif(code < d->ct_used) {\n\t\t// Yes, code is in table.\n\t\tlzw_emit_code(rctx,d,code);\n\n\t\t// Let k = the first character of the translation of the code.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tlzw_add_to_dict(d,d->oldcode,d->ct[code].firstchar);\n\t}\n\telse {\n\t\t// No, code is not in table.\n\t\tif(d->oldcode>=d->ct_used) {\n\t\t\tiw_set_error(rctx->ctx,\""GIF decoding error\"");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Let k = the first char of the translation of oldcode.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tif(lzw_add_to_dict(d,d->oldcode,d->ct[d->oldcode].firstchar)) {\n\t\t\t// Write <oldcode>k to the output stream.\n\t\t\tlzw_emit_code(rctx,d,d->last_code_added);\n\t\t}\n\t}\n\td->oldcode = code;\n\n\treturn 1;\n}\n"", ""start_line"": 361, ""end_line"": 409, ""full_name"": ""lzw_process_code"", ""file_path"": ""src/imagew-gif.c""}]}]","1. GIF input data is parsed into LZW codes via bitstream accumulation in lzw_process_bytes (src/imagew-gif.c:435). \n2. The 'code' is derived from d->pending_code when d->bits_in_pending_code >= d->current_codesize (src/imagew-gif.c:435). \n3. 'code' is passed to lzw_process_code (src/imagew-gif.c:379), where it is assigned to d->oldcode without validation. \n4. lzw_add_to_dict (src/imagew-gif.c:337) uses d->oldcode (now 'oldcode') to add entries to the dictionary. If oldcode >= d->ct_used, the dictionary becomes corrupted, causing an infinite loop during LZW decoding. \n5. The patch adds bounds checks (src/imagew-gif.c:337-342) to reject invalid oldcode values and propagate errors.",1.0,./github/other_context/CVE-2017-9094
42,CVE-2018-15856,CWE-835,c_cpp,An infinite loop when reaching EOL unexpectedly in compose/parser.c (aka the keymap parser) in xkbcommon before 0.8.1 could be used by local attackers to cause a denial of service during parsing of crafted keymap files.,https://github.com/xkbcommon/libxkbcommon/commit/842e4351c2c97de6051cab6ce36b4a81e709a0e1,compose: fix infinite loop in parser on some inputs\n\nThe parser would enter an infinite loop if an unterminated keysym\nliteral occurs at EOF.\n\nFound with the afl fuzzer.\n\nSigned-off-by: Ran Benita <ran234@gmail.com>,1,"[{""func_name"": ""lex"", ""file_path"": ""src/compose/parser.c"", ""func_code"": ""static enum rules_token\nlex(struct scanner *s, union lvalue *val)\n{\nskip_more_whitespace_and_comments:\n    /* Skip spaces. */\n    while (is_space(peek(s)))\n        if (next(s) == '\\n')\n            return TOK_END_OF_LINE;\n\n    /* Skip comments. */\n    if (chr(s, '#')) {\n        skip_to_eol(s);\n        goto skip_more_whitespace_and_comments;\n    }\n\n    /* See if we're done. */\n    if (eof(s)) return TOK_END_OF_FILE;\n\n    /* New token. */\n    s->token_line = s->line;\n    s->token_column = s->column;\n    s->buf_pos = 0;\n\n    /* LHS Keysym. */\n    if (chr(s, '<')) {\n        while (peek(s) != '>' && !eol(s))\n            buf_append(s, next(s));\n        if (!chr(s, '>')) {\n            scanner_err(s, \""unterminated keysym literal\"");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \""keysym literal is too long\"");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_LHS_KEYSYM;\n    }\n\n    /* Colon. */\n    if (chr(s, ':'))\n        return TOK_COLON;\n    if (chr(s, '!'))\n        return TOK_BANG;\n    if (chr(s, '~'))\n        return TOK_TILDE;\n\n    /* String literal. */\n    if (chr(s, '\\\""')) {\n        while (!eof(s) && !eol(s) && peek(s) != '\\\""') {\n            if (chr(s, '\\\\')) {\n                uint8_t o;\n                if (chr(s, '\\\\')) {\n                    buf_append(s, '\\\\');\n                }\n                else if (chr(s, '\""')) {\n                    buf_append(s, '\""');\n                }\n                else if (chr(s, 'x') || chr(s, 'X')) {\n                    if (hex(s, &o))\n                        buf_append(s, (char) o);\n                    else\n                        scanner_warn(s, \""illegal hexadecimal escape sequence in string literal\"");\n                }\n                else if (oct(s, &o)) {\n                    buf_append(s, (char) o);\n                }\n                else {\n                    scanner_warn(s, \""unknown escape sequence (%c) in string literal\"", peek(s));\n                    /* Ignore. */\n                }\n            } else {\n                buf_append(s, next(s));\n            }\n        }\n        if (!chr(s, '\\\""')) {\n            scanner_err(s, \""unterminated string literal\"");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \""string literal is too long\"");\n            return TOK_ERROR;\n        }\n        if (!is_valid_utf8(s->buf, s->buf_pos - 1)) {\n            scanner_err(s, \""string literal is not a valid UTF-8 string\"");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_STRING;\n    }\n\n    /* Identifier or include. */\n    if (is_alpha(peek(s)) || peek(s) == '_') {\n        s->buf_pos = 0;\n        while (is_alnum(peek(s)) || peek(s) == '_')\n            buf_append(s, next(s));\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \""identifier is too long\"");\n            return TOK_ERROR;\n        }\n\n        if (streq(s->buf, \""include\""))\n            return TOK_INCLUDE;\n\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_IDENT;\n    }\n\n    /* Discard rest of line. */\n    skip_to_eol(s);\n\n    scanner_err(s, \""unrecognized token\"");\n    return TOK_ERROR;\n}"", ""target"": 0}]","[{""func_name"": ""lex"", ""file_path"": ""src/compose/parser.c"", ""func_code"": ""static enum rules_token\nlex(struct scanner *s, union lvalue *val)\n{\nskip_more_whitespace_and_comments:\n    /* Skip spaces. */\n    while (is_space(peek(s)))\n        if (next(s) == '\\n')\n            return TOK_END_OF_LINE;\n\n    /* Skip comments. */\n    if (chr(s, '#')) {\n        skip_to_eol(s);\n        goto skip_more_whitespace_and_comments;\n    }\n\n    /* See if we're done. */\n    if (eof(s)) return TOK_END_OF_FILE;\n\n    /* New token. */\n    s->token_line = s->line;\n    s->token_column = s->column;\n    s->buf_pos = 0;\n\n    /* LHS Keysym. */\n    if (chr(s, '<')) {\n        while (peek(s) != '>' && !eol(s) && !eof(s))\n            buf_append(s, next(s));\n        if (!chr(s, '>')) {\n            scanner_err(s, \""unterminated keysym literal\"");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \""keysym literal is too long\"");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_LHS_KEYSYM;\n    }\n\n    /* Colon. */\n    if (chr(s, ':'))\n        return TOK_COLON;\n    if (chr(s, '!'))\n        return TOK_BANG;\n    if (chr(s, '~'))\n        return TOK_TILDE;\n\n    /* String literal. */\n    if (chr(s, '\\\""')) {\n        while (!eof(s) && !eol(s) && peek(s) != '\\\""') {\n            if (chr(s, '\\\\')) {\n                uint8_t o;\n                if (chr(s, '\\\\')) {\n                    buf_append(s, '\\\\');\n                }\n                else if (chr(s, '\""')) {\n                    buf_append(s, '\""');\n                }\n                else if (chr(s, 'x') || chr(s, 'X')) {\n                    if (hex(s, &o))\n                        buf_append(s, (char) o);\n                    else\n                        scanner_warn(s, \""illegal hexadecimal escape sequence in string literal\"");\n                }\n                else if (oct(s, &o)) {\n                    buf_append(s, (char) o);\n                }\n                else {\n                    scanner_warn(s, \""unknown escape sequence (%c) in string literal\"", peek(s));\n                    /* Ignore. */\n                }\n            } else {\n                buf_append(s, next(s));\n            }\n        }\n        if (!chr(s, '\\\""')) {\n            scanner_err(s, \""unterminated string literal\"");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \""string literal is too long\"");\n            return TOK_ERROR;\n        }\n        if (!is_valid_utf8(s->buf, s->buf_pos - 1)) {\n            scanner_err(s, \""string literal is not a valid UTF-8 string\"");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_STRING;\n    }\n\n    /* Identifier or include. */\n    if (is_alpha(peek(s)) || peek(s) == '_') {\n        s->buf_pos = 0;\n        while (is_alnum(peek(s)) || peek(s) == '_')\n            buf_append(s, next(s));\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \""identifier is too long\"");\n            return TOK_ERROR;\n        }\n\n        if (streq(s->buf, \""include\""))\n            return TOK_INCLUDE;\n\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_IDENT;\n    }\n\n    /* Discard rest of line. */\n    skip_to_eol(s);\n\n    scanner_err(s, \""unrecognized token\"");\n    return TOK_ERROR;\n}""}]","{""value"": 1, ""function"": 2}","[{""source"": ""value_info(file:parser.c, value:s)"", ""result"": {""value_trace"": [{""full_code"": ""s = string"", ""line"": 77, ""func_name"": ""resolve_name""}, {""full_code"": ""s++"", ""line"": 85, ""func_name"": ""resolve_name""}, {""full_code"": ""s++"", ""line"": 90, ""func_name"": ""resolve_name""}, {""full_code"": ""s++"", ""line"": 97, ""func_name"": ""resolve_name""}, {""full_code"": ""s++"", ""line"": 102, ""func_name"": ""resolve_name""}], ""struct_var"": ""s"", ""struct_type"": ""scanner"", ""struct_definition"": ""struct scanner\n\nstruct scanner {\n    const char *s;\n    size_t pos;\n    size_t len;\n    char buf[1024];\n    size_t buf_pos;\n    unsigned line, column;\n    /* The line/column of the start of the current token. */\n    unsigned token_line, token_column;\n    const char *file_name;\n    struct xkb_context *ctx;\n    void *priv;\n}\n\nstruct scanner""}}, {""source"": ""func_info(func:eof)"", ""result"": [{""code"": ""static inline bool\neof(struct scanner *s)\n{\n    return s->pos >= s->len;\n}"", ""start_line"": 95, ""end_line"": 99, ""full_name"": ""eof"", ""file_path"": ""src/scanner-utils.h""}]}, {""source"": ""func_info(func:eol)"", ""result"": [{""code"": ""static inline bool\neol(struct scanner *s)\n{\n    return peek(s) == '\\n';\n}"", ""start_line"": 101, ""end_line"": 105, ""full_name"": ""eol"", ""file_path"": ""src/scanner-utils.h""}]}]","src/compose/parser.c:145-155: The loop condition in `lex` lacked an EOF check, allowing infinite iteration when parsing unterminated keysym literals at EOF. The patch added `&& !eof(s)` to terminate the loop. The `eof(s)` function (src/scanner-utils.h:95-99) checks `s->pos >= s->len` to detect EOF. The `scanner` struct (src/compose/parser.c) tracks input length and position, enabling accurate EOF detection.",0.95,./github/other_context/CVE-2018-15856
43,CVE-2018-6544,CWE-674,c_cpp,"pdf_load_obj_stm in pdf/pdf-xref.c in Artifex MuPDF 1.12.0 could reference the object stream recursively and therefore run out of error stack, which allows remote attackers to cause a denial of service via a crafted PDF document.",https://github.com/ArtifexSoftware/mupdf/commit/b03def134988da8c800adac1a38a41a1f09a1d89,"Bug 698830: Avoid recursion when loading object streams objects.\n\nIf there were indirect references in the object stream dictionary and\none of those indirect references referred to an object inside the object\nstream itself, mupdf would previously enter recursion only bounded by the\nexception stack. After this commit the object stream is checked if it is\nmarked immediately after being loaded. If it is marked then we terminate\nthe recursion at this point, if it is not marked then mark it and\nattempt to load the desired object within. We also take care to unmark\nthe stream object when done or upon exception.",2,"[{""func_name"": ""pdf_open_raw_filter"", ""file_path"": ""source/pdf/pdf-stream.c"", ""func_code"": ""static fz_stream *\npdf_open_raw_filter(fz_context *ctx, fz_stream *chain, pdf_document *doc, pdf_obj *stmobj, int num, int *orig_num, int *orig_gen, int64_t offset)\n{\n\tpdf_xref_entry *x = NULL;\n\tfz_stream *chain2;\n\tint hascrypt;\n\tint len;\n\n\tif (num > 0 && num < pdf_xref_len(ctx, doc))\n\t{\n\t\tx = pdf_get_xref_entry(ctx, doc, num);\n\t\t*orig_num = x->num;\n\t\t*orig_gen = x->gen;\n\t\tif (x->stm_buf)\n\t\t\treturn fz_open_buffer(ctx, x->stm_buf);\n\t}\n\telse\n\t{\n\t\t/* We only end up here when called from pdf_open_stream_with_offset to parse new format XRef sections. */\n\t\t/* New style XRef sections must have generation number 0. */\n\t\t*orig_num = num;\n\t\t*orig_gen = 0;\n\t}\n\n\tfz_var(chain);\n\n\tfz_try(ctx)\n\t{\n\t\tlen = pdf_to_int(ctx, pdf_dict_get(ctx, stmobj, PDF_NAME_Length));\n\n\t\t/* don't close chain when we close this filter */\n\t\tchain2 = fz_keep_stream(ctx, chain);\n\t\tchain = NULL;\n\t\tchain = fz_open_null(ctx, chain2, len, offset);\n\n\t\thascrypt = pdf_stream_has_crypt(ctx, stmobj);\n\t\tif (doc->crypt && !hascrypt)\n\t\t{\n\t\t\tchain2 = chain;\n\t\t\tchain = NULL;\n\t\t\tchain = pdf_open_crypt(ctx, chain2, doc->crypt, *orig_num, *orig_gen);\n\t\t}\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_drop_stream(ctx, chain);\n\t\tfz_rethrow(ctx);\n\t}\n\n\treturn chain;\n}"", ""target"": 1}, {""func_name"": ""pdf_load_obj_stm"", ""file_path"": ""source/pdf/pdf-xref.c"", ""func_code"": ""static pdf_xref_entry *\npdf_load_obj_stm(fz_context *ctx, pdf_document *doc, int num, pdf_lexbuf *buf, int target)\n{\n\tfz_stream *stm = NULL;\n\tpdf_obj *objstm = NULL;\n\tint *numbuf = NULL;\n\tint64_t *ofsbuf = NULL;\n\n\tpdf_obj *obj;\n\tint64_t first;\n\tint count;\n\tint i;\n\tpdf_token tok;\n\tpdf_xref_entry *ret_entry = NULL;\n\n\tfz_var(numbuf);\n\tfz_var(ofsbuf);\n\tfz_var(objstm);\n\tfz_var(stm);\n\n\tfz_try(ctx)\n\t{\n\t\tobjstm = pdf_load_object(ctx, doc, num);\n\n\t\tcount = pdf_to_int(ctx, pdf_dict_get(ctx, objstm, PDF_NAME_N));\n\t\tfirst = pdf_to_int(ctx, pdf_dict_get(ctx, objstm, PDF_NAME_First));\n\n\t\tif (count < 0)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \""negative number of objects in object stream\"");\n\t\tif (first < 0)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \""first object in object stream resides outside stream\"");\n\n\t\tnumbuf = fz_calloc(ctx, count, sizeof(*numbuf));\n\t\tofsbuf = fz_calloc(ctx, count, sizeof(*ofsbuf));\n\n\t\tstm = pdf_open_stream_number(ctx, doc, num);\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\ttok = pdf_lex(ctx, stm, buf);\n\t\t\tif (tok != PDF_TOK_INT)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \""corrupt object stream (%d 0 R)\"", num);\n\t\t\tnumbuf[i] = buf->i;\n\n\t\t\ttok = pdf_lex(ctx, stm, buf);\n\t\t\tif (tok != PDF_TOK_INT)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \""corrupt object stream (%d 0 R)\"", num);\n\t\t\tofsbuf[i] = buf->i;\n\t\t}\n\n\t\tfz_seek(ctx, stm, first, SEEK_SET);\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tint xref_len = pdf_xref_len(ctx, doc);\n\t\t\tpdf_xref_entry *entry;\n\t\t\tfz_seek(ctx, stm, first + ofsbuf[i], SEEK_SET);\n\n\t\t\tobj = pdf_parse_stm_obj(ctx, doc, stm, buf);\n\n\t\t\tif (numbuf[i] <= 0 || numbuf[i] >= xref_len)\n\t\t\t{\n\t\t\t\tpdf_drop_obj(ctx, obj);\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \""object id (%d 0 R) out of range (0..%d)\"", numbuf[i], xref_len - 1);\n\t\t\t}\n\n\t\t\tentry = pdf_get_xref_entry(ctx, doc, numbuf[i]);\n\n\t\t\tpdf_set_obj_parent(ctx, obj, numbuf[i]);\n\n\t\t\tif (entry->type == 'o' && entry->ofs == num)\n\t\t\t{\n\t\t\t\t/* If we already have an entry for this object,\n\t\t\t\t * we'd like to drop it and use the new one -\n\t\t\t\t * but this means that anyone currently holding\n\t\t\t\t * a pointer to the old one will be left with a\n\t\t\t\t * stale pointer. Instead, we drop the new one\n\t\t\t\t * and trust that the old one is correct. */\n\t\t\t\tif (entry->obj)\n\t\t\t\t{\n\t\t\t\t\tif (pdf_objcmp(ctx, entry->obj, obj))\n\t\t\t\t\t\tfz_warn(ctx, \""Encountered new definition for object %d - keeping the original one\"", numbuf[i]);\n\t\t\t\t\tpdf_drop_obj(ctx, obj);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tentry->obj = obj;\n\t\t\t\t\tfz_drop_buffer(ctx, entry->stm_buf);\n\t\t\t\t\tentry->stm_buf = NULL;\n\t\t\t\t}\n\t\t\t\tif (numbuf[i] == target)\n\t\t\t\t\tret_entry = entry;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpdf_drop_obj(ctx, obj);\n\t\t\t}\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_stream(ctx, stm);\n\t\tfz_free(ctx, ofsbuf);\n\t\tfz_free(ctx, numbuf);\n\t\tpdf_drop_obj(ctx, objstm);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n\treturn ret_entry;\n}"", ""target"": 0}]","[{""func_name"": ""pdf_open_raw_filter"", ""file_path"": ""source/pdf/pdf-stream.c"", ""func_code"": ""static fz_stream *\npdf_open_raw_filter(fz_context *ctx, fz_stream *chain, pdf_document *doc, pdf_obj *stmobj, int num, int *orig_num, int *orig_gen, int64_t offset)\n{\n\tpdf_xref_entry *x = NULL;\n\tfz_stream *chain2;\n\tint hascrypt;\n\tint len;\n\n\tif (num > 0 && num < pdf_xref_len(ctx, doc))\n\t{\n\t\tx = pdf_get_xref_entry(ctx, doc, num);\n\t\t*orig_num = x->num;\n\t\t*orig_gen = x->gen;\n\t\tif (x->stm_buf)\n\t\t\treturn fz_open_buffer(ctx, x->stm_buf);\n\t}\n\telse\n\t{\n\t\t/* We only end up here when called from pdf_open_stream_with_offset to parse new format XRef sections. */\n\t\t/* New style XRef sections must have generation number 0. */\n\t\t*orig_num = num;\n\t\t*orig_gen = 0;\n\t}\n\n\tchain = fz_keep_stream(ctx, chain);\n\n\tfz_try(ctx)\n\t{\n\t\tlen = pdf_to_int(ctx, pdf_dict_get(ctx, stmobj, PDF_NAME_Length));\n\n\t\tchain2 = chain;\n\t\tchain = NULL;\n\t\tchain = fz_open_null(ctx, chain2, len, offset);\n\n\t\thascrypt = pdf_stream_has_crypt(ctx, stmobj);\n\t\tif (doc->crypt && !hascrypt)\n\t\t{\n\t\t\tchain2 = chain;\n\t\t\tchain = NULL;\n\t\t\tchain = pdf_open_crypt(ctx, chain2, doc->crypt, *orig_num, *orig_gen);\n\t\t}\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_drop_stream(ctx, chain);\n\t\tfz_rethrow(ctx);\n\t}\n\n\treturn chain;\n}""}, {""func_name"": ""pdf_load_obj_stm"", ""file_path"": ""source/pdf/pdf-xref.c"", ""func_code"": ""static pdf_xref_entry *\npdf_load_obj_stm(fz_context *ctx, pdf_document *doc, int num, pdf_lexbuf *buf, int target)\n{\n\tfz_stream *stm = NULL;\n\tpdf_obj *objstm = NULL;\n\tint *numbuf = NULL;\n\tint64_t *ofsbuf = NULL;\n\n\tpdf_obj *obj;\n\tint64_t first;\n\tint count;\n\tint i;\n\tpdf_token tok;\n\tpdf_xref_entry *ret_entry = NULL;\n\n\tfz_var(numbuf);\n\tfz_var(ofsbuf);\n\tfz_var(objstm);\n\tfz_var(stm);\n\n\tfz_try(ctx)\n\t{\n\t\tobjstm = pdf_load_object(ctx, doc, num);\n\n\t\tif (pdf_obj_marked(ctx, objstm))\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \""recursive object stream lookup\"");\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, objstm);\n\t\tfz_rethrow(ctx);\n\t}\n\n\tfz_try(ctx)\n\t{\n\t\tpdf_mark_obj(ctx, objstm);\n\n\t\tcount = pdf_to_int(ctx, pdf_dict_get(ctx, objstm, PDF_NAME_N));\n\t\tfirst = pdf_to_int(ctx, pdf_dict_get(ctx, objstm, PDF_NAME_First));\n\n\t\tif (count < 0)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \""negative number of objects in object stream\"");\n\t\tif (first < 0)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \""first object in object stream resides outside stream\"");\n\n\t\tnumbuf = fz_calloc(ctx, count, sizeof(*numbuf));\n\t\tofsbuf = fz_calloc(ctx, count, sizeof(*ofsbuf));\n\n\t\tstm = pdf_open_stream_number(ctx, doc, num);\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\ttok = pdf_lex(ctx, stm, buf);\n\t\t\tif (tok != PDF_TOK_INT)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \""corrupt object stream (%d 0 R)\"", num);\n\t\t\tnumbuf[i] = buf->i;\n\n\t\t\ttok = pdf_lex(ctx, stm, buf);\n\t\t\tif (tok != PDF_TOK_INT)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \""corrupt object stream (%d 0 R)\"", num);\n\t\t\tofsbuf[i] = buf->i;\n\t\t}\n\n\t\tfz_seek(ctx, stm, first, SEEK_SET);\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tint xref_len = pdf_xref_len(ctx, doc);\n\t\t\tpdf_xref_entry *entry;\n\t\t\tfz_seek(ctx, stm, first + ofsbuf[i], SEEK_SET);\n\n\t\t\tobj = pdf_parse_stm_obj(ctx, doc, stm, buf);\n\n\t\t\tif (numbuf[i] <= 0 || numbuf[i] >= xref_len)\n\t\t\t{\n\t\t\t\tpdf_drop_obj(ctx, obj);\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \""object id (%d 0 R) out of range (0..%d)\"", numbuf[i], xref_len - 1);\n\t\t\t}\n\n\t\t\tentry = pdf_get_xref_entry(ctx, doc, numbuf[i]);\n\n\t\t\tpdf_set_obj_parent(ctx, obj, numbuf[i]);\n\n\t\t\tif (entry->type == 'o' && entry->ofs == num)\n\t\t\t{\n\t\t\t\t/* If we already have an entry for this object,\n\t\t\t\t * we'd like to drop it and use the new one -\n\t\t\t\t * but this means that anyone currently holding\n\t\t\t\t * a pointer to the old one will be left with a\n\t\t\t\t * stale pointer. Instead, we drop the new one\n\t\t\t\t * and trust that the old one is correct. */\n\t\t\t\tif (entry->obj)\n\t\t\t\t{\n\t\t\t\t\tif (pdf_objcmp(ctx, entry->obj, obj))\n\t\t\t\t\t\tfz_warn(ctx, \""Encountered new definition for object %d - keeping the original one\"", numbuf[i]);\n\t\t\t\t\tpdf_drop_obj(ctx, obj);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tentry->obj = obj;\n\t\t\t\t\tfz_drop_buffer(ctx, entry->stm_buf);\n\t\t\t\t\tentry->stm_buf = NULL;\n\t\t\t\t}\n\t\t\t\tif (numbuf[i] == target)\n\t\t\t\t\tret_entry = entry;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpdf_drop_obj(ctx, obj);\n\t\t\t}\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_stream(ctx, stm);\n\t\tfz_free(ctx, ofsbuf);\n\t\tfz_free(ctx, numbuf);\n\t\tpdf_unmark_obj(ctx, objstm);\n\t\tpdf_drop_obj(ctx, objstm);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n\treturn ret_entry;\n}""}]","{""function"": 6}","[{""source"": ""func_info(func:pdf_obj_marked)"", ""result"": [{""code"": ""int\npdf_obj_marked(fz_context *ctx, pdf_obj *obj)\n{\n\tRESOLVE(obj);\n\tif (obj < PDF_OBJ__LIMIT)\n\t\treturn 0;\n\treturn !!(obj->flags & PDF_FLAGS_MARKED);\n}"", ""start_line"": 1597, ""end_line"": 1604, ""full_name"": ""pdf_obj_marked"", ""file_path"": ""source/pdf/pdf-object.c""}]}, {""source"": ""func_info(func:pdf_obj_marked)"", ""result"": [{""code"": ""int\npdf_obj_marked(fz_context *ctx, pdf_obj *obj)\n{\n\tRESOLVE(obj);\n\tif (obj < PDF_OBJ__LIMIT)\n\t\treturn 0;\n\treturn !!(obj->flags & PDF_FLAGS_MARKED);\n}"", ""start_line"": 1597, ""end_line"": 1604, ""full_name"": ""pdf_obj_marked"", ""file_path"": ""source/pdf/pdf-object.c""}]}, {""source"": ""func_info(func:pdf_mark_obj)"", ""result"": [{""code"": ""int\npdf_mark_obj(fz_context *ctx, pdf_obj *obj)\n{\n\tint marked;\n\tRESOLVE(obj);\n\tif (obj < PDF_OBJ__LIMIT)\n\t\treturn 0;\n\tmarked = !!(obj->flags & PDF_FLAGS_MARKED);\n\tobj->flags |= PDF_FLAGS_MARKED;\n\treturn marked;\n}"", ""start_line"": 1606, ""end_line"": 1616, ""full_name"": ""pdf_mark_obj"", ""file_path"": ""source/pdf/pdf-object.c""}]}, {""source"": ""func_info(func:pdf_mark_obj)"", ""result"": [{""code"": ""int\npdf_mark_obj(fz_context *ctx, pdf_obj *obj)\n{\n\tint marked;\n\tRESOLVE(obj);\n\tif (obj < PDF_OBJ__LIMIT)\n\t\treturn 0;\n\tmarked = !!(obj->flags & PDF_FLAGS_MARKED);\n\tobj->flags |= PDF_FLAGS_MARKED;\n\treturn marked;\n}"", ""start_line"": 1606, ""end_line"": 1616, ""full_name"": ""pdf_mark_obj"", ""file_path"": ""source/pdf/pdf-object.c""}]}, {""source"": ""func_info(func:pdf_unmark_obj)"", ""result"": [{""code"": ""void\npdf_unmark_obj(fz_context *ctx, pdf_obj *obj)\n{\n\tRESOLVE(obj);\n\tif (obj < PDF_OBJ__LIMIT)\n\t\treturn;\n\tobj->flags &= ~PDF_FLAGS_MARKED;\n}"", ""start_line"": 1618, ""end_line"": 1625, ""full_name"": ""pdf_unmark_obj"", ""file_path"": ""source/pdf/pdf-object.c""}]}, {""source"": ""func_info(func:pdf_unmark_obj)"", ""result"": [{""code"": ""void\npdf_unmark_obj(fz_context *ctx, pdf_obj *obj)\n{\n\tRESOLVE(obj);\n\tif (obj < PDF_OBJ__LIMIT)\n\t\treturn;\n\tobj->flags &= ~PDF_FLAGS_MARKED;\n}"", ""start_line"": 1618, ""end_line"": 1625, ""full_name"": ""pdf_unmark_obj"", ""file_path"": ""source/pdf/pdf-object.c""}]}]","source/pdf/pdf-xref.c:1576-1669: pdf_load_obj_stm loads an object stream (objstm) and checks pdf_obj_marked(ctx, objstm) to detect recursion. If marked, it throws an exception (fz_throw). source/pdf/pdf-object.c:1597-1625: pdf_obj_marked, pdf_mark_obj, and pdf_unmark_obj manage the PDF_FLAGS_MARKED bit in obj->flags to track active loads. This prevents recursive calls to pdf_load_obj_stm by marking the stream during loading and unmarking it afterward.",0.95,./github/other_context/CVE-2018-6544
44,CVE-2018-7330,CWE-835,c_cpp,"In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thread.c had an infinite loop that was addressed by using a correct integer data type.",https://github.com/wireshark/wireshark/commit/8ad0c5b3683a17d9e2e16bbf25869140fd5c1c66,Thread: use wider variables to prevent overflow and infinite loops\n\nBug: 14428\nChange-Id: I5536bdca23b24e41c13c0837d1f50d9db26f864a\nReviewed-on: https://code.wireshark.org/review/25832\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit 49e331c4cec96a1ca2637eed48f67553bc53a5b9)\nReviewed-on: https://code.wireshark.org/review/25833\nPetri-Dish: Michael Mann <mmann78@netscape.net>,2,"[{""func_name"": ""get_chancount"", ""file_path"": ""epan/dissectors/packet-thread.c"", ""func_code"": ""static guint\nget_chancount(tvbuff_t *tvb)\n{\n    guint         offset;\n    guint8        tlv_type;\n    guint16       tlv_len;\n    tlv_len_len_e tlv_len_len;\n    guint         chancount = THREAD_MC_INVALID_CHAN_COUNT;\n\n    offset = 0;\n\n    /* Thread Network Data TLVs */\n    while (tvb_offset_exists(tvb, offset)) {\n\n        /* Get the type and length ahead of time to pass to next function so we can highlight\n           proper amount of bytes */\n        tlv_type = tvb_get_guint8(tvb, offset);\n        tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);\n\n        /* TODO: need to make sure this applies to all MeshCoP TLVs */\n        if (THREAD_TLV_LENGTH_ESC == tlv_len) {\n            /* 16-bit length field */\n            tlv_len = tvb_get_ntohs(tvb, offset + 2);\n            tlv_len_len = TLV_LEN_LEN16;\n        } else {\n            tlv_len_len = TLV_LEN_LEN8;\n        }\n\n        /* Skip over Type and Length */\n        offset += 1 + tlv_len_len;\n\n        switch(tlv_type) {\n\n            case THREAD_MC_TLV_CHANNEL_MASK:\n                {\n                    int i, j;\n                    guint8 entries = 0;\n                    gint32 check_len = tlv_len;\n                    guint8 check_offset = offset + 1; /* Channel page first */\n                    guint8 masklen;\n\n                    /* Check consistency of entries */\n                    while (check_len > 0) {\n\n                        masklen = tvb_get_guint8(tvb, check_offset);\n                        if (masklen == 0) {\n                            break; /* Get out or we might spin forever */\n                        }\n                        masklen += 2; /* Add in page and length */\n                        check_offset += masklen;\n                        check_len -= masklen;\n                        entries++;\n                    }\n\n                    if (check_len != 0) {\n                        /* Not an integer number of entries */\n                        /* offset += tlv_len; */\n                        return chancount;\n                    } else {\n                        chancount = 0;\n                        for (i = 0; i < entries; i++) {\n                            /* Skip over channel page */\n                            offset++;\n                            masklen = tvb_get_guint8(tvb, offset);\n                            offset++;\n                            /* Count the number of channels in the channel mask */\n                            for (j = 0; j < masklen; j++) {\n                                chancount += count_bits_in_byte(tvb_get_guint8(tvb, offset));\n                                offset++;\n                            }\n                        }\n                    }\n                }\n                break;\n\n            default:\n                /* Skip over any other TLVs */\n                offset += tlv_len;\n        }\n    }\n    return chancount;\n}"", ""target"": 0}, {""func_name"": ""dissect_thread_mc"", ""file_path"": ""epan/dissectors/packet-thread.c"", ""func_code"": ""static int\ndissect_thread_mc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    proto_item    *proto_root;\n    proto_tree    *thread_mc_tree;\n    proto_tree    *tlv_tree;\n    guint         offset = 0;\n    proto_item    *ti;\n    proto_item    *pi;\n    guint8        tlv_type;\n    guint16       tlv_len;\n    tlv_len_len_e tlv_len_len;\n    guint         chancount;\n\n\n    /* Create the protocol tree. */\n    proto_root = proto_tree_add_item(tree, proto_thread_mc, tvb, 0, tvb_reported_length(tvb), ENC_NA);\n    thread_mc_tree = proto_item_add_subtree(proto_root, ett_thread_mc);\n\n    /* Get channel count a priori so we can process energy list better */\n    chancount = get_chancount(tvb);\n\n    /* Thread Network Data TLVs */\n    while (tvb_offset_exists(tvb, offset)) {\n\n        /* Get the type and length ahead of time to pass to next function so we can highlight\n           proper amount of bytes */\n        tlv_type = tvb_get_guint8(tvb, offset);\n        tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);\n\n        /* TODO: need to make sure this applies to all MeshCoP TLVs */\n        if (THREAD_TLV_LENGTH_ESC == tlv_len) {\n            /* 16-bit length field */\n            tlv_len = tvb_get_ntohs(tvb, offset + 2);\n            tlv_len_len = TLV_LEN_LEN16;\n        } else {\n            tlv_len_len = TLV_LEN_LEN8;\n        }\n\n        /* Create the tree */\n        ti = proto_tree_add_item(thread_mc_tree, hf_thread_mc_tlv, tvb, offset, 1 + tlv_len_len + tlv_len, ENC_NA);\n        tlv_tree = proto_item_add_subtree(ti, ett_thread_mc_tlv);\n\n        /* Type */\n        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Add value name to value root label */\n        proto_item_append_text(ti, \"" (%s)\"", val_to_str(tlv_type, thread_mc_tlv_vals, \""Unknown (%d)\""));\n\n        /* Length */\n        switch (tlv_len_len) {\n            case TLV_LEN_LEN8:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_length8, tvb, offset, 1, ENC_BIG_ENDIAN);\n                break;\n            case TLV_LEN_LEN16:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_length16, tvb, offset + 1, 2, ENC_BIG_ENDIAN);\n                break;\n            default:\n                break;\n        }\n        offset += tlv_len_len;\n\n        switch(tlv_type) {\n            case THREAD_MC_TLV_CHANNEL:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 3) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Channel page */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_channel_page, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        /* Channel */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_channel, tvb, offset+1, 2, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PANID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* PAN ID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_pan_id, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_XPANID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* PAN ID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_xpan_id, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_NAME:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_net_name, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PSKC:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_pskc, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_MASTER_KEY:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_master_key, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_KEY_SEQ_CTR:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 4) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_net_key_seq_ctr, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_ML_PREFIX:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        struct e_in6_addr prefix;\n\n                        memset(&prefix, 0, sizeof(prefix));\n                        tvb_memcpy(tvb, (guint8 *)&prefix.bytes, offset, tlv_len);\n                        pi = proto_tree_add_ipv6(tlv_tree, hf_thread_mc_tlv_ml_prefix, tvb, offset, tlv_len, &prefix);\n                        proto_item_append_text(pi, \""/%d\"", tlv_len * 8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_STEERING_DATA:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Display it simply */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_steering_data, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_BORDER_AGENT_LOCATOR:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_ba_locator, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_ID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_commissioner_id, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_SESSION_ID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_commissioner_sess_id, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_SECURITY_POLICY:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 3) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_rot, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_o, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_n, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_r, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_c, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_b, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_GET:\n                {\n                    int i;\n\n                    for (i = 0; i < tlv_len; i++) {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_ACTIVE_TSTAMP:\n            case THREAD_MC_TLV_PENDING_TSTAMP:\n                {\n                    nstime_t timestamp;\n\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Fill in the nstime_t structure */\n                        timestamp.secs = (time_t)tvb_get_ntoh48(tvb, offset);\n                        timestamp.nsecs = (int)lround((double)(tvb_get_ntohs(tvb, offset + 6) >> 1) * THREAD_MC_32768_TO_NSEC_FACTOR);\n                        if (tlv_type == THREAD_MC_TLV_ACTIVE_TSTAMP) {\n                            proto_tree_add_time(tlv_tree, hf_thread_mc_tlv_active_tstamp, tvb, offset, 8, &timestamp);\n                        } else {\n                            proto_tree_add_time(tlv_tree, hf_thread_mc_tlv_pending_tstamp, tvb, offset, 8, &timestamp);\n                        }\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_STATE:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 1) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_state, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_DTLS_ENCAP:\n                {\n                    tvbuff_t *sub_tvb;\n\n                    if (tlv_len > 0) {\n                        sub_tvb = tvb_new_subset_length(tvb, offset, tlv_len);\n                        call_dissector(thread_dtls_handle, sub_tvb, pinfo, tree);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_UDP_PORT:\n            case THREAD_MC_TLV_JOINER_UDP_PORT:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* UDP Port */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_port, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_IID:\n                {\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* IID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_iid, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_ROUTER_LOCATOR:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_jr_locator, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_KEK:\n                {\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_kek, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PROVISIONING_URL:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_provisioning_url, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_NAME:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 32) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_name, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_MODEL:\n                {\n                    /* Check length is consistent: TODO not specified in spec. */\n                    if (tlv_len > 32) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_model, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_SW_VERSION:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_sw_ver, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_DATA:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Display it simply */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_data, tvb, offset, tlv_len, ENC_ASCII|ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_STACK_VERSION:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 6) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        guint8 build_u8;\n                        guint16 build;\n\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_oui, tvb, offset, 3, ENC_BIG_ENDIAN);\n                        offset += 3;\n                        build_u8 = tvb_get_guint8(tvb, offset);\n                        offset++;\n                        build = (guint16)build_u8 << 4;\n                        build_u8 = tvb_get_guint8(tvb, offset);\n                        build |= (guint16)build_u8 >> 4;\n                        pi = proto_tree_add_uint(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_build, tvb, 0, 0, build);\n                        PROTO_ITEM_SET_GENERATED(pi);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_rev, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_min, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_maj, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_UDP_ENCAPSULATION:\n                {\n                    tvbuff_t *sub_tvb;\n                    guint16 src_port;\n                    guint16 dst_port;\n                    udp_hdr_t *udp_hdr;\n                    guint8 *buffer;\n\n                    src_port = tvb_get_ntohs(tvb, offset);\n                    proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_encap_src_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n                    offset += 2;\n                    dst_port = tvb_get_ntohs(tvb, offset);\n                    proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_encap_dst_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n                    offset += 2;\n\n                    if (tlv_len >= 4)\n                    {\n                        /* Allocate a buffer for the fake UDP datagram and create the fake header. */\n                        buffer = (guint8 *)wmem_alloc(pinfo->pool, sizeof(udp_hdr_t) + (tlv_len - 4));\n\n                        /* Create pseudo UDP header */\n                        udp_hdr = (udp_hdr_t *)buffer;\n                        udp_hdr->src_port = g_htons(src_port);\n                        udp_hdr->dst_port = g_htons(dst_port);\n                        udp_hdr->length = g_htons(tlv_len + 4); /* Includes UDP header length */\n                        udp_hdr->checksum = 0;\n                        /* Copy UDP payload in */\n                        tvb_memcpy(tvb, udp_hdr + 1, offset, tlv_len - 4);\n                        /* Create child tvb */\n                        sub_tvb = tvb_new_child_real_data(tvb, buffer, tlv_len + 4, tvb_reported_length(tvb) + 4);\n                        call_dissector(thread_udp_handle, sub_tvb, pinfo, tree);\n                    }\n                    offset += (tlv_len-4);\n                }\n                break;\n\n            case THREAD_MC_TLV_IPV6_ADDRESS:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_ipv6_addr, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            /* case THREAD_MC_TLV_PENDING_TSTAMP: Handled in THREAD_MC_TLV_ACTIVE_TSTAMP case */\n\n            case THREAD_MC_TLV_DELAY_TIMER:\n                {\n                    if (tlv_len != 4) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_delay_timer, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_CHANNEL_MASK:\n                {\n                    proto_tree *cm_tree;\n                    int i;\n                    guint8 entries = 0;\n                    gint32 check_len = tlv_len;\n                    guint8 check_offset = offset + 1; /* Channel page first */\n                    guint8 masklen;\n\n                    /* Check consistency of entries */\n                    while (check_len > 0) {\n\n                        masklen = tvb_get_guint8(tvb, check_offset);\n                        if (masklen == 0) {\n                            break; /* Get out or we might spin forever */\n                        }\n                        masklen += 2; /* Add in page and length */\n                        check_offset += masklen;\n                        check_len -= masklen;\n                        entries++;\n                    }\n\n                    if (check_len != 0) {\n                        /* Not an integer number of entries */\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_tlv_length_failed);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        for (i = 0; i < entries; i++) {\n                            pi = proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_chan_mask, tvb, offset, 1, ENC_NA);\n                            cm_tree = proto_item_add_subtree(pi, ett_thread_mc_chan_mask);\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_page, tvb, offset, 1, ENC_BIG_ENDIAN);\n                            offset++;\n                            masklen = tvb_get_guint8(tvb, offset);\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n                            offset++;\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_mask, tvb, offset, masklen, ENC_NA);\n                            offset += masklen;\n                        }\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_COUNT:\n                {\n                    if (tlv_len != 1) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_count, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PERIOD:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_period, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_SCAN_DURATION:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_scan_duration, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_ENERGY_LIST:\n                {\n                    proto_tree *it_tree;\n                    int i;\n\n                    if ((chancount != THREAD_MC_INVALID_CHAN_COUNT) && (chancount != 0) && ((tlv_len % chancount) == 0)) {\n                        /* Go through the number of el_counts of scan */\n                        for (i = 0; i < (int)(tlv_len / (guint16)chancount); i++) {\n                            pi = proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_el_count, tvb, offset, 1, ENC_NA);\n                            proto_item_append_text(pi, \"" %d\"", i + 1);\n                            it_tree = proto_item_add_subtree(pi, ett_thread_mc_el_count);\n                            proto_tree_add_item(it_tree, hf_thread_mc_tlv_energy_list, tvb, offset, chancount, ENC_NA);\n                            offset += chancount;\n                        }\n                    } else {\n                        /* This might not work but try and display as string */\n                        /* Something wrong with channel count so just show it as a simple string */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_energy_list, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_DISCOVERY_REQUEST:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_req_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_req_j, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_DISCOVERY_RESPONSE:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_rsp_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_rsp_n, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            default:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                offset += tlv_len;\n        }\n    }\n    return tvb_captured_length(tvb);\n}"", ""target"": 0}]","[{""func_name"": ""get_chancount"", ""file_path"": ""epan/dissectors/packet-thread.c"", ""func_code"": ""static guint\nget_chancount(tvbuff_t *tvb)\n{\n    guint         offset;\n    guint8        tlv_type;\n    guint16       tlv_len;\n    tlv_len_len_e tlv_len_len;\n    guint         chancount = THREAD_MC_INVALID_CHAN_COUNT;\n\n    offset = 0;\n\n    /* Thread Network Data TLVs */\n    while (tvb_offset_exists(tvb, offset)) {\n\n        /* Get the type and length ahead of time to pass to next function so we can highlight\n           proper amount of bytes */\n        tlv_type = tvb_get_guint8(tvb, offset);\n        tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);\n\n        /* TODO: need to make sure this applies to all MeshCoP TLVs */\n        if (THREAD_TLV_LENGTH_ESC == tlv_len) {\n            /* 16-bit length field */\n            tlv_len = tvb_get_ntohs(tvb, offset + 2);\n            tlv_len_len = TLV_LEN_LEN16;\n        } else {\n            tlv_len_len = TLV_LEN_LEN8;\n        }\n\n        /* Skip over Type and Length */\n        offset += 1 + tlv_len_len;\n\n        switch(tlv_type) {\n\n            case THREAD_MC_TLV_CHANNEL_MASK:\n                {\n                    int i, j;\n                    guint8 entries = 0;\n                    gint32 check_len = tlv_len;\n                    gint check_offset = offset + 1; /* Channel page first */\n                    guint16 masklen;\n\n                    /* Check consistency of entries */\n                    while (check_len > 0) {\n\n                        masklen = tvb_get_guint8(tvb, check_offset);\n                        if (masklen == 0) {\n                            break; /* Get out or we might spin forever */\n                        }\n                        masklen += 2; /* Add in page and length */\n                        check_offset += masklen;\n                        check_len -= masklen;\n                        entries++;\n                    }\n\n                    if (check_len != 0) {\n                        /* Not an integer number of entries */\n                        /* offset += tlv_len; */\n                        return chancount;\n                    } else {\n                        chancount = 0;\n                        for (i = 0; i < entries; i++) {\n                            /* Skip over channel page */\n                            offset++;\n                            masklen = tvb_get_guint8(tvb, offset);\n                            offset++;\n                            /* Count the number of channels in the channel mask */\n                            for (j = 0; j < masklen; j++) {\n                                chancount += count_bits_in_byte(tvb_get_guint8(tvb, offset));\n                                offset++;\n                            }\n                        }\n                    }\n                }\n                break;\n\n            default:\n                /* Skip over any other TLVs */\n                offset += tlv_len;\n        }\n    }\n    return chancount;\n}""}, {""func_name"": ""dissect_thread_mc"", ""file_path"": ""epan/dissectors/packet-thread.c"", ""func_code"": ""static int\ndissect_thread_mc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    proto_item    *proto_root;\n    proto_tree    *thread_mc_tree;\n    proto_tree    *tlv_tree;\n    guint         offset = 0;\n    proto_item    *ti;\n    proto_item    *pi;\n    guint8        tlv_type;\n    guint16       tlv_len;\n    tlv_len_len_e tlv_len_len;\n    guint         chancount;\n\n\n    /* Create the protocol tree. */\n    proto_root = proto_tree_add_item(tree, proto_thread_mc, tvb, 0, tvb_reported_length(tvb), ENC_NA);\n    thread_mc_tree = proto_item_add_subtree(proto_root, ett_thread_mc);\n\n    /* Get channel count a priori so we can process energy list better */\n    chancount = get_chancount(tvb);\n\n    /* Thread Network Data TLVs */\n    while (tvb_offset_exists(tvb, offset)) {\n\n        /* Get the type and length ahead of time to pass to next function so we can highlight\n           proper amount of bytes */\n        tlv_type = tvb_get_guint8(tvb, offset);\n        tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);\n\n        /* TODO: need to make sure this applies to all MeshCoP TLVs */\n        if (THREAD_TLV_LENGTH_ESC == tlv_len) {\n            /* 16-bit length field */\n            tlv_len = tvb_get_ntohs(tvb, offset + 2);\n            tlv_len_len = TLV_LEN_LEN16;\n        } else {\n            tlv_len_len = TLV_LEN_LEN8;\n        }\n\n        /* Create the tree */\n        ti = proto_tree_add_item(thread_mc_tree, hf_thread_mc_tlv, tvb, offset, 1 + tlv_len_len + tlv_len, ENC_NA);\n        tlv_tree = proto_item_add_subtree(ti, ett_thread_mc_tlv);\n\n        /* Type */\n        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Add value name to value root label */\n        proto_item_append_text(ti, \"" (%s)\"", val_to_str(tlv_type, thread_mc_tlv_vals, \""Unknown (%d)\""));\n\n        /* Length */\n        switch (tlv_len_len) {\n            case TLV_LEN_LEN8:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_length8, tvb, offset, 1, ENC_BIG_ENDIAN);\n                break;\n            case TLV_LEN_LEN16:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_length16, tvb, offset + 1, 2, ENC_BIG_ENDIAN);\n                break;\n            default:\n                break;\n        }\n        offset += tlv_len_len;\n\n        switch(tlv_type) {\n            case THREAD_MC_TLV_CHANNEL:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 3) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Channel page */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_channel_page, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        /* Channel */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_channel, tvb, offset+1, 2, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PANID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* PAN ID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_pan_id, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_XPANID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* PAN ID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_xpan_id, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_NAME:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_net_name, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PSKC:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_pskc, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_MASTER_KEY:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_master_key, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_KEY_SEQ_CTR:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 4) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_net_key_seq_ctr, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_ML_PREFIX:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        struct e_in6_addr prefix;\n\n                        memset(&prefix, 0, sizeof(prefix));\n                        tvb_memcpy(tvb, (guint8 *)&prefix.bytes, offset, tlv_len);\n                        pi = proto_tree_add_ipv6(tlv_tree, hf_thread_mc_tlv_ml_prefix, tvb, offset, tlv_len, &prefix);\n                        proto_item_append_text(pi, \""/%d\"", tlv_len * 8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_STEERING_DATA:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Display it simply */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_steering_data, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_BORDER_AGENT_LOCATOR:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_ba_locator, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_ID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_commissioner_id, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_SESSION_ID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_commissioner_sess_id, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_SECURITY_POLICY:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 3) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_rot, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_o, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_n, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_r, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_c, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_b, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_GET:\n                {\n                    int i;\n\n                    for (i = 0; i < tlv_len; i++) {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_ACTIVE_TSTAMP:\n            case THREAD_MC_TLV_PENDING_TSTAMP:\n                {\n                    nstime_t timestamp;\n\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Fill in the nstime_t structure */\n                        timestamp.secs = (time_t)tvb_get_ntoh48(tvb, offset);\n                        timestamp.nsecs = (int)lround((double)(tvb_get_ntohs(tvb, offset + 6) >> 1) * THREAD_MC_32768_TO_NSEC_FACTOR);\n                        if (tlv_type == THREAD_MC_TLV_ACTIVE_TSTAMP) {\n                            proto_tree_add_time(tlv_tree, hf_thread_mc_tlv_active_tstamp, tvb, offset, 8, &timestamp);\n                        } else {\n                            proto_tree_add_time(tlv_tree, hf_thread_mc_tlv_pending_tstamp, tvb, offset, 8, &timestamp);\n                        }\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_STATE:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 1) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_state, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_DTLS_ENCAP:\n                {\n                    tvbuff_t *sub_tvb;\n\n                    if (tlv_len > 0) {\n                        sub_tvb = tvb_new_subset_length(tvb, offset, tlv_len);\n                        call_dissector(thread_dtls_handle, sub_tvb, pinfo, tree);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_UDP_PORT:\n            case THREAD_MC_TLV_JOINER_UDP_PORT:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* UDP Port */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_port, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_IID:\n                {\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* IID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_iid, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_ROUTER_LOCATOR:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_jr_locator, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_KEK:\n                {\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_kek, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PROVISIONING_URL:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_provisioning_url, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_NAME:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 32) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_name, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_MODEL:\n                {\n                    /* Check length is consistent: TODO not specified in spec. */\n                    if (tlv_len > 32) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_model, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_SW_VERSION:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_sw_ver, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_DATA:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Display it simply */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_data, tvb, offset, tlv_len, ENC_ASCII|ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_STACK_VERSION:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 6) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        guint8 build_u8;\n                        guint16 build;\n\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_oui, tvb, offset, 3, ENC_BIG_ENDIAN);\n                        offset += 3;\n                        build_u8 = tvb_get_guint8(tvb, offset);\n                        offset++;\n                        build = (guint16)build_u8 << 4;\n                        build_u8 = tvb_get_guint8(tvb, offset);\n                        build |= (guint16)build_u8 >> 4;\n                        pi = proto_tree_add_uint(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_build, tvb, 0, 0, build);\n                        PROTO_ITEM_SET_GENERATED(pi);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_rev, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_min, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_maj, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_UDP_ENCAPSULATION:\n                {\n                    tvbuff_t *sub_tvb;\n                    guint16 src_port;\n                    guint16 dst_port;\n                    udp_hdr_t *udp_hdr;\n                    guint8 *buffer;\n\n                    src_port = tvb_get_ntohs(tvb, offset);\n                    proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_encap_src_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n                    offset += 2;\n                    dst_port = tvb_get_ntohs(tvb, offset);\n                    proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_encap_dst_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n                    offset += 2;\n\n                    if (tlv_len >= 4)\n                    {\n                        /* Allocate a buffer for the fake UDP datagram and create the fake header. */\n                        buffer = (guint8 *)wmem_alloc(pinfo->pool, sizeof(udp_hdr_t) + (tlv_len - 4));\n\n                        /* Create pseudo UDP header */\n                        udp_hdr = (udp_hdr_t *)buffer;\n                        udp_hdr->src_port = g_htons(src_port);\n                        udp_hdr->dst_port = g_htons(dst_port);\n                        udp_hdr->length = g_htons(tlv_len + 4); /* Includes UDP header length */\n                        udp_hdr->checksum = 0;\n                        /* Copy UDP payload in */\n                        tvb_memcpy(tvb, udp_hdr + 1, offset, tlv_len - 4);\n                        /* Create child tvb */\n                        sub_tvb = tvb_new_child_real_data(tvb, buffer, tlv_len + 4, tvb_reported_length(tvb) + 4);\n                        call_dissector(thread_udp_handle, sub_tvb, pinfo, tree);\n                    }\n                    offset += (tlv_len-4);\n                }\n                break;\n\n            case THREAD_MC_TLV_IPV6_ADDRESS:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_ipv6_addr, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            /* case THREAD_MC_TLV_PENDING_TSTAMP: Handled in THREAD_MC_TLV_ACTIVE_TSTAMP case */\n\n            case THREAD_MC_TLV_DELAY_TIMER:\n                {\n                    if (tlv_len != 4) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_delay_timer, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_CHANNEL_MASK:\n                {\n                    proto_tree *cm_tree;\n                    int i;\n                    guint8 entries = 0;\n                    gint32 check_len = tlv_len;\n                    gint check_offset = offset + 1; /* Channel page first */\n                    guint16 masklen;\n\n                    /* Check consistency of entries */\n                    while (check_len > 0) {\n\n                        masklen = tvb_get_guint8(tvb, check_offset);\n                        if (masklen == 0) {\n                            break; /* Get out or we might spin forever */\n                        }\n                        masklen += 2; /* Add in page and length */\n                        check_offset += masklen;\n                        check_len -= masklen;\n                        entries++;\n                    }\n\n                    if (check_len != 0) {\n                        /* Not an integer number of entries */\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_tlv_length_failed);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        for (i = 0; i < entries; i++) {\n                            pi = proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_chan_mask, tvb, offset, 1, ENC_NA);\n                            cm_tree = proto_item_add_subtree(pi, ett_thread_mc_chan_mask);\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_page, tvb, offset, 1, ENC_BIG_ENDIAN);\n                            offset++;\n                            masklen = tvb_get_guint8(tvb, offset);\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n                            offset++;\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_mask, tvb, offset, masklen, ENC_NA);\n                            offset += masklen;\n                        }\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_COUNT:\n                {\n                    if (tlv_len != 1) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_count, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PERIOD:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_period, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_SCAN_DURATION:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_scan_duration, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_ENERGY_LIST:\n                {\n                    proto_tree *it_tree;\n                    int i;\n\n                    if ((chancount != THREAD_MC_INVALID_CHAN_COUNT) && (chancount != 0) && ((tlv_len % chancount) == 0)) {\n                        /* Go through the number of el_counts of scan */\n                        for (i = 0; i < (int)(tlv_len / (guint16)chancount); i++) {\n                            pi = proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_el_count, tvb, offset, 1, ENC_NA);\n                            proto_item_append_text(pi, \"" %d\"", i + 1);\n                            it_tree = proto_item_add_subtree(pi, ett_thread_mc_el_count);\n                            proto_tree_add_item(it_tree, hf_thread_mc_tlv_energy_list, tvb, offset, chancount, ENC_NA);\n                            offset += chancount;\n                        }\n                    } else {\n                        /* This might not work but try and display as string */\n                        /* Something wrong with channel count so just show it as a simple string */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_energy_list, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_DISCOVERY_REQUEST:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_req_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_req_j, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_DISCOVERY_RESPONSE:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_rsp_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_rsp_n, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            default:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                offset += tlv_len;\n        }\n    }\n    return tvb_captured_length(tvb);\n}""}]","{""code"": 2, ""value"": 1}","[{""source"": ""code_info(file:packet-thread.c, lines:905-920)"", ""result"": ""                    /* Check consistency of entries */\n                    while (check_len > 0) {\n\n                        masklen = tvb_get_guint8(tvb, check_offset);\n                        if (masklen == 0) {\n                            break; /* Get out or we might spin forever */\n                        }\n                        masklen += 2; /* Add in page and length */\n                        check_offset += masklen;\n                        check_len -= masklen;\n                        entries++;\n                    }\n\n                    if (check_len != 0) {\n                        /* Not an integer number of entries */\n                        /* offset += tlv_len; */\n""}, {""source"": ""code_info(file:packet-thread.c, lines:1750-1765)"", ""result"": ""                    while (check_len > 0) {\n\n                        masklen = tvb_get_guint8(tvb, check_offset);\n                        if (masklen == 0) {\n                            break; /* Get out or we might spin forever */\n                        }\n                        masklen += 2; /* Add in page and length */\n                        check_offset += masklen;\n                        check_len -= masklen;\n                        entries++;\n                    }\n\n                    if (check_len != 0) {\n                        /* Not an integer number of entries */\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_tlv_length_failed);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n""}, {""source"": ""value_info(file:packet-thread.c, value:offset)"", ""result"": {""value_trace"": [{""full_code"": ""offset = 0"", ""line"": 873, ""func_name"": ""get_chancount""}, {""full_code"": ""offset += 1 + tlv_len_len"", ""line"": 893, ""func_name"": ""get_chancount""}, {""full_code"": ""offset++"", ""line"": 926, ""func_name"": ""get_chancount""}, {""full_code"": ""offset++"", ""line"": 928, ""func_name"": ""get_chancount""}, {""full_code"": ""offset++"", ""line"": 932, ""func_name"": ""get_chancount""}], ""struct_var"": ""offset"", ""struct_type"": ""guint"", ""struct_definition"": ""guint\n\nguint""}}]","In epan/dissectors/packet-thread.c, the variables check_offset (guint8) and masklen (guint8) in get_chancount (lines 900-903) and dissect_thread_mc (lines 1745-1748) were insufficient to handle large values. When masklen = tvb_get_guint8(...) + 2 (line 907/1752) exceeded 255, guint8 overflow caused masklen to wrap to a small value. This led to check_len -= masklen (line 909/1754) not reducing check_len properly, creating an infinite loop in while (check_len > 0) { ... } (line 903/1748). The patch upgraded check_offset to gint and masklen to guint16 to prevent overflow.",0.95,./github/other_context/CVE-2018-7330
45,CVE-2018-7329,"CWE-193, CWE-835",c_cpp,"In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be,"S7comm: fix range check to prevent infinite loop when upper bound is 255\n\nWhile we are at it, fix identification of not last element in a few\nplaces\n\nBug: 14423\nChange-Id: I568530949d09ddfd8c5c58d24050dfed32ce10f5\nReviewed-on: https://code.wireshark.org/review/25851\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51)\nConflicts:\n	epan/dissectors/packet-s7comm.c\nReviewed-on: https://code.wireshark.org/review/25867\n(cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)\nReviewed-on: https://code.wireshark.org/review/25868",5,"[{""func_name"": ""s7comm_decode_response_write_data"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_response_write_data(tvbuff_t *tvb,\n                                  proto_tree *tree,\n                                  guint8 item_count,\n                                  guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 1; i <= item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, 1, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \"" [%d]: (%s)\"", i, val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        offset += 1;\n    }\n    return offset;\n}"", ""target"": 1}, {""func_name"": ""s7comm_decode_req_resp"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_req_resp(tvbuff_t *tvb,\n                       packet_info *pinfo,\n                       proto_tree *tree,\n                       guint16 plength,\n                       guint16 dlength,\n                       guint32 offset,\n                       guint8 rosctr)\n{\n    proto_item *item = NULL;\n    proto_tree *param_tree = NULL;\n    proto_tree *data_tree = NULL;\n    guint8 function = 0;\n    guint8 item_count = 0;\n    guint8 i;\n    guint32 offset_old;\n    guint32 len;\n\n    if (plength > 0) {\n        /* Add parameter tree */\n        item = proto_tree_add_item(tree, hf_s7comm_param, tvb, offset, plength, ENC_NA);\n        param_tree = proto_item_add_subtree(item, ett_s7comm_param);\n        /* Analyze function */\n        function = tvb_get_guint8(tvb, offset);\n        /* add param.function to info column */\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"" Function:[%s]\"", val_to_str(function, param_functionnames, \""Unknown function: 0x%02x\""));\n        proto_tree_add_uint(param_tree, hf_s7comm_param_service, tvb, offset, 1, function);\n        /* show param.function code at the tree */\n        proto_item_append_text(param_tree, \"": (%s)\"", val_to_str(function, param_functionnames, \""Unknown function: 0x%02x\""));\n        offset += 1;\n\n        if (rosctr == S7COMM_ROSCTR_JOB) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* parse item data */\n                    for (i = 0; i < item_count; i++) {\n                        offset_old = offset;\n                        offset = s7comm_decode_param_item(tvb, offset, param_tree, i);\n                        /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                        len = offset - offset_old;\n                        if ((len % 2) && (i < item_count)) {\n                            offset += 1;\n                        }\n                    }\n                    /* in write-function there is a data part */\n                    if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        /* Add returned data to data-tree */\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                /* Special functions */\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    offset = s7comm_decode_pi_service(tvb, pinfo, param_tree, plength, offset -1);\n                    break;\n                case S7COMM_FUNC_PLC_STOP:\n                    offset = s7comm_decode_plc_controls_param_hex29(tvb, param_tree, offset -1);\n                    break;\n\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        } else if (rosctr == S7COMM_ROSCTR_ACK_DATA) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    /* This is a read-response, so the requested data may follow when address in request was ok */\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* Add data tree */\n                    item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                    data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                    /* Add returned data to data-tree */\n                    if ((function == S7COMM_SERV_READVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    } else if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_write_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    if (plength >= 2) {\n                        proto_tree_add_bitmask(param_tree, tvb, offset, hf_s7comm_data_blockcontrol_functionstatus,\n                            ett_s7comm_data_blockcontrol_status, s7comm_data_blockcontrol_status_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    break;\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        }\n    }\n    return offset;\n}"", ""target"": 1}, {""func_name"": ""s7comm_decode_ud_cyclic_subfunc"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_ud_cyclic_subfunc(tvbuff_t *tvb,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint16 dlength,            /* length of data part given in header */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    gboolean know_data = FALSE;\n    guint32 offset_old;\n    guint32 len_item;\n    guint8 item_count;\n    guint8 i;\n\n    switch (subfunc)\n    {\n        case S7COMM_UD_SUBF_CYCLIC_MEM:\n            item_count = tvb_get_guint8(tvb, offset + 1);     /* first byte reserved??? */\n            proto_tree_add_uint(data_tree, hf_s7comm_param_itemcount, tvb, offset, 2, item_count);\n            offset += 2;\n            if (type == S7COMM_UD_TYPE_REQ) {                   /* Request to PLC to send cyclic data */\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_timebase, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_time, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                /* parse item data */\n                for (i = 0; i < item_count; i++) {\n                    offset_old = offset;\n                    offset = s7comm_decode_param_item(tvb, offset, data_tree, i);\n                    /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                    len_item = offset - offset_old;\n                    if ((len_item % 2) && (i < item_count)) {\n                        offset += 1;\n                    }\n                }\n\n            } else if (type == S7COMM_UD_TYPE_RES || type == S7COMM_UD_TYPE_PUSH) {   /* Response from PLC with the requested data */\n                /* parse item data */\n                offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n            }\n            know_data = TRUE;\n            break;\n    }\n\n    if (know_data == FALSE && dlength > 4) {\n        proto_tree_add_item(data_tree, hf_s7comm_userdata_data, tvb, offset, dlength - 4, ENC_NA);\n        offset += dlength;\n    }\n    return offset;\n}"", ""target"": 1}, {""func_name"": ""s7comm_decode_response_read_data"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_response_read_data(tvbuff_t *tvb,\n                                 proto_tree *tree,\n                                 guint8 item_count,\n                                 guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 tsize = 0;\n    guint16 len = 0, len2 = 0;\n    guint16 head_len = 4;           /* 1 byte res-code, 1 byte transp-size, 2 bytes len */\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 1; i <= item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_ERR\n            ) {\n            tsize = tvb_get_guint8(tvb, offset + 1);\n            len = tvb_get_ntohs(tvb, offset + 2);\n            /* calculate length in bytes */\n            if (tsize == S7COMM_DATA_TRANSPORT_SIZE_BBIT ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BBYTE ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BINT\n                ) {     /* given length is in number of bits */\n                if (len % 8) { /* len is not a multiple of 8, then round up to next number */\n                    len /= 8;\n                    len = len + 1;\n                } else {\n                    len /= 8;\n                }\n            }\n\n            /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n            if ((len % 2) && (i < item_count)) {\n                len2 = len + 1;\n            } else {\n                len2 = len;\n            }\n        }\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \"" [%d]: (%s)\"", i, val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_length, tvb, offset + 2, 2, len);\n        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}"", ""target"": 0}, {""func_name"": ""s7comm_decode_ud_cpu_alarm_main"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_ud_cpu_alarm_main(tvbuff_t *tvb,\n                                packet_info *pinfo,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    guint32 start_offset;\n    guint32 asc_start_offset;\n    guint32 msg_obj_start_offset;\n    guint32 ev_id;\n    proto_item *msg_item = NULL;\n    proto_tree *msg_item_tree = NULL;\n    proto_item *msg_obj_item = NULL;\n    proto_tree *msg_obj_item_tree = NULL;\n    proto_item *msg_work_item = NULL;\n    proto_tree *msg_work_item_tree = NULL;\n    guint8 nr_objects;\n    guint8 i;\n    guint8 syntax_id;\n    guint8 nr_of_additional_values;\n    guint8 signalstate;\n    guint8 sig_nr;\n    guint8 ret_val;\n    guint8 querytype;\n    guint8 varspec_length;\n\n    start_offset = offset;\n\n    msg_item = proto_tree_add_item(data_tree, hf_s7comm_cpu_alarm_message_item, tvb, offset, 0, ENC_NA);\n    msg_item_tree = proto_item_add_subtree(msg_item, ett_s7comm_cpu_alarm_message);\n\n    if (subfunc == S7COMM_UD_SUBF_CPU_ALARM8_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMACK_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_ALARMSQ_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMS_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_NOTIFY_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY8_IND) {\n        msg_work_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_timestamp_coming, tvb, offset, 8, ENC_NA);\n        msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_timestamp);\n        offset = s7comm_add_timestamp_to_tree(tvb, msg_work_item_tree, offset, TRUE, FALSE);\n    }\n    proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_function, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    nr_objects = tvb_get_guint8(tvb, offset);\n    proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n    offset += 1;\n    for (i = 1; i <= nr_objects; i++) {\n        msg_obj_start_offset = offset;\n        msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n        msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n        proto_item_append_text(msg_obj_item_tree, \"" [%d]\"", i);\n        if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset += 1;\n            varspec_length = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length);\n            offset += 1;\n            syntax_id = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id);\n            offset += 1;\n            switch (syntax_id) {\n                case S7COMM_SYNTAXID_ALARM_LOCKFREESET:\n                case S7COMM_SYNTAXID_ALARM_INDSET:\n                case S7COMM_SYNTAXID_NOTIFY_INDSET:\n                case S7COMM_SYNTAXID_ALARM_ACKSET:\n                    nr_of_additional_values = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id);\n                    offset += 4;\n                    proto_item_append_text(msg_obj_item_tree, \"": EventID=0x%08x\"", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \"" EventID=0x%08x\"", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" On=[\"");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d\"", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d,\"", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n                                }\n                            }\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \""]\"");\n                        }\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_state,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_ALARM_ACKSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_lastchanged,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_event_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        if (nr_of_additional_values > 0) {\n                            asc_start_offset = offset;\n                            msg_work_item = proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_associated_value, tvb, offset, 0, ENC_NA);\n                            msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_associated_value);\n                            offset = s7comm_decode_response_read_data(tvb, msg_work_item_tree, nr_of_additional_values, offset);\n                            proto_item_set_len(msg_work_item_tree, offset - asc_start_offset);\n                        }\n                    }\n                    break;\n                case S7COMM_SYNTAXID_ALARM_QUERYREQSET:\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown1, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    querytype = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_querytype, tvb, offset, 1, querytype);\n                    offset += 1;\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown2, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    /* there is a querytype=8, which only occurs when a previous SZL request 0x131 index 0x10 has a missing flag in funk_1 */\n                    switch (querytype) {\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYALARMTYPE:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_alarmtype, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" ByAlarmtype=%s\"",\n                                val_to_str(ev_id, alarm_message_query_alarmtype_names, \""Unknown Alarmtype: %u\""));\n                            break;\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYEVENTID:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" ByEventID=0x%08x\"", ev_id);\n                            break;\n                        default:\n                            break;\n                    }\n                    offset += 4;\n                    break;\n                default:\n                    /* for current unknown syntax id, set offset to end of dataset. The varspec_length includes\n                     * the byte for the syntax_id, so minus one.\n                     */\n                    offset += (varspec_length - 1);\n                    break;\n            }\n        } else if (type == S7COMM_UD_TYPE_RES) {\n            ret_val = tvb_get_guint8(tvb, offset);\n            proto_item_append_text(msg_obj_item_tree, \"": (%s)\"", val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n            offset += 1;\n        }\n        proto_item_set_len(msg_obj_item_tree, offset - msg_obj_start_offset);\n    }\n    proto_item_set_len(msg_item_tree, offset - start_offset);\n    return offset;\n}"", ""target"": 0}]","[{""func_name"": ""s7comm_decode_response_write_data"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_response_write_data(tvbuff_t *tvb,\n                                  proto_tree *tree,\n                                  guint8 item_count,\n                                  guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 0; i < item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, 1, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \"" [%d]: (%s)\"", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        offset += 1;\n    }\n    return offset;\n}""}, {""func_name"": ""s7comm_decode_req_resp"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_req_resp(tvbuff_t *tvb,\n                       packet_info *pinfo,\n                       proto_tree *tree,\n                       guint16 plength,\n                       guint16 dlength,\n                       guint32 offset,\n                       guint8 rosctr)\n{\n    proto_item *item = NULL;\n    proto_tree *param_tree = NULL;\n    proto_tree *data_tree = NULL;\n    guint8 function = 0;\n    guint8 item_count = 0;\n    guint8 i;\n    guint32 offset_old;\n    guint32 len;\n\n    if (plength > 0) {\n        /* Add parameter tree */\n        item = proto_tree_add_item(tree, hf_s7comm_param, tvb, offset, plength, ENC_NA);\n        param_tree = proto_item_add_subtree(item, ett_s7comm_param);\n        /* Analyze function */\n        function = tvb_get_guint8(tvb, offset);\n        /* add param.function to info column */\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"" Function:[%s]\"", val_to_str(function, param_functionnames, \""Unknown function: 0x%02x\""));\n        proto_tree_add_uint(param_tree, hf_s7comm_param_service, tvb, offset, 1, function);\n        /* show param.function code at the tree */\n        proto_item_append_text(param_tree, \"": (%s)\"", val_to_str(function, param_functionnames, \""Unknown function: 0x%02x\""));\n        offset += 1;\n\n        if (rosctr == S7COMM_ROSCTR_JOB) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* parse item data */\n                    for (i = 0; i < item_count; i++) {\n                        offset_old = offset;\n                        offset = s7comm_decode_param_item(tvb, offset, param_tree, i);\n                        /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                        len = offset - offset_old;\n                        if ((len % 2) && (i < (item_count-1))) {\n                            offset += 1;\n                        }\n                    }\n                    /* in write-function there is a data part */\n                    if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        /* Add returned data to data-tree */\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                /* Special functions */\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    offset = s7comm_decode_pi_service(tvb, pinfo, param_tree, plength, offset -1);\n                    break;\n                case S7COMM_FUNC_PLC_STOP:\n                    offset = s7comm_decode_plc_controls_param_hex29(tvb, param_tree, offset -1);\n                    break;\n\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        } else if (rosctr == S7COMM_ROSCTR_ACK_DATA) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    /* This is a read-response, so the requested data may follow when address in request was ok */\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* Add data tree */\n                    item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                    data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                    /* Add returned data to data-tree */\n                    if ((function == S7COMM_SERV_READVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    } else if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_write_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    if (plength >= 2) {\n                        proto_tree_add_bitmask(param_tree, tvb, offset, hf_s7comm_data_blockcontrol_functionstatus,\n                            ett_s7comm_data_blockcontrol_status, s7comm_data_blockcontrol_status_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    break;\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        }\n    }\n    return offset;\n}""}, {""func_name"": ""s7comm_decode_ud_cyclic_subfunc"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_ud_cyclic_subfunc(tvbuff_t *tvb,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint16 dlength,            /* length of data part given in header */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    gboolean know_data = FALSE;\n    guint32 offset_old;\n    guint32 len_item;\n    guint8 item_count;\n    guint8 i;\n\n    switch (subfunc)\n    {\n        case S7COMM_UD_SUBF_CYCLIC_MEM:\n            item_count = tvb_get_guint8(tvb, offset + 1);     /* first byte reserved??? */\n            proto_tree_add_uint(data_tree, hf_s7comm_param_itemcount, tvb, offset, 2, item_count);\n            offset += 2;\n            if (type == S7COMM_UD_TYPE_REQ) {                   /* Request to PLC to send cyclic data */\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_timebase, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_time, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                /* parse item data */\n                for (i = 0; i < item_count; i++) {\n                    offset_old = offset;\n                    offset = s7comm_decode_param_item(tvb, offset, data_tree, i);\n                    /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                    len_item = offset - offset_old;\n                    if ((len_item % 2) && (i < (item_count-1))) {\n                        offset += 1;\n                    }\n                }\n\n            } else if (type == S7COMM_UD_TYPE_RES || type == S7COMM_UD_TYPE_PUSH) {   /* Response from PLC with the requested data */\n                /* parse item data */\n                offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n            }\n            know_data = TRUE;\n            break;\n    }\n\n    if (know_data == FALSE && dlength > 4) {\n        proto_tree_add_item(data_tree, hf_s7comm_userdata_data, tvb, offset, dlength - 4, ENC_NA);\n        offset += dlength;\n    }\n    return offset;\n}""}, {""func_name"": ""s7comm_decode_response_read_data"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_response_read_data(tvbuff_t *tvb,\n                                 proto_tree *tree,\n                                 guint8 item_count,\n                                 guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 tsize = 0;\n    guint16 len = 0, len2 = 0;\n    guint16 head_len = 4;           /* 1 byte res-code, 1 byte transp-size, 2 bytes len */\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 0; i < item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_ERR\n            ) {\n            tsize = tvb_get_guint8(tvb, offset + 1);\n            len = tvb_get_ntohs(tvb, offset + 2);\n            /* calculate length in bytes */\n            if (tsize == S7COMM_DATA_TRANSPORT_SIZE_BBIT ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BBYTE ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BINT\n                ) {     /* given length is in number of bits */\n                if (len % 8) { /* len is not a multiple of 8, then round up to next number */\n                    len /= 8;\n                    len = len + 1;\n                } else {\n                    len /= 8;\n                }\n            }\n\n            /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n            if ((len % 2) && (i < (item_count-1))) {\n                len2 = len + 1;\n            } else {\n                len2 = len;\n            }\n        }\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \"" [%d]: (%s)\"", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_length, tvb, offset + 2, 2, len);\n        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}""}, {""func_name"": ""s7comm_decode_ud_cpu_alarm_main"", ""file_path"": ""epan/dissectors/packet-s7comm.c"", ""func_code"": ""static guint32\ns7comm_decode_ud_cpu_alarm_main(tvbuff_t *tvb,\n                                packet_info *pinfo,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    guint32 start_offset;\n    guint32 asc_start_offset;\n    guint32 msg_obj_start_offset;\n    guint32 ev_id;\n    proto_item *msg_item = NULL;\n    proto_tree *msg_item_tree = NULL;\n    proto_item *msg_obj_item = NULL;\n    proto_tree *msg_obj_item_tree = NULL;\n    proto_item *msg_work_item = NULL;\n    proto_tree *msg_work_item_tree = NULL;\n    guint8 nr_objects;\n    guint8 i;\n    guint8 syntax_id;\n    guint8 nr_of_additional_values;\n    guint8 signalstate;\n    guint8 sig_nr;\n    guint8 ret_val;\n    guint8 querytype;\n    guint8 varspec_length;\n\n    start_offset = offset;\n\n    msg_item = proto_tree_add_item(data_tree, hf_s7comm_cpu_alarm_message_item, tvb, offset, 0, ENC_NA);\n    msg_item_tree = proto_item_add_subtree(msg_item, ett_s7comm_cpu_alarm_message);\n\n    if (subfunc == S7COMM_UD_SUBF_CPU_ALARM8_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMACK_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_ALARMSQ_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMS_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_NOTIFY_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY8_IND) {\n        msg_work_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_timestamp_coming, tvb, offset, 8, ENC_NA);\n        msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_timestamp);\n        offset = s7comm_add_timestamp_to_tree(tvb, msg_work_item_tree, offset, TRUE, FALSE);\n    }\n    proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_function, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    nr_objects = tvb_get_guint8(tvb, offset);\n    proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n    offset += 1;\n    for (i = 0; i < nr_objects; i++) {\n        msg_obj_start_offset = offset;\n        msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n        msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n        proto_item_append_text(msg_obj_item_tree, \"" [%d]\"", i+1);\n        if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset += 1;\n            varspec_length = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length);\n            offset += 1;\n            syntax_id = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id);\n            offset += 1;\n            switch (syntax_id) {\n                case S7COMM_SYNTAXID_ALARM_LOCKFREESET:\n                case S7COMM_SYNTAXID_ALARM_INDSET:\n                case S7COMM_SYNTAXID_NOTIFY_INDSET:\n                case S7COMM_SYNTAXID_ALARM_ACKSET:\n                    nr_of_additional_values = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id);\n                    offset += 4;\n                    proto_item_append_text(msg_obj_item_tree, \"": EventID=0x%08x\"", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \"" EventID=0x%08x\"", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" On=[\"");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d\"", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d,\"", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n                                }\n                            }\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \""]\"");\n                        }\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_state,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_ALARM_ACKSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_lastchanged,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_event_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        if (nr_of_additional_values > 0) {\n                            asc_start_offset = offset;\n                            msg_work_item = proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_associated_value, tvb, offset, 0, ENC_NA);\n                            msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_associated_value);\n                            offset = s7comm_decode_response_read_data(tvb, msg_work_item_tree, nr_of_additional_values, offset);\n                            proto_item_set_len(msg_work_item_tree, offset - asc_start_offset);\n                        }\n                    }\n                    break;\n                case S7COMM_SYNTAXID_ALARM_QUERYREQSET:\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown1, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    querytype = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_querytype, tvb, offset, 1, querytype);\n                    offset += 1;\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown2, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    /* there is a querytype=8, which only occurs when a previous SZL request 0x131 index 0x10 has a missing flag in funk_1 */\n                    switch (querytype) {\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYALARMTYPE:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_alarmtype, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" ByAlarmtype=%s\"",\n                                val_to_str(ev_id, alarm_message_query_alarmtype_names, \""Unknown Alarmtype: %u\""));\n                            break;\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYEVENTID:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" ByEventID=0x%08x\"", ev_id);\n                            break;\n                        default:\n                            break;\n                    }\n                    offset += 4;\n                    break;\n                default:\n                    /* for current unknown syntax id, set offset to end of dataset. The varspec_length includes\n                     * the byte for the syntax_id, so minus one.\n                     */\n                    offset += (varspec_length - 1);\n                    break;\n            }\n        } else if (type == S7COMM_UD_TYPE_RES) {\n            ret_val = tvb_get_guint8(tvb, offset);\n            proto_item_append_text(msg_obj_item_tree, \"": (%s)\"", val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n            offset += 1;\n        }\n        proto_item_set_len(msg_obj_item_tree, offset - msg_obj_start_offset);\n    }\n    proto_item_set_len(msg_item_tree, offset - start_offset);\n    return offset;\n}""}]","{""code"": 6, ""value"": 2}","[{""source"": ""code_info(file:packet-s7comm.c, lines:2663-2700)"", ""result"": ""    proto_tree *item_tree = NULL;\n\n    for (i = 1; i <= item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_ERR\n            ) {\n            tsize = tvb_get_guint8(tvb, offset + 1);\n            len = tvb_get_ntohs(tvb, offset + 2);\n            /* calculate length in bytes */\n            if (tsize == S7COMM_DATA_TRANSPORT_SIZE_BBIT ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BBYTE ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BINT\n                ) {     /* given length is in number of bits */\n                if (len % 8) { /* len is not a multiple of 8, then round up to next number */\n                    len /= 8;\n                    len = len + 1;\n                } else {\n                    len /= 8;\n                }\n            }\n\n            /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n            if ((len % 2) && (i < item_count)) {\n                len2 = len + 1;\n            } else {\n                len2 = len;\n            }\n        }\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \"" [%d]: (%s)\"", i, val_to_str(ret_val, s7comm_item_return_valuenames, \""Unknown code: 0x%02x\""));\n\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_length, tvb, offset + 2, 2, len);\n""}, {""source"": ""code_info(file:packet-s7comm.c, lines:3874-3900)"", ""result"": ""    proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n    offset += 1;\n    for (i = 1; i <= nr_objects; i++) {\n        msg_obj_start_offset = offset;\n        msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n        msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n        proto_item_append_text(msg_obj_item_tree, \"" [%d]\"", i);\n        if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset += 1;\n            varspec_length = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length);\n            offset += 1;\n            syntax_id = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id);\n            offset += 1;\n            switch (syntax_id) {\n                case S7COMM_SYNTAXID_ALARM_LOCKFREESET:\n                case S7COMM_SYNTAXID_ALARM_INDSET:\n                case S7COMM_SYNTAXID_NOTIFY_INDSET:\n                case S7COMM_SYNTAXID_ALARM_ACKSET:\n                    nr_of_additional_values = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id);\n                    offset += 4;\n""}, {""source"": ""code_info(file:packet-s7comm.c, lines:2701-2720)"", ""result"": ""        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}\n\n/*******************************************************************************************************\n *\n * PDU Type: Request or Response -> Function 0x29 (PLC control functions -> STOP)\n *\n *******************************************************************************************************/\nstatic guint32\n""}, {""source"": ""code_info(file:packet-s7comm.c, lines:3901-3920)"", ""result"": ""                    proto_item_append_text(msg_obj_item_tree, \"": EventID=0x%08x\"", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \"" EventID=0x%08x\"", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" On=[\"");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d\"", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d,\"", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n""}, {""source"": ""code_info(file:packet-s7comm.c, lines:2701-2720)"", ""result"": ""        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}\n\n/*******************************************************************************************************\n *\n * PDU Type: Request or Response -> Function 0x29 (PLC control functions -> STOP)\n *\n *******************************************************************************************************/\nstatic guint32\n""}, {""source"": ""code_info(file:packet-s7comm.c, lines:3901-3920)"", ""result"": ""                    proto_item_append_text(msg_obj_item_tree, \"": EventID=0x%08x\"", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \"" EventID=0x%08x\"", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"" On=[\"");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d\"", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \""SIG_%d,\"", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n""}, {""source"": ""value_info(file:packet-s7comm.c, value:item_count)"", ""result"": {""value_trace"": [{""full_code"": ""item_count = tvb_get_guint8(tvb, offset + 1)"", ""line"": 4483, ""func_name"": ""s7comm_decode_ud_cyclic_subfunc""}, {""full_code"": ""item_count = tvb_get_ntohs(tvb, offset)"", ""line"": 4570, ""func_name"": ""s7comm_decode_ud_prog_subfunc""}, {""full_code"": ""item_count = tvb_get_ntohs(tvb, offset)"", ""line"": 4588, ""func_name"": ""s7comm_decode_ud_prog_subfunc""}, {""full_code"": ""item_count = 0"", ""line"": 4844, ""func_name"": ""s7comm_decode_req_resp""}, {""full_code"": ""item_count = tvb_get_guint8(tvb, offset)"", ""line"": 4866, ""func_name"": ""s7comm_decode_req_resp""}], ""struct_var"": ""item_count"", ""struct_type"": ""guint8"", ""struct_definition"": ""guint8\n\nguint8\n\nguint8\n\nguint8\n\nguint8\n\nguint8""}}, {""source"": ""value_info(file:packet-s7comm.c, value:nr_objects)"", ""result"": {""value_trace"": [{""full_code"": ""nr_objects = tvb_get_guint8(tvb, offset)"", ""line"": 3873, ""func_name"": ""s7comm_decode_ud_cpu_alarm_main""}], ""struct_var"": ""nr_objects"", ""struct_type"": ""guint8"", ""struct_definition"": ""guint8\n\nguint8\n\nguint8\n\nguint8\n\nguint8\n\nguint8""}}]","1. **Off-by-one error in loop bounds**: In `s7comm_decode_response_read_data` (lines 2663-2700) and `s7comm_decode_ud_cpu_alarm_main` (lines 3874-3900), the original loop used 1-based indexing (`i=1` to `i <= item_count`/`nr_objects`). For `item_count`/`nr_objects` = 255 (guint8 max), this caused an extra iteration (256th iteration). 2. **Missing offset increment on invalid data**: When `ret_val` is invalid (not `S7COMM_ITEM_RETVAL_DATA_OK`/`RESERVED`), the code does not increment `offset` (evidenced by absence of `offset += ...` in these branches). This leads to reprocessing the same `offset`, creating an infinite loop. 3. **Patch correction**: The loop was changed to 0-based indexing (`i=0` to `i < item_count`/`nr_objects`), preventing the extra iteration and eliminating the infinite loop.",0.95,./github/other_context/CVE-2018-7329
46,CVE-2018-9918,CWE-674,c_cpp,"libqpdf.a in QPDF through 8.0.2 mishandles certain ""expected dictionary key but found non-name object"" cases, allowing remote attackers to cause a denial of service (stack exhaustion), related to the QPDFObjectHandle and QPDF_Dictionary classes, because nesting in direct objects is not restricted.",https://github.com/qpdf/qpdf/commit/b4d6cf6836ce025ba1811b7bbec52680c7204223,Limit depth of nesting in direct objects (fixes #202)\n\nThis fixes CVE-2018-9918.,1,"[{""func_name"": ""QPDFObjectHandle::parseInternal"", ""file_path"": ""libqpdf/QPDFObjectHandle.cc"", ""func_code"": ""QPDFObjectHandle\nQPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool content_stream)\n{\n    // This method must take care not to resolve any objects. Don't\n    // check the type of any object without first ensuring that it is\n    // a direct object. Otherwise, doing so may have the side effect\n    // of reading the object and changing the file pointer.\n\n    empty = false;\n\n    QPDFObjectHandle object;\n\n    std::vector<std::vector<QPDFObjectHandle> > olist_stack;\n    olist_stack.push_back(std::vector<QPDFObjectHandle>());\n    std::vector<parser_state_e> state_stack;\n    state_stack.push_back(st_top);\n    std::vector<qpdf_offset_t> offset_stack;\n    qpdf_offset_t offset = input->tell();\n    offset_stack.push_back(offset);\n    bool done = false;\n    while (! done)\n    {\n        std::vector<QPDFObjectHandle>& olist = olist_stack.back();\n        parser_state_e state = state_stack.back();\n        offset = offset_stack.back();\n\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description, true);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (! content_stream)\n            {\n                QTC::TC(\""qpdf\"", \""QPDFObjectHandle eof in parseInternal\"");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""unexpected EOF\""));\n            }\n            state = st_eof;\n            break;\n\n          case QPDFTokenizer::tt_bad:\n\t    QTC::TC(\""qpdf\"", \""QPDFObjectHandle bad token in parse\"");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         token.getErrorMessage()));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_brace_open:\n\t  case QPDFTokenizer::tt_brace_close:\n\t    QTC::TC(\""qpdf\"", \""QPDFObjectHandle bad brace\"");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \""treating unexpected brace token as null\""));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (state == st_array)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\""qpdf\"", \""QPDFObjectHandle bad array close\"");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""treating unexpected array close token as null\""));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (state == st_dictionary)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\""qpdf\"", \""QPDFObjectHandle bad dictionary close\"");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""unexpected dictionary close token\""));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t  case QPDFTokenizer::tt_dict_open:\n            olist_stack.push_back(std::vector<QPDFObjectHandle>());\n            state = st_start;\n            offset_stack.push_back(input->tell());\n            state_stack.push_back(\n                (token.getType() == QPDFTokenizer::tt_array_open) ?\n                st_array : st_dictionary);\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \""true\""));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_integer:\n\t    object = newInteger(QUtil::string_to_ll(token.getValue().c_str()));\n\t    break;\n\n\t  case QPDFTokenizer::tt_real:\n\t    object = newReal(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_name:\n\t    object = newName(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \""R\"") && (state != st_top) &&\n                         (olist.size() >= 2) &&\n                         (! olist.at(olist.size() - 1).isIndirect()) &&\n                         (olist.at(olist.size() - 1).isInteger()) &&\n                         (! olist.at(olist.size() - 2).isIndirect()) &&\n                         (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\""qpdf\"", \""QPDFObjectHandle indirect without context\"");\n                        throw std::logic_error(\n                            \""QPDFObjectHandle::parse called without context\""\n                            \"" on an object with indirect references\"");\n                    }\n\t\t    // Try to resolve indirect objects\n\t\t    object = newIndirect(\n\t\t\tcontext,\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \""endobj\"") && (state == st_top))\n\t\t{\n\t\t    // We just saw endobj without having read\n\t\t    // anything.  Treat this as a null and do not move\n\t\t    // the input source's offset.\n\t\t    object = newNull();\n\t\t    input->seek(input->getLastOffset(), SEEK_SET);\n                    empty = true;\n\t\t}\n\t\telse\n\t\t{\n                    QTC::TC(\""qpdf\"", \""QPDFObjectHandle treat word as string\"");\n                    warn(context,\n                         QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                                 object_description,\n                                 input->getLastOffset(),\n                                 \""unknown token while reading object;\""\n                                 \"" treating as string\""));\n                    object = newString(value);\n\t\t}\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_string:\n\t    {\n\t\tstd::string val = token.getValue();\n                if (decrypter)\n                {\n                    decrypter->decryptString(val);\n                }\n\t\tobject = QPDFObjectHandle::newString(val);\n\t    }\n\n\t    break;\n\n\t  default:\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \""treating unknown token type as null while \""\n                         \""reading object\""));\n            object = newNull();\n\t    break;\n\t}\n\n        if ((! object.isInitialized()) &&\n            (! ((state == st_start) ||\n                (state == st_stop) ||\n                (state == st_eof))))\n        {\n            throw std::logic_error(\n                \""QPDFObjectHandle::parseInternal: \""\n                \""unexpected uninitialized object\"");\n            object = newNull();\n        }\n\n        switch (state)\n        {\n          case st_eof:\n            if (state_stack.size() > 1)\n            {\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""parse error while reading object\""));\n            }\n            done = true;\n            // In content stream mode, leave object uninitialized to\n            // indicate EOF\n            if (! content_stream)\n            {\n                object = newNull();\n            }\n            break;\n\n          case st_dictionary:\n          case st_array:\n            setObjectDescriptionFromInput(\n                object, context, object_description, input,\n                input->getLastOffset());\n            olist.push_back(object);\n            break;\n\n          case st_top:\n            done = true;\n            break;\n\n          case st_start:\n            break;\n\n          case st_stop:\n            if ((state_stack.size() < 2) || (olist_stack.size() < 2))\n            {\n                throw std::logic_error(\n                    \""QPDFObjectHandle::parseInternal: st_stop encountered\""\n                    \"" with insufficient elements in stack\"");\n            }\n            parser_state_e old_state = state_stack.back();\n            state_stack.pop_back();\n            if (old_state == st_array)\n            {\n                object = newArray(olist);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            else if (old_state == st_dictionary)\n            {\n                // Convert list to map. Alternating elements are keys.\n                // Attempt to recover more or less gracefully from\n                // invalid dictionaries.\n                std::set<std::string> names;\n                for (std::vector<QPDFObjectHandle>::iterator iter =\n                         olist.begin();\n                     iter != olist.end(); ++iter)\n                {\n                    if ((! (*iter).isIndirect()) && (*iter).isName())\n                    {\n                        names.insert((*iter).getName());\n                    }\n                }\n\n                std::map<std::string, QPDFObjectHandle> dict;\n                int next_fake_key = 1;\n                for (unsigned int i = 0; i < olist.size(); ++i)\n                {\n                    QPDFObjectHandle key_obj = olist.at(i);\n                    QPDFObjectHandle val;\n                    if (key_obj.isIndirect() || (! key_obj.isName()))\n                    {\n                        bool found_fake = false;\n                        std::string candidate;\n                        while (! found_fake)\n                        {\n                            candidate =\n                                \""/QPDFFake\"" +\n                                QUtil::int_to_string(next_fake_key++);\n                            found_fake = (names.count(candidate) == 0);\n                            QTC::TC(\""qpdf\"", \""QPDFObjectHandle found fake\"",\n                                    (found_fake ? 0 : 1));\n                        }\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \""expected dictionary key but found\""\n                                 \"" non-name object; inserting key \"" +\n                                 candidate));\n                        val = key_obj;\n                        key_obj = newName(candidate);\n                    }\n                    else if (i + 1 >= olist.size())\n                    {\n                        QTC::TC(\""qpdf\"", \""QPDFObjectHandle no val for last key\"");\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \""dictionary ended prematurely; \""\n                                 \""using null as value for last key\""));\n                        val = newNull();\n                        setObjectDescriptionFromInput(\n                            val, context, object_description, input, offset);\n                    }\n                    else\n                    {\n                        val = olist.at(++i);\n                    }\n                    dict[key_obj.getName()] = val;\n                }\n                object = newDictionary(dict);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            olist_stack.pop_back();\n            offset_stack.pop_back();\n            if (state_stack.back() == st_top)\n            {\n                done = true;\n            }\n            else\n            {\n                olist_stack.back().push_back(object);\n            }\n        }\n    }\n\n    setObjectDescriptionFromInput(\n        object, context, object_description, input, offset);\n    return object;\n}"", ""target"": 0}]","[{""func_name"": ""QPDFObjectHandle::parseInternal"", ""file_path"": ""libqpdf/QPDFObjectHandle.cc"", ""func_code"": ""QPDFObjectHandle\nQPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool content_stream)\n{\n    // This method must take care not to resolve any objects. Don't\n    // check the type of any object without first ensuring that it is\n    // a direct object. Otherwise, doing so may have the side effect\n    // of reading the object and changing the file pointer.\n\n    empty = false;\n\n    QPDFObjectHandle object;\n\n    std::vector<std::vector<QPDFObjectHandle> > olist_stack;\n    olist_stack.push_back(std::vector<QPDFObjectHandle>());\n    std::vector<parser_state_e> state_stack;\n    state_stack.push_back(st_top);\n    std::vector<qpdf_offset_t> offset_stack;\n    qpdf_offset_t offset = input->tell();\n    offset_stack.push_back(offset);\n    bool done = false;\n    while (! done)\n    {\n        std::vector<QPDFObjectHandle>& olist = olist_stack.back();\n        parser_state_e state = state_stack.back();\n        offset = offset_stack.back();\n\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description, true);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (! content_stream)\n            {\n                QTC::TC(\""qpdf\"", \""QPDFObjectHandle eof in parseInternal\"");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""unexpected EOF\""));\n            }\n            state = st_eof;\n            break;\n\n          case QPDFTokenizer::tt_bad:\n\t    QTC::TC(\""qpdf\"", \""QPDFObjectHandle bad token in parse\"");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         token.getErrorMessage()));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_brace_open:\n\t  case QPDFTokenizer::tt_brace_close:\n\t    QTC::TC(\""qpdf\"", \""QPDFObjectHandle bad brace\"");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \""treating unexpected brace token as null\""));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (state == st_array)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\""qpdf\"", \""QPDFObjectHandle bad array close\"");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""treating unexpected array close token as null\""));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (state == st_dictionary)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\""qpdf\"", \""QPDFObjectHandle bad dictionary close\"");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""unexpected dictionary close token\""));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t  case QPDFTokenizer::tt_dict_open:\n            if (olist_stack.size() > 500)\n            {\n\t\tQTC::TC(\""qpdf\"", \""QPDFObjectHandle too deep\"");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""ignoring excessively deeply nested data structure\""));\n                object = newNull();\n                state = st_top;\n            }\n            else\n            {\n                olist_stack.push_back(std::vector<QPDFObjectHandle>());\n                state = st_start;\n                offset_stack.push_back(input->tell());\n                state_stack.push_back(\n                    (token.getType() == QPDFTokenizer::tt_array_open) ?\n                    st_array : st_dictionary);\n            }\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \""true\""));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_integer:\n\t    object = newInteger(QUtil::string_to_ll(token.getValue().c_str()));\n\t    break;\n\n\t  case QPDFTokenizer::tt_real:\n\t    object = newReal(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_name:\n\t    object = newName(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \""R\"") && (state != st_top) &&\n                         (olist.size() >= 2) &&\n                         (! olist.at(olist.size() - 1).isIndirect()) &&\n                         (olist.at(olist.size() - 1).isInteger()) &&\n                         (! olist.at(olist.size() - 2).isIndirect()) &&\n                         (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\""qpdf\"", \""QPDFObjectHandle indirect without context\"");\n                        throw std::logic_error(\n                            \""QPDFObjectHandle::parse called without context\""\n                            \"" on an object with indirect references\"");\n                    }\n\t\t    // Try to resolve indirect objects\n\t\t    object = newIndirect(\n\t\t\tcontext,\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \""endobj\"") && (state == st_top))\n\t\t{\n\t\t    // We just saw endobj without having read\n\t\t    // anything.  Treat this as a null and do not move\n\t\t    // the input source's offset.\n\t\t    object = newNull();\n\t\t    input->seek(input->getLastOffset(), SEEK_SET);\n                    empty = true;\n\t\t}\n\t\telse\n\t\t{\n                    QTC::TC(\""qpdf\"", \""QPDFObjectHandle treat word as string\"");\n                    warn(context,\n                         QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                                 object_description,\n                                 input->getLastOffset(),\n                                 \""unknown token while reading object;\""\n                                 \"" treating as string\""));\n                    object = newString(value);\n\t\t}\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_string:\n\t    {\n\t\tstd::string val = token.getValue();\n                if (decrypter)\n                {\n                    decrypter->decryptString(val);\n                }\n\t\tobject = QPDFObjectHandle::newString(val);\n\t    }\n\n\t    break;\n\n\t  default:\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \""treating unknown token type as null while \""\n                         \""reading object\""));\n            object = newNull();\n\t    break;\n\t}\n\n        if ((! object.isInitialized()) &&\n            (! ((state == st_start) ||\n                (state == st_stop) ||\n                (state == st_eof))))\n        {\n            throw std::logic_error(\n                \""QPDFObjectHandle::parseInternal: \""\n                \""unexpected uninitialized object\"");\n            object = newNull();\n        }\n\n        switch (state)\n        {\n          case st_eof:\n            if (state_stack.size() > 1)\n            {\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""parse error while reading object\""));\n            }\n            done = true;\n            // In content stream mode, leave object uninitialized to\n            // indicate EOF\n            if (! content_stream)\n            {\n                object = newNull();\n            }\n            break;\n\n          case st_dictionary:\n          case st_array:\n            setObjectDescriptionFromInput(\n                object, context, object_description, input,\n                input->getLastOffset());\n            olist.push_back(object);\n            break;\n\n          case st_top:\n            done = true;\n            break;\n\n          case st_start:\n            break;\n\n          case st_stop:\n            if ((state_stack.size() < 2) || (olist_stack.size() < 2))\n            {\n                throw std::logic_error(\n                    \""QPDFObjectHandle::parseInternal: st_stop encountered\""\n                    \"" with insufficient elements in stack\"");\n            }\n            parser_state_e old_state = state_stack.back();\n            state_stack.pop_back();\n            if (old_state == st_array)\n            {\n                object = newArray(olist);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            else if (old_state == st_dictionary)\n            {\n                // Convert list to map. Alternating elements are keys.\n                // Attempt to recover more or less gracefully from\n                // invalid dictionaries.\n                std::set<std::string> names;\n                for (std::vector<QPDFObjectHandle>::iterator iter =\n                         olist.begin();\n                     iter != olist.end(); ++iter)\n                {\n                    if ((! (*iter).isIndirect()) && (*iter).isName())\n                    {\n                        names.insert((*iter).getName());\n                    }\n                }\n\n                std::map<std::string, QPDFObjectHandle> dict;\n                int next_fake_key = 1;\n                for (unsigned int i = 0; i < olist.size(); ++i)\n                {\n                    QPDFObjectHandle key_obj = olist.at(i);\n                    QPDFObjectHandle val;\n                    if (key_obj.isIndirect() || (! key_obj.isName()))\n                    {\n                        bool found_fake = false;\n                        std::string candidate;\n                        while (! found_fake)\n                        {\n                            candidate =\n                                \""/QPDFFake\"" +\n                                QUtil::int_to_string(next_fake_key++);\n                            found_fake = (names.count(candidate) == 0);\n                            QTC::TC(\""qpdf\"", \""QPDFObjectHandle found fake\"",\n                                    (found_fake ? 0 : 1));\n                        }\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \""expected dictionary key but found\""\n                                 \"" non-name object; inserting key \"" +\n                                 candidate));\n                        val = key_obj;\n                        key_obj = newName(candidate);\n                    }\n                    else if (i + 1 >= olist.size())\n                    {\n                        QTC::TC(\""qpdf\"", \""QPDFObjectHandle no val for last key\"");\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \""dictionary ended prematurely; \""\n                                 \""using null as value for last key\""));\n                        val = newNull();\n                        setObjectDescriptionFromInput(\n                            val, context, object_description, input, offset);\n                    }\n                    else\n                    {\n                        val = olist.at(++i);\n                    }\n                    dict[key_obj.getName()] = val;\n                }\n                object = newDictionary(dict);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            olist_stack.pop_back();\n            offset_stack.pop_back();\n            if (state_stack.back() == st_top)\n            {\n                done = true;\n            }\n            else\n            {\n                olist_stack.back().push_back(object);\n            }\n        }\n    }\n\n    setObjectDescriptionFromInput(\n        object, context, object_description, input, offset);\n    return object;\n}""}]","{""code"": 2, ""function"": 1, ""value"": 1}","[{""source"": ""code_info(file:QPDFObjectHandle.cc, lines:1500-1600)"", ""result"": ""\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_integer:\n\t    object = newInteger(QUtil::string_to_ll(token.getValue().c_str()));\n\t    break;\n\n\t  case QPDFTokenizer::tt_real:\n\t    object = newReal(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_name:\n\t    object = newName(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \""R\"") && (state != st_top) &&\n                         (olist.size() >= 2) &&\n                         (! olist.at(olist.size() - 1).isIndirect()) &&\n                         (olist.at(olist.size() - 1).isInteger()) &&\n                         (! olist.at(olist.size() - 2).isIndirect()) &&\n                         (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\""qpdf\"", \""QPDFObjectHandle indirect without context\"");\n                        throw std::logic_error(\n                            \""QPDFObjectHandle::parse called without context\""\n                            \"" on an object with indirect references\"");\n                    }\n\t\t    // Try to resolve indirect objects\n\t\t    object = newIndirect(\n\t\t\tcontext,\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \""endobj\"") && (state == st_top))\n\t\t{\n\t\t    // We just saw endobj without having read\n\t\t    // anything.  Treat this as a null and do not move\n\t\t    // the input source's offset.\n\t\t    object = newNull();\n\t\t    input->seek(input->getLastOffset(), SEEK_SET);\n                    empty = true;\n\t\t}\n\t\telse\n\t\t{\n                    QTC::TC(\""qpdf\"", \""QPDFObjectHandle treat word as string\"");\n                    warn(context,\n                         QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                                 object_description,\n                                 input->getLastOffset(),\n                                 \""unknown token while reading object;\""\n                                 \"" treating as string\""));\n                    object = newString(value);\n\t\t}\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_string:\n\t    {\n\t\tstd::string val = token.getValue();\n                if (decrypter)\n                {\n                    decrypter->decryptString(val);\n                }\n\t\tobject = QPDFObjectHandle::newString(val);\n\t    }\n\n\t    break;\n\n\t  default:\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \""treating unknown token type as null while \""\n                         \""reading object\""));\n            object = newNull();\n\t    break;\n\t}\n\n        if ((! object.isInitialized()) &&\n            (! ((state == st_start) ||\n                (state == st_stop) ||\n                (state == st_eof))))\n        {\n            throw std::logic_error(\n                \""QPDFObjectHandle::parseInternal: \""\n                \""unexpected uninitialized object\"");\n""}, {""source"": ""func_info(file:QPDFObjectHandle.cc, func:parseInternal)"", ""result"": [{""code"": ""QPDFObjectHandle\nQPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool content_stream)\n{\n    // This method must take care not to resolve any objects. Don't\n    // check the type of any object without first ensuring that it is\n    // a direct object. Otherwise, doing so may have the side effect\n    // of reading the object and changing the file pointer.\n\n    empty = false;\n\n    QPDFObjectHandle object;\n\n    std::vector<std::vector<QPDFObjectHandle> > olist_stack;\n    olist_stack.push_back(std::vector<QPDFObjectHandle>());\n    std::vector<parser_state_e> state_stack;\n    state_stack.push_back(st_top);\n    std::vector<qpdf_offset_t> offset_stack;\n    qpdf_offset_t offset = input->tell();\n    offset_stack.push_back(offset);\n    bool done = false;\n    while (! done)\n    {\n        std::vector<QPDFObjectHandle>& olist = olist_stack.back();\n        parser_state_e state = state_stack.back();\n        offset = offset_stack.back();\n\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description, true);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (! content_stream)\n            {\n                QTC::TC(\""qpdf\"", \""QPDFObjectHandle eof in parseInternal\"");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""unexpected EOF\""));\n            }\n            state = st_eof;\n            break;\n\n          case QPDFTokenizer::tt_bad:\n\t    QTC::TC(\""qpdf\"", \""QPDFObjectHandle bad token in parse\"");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         token.getErrorMessage()));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_brace_open:\n\t  case QPDFTokenizer::tt_brace_close:\n\t    QTC::TC(\""qpdf\"", \""QPDFObjectHandle bad brace\"");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \""treating unexpected brace token as null\""));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (state == st_array)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\""qpdf\"", \""QPDFObjectHandle bad array close\"");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""treating unexpected array close token as null\""));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (state == st_dictionary)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\""qpdf\"", \""QPDFObjectHandle bad dictionary close\"");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""unexpected dictionary close token\""));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t  case QPDFTokenizer::tt_dict_open:\n            olist_stack.push_back(std::vector<QPDFObjectHandle>());\n            state = st_start;\n            offset_stack.push_back(input->tell());\n            state_stack.push_back(\n                (token.getType() == QPDFTokenizer::tt_array_open) ?\n                st_array : st_dictionary);\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \""true\""));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_integer:\n\t    object = newInteger(QUtil::string_to_ll(token.getValue().c_str()));\n\t    break;\n\n\t  case QPDFTokenizer::tt_real:\n\t    object = newReal(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_name:\n\t    object = newName(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \""R\"") && (state != st_top) &&\n                         (olist.size() >= 2) &&\n                         (! olist.at(olist.size() - 1).isIndirect()) &&\n                         (olist.at(olist.size() - 1).isInteger()) &&\n                         (! olist.at(olist.size() - 2).isIndirect()) &&\n                         (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\""qpdf\"", \""QPDFObjectHandle indirect without context\"");\n                        throw std::logic_error(\n                            \""QPDFObjectHandle::parse called without context\""\n                            \"" on an object with indirect references\"");\n                    }\n\t\t    // Try to resolve indirect objects\n\t\t    object = newIndirect(\n\t\t\tcontext,\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \""endobj\"") && (state == st_top))\n\t\t{\n\t\t    // We just saw endobj without having read\n\t\t    // anything.  Treat this as a null and do not move\n\t\t    // the input source's offset.\n\t\t    object = newNull();\n\t\t    input->seek(input->getLastOffset(), SEEK_SET);\n                    empty = true;\n\t\t}\n\t\telse\n\t\t{\n                    QTC::TC(\""qpdf\"", \""QPDFObjectHandle treat word as string\"");\n                    warn(context,\n                         QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                                 object_description,\n                                 input->getLastOffset(),\n                                 \""unknown token while reading object;\""\n                                 \"" treating as string\""));\n                    object = newString(value);\n\t\t}\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_string:\n\t    {\n\t\tstd::string val = token.getValue();\n                if (decrypter)\n                {\n                    decrypter->decryptString(val);\n                }\n\t\tobject = QPDFObjectHandle::newString(val);\n\t    }\n\n\t    break;\n\n\t  default:\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \""treating unknown token type as null while \""\n                         \""reading object\""));\n            object = newNull();\n\t    break;\n\t}\n\n        if ((! object.isInitialized()) &&\n            (! ((state == st_start) ||\n                (state == st_stop) ||\n                (state == st_eof))))\n        {\n            throw std::logic_error(\n                \""QPDFObjectHandle::parseInternal: \""\n                \""unexpected uninitialized object\"");\n            object = newNull();\n        }\n\n        switch (state)\n        {\n          case st_eof:\n            if (state_stack.size() > 1)\n            {\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \""parse error while reading object\""));\n            }\n            done = true;\n            // In content stream mode, leave object uninitialized to\n            // indicate EOF\n            if (! content_stream)\n            {\n                object = newNull();\n            }\n            break;\n\n          case st_dictionary:\n          case st_array:\n            setObjectDescriptionFromInput(\n                object, context, object_description, input,\n                input->getLastOffset());\n            olist.push_back(object);\n            break;\n\n          case st_top:\n            done = true;\n            break;\n\n          case st_start:\n            break;\n\n          case st_stop:\n            if ((state_stack.size() < 2) || (olist_stack.size() < 2))\n            {\n                throw std::logic_error(\n                    \""QPDFObjectHandle::parseInternal: st_stop encountered\""\n                    \"" with insufficient elements in stack\"");\n            }\n            parser_state_e old_state = state_stack.back();\n            state_stack.pop_back();\n            if (old_state == st_array)\n            {\n                object = newArray(olist);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            else if (old_state == st_dictionary)\n            {\n                // Convert list to map. Alternating elements are keys.\n                // Attempt to recover more or less gracefully from\n                // invalid dictionaries.\n                std::set<std::string> names;\n                for (std::vector<QPDFObjectHandle>::iterator iter =\n                         olist.begin();\n                     iter != olist.end(); ++iter)\n                {\n                    if ((! (*iter).isIndirect()) && (*iter).isName())\n                    {\n                        names.insert((*iter).getName());\n                    }\n                }\n\n                std::map<std::string, QPDFObjectHandle> dict;\n                int next_fake_key = 1;\n                for (unsigned int i = 0; i < olist.size(); ++i)\n                {\n                    QPDFObjectHandle key_obj = olist.at(i);\n                    QPDFObjectHandle val;\n                    if (key_obj.isIndirect() || (! key_obj.isName()))\n                    {\n                        bool found_fake = false;\n                        std::string candidate;\n                        while (! found_fake)\n                        {\n                            candidate =\n                                \""/QPDFFake\"" +\n                                QUtil::int_to_string(next_fake_key++);\n                            found_fake = (names.count(candidate) == 0);\n                            QTC::TC(\""qpdf\"", \""QPDFObjectHandle found fake\"",\n                                    (found_fake ? 0 : 1));\n                        }\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \""expected dictionary key but found\""\n                                 \"" non-name object; inserting key \"" +\n                                 candidate));\n                        val = key_obj;\n                        key_obj = newName(candidate);\n                    }\n                    else if (i + 1 >= olist.size())\n                    {\n                        QTC::TC(\""qpdf\"", \""QPDFObjectHandle no val for last key\"");\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \""dictionary ended prematurely; \""\n                                 \""using null as value for last key\""));\n                        val = newNull();\n                        setObjectDescriptionFromInput(\n                            val, context, object_description, input, offset);\n                    }\n                    else\n                    {\n                        val = olist.at(++i);\n                    }\n                    dict[key_obj.getName()] = val;\n                }\n                object = newDictionary(dict);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            olist_stack.pop_back();\n            offset_stack.pop_back();\n            if (state_stack.back() == st_top)\n            {\n                done = true;\n            }\n            else\n            {\n                olist_stack.back().push_back(object);\n            }\n        }\n    }\n\n    setObjectDescriptionFromInput(\n        object, context, object_description, input, offset);\n    return object;\n}\n"", ""start_line"": 1383, ""end_line"": 1738, ""full_name"": ""QPDFObjectHandle.parseInternal:QPDFObjectHandle(PointerHolder,std.string&,QPDFTokenizer&,bool&,StringDecrypter*,QPDF*,bool)"", ""file_path"": ""libqpdf/QPDFObjectHandle.cc""}]}, {""source"": ""value_info(file:QPDFObjectHandle.h, value:olist_stack)"", ""result"": {""value_trace"": [{""full_code"": ""olist_stack"", ""line"": 1399, ""func_name"": null}], ""struct_var"": ""olist_stack"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""code_info(file:QPDFObjectHandle.cc, lines:1700-1738)"", ""result"": ""                    {\n                        QTC::TC(\""qpdf\"", \""QPDFObjectHandle no val for last key\"");\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \""dictionary ended prematurely; \""\n                                 \""using null as value for last key\""));\n                        val = newNull();\n                        setObjectDescriptionFromInput(\n                            val, context, object_description, input, offset);\n                    }\n                    else\n                    {\n                        val = olist.at(++i);\n                    }\n                    dict[key_obj.getName()] = val;\n                }\n                object = newDictionary(dict);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            olist_stack.pop_back();\n            offset_stack.pop_back();\n            if (state_stack.back() == st_top)\n            {\n                done = true;\n            }\n            else\n            {\n                olist_stack.back().push_back(object);\n            }\n        }\n    }\n\n    setObjectDescriptionFromInput(\n        object, context, object_description, input, offset);\n    return object;\n}\n""}]","libqpdf/QPDFObjectHandle.cc:1488-1504: Unrestricted pushing to `olist_stack` during nested parsing allowed excessive growth. The original code permitted unlimited nesting by appending to `olist_stack` on `tt_array_open`/`tt_dict_open` without depth limits. The patch adds a check (`olist_stack.size() > 500`) to reject deeply nested structures. `olist_stack` is popped only during `st_stop` handling (triggered by `tt_array_close`/`tt_dict_close`). Malformed inputs (e.g., missing/invalid close tokens) prevent popping, leading to unbounded growth. GAP: Evidence for popping behavior in malformed input cases is incomplete, but the code confirms that `olist_stack.pop_back()` occurs only in `st_stop` (libqpdf/QPDFObjectHandle.cc:1700-1738).",0.95,./github/other_context/CVE-2018-9918
47,CVE-2019-12450,"CWE-362, CWE-276",c_cpp,"file_copy_fallback in gio/gfile.c in GNOME GLib 2.15.0 through 2.61.1 does not properly restrict file permissions while a copy operation is in progress. Instead, default permissions are used.",https://github.com/GNOME/glib/commit/d8f8f4d637ce43f8699ba94c9b7648beda0ca174,gfile: Limit access to files when copying\n\nfile_copy_fallback creates new files with default permissions and\nset the correct permissions after the operation is finished. This\nmight cause that the files can be accessible by more users during\nthe operation than expected. Use G_FILE_CREATE_PRIVATE for the new\nfiles to limit access to those files.,1,"[{""func_name"": ""file_copy_fallback"", ""file_path"": ""gio/gfile.c"", ""func_code"": ""static gboolean\nfile_copy_fallback (GFile                  *source,\n                    GFile                  *destination,\n                    GFileCopyFlags          flags,\n                    GCancellable           *cancellable,\n                    GFileProgressCallback   progress_callback,\n                    gpointer                progress_callback_data,\n                    GError                **error)\n{\n  gboolean ret = FALSE;\n  GFileInputStream *file_in = NULL;\n  GInputStream *in = NULL;\n  GOutputStream *out = NULL;\n  GFileInfo *info = NULL;\n  const char *target;\n  char *attrs_to_read;\n  gboolean do_set_attributes = FALSE;\n\n  /* need to know the file type */\n  info = g_file_query_info (source,\n                            G_FILE_ATTRIBUTE_STANDARD_TYPE \"",\"" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                            cancellable,\n                            error);\n  if (!info)\n    goto out;\n\n  /* Maybe copy the symlink? */\n  if ((flags & G_FILE_COPY_NOFOLLOW_SYMLINKS) &&\n      g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK)\n    {\n      target = g_file_info_get_symlink_target (info);\n      if (target)\n        {\n          if (!copy_symlink (destination, flags, cancellable, target, error))\n            goto out;\n\n          ret = TRUE;\n          goto out;\n        }\n        /* ... else fall back on a regular file copy */\n    }\n  /* Handle \""special\"" files (pipes, device nodes, ...)? */\n  else if (g_file_info_get_file_type (info) == G_FILE_TYPE_SPECIAL)\n    {\n      /* FIXME: could try to recreate device nodes and others? */\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n                           _(\""Can\u2019t copy special file\""));\n      goto out;\n    }\n\n  /* Everything else should just fall back on a regular copy. */\n\n  file_in = open_source_for_copy (source, destination, flags, cancellable, error);\n  if (!file_in)\n    goto out;\n  in = G_INPUT_STREAM (file_in);\n\n  if (!build_attribute_list_for_copy (destination, flags, &attrs_to_read,\n                                      cancellable, error))\n    goto out;\n\n  if (attrs_to_read != NULL)\n    {\n      GError *tmp_error = NULL;\n\n      /* Ok, ditch the previous lightweight info (on Unix we just\n       * called lstat()); at this point we gather all the information\n       * we need about the source from the opened file descriptor.\n       */\n      g_object_unref (info);\n\n      info = g_file_input_stream_query_info (file_in, attrs_to_read,\n                                             cancellable, &tmp_error);\n      if (!info)\n        {\n          /* Not all gvfs backends implement query_info_on_read(), we\n           * can just fall back to the pathname again.\n           * https://bugzilla.gnome.org/706254\n           */\n          if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&tmp_error);\n              info = g_file_query_info (source, attrs_to_read, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable, error);\n            }\n          else\n            {\n              g_free (attrs_to_read);\n              g_propagate_error (error, tmp_error);\n              goto out;\n            }\n        }\n      g_free (attrs_to_read);\n      if (!info)\n        goto out;\n\n      do_set_attributes = TRUE;\n    }\n\n  /* In the local file path, we pass down the source info which\n   * includes things like unix::mode, to ensure that the target file\n   * is not created with different permissions from the source file.\n   *\n   * If a future API like g_file_replace_with_info() is added, switch\n   * this code to use that.\n   */\n  if (G_IS_LOCAL_FILE (destination))\n    {\n      if (flags & G_FILE_COPY_OVERWRITE)\n        out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                   FALSE, NULL,\n                                                                   flags & G_FILE_COPY_BACKUP,\n                                                                   G_FILE_CREATE_REPLACE_DESTINATION,\n                                                                   info,\n                                                                   cancellable, error);\n      else\n        out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                  FALSE, 0, info,\n                                                                  cancellable, error);\n    }\n  else if (flags & G_FILE_COPY_OVERWRITE)\n    {\n      out = (GOutputStream *)g_file_replace (destination,\n                                             NULL,\n                                             flags & G_FILE_COPY_BACKUP,\n                                             G_FILE_CREATE_REPLACE_DESTINATION,\n                                             cancellable, error);\n    }\n  else\n    {\n      out = (GOutputStream *)g_file_create (destination, 0, cancellable, error);\n    }\n\n  if (!out)\n    goto out;\n\n#ifdef __linux__\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *reflink_err = NULL;\n\n      if (!btrfs_reflink_with_progress (in, out, info, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &reflink_err))\n        {\n          if (g_error_matches (reflink_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&reflink_err);\n            }\n          else\n            {\n              g_propagate_error (error, reflink_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n#endif\n\n#ifdef HAVE_SPLICE\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *splice_err = NULL;\n\n      if (!splice_stream_with_progress (in, out, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &splice_err))\n        {\n          if (g_error_matches (splice_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&splice_err);\n            }\n          else\n            {\n              g_propagate_error (error, splice_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n\n#endif\n\n  /* A plain read/write loop */\n  if (!copy_stream_with_progress (in, out, source, cancellable,\n                                  progress_callback, progress_callback_data,\n                                  error))\n    goto out;\n\n  ret = TRUE;\n out:\n  if (in)\n    {\n      /* Don't care about errors in source here */\n      (void) g_input_stream_close (in, cancellable, NULL);\n      g_object_unref (in);\n    }\n\n  if (out)\n    {\n      /* But write errors on close are bad! */\n      if (!g_output_stream_close (out, cancellable, ret ? error : NULL))\n        ret = FALSE;\n      g_object_unref (out);\n    }\n\n  /* Ignore errors here. Failure to copy metadata is not a hard error */\n  /* TODO: set these attributes /before/ we do the rename() on Unix */\n  if (ret && do_set_attributes)\n    {\n      g_file_set_attributes_from_info (destination,\n                                       info,\n                                       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                       cancellable,\n                                       NULL);\n    }\n\n  g_clear_object (&info);\n\n  return ret;\n}"", ""target"": 0}]","[{""func_name"": ""file_copy_fallback"", ""file_path"": ""gio/gfile.c"", ""func_code"": ""static gboolean\nfile_copy_fallback (GFile                  *source,\n                    GFile                  *destination,\n                    GFileCopyFlags          flags,\n                    GCancellable           *cancellable,\n                    GFileProgressCallback   progress_callback,\n                    gpointer                progress_callback_data,\n                    GError                **error)\n{\n  gboolean ret = FALSE;\n  GFileInputStream *file_in = NULL;\n  GInputStream *in = NULL;\n  GOutputStream *out = NULL;\n  GFileInfo *info = NULL;\n  const char *target;\n  char *attrs_to_read;\n  gboolean do_set_attributes = FALSE;\n\n  /* need to know the file type */\n  info = g_file_query_info (source,\n                            G_FILE_ATTRIBUTE_STANDARD_TYPE \"",\"" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                            cancellable,\n                            error);\n  if (!info)\n    goto out;\n\n  /* Maybe copy the symlink? */\n  if ((flags & G_FILE_COPY_NOFOLLOW_SYMLINKS) &&\n      g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK)\n    {\n      target = g_file_info_get_symlink_target (info);\n      if (target)\n        {\n          if (!copy_symlink (destination, flags, cancellable, target, error))\n            goto out;\n\n          ret = TRUE;\n          goto out;\n        }\n        /* ... else fall back on a regular file copy */\n    }\n  /* Handle \""special\"" files (pipes, device nodes, ...)? */\n  else if (g_file_info_get_file_type (info) == G_FILE_TYPE_SPECIAL)\n    {\n      /* FIXME: could try to recreate device nodes and others? */\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n                           _(\""Can\u2019t copy special file\""));\n      goto out;\n    }\n\n  /* Everything else should just fall back on a regular copy. */\n\n  file_in = open_source_for_copy (source, destination, flags, cancellable, error);\n  if (!file_in)\n    goto out;\n  in = G_INPUT_STREAM (file_in);\n\n  if (!build_attribute_list_for_copy (destination, flags, &attrs_to_read,\n                                      cancellable, error))\n    goto out;\n\n  if (attrs_to_read != NULL)\n    {\n      GError *tmp_error = NULL;\n\n      /* Ok, ditch the previous lightweight info (on Unix we just\n       * called lstat()); at this point we gather all the information\n       * we need about the source from the opened file descriptor.\n       */\n      g_object_unref (info);\n\n      info = g_file_input_stream_query_info (file_in, attrs_to_read,\n                                             cancellable, &tmp_error);\n      if (!info)\n        {\n          /* Not all gvfs backends implement query_info_on_read(), we\n           * can just fall back to the pathname again.\n           * https://bugzilla.gnome.org/706254\n           */\n          if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&tmp_error);\n              info = g_file_query_info (source, attrs_to_read, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable, error);\n            }\n          else\n            {\n              g_free (attrs_to_read);\n              g_propagate_error (error, tmp_error);\n              goto out;\n            }\n        }\n      g_free (attrs_to_read);\n      if (!info)\n        goto out;\n\n      do_set_attributes = TRUE;\n    }\n\n  /* In the local file path, we pass down the source info which\n   * includes things like unix::mode, to ensure that the target file\n   * is not created with different permissions from the source file.\n   *\n   * If a future API like g_file_replace_with_info() is added, switch\n   * this code to use that.\n   */\n  if (G_IS_LOCAL_FILE (destination))\n    {\n      if (flags & G_FILE_COPY_OVERWRITE)\n        out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                   FALSE, NULL,\n                                                                   flags & G_FILE_COPY_BACKUP,\n                                                                   G_FILE_CREATE_REPLACE_DESTINATION |\n                                                                   G_FILE_CREATE_PRIVATE, info,\n                                                                   cancellable, error);\n      else\n        out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                  FALSE, G_FILE_CREATE_PRIVATE, info,\n                                                                  cancellable, error);\n    }\n  else if (flags & G_FILE_COPY_OVERWRITE)\n    {\n      out = (GOutputStream *)g_file_replace (destination,\n                                             NULL,\n                                             flags & G_FILE_COPY_BACKUP,\n                                             G_FILE_CREATE_REPLACE_DESTINATION |\n                                             G_FILE_CREATE_PRIVATE,\n                                             cancellable, error);\n    }\n  else\n    {\n      out = (GOutputStream *)g_file_create (destination, G_FILE_CREATE_PRIVATE, cancellable, error);\n    }\n\n  if (!out)\n    goto out;\n\n#ifdef __linux__\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *reflink_err = NULL;\n\n      if (!btrfs_reflink_with_progress (in, out, info, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &reflink_err))\n        {\n          if (g_error_matches (reflink_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&reflink_err);\n            }\n          else\n            {\n              g_propagate_error (error, reflink_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n#endif\n\n#ifdef HAVE_SPLICE\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *splice_err = NULL;\n\n      if (!splice_stream_with_progress (in, out, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &splice_err))\n        {\n          if (g_error_matches (splice_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&splice_err);\n            }\n          else\n            {\n              g_propagate_error (error, splice_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n\n#endif\n\n  /* A plain read/write loop */\n  if (!copy_stream_with_progress (in, out, source, cancellable,\n                                  progress_callback, progress_callback_data,\n                                  error))\n    goto out;\n\n  ret = TRUE;\n out:\n  if (in)\n    {\n      /* Don't care about errors in source here */\n      (void) g_input_stream_close (in, cancellable, NULL);\n      g_object_unref (in);\n    }\n\n  if (out)\n    {\n      /* But write errors on close are bad! */\n      if (!g_output_stream_close (out, cancellable, ret ? error : NULL))\n        ret = FALSE;\n      g_object_unref (out);\n    }\n\n  /* Ignore errors here. Failure to copy metadata is not a hard error */\n  /* TODO: set these attributes /before/ we do the rename() on Unix */\n  if (ret && do_set_attributes)\n    {\n      g_file_set_attributes_from_info (destination,\n                                       info,\n                                       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                       cancellable,\n                                       NULL);\n    }\n\n  g_clear_object (&info);\n\n  return ret;\n}""}]","{""function"": 4, ""value"": 1}","[{""source"": ""func_info(file:glocalfileoutputstream.c, func:_g_local_file_output_stream_create)"", ""result"": [{""code"": ""GFileOutputStream *\n_g_local_file_output_stream_create  (const char        *filename,\n\t\t\t\t     gboolean          readable,\n\t\t\t\t     GFileCreateFlags   flags,\n                                     GFileInfo         *reference_info,\n\t\t\t\t     GCancellable      *cancellable,\n\t\t\t\t     GError           **error)\n{\n  int mode;\n  int open_flags;\n\n  if (g_cancellable_set_error_if_cancelled (cancellable, error))\n    return NULL;\n\n  mode = mode_from_flags_or_info (flags, reference_info);\n\n  open_flags = O_CREAT | O_EXCL | O_BINARY;\n  if (readable)\n    open_flags |= O_RDWR;\n  else\n    open_flags |= O_WRONLY;\n\n  return output_stream_open (filename, open_flags, mode, cancellable, error);\n}"", ""start_line"": 712, ""end_line"": 735, ""full_name"": ""_g_local_file_output_stream_create"", ""file_path"": ""gio/glocalfileoutputstream.c""}]}, {""source"": ""func_info(file:gfile.c, func:g_file_replace)"", ""result"": [{""code"": ""GFileOutputStream *\ng_file_replace (GFile             *file,\n                const char        *etag,\n                gboolean           make_backup,\n                GFileCreateFlags   flags,\n                GCancellable      *cancellable,\n                GError           **error)\n{\n  GFileIface *iface;\n\n  g_return_val_if_fail (G_IS_FILE (file), NULL);\n\n  if (g_cancellable_set_error_if_cancelled (cancellable, error))\n    return NULL;\n\n  iface = G_FILE_GET_IFACE (file);\n\n  if (iface->replace == NULL)\n    {\n      g_set_error_literal (error, G_IO_ERROR,\n                           G_IO_ERROR_NOT_SUPPORTED,\n                           _(\""Operation not supported\""));\n      return NULL;\n    }\n\n  /* Handle empty tag string as NULL in consistent way. */\n  if (etag && *etag == 0)\n    etag = NULL;\n\n  return (* iface->replace) (file, etag, make_backup, flags, cancellable, error);\n}"", ""start_line"": 1866, ""end_line"": 1896, ""full_name"": ""g_file_replace"", ""file_path"": ""gio/gfile.c""}]}, {""source"": ""func_info(file:gfile.c, func:g_file_create)"", ""result"": [{""code"": ""GFileOutputStream *\ng_file_create (GFile             *file,\n               GFileCreateFlags   flags,\n               GCancellable      *cancellable,\n               GError           **error)\n{\n  GFileIface *iface;\n\n  g_return_val_if_fail (G_IS_FILE (file), NULL);\n\n  if (g_cancellable_set_error_if_cancelled (cancellable, error))\n    return NULL;\n\n  iface = G_FILE_GET_IFACE (file);\n\n  if (iface->create == NULL)\n    {\n      g_set_error_literal (error, G_IO_ERROR,\n                           G_IO_ERROR_NOT_SUPPORTED,\n                           _(\""Operation not supported\""));\n      return NULL;\n    }\n\n  return (* iface->create) (file, flags, cancellable, error);\n}"", ""start_line"": 1784, ""end_line"": 1808, ""full_name"": ""g_file_create"", ""file_path"": ""gio/gfile.c""}]}, {""source"": ""value_info(file:gfileenums.h, value:G_FILE_CREATE_PRIVATE)"", ""result"": {""value_trace"": [{""full_code"": ""G_FILE_CREATE_PRIVATE = (1 << 0)"", ""line"": 208, ""func_name"": ""GFileCreateFlags:<clinit>""}], ""struct_var"": ""G_FILE_CREATE_PRIVATE"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""func_info(file:glocalfileoutputstream.c, func:mode_from_flags_or_info)"", ""result"": [{""code"": ""static gint\nmode_from_flags_or_info (GFileCreateFlags   flags,\n                         GFileInfo         *reference_info)\n{\n  if (flags & G_FILE_CREATE_PRIVATE)\n    return 0600;\n  else if (reference_info && g_file_info_has_attribute (reference_info, \""unix::mode\""))\n    return g_file_info_get_attribute_uint32 (reference_info, \""unix::mode\"") & (~S_IFMT);\n  else\n    return 0666;\n}"", ""start_line"": 700, ""end_line"": 710, ""full_name"": ""mode_from_flags_or_info"", ""file_path"": ""gio/glocalfileoutputstream.c""}]}]","gio/gfile.c:3285-3295: Files were created with default permissions (0666) during copy operations. The patch adds G_FILE_CREATE_PRIVATE to g_file_create, g_file_replace, and _g_local_file_output_stream_create. This flag is processed in gio/glocalfileoutputstream.c:700-710 (mode_from_flags_or_info), which sets mode=0600 for private files. Previously, mode_from_flags_or_info defaulted to 0666, allowing temporary over-privilege before final permissions were applied.",0.95,./github/other_context/CVE-2019-12450
48,CVE-2019-15702,CWE-835,c_cpp,"In the TCP implementation (gnrc_tcp) in RIOT through 2019.07, the parser for TCP options does not terminate on all inputs, allowing a denial-of-service, because sys/net/gnrc/transport_layer/tcp/gnrc_tcp_option.c has an infinite loop for an unknown zero-length option.",https://github.com/RIOT-OS/RIOT/commit/9764697a3b21ea4c7c0d33ce4e3a83d2da620a1a,gnrc_tcp: abort on unknown option,1,"[{""func_name"": ""_option_parse"", ""file_path"": ""sys/net/gnrc/transport_layer/tcp/gnrc_tcp_option.c"", ""func_code"": ""int _option_parse(gnrc_tcp_tcb_t *tcb, tcp_hdr_t *hdr)\n{\n    /* Extract offset value. Return if no options are set */\n    uint8_t offset = GET_OFFSET(byteorder_ntohs(hdr->off_ctl));\n    if (offset <= TCP_HDR_OFFSET_MIN) {\n        return 0;\n    }\n\n    /* Get pointer to option field and field size */\n    uint8_t *opt_ptr = (uint8_t *) hdr + sizeof(tcp_hdr_t);\n    uint8_t opt_left = (offset - TCP_HDR_OFFSET_MIN) * 4;\n\n    /* Parse options via tcp_hdr_opt_t */\n    while (opt_left > 0) {\n        tcp_hdr_opt_t *option = (tcp_hdr_opt_t *) opt_ptr;\n\n        /* Examine current option */\n        switch (option->kind) {\n            case TCP_OPTION_KIND_EOL:\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : EOL option found\\n\"");\n                return 0;\n\n            case TCP_OPTION_KIND_NOP:\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : NOP option found\\n\"");\n                opt_ptr += 1;\n                opt_left -= 1;\n                continue;\n\n            case TCP_OPTION_KIND_MSS:\n                if (option->length != TCP_OPTION_LENGTH_MSS) {\n                    DEBUG(\""gnrc_tcp_option.c : _option_parse() : invalid MSS Option length.\\n\"");\n                    return -1;\n                }\n                tcb->mss = (option->value[0] << 8) | option->value[1];\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : MSS option found. MSS=%\""PRIu16\""\\n\"",\n                      tcb->mss);\n                break;\n\n            default:\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : Unknown option found.\\\n                      KIND=%\""PRIu8\"", LENGTH=%\""PRIu8\""\\n\"", option->kind, option->length);\n        }\n\n        if (option->length > opt_left) {\n            DEBUG(\""gnrc_tcp_option.c : _option_parse() : invalid option length\\n\"");\n            return 0;\n        }\n\n        opt_ptr += option->length;\n        opt_left -= option->length;\n    }\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""_option_parse"", ""file_path"": ""sys/net/gnrc/transport_layer/tcp/gnrc_tcp_option.c"", ""func_code"": ""int _option_parse(gnrc_tcp_tcb_t *tcb, tcp_hdr_t *hdr)\n{\n    /* Extract offset value. Return if no options are set */\n    uint8_t offset = GET_OFFSET(byteorder_ntohs(hdr->off_ctl));\n    if (offset <= TCP_HDR_OFFSET_MIN) {\n        return 0;\n    }\n\n    /* Get pointer to option field and field size */\n    uint8_t *opt_ptr = (uint8_t *) hdr + sizeof(tcp_hdr_t);\n    uint8_t opt_left = (offset - TCP_HDR_OFFSET_MIN) * 4;\n\n    /* Parse options via tcp_hdr_opt_t */\n    while (opt_left > 0) {\n        tcp_hdr_opt_t *option = (tcp_hdr_opt_t *) opt_ptr;\n\n        /* Examine current option */\n        switch (option->kind) {\n            case TCP_OPTION_KIND_EOL:\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : EOL option found\\n\"");\n                return 0;\n\n            case TCP_OPTION_KIND_NOP:\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : NOP option found\\n\"");\n                opt_ptr += 1;\n                opt_left -= 1;\n                continue;\n\n            case TCP_OPTION_KIND_MSS:\n                if (option->length != TCP_OPTION_LENGTH_MSS) {\n                    DEBUG(\""gnrc_tcp_option.c : _option_parse() : invalid MSS Option length.\\n\"");\n                    return -1;\n                }\n                tcb->mss = (option->value[0] << 8) | option->value[1];\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : MSS option found. MSS=%\""PRIu16\""\\n\"",\n                      tcb->mss);\n                break;\n\n            default:\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : Unknown option found.\\\n                      KIND=%\""PRIu8\"", LENGTH=%\""PRIu8\""\\n\"", option->kind, option->length);\n                return -1;\n        }\n\n        if (option->length > opt_left) {\n            DEBUG(\""gnrc_tcp_option.c : _option_parse() : invalid option length\\n\"");\n            return 0;\n        }\n\n        opt_ptr += option->length;\n        opt_left -= option->length;\n    }\n    return 0;\n}""}]","{""caller"": 1, ""code"": 5}","[{""source"": ""caller_info(file:gnrc_tcp_option.c, func:_option_parse)"", ""result"": [{""call_line"": 414, ""call_code"": ""_option_parse(tcb, tcp_hdr)"", ""caller_code"": ""static int _fsm_rcvd_pkt(gnrc_tcp_tcb_t *tcb, gnrc_pktsnip_t *in_pkt)\n{\n    gnrc_pktsnip_t *out_pkt = NULL;  /* Outgoing packet */\n    uint16_t seq_con = 0;            /* Sequence number consumption of outgoing packet */\n    gnrc_pktsnip_t *snp = NULL;      /* Temporary packet snip */\n    gnrc_tcp_tcb_t *lst = NULL;      /* Temporary pointer to TCB */\n    uint16_t ctl = 0;                /* Control bits of the incomming packet */\n    uint32_t seg_seq = 0;            /* Sequence number of the incomming packet*/\n    uint32_t seg_ack = 0;            /* Acknowledgment number of the incomming packet */\n    uint32_t seg_wnd = 0;            /* Receive window of the incomming packet */\n    uint32_t seg_len = 0;            /* Segment length of the incomming packet */\n    uint32_t pay_len = 0;            /* Payload length of the incomming packet */\n\n    DEBUG(\""gnrc_tcp_fsm.c : _fsm_rcvd_pkt()\\n\"");\n    /* Search for TCP header. */\n    LL_SEARCH_SCALAR(in_pkt, snp, type, GNRC_NETTYPE_TCP);\n    tcp_hdr_t *tcp_hdr = (tcp_hdr_t *) snp->data;\n\n    /* Parse packet options, return if they are malformed */\n    if (_option_parse(tcb, tcp_hdr) < 0) {\n        return 0;\n    }\n\n    /* Extract header values */\n    ctl = byteorder_ntohs(tcp_hdr->off_ctl);\n    seg_seq = byteorder_ntohl(tcp_hdr->seq_num);\n    seg_ack = byteorder_ntohl(tcp_hdr->ack_num);\n    seg_wnd = byteorder_ntohs(tcp_hdr->window);\n\n    /* Extract network layer header */\n#ifdef MODULE_GNRC_IPV6\n    LL_SEARCH_SCALAR(in_pkt, snp, type, GNRC_NETTYPE_IPV6);\n    if (snp == NULL) {\n        DEBUG(\""gnrc_tcp_fsm.c : _fsm_rcvd_pkt() : incomming packet had no IPv6 header\\n\"");\n        return 0;\n    }\n    void *ip = snp->data;\n#endif\n\n    /* Handle state LISTEN */\n    if (tcb->state == FSM_STATE_LISTEN) {\n        /* 1) Check RST: if RST is set: return */\n        if (ctl & MSK_RST) {\n            return 0;\n        }\n        /* 2) Check ACK: if ACK is set: send RST with seq_no = ack_no and return */\n        if (ctl & MSK_ACK) {\n            _pkt_build_reset_from_pkt(&out_pkt, in_pkt);\n            _pkt_send(tcb, out_pkt, 0, false);\n            return 0;\n        }\n        /* 3) Check SYN: if SYN is set prepare for incomming connection */\n        if (ctl & MSK_SYN) {\n            uint16_t src = byteorder_ntohs(tcp_hdr->src_port);\n            uint16_t dst = byteorder_ntohs(tcp_hdr->dst_port);\n\n            /* Check if SYN request is handled by another connection */\n            lst = _list_tcb_head;\n            while (lst) {\n                /* Compare port numbers and network layer adresses */\n                if (lst->local_port == dst && lst->peer_port == src) {\n#ifdef MODULE_GNRC_IPV6\n                    if (snp->type == GNRC_NETTYPE_IPV6 && lst->address_family == AF_INET6) {\n                        ipv6_addr_t *dst_addr = &((ipv6_hdr_t *)ip)->dst;\n                        ipv6_addr_t *src_addr = &((ipv6_hdr_t *)ip)->src;\n\n                        if (ipv6_addr_equal((ipv6_addr_t *)lst->local_addr, dst_addr) &&\n                            ipv6_addr_equal((ipv6_addr_t *)lst->peer_addr, src_addr)) {\n                            break;\n                        }\n                    }\n#endif\n                }\n                lst = lst->next;\n            }\n            /* Return if connection is already handled (port and addresses match) */\n            if (lst != NULL) {\n                DEBUG(\""gnrc_tcp_fsm.c : _fsm_rcvd_pkt() : Connection already handled\\n\"");\n                return 0;\n            }\n\n            /* SYN request is valid, fill TCB with connection information */\n#ifdef MODULE_GNRC_IPV6\n            if (snp->type == GNRC_NETTYPE_IPV6 && tcb->address_family == AF_INET6) {\n                memcpy(tcb->local_addr, &((ipv6_hdr_t *)ip)->dst, sizeof(ipv6_addr_t));\n                memcpy(tcb->peer_addr, &((ipv6_hdr_t *)ip)->src, sizeof(ipv6_addr_t));\n\n                /* In case peer_addr is link local: Store interface Id in tcb */\n                if (ipv6_addr_is_link_local((ipv6_addr_t *) tcb->peer_addr)) {\n                    gnrc_pktsnip_t *tmp = NULL;\n                    LL_SEARCH_SCALAR(in_pkt, tmp, type, GNRC_NETTYPE_NETIF);\n                    /* cppcheck-suppress knownConditionTrueFalse\n                     * (reason: tmp *can* be != NULL after LL_SEARCH_SCALAR) */\n                    if (tmp == NULL) {\n                        DEBUG(\""gnrc_tcp_fsm.c : _fsm_rcvd_pkt() :\\\n                               incomming packet had no netif header\\n\"");\n                        return 0;\n                    }\n                    tcb->ll_iface = ((gnrc_netif_hdr_t *)tmp->data)->if_pid;\n                }\n            }\n#else\n            DEBUG(\""gnrc_tcp_fsm.c : _fsm_rcvd_pkt() : Received address was not stored\\n\"");\n            return 0;\n#endif\n\n            tcb->local_port = dst;\n            tcb->peer_port = src;\n            tcb->irs = byteorder_ntohl(tcp_hdr->seq_num);\n            tcb->rcv_nxt = tcb->irs + 1;\n            tcb->iss = random_uint32();\n            tcb->snd_una = tcb->iss;\n            tcb->snd_nxt = tcb->iss;\n            tcb->snd_wnd = seg_wnd;\n\n            /* Send SYN+ACK: seq_no = iss, ack_no = rcv_nxt, T: LISTEN -> SYN_RCVD */\n            _pkt_build(tcb, &out_pkt, &seq_con, MSK_SYN_ACK, tcb->iss, tcb->rcv_nxt, NULL, 0);\n            _pkt_setup_retransmit(tcb, out_pkt, false);\n            _pkt_send(tcb, out_pkt, seq_con, false);\n            _transition_to(tcb, FSM_STATE_SYN_RCVD);\n        }\n        return 0;\n    }\n    /* Handle state SYN_SENT */\n    else if (tcb->state == FSM_STATE_SYN_SENT) {\n        /* 1) Check ACK */\n        if (ctl & MSK_ACK) {\n            /* If ACK is not acceptable ...*/\n            if (seg_ack <= tcb->iss || seg_ack > tcb->snd_nxt) {\n                /* ... send reset, if RST is not set else return */\n                if ((ctl & MSK_RST) != MSK_RST) {\n                    _pkt_build(tcb, &out_pkt, &seq_con, MSK_RST, seg_ack, 0, NULL, 0);\n                    _pkt_send(tcb, out_pkt, seq_con, false);\n                }\n                return 0;\n            }\n        }\n        /* 2) Check RST: If RST set ... */\n        if (ctl & MSK_RST) {\n            /* ... and ACK: Translate to CLOSED, if not return */\n            if (ctl & MSK_ACK) {\n                _transition_to(tcb, FSM_STATE_CLOSED);\n            }\n            return 0;\n        }\n        /* 3) Check SYN: Set TCB values accordingly */\n        if (ctl & MSK_SYN) {\n            tcb->rcv_nxt = seg_seq + 1;\n            tcb->irs = seg_seq;\n            if (ctl & MSK_ACK) {\n                tcb->snd_una = seg_ack;\n                _pkt_acknowledge(tcb, seg_ack);\n            }\n            /* Set local network layer address accordingly */\n#ifdef MODULE_GNRC_IPV6\n            if (snp->type == GNRC_NETTYPE_IPV6 && tcb->address_family == AF_INET6) {\n                memcpy(tcb->local_addr, &((ipv6_hdr_t *)ip)->dst, sizeof(ipv6_addr_t));\n            }\n#else\n            DEBUG(\""gnrc_tcp_fsm.c : _fsm_rcvd_pkt() : Received address was not stored\\n\"");\n            return 0;\n#endif\n\n            /* SYN has been ACKed. Send ACK, T: SYN_SENT -> ESTABLISHED */\n            if (tcb->snd_una > tcb->iss) {\n                _pkt_build(tcb, &out_pkt, &seq_con, MSK_ACK, tcb->snd_nxt, tcb->rcv_nxt, NULL, 0);\n                _pkt_send(tcb, out_pkt, seq_con, false);\n                _transition_to(tcb, FSM_STATE_ESTABLISHED);\n            }\n            /* Simultaneous SYN received. Send SYN+ACK, T: SYN_SENT -> SYN_RCVD */\n            else {\n                _pkt_build(tcb, &out_pkt, &seq_con, MSK_SYN_ACK, tcb->iss, tcb->rcv_nxt, NULL, 0);\n                _pkt_setup_retransmit(tcb, out_pkt, false);\n                _pkt_send(tcb, out_pkt, seq_con, false);\n                _transition_to(tcb, FSM_STATE_SYN_RCVD);\n            }\n            tcb->snd_wnd = seg_wnd;\n            tcb->snd_wl1 = seg_seq;\n            tcb->snd_wl2 = seg_ack;\n        }\n        return 0;\n    }\n    /* Handle other states */\n    else {\n        seg_len = _pkt_get_seg_len(in_pkt);\n        pay_len = _pkt_get_pay_len(in_pkt);\n        /* 1) Verify sequence number ... */\n        if (_pkt_chk_seq_num(tcb, seg_seq, pay_len)) {\n            /* ... if invalid, and RST not set, reply with pure ACK, return */\n            if ((ctl & MSK_RST) != MSK_RST) {\n                _pkt_build(tcb, &out_pkt, &seq_con, MSK_ACK, tcb->snd_nxt, tcb->rcv_nxt, NULL, 0);\n                _pkt_send(tcb, out_pkt, seq_con, false);\n            }\n            return 0;\n        }\n        /* 2) Check RST: If RST is set ... */\n        if (ctl & MSK_RST) {\n            /* .. and state is SYN_RCVD and the connection is passive: SYN_RCVD -> LISTEN */\n            if (tcb->state == FSM_STATE_SYN_RCVD && (tcb->status & STATUS_PASSIVE)) {\n                if (_transition_to(tcb, FSM_STATE_LISTEN) == -ENOMEM) {\n                    _transition_to(tcb, FSM_STATE_CLOSED);\n                    return -ENOMEM;\n                }\n            }\n            else {\n                _transition_to(tcb, FSM_STATE_CLOSED);\n            }\n            return 0;\n        }\n        /* 3) Check SYN: If SYN is set ... */\n        if (ctl & MSK_SYN) {\n            /* ... send RST, seq_no = snd_nxt, ack_no = rcv_nxt */\n            _pkt_build(tcb, &out_pkt, &seq_con, MSK_RST, tcb->snd_nxt, tcb->rcv_nxt, NULL, 0);\n            _pkt_send(tcb, out_pkt, seq_con, false);\n            _transition_to(tcb, FSM_STATE_CLOSED);\n            return 0;\n        }\n        /* 4) Check ACK */\n        if (!(ctl & MSK_ACK)) {\n            return 0;\n        }\n        else {\n            if (tcb->state == FSM_STATE_SYN_RCVD) {\n                if (LSS_32_BIT(tcb->snd_una, seg_ack) && LEQ_32_BIT(seg_ack, tcb->snd_nxt)) {\n                    tcb->snd_wnd = seg_wnd;\n                    tcb->snd_wl1 = seg_seq;\n                    tcb->snd_wl2 = seg_ack;\n                    _transition_to(tcb, FSM_STATE_ESTABLISHED);\n                }\n                else {\n                    _pkt_build(tcb, &out_pkt, &seq_con, MSK_RST, seg_ack, 0, NULL, 0);\n                    _pkt_send(tcb, out_pkt, seq_con, false);\n                }\n            }\n            /* Acknowledgment processing */\n            if (tcb->state == FSM_STATE_ESTABLISHED || tcb->state == FSM_STATE_FIN_WAIT_1 ||\n                tcb->state == FSM_STATE_FIN_WAIT_2 || tcb->state == FSM_STATE_CLOSE_WAIT ||\n                tcb->state == FSM_STATE_CLOSING || tcb->state == FSM_STATE_LAST_ACK) {\n                /* Acknowledge previously sent data */\n                if (LSS_32_BIT(tcb->snd_una, seg_ack) && LEQ_32_BIT(seg_ack, tcb->snd_nxt)) {\n                    tcb->snd_una = seg_ack;\n                    _pkt_acknowledge(tcb, seg_ack);\n                }\n                /* ACK received for something not yet sent: Reply with pure ACK */\n                else if (LSS_32_BIT(tcb->snd_nxt, seg_ack)) {\n                    _pkt_build(tcb, &out_pkt, &seq_con, MSK_ACK, tcb->snd_nxt, tcb->rcv_nxt,\n                               NULL, 0);\n                    _pkt_send(tcb, out_pkt, seq_con, false);\n                    return 0;\n                }\n                /* Update receive window */\n                if (LEQ_32_BIT(tcb->snd_una, seg_ack) && LEQ_32_BIT(seg_ack, tcb->snd_nxt)) {\n                    if (LSS_32_BIT(tcb->snd_wl1, seg_seq) || (tcb->snd_wl1 == seg_seq &&\n                        LEQ_32_BIT(tcb->snd_wl2, seg_ack))) {\n                        tcb->snd_wnd = seg_wnd;\n                        tcb->snd_wl1 = seg_seq;\n                        tcb->snd_wl2 = seg_ack;\n\n                        /* Signal user after window update */\n                        tcb->status |= STATUS_NOTIFY_USER;\n                    }\n                }\n                /* Additional processing */\n                /* Check additionaly if previously sent FIN was acknowledged */\n                if (tcb->state == FSM_STATE_FIN_WAIT_1) {\n                    if (tcb->pkt_retransmit == NULL) {\n                        _transition_to(tcb, FSM_STATE_FIN_WAIT_2);\n                    }\n                }\n                /* If retransmission queue is empty, acknowledge close operation */\n                if (tcb->state == FSM_STATE_FIN_WAIT_2) {\n                    if (tcb->pkt_retransmit == NULL) {\n                        /* Optional: Unblock user close operation */\n                    }\n                }\n                /* If our FIN has been acknowledged: Transition to TIME_WAIT */\n                if (tcb->state == FSM_STATE_CLOSING) {\n                    if (tcb->pkt_retransmit == NULL) {\n                        _transition_to(tcb, FSM_STATE_TIME_WAIT);\n                    }\n                }\n                /* If our FIN was acknowledged and status is LAST_ACK: close connection */\n                if (tcb->state == FSM_STATE_LAST_ACK) {\n                    if (tcb->pkt_retransmit == NULL) {\n                        _transition_to(tcb, FSM_STATE_CLOSED);\n                        return 0;\n                    }\n                }\n            }\n        }\n        /* 5) Check URG */\n        /* NOTE: Add urgent pointer processing here ... */\n\n        /* 6) Process payload, if existing */\n        if (pay_len > 0) {\n            /* Check if state is valid for payload receiving */\n            if (tcb->state == FSM_STATE_ESTABLISHED || tcb->state == FSM_STATE_FIN_WAIT_1 ||\n                tcb->state == FSM_STATE_FIN_WAIT_2) {\n                /* Search for begin of payload */\n                LL_SEARCH_SCALAR(in_pkt, snp, type, GNRC_NETTYPE_UNDEF);\n\n                /* Accept only data that is expected, to be received */\n                if (tcb->rcv_nxt == seg_seq) {\n                    /* Copy contents into receive buffer */\n                    while (snp && snp->type == GNRC_NETTYPE_UNDEF) {\n                        tcb->rcv_nxt += ringbuffer_add(&(tcb->rcv_buf), snp->data, snp->size);\n                        snp = snp->next;\n                    }\n                    /* Shrink receive window */\n                    tcb->rcv_wnd = ringbuffer_get_free(&(tcb->rcv_buf));\n                    /* Notify owner because new data is available */\n                    tcb->status |= STATUS_NOTIFY_USER;\n                }\n                /* Send ACK, if FIN processing sends ACK already */\n                /* NOTE: this is the place to add payload piggybagging in the future */\n                if (!(ctl & MSK_FIN)) {\n                    _pkt_build(tcb, &out_pkt, &seq_con, MSK_ACK, tcb->snd_nxt, tcb->rcv_nxt,\n                               NULL, 0);\n                    _pkt_send(tcb, out_pkt, seq_con, false);\n                }\n            }\n        }\n        /* 7) Check FIN */\n        if (ctl & MSK_FIN) {\n            if (tcb->state == FSM_STATE_CLOSED || tcb->state == FSM_STATE_LISTEN ||\n                tcb->state == FSM_STATE_SYN_SENT) {\n                return 0;\n            }\n            /* Advance rcv_nxt over FIN bit */\n            tcb->rcv_nxt = seg_seq + seg_len;\n            _pkt_build(tcb, &out_pkt, &seq_con, MSK_ACK, tcb->snd_nxt, tcb->rcv_nxt, NULL, 0);\n            _pkt_send(tcb, out_pkt, seq_con, false);\n\n            if (tcb->state == FSM_STATE_SYN_RCVD || tcb->state == FSM_STATE_ESTABLISHED) {\n                _transition_to(tcb, FSM_STATE_CLOSE_WAIT);\n            }\n            else if (tcb->state == FSM_STATE_FIN_WAIT_1) {\n                if (tcb->pkt_retransmit == NULL) {\n                    _transition_to(tcb, FSM_STATE_TIME_WAIT);\n                }\n                else {\n                    _transition_to(tcb, FSM_STATE_CLOSING);\n                }\n            }\n            else if (tcb->state == FSM_STATE_FIN_WAIT_2) {\n                _transition_to(tcb, FSM_STATE_TIME_WAIT);\n            }\n            else if (tcb->state == FSM_STATE_TIME_WAIT) {\n                _restart_timewait_timer(tcb);\n            }\n        }\n    }\n    return 0;\n}\n"", ""caller_start"": 395, ""file_path"": ""sys/net/gnrc/transport_layer/tcp/gnrc_tcp_fsm.c""}]}, {""source"": ""code_info(file:gnrc_tcp_option.c, lines:64-75)"", ""result"": ""                DEBUG(\""gnrc_tcp_option.c : _option_parse() : Unknown option found.\\\n                      KIND=%\""PRIu8\"", LENGTH=%\""PRIu8\""\\n\"", option->kind, option->length);\n        }\n\n        if (option->length > opt_left) {\n            DEBUG(\""gnrc_tcp_option.c : _option_parse() : invalid option length\\n\"");\n            return 0;\n        }\n\n        opt_ptr += option->length;\n        opt_left -= option->length;\n    }\n""}, {""source"": ""code_info(file:gnrc_tcp_option.c, lines:50-63)"", ""result"": ""                opt_left -= 1;\n                continue;\n\n            case TCP_OPTION_KIND_MSS:\n                if (option->length != TCP_OPTION_LENGTH_MSS) {\n                    DEBUG(\""gnrc_tcp_option.c : _option_parse() : invalid MSS Option length.\\n\"");\n                    return -1;\n                }\n                tcb->mss = (option->value[0] << 8) | option->value[1];\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : MSS option found. MSS=%\""PRIu16\""\\n\"",\n                      tcb->mss);\n                break;\n\n            default:\n""}, {""source"": ""code_info(file:gnrc_tcp_option.c, lines:45-59)"", ""result"": ""                return 0;\n\n            case TCP_OPTION_KIND_NOP:\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : NOP option found\\n\"");\n                opt_ptr += 1;\n                opt_left -= 1;\n                continue;\n\n            case TCP_OPTION_KIND_MSS:\n                if (option->length != TCP_OPTION_LENGTH_MSS) {\n                    DEBUG(\""gnrc_tcp_option.c : _option_parse() : invalid MSS Option length.\\n\"");\n                    return -1;\n                }\n                tcb->mss = (option->value[0] << 8) | option->value[1];\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : MSS option found. MSS=%\""PRIu16\""\\n\"",\n""}, {""source"": ""code_info(file:gnrc_tcp_option.c, lines:40-50)"", ""result"": ""\n        /* Examine current option */\n        switch (option->kind) {\n            case TCP_OPTION_KIND_EOL:\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : EOL option found\\n\"");\n                return 0;\n\n            case TCP_OPTION_KIND_NOP:\n                DEBUG(\""gnrc_tcp_option.c : _option_parse() : NOP option found\\n\"");\n                opt_ptr += 1;\n                opt_left -= 1;\n""}, {""source"": ""code_info(file:gnrc_tcp_option.c, lines:30-40)"", ""result"": ""        return 0;\n    }\n\n    /* Get pointer to option field and field size */\n    uint8_t *opt_ptr = (uint8_t *) hdr + sizeof(tcp_hdr_t);\n    uint8_t opt_left = (offset - TCP_HDR_OFFSET_MIN) * 4;\n\n    /* Parse options via tcp_hdr_opt_t */\n    while (opt_left > 0) {\n        tcp_hdr_opt_t *option = (tcp_hdr_opt_t *) opt_ptr;\n\n""}]","In `sys/net/gnrc/transport_layer/tcp/gnrc_tcp_option.c`'s `_option_parse`, an infinite loop occurs when processing an unknown zero-length TCP option. The `default` case (lines 64-75) does not return or decrement `opt_left` (since `option->length == 0`), leaving the loop condition `while (opt_left > 0)` (lines 30-40) perpetually true. This is triggered by a malformed TCP packet parsed in `_fsm_rcvd_pkt` (lines 414-415, `gnrc_tcp_fsm.c`), which calls `_option_parse`. The patch adds `return -1` to terminate parsing and break the loop.",0.95,./github/other_context/CVE-2019-15702
49,CVE-2019-16163,CWE-674,c_cpp,Oniguruma before 6.9.3 allows Stack Exhaustion in regcomp.c because of recursion in regparse.c.,https://github.com/kkos/oniguruma/commit/4097828d7cc87589864fecf452f2cd46c5f37180,fix #147: Stack Exhaustion Problem caused by some parsing functions in regcomp.c making recursive calls to themselves.,2,"[{""func_name"": ""parse_exp"", ""file_path"": ""src/regparse.c"", ""func_code"": ""static int\nparse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,\n          ScanEnv* env, int group_head)\n{\n  int r, len, group = 0;\n  Node* qn;\n  Node** tp;\n\n  *np = NULL;\n  if (tok->type == (enum TokenSyms )term)\n    goto end_of_token;\n\n  switch (tok->type) {\n  case TK_ALT:\n  case TK_EOT:\n  end_of_token:\n    *np = node_new_empty();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    return tok->type;\n  break;\n\n  case TK_SUBEXP_OPEN:\n    r = parse_bag(np, tok, TK_SUBEXP_CLOSE, src, end, env);\n    if (r < 0) return r;\n    if (r == 1) { /* group */\n      if (group_head == 0)\n        group = 1;\n      else {\n        Node* target = *np;\n        *np = node_new_group(target);\n        if (IS_NULL(*np)) {\n          onig_node_free(target);\n          return ONIGERR_MEMORY;\n        }\n        group = 2;\n      }\n    }\n    else if (r == 2) { /* option only */\n      Node* target;\n      OnigOptionType prev = env->options;\n\n      env->options = BAG_(*np)->o.options;\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(&target, tok, term, src, end, env, 0);\n      env->options = prev;\n      if (r < 0) {\n        onig_node_free(target);\n        return r;\n      }\n      NODE_BODY(*np) = target;\n      return tok->type;\n    }\n    break;\n\n  case TK_SUBEXP_CLOSE:\n    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))\n      return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;\n\n    if (tok->escaped) goto tk_raw_byte;\n    else goto tk_byte;\n    break;\n\n  case TK_STRING:\n  tk_byte:\n    {\n      *np = node_new_str(tok->backp, *src);\n      CHECK_NULL_RETURN_MEMERR(*np);\n\n      while (1) {\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_STRING) break;\n\n        r = onig_node_str_cat(*np, tok->backp, *src);\n        if (r < 0) return r;\n      }\n\n    string_end:\n      tp = np;\n      goto repeat;\n    }\n    break;\n\n  case TK_RAW_BYTE:\n  tk_raw_byte:\n    {\n      *np = node_new_str_raw_char((UChar )tok->u.c);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      len = 1;\n      while (1) {\n        if (len >= ONIGENC_MBC_MINLEN(env->enc)) {\n          if (len == enclen(env->enc, STR_(*np)->s)) {\n            r = fetch_token(tok, src, end, env);\n            goto tk_raw_byte_end;\n          }\n        }\n\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_RAW_BYTE)\n          return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\n        r = node_str_cat_char(*np, (UChar )tok->u.c);\n        if (r < 0) return r;\n\n        len++;\n      }\n\n    tk_raw_byte_end:\n      if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, STR_(*np)->s, STR_(*np)->end))\n        return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n      NODE_STRING_CLEAR_RAW(*np);\n      goto string_end;\n    }\n    break;\n\n  case TK_CODE_POINT:\n    {\n      UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n      len = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);\n      if (len < 0) return len;\n#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n      *np = node_new_str_raw(buf, buf + len);\n#else\n      *np = node_new_str(buf, buf + len);\n#endif\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_QUOTE_OPEN:\n    {\n      OnigCodePoint end_op[2];\n      UChar *qstart, *qend, *nextp;\n\n      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);\n      end_op[1] = (OnigCodePoint )'E';\n      qstart = *src;\n      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);\n      if (IS_NULL(qend)) {\n        nextp = qend = end;\n      }\n      *np = node_new_str(qstart, qend);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      *src = nextp;\n    }\n    break;\n\n  case TK_CHAR_TYPE:\n    {\n      switch (tok->u.prop.ctype) {\n      case ONIGENC_CTYPE_WORD:\n        *np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not, env->options);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        break;\n\n      case ONIGENC_CTYPE_SPACE:\n      case ONIGENC_CTYPE_DIGIT:\n      case ONIGENC_CTYPE_XDIGIT:\n        {\n          CClassNode* cc;\n\n          *np = node_new_cclass();\n          CHECK_NULL_RETURN_MEMERR(*np);\n          cc = CCLASS_(*np);\n          add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);\n          if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n        }\n        break;\n\n      default:\n        return ONIGERR_PARSER_BUG;\n        break;\n      }\n    }\n    break;\n\n  case TK_CHAR_PROPERTY:\n    r = parse_char_property(np, tok, src, end, env);\n    if (r != 0) return r;\n    break;\n\n  case TK_CC_OPEN:\n    {\n      CClassNode* cc;\n\n      r = parse_char_class(np, tok, src, end, env);\n      if (r != 0) return r;\n\n      cc = CCLASS_(*np);\n      if (IS_IGNORECASE(env->options)) {\n        IApplyCaseFoldArg iarg;\n\n        iarg.env      = env;\n        iarg.cc       = cc;\n        iarg.alt_root = NULL_NODE;\n        iarg.ptail    = &(iarg.alt_root);\n\n        r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,\n                                        i_apply_case_fold, &iarg);\n        if (r != 0) {\n          onig_node_free(iarg.alt_root);\n          return r;\n        }\n        if (IS_NOT_NULL(iarg.alt_root)) {\n          Node* work = onig_node_new_alt(*np, iarg.alt_root);\n          if (IS_NULL(work)) {\n            onig_node_free(iarg.alt_root);\n            return ONIGERR_MEMORY;\n          }\n          *np = work;\n        }\n      }\n    }\n    break;\n\n  case TK_ANYCHAR:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_ANYCHAR_ANYTIME:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    qn = node_new_quantifier(0, INFINITE_REPEAT, 0);\n    CHECK_NULL_RETURN_MEMERR(qn);\n    NODE_BODY(qn) = *np;\n    *np = qn;\n    break;\n\n  case TK_BACKREF:\n    len = tok->u.backref.num;\n    *np = node_new_backref(len,\n                  (len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),\n                  tok->u.backref.by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                           tok->u.backref.exist_level,\n                           tok->u.backref.level,\n#endif\n                           env);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n#ifdef USE_CALL\n  case TK_CALL:\n    {\n      int gnum = tok->u.call.gnum;\n\n      *np = node_new_call(tok->u.call.name, tok->u.call.name_end,\n                          gnum, tok->u.call.by_number);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      env->num_call++;\n      if (tok->u.call.by_number != 0 && gnum == 0) {\n        env->has_call_zero = 1;\n      }\n    }\n    break;\n#endif\n\n  case TK_ANCHOR:\n    {\n      int ascii_mode =\n        IS_WORD_ASCII(env->options) && IS_WORD_ANCHOR_TYPE(tok->u.anchor) ? 1 : 0;\n      *np = onig_node_new_anchor(tok->u.anchor, ascii_mode);\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_REPEAT:\n  case TK_INTERVAL:\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {\n      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;\n      else {\n        *np = node_new_empty();\n        CHECK_NULL_RETURN_MEMERR(*np);\n      }\n    }\n    else {\n      goto tk_byte;\n    }\n    break;\n\n  case TK_KEEP:\n    r = node_new_keep(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_GENERAL_NEWLINE:\n    r = node_new_general_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_NO_NEWLINE:\n    r = node_new_no_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TRUE_ANYCHAR:\n    r = node_new_true_anychar(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TEXT_SEGMENT:\n    r = make_text_segment(np, env);\n    if (r < 0) return r;\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  {\n    tp = np;\n\n  re_entry:\n    r = fetch_token(tok, src, end, env);\n    if (r < 0) return r;\n\n  repeat:\n    if (r == TK_REPEAT || r == TK_INTERVAL) {\n      Node* target;\n\n      if (is_invalid_quantifier_target(*tp))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;\n\n      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,\n                               r == TK_INTERVAL);\n      CHECK_NULL_RETURN_MEMERR(qn);\n      QUANT_(qn)->greedy = tok->u.repeat.greedy;\n      if (group == 2) {\n        target = node_drop_group(*tp);\n        *tp = NULL_NODE;\n      }\n      else {\n        target = *tp;\n      }\n      r = set_quantifier(qn, target, group, env);\n      if (r < 0) {\n        onig_node_free(qn);\n        return r;\n      }\n\n      if (tok->u.repeat.possessive != 0) {\n        Node* en;\n        en = node_new_bag(BAG_STOP_BACKTRACK);\n        if (IS_NULL(en)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        NODE_BODY(en) = qn;\n        qn = en;\n      }\n\n      if (r == 0) {\n        *tp = qn;\n      }\n      else if (r == 1) { /* x{1,1} ==> x */\n        onig_node_free(qn);\n        *tp = target;\n      }\n      else if (r == 2) { /* split case: /abc+/ */\n        Node *tmp;\n\n        *tp = node_new_list(*tp, NULL);\n        if (IS_NULL(*tp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tmp = NODE_CDR(*tp) = node_new_list(qn, NULL);\n        if (IS_NULL(tmp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tp = &(NODE_CAR(tmp));\n      }\n      group = 0;\n      goto re_entry;\n    }\n  }\n\n  return r;\n}"", ""target"": 0}, {""func_name"": ""parse_char_class"", ""file_path"": ""src/regparse.c"", ""func_code"": ""static int\nparse_char_class(Node** np, PToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, neg, len, fetched, and_start;\n  OnigCodePoint v, vs;\n  UChar *p;\n  Node* node;\n  CClassNode *cc, *prev_cc;\n  CClassNode work_cc;\n\n  enum CCSTATE state;\n  enum CCVALTYPE val_type, in_type;\n  int val_israw, in_israw;\n\n  *np = NULL_NODE;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n  prev_cc = (CClassNode* )NULL;\n  r = fetch_token_in_cc(tok, src, end, env);\n  if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {\n    neg = 1;\n    r = fetch_token_in_cc(tok, src, end, env);\n  }\n  else {\n    neg = 0;\n  }\n\n  if (r < 0) return r;\n  if (r == TK_CC_CLOSE) {\n    if (! code_exist_check((OnigCodePoint )']',\n                           *src, env->pattern_end, 1, env))\n      return ONIGERR_EMPTY_CHAR_CLASS;\n\n    CC_ESC_WARN(env, (UChar* )\""]\"");\n    r = tok->type = TK_CHAR;  /* allow []...] */\n  }\n\n  *np = node = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(node);\n  cc = CCLASS_(node);\n\n  and_start = 0;\n  state = CCS_START;\n  p = *src;\n  while (r != TK_CC_CLOSE) {\n    fetched = 0;\n    switch (r) {\n    case TK_CHAR:\n    any_char_in:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c);\n      if (len > 1) {\n        in_type = CCV_CODE_POINT;\n      }\n      else if (len < 0) {\n        r = len;\n        goto err;\n      }\n      else {\n        /* sb_char: */\n        in_type = CCV_SB;\n      }\n      v = (OnigCodePoint )tok->u.c;\n      in_israw = 0;\n      goto val_entry2;\n      break;\n\n    case TK_RAW_BYTE:\n      /* tok->base != 0 : octal or hexadec. */\n      if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {\n        int i, j;\n        UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n        UChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;\n        UChar* psave = p;\n        int base = tok->base;\n\n        buf[0] = tok->u.c;\n        for (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {\n          r = fetch_token_in_cc(tok, &p, end, env);\n          if (r < 0) goto err;\n          if (r != TK_RAW_BYTE || tok->base != base) {\n            fetched = 1;\n            break;\n          }\n          buf[i] = tok->u.c;\n        }\n\n        if (i < ONIGENC_MBC_MINLEN(env->enc)) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n\n        /* clear buf tail */\n        for (j = i; j < ONIGENC_CODE_TO_MBC_MAXLEN; j++) buf[j] = '\\0';\n\n        len = enclen(env->enc, buf);\n        if (i < len) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n        else if (i > len) { /* fetch back */\n          p = psave;\n          for (i = 1; i < len; i++) {\n            r = fetch_token_in_cc(tok, &p, end, env);\n          }\n          fetched = 0;\n        }\n\n        if (i == 1) {\n          v = (OnigCodePoint )buf[0];\n          goto raw_single;\n        }\n        else {\n          v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);\n          in_type = CCV_CODE_POINT;\n        }\n      }\n      else {\n        v = (OnigCodePoint )tok->u.c;\n      raw_single:\n        in_type = CCV_SB;\n      }\n      in_israw = 1;\n      goto val_entry2;\n      break;\n\n    case TK_CODE_POINT:\n      v = tok->u.code;\n      in_israw = 1;\n    val_entry:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);\n      if (len < 0) {\n        r = len;\n        goto err;\n      }\n      in_type = (len == 1 ? CCV_SB : CCV_CODE_POINT);\n    val_entry2:\n      r = next_state_val(cc, &vs, v, &val_israw, in_israw, in_type, &val_type,\n                         &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_POSIX_BRACKET_OPEN:\n      r = parse_posix_bracket(cc, &p, end, env);\n      if (r < 0) goto err;\n      if (r == 1) {  /* is not POSIX bracket */\n        CC_ESC_WARN(env, (UChar* )\""[\"");\n        p = tok->backp;\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n        goto val_entry;\n      }\n      goto next_class;\n      break;\n\n    case TK_CHAR_TYPE:\n      r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not, env);\n      if (r != 0) goto err;\n\n    next_class:\n      r = next_state_class(cc, &vs, &val_type, &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_CHAR_PROPERTY:\n      {\n        int ctype = fetch_char_property_to_ctype(&p, end, env);\n        if (ctype < 0) {\n          r = ctype;\n          goto err;\n        }\n        r = add_ctype_to_cc(cc, ctype, tok->u.prop.not, env);\n        if (r != 0) goto err;\n        goto next_class;\n      }\n      break;\n\n    case TK_CC_RANGE:\n      if (state == CCS_VALUE) {\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) { /* allow [x-] */\n        range_end_val:\n          v = (OnigCodePoint )'-';\n          in_israw = 0;\n          goto val_entry;\n        }\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\""-\"");\n          goto range_end_val;\n        }\n\n        if (val_type == CCV_CLASS) {\n          r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n          goto err;\n        }\n\n        state = CCS_RANGE;\n      }\n      else if (state == CCS_START) {\n        /* [-xa] is allowed */\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        /* [--x] or [a&&-x] is warned. */\n        if (r == TK_CC_RANGE || and_start != 0)\n          CC_ESC_WARN(env, (UChar* )\""-\"");\n\n        goto val_entry;\n      }\n      else if (state == CCS_RANGE) {\n        CC_ESC_WARN(env, (UChar* )\""-\"");\n        goto any_char_in;  /* [!--x] is allowed */\n      }\n      else { /* CCS_COMPLETE */\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) goto range_end_val; /* allow [a-b-] */\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\""-\"");\n          goto range_end_val;\n        }\n\n        if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {\n          CC_ESC_WARN(env, (UChar* )\""-\"");\n          goto range_end_val;   /* [0-9-a] is allowed as [0-9\\-a] */\n        }\n        r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n        goto err;\n      }\n      break;\n\n    case TK_CC_CC_OPEN: /* [ */\n      {\n        Node *anode;\n        CClassNode* acc;\n\n        r = parse_char_class(&anode, tok, &p, end, env);\n        if (r != 0) {\n          onig_node_free(anode);\n          goto cc_open_err;\n        }\n        acc = CCLASS_(anode);\n        r = or_cclass(cc, acc, env->enc);\n        onig_node_free(anode);\n\n      cc_open_err:\n        if (r != 0) goto err;\n      }\n      break;\n\n    case TK_CC_AND: /* && */\n      {\n        if (state == CCS_VALUE) {\n          r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n                             &val_type, &state, env);\n          if (r != 0) goto err;\n        }\n        /* initialize local variables */\n        and_start = 1;\n        state = CCS_START;\n\n        if (IS_NOT_NULL(prev_cc)) {\n          r = and_cclass(prev_cc, cc, env->enc);\n          if (r != 0) goto err;\n          bbuf_free(cc->mbuf);\n        }\n        else {\n          prev_cc = cc;\n          cc = &work_cc;\n        }\n        initialize_cclass(cc);\n      }\n      break;\n\n    case TK_EOT:\n      r = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;\n      goto err;\n      break;\n    default:\n      r = ONIGERR_PARSER_BUG;\n      goto err;\n      break;\n    }\n\n    if (fetched)\n      r = tok->type;\n    else {\n      r = fetch_token_in_cc(tok, &p, end, env);\n      if (r < 0) goto err;\n    }\n  }\n\n  if (state == CCS_VALUE) {\n    r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n                       &val_type, &state, env);\n    if (r != 0) goto err;\n  }\n\n  if (IS_NOT_NULL(prev_cc)) {\n    r = and_cclass(prev_cc, cc, env->enc);\n    if (r != 0) goto err;\n    bbuf_free(cc->mbuf);\n    cc = prev_cc;\n  }\n\n  if (neg != 0)\n    NCCLASS_SET_NOT(cc);\n  else\n    NCCLASS_CLEAR_NOT(cc);\n  if (IS_NCCLASS_NOT(cc) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {\n    int is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);\n    if (is_empty != 0)\n      BITSET_IS_EMPTY(cc->bs, is_empty);\n\n    if (is_empty == 0) {\n#define NEWLINE_CODE    0x0a\n\n      if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {\n        if (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)\n          BITSET_SET_BIT(cc->bs, NEWLINE_CODE);\n        else\n          add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);\n      }\n    }\n  }\n  *src = p;\n  env->parse_depth--;\n  return 0;\n\n err:\n  if (cc != CCLASS_(*np))\n    bbuf_free(cc->mbuf);\n  return r;\n}"", ""target"": 0}]","[{""func_name"": ""parse_exp"", ""file_path"": ""src/regparse.c"", ""func_code"": ""static int\nparse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,\n          ScanEnv* env, int group_head)\n{\n  int r, len, group;\n  Node* qn;\n  Node** tp;\n  unsigned int parse_depth;\n\n  group = 0;\n  *np = NULL;\n  if (tok->type == (enum TokenSyms )term)\n    goto end_of_token;\n\n  parse_depth = env->parse_depth;\n\n  switch (tok->type) {\n  case TK_ALT:\n  case TK_EOT:\n  end_of_token:\n    *np = node_new_empty();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    return tok->type;\n  break;\n\n  case TK_SUBEXP_OPEN:\n    r = parse_bag(np, tok, TK_SUBEXP_CLOSE, src, end, env);\n    if (r < 0) return r;\n    if (r == 1) { /* group */\n      if (group_head == 0)\n        group = 1;\n      else {\n        Node* target = *np;\n        *np = node_new_group(target);\n        if (IS_NULL(*np)) {\n          onig_node_free(target);\n          return ONIGERR_MEMORY;\n        }\n        group = 2;\n      }\n    }\n    else if (r == 2) { /* option only */\n      Node* target;\n      OnigOptionType prev = env->options;\n\n      env->options = BAG_(*np)->o.options;\n      r = fetch_token(tok, src, end, env);\n      if (r < 0) return r;\n      r = parse_subexp(&target, tok, term, src, end, env, 0);\n      env->options = prev;\n      if (r < 0) {\n        onig_node_free(target);\n        return r;\n      }\n      NODE_BODY(*np) = target;\n      return tok->type;\n    }\n    break;\n\n  case TK_SUBEXP_CLOSE:\n    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))\n      return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;\n\n    if (tok->escaped) goto tk_raw_byte;\n    else goto tk_byte;\n    break;\n\n  case TK_STRING:\n  tk_byte:\n    {\n      *np = node_new_str(tok->backp, *src);\n      CHECK_NULL_RETURN_MEMERR(*np);\n\n      while (1) {\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_STRING) break;\n\n        r = onig_node_str_cat(*np, tok->backp, *src);\n        if (r < 0) return r;\n      }\n\n    string_end:\n      tp = np;\n      goto repeat;\n    }\n    break;\n\n  case TK_RAW_BYTE:\n  tk_raw_byte:\n    {\n      *np = node_new_str_raw_char((UChar )tok->u.c);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      len = 1;\n      while (1) {\n        if (len >= ONIGENC_MBC_MINLEN(env->enc)) {\n          if (len == enclen(env->enc, STR_(*np)->s)) {\n            r = fetch_token(tok, src, end, env);\n            goto tk_raw_byte_end;\n          }\n        }\n\n        r = fetch_token(tok, src, end, env);\n        if (r < 0) return r;\n        if (r != TK_RAW_BYTE)\n          return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n\n        r = node_str_cat_char(*np, (UChar )tok->u.c);\n        if (r < 0) return r;\n\n        len++;\n      }\n\n    tk_raw_byte_end:\n      if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, STR_(*np)->s, STR_(*np)->end))\n        return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n      NODE_STRING_CLEAR_RAW(*np);\n      goto string_end;\n    }\n    break;\n\n  case TK_CODE_POINT:\n    {\n      UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n      len = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);\n      if (len < 0) return len;\n#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG\n      *np = node_new_str_raw(buf, buf + len);\n#else\n      *np = node_new_str(buf, buf + len);\n#endif\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_QUOTE_OPEN:\n    {\n      OnigCodePoint end_op[2];\n      UChar *qstart, *qend, *nextp;\n\n      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);\n      end_op[1] = (OnigCodePoint )'E';\n      qstart = *src;\n      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);\n      if (IS_NULL(qend)) {\n        nextp = qend = end;\n      }\n      *np = node_new_str(qstart, qend);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      *src = nextp;\n    }\n    break;\n\n  case TK_CHAR_TYPE:\n    {\n      switch (tok->u.prop.ctype) {\n      case ONIGENC_CTYPE_WORD:\n        *np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not, env->options);\n        CHECK_NULL_RETURN_MEMERR(*np);\n        break;\n\n      case ONIGENC_CTYPE_SPACE:\n      case ONIGENC_CTYPE_DIGIT:\n      case ONIGENC_CTYPE_XDIGIT:\n        {\n          CClassNode* cc;\n\n          *np = node_new_cclass();\n          CHECK_NULL_RETURN_MEMERR(*np);\n          cc = CCLASS_(*np);\n          add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);\n          if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n        }\n        break;\n\n      default:\n        return ONIGERR_PARSER_BUG;\n        break;\n      }\n    }\n    break;\n\n  case TK_CHAR_PROPERTY:\n    r = parse_char_property(np, tok, src, end, env);\n    if (r != 0) return r;\n    break;\n\n  case TK_CC_OPEN:\n    {\n      CClassNode* cc;\n\n      r = parse_char_class(np, tok, src, end, env);\n      if (r != 0) return r;\n\n      cc = CCLASS_(*np);\n      if (IS_IGNORECASE(env->options)) {\n        IApplyCaseFoldArg iarg;\n\n        iarg.env      = env;\n        iarg.cc       = cc;\n        iarg.alt_root = NULL_NODE;\n        iarg.ptail    = &(iarg.alt_root);\n\n        r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,\n                                        i_apply_case_fold, &iarg);\n        if (r != 0) {\n          onig_node_free(iarg.alt_root);\n          return r;\n        }\n        if (IS_NOT_NULL(iarg.alt_root)) {\n          Node* work = onig_node_new_alt(*np, iarg.alt_root);\n          if (IS_NULL(work)) {\n            onig_node_free(iarg.alt_root);\n            return ONIGERR_MEMORY;\n          }\n          *np = work;\n        }\n      }\n    }\n    break;\n\n  case TK_ANYCHAR:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n  case TK_ANYCHAR_ANYTIME:\n    *np = node_new_anychar();\n    CHECK_NULL_RETURN_MEMERR(*np);\n    qn = node_new_quantifier(0, INFINITE_REPEAT, 0);\n    CHECK_NULL_RETURN_MEMERR(qn);\n    NODE_BODY(qn) = *np;\n    *np = qn;\n    break;\n\n  case TK_BACKREF:\n    len = tok->u.backref.num;\n    *np = node_new_backref(len,\n                  (len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),\n                  tok->u.backref.by_name,\n#ifdef USE_BACKREF_WITH_LEVEL\n                           tok->u.backref.exist_level,\n                           tok->u.backref.level,\n#endif\n                           env);\n    CHECK_NULL_RETURN_MEMERR(*np);\n    break;\n\n#ifdef USE_CALL\n  case TK_CALL:\n    {\n      int gnum = tok->u.call.gnum;\n\n      *np = node_new_call(tok->u.call.name, tok->u.call.name_end,\n                          gnum, tok->u.call.by_number);\n      CHECK_NULL_RETURN_MEMERR(*np);\n      env->num_call++;\n      if (tok->u.call.by_number != 0 && gnum == 0) {\n        env->has_call_zero = 1;\n      }\n    }\n    break;\n#endif\n\n  case TK_ANCHOR:\n    {\n      int ascii_mode =\n        IS_WORD_ASCII(env->options) && IS_WORD_ANCHOR_TYPE(tok->u.anchor) ? 1 : 0;\n      *np = onig_node_new_anchor(tok->u.anchor, ascii_mode);\n      CHECK_NULL_RETURN_MEMERR(*np);\n    }\n    break;\n\n  case TK_REPEAT:\n  case TK_INTERVAL:\n    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {\n      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;\n      else {\n        *np = node_new_empty();\n        CHECK_NULL_RETURN_MEMERR(*np);\n      }\n    }\n    else {\n      goto tk_byte;\n    }\n    break;\n\n  case TK_KEEP:\n    r = node_new_keep(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_GENERAL_NEWLINE:\n    r = node_new_general_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_NO_NEWLINE:\n    r = node_new_no_newline(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TRUE_ANYCHAR:\n    r = node_new_true_anychar(np, env);\n    if (r < 0) return r;\n    break;\n\n  case TK_TEXT_SEGMENT:\n    r = make_text_segment(np, env);\n    if (r < 0) return r;\n    break;\n\n  default:\n    return ONIGERR_PARSER_BUG;\n    break;\n  }\n\n  {\n    tp = np;\n\n  re_entry:\n    r = fetch_token(tok, src, end, env);\n    if (r < 0) return r;\n\n  repeat:\n    if (r == TK_REPEAT || r == TK_INTERVAL) {\n      Node* target;\n\n      if (is_invalid_quantifier_target(*tp))\n        return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;\n\n      parse_depth++;\n      if (parse_depth > ParseDepthLimit)\n        return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n\n      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,\n                               r == TK_INTERVAL);\n      CHECK_NULL_RETURN_MEMERR(qn);\n      QUANT_(qn)->greedy = tok->u.repeat.greedy;\n      if (group == 2) {\n        target = node_drop_group(*tp);\n        *tp = NULL_NODE;\n      }\n      else {\n        target = *tp;\n      }\n      r = set_quantifier(qn, target, group, env);\n      if (r < 0) {\n        onig_node_free(qn);\n        return r;\n      }\n\n      if (tok->u.repeat.possessive != 0) {\n        Node* en;\n        en = node_new_bag(BAG_STOP_BACKTRACK);\n        if (IS_NULL(en)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        NODE_BODY(en) = qn;\n        qn = en;\n      }\n\n      if (r == 0) {\n        *tp = qn;\n      }\n      else if (r == 1) { /* x{1,1} ==> x */\n        onig_node_free(qn);\n        *tp = target;\n      }\n      else if (r == 2) { /* split case: /abc+/ */\n        Node *tmp;\n\n        *tp = node_new_list(*tp, NULL);\n        if (IS_NULL(*tp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tmp = NODE_CDR(*tp) = node_new_list(qn, NULL);\n        if (IS_NULL(tmp)) {\n          onig_node_free(qn);\n          return ONIGERR_MEMORY;\n        }\n        tp = &(NODE_CAR(tmp));\n      }\n      group = 0;\n      goto re_entry;\n    }\n  }\n\n  return r;\n}""}, {""func_name"": ""parse_char_class"", ""file_path"": ""src/regparse.c"", ""func_code"": ""static int\nparse_char_class(Node** np, PToken* tok, UChar** src, UChar* end, ScanEnv* env)\n{\n  int r, neg, len, fetched, and_start;\n  OnigCodePoint v, vs;\n  UChar *p;\n  Node* node;\n  CClassNode *cc, *prev_cc;\n  CClassNode work_cc;\n\n  enum CCSTATE state;\n  enum CCVALTYPE val_type, in_type;\n  int val_israw, in_israw;\n\n  *np = NULL_NODE;\n  env->parse_depth++;\n  if (env->parse_depth > ParseDepthLimit)\n    return ONIGERR_PARSE_DEPTH_LIMIT_OVER;\n\n  prev_cc = (CClassNode* )NULL;\n  r = fetch_token_in_cc(tok, src, end, env);\n  if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {\n    neg = 1;\n    r = fetch_token_in_cc(tok, src, end, env);\n  }\n  else {\n    neg = 0;\n  }\n\n  if (r < 0) return r;\n  if (r == TK_CC_CLOSE) {\n    if (! code_exist_check((OnigCodePoint )']',\n                           *src, env->pattern_end, 1, env))\n      return ONIGERR_EMPTY_CHAR_CLASS;\n\n    CC_ESC_WARN(env, (UChar* )\""]\"");\n    r = tok->type = TK_CHAR;  /* allow []...] */\n  }\n\n  *np = node = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(node);\n  cc = CCLASS_(node);\n\n  and_start = 0;\n  state = CCS_START;\n  p = *src;\n  while (r != TK_CC_CLOSE) {\n    fetched = 0;\n    switch (r) {\n    case TK_CHAR:\n    any_char_in:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c);\n      if (len > 1) {\n        in_type = CCV_CODE_POINT;\n      }\n      else if (len < 0) {\n        r = len;\n        goto err;\n      }\n      else {\n        /* sb_char: */\n        in_type = CCV_SB;\n      }\n      v = (OnigCodePoint )tok->u.c;\n      in_israw = 0;\n      goto val_entry2;\n      break;\n\n    case TK_RAW_BYTE:\n      /* tok->base != 0 : octal or hexadec. */\n      if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {\n        int i, j;\n        UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n        UChar* bufe = buf + ONIGENC_CODE_TO_MBC_MAXLEN;\n        UChar* psave = p;\n        int base = tok->base;\n\n        buf[0] = tok->u.c;\n        for (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {\n          r = fetch_token_in_cc(tok, &p, end, env);\n          if (r < 0) goto err;\n          if (r != TK_RAW_BYTE || tok->base != base) {\n            fetched = 1;\n            break;\n          }\n          buf[i] = tok->u.c;\n        }\n\n        if (i < ONIGENC_MBC_MINLEN(env->enc)) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n\n        /* clear buf tail */\n        for (j = i; j < ONIGENC_CODE_TO_MBC_MAXLEN; j++) buf[j] = '\\0';\n\n        len = enclen(env->enc, buf);\n        if (i < len) {\n          r = ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;\n          goto err;\n        }\n        else if (i > len) { /* fetch back */\n          p = psave;\n          for (i = 1; i < len; i++) {\n            r = fetch_token_in_cc(tok, &p, end, env);\n          }\n          fetched = 0;\n        }\n\n        if (i == 1) {\n          v = (OnigCodePoint )buf[0];\n          goto raw_single;\n        }\n        else {\n          v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);\n          in_type = CCV_CODE_POINT;\n        }\n      }\n      else {\n        v = (OnigCodePoint )tok->u.c;\n      raw_single:\n        in_type = CCV_SB;\n      }\n      in_israw = 1;\n      goto val_entry2;\n      break;\n\n    case TK_CODE_POINT:\n      v = tok->u.code;\n      in_israw = 1;\n    val_entry:\n      len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);\n      if (len < 0) {\n        r = len;\n        goto err;\n      }\n      in_type = (len == 1 ? CCV_SB : CCV_CODE_POINT);\n    val_entry2:\n      r = next_state_val(cc, &vs, v, &val_israw, in_israw, in_type, &val_type,\n                         &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_POSIX_BRACKET_OPEN:\n      r = parse_posix_bracket(cc, &p, end, env);\n      if (r < 0) goto err;\n      if (r == 1) {  /* is not POSIX bracket */\n        CC_ESC_WARN(env, (UChar* )\""[\"");\n        p = tok->backp;\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n        goto val_entry;\n      }\n      goto next_class;\n      break;\n\n    case TK_CHAR_TYPE:\n      r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not, env);\n      if (r != 0) goto err;\n\n    next_class:\n      r = next_state_class(cc, &vs, &val_type, &state, env);\n      if (r != 0) goto err;\n      break;\n\n    case TK_CHAR_PROPERTY:\n      {\n        int ctype = fetch_char_property_to_ctype(&p, end, env);\n        if (ctype < 0) {\n          r = ctype;\n          goto err;\n        }\n        r = add_ctype_to_cc(cc, ctype, tok->u.prop.not, env);\n        if (r != 0) goto err;\n        goto next_class;\n      }\n      break;\n\n    case TK_CC_RANGE:\n      if (state == CCS_VALUE) {\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) { /* allow [x-] */\n        range_end_val:\n          v = (OnigCodePoint )'-';\n          in_israw = 0;\n          goto val_entry;\n        }\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\""-\"");\n          goto range_end_val;\n        }\n\n        if (val_type == CCV_CLASS) {\n          r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n          goto err;\n        }\n\n        state = CCS_RANGE;\n      }\n      else if (state == CCS_START) {\n        /* [-xa] is allowed */\n        v = (OnigCodePoint )tok->u.c;\n        in_israw = 0;\n\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        /* [--x] or [a&&-x] is warned. */\n        if (r == TK_CC_RANGE || and_start != 0)\n          CC_ESC_WARN(env, (UChar* )\""-\"");\n\n        goto val_entry;\n      }\n      else if (state == CCS_RANGE) {\n        CC_ESC_WARN(env, (UChar* )\""-\"");\n        goto any_char_in;  /* [!--x] is allowed */\n      }\n      else { /* CCS_COMPLETE */\n        r = fetch_token_in_cc(tok, &p, end, env);\n        if (r < 0) goto err;\n        fetched = 1;\n        if (r == TK_CC_CLOSE) goto range_end_val; /* allow [a-b-] */\n        else if (r == TK_CC_AND) {\n          CC_ESC_WARN(env, (UChar* )\""-\"");\n          goto range_end_val;\n        }\n\n        if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {\n          CC_ESC_WARN(env, (UChar* )\""-\"");\n          goto range_end_val;   /* [0-9-a] is allowed as [0-9\\-a] */\n        }\n        r = ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS;\n        goto err;\n      }\n      break;\n\n    case TK_CC_CC_OPEN: /* [ */\n      {\n        Node *anode;\n        CClassNode* acc;\n\n        r = parse_char_class(&anode, tok, &p, end, env);\n        if (r != 0) {\n          onig_node_free(anode);\n          goto cc_open_err;\n        }\n        acc = CCLASS_(anode);\n        r = or_cclass(cc, acc, env->enc);\n        onig_node_free(anode);\n\n      cc_open_err:\n        if (r != 0) goto err;\n      }\n      break;\n\n    case TK_CC_AND: /* && */\n      {\n        if (state == CCS_VALUE) {\n          r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n                             &val_type, &state, env);\n          if (r != 0) goto err;\n        }\n        /* initialize local variables */\n        and_start = 1;\n        state = CCS_START;\n\n        if (IS_NOT_NULL(prev_cc)) {\n          r = and_cclass(prev_cc, cc, env->enc);\n          if (r != 0) goto err;\n          bbuf_free(cc->mbuf);\n        }\n        else {\n          prev_cc = cc;\n          cc = &work_cc;\n        }\n        initialize_cclass(cc);\n      }\n      break;\n\n    case TK_EOT:\n      r = ONIGERR_PREMATURE_END_OF_CHAR_CLASS;\n      goto err;\n      break;\n    default:\n      r = ONIGERR_PARSER_BUG;\n      goto err;\n      break;\n    }\n\n    if (fetched)\n      r = tok->type;\n    else {\n      r = fetch_token_in_cc(tok, &p, end, env);\n      if (r < 0) goto err;\n    }\n  }\n\n  if (state == CCS_VALUE) {\n    r = next_state_val(cc, &vs, 0, &val_israw, 0, val_type,\n                       &val_type, &state, env);\n    if (r != 0) goto err;\n  }\n\n  if (IS_NOT_NULL(prev_cc)) {\n    r = and_cclass(prev_cc, cc, env->enc);\n    if (r != 0) goto err;\n    bbuf_free(cc->mbuf);\n    cc = prev_cc;\n  }\n\n  if (neg != 0)\n    NCCLASS_SET_NOT(cc);\n  else\n    NCCLASS_CLEAR_NOT(cc);\n  if (IS_NCCLASS_NOT(cc) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {\n    int is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);\n    if (is_empty != 0)\n      BITSET_IS_EMPTY(cc->bs, is_empty);\n\n    if (is_empty == 0) {\n#define NEWLINE_CODE    0x0a\n\n      if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {\n        if (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)\n          BITSET_SET_BIT(cc->bs, NEWLINE_CODE);\n        else\n          add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);\n      }\n    }\n  }\n  *src = p;\n  env->parse_depth--;\n  return 0;\n\n err:\n  if (cc != CCLASS_(*np))\n    bbuf_free(cc->mbuf);\n  return r;\n}""}]","{""value"": 2}","[{""source"": ""value_info(file:regparse.c, value:ParseDepthLimit)"", ""result"": {""value_trace"": [{""full_code"": ""ParseDepthLimit = DEFAULT_PARSE_DEPTH_LIMIT"", ""line"": 183, ""func_name"": ""src/regparse.c:<global>""}], ""struct_var"": ""ParseDepthLimit"", ""struct_type"": ""unsigned int"", ""struct_definition"": ""unsigned int""}}, {""source"": ""value_info(file:regparse.c, value:parse_depth)"", ""result"": {""value_trace"": [{""full_code"": ""env->parse_depth         = 0"", ""line"": 1962, ""func_name"": ""scan_env_clear""}, {""full_code"": ""env->parse_depth++"", ""line"": 6239, ""func_name"": ""parse_char_class""}, {""full_code"": ""env->parse_depth++"", ""line"": 8262, ""func_name"": ""parse_subexp""}], ""struct_var"": ""parse_depth"", ""struct_type"": null, ""struct_definition"": null}}]","Recursive functions in regparse.c (parse_exp:7821-8150, parse_char_class:6240-6247) lacked recursion depth tracking. Before the patch, these functions made recursive calls without limiting stack depth. The fix adds parse_depth tracking via ScanEnv->parse_depth (initialized to 0 in scan_env_clear:1962), which is incremented before recursive operations (parse_char_class:6239, parse_exp:8150). If parse_depth exceeds ParseDepthLimit (defined as DEFAULT_PARSE_DEPTH_LIMIT in regparse.c:183), recursion terminates with an error.",0.95,./github/other_context/CVE-2019-16163
50,CVE-2019-18936,CWE-674,c_cpp,UniValue::read() in UniValue before 1.0.5 allow attackers to cause a denial of service (the class internal data reaches an inconsistent state) via input data that triggers an error.,https://github.com/jgarzik/univalue/commit/07aa635c034f3a2accfe4e20a8148c366bccf5bf,"UniValue::read(): Clear internal state upon error\n\nAvoid parsing edge cases that leave the class internal data in an\ninconsistent state, when the parser encounters an input data error.\n\nThis is a rewrite of PR #39 by @awemany.",1,"[{""func_name"": ""UniValue::read"", ""file_path"": ""lib/univalue_read.cpp"", ""func_code"": ""bool UniValue::read(const char *raw, size_t size)\n{\n    clear();\n\n    uint32_t expectMask = 0;\n    std::vector<UniValue*> stack;\n\n    std::string tokenVal;\n    unsigned int consumed;\n    enum jtokentype tok = JTOK_NONE;\n    enum jtokentype last_tok = JTOK_NONE;\n    const char* end = raw + size;\n    do {\n        last_tok = tok;\n\n        tok = getJsonToken(tokenVal, consumed, raw, end);\n        if (tok == JTOK_NONE || tok == JTOK_ERR)\n            return false;\n        raw += consumed;\n\n        bool isValueOpen = jsonTokenIsValue(tok) ||\n            tok == JTOK_OBJ_OPEN || tok == JTOK_ARR_OPEN;\n\n        if (expect(VALUE)) {\n            if (!isValueOpen)\n                return false;\n            clearExpect(VALUE);\n\n        } else if (expect(ARR_VALUE)) {\n            bool isArrValue = isValueOpen || (tok == JTOK_ARR_CLOSE);\n            if (!isArrValue)\n                return false;\n\n            clearExpect(ARR_VALUE);\n\n        } else if (expect(OBJ_NAME)) {\n            bool isObjName = (tok == JTOK_OBJ_CLOSE || tok == JTOK_STRING);\n            if (!isObjName)\n                return false;\n\n        } else if (expect(COLON)) {\n            if (tok != JTOK_COLON)\n                return false;\n            clearExpect(COLON);\n\n        } else if (!expect(COLON) && (tok == JTOK_COLON)) {\n            return false;\n        }\n\n        if (expect(NOT_VALUE)) {\n            if (isValueOpen)\n                return false;\n            clearExpect(NOT_VALUE);\n        }\n\n        switch (tok) {\n\n        case JTOK_OBJ_OPEN:\n        case JTOK_ARR_OPEN: {\n            VType utyp = (tok == JTOK_OBJ_OPEN ? VOBJ : VARR);\n            if (!stack.size()) {\n                if (utyp == VOBJ)\n                    setObject();\n                else\n                    setArray();\n                stack.push_back(this);\n            } else {\n                UniValue tmpVal(utyp);\n                UniValue *top = stack.back();\n                top->values.push_back(tmpVal);\n\n                UniValue *newTop = &(top->values.back());\n                stack.push_back(newTop);\n            }\n\n            if (utyp == VOBJ)\n                setExpect(OBJ_NAME);\n            else\n                setExpect(ARR_VALUE);\n            break;\n            }\n\n        case JTOK_OBJ_CLOSE:\n        case JTOK_ARR_CLOSE: {\n            if (!stack.size() || (last_tok == JTOK_COMMA))\n                return false;\n\n            VType utyp = (tok == JTOK_OBJ_CLOSE ? VOBJ : VARR);\n            UniValue *top = stack.back();\n            if (utyp != top->getType())\n                return false;\n\n            stack.pop_back();\n            clearExpect(OBJ_NAME);\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_COLON: {\n            if (!stack.size())\n                return false;\n\n            UniValue *top = stack.back();\n            if (top->getType() != VOBJ)\n                return false;\n\n            setExpect(VALUE);\n            break;\n            }\n\n        case JTOK_COMMA: {\n            if (!stack.size() ||\n                (last_tok == JTOK_COMMA) || (last_tok == JTOK_ARR_OPEN))\n                return false;\n\n            UniValue *top = stack.back();\n            if (top->getType() == VOBJ)\n                setExpect(OBJ_NAME);\n            else\n                setExpect(ARR_VALUE);\n            break;\n            }\n\n        case JTOK_KW_NULL:\n        case JTOK_KW_TRUE:\n        case JTOK_KW_FALSE: {\n            UniValue tmpVal;\n            switch (tok) {\n            case JTOK_KW_NULL:\n                // do nothing more\n                break;\n            case JTOK_KW_TRUE:\n                tmpVal.setBool(true);\n                break;\n            case JTOK_KW_FALSE:\n                tmpVal.setBool(false);\n                break;\n            default: /* impossible */ break;\n            }\n\n            if (!stack.size()) {\n                *this = tmpVal;\n                break;\n            }\n\n            UniValue *top = stack.back();\n            top->values.push_back(tmpVal);\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_NUMBER: {\n            UniValue tmpVal(VNUM, tokenVal);\n            if (!stack.size()) {\n                *this = tmpVal;\n                break;\n            }\n\n            UniValue *top = stack.back();\n            top->values.push_back(tmpVal);\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_STRING: {\n            if (expect(OBJ_NAME)) {\n                UniValue *top = stack.back();\n                top->keys.push_back(tokenVal);\n                clearExpect(OBJ_NAME);\n                setExpect(COLON);\n            } else {\n                UniValue tmpVal(VSTR, tokenVal);\n                if (!stack.size()) {\n                    *this = tmpVal;\n                    break;\n                }\n                UniValue *top = stack.back();\n                top->values.push_back(tmpVal);\n            }\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        default:\n            return false;\n        }\n    } while (!stack.empty ());\n\n    /* Check that nothing follows the initial construct (parsed above).  */\n    tok = getJsonToken(tokenVal, consumed, raw, end);\n    if (tok != JTOK_NONE)\n        return false;\n\n    return true;\n}"", ""target"": 0}]","[{""func_name"": ""UniValue::read"", ""file_path"": ""lib/univalue_read.cpp"", ""func_code"": ""bool UniValue::read(const char *raw, size_t size)\n{\n    clear();\n\n    uint32_t expectMask = 0;\n    std::vector<UniValue*> stack;\n\n    std::string tokenVal;\n    unsigned int consumed;\n    enum jtokentype tok = JTOK_NONE;\n    enum jtokentype last_tok = JTOK_NONE;\n    const char* end = raw + size;\n    do {\n        last_tok = tok;\n\n        tok = getJsonToken(tokenVal, consumed, raw, end);\n        if (tok == JTOK_NONE || tok == JTOK_ERR)\n            goto return_fail;\n        raw += consumed;\n\n        bool isValueOpen = jsonTokenIsValue(tok) ||\n            tok == JTOK_OBJ_OPEN || tok == JTOK_ARR_OPEN;\n\n        if (expect(VALUE)) {\n            if (!isValueOpen)\n                goto return_fail;\n            clearExpect(VALUE);\n\n        } else if (expect(ARR_VALUE)) {\n            bool isArrValue = isValueOpen || (tok == JTOK_ARR_CLOSE);\n            if (!isArrValue)\n                goto return_fail;\n\n            clearExpect(ARR_VALUE);\n\n        } else if (expect(OBJ_NAME)) {\n            bool isObjName = (tok == JTOK_OBJ_CLOSE || tok == JTOK_STRING);\n            if (!isObjName)\n                goto return_fail;\n\n        } else if (expect(COLON)) {\n            if (tok != JTOK_COLON)\n                goto return_fail;\n            clearExpect(COLON);\n\n        } else if (!expect(COLON) && (tok == JTOK_COLON)) {\n            goto return_fail;\n        }\n\n        if (expect(NOT_VALUE)) {\n            if (isValueOpen)\n                goto return_fail;\n            clearExpect(NOT_VALUE);\n        }\n\n        switch (tok) {\n\n        case JTOK_OBJ_OPEN:\n        case JTOK_ARR_OPEN: {\n            VType utyp = (tok == JTOK_OBJ_OPEN ? VOBJ : VARR);\n            if (!stack.size()) {\n                if (utyp == VOBJ)\n                    setObject();\n                else\n                    setArray();\n                stack.push_back(this);\n            } else {\n                UniValue tmpVal(utyp);\n                UniValue *top = stack.back();\n                top->values.push_back(tmpVal);\n\n                UniValue *newTop = &(top->values.back());\n                stack.push_back(newTop);\n            }\n\n            if (utyp == VOBJ)\n                setExpect(OBJ_NAME);\n            else\n                setExpect(ARR_VALUE);\n            break;\n            }\n\n        case JTOK_OBJ_CLOSE:\n        case JTOK_ARR_CLOSE: {\n            if (!stack.size() || (last_tok == JTOK_COMMA))\n                goto return_fail;\n\n            VType utyp = (tok == JTOK_OBJ_CLOSE ? VOBJ : VARR);\n            UniValue *top = stack.back();\n            if (utyp != top->getType())\n                goto return_fail;\n\n            stack.pop_back();\n            clearExpect(OBJ_NAME);\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_COLON: {\n            if (!stack.size())\n                goto return_fail;\n\n            UniValue *top = stack.back();\n            if (top->getType() != VOBJ)\n                goto return_fail;\n\n            setExpect(VALUE);\n            break;\n            }\n\n        case JTOK_COMMA: {\n            if (!stack.size() ||\n                (last_tok == JTOK_COMMA) || (last_tok == JTOK_ARR_OPEN))\n                goto return_fail;\n\n            UniValue *top = stack.back();\n            if (top->getType() == VOBJ)\n                setExpect(OBJ_NAME);\n            else\n                setExpect(ARR_VALUE);\n            break;\n            }\n\n        case JTOK_KW_NULL:\n        case JTOK_KW_TRUE:\n        case JTOK_KW_FALSE: {\n            UniValue tmpVal;\n            switch (tok) {\n            case JTOK_KW_NULL:\n                // do nothing more\n                break;\n            case JTOK_KW_TRUE:\n                tmpVal.setBool(true);\n                break;\n            case JTOK_KW_FALSE:\n                tmpVal.setBool(false);\n                break;\n            default: /* impossible */ break;\n            }\n\n            if (!stack.size()) {\n                *this = tmpVal;\n                break;\n            }\n\n            UniValue *top = stack.back();\n            top->values.push_back(tmpVal);\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_NUMBER: {\n            UniValue tmpVal(VNUM, tokenVal);\n            if (!stack.size()) {\n                *this = tmpVal;\n                break;\n            }\n\n            UniValue *top = stack.back();\n            top->values.push_back(tmpVal);\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        case JTOK_STRING: {\n            if (expect(OBJ_NAME)) {\n                UniValue *top = stack.back();\n                top->keys.push_back(tokenVal);\n                clearExpect(OBJ_NAME);\n                setExpect(COLON);\n            } else {\n                UniValue tmpVal(VSTR, tokenVal);\n                if (!stack.size()) {\n                    *this = tmpVal;\n                    break;\n                }\n                UniValue *top = stack.back();\n                top->values.push_back(tmpVal);\n            }\n\n            setExpect(NOT_VALUE);\n            break;\n            }\n\n        default:\n            goto return_fail;\n        }\n    } while (!stack.empty ());\n\n    /* Check that nothing follows the initial construct (parsed above).  */\n    tok = getJsonToken(tokenVal, consumed, raw, end);\n    if (tok != JTOK_NONE)\n        goto return_fail;\n\n    return true;\n\nreturn_fail:\n    clear();\n    return false;\n}""}]","{""function"": 1}","[{""source"": ""func_info(func:clear)"", ""result"": [{""code"": ""void UniValue::clear()\n{\n    typ = VNULL;\n    val.clear();\n    keys.clear();\n    values.clear();\n}"", ""start_line"": 15, ""end_line"": 21, ""full_name"": ""UniValue.clear:void()"", ""file_path"": ""lib/univalue.cpp""}]}]","Original error paths in UniValue::read() (lib/univalue_read.cpp:266, 274, 334, etc.) returned false without calling clear(). This left typ, val, keys, and values (lib/univalue.cpp:15-21) in an inconsistent state. The patch adds 'goto return_fail' to invoke clear() before returning, ensuring state reset on errors.",0.95,./github/other_context/CVE-2019-18936
51,CVE-2019-19577,"CWE-401, CWE-662",c_cpp,"An issue was discovered in Xen through 4.12.x allowing x86 AMD HVM guest OS users to cause a denial of service or possibly gain privileges by triggering data-structure access during pagetable-height updates. When running on AMD systems with an IOMMU, Xen attempted to dynamically adapt the number of levels of pagetables (the pagetable height) in the IOMMU according to the guest's address space size. The code to select and update the height had several bugs. Notably, the update was done without taking a lock which is necessary for safe operation. A malicious guest administrator can cause Xen to access data structures while they are being modified, causing Xen to crash. Privilege escalation is thought to be very difficult but cannot be ruled out. Additionally, there is a potential memory leak of 4kb per guest boot, under memory pressure. Only Xen on AMD CPUs is vulnerable. Xen running on Intel CPUs is not vulnerable. ARM systems are not vulnerable. Only systems where guests are given direct access to physical devices are vulnerable. Systems which do not use PCI pass-through are not vulnerable. Only HVM guests can exploit the vulnerability. PV and PVH guests cannot. All versions of Xen with IOMMU support are vulnerable.",https://github.com/xen-project/xen/commit/b4f042236ae0bb6725b3e8dd40af5a2466a6f971,"AMD/IOMMU: Cease using a dynamic height for the IOMMU pagetables\n\nupdate_paging_mode() has multiple bugs:\n\n 1) Booting with iommu=debug will cause it to inform you that that it called\n    without the pdev_list lock held.\n 2) When growing by more than a single level, it leaks the newly allocated\n    table(s) in the case of a further error.\n\nFurthermore, the choice of default level for a domain has issues:\n\n 1) All HVM guests grow from 2 to 3 levels during construction because of the\n    position of the VRAM just below the 4G boundary, so defaulting to 2 is a\n    waste of effort.\n 2) The limit for PV guests doesn't take memory hotplug into account, and\n    isn't dynamic at runtime like HVM guests.  This means that a PV guest may\n    get RAM which it can't map in the IOMMU.\n\nThe dynamic height is a property unique to AMD, and adds a substantial\nquantity of complexity for what is a marginal performance improvement.  Remove\nthe complexity by removing the dynamic height.\n\nPV guests now get 3 or 4 levels based on any hotplug regions in the host.\nThis only makes a difference for hardware which previously had all RAM below\nthe 512G boundary, and a hotplug region above.\n\nHVM guests now get 4 levels (which will be sufficient until 256TB guests\nbecome a thing), because we don't currently have the information to know when\n3 would be safe to use.\n\nThe overhead of this extra level is not expected to be noticeable.  It costs\none page (4k) per domain, and one extra IO-TLB paging structure cache entry\nwhich is very hot and less likely to be evicted.\n\nThis is XSA-311.\n\nSigned-off-by: Andrew Cooper <andrew.cooper3@citrix.com>\nAcked-by: Jan Beulich <jbeulich@suse.com>",2,"[{""func_name"": ""amd_iommu_domain_init"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static int amd_iommu_domain_init(struct domain *d)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n\n    /* For pv and dom0, stick with get_paging_mode(max_page)\n     * For HVM dom0, use 2 level page table at first */\n    hd->arch.paging_mode = is_hvm_domain(d) ?\n        2 : amd_iommu_get_paging_mode(max_page);\n    return 0;\n}"", ""target"": 1}, {""func_name"": ""amd_iommu_map_page"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""int amd_iommu_map_page(struct domain *d, dfn_t dfn, mfn_t mfn,\n                       unsigned int flags, unsigned int *flush_flags)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int rc;\n    unsigned long pt_mfn[7];\n\n    memset(pt_mfn, 0, sizeof(pt_mfn));\n\n    spin_lock(&hd->arch.mapping_lock);\n\n    rc = amd_iommu_alloc_root(hd);\n    if ( rc )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\""Root table alloc failed, dfn = %\""PRI_dfn\""\\n\"",\n                        dfn_x(dfn));\n        domain_crash(d);\n        return rc;\n    }\n\n    /* Since HVM domain is initialized with 2 level IO page table,\n     * we might need a deeper page table for wider dfn now */\n    if ( is_hvm_domain(d) )\n    {\n        if ( update_paging_mode(d, dfn_x(dfn)) )\n        {\n            spin_unlock(&hd->arch.mapping_lock);\n            AMD_IOMMU_DEBUG(\""Update page mode failed dfn = %\""PRI_dfn\""\\n\"",\n                            dfn_x(dfn));\n            domain_crash(d);\n            return -EFAULT;\n        }\n    }\n\n    if ( iommu_pde_from_dfn(d, dfn_x(dfn), pt_mfn, true) || (pt_mfn[1] == 0) )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\""Invalid IO pagetable entry dfn = %\""PRI_dfn\""\\n\"",\n                        dfn_x(dfn));\n        domain_crash(d);\n        return -EFAULT;\n    }\n\n    /* Install 4k mapping */\n    *flush_flags |= set_iommu_pte_present(pt_mfn[1], dfn_x(dfn), mfn_x(mfn),\n                                          1, (flags & IOMMUF_writable),\n                                          (flags & IOMMUF_readable));\n\n    spin_unlock(&hd->arch.mapping_lock);\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""amd_iommu_domain_init"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static int amd_iommu_domain_init(struct domain *d)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n\n    /*\n     * Choose the number of levels for the IOMMU page tables.\n     * - PV needs 3 or 4, depending on whether there is RAM (including hotplug\n     *   RAM) above the 512G boundary.\n     * - HVM could in principle use 3 or 4 depending on how much guest\n     *   physical address space we give it, but this isn't known yet so use 4\n     *   unilaterally.\n     */\n    hd->arch.paging_mode = is_hvm_domain(d)\n        ? 4 : amd_iommu_get_paging_mode(get_upper_mfn_bound());\n\n    return 0;\n}""}, {""func_name"": ""amd_iommu_map_page"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""int amd_iommu_map_page(struct domain *d, dfn_t dfn, mfn_t mfn,\n                       unsigned int flags, unsigned int *flush_flags)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int rc;\n    unsigned long pt_mfn[7];\n\n    memset(pt_mfn, 0, sizeof(pt_mfn));\n\n    spin_lock(&hd->arch.mapping_lock);\n\n    rc = amd_iommu_alloc_root(hd);\n    if ( rc )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\""Root table alloc failed, dfn = %\""PRI_dfn\""\\n\"",\n                        dfn_x(dfn));\n        domain_crash(d);\n        return rc;\n    }\n\n    if ( iommu_pde_from_dfn(d, dfn_x(dfn), pt_mfn, true) || (pt_mfn[1] == 0) )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\""Invalid IO pagetable entry dfn = %\""PRI_dfn\""\\n\"",\n                        dfn_x(dfn));\n        domain_crash(d);\n        return -EFAULT;\n    }\n\n    /* Install 4k mapping */\n    *flush_flags |= set_iommu_pte_present(pt_mfn[1], dfn_x(dfn), mfn_x(mfn),\n                                          1, (flags & IOMMUF_writable),\n                                          (flags & IOMMUF_readable));\n\n    spin_unlock(&hd->arch.mapping_lock);\n\n    return 0;\n}""}]","{""function"": 1, ""caller"": 1, ""code"": 1}","[{""source"": ""func_info(func:update_paging_mode)"", ""result"": [{""code"": ""static int update_paging_mode(struct domain *d, unsigned long dfn)\n{\n    uint16_t bdf;\n    struct amd_iommu_dte *table, *dte;\n    unsigned int req_id, level, offset;\n    unsigned long flags;\n    struct pci_dev *pdev;\n    struct amd_iommu *iommu = NULL;\n    struct page_info *new_root = NULL;\n    struct page_info *old_root = NULL;\n    struct amd_iommu_pte *new_root_vaddr;\n    unsigned long old_root_mfn;\n    struct domain_iommu *hd = dom_iommu(d);\n\n    if ( dfn == dfn_x(INVALID_DFN) )\n        return -EADDRNOTAVAIL;\n    ASSERT(!(dfn >> DEFAULT_DOMAIN_ADDRESS_WIDTH));\n\n    level = hd->arch.paging_mode;\n    old_root = hd->arch.root_table;\n    offset = dfn >> (PTE_PER_TABLE_SHIFT * (level - 1));\n\n    ASSERT(spin_is_locked(&hd->arch.mapping_lock) && is_hvm_domain(d));\n\n    while ( offset >= PTE_PER_TABLE_SIZE )\n    {\n        /* Allocate and install a new root table.\n         * Only upper I/O page table grows, no need to fix next level bits */\n        new_root = alloc_amd_iommu_pgtable();\n        if ( new_root == NULL )\n        {\n            AMD_IOMMU_DEBUG(\""%s Cannot allocate I/O page table\\n\"",\n                            __func__);\n            return -ENOMEM;\n        }\n\n        new_root_vaddr = __map_domain_page(new_root);\n        old_root_mfn = mfn_x(page_to_mfn(old_root));\n        set_iommu_pde_present(new_root_vaddr, old_root_mfn, level,\n                              true, true);\n        level++;\n        old_root = new_root;\n        offset >>= PTE_PER_TABLE_SHIFT;\n        unmap_domain_page(new_root_vaddr);\n    }\n\n    if ( new_root != NULL )\n    {\n        hd->arch.paging_mode = level;\n        hd->arch.root_table = new_root;\n\n        if ( !pcidevs_locked() )\n            AMD_IOMMU_DEBUG(\""%s Try to access pdev_list \""\n                            \""without aquiring pcidevs_lock.\\n\"", __func__);\n\n        /* Update device table entries using new root table and paging mode */\n        for_each_pdev( d, pdev )\n        {\n            if ( pdev->type == DEV_TYPE_PCI_HOST_BRIDGE )\n                continue;\n\n            bdf = PCI_BDF2(pdev->bus, pdev->devfn);\n            iommu = find_iommu_for_device(pdev->seg, bdf);\n            if ( !iommu )\n            {\n                AMD_IOMMU_DEBUG(\""%s Fail to find iommu.\\n\"", __func__);\n                return -ENODEV;\n            }\n\n            spin_lock_irqsave(&iommu->lock, flags);\n            do {\n                req_id = get_dma_requestor_id(pdev->seg, bdf);\n                table = iommu->dev_table.buffer;\n                dte = &table[req_id];\n\n                /* valid = 0 only works for dom0 passthrough mode */\n                amd_iommu_set_root_page_table(dte,\n                                              page_to_maddr(hd->arch.root_table),\n                                              d->domain_id,\n                                              hd->arch.paging_mode, 1);\n\n                amd_iommu_flush_device(iommu, req_id);\n                bdf += pdev->phantom_stride;\n            } while ( PCI_DEVFN2(bdf) != pdev->devfn &&\n                      PCI_SLOT(bdf) == PCI_SLOT(pdev->devfn) );\n            spin_unlock_irqrestore(&iommu->lock, flags);\n        }\n\n        /* For safety, invalidate all entries */\n        amd_iommu_flush_all_pages(d);\n    }\n    return 0;\n}\n"", ""start_line"": 288, ""end_line"": 380, ""full_name"": ""update_paging_mode"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c""}]}, {""source"": ""caller_info(file:iommu_map.c, func:amd_iommu_map_page)"", ""result"": [{""call_line"": 548, ""call_code"": ""amd_iommu_map_page(domain, _dfn(frame), _mfn(frame), flags,\n                                &flush_flags)"", ""caller_code"": ""int amd_iommu_reserve_domain_unity_map(struct domain *domain,\n                                       paddr_t phys_addr,\n                                       unsigned long size, int iw, int ir)\n{\n    unsigned long npages, i;\n    unsigned long gfn;\n    unsigned int flags = !!ir;\n    unsigned int flush_flags = 0;\n    int rt = 0;\n\n    if ( iw )\n        flags |= IOMMUF_writable;\n\n    npages = region_to_pages(phys_addr, size);\n    gfn = phys_addr >> PAGE_SHIFT;\n    for ( i = 0; i < npages; i++ )\n    {\n        unsigned long frame = gfn + i;\n\n        rt = amd_iommu_map_page(domain, _dfn(frame), _mfn(frame), flags,\n                                &flush_flags);\n        if ( rt != 0 )\n            break;\n    }\n\n    /* Use while-break to avoid compiler warning */\n    while ( flush_flags &&\n            amd_iommu_flush_iotlb_pages(domain, _dfn(gfn),\n                                        npages, flush_flags) )\n        break;\n\n    return rt;\n}"", ""caller_start"": 529, ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c""}]}, {""source"": ""code_info(file:iommu_map.c, lines:390-420)"", ""result"": ""\n    spin_lock(&hd->arch.mapping_lock);\n\n    rc = amd_iommu_alloc_root(hd);\n    if ( rc )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\""Root table alloc failed, dfn = %\""PRI_dfn\""\\n\"",\n                        dfn_x(dfn));\n        domain_crash(d);\n        return rc;\n    }\n\n    /* Since HVM domain is initialized with 2 level IO page table,\n     * we might need a deeper page table for wider dfn now */\n    if ( is_hvm_domain(d) )\n    {\n        if ( update_paging_mode(d, dfn_x(dfn)) )\n        {\n            spin_unlock(&hd->arch.mapping_lock);\n            AMD_IOMMU_DEBUG(\""Update page mode failed dfn = %\""PRI_dfn\""\\n\"",\n                            dfn_x(dfn));\n            domain_crash(d);\n            return -EFAULT;\n        }\n    }\n\n    if ( iommu_pde_from_dfn(d, dfn_x(dfn), pt_mfn, true) || (pt_mfn[1] == 0) )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\""Invalid IO pagetable entry dfn = %\""PRI_dfn\""\\n\"",\n""}]","xen/drivers/passthrough/amd/iommu_map.c:401-417: Removed code calling update_paging_mode() in HVM domains without ensuring pdev_list lock. update_paging_mode() (xen/drivers/passthrough/amd/iommu_map.c:288-380) iterates over pdev_list without holding the lock (logs a debug message if !pcidevs_locked()), leading to data races during device table updates. The dynamic height adjustment required runtime locking that was inconsistently enforced, enabling concurrent access to IOMMU data structures.",0.95,./github/other_context/CVE-2019-19577
52,CVE-2019-9144,CWE-674,c_cpp,An issue was discovered in Exiv2 0.27. There is infinite recursion at BigTiffImage::printIFD in the file bigtiffimage.cpp. This can be triggered by a crafted file. It allows an attacker to cause Denial of Service (Segmentation fault) or possibly have unspecified other impact.,https://github.com/Exiv2/exiv2/commit/134e062b664e52a0f1e5223ea8c5d2495de2f31e,Fix issue 712.,2,"[{""func_name"": ""printIFD"", ""file_path"": ""src/bigtiffimage.cpp"", ""func_code"": ""void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)\n                {\n                    BasicIo& io = Image::io();\n\n                    depth++;\n                    bool bFirst  = true;\n\n                    // buffer\n                    bool bPrint = true;\n\n                    do\n                    {\n                        // Read top of directory\n                        io.seek(static_cast<int64>(dir_offset), BasicIo::beg);\n\n                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);\n                        const bool tooBig = entries > 500;\n\n                        if ( bFirst && bPrint )\n                        {\n                            out << Internal::indent(depth) << \""STRUCTURE OF BIGTIFF FILE \"" << io.path() << std::endl;\n                            if (tooBig)\n                                out << Internal::indent(depth) << \""entries = \"" << entries << std::endl;\n                        }\n\n                        if (tooBig)\n                            break;\n\n                        // Read the dictionary\n                        for ( uint64_t i = 0; i < entries; i ++ )\n                        {\n                            if ( bFirst && bPrint )\n                                out << Internal::indent(depth)\n                                    << \"" address |    tag                           |     \""\n                                    << \"" type |    count |    offset | value\\n\"";\n\n                            bFirst = false;\n\n                            const uint16_t tag   = (uint16_t) readData(2);\n                            const uint16_t type  = (uint16_t) readData(2);\n                            const uint64_t count = readData(dataSize_);\n                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type\n\n                            std::string sp = \""\"" ; // output spacer\n\n                            //prepare to print the value\n                            // TODO: figure out what's going on with kount\n                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays\n                                                            : count > 5              ? 5\n                                                            : count\n                                                            ;\n                            const uint32_t pad    = isStringType(type) ? 1 : 0;\n                            const uint32_t size   = isStringType(type) ? 1\n                                                  : is2ByteType(type)  ? 2\n                                                  : is4ByteType(type)  ? 4\n                                                  : is8ByteType(type)  ? 8\n                                                  : 1;\n\n                            // #55 and #56 memory allocation crash test/data/POC8\n\n                            // size * count > std::numeric_limits<uint64_t>::max()\n                            // =>\n                            // size > std::numeric_limits<uint64_t>::max() / count\n                            // (don't perform that check when count == 0 => will cause a division by zero exception)\n                            if (count != 0) {\n                                if (size > std::numeric_limits<uint64_t>::max() / count) {\n                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64\n                                }\n                            }\n                                                             // more than we can handle\n\n                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)\n                                throw Error(kerInvalidMalloc);             // again more than 2^64\n\n                            const uint64_t allocate = size*count + pad;\n                            if ( allocate > io.size() ) {\n                                throw Error(kerInvalidMalloc);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t offset = header_.format() == Header::StandardTiff?\n                                    byteSwap4(data, 0, doSwap_):\n                                    byteSwap8(data, 0, doSwap_);\n\n                            // big data? Use 'data' as pointer to real data\n                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;\n\n                            if ( usePointer )                          // read into buffer\n                            {\n                                size_t   restore = io.tell();          // save\n                                io.seek(static_cast<int64>(offset), BasicIo::beg);         // position\n                                io.read(buf.pData_, (long) count * size);     // read\n                                io.seek(restore, BasicIo::beg);        // restore\n                            }\n                            else  // use 'data' as data :)\n                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data\n\n                            if ( bPrint )\n                            {\n                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t address = dir_offset + 2 + i * entrySize;\n\n                                out << Internal::indent(depth)\n                                    << Internal::stringFormat(\""%8u | %#06x %-25s |%10s |%9u |\"",\n                                        static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count)\n                                    <<(usePointer ? Internal::stringFormat(\""%10u | \"",(size_t)offset)\n                                                  : Internal::stringFormat(\""%10s | \"",\""\""))\n                                    ;\n                                if ( isShortType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap2(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap4(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isLongLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap8(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isRationalType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);\n                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);\n                                        out << sp << a << \""/\"" << b;\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isStringType(type) )\n                                    out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount)));\n\n                                sp = kount == count ? \""\"" : \"" ...\"";\n                                out << sp << std::endl;\n\n                                if ( option == kpsRecursive &&\n                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )\n                                {\n                                    for ( size_t k = 0 ; k < count ; k++ )\n                                    {\n                                        const size_t restore = io.tell();\n                                        const uint64_t ifdOffset = type == tiffIfd8?\n                                            byteSwap8(buf, k*size, doSwap_):\n                                            byteSwap4(buf, k*size, doSwap_);\n\n                                        printIFD(out, option, ifdOffset, depth);\n                                        io.seek(restore, BasicIo::beg);\n                                    }\n                                }\n                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )\n                                {\n                                    if (Safe::add(count, offset) > io.size()) {\n                                        throw Error(kerCorruptedMetadata);\n                                    }\n\n                                    const size_t restore = io.tell();\n                                    io.seek(static_cast<int64>(offset), BasicIo::beg);  // position\n                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  // allocate memory\n                                    // TODO: once we have C++11 use bytes.data()\n                                    const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count));\n                                    io.seek(restore, BasicIo::beg);\n                                    // TODO: once we have C++11 use bytes.data()\n                                    IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                                }\n                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)\n                                {\n                                    size_t   restore = io.tell();  // save\n\n                                    long jump= 10           ;\n                                    byte     bytes[20]          ;\n                                    const char* chars = (const char*) &bytes[0] ;\n                                    io.seek(static_cast<int64>(dir_offset), BasicIo::beg);  // position\n                                    io.read(bytes,jump    )     ;  // read\n                                    bytes[jump]=0               ;\n                                    if ( ::strcmp(\""Nikon\"",chars) == 0 )\n                                    {\n                                      // tag is an embedded tiff\n                                      std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump));\n\n                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());\n                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file\n                                      std::cerr << \""Nikon makernote\"" << std::endl;\n                                      // printTiffStructure(memIo,out,option,depth);\n                                      // TODO: fix it\n                                    }\n                                    else\n                                    {\n                                        // tag is an IFD\n                                        io.seek(0, BasicIo::beg);  // position\n                                        std::cerr << \""makernote\"" << std::endl;\n                                        printIFD(out,option,offset,depth);\n                                    }\n\n                                    io.seek(restore,BasicIo::beg); // restore\n                                }\n                            }\n                        }\n\n                        const uint64_t nextDirOffset = readData(dataSize_);\n\n                        dir_offset = tooBig ? 0 : nextDirOffset;\n                        out.flush();\n                    } while (dir_offset != 0);\n\n                    if ( bPrint )\n                        out << Internal::indent(depth) << \""END \"" << io.path() << std::endl;\n                }"", ""target"": 0}, {""func_name"": ""printIFD"", ""file_path"": ""src/bigtiffimage.cpp"", ""func_code"": ""void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)\n                {\n                    BasicIo& io = Image::io();\n\n                    // Fix for https://github.com/Exiv2/exiv2/issues/712\n                    // A malicious file can cause a very deep recursion, leading to\n                    // stack exhaustion.\n                    if (depth > 200) {\n                      out << Internal::indent(depth) << \""Maximum indentation depth exceeded.\"" << std::endl;\n                      return;\n                    }\n\n                    depth++;\n                    bool bFirst  = true;\n\n                    // buffer\n                    bool bPrint = true;\n\n                    do\n                    {\n                        // Read top of directory\n                        io.seek(static_cast<int64>(dir_offset), BasicIo::beg);\n\n                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);\n                        const bool tooBig = entries > 500;\n\n                        if ( bFirst && bPrint )\n                        {\n                            out << Internal::indent(depth) << \""STRUCTURE OF BIGTIFF FILE \"" << io.path() << std::endl;\n                            if (tooBig)\n                                out << Internal::indent(depth) << \""entries = \"" << entries << std::endl;\n                        }\n\n                        if (tooBig)\n                            break;\n\n                        // Read the dictionary\n                        for ( uint64_t i = 0; i < entries; i ++ )\n                        {\n                            if ( bFirst && bPrint )\n                                out << Internal::indent(depth)\n                                    << \"" address |    tag                           |     \""\n                                    << \"" type |    count |    offset | value\\n\"";\n\n                            bFirst = false;\n\n                            const uint16_t tag   = (uint16_t) readData(2);\n                            const uint16_t type  = (uint16_t) readData(2);\n                            const uint64_t count = readData(dataSize_);\n                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type\n\n                            std::string sp = \""\"" ; // output spacer\n\n                            //prepare to print the value\n                            // TODO: figure out what's going on with kount\n                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays\n                                                            : count > 5              ? 5\n                                                            : count\n                                                            ;\n                            const uint32_t pad    = isStringType(type) ? 1 : 0;\n                            const uint32_t size   = isStringType(type) ? 1\n                                                  : is2ByteType(type)  ? 2\n                                                  : is4ByteType(type)  ? 4\n                                                  : is8ByteType(type)  ? 8\n                                                  : 1;\n\n                            // #55 and #56 memory allocation crash test/data/POC8\n\n                            // size * count > std::numeric_limits<uint64_t>::max()\n                            // =>\n                            // size > std::numeric_limits<uint64_t>::max() / count\n                            // (don't perform that check when count == 0 => will cause a division by zero exception)\n                            if (count != 0) {\n                                if (size > std::numeric_limits<uint64_t>::max() / count) {\n                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64\n                                }\n                            }\n                                                             // more than we can handle\n\n                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)\n                                throw Error(kerInvalidMalloc);             // again more than 2^64\n\n                            const uint64_t allocate = size*count + pad;\n                            if ( allocate > io.size() ) {\n                                throw Error(kerInvalidMalloc);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t offset = header_.format() == Header::StandardTiff?\n                                    byteSwap4(data, 0, doSwap_):\n                                    byteSwap8(data, 0, doSwap_);\n\n                            // big data? Use 'data' as pointer to real data\n                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;\n\n                            if ( usePointer )                          // read into buffer\n                            {\n                                size_t   restore = io.tell();          // save\n                                io.seek(static_cast<int64>(offset), BasicIo::beg);         // position\n                                io.read(buf.pData_, (long) count * size);     // read\n                                io.seek(restore, BasicIo::beg);        // restore\n                            }\n                            else  // use 'data' as data :)\n                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data\n\n                            if ( bPrint )\n                            {\n                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t address = dir_offset + 2 + i * entrySize;\n\n                                out << Internal::indent(depth)\n                                    << Internal::stringFormat(\""%8u | %#06x %-25s |%10s |%9u |\"",\n                                        static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count)\n                                    <<(usePointer ? Internal::stringFormat(\""%10u | \"",(size_t)offset)\n                                                  : Internal::stringFormat(\""%10s | \"",\""\""))\n                                    ;\n                                if ( isShortType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap2(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap4(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isLongLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap8(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isRationalType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);\n                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);\n                                        out << sp << a << \""/\"" << b;\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isStringType(type) )\n                                    out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount)));\n\n                                sp = kount == count ? \""\"" : \"" ...\"";\n                                out << sp << std::endl;\n\n                                if ( option == kpsRecursive &&\n                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )\n                                {\n                                    for ( size_t k = 0 ; k < count ; k++ )\n                                    {\n                                        const size_t restore = io.tell();\n                                        const uint64_t ifdOffset = type == tiffIfd8?\n                                            byteSwap8(buf, k*size, doSwap_):\n                                            byteSwap4(buf, k*size, doSwap_);\n\n                                        printIFD(out, option, ifdOffset, depth);\n                                        io.seek(restore, BasicIo::beg);\n                                    }\n                                }\n                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )\n                                {\n                                    if (Safe::add(count, offset) > io.size()) {\n                                        throw Error(kerCorruptedMetadata);\n                                    }\n\n                                    const size_t restore = io.tell();\n                                    io.seek(static_cast<int64>(offset), BasicIo::beg);  // position\n                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  // allocate memory\n                                    // TODO: once we have C++11 use bytes.data()\n                                    const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count));\n                                    io.seek(restore, BasicIo::beg);\n                                    // TODO: once we have C++11 use bytes.data()\n                                    IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                                }\n                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)\n                                {\n                                    size_t   restore = io.tell();  // save\n\n                                    long jump= 10           ;\n                                    byte     bytes[20]          ;\n                                    const char* chars = (const char*) &bytes[0] ;\n                                    io.seek(static_cast<int64>(dir_offset), BasicIo::beg);  // position\n                                    io.read(bytes,jump    )     ;  // read\n                                    bytes[jump]=0               ;\n                                    if ( ::strcmp(\""Nikon\"",chars) == 0 )\n                                    {\n                                      // tag is an embedded tiff\n                                      std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump));\n\n                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());\n                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file\n                                      std::cerr << \""Nikon makernote\"" << std::endl;\n                                      // printTiffStructure(memIo,out,option,depth);\n                                      // TODO: fix it\n                                    }\n                                    else\n                                    {\n                                        // tag is an IFD\n                                        io.seek(0, BasicIo::beg);  // position\n                                        std::cerr << \""makernote\"" << std::endl;\n                                        printIFD(out,option,offset,depth);\n                                    }\n\n                                    io.seek(restore,BasicIo::beg); // restore\n                                }\n                            }\n                        }\n\n                        const uint64_t nextDirOffset = readData(dataSize_);\n\n                        dir_offset = tooBig ? 0 : nextDirOffset;\n                        out.flush();\n                    } while (dir_offset != 0);\n\n                    if ( bPrint )\n                        out << Internal::indent(depth) << \""END \"" << io.path() << std::endl;\n                }"", ""target"": 0}]","[{""func_name"": ""printIFD"", ""file_path"": ""src/bigtiffimage.cpp"", ""func_code"": ""void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)\n                {\n                    BasicIo& io = Image::io();\n\n                    // Fix for https://github.com/Exiv2/exiv2/issues/712\n                    // A malicious file can cause a very deep recursion, leading to\n                    // stack exhaustion.\n                    if (depth > 200) {\n                      out << Internal::indent(depth) << \""Maximum indentation depth exceeded.\"" << std::endl;\n                      return;\n                    }\n\n                    depth++;\n                    bool bFirst  = true;\n\n                    // buffer\n                    bool bPrint = true;\n\n                    do\n                    {\n                        // Read top of directory\n                        io.seek(static_cast<int64>(dir_offset), BasicIo::beg);\n\n                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);\n                        const bool tooBig = entries > 500;\n\n                        if ( bFirst && bPrint )\n                        {\n                            out << Internal::indent(depth) << \""STRUCTURE OF BIGTIFF FILE \"" << io.path() << std::endl;\n                            if (tooBig)\n                                out << Internal::indent(depth) << \""entries = \"" << entries << std::endl;\n                        }\n\n                        if (tooBig)\n                            break;\n\n                        // Read the dictionary\n                        for ( uint64_t i = 0; i < entries; i ++ )\n                        {\n                            if ( bFirst && bPrint )\n                                out << Internal::indent(depth)\n                                    << \"" address |    tag                           |     \""\n                                    << \"" type |    count |    offset | value\\n\"";\n\n                            bFirst = false;\n\n                            const uint16_t tag   = (uint16_t) readData(2);\n                            const uint16_t type  = (uint16_t) readData(2);\n                            const uint64_t count = readData(dataSize_);\n                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type\n\n                            std::string sp = \""\"" ; // output spacer\n\n                            //prepare to print the value\n                            // TODO: figure out what's going on with kount\n                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays\n                                                            : count > 5              ? 5\n                                                            : count\n                                                            ;\n                            const uint32_t pad    = isStringType(type) ? 1 : 0;\n                            const uint32_t size   = isStringType(type) ? 1\n                                                  : is2ByteType(type)  ? 2\n                                                  : is4ByteType(type)  ? 4\n                                                  : is8ByteType(type)  ? 8\n                                                  : 1;\n\n                            // #55 and #56 memory allocation crash test/data/POC8\n\n                            // size * count > std::numeric_limits<uint64_t>::max()\n                            // =>\n                            // size > std::numeric_limits<uint64_t>::max() / count\n                            // (don't perform that check when count == 0 => will cause a division by zero exception)\n                            if (count != 0) {\n                                if (size > std::numeric_limits<uint64_t>::max() / count) {\n                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64\n                                }\n                            }\n                                                             // more than we can handle\n\n                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)\n                                throw Error(kerInvalidMalloc);             // again more than 2^64\n\n                            const uint64_t allocate = size*count + pad;\n                            if ( allocate > io.size() ) {\n                                throw Error(kerInvalidMalloc);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t offset = header_.format() == Header::StandardTiff?\n                                    byteSwap4(data, 0, doSwap_):\n                                    byteSwap8(data, 0, doSwap_);\n\n                            // big data? Use 'data' as pointer to real data\n                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;\n\n                            if ( usePointer )                          // read into buffer\n                            {\n                                size_t   restore = io.tell();          // save\n                                io.seek(static_cast<int64>(offset), BasicIo::beg);         // position\n                                io.read(buf.pData_, (long) count * size);     // read\n                                io.seek(restore, BasicIo::beg);        // restore\n                            }\n                            else  // use 'data' as data :)\n                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data\n\n                            if ( bPrint )\n                            {\n                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t address = dir_offset + 2 + i * entrySize;\n\n                                out << Internal::indent(depth)\n                                    << Internal::stringFormat(\""%8u | %#06x %-25s |%10s |%9u |\"",\n                                        static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count)\n                                    <<(usePointer ? Internal::stringFormat(\""%10u | \"",(size_t)offset)\n                                                  : Internal::stringFormat(\""%10s | \"",\""\""))\n                                    ;\n                                if ( isShortType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap2(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap4(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isLongLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap8(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isRationalType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);\n                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);\n                                        out << sp << a << \""/\"" << b;\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isStringType(type) )\n                                    out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount)));\n\n                                sp = kount == count ? \""\"" : \"" ...\"";\n                                out << sp << std::endl;\n\n                                if ( option == kpsRecursive &&\n                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )\n                                {\n                                    for ( size_t k = 0 ; k < count ; k++ )\n                                    {\n                                        const size_t restore = io.tell();\n                                        const uint64_t ifdOffset = type == tiffIfd8?\n                                            byteSwap8(buf, k*size, doSwap_):\n                                            byteSwap4(buf, k*size, doSwap_);\n\n                                        printIFD(out, option, ifdOffset, depth);\n                                        io.seek(restore, BasicIo::beg);\n                                    }\n                                }\n                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )\n                                {\n                                    if (Safe::add(count, offset) > io.size()) {\n                                        throw Error(kerCorruptedMetadata);\n                                    }\n\n                                    const size_t restore = io.tell();\n                                    io.seek(static_cast<int64>(offset), BasicIo::beg);  // position\n                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  // allocate memory\n                                    // TODO: once we have C++11 use bytes.data()\n                                    const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count));\n                                    io.seek(restore, BasicIo::beg);\n                                    // TODO: once we have C++11 use bytes.data()\n                                    IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                                }\n                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)\n                                {\n                                    size_t   restore = io.tell();  // save\n\n                                    long jump= 10           ;\n                                    byte     bytes[20]          ;\n                                    const char* chars = (const char*) &bytes[0] ;\n                                    io.seek(static_cast<int64>(dir_offset), BasicIo::beg);  // position\n                                    io.read(bytes,jump    )     ;  // read\n                                    bytes[jump]=0               ;\n                                    if ( ::strcmp(\""Nikon\"",chars) == 0 )\n                                    {\n                                      // tag is an embedded tiff\n                                      std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump));\n\n                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());\n                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file\n                                      std::cerr << \""Nikon makernote\"" << std::endl;\n                                      // printTiffStructure(memIo,out,option,depth);\n                                      // TODO: fix it\n                                    }\n                                    else\n                                    {\n                                        // tag is an IFD\n                                        io.seek(0, BasicIo::beg);  // position\n                                        std::cerr << \""makernote\"" << std::endl;\n                                        printIFD(out,option,offset,depth);\n                                    }\n\n                                    io.seek(restore,BasicIo::beg); // restore\n                                }\n                            }\n                        }\n\n                        const uint64_t nextDirOffset = readData(dataSize_);\n\n                        dir_offset = tooBig ? 0 : nextDirOffset;\n                        out.flush();\n                    } while (dir_offset != 0);\n\n                    if ( bPrint )\n                        out << Internal::indent(depth) << \""END \"" << io.path() << std::endl;\n                }""}, {""func_name"": ""printIFD"", ""file_path"": ""src/bigtiffimage.cpp"", ""func_code"": ""void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)\n                {\n                    BasicIo& io = Image::io();\n\n                    // Fix for https://github.com/Exiv2/exiv2/issues/712\n                    // A malicious file can cause a very deep recursion, leading to\n                    // stack exhaustion.\n                    // Note: 200 is an arbitrarily chosen cut-off value. The value\n                    // of depth determines the amount of indentation inserted by the\n                    // pretty-printer. The output starts to become unreadable as\n                    // soon as the indentation exceeds 80 characters or so. That's\n                    // why 200 ought to be a reasonable cut-off.\n                    if (depth > 200) {\n                      out << Internal::indent(depth) << \""Maximum indentation depth exceeded.\"" << std::endl;\n                      return;\n                    }\n\n                    depth++;\n                    bool bFirst  = true;\n\n                    // buffer\n                    bool bPrint = true;\n\n                    do\n                    {\n                        // Read top of directory\n                        io.seek(static_cast<int64>(dir_offset), BasicIo::beg);\n\n                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);\n                        const bool tooBig = entries > 500;\n\n                        if ( bFirst && bPrint )\n                        {\n                            out << Internal::indent(depth) << \""STRUCTURE OF BIGTIFF FILE \"" << io.path() << std::endl;\n                            if (tooBig)\n                                out << Internal::indent(depth) << \""entries = \"" << entries << std::endl;\n                        }\n\n                        if (tooBig)\n                            break;\n\n                        // Read the dictionary\n                        for ( uint64_t i = 0; i < entries; i ++ )\n                        {\n                            if ( bFirst && bPrint )\n                                out << Internal::indent(depth)\n                                    << \"" address |    tag                           |     \""\n                                    << \"" type |    count |    offset | value\\n\"";\n\n                            bFirst = false;\n\n                            const uint16_t tag   = (uint16_t) readData(2);\n                            const uint16_t type  = (uint16_t) readData(2);\n                            const uint64_t count = readData(dataSize_);\n                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type\n\n                            std::string sp = \""\"" ; // output spacer\n\n                            //prepare to print the value\n                            // TODO: figure out what's going on with kount\n                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays\n                                                            : count > 5              ? 5\n                                                            : count\n                                                            ;\n                            const uint32_t pad    = isStringType(type) ? 1 : 0;\n                            const uint32_t size   = isStringType(type) ? 1\n                                                  : is2ByteType(type)  ? 2\n                                                  : is4ByteType(type)  ? 4\n                                                  : is8ByteType(type)  ? 8\n                                                  : 1;\n\n                            // #55 and #56 memory allocation crash test/data/POC8\n\n                            // size * count > std::numeric_limits<uint64_t>::max()\n                            // =>\n                            // size > std::numeric_limits<uint64_t>::max() / count\n                            // (don't perform that check when count == 0 => will cause a division by zero exception)\n                            if (count != 0) {\n                                if (size > std::numeric_limits<uint64_t>::max() / count) {\n                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64\n                                }\n                            }\n                                                             // more than we can handle\n\n                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)\n                                throw Error(kerInvalidMalloc);             // again more than 2^64\n\n                            const uint64_t allocate = size*count + pad;\n                            if ( allocate > io.size() ) {\n                                throw Error(kerInvalidMalloc);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t offset = header_.format() == Header::StandardTiff?\n                                    byteSwap4(data, 0, doSwap_):\n                                    byteSwap8(data, 0, doSwap_);\n\n                            // big data? Use 'data' as pointer to real data\n                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;\n\n                            if ( usePointer )                          // read into buffer\n                            {\n                                size_t   restore = io.tell();          // save\n                                io.seek(static_cast<int64>(offset), BasicIo::beg);         // position\n                                io.read(buf.pData_, (long) count * size);     // read\n                                io.seek(restore, BasicIo::beg);        // restore\n                            }\n                            else  // use 'data' as data :)\n                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data\n\n                            if ( bPrint )\n                            {\n                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t address = dir_offset + 2 + i * entrySize;\n\n                                out << Internal::indent(depth)\n                                    << Internal::stringFormat(\""%8u | %#06x %-25s |%10s |%9u |\"",\n                                        static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count)\n                                    <<(usePointer ? Internal::stringFormat(\""%10u | \"",(size_t)offset)\n                                                  : Internal::stringFormat(\""%10s | \"",\""\""))\n                                    ;\n                                if ( isShortType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap2(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap4(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isLongLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap8(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isRationalType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);\n                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);\n                                        out << sp << a << \""/\"" << b;\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isStringType(type) )\n                                    out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount)));\n\n                                sp = kount == count ? \""\"" : \"" ...\"";\n                                out << sp << std::endl;\n\n                                if ( option == kpsRecursive &&\n                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )\n                                {\n                                    for ( size_t k = 0 ; k < count ; k++ )\n                                    {\n                                        const size_t restore = io.tell();\n                                        const uint64_t ifdOffset = type == tiffIfd8?\n                                            byteSwap8(buf, k*size, doSwap_):\n                                            byteSwap4(buf, k*size, doSwap_);\n\n                                        printIFD(out, option, ifdOffset, depth);\n                                        io.seek(restore, BasicIo::beg);\n                                    }\n                                }\n                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )\n                                {\n                                    if (Safe::add(count, offset) > io.size()) {\n                                        throw Error(kerCorruptedMetadata);\n                                    }\n\n                                    const size_t restore = io.tell();\n                                    io.seek(static_cast<int64>(offset), BasicIo::beg);  // position\n                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  // allocate memory\n                                    // TODO: once we have C++11 use bytes.data()\n                                    const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count));\n                                    io.seek(restore, BasicIo::beg);\n                                    // TODO: once we have C++11 use bytes.data()\n                                    IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                                }\n                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)\n                                {\n                                    size_t   restore = io.tell();  // save\n\n                                    long jump= 10           ;\n                                    byte     bytes[20]          ;\n                                    const char* chars = (const char*) &bytes[0] ;\n                                    io.seek(static_cast<int64>(dir_offset), BasicIo::beg);  // position\n                                    io.read(bytes,jump    )     ;  // read\n                                    bytes[jump]=0               ;\n                                    if ( ::strcmp(\""Nikon\"",chars) == 0 )\n                                    {\n                                      // tag is an embedded tiff\n                                      std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump));\n\n                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());\n                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file\n                                      std::cerr << \""Nikon makernote\"" << std::endl;\n                                      // printTiffStructure(memIo,out,option,depth);\n                                      // TODO: fix it\n                                    }\n                                    else\n                                    {\n                                        // tag is an IFD\n                                        io.seek(0, BasicIo::beg);  // position\n                                        std::cerr << \""makernote\"" << std::endl;\n                                        printIFD(out,option,offset,depth);\n                                    }\n\n                                    io.seek(restore,BasicIo::beg); // restore\n                                }\n                            }\n                        }\n\n                        const uint64_t nextDirOffset = readData(dataSize_);\n\n                        dir_offset = tooBig ? 0 : nextDirOffset;\n                        out.flush();\n                    } while (dir_offset != 0);\n\n                    if ( bPrint )\n                        out << Internal::indent(depth) << \""END \"" << io.path() << std::endl;\n                }""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(file:bigtiffimage.cpp, func:printIFD)"", ""result"": [{""code"": ""                void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)\n                {\n                    BasicIo& io = Image::io();\n\n                    depth++;\n                    bool bFirst  = true;\n\n                    // buffer\n                    bool bPrint = true;\n\n                    do\n                    {\n                        // Read top of directory\n                        io.seek(static_cast<int64>(dir_offset), BasicIo::beg);\n\n                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);\n                        const bool tooBig = entries > 500;\n\n                        if ( bFirst && bPrint )\n                        {\n                            out << Internal::indent(depth) << \""STRUCTURE OF BIGTIFF FILE \"" << io.path() << std::endl;\n                            if (tooBig)\n                                out << Internal::indent(depth) << \""entries = \"" << entries << std::endl;\n                        }\n\n                        if (tooBig)\n                            break;\n\n                        // Read the dictionary\n                        for ( uint64_t i = 0; i < entries; i ++ )\n                        {\n                            if ( bFirst && bPrint )\n                                out << Internal::indent(depth)\n                                    << \"" address |    tag                           |     \""\n                                    << \"" type |    count |    offset | value\\n\"";\n\n                            bFirst = false;\n\n                            const uint16_t tag   = (uint16_t) readData(2);\n                            const uint16_t type  = (uint16_t) readData(2);\n                            const uint64_t count = readData(dataSize_);\n                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type\n\n                            std::string sp = \""\"" ; // output spacer\n\n                            //prepare to print the value\n                            // TODO: figure out what's going on with kount\n                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays\n                                                            : count > 5              ? 5\n                                                            : count\n                                                            ;\n                            const uint32_t pad    = isStringType(type) ? 1 : 0;\n                            const uint32_t size   = isStringType(type) ? 1\n                                                  : is2ByteType(type)  ? 2\n                                                  : is4ByteType(type)  ? 4\n                                                  : is8ByteType(type)  ? 8\n                                                  : 1;\n\n                            // #55 and #56 memory allocation crash test/data/POC8\n\n                            // size * count > std::numeric_limits<uint64_t>::max()\n                            // =>\n                            // size > std::numeric_limits<uint64_t>::max() / count\n                            // (don't perform that check when count == 0 => will cause a division by zero exception)\n                            if (count != 0) {\n                                if (size > std::numeric_limits<uint64_t>::max() / count) {\n                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64\n                                }\n                            }\n                                                             // more than we can handle\n\n                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)\n                                throw Error(kerInvalidMalloc);             // again more than 2^64\n\n                            const uint64_t allocate = size*count + pad;\n                            if ( allocate > io.size() ) {\n                                throw Error(kerInvalidMalloc);\n                            }\n\n                            DataBuf buf(static_cast<long>(allocate));\n\n                            const uint64_t offset = header_.format() == Header::StandardTiff?\n                                    byteSwap4(data, 0, doSwap_):\n                                    byteSwap8(data, 0, doSwap_);\n\n                            // big data? Use 'data' as pointer to real data\n                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;\n\n                            if ( usePointer )                          // read into buffer\n                            {\n                                size_t   restore = io.tell();          // save\n                                io.seek(static_cast<int64>(offset), BasicIo::beg);         // position\n                                io.read(buf.pData_, (long) count * size);     // read\n                                io.seek(restore, BasicIo::beg);        // restore\n                            }\n                            else  // use 'data' as data :)\n                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data\n\n                            if ( bPrint )\n                            {\n                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;\n                                const uint64_t address = dir_offset + 2 + i * entrySize;\n\n                                out << Internal::indent(depth)\n                                    << Internal::stringFormat(\""%8u | %#06x %-25s |%10s |%9u |\"",\n                                        static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count)\n                                    <<(usePointer ? Internal::stringFormat(\""%10u | \"",(size_t)offset)\n                                                  : Internal::stringFormat(\""%10s | \"",\""\""))\n                                    ;\n                                if ( isShortType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap2(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap4(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isLongLongType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        out << sp << byteSwap8(buf, k*size, doSwap_);\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isRationalType(type) )\n                                {\n                                    for ( size_t k = 0 ; k < kount ; k++ )\n                                    {\n                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);\n                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);\n                                        out << sp << a << \""/\"" << b;\n                                        sp = \"" \"";\n                                    }\n                                }\n                                else if ( isStringType(type) )\n                                    out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount)));\n\n                                sp = kount == count ? \""\"" : \"" ...\"";\n                                out << sp << std::endl;\n\n                                if ( option == kpsRecursive &&\n                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )\n                                {\n                                    for ( size_t k = 0 ; k < count ; k++ )\n                                    {\n                                        const size_t restore = io.tell();\n                                        const uint64_t ifdOffset = type == tiffIfd8?\n                                            byteSwap8(buf, k*size, doSwap_):\n                                            byteSwap4(buf, k*size, doSwap_);\n\n                                        printIFD(out, option, ifdOffset, depth);\n                                        io.seek(restore, BasicIo::beg);\n                                    }\n                                }\n                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )\n                                {\n                                    if (Safe::add(count, offset) > io.size()) {\n                                        throw Error(kerCorruptedMetadata);\n                                    }\n\n                                    const size_t restore = io.tell();\n                                    io.seek(static_cast<int64>(offset), BasicIo::beg);  // position\n                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  // allocate memory\n                                    // TODO: once we have C++11 use bytes.data()\n                                    const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count));\n                                    io.seek(restore, BasicIo::beg);\n                                    // TODO: once we have C++11 use bytes.data()\n                                    IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                                }\n                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)\n                                {\n                                    size_t   restore = io.tell();  // save\n\n                                    long jump= 10           ;\n                                    byte     bytes[20]          ;\n                                    const char* chars = (const char*) &bytes[0] ;\n                                    io.seek(static_cast<int64>(dir_offset), BasicIo::beg);  // position\n                                    io.read(bytes,jump    )     ;  // read\n                                    bytes[jump]=0               ;\n                                    if ( ::strcmp(\""Nikon\"",chars) == 0 )\n                                    {\n                                      // tag is an embedded tiff\n                                      std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump));\n\n                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());\n                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file\n                                      std::cerr << \""Nikon makernote\"" << std::endl;\n                                      // printTiffStructure(memIo,out,option,depth);\n                                      // TODO: fix it\n                                    }\n                                    else\n                                    {\n                                        // tag is an IFD\n                                        io.seek(0, BasicIo::beg);  // position\n                                        std::cerr << \""makernote\"" << std::endl;\n                                        printIFD(out,option,offset,depth);\n                                    }\n\n                                    io.seek(restore,BasicIo::beg); // restore\n                                }\n                            }\n                        }\n\n                        const uint64_t nextDirOffset = readData(dataSize_);\n\n                        dir_offset = tooBig ? 0 : nextDirOffset;\n                        out.flush();\n                    } while (dir_offset != 0);\n\n                    if ( bPrint )\n                        out << Internal::indent(depth) << \""END \"" << io.path() << std::endl;\n                }\n"", ""start_line"": 191, ""end_line"": 412, ""full_name"": ""Exiv2.BigTiffImage.printIFD:void(std.ostream&,Exiv2.PrintStructureOption,uint64_t,int)"", ""file_path"": ""src/bigtiffimage.cpp""}]}, {""source"": ""code_info(file:bigtiffimage.cpp, lines:180-210)"", ""result"": ""\n                void printStructure(std::ostream& os, PrintStructureOption option, int depth)\n                {\n                    printIFD(os, option, header_.dirOffset(), depth - 1);\n                }\n\n            private:\n                Header header_;\n                int dataSize_;\n                bool doSwap_;\n\n                void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)\n                {\n                    BasicIo& io = Image::io();\n\n                    depth++;\n                    bool bFirst  = true;\n\n                    // buffer\n                    bool bPrint = true;\n\n                    do\n                    {\n                        // Read top of directory\n                        io.seek(static_cast<int64>(dir_offset), BasicIo::beg);\n\n                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);\n                        const bool tooBig = entries > 500;\n\n                        if ( bFirst && bPrint )\n                        {\n""}]","src/bigtiffimage.cpp:printIFD: The function `printIFD` recursively calls itself without depth limits when processing IFD entries (e.g., `printIFD(out, option, ifdOffset, depth)` in loops for tags like ExifTag or MakerNote). A crafted file can create a cyclic or deeply nested IFD structure, leading to infinite recursion and stack exhaustion. The patch (src/bigtiffimage.cpp:192-196) adds a depth check to cap recursion at 200 levels.",0.95,./github/other_context/CVE-2019-9144
53,CVE-2020-10576,CWE-362,c_cpp,An issue was discovered in Janus through 0.9.1. plugins/janus_voicemail.c in the VoiceMail plugin has a race condition that could cause a server crash.,https://github.com/meetecho/janus-gateway/commit/eb99ac8674c554bab6775f4378b24e991b4a2fa1,Fixes to leaks and race conditions in VoiceMail plugin,7,"[{""func_name"": ""janus_voicemail_destroy_session"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""void janus_voicemail_destroy_session(janus_plugin_session *handle, int *error) {\n\tif(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {\n\t\t*error = -1;\n\t\treturn;\n\t}\n\tjanus_mutex_lock(&sessions_mutex);\n\tjanus_voicemail_session *session = janus_voicemail_lookup_session(handle);\n\tif(!session) {\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\tJANUS_LOG(LOG_ERR, \""No VoiceMail session associated with this handle...\\n\"");\n\t\t*error = -2;\n\t\treturn;\n\t}\n\tJANUS_LOG(LOG_VERB, \""Removing VoiceMail session...\\n\"");\n\tjanus_voicemail_hangup_media_internal(handle);\n\thandle->plugin_handle = NULL;\n\tg_hash_table_remove(sessions, handle);\n\tjanus_mutex_unlock(&sessions_mutex);\n\n\treturn;\n}"", ""target"": 0}, {""func_name"": ""janus_voicemail_incoming_rtp"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""void janus_voicemail_incoming_rtp(janus_plugin_session *handle, janus_plugin_rtp *packet) {\n\tif(handle == NULL || g_atomic_int_get(&handle->stopped) || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))\n\t\treturn;\n\tjanus_voicemail_session *session = (janus_voicemail_session *)handle->plugin_handle;\n\tif(!session || g_atomic_int_get(&session->destroyed) || session->stopping || !session->started || session->start_time == 0)\n\t\treturn;\n\tgint64 now = janus_get_monotonic_time();\n\t/* Have 10 seconds passed? */\n\tif((now-session->start_time) >= 10*G_USEC_PER_SEC) {\n\t\t/* FIXME Simulate a \""stop\"" coming from the browser */\n\t\tsession->started = FALSE;\n\t\tjanus_refcount_increase(&session->ref);\n\t\tjanus_voicemail_message *msg = g_malloc(sizeof(janus_voicemail_message));\n\t\tmsg->handle = handle;\n\t\tmsg->message = json_pack(\""{ss}\"", \""request\"", \""stop\"");\n\t\tmsg->transaction = NULL;\n\t\tmsg->jsep = NULL;\n\t\tg_async_queue_push(messages, msg);\n\t\treturn;\n\t}\n\t/* Save the frame */\n\tchar *buf = packet->buffer;\n\tuint16_t len = packet->length;\n\tjanus_rtp_header *rtp = (janus_rtp_header *)buf;\n\tuint16_t seq = ntohs(rtp->seq_number);\n\tif(session->seq == 0)\n\t\tsession->seq = seq;\n\tint plen = 0;\n\tconst unsigned char *payload = (const unsigned char *)janus_rtp_payload(buf, len, &plen);\n\tif(!payload) {\n\t\tJANUS_LOG(LOG_ERR, \""Ops! got an error accessing the RTP payload\\n\"");\n\t\treturn;\n\t}\n\togg_packet *op = op_from_pkt(payload, plen);\n\t//~ JANUS_LOG(LOG_VERB, \""\\tWriting at position %d (%d)\\n\"", seq-session->seq+1, 960*(seq-session->seq+1));\n\top->granulepos = 960*(seq-session->seq+1); // FIXME: get this from the toc byte\n\togg_stream_packetin(session->stream, op);\n\tg_free(op);\n\togg_write(session);\n}"", ""target"": 0}, {""func_name"": ""janus_voicemail_handler"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""static void *janus_voicemail_handler(void *data) {\n\tJANUS_LOG(LOG_VERB, \""Joining VoiceMail handler thread\\n\"");\n\tjanus_voicemail_message *msg = NULL;\n\tint error_code = 0;\n\tchar error_cause[512];\n\tjson_t *root = NULL;\n\twhile(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {\n\t\tmsg = g_async_queue_pop(messages);\n\t\tif(msg == &exit_message)\n\t\t\tbreak;\n\t\tif(msg->handle == NULL) {\n\t\t\tjanus_voicemail_message_free(msg);\n\t\t\tcontinue;\n\t\t}\n\t\tjanus_mutex_lock(&sessions_mutex);\n\t\tjanus_voicemail_session *session = janus_voicemail_lookup_session(msg->handle);\n\t\tif(!session) {\n\t\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t\tJANUS_LOG(LOG_ERR, \""No session associated with this handle...\\n\"");\n\t\t\tjanus_voicemail_message_free(msg);\n\t\t\tcontinue;\n\t\t}\n\t\tif(g_atomic_int_get(&session->destroyed)) {\n\t\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t\tjanus_voicemail_message_free(msg);\n\t\t\tcontinue;\n\t\t}\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t/* Handle request */\n\t\terror_code = 0;\n\t\troot = msg->message;\n\t\tif(msg->message == NULL) {\n\t\t\tJANUS_LOG(LOG_ERR, \""No message??\\n\"");\n\t\t\terror_code = JANUS_VOICEMAIL_ERROR_NO_MESSAGE;\n\t\t\tg_snprintf(error_cause, 512, \""%s\"", \""No message??\"");\n\t\t\tgoto error;\n\t\t}\n\t\tif(!json_is_object(root)) {\n\t\t\tJANUS_LOG(LOG_ERR, \""JSON error: not an object\\n\"");\n\t\t\terror_code = JANUS_VOICEMAIL_ERROR_INVALID_JSON;\n\t\t\tg_snprintf(error_cause, 512, \""JSON error: not an object\"");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Get the request first */\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, request_parameters,\n\t\t\terror_code, error_cause, TRUE,\n\t\t\tJANUS_VOICEMAIL_ERROR_MISSING_ELEMENT, JANUS_VOICEMAIL_ERROR_INVALID_ELEMENT);\n\t\tif(error_code != 0)\n\t\t\tgoto error;\n\t\tjson_t *request = json_object_get(root, \""request\"");\n\t\tconst char *request_text = json_string_value(request);\n\t\tjson_t *event = NULL;\n\t\tgboolean sdp_update = FALSE;\n\t\tif(json_object_get(msg->jsep, \""update\"") != NULL)\n\t\t\tsdp_update = json_is_true(json_object_get(msg->jsep, \""update\""));\n\t\tif(!strcasecmp(request_text, \""record\"")) {\n\t\t\tJANUS_LOG(LOG_VERB, \""Starting new recording\\n\"");\n\t\t\tif(session->file != NULL) {\n\t\t\t\tJANUS_LOG(LOG_ERR, \""Already recording (%s)\\n\"", session->filename ? session->filename : \""??\"");\n\t\t\t\terror_code = JANUS_VOICEMAIL_ERROR_ALREADY_RECORDING;\n\t\t\t\tg_snprintf(error_cause, 512, \""Already recording\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tsession->stream = g_malloc0(sizeof(ogg_stream_state));\n\t\t\tif(ogg_stream_init(session->stream, rand()) < 0) {\n\t\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't initialize Ogg stream state\\n\"");\n\t\t\t\terror_code = JANUS_VOICEMAIL_ERROR_LIBOGG_ERROR;\n\t\t\t\tg_snprintf(error_cause, 512, \""Couldn't initialize Ogg stream state\\n\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tsession->file = fopen(session->filename, \""wb\"");\n\t\t\tif(session->file == NULL) {\n\t\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't open output file\\n\"");\n\t\t\t\terror_code = JANUS_VOICEMAIL_ERROR_IO_ERROR;\n\t\t\t\tg_snprintf(error_cause, 512, \""Couldn't open output file\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tsession->seq = 0;\n\t\t\t/* Write stream headers */\n\t\t\togg_packet *op = op_opushead();\n\t\t\togg_stream_packetin(session->stream, op);\n\t\t\top_free(op);\n\t\t\top = op_opustags();\n\t\t\togg_stream_packetin(session->stream, op);\n\t\t\top_free(op);\n\t\t\togg_flush(session);\n\t\t\t/* Done: now wait for the setup_media callback to be called */\n\t\t\tevent = json_object();\n\t\t\tjson_object_set_new(event, \""voicemail\"", json_string(\""event\""));\n\t\t\tjson_object_set_new(event, \""status\"", json_string(session->started ? \""started\"" : \""starting\""));\n\t\t\t/* Also notify event handlers */\n\t\t\tif(notify_events && gateway->events_is_enabled()) {\n\t\t\t\tjson_t *info = json_object();\n\t\t\t\tjson_object_set_new(info, \""event\"", json_string(\""starting\""));\n\t\t\t\tgateway->notify_event(&janus_voicemail_plugin, session->handle, info);\n\t\t\t}\n\t\t} else if(!strcasecmp(request_text, \""update\"")) {\n\t\t\t/* Only needed in case of renegotiations and ICE restarts (but with 10s messages is this worth it?) */\n\t\t\tJANUS_LOG(LOG_VERB, \""Updating existing recording\\n\"");\n\t\t\tif(session->stream == NULL || !session->started) {\n\t\t\t\tJANUS_LOG(LOG_ERR, \""Invalid state (not recording)\\n\"");\n\t\t\t\terror_code = JANUS_VOICEMAIL_ERROR_INVALID_STATE;\n\t\t\t\tg_snprintf(error_cause, 512, \""Invalid state (not recording)\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tsdp_update = TRUE;\n\t\t\tevent = json_object();\n\t\t\tjson_object_set_new(event, \""voicemail\"", json_string(\""event\""));\n\t\t\tjson_object_set_new(event, \""status\"", json_string(\""updating\""));\n\t\t} else if(!strcasecmp(request_text, \""stop\"")) {\n\t\t\t/* Stop the recording */\n\t\t\tsession->started = FALSE;\n\t\t\tsession->stopping = TRUE;\n\t\t\tif(session->file)\n\t\t\t\tfclose(session->file);\n\t\t\tsession->file = NULL;\n\t\t\tif(session->stream)\n\t\t\t\togg_stream_destroy(session->stream);\n\t\t\tsession->stream = NULL;\n\t\t\t/* Done: send the event and close the handle */\n\t\t\tevent = json_object();\n\t\t\tjson_object_set_new(event, \""voicemail\"", json_string(\""event\""));\n\t\t\tjson_object_set_new(event, \""status\"", json_string(\""done\""));\n\t\t\tchar url[1024];\n\t\t\tg_snprintf(url, 1024, \""%s/janus-voicemail-%\""SCNu64\"".opus\"", recordings_base, session->recording_id);\n\t\t\tjson_object_set_new(event, \""recording\"", json_string(url));\n\t\t\t/* Also notify event handlers */\n\t\t\tif(notify_events && gateway->events_is_enabled()) {\n\t\t\t\tjson_t *info = json_object();\n\t\t\t\tjson_object_set_new(info, \""event\"", json_string(\""done\""));\n\t\t\t\tgateway->notify_event(&janus_voicemail_plugin, session->handle, info);\n\t\t\t}\n\t\t} else {\n\t\t\tJANUS_LOG(LOG_ERR, \""Unknown request '%s'\\n\"", request_text);\n\t\t\terror_code = JANUS_VOICEMAIL_ERROR_INVALID_REQUEST;\n\t\t\tg_snprintf(error_cause, 512, \""Unknown request '%s'\"", request_text);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* Prepare JSON event */\n\t\tJANUS_LOG(LOG_VERB, \""Preparing JSON event as a reply\\n\"");\n\t\t/* Any SDP to handle? */\n\t\tconst char *msg_sdp_type = json_string_value(json_object_get(msg->jsep, \""type\""));\n\t\tconst char *msg_sdp = json_string_value(json_object_get(msg->jsep, \""sdp\""));\n\t\tif(!msg_sdp) {\n\t\t\tint ret = gateway->push_event(msg->handle, &janus_voicemail_plugin, msg->transaction, event, NULL);\n\t\t\tJANUS_LOG(LOG_VERB, \""  >> %d (%s)\\n\"", ret, janus_get_api_error(ret));\n\t\t\tjson_decref(event);\n\t\t} else {\n\t\t\tJANUS_LOG(LOG_VERB, \""This is involving a negotiation (%s) as well:\\n%s\\n\"", msg_sdp_type, msg_sdp);\n\t\t\tconst char *type = NULL;\n\t\t\tif(!strcasecmp(msg_sdp_type, \""offer\""))\n\t\t\t\ttype = \""answer\"";\n\t\t\tif(!strcasecmp(msg_sdp_type, \""answer\""))\n\t\t\t\ttype = \""offer\"";\n\t\t\tif(sdp_update) {\n\t\t\t\t/* Renegotiation: make sure the user provided an offer, and send answer */\n\t\t\t\tJANUS_LOG(LOG_VERB, \""Request to update existing connection\\n\"");\n\t\t\t\tsession->sdp_version++;\t\t/* This needs to be increased when it changes */\n\t\t\t} else {\n\t\t\t\t/* New PeerConnection */\n\t\t\t\tsession->sdp_version = 1;\t/* This needs to be increased when it changes */\n\t\t\t\tsession->sdp_sessid = janus_get_real_time();\n\t\t\t}\n\t\t\t/* Fill the SDP template and use that as our answer */\n\t\t\tchar sdp[1024];\n\t\t\t/* What is the Opus payload type? */\n\t\t\tint opus_pt = janus_get_codec_pt(msg_sdp, \""opus\"");\n\t\t\tJANUS_LOG(LOG_VERB, \""Opus payload type is %d\\n\"", opus_pt);\n\t\t\tg_snprintf(sdp, 1024, sdp_template,\n\t\t\t\tsession->sdp_sessid,\n\t\t\t\tsession->sdp_version,\n\t\t\t\tsession->recording_id,\t\t\t/* Recording ID */\n\t\t\t\topus_pt,\t\t\t\t\t\t/* Opus payload type */\n\t\t\t\topus_pt\t\t\t\t\t\t\t/* Opus payload type */);\n\t\t\t/* Did the peer negotiate video? */\n\t\t\tif(strstr(msg_sdp, \""m=video\"") != NULL) {\n\t\t\t\t/* If so, reject it */\n\t\t\t\tg_strlcat(sdp, \""m=video 0 RTP/SAVPF 0\\r\\n\"", 1024);\n\t\t\t}\n\t\t\tjson_t *jsep = json_pack(\""{ssss}\"", \""type\"", type, \""sdp\"", sdp);\n\t\t\t/* How long will the Janus core take to push the event? */\n\t\t\tg_atomic_int_set(&session->hangingup, 0);\n\t\t\tgint64 start = janus_get_monotonic_time();\n\t\t\tint res = gateway->push_event(msg->handle, &janus_voicemail_plugin, msg->transaction, event, jsep);\n\t\t\tJANUS_LOG(LOG_VERB, \""  >> Pushing event: %d (took %\""SCNu64\"" us)\\n\"", res, janus_get_monotonic_time()-start);\n\t\t\tjson_decref(event);\n\t\t\tjson_decref(jsep);\n\t\t\tif(res != JANUS_OK) {\n\t\t\t\t/* TODO Failed to negotiate? We should remove this participant */\n\t\t\t}\n\t\t}\n\t\tjanus_voicemail_message_free(msg);\n\n\t\tif(session->stopping) {\n\t\t\tgateway->end_session(session->handle);\n\t\t}\n\n\t\tcontinue;\n\nerror:\n\t\t{\n\t\t\t/* Prepare JSON error event */\n\t\t\tjson_t *event = json_object();\n\t\t\tjson_object_set_new(event, \""voicemail\"", json_string(\""event\""));\n\t\t\tjson_object_set_new(event, \""error_code\"", json_integer(error_code));\n\t\t\tjson_object_set_new(event, \""error\"", json_string(error_cause));\n\t\t\tint ret = gateway->push_event(msg->handle, &janus_voicemail_plugin, msg->transaction, event, NULL);\n\t\t\tJANUS_LOG(LOG_VERB, \""  >> Pushing event: %d (%s)\\n\"", ret, janus_get_api_error(ret));\n\t\t\tjson_decref(event);\n\t\t\tjanus_voicemail_message_free(msg);\n\t\t}\n\t}\n\tJANUS_LOG(LOG_VERB, \""Leaving VoiceMail handler thread\\n\"");\n\treturn NULL;\n}"", ""target"": 0}, {""func_name"": ""janus_voicemail_hangup_media_internal"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""static void janus_voicemail_hangup_media_internal(janus_plugin_session *handle) {\n\tif(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))\n\t\treturn;\n\tjanus_voicemail_session *session = janus_voicemail_lookup_session(handle);\n\tif(!session) {\n\t\tJANUS_LOG(LOG_ERR, \""No session associated with this handle...\\n\"");\n\t\treturn;\n\t}\n\tsession->started = FALSE;\n\tif(g_atomic_int_get(&session->destroyed))\n\t\treturn;\n\tif(!g_atomic_int_compare_and_exchange(&session->hangingup, 0, 1))\n\t\treturn;\n\t/* Close and reset stuff */\n\tif(session->file)\n\t\tfclose(session->file);\n\tsession->file = NULL;\n\tif(session->stream)\n\t\togg_stream_destroy(session->stream);\n\tsession->stream = NULL;\n\tg_atomic_int_set(&session->hangingup, 0);\n}"", ""target"": 0}, {""func_name"": ""janus_voicemail_create_session"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""void janus_voicemail_create_session(janus_plugin_session *handle, int *error) {\n\tif(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {\n\t\t*error = -1;\n\t\treturn;\n\t}\n\tjanus_voicemail_session *session = g_malloc0(sizeof(janus_voicemail_session));\n\tsession->handle = handle;\n\tsession->recording_id = janus_random_uint64();\n\tsession->start_time = 0;\n\tsession->stream = NULL;\n\tchar f[255];\n\tg_snprintf(f, 255, \""%s/janus-voicemail-%\""SCNu64\"".opus\"", recordings_path, session->recording_id);\n\tsession->filename = g_strdup(f);\n\tsession->file = NULL;\n\tsession->seq = 0;\n\tsession->started = FALSE;\n\tsession->stopping = FALSE;\n\tg_atomic_int_set(&session->hangingup, 0);\n\tg_atomic_int_set(&session->destroyed, 0);\n\tjanus_refcount_init(&session->ref, janus_voicemail_session_free);\n\thandle->plugin_handle = session;\n\n\tjanus_mutex_lock(&sessions_mutex);\n\tg_hash_table_insert(sessions, handle, session);\n\tjanus_mutex_unlock(&sessions_mutex);\n\n\treturn;\n}"", ""target"": 0}, {""func_name"": ""janus_voicemail_session_free"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""static void janus_voicemail_session_free(const janus_refcount *session_ref) {\n\tjanus_voicemail_session *session = janus_refcount_containerof(session_ref, janus_voicemail_session, ref);\n\t/* Remove the reference to the core plugin session */\n\tjanus_refcount_decrease(&session->handle->ref);\n\t/* This session can be destroyed, free all the resources */\n\tg_free(session);\n}"", ""target"": 0}, {""func_name"": ""janus_voicemail_setup_media"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""void janus_voicemail_setup_media(janus_plugin_session *handle) {\n\tJANUS_LOG(LOG_INFO, \""[%s-%p] WebRTC media is now available\\n\"", JANUS_VOICEMAIL_PACKAGE, handle);\n\tif(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))\n\t\treturn;\n\tjanus_mutex_lock(&sessions_mutex);\n\tjanus_voicemail_session *session = janus_voicemail_lookup_session(handle);\n\tif(!session) {\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\tJANUS_LOG(LOG_ERR, \""No session associated with this handle...\\n\"");\n\t\treturn;\n\t}\n\tif(g_atomic_int_get(&session->destroyed)) {\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\treturn;\n\t}\n\tjanus_refcount_increase(&session->ref);\n\tjanus_mutex_unlock(&sessions_mutex);\n\tg_atomic_int_set(&session->hangingup, 0);\n\t/* Only start recording this peer when we get this event */\n\tsession->start_time = janus_get_monotonic_time();\n\tsession->started = TRUE;\n\t/* Prepare JSON event */\n\tjson_t *event = json_object();\n\tjson_object_set_new(event, \""voicemail\"", json_string(\""event\""));\n\tjson_object_set_new(event, \""status\"", json_string(\""started\""));\n\tint ret = gateway->push_event(handle, &janus_voicemail_plugin, NULL, event, NULL);\n\tJANUS_LOG(LOG_VERB, \""  >> Pushing event: %d (%s)\\n\"", ret, janus_get_api_error(ret));\n\tjson_decref(event);\n\tjanus_refcount_decrease(&session->ref);\n}"", ""target"": 0}]","[{""func_name"": ""janus_voicemail_destroy_session"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""void janus_voicemail_destroy_session(janus_plugin_session *handle, int *error) {\n\tif(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {\n\t\t*error = -1;\n\t\treturn;\n\t}\n\tjanus_mutex_lock(&sessions_mutex);\n\tjanus_voicemail_session *session = janus_voicemail_lookup_session(handle);\n\tif(!session) {\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\tJANUS_LOG(LOG_ERR, \""No VoiceMail session associated with this handle...\\n\"");\n\t\t*error = -2;\n\t\treturn;\n\t}\n\tJANUS_LOG(LOG_VERB, \""Removing VoiceMail session...\\n\"");\n\tjanus_voicemail_hangup_media_internal(handle);\n\tg_hash_table_remove(sessions, handle);\n\tjanus_mutex_unlock(&sessions_mutex);\n\n\treturn;\n}""}, {""func_name"": ""janus_voicemail_incoming_rtp"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""void janus_voicemail_incoming_rtp(janus_plugin_session *handle, janus_plugin_rtp *packet) {\n\tif(handle == NULL || g_atomic_int_get(&handle->stopped) || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))\n\t\treturn;\n\tjanus_voicemail_session *session = (janus_voicemail_session *)handle->plugin_handle;\n\tif(!session || g_atomic_int_get(&session->destroyed) || g_atomic_int_get(&session->stopping) ||\n\t\t\t!g_atomic_int_get(&session->started) || session->start_time == 0)\n\t\treturn;\n\tgint64 now = janus_get_monotonic_time();\n\t/* Have 10 seconds passed? */\n\tif((now-session->start_time) >= 10*G_USEC_PER_SEC) {\n\t\t/* FIXME Simulate a \""stop\"" coming from the browser */\n\t\tg_atomic_int_set(&session->started, 0);\n\t\tjanus_refcount_increase(&session->ref);\n\t\tjanus_voicemail_message *msg = g_malloc(sizeof(janus_voicemail_message));\n\t\tmsg->handle = handle;\n\t\tmsg->message = json_pack(\""{ss}\"", \""request\"", \""stop\"");\n\t\tmsg->transaction = NULL;\n\t\tmsg->jsep = NULL;\n\t\tg_async_queue_push(messages, msg);\n\t\treturn;\n\t}\n\t/* Save the frame */\n\tchar *buf = packet->buffer;\n\tuint16_t len = packet->length;\n\tjanus_rtp_header *rtp = (janus_rtp_header *)buf;\n\tuint16_t seq = ntohs(rtp->seq_number);\n\tif(session->seq == 0)\n\t\tsession->seq = seq;\n\tint plen = 0;\n\tconst unsigned char *payload = (const unsigned char *)janus_rtp_payload(buf, len, &plen);\n\tif(!payload) {\n\t\tJANUS_LOG(LOG_ERR, \""Ops! got an error accessing the RTP payload\\n\"");\n\t\treturn;\n\t}\n\togg_packet *op = op_from_pkt(payload, plen);\n\t//~ JANUS_LOG(LOG_VERB, \""\\tWriting at position %d (%d)\\n\"", seq-session->seq+1, 960*(seq-session->seq+1));\n\top->granulepos = 960*(seq-session->seq+1); // FIXME: get this from the toc byte\n\togg_stream_packetin(session->stream, op);\n\tg_free(op);\n\togg_write(session);\n}""}, {""func_name"": ""janus_voicemail_handler"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""static void *janus_voicemail_handler(void *data) {\n\tJANUS_LOG(LOG_VERB, \""Joining VoiceMail handler thread\\n\"");\n\tjanus_voicemail_message *msg = NULL;\n\tint error_code = 0;\n\tchar error_cause[512];\n\tjson_t *root = NULL;\n\twhile(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {\n\t\tmsg = g_async_queue_pop(messages);\n\t\tif(msg == &exit_message)\n\t\t\tbreak;\n\t\tif(msg->handle == NULL) {\n\t\t\tjanus_voicemail_message_free(msg);\n\t\t\tcontinue;\n\t\t}\n\t\tjanus_mutex_lock(&sessions_mutex);\n\t\tjanus_voicemail_session *session = janus_voicemail_lookup_session(msg->handle);\n\t\tif(!session) {\n\t\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t\tJANUS_LOG(LOG_ERR, \""No session associated with this handle...\\n\"");\n\t\t\tjanus_voicemail_message_free(msg);\n\t\t\tcontinue;\n\t\t}\n\t\tif(g_atomic_int_get(&session->destroyed)) {\n\t\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t\tjanus_voicemail_message_free(msg);\n\t\t\tcontinue;\n\t\t}\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t/* Handle request */\n\t\terror_code = 0;\n\t\troot = msg->message;\n\t\tif(msg->message == NULL) {\n\t\t\tJANUS_LOG(LOG_ERR, \""No message??\\n\"");\n\t\t\terror_code = JANUS_VOICEMAIL_ERROR_NO_MESSAGE;\n\t\t\tg_snprintf(error_cause, 512, \""%s\"", \""No message??\"");\n\t\t\tgoto error;\n\t\t}\n\t\tif(!json_is_object(root)) {\n\t\t\tJANUS_LOG(LOG_ERR, \""JSON error: not an object\\n\"");\n\t\t\terror_code = JANUS_VOICEMAIL_ERROR_INVALID_JSON;\n\t\t\tg_snprintf(error_cause, 512, \""JSON error: not an object\"");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Get the request first */\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, request_parameters,\n\t\t\terror_code, error_cause, TRUE,\n\t\t\tJANUS_VOICEMAIL_ERROR_MISSING_ELEMENT, JANUS_VOICEMAIL_ERROR_INVALID_ELEMENT);\n\t\tif(error_code != 0)\n\t\t\tgoto error;\n\t\tjson_t *request = json_object_get(root, \""request\"");\n\t\tconst char *request_text = json_string_value(request);\n\t\tjson_t *event = NULL;\n\t\tgboolean sdp_update = FALSE;\n\t\tif(json_object_get(msg->jsep, \""update\"") != NULL)\n\t\t\tsdp_update = json_is_true(json_object_get(msg->jsep, \""update\""));\n\t\tif(!strcasecmp(request_text, \""record\"")) {\n\t\t\tJANUS_LOG(LOG_VERB, \""Starting new recording\\n\"");\n\t\t\tif(session->file != NULL) {\n\t\t\t\tJANUS_LOG(LOG_ERR, \""Already recording (%s)\\n\"", session->filename ? session->filename : \""??\"");\n\t\t\t\terror_code = JANUS_VOICEMAIL_ERROR_ALREADY_RECORDING;\n\t\t\t\tg_snprintf(error_cause, 512, \""Already recording\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tsession->stream = g_malloc0(sizeof(ogg_stream_state));\n\t\t\tif(ogg_stream_init(session->stream, rand()) < 0) {\n\t\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't initialize Ogg stream state\\n\"");\n\t\t\t\terror_code = JANUS_VOICEMAIL_ERROR_LIBOGG_ERROR;\n\t\t\t\tg_snprintf(error_cause, 512, \""Couldn't initialize Ogg stream state\\n\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tsession->file = fopen(session->filename, \""wb\"");\n\t\t\tif(session->file == NULL) {\n\t\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't open output file\\n\"");\n\t\t\t\terror_code = JANUS_VOICEMAIL_ERROR_IO_ERROR;\n\t\t\t\tg_snprintf(error_cause, 512, \""Couldn't open output file\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tsession->seq = 0;\n\t\t\t/* Write stream headers */\n\t\t\togg_packet *op = op_opushead();\n\t\t\togg_stream_packetin(session->stream, op);\n\t\t\top_free(op);\n\t\t\top = op_opustags();\n\t\t\togg_stream_packetin(session->stream, op);\n\t\t\top_free(op);\n\t\t\togg_flush(session);\n\t\t\t/* Done: now wait for the setup_media callback to be called */\n\t\t\tevent = json_object();\n\t\t\tjson_object_set_new(event, \""voicemail\"", json_string(\""event\""));\n\t\t\tjson_object_set_new(event, \""status\"", json_string(g_atomic_int_get(&session->started) ? \""started\"" : \""starting\""));\n\t\t\t/* Also notify event handlers */\n\t\t\tif(notify_events && gateway->events_is_enabled()) {\n\t\t\t\tjson_t *info = json_object();\n\t\t\t\tjson_object_set_new(info, \""event\"", json_string(\""starting\""));\n\t\t\t\tgateway->notify_event(&janus_voicemail_plugin, session->handle, info);\n\t\t\t}\n\t\t} else if(!strcasecmp(request_text, \""update\"")) {\n\t\t\t/* Only needed in case of renegotiations and ICE restarts (but with 10s messages is this worth it?) */\n\t\t\tJANUS_LOG(LOG_VERB, \""Updating existing recording\\n\"");\n\t\t\tif(session->stream == NULL || !g_atomic_int_get(&session->started)) {\n\t\t\t\tJANUS_LOG(LOG_ERR, \""Invalid state (not recording)\\n\"");\n\t\t\t\terror_code = JANUS_VOICEMAIL_ERROR_INVALID_STATE;\n\t\t\t\tg_snprintf(error_cause, 512, \""Invalid state (not recording)\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tsdp_update = TRUE;\n\t\t\tevent = json_object();\n\t\t\tjson_object_set_new(event, \""voicemail\"", json_string(\""event\""));\n\t\t\tjson_object_set_new(event, \""status\"", json_string(\""updating\""));\n\t\t} else if(!strcasecmp(request_text, \""stop\"")) {\n\t\t\t/* Stop the recording */\n\t\t\tg_atomic_int_set(&session->started, 0);\n\t\t\tg_atomic_int_set(&session->stopping, 1);\n\t\t\tif(session->file)\n\t\t\t\tfclose(session->file);\n\t\t\tsession->file = NULL;\n\t\t\tif(session->stream)\n\t\t\t\togg_stream_destroy(session->stream);\n\t\t\tsession->stream = NULL;\n\t\t\t/* Done: send the event and close the handle */\n\t\t\tevent = json_object();\n\t\t\tjson_object_set_new(event, \""voicemail\"", json_string(\""event\""));\n\t\t\tjson_object_set_new(event, \""status\"", json_string(\""done\""));\n\t\t\tif(session->recording_id > 0) {\n\t\t\t\tchar url[1024];\n\t\t\t\tg_snprintf(url, 1024, \""%s/janus-voicemail-%\""SCNu64\"".opus\"", recordings_base, session->recording_id);\n\t\t\t\tjson_object_set_new(event, \""recording\"", json_string(url));\n\t\t\t}\n\t\t\t/* Also notify event handlers */\n\t\t\tif(notify_events && gateway->events_is_enabled()) {\n\t\t\t\tjson_t *info = json_object();\n\t\t\t\tjson_object_set_new(info, \""event\"", json_string(\""done\""));\n\t\t\t\tgateway->notify_event(&janus_voicemail_plugin, session->handle, info);\n\t\t\t}\n\t\t} else {\n\t\t\tJANUS_LOG(LOG_ERR, \""Unknown request '%s'\\n\"", request_text);\n\t\t\terror_code = JANUS_VOICEMAIL_ERROR_INVALID_REQUEST;\n\t\t\tg_snprintf(error_cause, 512, \""Unknown request '%s'\"", request_text);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* Prepare JSON event */\n\t\tJANUS_LOG(LOG_VERB, \""Preparing JSON event as a reply\\n\"");\n\t\t/* Any SDP to handle? */\n\t\tconst char *msg_sdp_type = json_string_value(json_object_get(msg->jsep, \""type\""));\n\t\tconst char *msg_sdp = json_string_value(json_object_get(msg->jsep, \""sdp\""));\n\t\tif(!msg_sdp) {\n\t\t\tint ret = gateway->push_event(msg->handle, &janus_voicemail_plugin, msg->transaction, event, NULL);\n\t\t\tJANUS_LOG(LOG_VERB, \""  >> %d (%s)\\n\"", ret, janus_get_api_error(ret));\n\t\t\tjson_decref(event);\n\t\t} else {\n\t\t\tJANUS_LOG(LOG_VERB, \""This is involving a negotiation (%s) as well:\\n%s\\n\"", msg_sdp_type, msg_sdp);\n\t\t\tconst char *type = NULL;\n\t\t\tif(!strcasecmp(msg_sdp_type, \""offer\""))\n\t\t\t\ttype = \""answer\"";\n\t\t\tif(!strcasecmp(msg_sdp_type, \""answer\""))\n\t\t\t\ttype = \""offer\"";\n\t\t\tif(sdp_update) {\n\t\t\t\t/* Renegotiation: make sure the user provided an offer, and send answer */\n\t\t\t\tJANUS_LOG(LOG_VERB, \""Request to update existing connection\\n\"");\n\t\t\t\tsession->sdp_version++;\t\t/* This needs to be increased when it changes */\n\t\t\t} else {\n\t\t\t\t/* New PeerConnection */\n\t\t\t\tsession->sdp_version = 1;\t/* This needs to be increased when it changes */\n\t\t\t\tsession->sdp_sessid = janus_get_real_time();\n\t\t\t}\n\t\t\t/* Fill the SDP template and use that as our answer */\n\t\t\tchar sdp[1024];\n\t\t\t/* What is the Opus payload type? */\n\t\t\tint opus_pt = janus_get_codec_pt(msg_sdp, \""opus\"");\n\t\t\tJANUS_LOG(LOG_VERB, \""Opus payload type is %d\\n\"", opus_pt);\n\t\t\tg_snprintf(sdp, 1024, sdp_template,\n\t\t\t\tsession->sdp_sessid,\n\t\t\t\tsession->sdp_version,\n\t\t\t\tsession->recording_id,\t\t\t/* Recording ID */\n\t\t\t\topus_pt,\t\t\t\t\t\t/* Opus payload type */\n\t\t\t\topus_pt\t\t\t\t\t\t\t/* Opus payload type */);\n\t\t\t/* Did the peer negotiate video? */\n\t\t\tif(strstr(msg_sdp, \""m=video\"") != NULL) {\n\t\t\t\t/* If so, reject it */\n\t\t\t\tg_strlcat(sdp, \""m=video 0 RTP/SAVPF 0\\r\\n\"", 1024);\n\t\t\t}\n\t\t\tjson_t *jsep = json_pack(\""{ssss}\"", \""type\"", type, \""sdp\"", sdp);\n\t\t\t/* How long will the Janus core take to push the event? */\n\t\t\tg_atomic_int_set(&session->hangingup, 0);\n\t\t\tgint64 start = janus_get_monotonic_time();\n\t\t\tint res = gateway->push_event(msg->handle, &janus_voicemail_plugin, msg->transaction, event, jsep);\n\t\t\tJANUS_LOG(LOG_VERB, \""  >> Pushing event: %d (took %\""SCNu64\"" us)\\n\"", res, janus_get_monotonic_time()-start);\n\t\t\tjson_decref(event);\n\t\t\tjson_decref(jsep);\n\t\t\tif(res != JANUS_OK) {\n\t\t\t\t/* TODO Failed to negotiate? We should remove this participant */\n\t\t\t}\n\t\t}\n\n\t\t/* Tear down the session if we're done */\n\t\tif(g_atomic_int_get(&session->stopping))\n\t\t\tgateway->end_session(session->handle);\n\t\tjanus_voicemail_message_free(msg);\n\n\t\tcontinue;\n\nerror:\n\t\t{\n\t\t\t/* Prepare JSON error event */\n\t\t\tjson_t *event = json_object();\n\t\t\tjson_object_set_new(event, \""voicemail\"", json_string(\""event\""));\n\t\t\tjson_object_set_new(event, \""error_code\"", json_integer(error_code));\n\t\t\tjson_object_set_new(event, \""error\"", json_string(error_cause));\n\t\t\tint ret = gateway->push_event(msg->handle, &janus_voicemail_plugin, msg->transaction, event, NULL);\n\t\t\tJANUS_LOG(LOG_VERB, \""  >> Pushing event: %d (%s)\\n\"", ret, janus_get_api_error(ret));\n\t\t\tjson_decref(event);\n\t\t\tjanus_voicemail_message_free(msg);\n\t\t}\n\t}\n\tJANUS_LOG(LOG_VERB, \""Leaving VoiceMail handler thread\\n\"");\n\treturn NULL;\n}""}, {""func_name"": ""janus_voicemail_hangup_media_internal"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""static void janus_voicemail_hangup_media_internal(janus_plugin_session *handle) {\n\tif(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))\n\t\treturn;\n\tjanus_voicemail_session *session = janus_voicemail_lookup_session(handle);\n\tif(!session) {\n\t\tJANUS_LOG(LOG_ERR, \""No session associated with this handle...\\n\"");\n\t\treturn;\n\t}\n\tg_atomic_int_set(&session->started, 0);\n\tif(g_atomic_int_get(&session->destroyed))\n\t\treturn;\n\tif(!g_atomic_int_compare_and_exchange(&session->hangingup, 0, 1))\n\t\treturn;\n\t/* Close and reset stuff */\n\tif(session->file)\n\t\tfclose(session->file);\n\tsession->file = NULL;\n\tif(session->stream)\n\t\togg_stream_destroy(session->stream);\n\tsession->stream = NULL;\n\tg_atomic_int_set(&session->hangingup, 0);\n}""}, {""func_name"": ""janus_voicemail_create_session"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""void janus_voicemail_create_session(janus_plugin_session *handle, int *error) {\n\tif(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {\n\t\t*error = -1;\n\t\treturn;\n\t}\n\tjanus_voicemail_session *session = g_malloc0(sizeof(janus_voicemail_session));\n\tsession->handle = handle;\n\tsession->recording_id = janus_random_uint64();\n\tsession->start_time = 0;\n\tsession->stream = NULL;\n\tchar f[255];\n\tg_snprintf(f, 255, \""%s/janus-voicemail-%\""SCNu64\"".opus\"", recordings_path, session->recording_id);\n\tsession->filename = g_strdup(f);\n\tsession->file = NULL;\n\tsession->seq = 0;\n\tg_atomic_int_set(&session->started, 0);\n\tg_atomic_int_set(&session->stopping, 0);\n\tg_atomic_int_set(&session->hangingup, 0);\n\tg_atomic_int_set(&session->destroyed, 0);\n\tjanus_refcount_init(&session->ref, janus_voicemail_session_free);\n\thandle->plugin_handle = session;\n\n\tjanus_mutex_lock(&sessions_mutex);\n\tg_hash_table_insert(sessions, handle, session);\n\tjanus_mutex_unlock(&sessions_mutex);\n\n\treturn;\n}""}, {""func_name"": ""janus_voicemail_session_free"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""static void janus_voicemail_session_free(const janus_refcount *session_ref) {\n\tjanus_voicemail_session *session = janus_refcount_containerof(session_ref, janus_voicemail_session, ref);\n\t/* Remove the reference to the core plugin session */\n\tjanus_refcount_decrease(&session->handle->ref);\n\t/* This session can be destroyed, free all the resources */\n\tg_free(session->filename);\n\tif(session->file)\n\t\tfclose(session->file);\n\tg_free(session);\n}""}, {""func_name"": ""janus_voicemail_setup_media"", ""file_path"": ""plugins/janus_voicemail.c"", ""func_code"": ""void janus_voicemail_setup_media(janus_plugin_session *handle) {\n\tJANUS_LOG(LOG_INFO, \""[%s-%p] WebRTC media is now available\\n\"", JANUS_VOICEMAIL_PACKAGE, handle);\n\tif(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))\n\t\treturn;\n\tjanus_mutex_lock(&sessions_mutex);\n\tjanus_voicemail_session *session = janus_voicemail_lookup_session(handle);\n\tif(!session) {\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\tJANUS_LOG(LOG_ERR, \""No session associated with this handle...\\n\"");\n\t\treturn;\n\t}\n\tif(g_atomic_int_get(&session->destroyed)) {\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\treturn;\n\t}\n\tjanus_refcount_increase(&session->ref);\n\tjanus_mutex_unlock(&sessions_mutex);\n\tg_atomic_int_set(&session->hangingup, 0);\n\t/* Only start recording this peer when we get this event */\n\tsession->start_time = janus_get_monotonic_time();\n\tg_atomic_int_set(&session->started, 1);\n\t/* Prepare JSON event */\n\tjson_t *event = json_object();\n\tjson_object_set_new(event, \""voicemail\"", json_string(\""event\""));\n\tjson_object_set_new(event, \""status\"", json_string(\""started\""));\n\tint ret = gateway->push_event(handle, &janus_voicemail_plugin, NULL, event, NULL);\n\tJANUS_LOG(LOG_VERB, \""  >> Pushing event: %d (%s)\\n\"", ret, janus_get_api_error(ret));\n\tjson_decref(event);\n\tjanus_refcount_decrease(&session->ref);\n}""}]","{""function"": 3, ""code"": 3, ""value"": 1}","[{""source"": ""func_info(file:janus_voicemail.c, func:janus_voicemail_destroy_session)"", ""result"": [{""code"": ""void janus_voicemail_destroy_session(janus_plugin_session *handle, int *error) {\n\tif(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {\n\t\t*error = -1;\n\t\treturn;\n\t}\n\tjanus_mutex_lock(&sessions_mutex);\n\tjanus_voicemail_session *session = janus_voicemail_lookup_session(handle);\n\tif(!session) {\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\tJANUS_LOG(LOG_ERR, \""No VoiceMail session associated with this handle...\\n\"");\n\t\t*error = -2;\n\t\treturn;\n\t}\n\tJANUS_LOG(LOG_VERB, \""Removing VoiceMail session...\\n\"");\n\tjanus_voicemail_hangup_media_internal(handle);\n\thandle->plugin_handle = NULL;\n\tg_hash_table_remove(sessions, handle);\n\tjanus_mutex_unlock(&sessions_mutex);\n\n\treturn;\n}\n"", ""start_line"": 459, ""end_line"": 479, ""full_name"": ""janus_voicemail_destroy_session"", ""file_path"": ""plugins/janus_voicemail.c""}]}, {""source"": ""code_info(file:janus_voicemail.c, lines:470-475)"", ""result"": ""\t\treturn;\n\t}\n\tJANUS_LOG(LOG_VERB, \""Removing VoiceMail session...\\n\"");\n\tjanus_voicemail_hangup_media_internal(handle);\n\thandle->plugin_handle = NULL;\n\tg_hash_table_remove(sessions, handle);\n""}, {""source"": ""func_info(file:janus_voicemail.c, func:janus_voicemail_lookup_session)"", ""result"": [{""code"": ""static janus_voicemail_session *janus_voicemail_lookup_session(janus_plugin_session *handle) {\n\tjanus_voicemail_session *session = NULL;\n\tif (g_hash_table_contains(sessions, handle)) {\n\t\tsession = (janus_voicemail_session *)handle->plugin_handle;\n\t}\n\treturn session;\n}"", ""start_line"": 422, ""end_line"": 428, ""full_name"": ""janus_voicemail_lookup_session"", ""file_path"": ""plugins/janus_voicemail.c""}]}, {""source"": ""code_info(file:janus_voicemail.c, lines:440-450)"", ""result"": ""\tchar f[255];\n\tg_snprintf(f, 255, \""%s/janus-voicemail-%\""SCNu64\"".opus\"", recordings_path, session->recording_id);\n\tsession->filename = g_strdup(f);\n\tsession->file = NULL;\n\tsession->seq = 0;\n\tsession->started = FALSE;\n\tsession->stopping = FALSE;\n\tg_atomic_int_set(&session->hangingup, 0);\n\tg_atomic_int_set(&session->destroyed, 0);\n\tjanus_refcount_init(&session->ref, janus_voicemail_session_free);\n\thandle->plugin_handle = session;\n""}, {""source"": ""func_info(file:janus_voicemail.c, func:janus_voicemail_incoming_rtp)"", ""result"": [{""code"": ""void janus_voicemail_incoming_rtp(janus_plugin_session *handle, janus_plugin_rtp *packet) {\n\tif(handle == NULL || g_atomic_int_get(&handle->stopped) || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))\n\t\treturn;\n\tjanus_voicemail_session *session = (janus_voicemail_session *)handle->plugin_handle;\n\tif(!session || g_atomic_int_get(&session->destroyed) || session->stopping || !session->started || session->start_time == 0)\n\t\treturn;\n\tgint64 now = janus_get_monotonic_time();\n\t/* Have 10 seconds passed? */\n\tif((now-session->start_time) >= 10*G_USEC_PER_SEC) {\n\t\t/* FIXME Simulate a \""stop\"" coming from the browser */\n\t\tsession->started = FALSE;\n\t\tjanus_refcount_increase(&session->ref);\n\t\tjanus_voicemail_message *msg = g_malloc(sizeof(janus_voicemail_message));\n\t\tmsg->handle = handle;\n\t\tmsg->message = json_pack(\""{ss}\"", \""request\"", \""stop\"");\n\t\tmsg->transaction = NULL;\n\t\tmsg->jsep = NULL;\n\t\tg_async_queue_push(messages, msg);\n\t\treturn;\n\t}\n\t/* Save the frame */\n\tchar *buf = packet->buffer;\n\tuint16_t len = packet->length;\n\tjanus_rtp_header *rtp = (janus_rtp_header *)buf;\n\tuint16_t seq = ntohs(rtp->seq_number);\n\tif(session->seq == 0)\n\t\tsession->seq = seq;\n\tint plen = 0;\n\tconst unsigned char *payload = (const unsigned char *)janus_rtp_payload(buf, len, &plen);\n\tif(!payload) {\n\t\tJANUS_LOG(LOG_ERR, \""Ops! got an error accessing the RTP payload\\n\"");\n\t\treturn;\n\t}\n\togg_packet *op = op_from_pkt(payload, plen);\n\t//~ JANUS_LOG(LOG_VERB, \""\\tWriting at position %d (%d)\\n\"", seq-session->seq+1, 960*(seq-session->seq+1));\n\top->granulepos = 960*(seq-session->seq+1); // FIXME: get this from the toc byte\n\togg_stream_packetin(session->stream, op);\n\tg_free(op);\n\togg_write(session);\n}\n"", ""start_line"": 564, ""end_line"": 603, ""full_name"": ""janus_voicemail_incoming_rtp"", ""file_path"": ""plugins/janus_voicemail.c""}]}, {""source"": ""code_info(file:janus_voicemail.c, lines:420-430)"", ""result"": ""}\n\nstatic janus_voicemail_session *janus_voicemail_lookup_session(janus_plugin_session *handle) {\n\tjanus_voicemail_session *session = NULL;\n\tif (g_hash_table_contains(sessions, handle)) {\n\t\tsession = (janus_voicemail_session *)handle->plugin_handle;\n\t}\n\treturn session;\n}\n\nvoid janus_voicemail_create_session(janus_plugin_session *handle, int *error) {\n""}, {""source"": ""value_info(file:janus_voicemail.c, value:handle->plugin_handle)"", ""result"": {""value_trace"": [{""full_code"": ""handle->plugin_handle = session"", ""line"": 450, ""func_name"": ""janus_voicemail_create_session""}, {""full_code"": ""handle->plugin_handle = NULL"", ""line"": 474, ""func_name"": ""janus_voicemail_destroy_session""}], ""struct_var"": ""handle"", ""struct_type"": null, ""struct_definition"": null}}]","Race conditions arise from non-atomic access to `session->started` (e.g., plugins/janus_voicemail.c:566, 751) and `session->stopping` (plugins/janus_voicemail.c:752) across threads. The `janus_voicemail_lookup_session` function (plugins/janus_voicemail.c:422-428) accesses `handle->plugin_handle` without holding `sessions_mutex`, which is used in `janus_voicemail_destroy_session` (plugins/janus_voicemail.c:472-473). This allows concurrent destruction of a session while it is being accessed, leading to invalid memory accesses. The patch fixes this by replacing direct assignments with atomic operations and ensuring proper mutex usage during session destruction.",0.95,./github/other_context/CVE-2020-10576
54,CVE-2020-10577,CWE-362,c_cpp,"An issue was discovered in Janus through 0.9.1. janus.c has multiple concurrent threads that misuse the source property of a session, leading to a race condition when claiming sessions.",https://github.com/meetecho/janus-gateway/commit/bc319056603295953f4a70999bc4553785c6e5ef,Fix rare race condition when claiming sessions,4,"[{""func_name"": ""janus_process_incoming_request"", ""file_path"": ""janus.c"", ""func_code"": ""int janus_process_incoming_request(janus_request *request) {\n\tint ret = -1;\n\tif(request == NULL) {\n\t\tJANUS_LOG(LOG_ERR, \""Missing request or payload to process, giving up...\\n\"");\n\t\treturn ret;\n\t}\n\tint error_code = 0;\n\tchar error_cause[100];\n\tjson_t *root = request->message;\n\t/* Ok, let's start with the ids */\n\tguint64 session_id = 0, handle_id = 0;\n\tjson_t *s = json_object_get(root, \""session_id\"");\n\tif(s && json_is_integer(s))\n\t\tsession_id = json_integer_value(s);\n\tjson_t *h = json_object_get(root, \""handle_id\"");\n\tif(h && json_is_integer(h))\n\t\thandle_id = json_integer_value(h);\n\n\tjanus_session *session = NULL;\n\tjanus_ice_handle *handle = NULL;\n\n\t/* Get transaction and message request */\n\tJANUS_VALIDATE_JSON_OBJECT(root, incoming_request_parameters,\n\t\terror_code, error_cause, FALSE,\n\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\tif(error_code != 0) {\n\t\tret = janus_process_error_string(request, session_id, NULL, error_code, error_cause);\n\t\tgoto jsondone;\n\t}\n\tjson_t *transaction = json_object_get(root, \""transaction\"");\n\tconst gchar *transaction_text = json_string_value(transaction);\n\tjson_t *message = json_object_get(root, \""janus\"");\n\tconst gchar *message_text = json_string_value(message);\n\n\tif(session_id == 0 && handle_id == 0) {\n\t\t/* Can only be a 'Create new session', a 'Get info' or a 'Ping/Pong' request */\n\t\tif(!strcasecmp(message_text, \""info\"")) {\n\t\t\tret = janus_process_success(request, janus_info(transaction_text));\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(!strcasecmp(message_text, \""ping\"")) {\n\t\t\t/* Prepare JSON reply */\n\t\t\tjson_t *reply = janus_create_message(\""pong\"", 0, transaction_text);\n\t\t\tret = janus_process_success(request, reply);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(strcasecmp(message_text, \""create\"")) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Make sure we're accepting new sessions */\n\t\tif(!accept_new_sessions) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_NOT_ACCEPTING_SESSIONS, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Any secret/token to check? */\n\t\tret = janus_request_check_secret(request, session_id, transaction_text);\n\t\tif(ret != 0) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = 0;\n\t\tjson_t *id = json_object_get(root, \""id\"");\n\t\tif(id != NULL) {\n\t\t\t/* The application provided the session ID to use */\n\t\t\tsession_id = json_integer_value(id);\n\t\t\tif(session_id > 0 && (session = janus_session_find(session_id)) != NULL) {\n\t\t\t\t/* Session ID already taken */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_CONFLICT, \""Session ID already in use\"");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t}\n\t\t/* Handle it */\n\t\tsession = janus_session_create(session_id);\n\t\tif(session == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Memory error\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = session->session_id;\n\t\t/* We increase the counter as this request is using the session */\n\t\tjanus_refcount_increase(&session->ref);\n\t\t/* Take note of the request source that originated this session (HTTP, WebSockets, RabbitMQ?) */\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the source that a new session has been created */\n\t\trequest->transport->session_created(request->instance, session->session_id);\n\t\t/* Notify event handlers */\n\t\tif(janus_events_is_enabled()) {\n\t\t\t/* Session created, add info on the transport that originated it */\n\t\t\tjson_t *transport = json_object();\n\t\t\tjson_object_set_new(transport, \""transport\"", json_string(session->source->transport->get_package()));\n\t\t\tchar id[32];\n\t\t\tmemset(id, 0, sizeof(id));\n\t\t\tg_snprintf(id, sizeof(id), \""%p\"", session->source->instance);\n\t\t\tjson_object_set_new(transport, \""id\"", json_string(id));\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \""created\"", transport);\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", 0, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \""id\"", json_integer(session_id));\n\t\tjson_object_set_new(reply, \""data\"", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\tgoto jsondone;\n\t}\n\tif(session_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \""Invalid session\\n\"");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\tif(h && handle_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \""Invalid handle\\n\"");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* Go on with the processing */\n\tret = janus_request_check_secret(request, session_id, transaction_text);\n\tif(ret != 0) {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* If we got here, make sure we have a session (and/or a handle) */\n\tsession = janus_session_find(session_id);\n\tif(!session) {\n\t\tJANUS_LOG(LOG_ERR, \""Couldn't find any session %\""SCNu64\""...\\n\"", session_id);\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, \""No such session %\""SCNu64\""\"", session_id);\n\t\tgoto jsondone;\n\t}\n\t/* Update the last activity timer */\n\tsession->last_activity = janus_get_monotonic_time();\n\thandle = NULL;\n\tif(handle_id > 0) {\n\t\thandle = janus_session_handles_find(session, handle_id);\n\t\tif(!handle) {\n\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't find any handle %\""SCNu64\"" in session %\""SCNu64\""...\\n\"", handle_id, session_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_HANDLE_NOT_FOUND, \""No such handle %\""SCNu64\"" in session %\""SCNu64\""\"", handle_id, session_id);\n\t\t\tgoto jsondone;\n\t\t}\n\t}\n\n\t/* What is this? */\n\tif(!strcasecmp(message_text, \""keepalive\"")) {\n\t\t/* Just a keep-alive message, reply with an ack */\n\t\tJANUS_LOG(LOG_VERB, \""Got a keep-alive on session %\""SCNu64\""\\n\"", session_id);\n\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""attach\"")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Attach is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, attach_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *plugin = json_object_get(root, \""plugin\"");\n\t\tconst gchar *plugin_text = json_string_value(plugin);\n\t\tjanus_plugin *plugin_t = janus_plugin_find(plugin_text);\n\t\tif(plugin_t == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_NOT_FOUND, \""No such plugin '%s'\"", plugin_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* If the auth token mechanism is enabled, we should check if this token can access this plugin */\n\t\tif(janus_auth_is_enabled()) {\n\t\t\tjson_t *token = json_object_get(root, \""token\"");\n\t\t\tif(token != NULL) {\n\t\t\t\tconst char *token_value = json_string_value(token);\n\t\t\t\tif(token_value && !janus_auth_check_plugin(token_value, plugin_t)) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Token '%s' can't access plugin '%s'\\n\"", token_value, plugin_text);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED_PLUGIN, \""Provided token can't access plugin '%s'\"", plugin_text);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjson_t *opaque = json_object_get(root, \""opaque_id\"");\n\t\tconst char *opaque_id = opaque ? json_string_value(opaque) : NULL;\n\t\t/* Create handle */\n\t\thandle = janus_ice_handle_create(session, opaque_id);\n\t\tif(handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Memory error\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\thandle_id = handle->handle_id;\n\t\t/* We increase the counter as this request is using the handle */\n\t\tjanus_refcount_increase(&handle->ref);\n\t\t/* Attach to the plugin */\n\t\tint error = 0;\n\t\tif((error = janus_ice_handle_attach_plugin(session, handle, plugin_t)) != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tjanus_session_handles_remove(session, handle);\n\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't attach to plugin '%s', error '%d'\\n\"", plugin_text, error);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_ATTACH, \""Couldn't attach to plugin: error '%d'\"", error);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \""id\"", json_integer(handle_id));\n\t\tjson_object_set_new(reply, \""data\"", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""destroy\"")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Query is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&sessions_mutex);\n\t\tg_hash_table_remove(sessions, &session->session_id);\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t/* Notify the source that the session has been destroyed */\n\t\tif(session->source && session->source->transport) {\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, FALSE);\n\t\t}\n\t\t/* Schedule the session for deletion */\n\t\tjanus_session_destroy(session);\n\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\t/* Notify event handlers as well */\n\t\tif(janus_events_is_enabled())\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \""destroyed\"", NULL);\n\t} else if(!strcasecmp(message_text, \""detach\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""No plugin to detach from\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tint error = janus_session_handles_remove(session, handle);\n\t\tif(error != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""Couldn't detach from plugin: error '%d'\"", error);\n\t\t\t/* TODO Delete handle instance */\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""hangup\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""No plugin attached\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_ice_webrtc_hangup(handle, \""Janus API\"");\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""claim\"")) {\n\t\tjanus_mutex_lock(&session->mutex);\n\t\tif(session->source != NULL) {\n\t\t\t/* Notify the old transport that this session is over for them, but has been reclaimed */\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, TRUE);\n\t\t\tjanus_request_destroy(session->source);\n\t\t\tsession->source = NULL;\n\t\t}\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the new transport that it has claimed a session */\n\t\tsession->source->transport->session_claimed(session->source->instance, session->session_id);\n\t\t/* Previous transport may be gone, clear flag. */\n\t\tg_atomic_int_set(&session->transport_gone, 0);\n\t\tjanus_mutex_unlock(&session->mutex);\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = json_object();\n\t\tjson_object_set_new(reply, \""janus\"", json_string(\""success\""));\n\t\tjson_object_set_new(reply, \""session_id\"", json_integer(session_id));\n\t\tjson_object_set_new(reply, \""transaction\"", json_string(transaction_text));\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""message\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this message\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin *plugin_t = (janus_plugin *)handle->app;\n\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] There's a message for %s\\n\"", handle->handle_id, plugin_t->get_name());\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, body_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *body = json_object_get(root, \""body\"");\n\t\t/* Is there an SDP attached? */\n\t\tjson_t *jsep = json_object_get(root, \""jsep\"");\n\t\tchar *jsep_type = NULL;\n\t\tchar *jsep_sdp = NULL, *jsep_sdp_stripped = NULL;\n\t\tgboolean renegotiation = FALSE;\n\t\tif(jsep != NULL) {\n\t\t\tif(!json_is_object(jsep)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON_OBJECT, \""Invalid jsep object\"");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_VALIDATE_JSON_OBJECT_FORMAT(\""JSEP error: missing mandatory element (%s)\"",\n\t\t\t\t\""JSEP error: invalid element type (%s should be %s)\"",\n\t\t\t\tjsep, jsep_parameters, error_code, error_cause, FALSE,\n\t\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\t\tif(error_code != 0) {\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *type = json_object_get(jsep, \""type\"");\n\t\t\tjsep_type = g_strdup(json_string_value(type));\n\t\t\ttype = NULL;\n\t\t\tgboolean do_trickle = TRUE;\n\t\t\tjson_t *jsep_trickle = json_object_get(jsep, \""trickle\"");\n\t\t\tdo_trickle = jsep_trickle ? json_is_true(jsep_trickle) : TRUE;\n\t\t\t/* Are we still cleaning up from a previous media session? */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Still cleaning up from a previous media session, let's wait a bit...\\n\"", handle->handle_id);\n\t\t\t\tgint64 waited = 0;\n\t\t\t\twhile(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\t\tg_usleep(100000);\n\t\t\t\t\twaited += 100000;\n\t\t\t\t\tif(waited >= 3*G_USEC_PER_SEC) {\n\t\t\t\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""]   -- Waited 3 seconds, that's enough!\\n\"", handle->handle_id);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \""Still cleaning a previous session\"");\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if we're renegotiating (if we have an answer, we did an offer/answer round already) */\n\t\t\trenegotiation = janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t/* Check the JSEP type */\n\t\t\tjanus_mutex_lock(&handle->mutex);\n\t\t\tint offer = 0;\n\t\t\tif(!strcasecmp(jsep_type, \""offer\"")) {\n\t\t\t\toffer = 1;\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t} else if(!strcasecmp(jsep_type, \""answer\"")) {\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t\toffer = 0;\n\t\t\t} else {\n\t\t\t\t/* TODO Handle other message types as well */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_UNKNOWN_TYPE, \""JSEP error: unknown message type '%s'\"", jsep_type);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *sdp = json_object_get(jsep, \""sdp\"");\n\t\t\tjsep_sdp = (char *)json_string_value(sdp);\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Remote SDP:\\n%s\"", handle->handle_id, jsep_sdp);\n\t\t\t/* Is this valid SDP? */\n\t\t\tchar error_str[512];\n\t\t\tint audio = 0, video = 0, data = 0;\n\t\t\tjanus_sdp *parsed_sdp = janus_sdp_preparse(handle, jsep_sdp, error_str, sizeof(error_str), &audio, &video, &data);\n\t\t\tif(parsed_sdp == NULL) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, error_str);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Notify event handlers */\n\t\t\tif(janus_events_is_enabled()) {\n\t\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_JSEP, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\t\tsession_id, handle_id, handle->opaque_id, \""remote\"", jsep_type, jsep_sdp);\n\t\t\t}\n\t\t\t/* FIXME We're only handling single audio/video lines for now... */\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Audio %s been negotiated, Video %s been negotiated, SCTP/DataChannels %s been negotiated\\n\"",\n\t\t\t                    handle->handle_id,\n\t\t\t                    audio ? \""has\"" : \""has NOT\"",\n\t\t\t                    video ? \""has\"" : \""has NOT\"",\n\t\t\t                    data ? \""have\"" : \""have NOT\"");\n\t\t\tif(audio > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one audio line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n\t\t\tif(video > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one video line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n\t\t\tif(data > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one data line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n#ifndef HAVE_SCTP\n\t\t\tif(data) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""]   -- DataChannels have been negotiated, but support for them has not been compiled...\\n\"", handle->handle_id);\n\t\t\t}\n#endif\n\t\t\t/* We behave differently if it's a new session or an update... */\n\t\t\tif(!renegotiation) {\n\t\t\t\t/* New session */\n\t\t\t\tif(offer) {\n\t\t\t\t\t/* Setup ICE locally (we received an offer) */\n\t\t\t\t\tif(janus_ice_setup_local(handle, offer, audio, video, data, do_trickle) < 0) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error setting ICE locally\\n\"");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Error setting ICE locally\"");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Make sure we're waiting for an ANSWER in the first place */\n\t\t\t\t\tif(!handle->agent) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Unexpected ANSWER (did we offer?)\\n\"");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \""Unexpected ANSWER (did we offer?)\"");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, FALSE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error processing SDP\\n\"");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \""Error processing SDP\"");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Set remote candidates now (we received an answer) */\n\t\t\t\t\tif(do_trickle) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t}\n\t\t\t\t\tjanus_request_ice_handle_answer(handle, audio, video, data, jsep_sdp);\n\t\t\t\t} else {\n\t\t\t\t\t/* Check if the mid RTP extension is being negotiated */\n\t\t\t\t\thandle->stream->mid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_MID);\n\t\t\t\t\t/* Check if the RTP Stream ID extension is being negotiated */\n\t\t\t\t\thandle->stream->rid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_RID);\n\t\t\t\t\thandle->stream->ridrtx_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_REPAIRED_RID);\n\t\t\t\t\t/* Check if the audio level ID extension is being negotiated */\n\t\t\t\t\thandle->stream->audiolevel_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_AUDIO_LEVEL);\n\t\t\t\t\t/* Check if the video orientation ID extension is being negotiated */\n\t\t\t\t\thandle->stream->videoorientation_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_VIDEO_ORIENTATION);\n\t\t\t\t\t/* Check if the frame marking ID extension is being negotiated */\n\t\t\t\t\thandle->stream->framemarking_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_FRAME_MARKING);\n\t\t\t\t\t/* Check if transport wide CC is supported */\n\t\t\t\t\tint transport_wide_cc_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC);\n\t\t\t\t\thandle->stream->do_transport_wide_cc = transport_wide_cc_ext_id > 0 ? TRUE : FALSE;\n\t\t\t\t\thandle->stream->transport_wide_cc_ext_id = transport_wide_cc_ext_id;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* FIXME This is a renegotiation: we can currently only handle simple changes in media\n\t\t\t\t * direction and ICE restarts: anything more complex than that will result in an error */\n\t\t\t\tJANUS_LOG(LOG_INFO, \""[%\""SCNu64\""] Negotiation update, checking what changed...\\n\"", handle->handle_id);\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, TRUE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error processing SDP\\n\"");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \""Error processing SDP\"");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART)) {\n\t\t\t\t\tJANUS_LOG(LOG_INFO, \""[%\""SCNu64\""] Restarting ICE...\\n\"", handle->handle_id);\n\t\t\t\t\t/* Update remote credentials for ICE */\n\t\t\t\t\tif(handle->stream) {\n\t\t\t\t\t\tnice_agent_set_remote_credentials(handle->agent, handle->stream->stream_id,\n\t\t\t\t\t\t\thandle->stream->ruser, handle->stream->rpass);\n\t\t\t\t\t}\n\t\t\t\t\t/* FIXME We only need to do that for offers: if it's an answer, we did that already */\n\t\t\t\t\tif(offer) {\n\t\t\t\t\t\tjanus_ice_restart(handle);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART);\n\t\t\t\t\t}\n\t\t\t\t\t/* If we're full-trickling, we'll need to resend the candidates later */\n\t\t\t\t\tif(janus_ice_is_full_trickle_enabled()) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_RESEND_TRICKLES);\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef HAVE_SCTP\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Were datachannels just added? */\n\t\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_DATA_CHANNELS)) {\n\t\t\t\t\t\tjanus_ice_stream *stream = handle->stream;\n\t\t\t\t\t\tif(stream != NULL && stream->component != NULL\n\t\t\t\t\t\t\t\t&& stream->component->dtls != NULL && stream->component->dtls->sctp == NULL) {\n\t\t\t\t\t\t\t/* Create SCTP association as well */\n\t\t\t\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] Creating datachannels...\\n\"", handle->handle_id);\n\t\t\t\t\t\t\tjanus_dtls_srtp_create_sctp(stream->component->dtls);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tchar *tmp = handle->remote_sdp;\n\t\t\thandle->remote_sdp = g_strdup(jsep_sdp);\n\t\t\tg_free(tmp);\n\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t/* Anonymize SDP */\n\t\t\tif(janus_sdp_anonymize(parsed_sdp) < 0) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \""JSEP error: invalid SDP\"");\n\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjsep_sdp_stripped = janus_sdp_write(parsed_sdp);\n\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\tsdp = NULL;\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t}\n\n\t\t/* Make sure the app handle is still valid */\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this message\"");\n\t\t\tg_free(jsep_type);\n\t\t\tg_free(jsep_sdp_stripped);\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\tgoto jsondone;\n\t\t}\n\n\t\t/* Send the message to the plugin (which must eventually free transaction_text and unref the two objects, body and jsep) */\n\t\tjson_incref(body);\n\t\tjson_t *body_jsep = NULL;\n\t\tif(jsep_sdp_stripped) {\n\t\t\tbody_jsep = json_pack(\""{ssss}\"", \""type\"", jsep_type, \""sdp\"", jsep_sdp_stripped);\n\t\t\t/* Check if simulcasting is enabled */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_VIDEO)) {\n\t\t\t\tif(handle->stream && (handle->stream->rid[0] || handle->stream->video_ssrc_peer[1])) {\n\t\t\t\t\tjson_t *simulcast = json_object();\n\t\t\t\t\t/* If we have rids, pass those, otherwise pass the SSRCs */\n\t\t\t\t\tif(handle->stream->rid[0]) {\n\t\t\t\t\t\tjson_t *rids = json_array();\n\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[0]));\n\t\t\t\t\t\tif(handle->stream->rid[1])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[1]));\n\t\t\t\t\t\tif(handle->stream->rid[2])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""rids\"", rids);\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""rid-ext\"", json_integer(handle->stream->rid_ext_id));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjson_t *ssrcs = json_array();\n\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[0]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[1])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[1]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[2])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""ssrcs\"", ssrcs);\n\t\t\t\t\t}\n\t\t\t\t\tif(handle->stream->framemarking_ext_id > 0)\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""framemarking-ext\"", json_integer(handle->stream->framemarking_ext_id));\n\t\t\t\t\tjson_object_set_new(body_jsep, \""simulcast\"", simulcast);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if this is a renegotiation or update */\n\t\t\tif(renegotiation)\n\t\t\t\tjson_object_set_new(body_jsep, \""update\"", json_true());\n\t\t}\n\t\tjanus_plugin_result *result = plugin_t->handle_message(handle->app_handle,\n\t\t\tg_strdup((char *)transaction_text), body, body_jsep);\n\t\tg_free(jsep_type);\n\t\tg_free(jsep_sdp_stripped);\n\t\tif(result == NULL) {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""Plugin didn't give a result\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(result->type == JANUS_PLUGIN_OK) {\n\t\t\t/* The plugin gave a result already (synchronous request/response) */\n\t\t\tif(result->content == NULL || !json_is_object(result->content)) {\n\t\t\t\t/* Missing content, or not a JSON object */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t\tresult->content == NULL ?\n\t\t\t\t\t\t\""Plugin didn't provide any content for this synchronous response\"" :\n\t\t\t\t\t\t\""Plugin returned an invalid JSON response\"");\n\t\t\t\tjanus_plugin_result_destroy(result);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Reference the content, as destroying the result instance will decref it */\n\t\t\tjson_incref(result->content);\n\t\t\t/* Prepare JSON response */\n\t\t\tjson_t *reply = janus_create_message(\""success\"", session->session_id, transaction_text);\n\t\t\tjson_object_set_new(reply, \""sender\"", json_integer(handle->handle_id));\n\t\t\tif(janus_is_opaqueid_in_api_enabled() && handle->opaque_id != NULL)\n\t\t\t\tjson_object_set_new(reply, \""opaque_id\"", json_string(handle->opaque_id));\n\t\t\tjson_t *plugin_data = json_object();\n\t\t\tjson_object_set_new(plugin_data, \""plugin\"", json_string(plugin_t->get_package()));\n\t\t\tjson_object_set_new(plugin_data, \""data\"", result->content);\n\t\t\tjson_object_set_new(reply, \""plugindata\"", plugin_data);\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else if(result->type == JANUS_PLUGIN_OK_WAIT) {\n\t\t\t/* The plugin received the request but didn't process it yet, send an ack (asynchronous notifications may follow) */\n\t\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t\tif(result->text)\n\t\t\t\tjson_object_set_new(reply, \""hint\"", json_string(result->text));\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t(char *)(result->text ? result->text : \""Plugin returned a severe (unknown) error\""));\n\t\t\tjanus_plugin_result_destroy(result);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin_result_destroy(result);\n\t} else if(!strcasecmp(message_text, \""trickle\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Trickle is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this trickle candidate\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *candidate = json_object_get(root, \""candidate\"");\n\t\tjson_t *candidates = json_object_get(root, \""candidates\"");\n\t\tif(candidate == NULL && candidates == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_MISSING_MANDATORY_ELEMENT, \""Missing mandatory element (candidate|candidates)\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(candidate != NULL && candidates != NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON, \""Can't have both candidate and candidates\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\tJANUS_LOG(LOG_ERR, \""[%\""SCNu64\""] Received a trickle, but still cleaning a previous session\\n\"", handle->handle_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \""Still cleaning a previous session\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&handle->mutex);\n\t\tif(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE)) {\n\t\t\t/* It looks like this peer supports Trickle, after all */\n\t\t\tJANUS_LOG(LOG_VERB, \""Handle %\""SCNu64\"" supports trickle even if it didn't negotiate it...\\n\"", handle->handle_id);\n\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t}\n\t\t/* Is there any stream ready? this trickle may get here before the SDP it relates to */\n\t\tif(handle->stream == NULL) {\n\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] No stream, queueing this trickle as it got here before the SDP...\\n\"", handle->handle_id);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\t/* Is the ICE stack ready already? */\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER)) {\n\t\t\tconst char *cause = NULL;\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER))\n\t\t\t\tcause = \""processing the offer\"";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER))\n\t\t\t\tcause = \""waiting for the answer\"";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\tcause = \""waiting for the offer\"";\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Still %s, queueing this trickle to wait until we're done there...\\n\"",\n\t\t\t\thandle->handle_id, cause);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\tif(candidate != NULL) {\n\t\t\t/* We got a single candidate */\n\t\t\tint error = 0;\n\t\t\tconst char *error_string = NULL;\n\t\t\tif((error = janus_ice_trickle_parse(handle, candidate, &error_string)) != 0) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, error, \""%s\"", error_string);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t} else {\n\t\t\t/* We got multiple candidates in an array */\n\t\t\tif(!json_is_array(candidates)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_ELEMENT_TYPE, \""candidates is not an array\"");\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_LOG(LOG_VERB, \""Got multiple candidates (%zu)\\n\"", json_array_size(candidates));\n\t\t\tif(json_array_size(candidates) > 0) {\n\t\t\t\t/* Handle remote candidates */\n\t\t\t\tsize_t i = 0;\n\t\t\t\tfor(i=0; i<json_array_size(candidates); i++) {\n\t\t\t\t\tjson_t *c = json_array_get(candidates, i);\n\t\t\t\t\t/* FIXME We don't care if any trickle fails to parse */\n\t\t\t\t\tjanus_ice_trickle_parse(handle, c, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ntrickledone:\n\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t/* We reply right away, not to block the web server... */\n\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN_REQUEST, \""Unknown request '%s'\"", message_text);\n\t}\n\njsondone:\n\t/* Done processing */\n\tif(handle != NULL)\n\t\tjanus_refcount_decrease(&handle->ref);\n\tif(session != NULL)\n\t\tjanus_refcount_decrease(&session->ref);\n\treturn ret;\n}"", ""target"": 0}, {""func_name"": ""janus_session_notify_event"", ""file_path"": ""janus.c"", ""func_code"": ""void janus_session_notify_event(janus_session *session, json_t *event) {\n\tif(session != NULL && !g_atomic_int_get(&session->destroyed) && session->source != NULL && session->source->transport != NULL) {\n\t\t/* Send this to the transport client */\n\t\tJANUS_LOG(LOG_HUGE, \""Sending event to %s (%p)\\n\"", session->source->transport->get_package(), session->source->instance);\n\t\tsession->source->transport->send_message(session->source->instance, NULL, FALSE, event);\n\t} else {\n\t\t/* No transport, free the event */\n\t\tjson_decref(event);\n\t}\n}"", ""target"": 0}, {""func_name"": ""janus_transport_gone"", ""file_path"": ""janus.c"", ""func_code"": ""void janus_transport_gone(janus_transport *plugin, janus_transport_session *transport) {\n\t/* Get rid of sessions this transport was handling */\n\tJANUS_LOG(LOG_VERB, \""A %s transport instance has gone away (%p)\\n\"", plugin->get_package(), transport);\n\tjanus_mutex_lock(&sessions_mutex);\n\tif(sessions && g_hash_table_size(sessions) > 0) {\n\t\tGHashTableIter iter;\n\t\tgpointer value;\n\t\tg_hash_table_iter_init(&iter, sessions);\n\t\twhile(g_hash_table_iter_next(&iter, NULL, &value)) {\n\t\t\tjanus_session *session = (janus_session *) value;\n\t\t\tif(!session || g_atomic_int_get(&session->destroyed) || g_atomic_int_get(&session->timeout) || session->last_activity == 0)\n\t\t\t\tcontinue;\n\t\t\tif(session->source && session->source->instance == transport) {\n\t\t\t\tJANUS_LOG(LOG_VERB, \""  -- Session %\""SCNu64\"" will be over if not reclaimed\\n\"", session->session_id);\n\t\t\t\tJANUS_LOG(LOG_VERB, \""  -- Marking Session %\""SCNu64\"" as over\\n\"", session->session_id);\n\t\t\t\tif(reclaim_session_timeout < 1) { /* Reclaim session timeouts are disabled */\n\t\t\t\t\t/* Mark the session as destroyed */\n\t\t\t\t\tjanus_session_destroy(session);\n\t\t\t\t\tg_hash_table_iter_remove(&iter);\n\t\t\t\t} else {\n\t\t\t\t\t/* Set flag for transport_gone. The Janus sessions watchdog will clean this up if not reclaimed*/\n\t\t\t\t\tg_atomic_int_set(&session->transport_gone, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tjanus_mutex_unlock(&sessions_mutex);\n}"", ""target"": 0}, {""func_name"": ""janus_process_incoming_request"", ""file_path"": ""janus.c"", ""func_code"": ""int janus_process_incoming_request(janus_request *request) {\n\tint ret = -1;\n\tif(request == NULL) {\n\t\tJANUS_LOG(LOG_ERR, \""Missing request or payload to process, giving up...\\n\"");\n\t\treturn ret;\n\t}\n\tint error_code = 0;\n\tchar error_cause[100];\n\tjson_t *root = request->message;\n\t/* Ok, let's start with the ids */\n\tguint64 session_id = 0, handle_id = 0;\n\tjson_t *s = json_object_get(root, \""session_id\"");\n\tif(s && json_is_integer(s))\n\t\tsession_id = json_integer_value(s);\n\tjson_t *h = json_object_get(root, \""handle_id\"");\n\tif(h && json_is_integer(h))\n\t\thandle_id = json_integer_value(h);\n\n\tjanus_session *session = NULL;\n\tjanus_ice_handle *handle = NULL;\n\n\t/* Get transaction and message request */\n\tJANUS_VALIDATE_JSON_OBJECT(root, incoming_request_parameters,\n\t\terror_code, error_cause, FALSE,\n\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\tif(error_code != 0) {\n\t\tret = janus_process_error_string(request, session_id, NULL, error_code, error_cause);\n\t\tgoto jsondone;\n\t}\n\tjson_t *transaction = json_object_get(root, \""transaction\"");\n\tconst gchar *transaction_text = json_string_value(transaction);\n\tjson_t *message = json_object_get(root, \""janus\"");\n\tconst gchar *message_text = json_string_value(message);\n\n\tif(session_id == 0 && handle_id == 0) {\n\t\t/* Can only be a 'Create new session', a 'Get info' or a 'Ping/Pong' request */\n\t\tif(!strcasecmp(message_text, \""info\"")) {\n\t\t\tret = janus_process_success(request, janus_info(transaction_text));\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(!strcasecmp(message_text, \""ping\"")) {\n\t\t\t/* Prepare JSON reply */\n\t\t\tjson_t *reply = janus_create_message(\""pong\"", 0, transaction_text);\n\t\t\tret = janus_process_success(request, reply);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(strcasecmp(message_text, \""create\"")) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Make sure we're accepting new sessions */\n\t\tif(!accept_new_sessions) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_NOT_ACCEPTING_SESSIONS, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Any secret/token to check? */\n\t\tret = janus_request_check_secret(request, session_id, transaction_text);\n\t\tif(ret != 0) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = 0;\n\t\tjson_t *id = json_object_get(root, \""id\"");\n\t\tif(id != NULL) {\n\t\t\t/* The application provided the session ID to use */\n\t\t\tsession_id = json_integer_value(id);\n\t\t\tif(session_id > 0 && (session = janus_session_find(session_id)) != NULL) {\n\t\t\t\t/* Session ID already taken */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_CONFLICT, \""Session ID already in use\"");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t}\n\t\t/* Handle it */\n\t\tsession = janus_session_create(session_id);\n\t\tif(session == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Memory error\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = session->session_id;\n\t\t/* We increase the counter as this request is using the session */\n\t\tjanus_refcount_increase(&session->ref);\n\t\t/* Take note of the request source that originated this session (HTTP, WebSockets, RabbitMQ?) */\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the source that a new session has been created */\n\t\trequest->transport->session_created(request->instance, session->session_id);\n\t\t/* Notify event handlers */\n\t\tif(janus_events_is_enabled()) {\n\t\t\t/* Session created, add info on the transport that originated it */\n\t\t\tjson_t *transport = json_object();\n\t\t\tjson_object_set_new(transport, \""transport\"", json_string(session->source->transport->get_package()));\n\t\t\tchar id[32];\n\t\t\tmemset(id, 0, sizeof(id));\n\t\t\tg_snprintf(id, sizeof(id), \""%p\"", session->source->instance);\n\t\t\tjson_object_set_new(transport, \""id\"", json_string(id));\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \""created\"", transport);\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", 0, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \""id\"", json_integer(session_id));\n\t\tjson_object_set_new(reply, \""data\"", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\tgoto jsondone;\n\t}\n\tif(session_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \""Invalid session\\n\"");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\tif(h && handle_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \""Invalid handle\\n\"");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* Go on with the processing */\n\tret = janus_request_check_secret(request, session_id, transaction_text);\n\tif(ret != 0) {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* If we got here, make sure we have a session (and/or a handle) */\n\tsession = janus_session_find(session_id);\n\tif(!session) {\n\t\tJANUS_LOG(LOG_ERR, \""Couldn't find any session %\""SCNu64\""...\\n\"", session_id);\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, \""No such session %\""SCNu64\""\"", session_id);\n\t\tgoto jsondone;\n\t}\n\t/* Update the last activity timer */\n\tsession->last_activity = janus_get_monotonic_time();\n\thandle = NULL;\n\tif(handle_id > 0) {\n\t\thandle = janus_session_handles_find(session, handle_id);\n\t\tif(!handle) {\n\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't find any handle %\""SCNu64\"" in session %\""SCNu64\""...\\n\"", handle_id, session_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_HANDLE_NOT_FOUND, \""No such handle %\""SCNu64\"" in session %\""SCNu64\""\"", handle_id, session_id);\n\t\t\tgoto jsondone;\n\t\t}\n\t}\n\n\t/* What is this? */\n\tif(!strcasecmp(message_text, \""keepalive\"")) {\n\t\t/* Just a keep-alive message, reply with an ack */\n\t\tJANUS_LOG(LOG_VERB, \""Got a keep-alive on session %\""SCNu64\""\\n\"", session_id);\n\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""attach\"")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Attach is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, attach_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *plugin = json_object_get(root, \""plugin\"");\n\t\tconst gchar *plugin_text = json_string_value(plugin);\n\t\tjanus_plugin *plugin_t = janus_plugin_find(plugin_text);\n\t\tif(plugin_t == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_NOT_FOUND, \""No such plugin '%s'\"", plugin_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* If the auth token mechanism is enabled, we should check if this token can access this plugin */\n\t\tif(janus_auth_is_enabled()) {\n\t\t\tjson_t *token = json_object_get(root, \""token\"");\n\t\t\tif(token != NULL) {\n\t\t\t\tconst char *token_value = json_string_value(token);\n\t\t\t\tif(token_value && !janus_auth_check_plugin(token_value, plugin_t)) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Token '%s' can't access plugin '%s'\\n\"", token_value, plugin_text);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED_PLUGIN, \""Provided token can't access plugin '%s'\"", plugin_text);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjson_t *opaque = json_object_get(root, \""opaque_id\"");\n\t\tconst char *opaque_id = opaque ? json_string_value(opaque) : NULL;\n\t\t/* Create handle */\n\t\thandle = janus_ice_handle_create(session, opaque_id);\n\t\tif(handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Memory error\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\thandle_id = handle->handle_id;\n\t\t/* We increase the counter as this request is using the handle */\n\t\tjanus_refcount_increase(&handle->ref);\n\t\t/* Attach to the plugin */\n\t\tint error = 0;\n\t\tif((error = janus_ice_handle_attach_plugin(session, handle, plugin_t)) != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tjanus_session_handles_remove(session, handle);\n\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't attach to plugin '%s', error '%d'\\n\"", plugin_text, error);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_ATTACH, \""Couldn't attach to plugin: error '%d'\"", error);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \""id\"", json_integer(handle_id));\n\t\tjson_object_set_new(reply, \""data\"", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""destroy\"")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Query is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&sessions_mutex);\n\t\tg_hash_table_remove(sessions, &session->session_id);\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t/* Notify the source that the session has been destroyed */\n\t\tjanus_mutex_lock(&session->mutex);\n\t\tif(session->source && session->source->transport)\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, FALSE);\n\t\tjanus_mutex_unlock(&session->mutex);\n\t\t/* Schedule the session for deletion */\n\t\tjanus_session_destroy(session);\n\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\t/* Notify event handlers as well */\n\t\tif(janus_events_is_enabled())\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \""destroyed\"", NULL);\n\t} else if(!strcasecmp(message_text, \""detach\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""No plugin to detach from\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tint error = janus_session_handles_remove(session, handle);\n\t\tif(error != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""Couldn't detach from plugin: error '%d'\"", error);\n\t\t\t/* TODO Delete handle instance */\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""hangup\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""No plugin attached\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_ice_webrtc_hangup(handle, \""Janus API\"");\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""claim\"")) {\n\t\tjanus_mutex_lock(&session->mutex);\n\t\tif(session->source != NULL) {\n\t\t\t/* Notify the old transport that this session is over for them, but has been reclaimed */\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, TRUE);\n\t\t\tjanus_request_destroy(session->source);\n\t\t\tsession->source = NULL;\n\t\t}\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the new transport that it has claimed a session */\n\t\tsession->source->transport->session_claimed(session->source->instance, session->session_id);\n\t\t/* Previous transport may be gone, clear flag. */\n\t\tg_atomic_int_set(&session->transport_gone, 0);\n\t\tjanus_mutex_unlock(&session->mutex);\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = json_object();\n\t\tjson_object_set_new(reply, \""janus\"", json_string(\""success\""));\n\t\tjson_object_set_new(reply, \""session_id\"", json_integer(session_id));\n\t\tjson_object_set_new(reply, \""transaction\"", json_string(transaction_text));\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""message\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this message\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin *plugin_t = (janus_plugin *)handle->app;\n\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] There's a message for %s\\n\"", handle->handle_id, plugin_t->get_name());\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, body_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *body = json_object_get(root, \""body\"");\n\t\t/* Is there an SDP attached? */\n\t\tjson_t *jsep = json_object_get(root, \""jsep\"");\n\t\tchar *jsep_type = NULL;\n\t\tchar *jsep_sdp = NULL, *jsep_sdp_stripped = NULL;\n\t\tgboolean renegotiation = FALSE;\n\t\tif(jsep != NULL) {\n\t\t\tif(!json_is_object(jsep)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON_OBJECT, \""Invalid jsep object\"");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_VALIDATE_JSON_OBJECT_FORMAT(\""JSEP error: missing mandatory element (%s)\"",\n\t\t\t\t\""JSEP error: invalid element type (%s should be %s)\"",\n\t\t\t\tjsep, jsep_parameters, error_code, error_cause, FALSE,\n\t\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\t\tif(error_code != 0) {\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *type = json_object_get(jsep, \""type\"");\n\t\t\tjsep_type = g_strdup(json_string_value(type));\n\t\t\ttype = NULL;\n\t\t\tgboolean do_trickle = TRUE;\n\t\t\tjson_t *jsep_trickle = json_object_get(jsep, \""trickle\"");\n\t\t\tdo_trickle = jsep_trickle ? json_is_true(jsep_trickle) : TRUE;\n\t\t\t/* Are we still cleaning up from a previous media session? */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Still cleaning up from a previous media session, let's wait a bit...\\n\"", handle->handle_id);\n\t\t\t\tgint64 waited = 0;\n\t\t\t\twhile(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\t\tg_usleep(100000);\n\t\t\t\t\twaited += 100000;\n\t\t\t\t\tif(waited >= 3*G_USEC_PER_SEC) {\n\t\t\t\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""]   -- Waited 3 seconds, that's enough!\\n\"", handle->handle_id);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \""Still cleaning a previous session\"");\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if we're renegotiating (if we have an answer, we did an offer/answer round already) */\n\t\t\trenegotiation = janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t/* Check the JSEP type */\n\t\t\tjanus_mutex_lock(&handle->mutex);\n\t\t\tint offer = 0;\n\t\t\tif(!strcasecmp(jsep_type, \""offer\"")) {\n\t\t\t\toffer = 1;\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t} else if(!strcasecmp(jsep_type, \""answer\"")) {\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t\toffer = 0;\n\t\t\t} else {\n\t\t\t\t/* TODO Handle other message types as well */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_UNKNOWN_TYPE, \""JSEP error: unknown message type '%s'\"", jsep_type);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *sdp = json_object_get(jsep, \""sdp\"");\n\t\t\tjsep_sdp = (char *)json_string_value(sdp);\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Remote SDP:\\n%s\"", handle->handle_id, jsep_sdp);\n\t\t\t/* Is this valid SDP? */\n\t\t\tchar error_str[512];\n\t\t\tint audio = 0, video = 0, data = 0;\n\t\t\tjanus_sdp *parsed_sdp = janus_sdp_preparse(handle, jsep_sdp, error_str, sizeof(error_str), &audio, &video, &data);\n\t\t\tif(parsed_sdp == NULL) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, error_str);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Notify event handlers */\n\t\t\tif(janus_events_is_enabled()) {\n\t\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_JSEP, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\t\tsession_id, handle_id, handle->opaque_id, \""remote\"", jsep_type, jsep_sdp);\n\t\t\t}\n\t\t\t/* FIXME We're only handling single audio/video lines for now... */\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Audio %s been negotiated, Video %s been negotiated, SCTP/DataChannels %s been negotiated\\n\"",\n\t\t\t                    handle->handle_id,\n\t\t\t                    audio ? \""has\"" : \""has NOT\"",\n\t\t\t                    video ? \""has\"" : \""has NOT\"",\n\t\t\t                    data ? \""have\"" : \""have NOT\"");\n\t\t\tif(audio > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one audio line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n\t\t\tif(video > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one video line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n\t\t\tif(data > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one data line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n#ifndef HAVE_SCTP\n\t\t\tif(data) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""]   -- DataChannels have been negotiated, but support for them has not been compiled...\\n\"", handle->handle_id);\n\t\t\t}\n#endif\n\t\t\t/* We behave differently if it's a new session or an update... */\n\t\t\tif(!renegotiation) {\n\t\t\t\t/* New session */\n\t\t\t\tif(offer) {\n\t\t\t\t\t/* Setup ICE locally (we received an offer) */\n\t\t\t\t\tif(janus_ice_setup_local(handle, offer, audio, video, data, do_trickle) < 0) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error setting ICE locally\\n\"");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Error setting ICE locally\"");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Make sure we're waiting for an ANSWER in the first place */\n\t\t\t\t\tif(!handle->agent) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Unexpected ANSWER (did we offer?)\\n\"");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \""Unexpected ANSWER (did we offer?)\"");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, FALSE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error processing SDP\\n\"");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \""Error processing SDP\"");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Set remote candidates now (we received an answer) */\n\t\t\t\t\tif(do_trickle) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t}\n\t\t\t\t\tjanus_request_ice_handle_answer(handle, audio, video, data, jsep_sdp);\n\t\t\t\t} else {\n\t\t\t\t\t/* Check if the mid RTP extension is being negotiated */\n\t\t\t\t\thandle->stream->mid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_MID);\n\t\t\t\t\t/* Check if the RTP Stream ID extension is being negotiated */\n\t\t\t\t\thandle->stream->rid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_RID);\n\t\t\t\t\thandle->stream->ridrtx_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_REPAIRED_RID);\n\t\t\t\t\t/* Check if the audio level ID extension is being negotiated */\n\t\t\t\t\thandle->stream->audiolevel_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_AUDIO_LEVEL);\n\t\t\t\t\t/* Check if the video orientation ID extension is being negotiated */\n\t\t\t\t\thandle->stream->videoorientation_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_VIDEO_ORIENTATION);\n\t\t\t\t\t/* Check if the frame marking ID extension is being negotiated */\n\t\t\t\t\thandle->stream->framemarking_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_FRAME_MARKING);\n\t\t\t\t\t/* Check if transport wide CC is supported */\n\t\t\t\t\tint transport_wide_cc_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC);\n\t\t\t\t\thandle->stream->do_transport_wide_cc = transport_wide_cc_ext_id > 0 ? TRUE : FALSE;\n\t\t\t\t\thandle->stream->transport_wide_cc_ext_id = transport_wide_cc_ext_id;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* FIXME This is a renegotiation: we can currently only handle simple changes in media\n\t\t\t\t * direction and ICE restarts: anything more complex than that will result in an error */\n\t\t\t\tJANUS_LOG(LOG_INFO, \""[%\""SCNu64\""] Negotiation update, checking what changed...\\n\"", handle->handle_id);\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, TRUE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error processing SDP\\n\"");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \""Error processing SDP\"");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART)) {\n\t\t\t\t\tJANUS_LOG(LOG_INFO, \""[%\""SCNu64\""] Restarting ICE...\\n\"", handle->handle_id);\n\t\t\t\t\t/* Update remote credentials for ICE */\n\t\t\t\t\tif(handle->stream) {\n\t\t\t\t\t\tnice_agent_set_remote_credentials(handle->agent, handle->stream->stream_id,\n\t\t\t\t\t\t\thandle->stream->ruser, handle->stream->rpass);\n\t\t\t\t\t}\n\t\t\t\t\t/* FIXME We only need to do that for offers: if it's an answer, we did that already */\n\t\t\t\t\tif(offer) {\n\t\t\t\t\t\tjanus_ice_restart(handle);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART);\n\t\t\t\t\t}\n\t\t\t\t\t/* If we're full-trickling, we'll need to resend the candidates later */\n\t\t\t\t\tif(janus_ice_is_full_trickle_enabled()) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_RESEND_TRICKLES);\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef HAVE_SCTP\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Were datachannels just added? */\n\t\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_DATA_CHANNELS)) {\n\t\t\t\t\t\tjanus_ice_stream *stream = handle->stream;\n\t\t\t\t\t\tif(stream != NULL && stream->component != NULL\n\t\t\t\t\t\t\t\t&& stream->component->dtls != NULL && stream->component->dtls->sctp == NULL) {\n\t\t\t\t\t\t\t/* Create SCTP association as well */\n\t\t\t\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] Creating datachannels...\\n\"", handle->handle_id);\n\t\t\t\t\t\t\tjanus_dtls_srtp_create_sctp(stream->component->dtls);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tchar *tmp = handle->remote_sdp;\n\t\t\thandle->remote_sdp = g_strdup(jsep_sdp);\n\t\t\tg_free(tmp);\n\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t/* Anonymize SDP */\n\t\t\tif(janus_sdp_anonymize(parsed_sdp) < 0) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \""JSEP error: invalid SDP\"");\n\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjsep_sdp_stripped = janus_sdp_write(parsed_sdp);\n\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\tsdp = NULL;\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t}\n\n\t\t/* Make sure the app handle is still valid */\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this message\"");\n\t\t\tg_free(jsep_type);\n\t\t\tg_free(jsep_sdp_stripped);\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\tgoto jsondone;\n\t\t}\n\n\t\t/* Send the message to the plugin (which must eventually free transaction_text and unref the two objects, body and jsep) */\n\t\tjson_incref(body);\n\t\tjson_t *body_jsep = NULL;\n\t\tif(jsep_sdp_stripped) {\n\t\t\tbody_jsep = json_pack(\""{ssss}\"", \""type\"", jsep_type, \""sdp\"", jsep_sdp_stripped);\n\t\t\t/* Check if simulcasting is enabled */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_VIDEO)) {\n\t\t\t\tif(handle->stream && (handle->stream->rid[0] || handle->stream->video_ssrc_peer[1])) {\n\t\t\t\t\tjson_t *simulcast = json_object();\n\t\t\t\t\t/* If we have rids, pass those, otherwise pass the SSRCs */\n\t\t\t\t\tif(handle->stream->rid[0]) {\n\t\t\t\t\t\tjson_t *rids = json_array();\n\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[0]));\n\t\t\t\t\t\tif(handle->stream->rid[1])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[1]));\n\t\t\t\t\t\tif(handle->stream->rid[2])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""rids\"", rids);\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""rid-ext\"", json_integer(handle->stream->rid_ext_id));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjson_t *ssrcs = json_array();\n\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[0]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[1])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[1]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[2])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""ssrcs\"", ssrcs);\n\t\t\t\t\t}\n\t\t\t\t\tif(handle->stream->framemarking_ext_id > 0)\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""framemarking-ext\"", json_integer(handle->stream->framemarking_ext_id));\n\t\t\t\t\tjson_object_set_new(body_jsep, \""simulcast\"", simulcast);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if this is a renegotiation or update */\n\t\t\tif(renegotiation)\n\t\t\t\tjson_object_set_new(body_jsep, \""update\"", json_true());\n\t\t}\n\t\tjanus_plugin_result *result = plugin_t->handle_message(handle->app_handle,\n\t\t\tg_strdup((char *)transaction_text), body, body_jsep);\n\t\tg_free(jsep_type);\n\t\tg_free(jsep_sdp_stripped);\n\t\tif(result == NULL) {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""Plugin didn't give a result\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(result->type == JANUS_PLUGIN_OK) {\n\t\t\t/* The plugin gave a result already (synchronous request/response) */\n\t\t\tif(result->content == NULL || !json_is_object(result->content)) {\n\t\t\t\t/* Missing content, or not a JSON object */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t\tresult->content == NULL ?\n\t\t\t\t\t\t\""Plugin didn't provide any content for this synchronous response\"" :\n\t\t\t\t\t\t\""Plugin returned an invalid JSON response\"");\n\t\t\t\tjanus_plugin_result_destroy(result);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Reference the content, as destroying the result instance will decref it */\n\t\t\tjson_incref(result->content);\n\t\t\t/* Prepare JSON response */\n\t\t\tjson_t *reply = janus_create_message(\""success\"", session->session_id, transaction_text);\n\t\t\tjson_object_set_new(reply, \""sender\"", json_integer(handle->handle_id));\n\t\t\tif(janus_is_opaqueid_in_api_enabled() && handle->opaque_id != NULL)\n\t\t\t\tjson_object_set_new(reply, \""opaque_id\"", json_string(handle->opaque_id));\n\t\t\tjson_t *plugin_data = json_object();\n\t\t\tjson_object_set_new(plugin_data, \""plugin\"", json_string(plugin_t->get_package()));\n\t\t\tjson_object_set_new(plugin_data, \""data\"", result->content);\n\t\t\tjson_object_set_new(reply, \""plugindata\"", plugin_data);\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else if(result->type == JANUS_PLUGIN_OK_WAIT) {\n\t\t\t/* The plugin received the request but didn't process it yet, send an ack (asynchronous notifications may follow) */\n\t\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t\tif(result->text)\n\t\t\t\tjson_object_set_new(reply, \""hint\"", json_string(result->text));\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t(char *)(result->text ? result->text : \""Plugin returned a severe (unknown) error\""));\n\t\t\tjanus_plugin_result_destroy(result);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin_result_destroy(result);\n\t} else if(!strcasecmp(message_text, \""trickle\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Trickle is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this trickle candidate\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *candidate = json_object_get(root, \""candidate\"");\n\t\tjson_t *candidates = json_object_get(root, \""candidates\"");\n\t\tif(candidate == NULL && candidates == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_MISSING_MANDATORY_ELEMENT, \""Missing mandatory element (candidate|candidates)\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(candidate != NULL && candidates != NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON, \""Can't have both candidate and candidates\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\tJANUS_LOG(LOG_ERR, \""[%\""SCNu64\""] Received a trickle, but still cleaning a previous session\\n\"", handle->handle_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \""Still cleaning a previous session\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&handle->mutex);\n\t\tif(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE)) {\n\t\t\t/* It looks like this peer supports Trickle, after all */\n\t\t\tJANUS_LOG(LOG_VERB, \""Handle %\""SCNu64\"" supports trickle even if it didn't negotiate it...\\n\"", handle->handle_id);\n\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t}\n\t\t/* Is there any stream ready? this trickle may get here before the SDP it relates to */\n\t\tif(handle->stream == NULL) {\n\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] No stream, queueing this trickle as it got here before the SDP...\\n\"", handle->handle_id);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\t/* Is the ICE stack ready already? */\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER)) {\n\t\t\tconst char *cause = NULL;\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER))\n\t\t\t\tcause = \""processing the offer\"";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER))\n\t\t\t\tcause = \""waiting for the answer\"";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\tcause = \""waiting for the offer\"";\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Still %s, queueing this trickle to wait until we're done there...\\n\"",\n\t\t\t\thandle->handle_id, cause);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\tif(candidate != NULL) {\n\t\t\t/* We got a single candidate */\n\t\t\tint error = 0;\n\t\t\tconst char *error_string = NULL;\n\t\t\tif((error = janus_ice_trickle_parse(handle, candidate, &error_string)) != 0) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, error, \""%s\"", error_string);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t} else {\n\t\t\t/* We got multiple candidates in an array */\n\t\t\tif(!json_is_array(candidates)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_ELEMENT_TYPE, \""candidates is not an array\"");\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_LOG(LOG_VERB, \""Got multiple candidates (%zu)\\n\"", json_array_size(candidates));\n\t\t\tif(json_array_size(candidates) > 0) {\n\t\t\t\t/* Handle remote candidates */\n\t\t\t\tsize_t i = 0;\n\t\t\t\tfor(i=0; i<json_array_size(candidates); i++) {\n\t\t\t\t\tjson_t *c = json_array_get(candidates, i);\n\t\t\t\t\t/* FIXME We don't care if any trickle fails to parse */\n\t\t\t\t\tjanus_ice_trickle_parse(handle, c, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ntrickledone:\n\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t/* We reply right away, not to block the web server... */\n\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN_REQUEST, \""Unknown request '%s'\"", message_text);\n\t}\n\njsondone:\n\t/* Done processing */\n\tif(handle != NULL)\n\t\tjanus_refcount_decrease(&handle->ref);\n\tif(session != NULL)\n\t\tjanus_refcount_decrease(&session->ref);\n\treturn ret;\n}"", ""target"": 0}]","[{""func_name"": ""janus_process_incoming_request"", ""file_path"": ""janus.c"", ""func_code"": ""int janus_process_incoming_request(janus_request *request) {\n\tint ret = -1;\n\tif(request == NULL) {\n\t\tJANUS_LOG(LOG_ERR, \""Missing request or payload to process, giving up...\\n\"");\n\t\treturn ret;\n\t}\n\tint error_code = 0;\n\tchar error_cause[100];\n\tjson_t *root = request->message;\n\t/* Ok, let's start with the ids */\n\tguint64 session_id = 0, handle_id = 0;\n\tjson_t *s = json_object_get(root, \""session_id\"");\n\tif(s && json_is_integer(s))\n\t\tsession_id = json_integer_value(s);\n\tjson_t *h = json_object_get(root, \""handle_id\"");\n\tif(h && json_is_integer(h))\n\t\thandle_id = json_integer_value(h);\n\n\tjanus_session *session = NULL;\n\tjanus_ice_handle *handle = NULL;\n\n\t/* Get transaction and message request */\n\tJANUS_VALIDATE_JSON_OBJECT(root, incoming_request_parameters,\n\t\terror_code, error_cause, FALSE,\n\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\tif(error_code != 0) {\n\t\tret = janus_process_error_string(request, session_id, NULL, error_code, error_cause);\n\t\tgoto jsondone;\n\t}\n\tjson_t *transaction = json_object_get(root, \""transaction\"");\n\tconst gchar *transaction_text = json_string_value(transaction);\n\tjson_t *message = json_object_get(root, \""janus\"");\n\tconst gchar *message_text = json_string_value(message);\n\n\tif(session_id == 0 && handle_id == 0) {\n\t\t/* Can only be a 'Create new session', a 'Get info' or a 'Ping/Pong' request */\n\t\tif(!strcasecmp(message_text, \""info\"")) {\n\t\t\tret = janus_process_success(request, janus_info(transaction_text));\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(!strcasecmp(message_text, \""ping\"")) {\n\t\t\t/* Prepare JSON reply */\n\t\t\tjson_t *reply = janus_create_message(\""pong\"", 0, transaction_text);\n\t\t\tret = janus_process_success(request, reply);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(strcasecmp(message_text, \""create\"")) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Make sure we're accepting new sessions */\n\t\tif(!accept_new_sessions) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_NOT_ACCEPTING_SESSIONS, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Any secret/token to check? */\n\t\tret = janus_request_check_secret(request, session_id, transaction_text);\n\t\tif(ret != 0) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = 0;\n\t\tjson_t *id = json_object_get(root, \""id\"");\n\t\tif(id != NULL) {\n\t\t\t/* The application provided the session ID to use */\n\t\t\tsession_id = json_integer_value(id);\n\t\t\tif(session_id > 0 && (session = janus_session_find(session_id)) != NULL) {\n\t\t\t\t/* Session ID already taken */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_CONFLICT, \""Session ID already in use\"");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t}\n\t\t/* Handle it */\n\t\tsession = janus_session_create(session_id);\n\t\tif(session == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Memory error\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = session->session_id;\n\t\t/* We increase the counter as this request is using the session */\n\t\tjanus_refcount_increase(&session->ref);\n\t\t/* Take note of the request source that originated this session (HTTP, WebSockets, RabbitMQ?) */\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the source that a new session has been created */\n\t\trequest->transport->session_created(request->instance, session->session_id);\n\t\t/* Notify event handlers */\n\t\tif(janus_events_is_enabled()) {\n\t\t\t/* Session created, add info on the transport that originated it */\n\t\t\tjson_t *transport = json_object();\n\t\t\tjson_object_set_new(transport, \""transport\"", json_string(session->source->transport->get_package()));\n\t\t\tchar id[32];\n\t\t\tmemset(id, 0, sizeof(id));\n\t\t\tg_snprintf(id, sizeof(id), \""%p\"", session->source->instance);\n\t\t\tjson_object_set_new(transport, \""id\"", json_string(id));\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \""created\"", transport);\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", 0, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \""id\"", json_integer(session_id));\n\t\tjson_object_set_new(reply, \""data\"", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\tgoto jsondone;\n\t}\n\tif(session_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \""Invalid session\\n\"");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\tif(h && handle_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \""Invalid handle\\n\"");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* Go on with the processing */\n\tret = janus_request_check_secret(request, session_id, transaction_text);\n\tif(ret != 0) {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* If we got here, make sure we have a session (and/or a handle) */\n\tsession = janus_session_find(session_id);\n\tif(!session) {\n\t\tJANUS_LOG(LOG_ERR, \""Couldn't find any session %\""SCNu64\""...\\n\"", session_id);\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, \""No such session %\""SCNu64\""\"", session_id);\n\t\tgoto jsondone;\n\t}\n\t/* Update the last activity timer */\n\tsession->last_activity = janus_get_monotonic_time();\n\thandle = NULL;\n\tif(handle_id > 0) {\n\t\thandle = janus_session_handles_find(session, handle_id);\n\t\tif(!handle) {\n\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't find any handle %\""SCNu64\"" in session %\""SCNu64\""...\\n\"", handle_id, session_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_HANDLE_NOT_FOUND, \""No such handle %\""SCNu64\"" in session %\""SCNu64\""\"", handle_id, session_id);\n\t\t\tgoto jsondone;\n\t\t}\n\t}\n\n\t/* What is this? */\n\tif(!strcasecmp(message_text, \""keepalive\"")) {\n\t\t/* Just a keep-alive message, reply with an ack */\n\t\tJANUS_LOG(LOG_VERB, \""Got a keep-alive on session %\""SCNu64\""\\n\"", session_id);\n\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""attach\"")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Attach is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, attach_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *plugin = json_object_get(root, \""plugin\"");\n\t\tconst gchar *plugin_text = json_string_value(plugin);\n\t\tjanus_plugin *plugin_t = janus_plugin_find(plugin_text);\n\t\tif(plugin_t == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_NOT_FOUND, \""No such plugin '%s'\"", plugin_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* If the auth token mechanism is enabled, we should check if this token can access this plugin */\n\t\tif(janus_auth_is_enabled()) {\n\t\t\tjson_t *token = json_object_get(root, \""token\"");\n\t\t\tif(token != NULL) {\n\t\t\t\tconst char *token_value = json_string_value(token);\n\t\t\t\tif(token_value && !janus_auth_check_plugin(token_value, plugin_t)) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Token '%s' can't access plugin '%s'\\n\"", token_value, plugin_text);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED_PLUGIN, \""Provided token can't access plugin '%s'\"", plugin_text);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjson_t *opaque = json_object_get(root, \""opaque_id\"");\n\t\tconst char *opaque_id = opaque ? json_string_value(opaque) : NULL;\n\t\t/* Create handle */\n\t\thandle = janus_ice_handle_create(session, opaque_id);\n\t\tif(handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Memory error\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\thandle_id = handle->handle_id;\n\t\t/* We increase the counter as this request is using the handle */\n\t\tjanus_refcount_increase(&handle->ref);\n\t\t/* Attach to the plugin */\n\t\tint error = 0;\n\t\tif((error = janus_ice_handle_attach_plugin(session, handle, plugin_t)) != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tjanus_session_handles_remove(session, handle);\n\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't attach to plugin '%s', error '%d'\\n\"", plugin_text, error);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_ATTACH, \""Couldn't attach to plugin: error '%d'\"", error);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \""id\"", json_integer(handle_id));\n\t\tjson_object_set_new(reply, \""data\"", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""destroy\"")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Query is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&sessions_mutex);\n\t\tg_hash_table_remove(sessions, &session->session_id);\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t/* Notify the source that the session has been destroyed */\n\t\tjanus_mutex_lock(&session->mutex);\n\t\tif(session->source && session->source->transport)\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, FALSE);\n\t\tjanus_mutex_unlock(&session->mutex);\n\t\t/* Schedule the session for deletion */\n\t\tjanus_session_destroy(session);\n\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\t/* Notify event handlers as well */\n\t\tif(janus_events_is_enabled())\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \""destroyed\"", NULL);\n\t} else if(!strcasecmp(message_text, \""detach\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""No plugin to detach from\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tint error = janus_session_handles_remove(session, handle);\n\t\tif(error != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""Couldn't detach from plugin: error '%d'\"", error);\n\t\t\t/* TODO Delete handle instance */\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""hangup\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""No plugin attached\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_ice_webrtc_hangup(handle, \""Janus API\"");\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""claim\"")) {\n\t\tjanus_mutex_lock(&session->mutex);\n\t\tif(session->source != NULL) {\n\t\t\t/* Notify the old transport that this session is over for them, but has been reclaimed */\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, TRUE);\n\t\t\tjanus_request_destroy(session->source);\n\t\t\tsession->source = NULL;\n\t\t}\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the new transport that it has claimed a session */\n\t\tsession->source->transport->session_claimed(session->source->instance, session->session_id);\n\t\t/* Previous transport may be gone, clear flag. */\n\t\tg_atomic_int_set(&session->transport_gone, 0);\n\t\tjanus_mutex_unlock(&session->mutex);\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = json_object();\n\t\tjson_object_set_new(reply, \""janus\"", json_string(\""success\""));\n\t\tjson_object_set_new(reply, \""session_id\"", json_integer(session_id));\n\t\tjson_object_set_new(reply, \""transaction\"", json_string(transaction_text));\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""message\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this message\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin *plugin_t = (janus_plugin *)handle->app;\n\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] There's a message for %s\\n\"", handle->handle_id, plugin_t->get_name());\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, body_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *body = json_object_get(root, \""body\"");\n\t\t/* Is there an SDP attached? */\n\t\tjson_t *jsep = json_object_get(root, \""jsep\"");\n\t\tchar *jsep_type = NULL;\n\t\tchar *jsep_sdp = NULL, *jsep_sdp_stripped = NULL;\n\t\tgboolean renegotiation = FALSE;\n\t\tif(jsep != NULL) {\n\t\t\tif(!json_is_object(jsep)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON_OBJECT, \""Invalid jsep object\"");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_VALIDATE_JSON_OBJECT_FORMAT(\""JSEP error: missing mandatory element (%s)\"",\n\t\t\t\t\""JSEP error: invalid element type (%s should be %s)\"",\n\t\t\t\tjsep, jsep_parameters, error_code, error_cause, FALSE,\n\t\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\t\tif(error_code != 0) {\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *type = json_object_get(jsep, \""type\"");\n\t\t\tjsep_type = g_strdup(json_string_value(type));\n\t\t\ttype = NULL;\n\t\t\tgboolean do_trickle = TRUE;\n\t\t\tjson_t *jsep_trickle = json_object_get(jsep, \""trickle\"");\n\t\t\tdo_trickle = jsep_trickle ? json_is_true(jsep_trickle) : TRUE;\n\t\t\t/* Are we still cleaning up from a previous media session? */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Still cleaning up from a previous media session, let's wait a bit...\\n\"", handle->handle_id);\n\t\t\t\tgint64 waited = 0;\n\t\t\t\twhile(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\t\tg_usleep(100000);\n\t\t\t\t\twaited += 100000;\n\t\t\t\t\tif(waited >= 3*G_USEC_PER_SEC) {\n\t\t\t\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""]   -- Waited 3 seconds, that's enough!\\n\"", handle->handle_id);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \""Still cleaning a previous session\"");\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if we're renegotiating (if we have an answer, we did an offer/answer round already) */\n\t\t\trenegotiation = janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t/* Check the JSEP type */\n\t\t\tjanus_mutex_lock(&handle->mutex);\n\t\t\tint offer = 0;\n\t\t\tif(!strcasecmp(jsep_type, \""offer\"")) {\n\t\t\t\toffer = 1;\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t} else if(!strcasecmp(jsep_type, \""answer\"")) {\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t\toffer = 0;\n\t\t\t} else {\n\t\t\t\t/* TODO Handle other message types as well */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_UNKNOWN_TYPE, \""JSEP error: unknown message type '%s'\"", jsep_type);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *sdp = json_object_get(jsep, \""sdp\"");\n\t\t\tjsep_sdp = (char *)json_string_value(sdp);\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Remote SDP:\\n%s\"", handle->handle_id, jsep_sdp);\n\t\t\t/* Is this valid SDP? */\n\t\t\tchar error_str[512];\n\t\t\tint audio = 0, video = 0, data = 0;\n\t\t\tjanus_sdp *parsed_sdp = janus_sdp_preparse(handle, jsep_sdp, error_str, sizeof(error_str), &audio, &video, &data);\n\t\t\tif(parsed_sdp == NULL) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, error_str);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Notify event handlers */\n\t\t\tif(janus_events_is_enabled()) {\n\t\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_JSEP, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\t\tsession_id, handle_id, handle->opaque_id, \""remote\"", jsep_type, jsep_sdp);\n\t\t\t}\n\t\t\t/* FIXME We're only handling single audio/video lines for now... */\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Audio %s been negotiated, Video %s been negotiated, SCTP/DataChannels %s been negotiated\\n\"",\n\t\t\t                    handle->handle_id,\n\t\t\t                    audio ? \""has\"" : \""has NOT\"",\n\t\t\t                    video ? \""has\"" : \""has NOT\"",\n\t\t\t                    data ? \""have\"" : \""have NOT\"");\n\t\t\tif(audio > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one audio line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n\t\t\tif(video > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one video line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n\t\t\tif(data > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one data line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n#ifndef HAVE_SCTP\n\t\t\tif(data) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""]   -- DataChannels have been negotiated, but support for them has not been compiled...\\n\"", handle->handle_id);\n\t\t\t}\n#endif\n\t\t\t/* We behave differently if it's a new session or an update... */\n\t\t\tif(!renegotiation) {\n\t\t\t\t/* New session */\n\t\t\t\tif(offer) {\n\t\t\t\t\t/* Setup ICE locally (we received an offer) */\n\t\t\t\t\tif(janus_ice_setup_local(handle, offer, audio, video, data, do_trickle) < 0) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error setting ICE locally\\n\"");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Error setting ICE locally\"");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Make sure we're waiting for an ANSWER in the first place */\n\t\t\t\t\tif(!handle->agent) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Unexpected ANSWER (did we offer?)\\n\"");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \""Unexpected ANSWER (did we offer?)\"");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, FALSE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error processing SDP\\n\"");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \""Error processing SDP\"");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Set remote candidates now (we received an answer) */\n\t\t\t\t\tif(do_trickle) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t}\n\t\t\t\t\tjanus_request_ice_handle_answer(handle, audio, video, data, jsep_sdp);\n\t\t\t\t} else {\n\t\t\t\t\t/* Check if the mid RTP extension is being negotiated */\n\t\t\t\t\thandle->stream->mid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_MID);\n\t\t\t\t\t/* Check if the RTP Stream ID extension is being negotiated */\n\t\t\t\t\thandle->stream->rid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_RID);\n\t\t\t\t\thandle->stream->ridrtx_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_REPAIRED_RID);\n\t\t\t\t\t/* Check if the audio level ID extension is being negotiated */\n\t\t\t\t\thandle->stream->audiolevel_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_AUDIO_LEVEL);\n\t\t\t\t\t/* Check if the video orientation ID extension is being negotiated */\n\t\t\t\t\thandle->stream->videoorientation_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_VIDEO_ORIENTATION);\n\t\t\t\t\t/* Check if the frame marking ID extension is being negotiated */\n\t\t\t\t\thandle->stream->framemarking_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_FRAME_MARKING);\n\t\t\t\t\t/* Check if transport wide CC is supported */\n\t\t\t\t\tint transport_wide_cc_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC);\n\t\t\t\t\thandle->stream->do_transport_wide_cc = transport_wide_cc_ext_id > 0 ? TRUE : FALSE;\n\t\t\t\t\thandle->stream->transport_wide_cc_ext_id = transport_wide_cc_ext_id;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* FIXME This is a renegotiation: we can currently only handle simple changes in media\n\t\t\t\t * direction and ICE restarts: anything more complex than that will result in an error */\n\t\t\t\tJANUS_LOG(LOG_INFO, \""[%\""SCNu64\""] Negotiation update, checking what changed...\\n\"", handle->handle_id);\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, TRUE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error processing SDP\\n\"");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \""Error processing SDP\"");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART)) {\n\t\t\t\t\tJANUS_LOG(LOG_INFO, \""[%\""SCNu64\""] Restarting ICE...\\n\"", handle->handle_id);\n\t\t\t\t\t/* Update remote credentials for ICE */\n\t\t\t\t\tif(handle->stream) {\n\t\t\t\t\t\tnice_agent_set_remote_credentials(handle->agent, handle->stream->stream_id,\n\t\t\t\t\t\t\thandle->stream->ruser, handle->stream->rpass);\n\t\t\t\t\t}\n\t\t\t\t\t/* FIXME We only need to do that for offers: if it's an answer, we did that already */\n\t\t\t\t\tif(offer) {\n\t\t\t\t\t\tjanus_ice_restart(handle);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART);\n\t\t\t\t\t}\n\t\t\t\t\t/* If we're full-trickling, we'll need to resend the candidates later */\n\t\t\t\t\tif(janus_ice_is_full_trickle_enabled()) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_RESEND_TRICKLES);\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef HAVE_SCTP\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Were datachannels just added? */\n\t\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_DATA_CHANNELS)) {\n\t\t\t\t\t\tjanus_ice_stream *stream = handle->stream;\n\t\t\t\t\t\tif(stream != NULL && stream->component != NULL\n\t\t\t\t\t\t\t\t&& stream->component->dtls != NULL && stream->component->dtls->sctp == NULL) {\n\t\t\t\t\t\t\t/* Create SCTP association as well */\n\t\t\t\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] Creating datachannels...\\n\"", handle->handle_id);\n\t\t\t\t\t\t\tjanus_dtls_srtp_create_sctp(stream->component->dtls);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tchar *tmp = handle->remote_sdp;\n\t\t\thandle->remote_sdp = g_strdup(jsep_sdp);\n\t\t\tg_free(tmp);\n\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t/* Anonymize SDP */\n\t\t\tif(janus_sdp_anonymize(parsed_sdp) < 0) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \""JSEP error: invalid SDP\"");\n\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjsep_sdp_stripped = janus_sdp_write(parsed_sdp);\n\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\tsdp = NULL;\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t}\n\n\t\t/* Make sure the app handle is still valid */\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this message\"");\n\t\t\tg_free(jsep_type);\n\t\t\tg_free(jsep_sdp_stripped);\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\tgoto jsondone;\n\t\t}\n\n\t\t/* Send the message to the plugin (which must eventually free transaction_text and unref the two objects, body and jsep) */\n\t\tjson_incref(body);\n\t\tjson_t *body_jsep = NULL;\n\t\tif(jsep_sdp_stripped) {\n\t\t\tbody_jsep = json_pack(\""{ssss}\"", \""type\"", jsep_type, \""sdp\"", jsep_sdp_stripped);\n\t\t\t/* Check if simulcasting is enabled */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_VIDEO)) {\n\t\t\t\tif(handle->stream && (handle->stream->rid[0] || handle->stream->video_ssrc_peer[1])) {\n\t\t\t\t\tjson_t *simulcast = json_object();\n\t\t\t\t\t/* If we have rids, pass those, otherwise pass the SSRCs */\n\t\t\t\t\tif(handle->stream->rid[0]) {\n\t\t\t\t\t\tjson_t *rids = json_array();\n\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[0]));\n\t\t\t\t\t\tif(handle->stream->rid[1])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[1]));\n\t\t\t\t\t\tif(handle->stream->rid[2])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""rids\"", rids);\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""rid-ext\"", json_integer(handle->stream->rid_ext_id));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjson_t *ssrcs = json_array();\n\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[0]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[1])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[1]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[2])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""ssrcs\"", ssrcs);\n\t\t\t\t\t}\n\t\t\t\t\tif(handle->stream->framemarking_ext_id > 0)\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""framemarking-ext\"", json_integer(handle->stream->framemarking_ext_id));\n\t\t\t\t\tjson_object_set_new(body_jsep, \""simulcast\"", simulcast);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if this is a renegotiation or update */\n\t\t\tif(renegotiation)\n\t\t\t\tjson_object_set_new(body_jsep, \""update\"", json_true());\n\t\t}\n\t\tjanus_plugin_result *result = plugin_t->handle_message(handle->app_handle,\n\t\t\tg_strdup((char *)transaction_text), body, body_jsep);\n\t\tg_free(jsep_type);\n\t\tg_free(jsep_sdp_stripped);\n\t\tif(result == NULL) {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""Plugin didn't give a result\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(result->type == JANUS_PLUGIN_OK) {\n\t\t\t/* The plugin gave a result already (synchronous request/response) */\n\t\t\tif(result->content == NULL || !json_is_object(result->content)) {\n\t\t\t\t/* Missing content, or not a JSON object */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t\tresult->content == NULL ?\n\t\t\t\t\t\t\""Plugin didn't provide any content for this synchronous response\"" :\n\t\t\t\t\t\t\""Plugin returned an invalid JSON response\"");\n\t\t\t\tjanus_plugin_result_destroy(result);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Reference the content, as destroying the result instance will decref it */\n\t\t\tjson_incref(result->content);\n\t\t\t/* Prepare JSON response */\n\t\t\tjson_t *reply = janus_create_message(\""success\"", session->session_id, transaction_text);\n\t\t\tjson_object_set_new(reply, \""sender\"", json_integer(handle->handle_id));\n\t\t\tif(janus_is_opaqueid_in_api_enabled() && handle->opaque_id != NULL)\n\t\t\t\tjson_object_set_new(reply, \""opaque_id\"", json_string(handle->opaque_id));\n\t\t\tjson_t *plugin_data = json_object();\n\t\t\tjson_object_set_new(plugin_data, \""plugin\"", json_string(plugin_t->get_package()));\n\t\t\tjson_object_set_new(plugin_data, \""data\"", result->content);\n\t\t\tjson_object_set_new(reply, \""plugindata\"", plugin_data);\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else if(result->type == JANUS_PLUGIN_OK_WAIT) {\n\t\t\t/* The plugin received the request but didn't process it yet, send an ack (asynchronous notifications may follow) */\n\t\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t\tif(result->text)\n\t\t\t\tjson_object_set_new(reply, \""hint\"", json_string(result->text));\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t(char *)(result->text ? result->text : \""Plugin returned a severe (unknown) error\""));\n\t\t\tjanus_plugin_result_destroy(result);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin_result_destroy(result);\n\t} else if(!strcasecmp(message_text, \""trickle\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Trickle is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this trickle candidate\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *candidate = json_object_get(root, \""candidate\"");\n\t\tjson_t *candidates = json_object_get(root, \""candidates\"");\n\t\tif(candidate == NULL && candidates == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_MISSING_MANDATORY_ELEMENT, \""Missing mandatory element (candidate|candidates)\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(candidate != NULL && candidates != NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON, \""Can't have both candidate and candidates\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\tJANUS_LOG(LOG_ERR, \""[%\""SCNu64\""] Received a trickle, but still cleaning a previous session\\n\"", handle->handle_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \""Still cleaning a previous session\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&handle->mutex);\n\t\tif(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE)) {\n\t\t\t/* It looks like this peer supports Trickle, after all */\n\t\t\tJANUS_LOG(LOG_VERB, \""Handle %\""SCNu64\"" supports trickle even if it didn't negotiate it...\\n\"", handle->handle_id);\n\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t}\n\t\t/* Is there any stream ready? this trickle may get here before the SDP it relates to */\n\t\tif(handle->stream == NULL) {\n\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] No stream, queueing this trickle as it got here before the SDP...\\n\"", handle->handle_id);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\t/* Is the ICE stack ready already? */\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER)) {\n\t\t\tconst char *cause = NULL;\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER))\n\t\t\t\tcause = \""processing the offer\"";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER))\n\t\t\t\tcause = \""waiting for the answer\"";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\tcause = \""waiting for the offer\"";\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Still %s, queueing this trickle to wait until we're done there...\\n\"",\n\t\t\t\thandle->handle_id, cause);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\tif(candidate != NULL) {\n\t\t\t/* We got a single candidate */\n\t\t\tint error = 0;\n\t\t\tconst char *error_string = NULL;\n\t\t\tif((error = janus_ice_trickle_parse(handle, candidate, &error_string)) != 0) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, error, \""%s\"", error_string);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t} else {\n\t\t\t/* We got multiple candidates in an array */\n\t\t\tif(!json_is_array(candidates)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_ELEMENT_TYPE, \""candidates is not an array\"");\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_LOG(LOG_VERB, \""Got multiple candidates (%zu)\\n\"", json_array_size(candidates));\n\t\t\tif(json_array_size(candidates) > 0) {\n\t\t\t\t/* Handle remote candidates */\n\t\t\t\tsize_t i = 0;\n\t\t\t\tfor(i=0; i<json_array_size(candidates); i++) {\n\t\t\t\t\tjson_t *c = json_array_get(candidates, i);\n\t\t\t\t\t/* FIXME We don't care if any trickle fails to parse */\n\t\t\t\t\tjanus_ice_trickle_parse(handle, c, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ntrickledone:\n\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t/* We reply right away, not to block the web server... */\n\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN_REQUEST, \""Unknown request '%s'\"", message_text);\n\t}\n\njsondone:\n\t/* Done processing */\n\tif(handle != NULL)\n\t\tjanus_refcount_decrease(&handle->ref);\n\tif(session != NULL)\n\t\tjanus_refcount_decrease(&session->ref);\n\treturn ret;\n}""}, {""func_name"": ""janus_session_notify_event"", ""file_path"": ""janus.c"", ""func_code"": ""void janus_session_notify_event(janus_session *session, json_t *event) {\n\tif(session != NULL && !g_atomic_int_get(&session->destroyed)) {\n\t\tjanus_mutex_lock(&session->mutex);\n\t\tif(session->source != NULL && session->source->transport != NULL) {\n\t\t\t/* Send this to the transport client */\n\t\t\tJANUS_LOG(LOG_HUGE, \""Sending event to %s (%p)\\n\"", session->source->transport->get_package(), session->source->instance);\n\t\t\tsession->source->transport->send_message(session->source->instance, NULL, FALSE, event);\n\t\t} else {\n\t\t\t/* No transport, free the event */\n\t\t\tjson_decref(event);\n\t\t}\n\t\tjanus_mutex_unlock(&session->mutex);\n\t} else {\n\t\t/* No session, free the event */\n\t\tjson_decref(event);\n\t}\n}""}, {""func_name"": ""janus_transport_gone"", ""file_path"": ""janus.c"", ""func_code"": ""void janus_transport_gone(janus_transport *plugin, janus_transport_session *transport) {\n\t/* Get rid of sessions this transport was handling */\n\tJANUS_LOG(LOG_VERB, \""A %s transport instance has gone away (%p)\\n\"", plugin->get_package(), transport);\n\tjanus_mutex_lock(&sessions_mutex);\n\tif(sessions && g_hash_table_size(sessions) > 0) {\n\t\tGHashTableIter iter;\n\t\tgpointer value;\n\t\tg_hash_table_iter_init(&iter, sessions);\n\t\twhile(g_hash_table_iter_next(&iter, NULL, &value)) {\n\t\t\tjanus_session *session = (janus_session *) value;\n\t\t\tif(!session || g_atomic_int_get(&session->destroyed) || g_atomic_int_get(&session->timeout) || session->last_activity == 0)\n\t\t\t\tcontinue;\n\t\t\tif(session->source && session->source->instance == transport) {\n\t\t\t\tJANUS_LOG(LOG_VERB, \""  -- Session %\""SCNu64\"" will be over if not reclaimed\\n\"", session->session_id);\n\t\t\t\tJANUS_LOG(LOG_VERB, \""  -- Marking Session %\""SCNu64\"" as over\\n\"", session->session_id);\n\t\t\t\tif(reclaim_session_timeout < 1) { /* Reclaim session timeouts are disabled */\n\t\t\t\t\t/* Mark the session as destroyed */\n\t\t\t\t\tjanus_session_destroy(session);\n\t\t\t\t\tg_hash_table_iter_remove(&iter);\n\t\t\t\t} else {\n\t\t\t\t\t/* Set flag for transport_gone. The Janus sessions watchdog will clean this up if not reclaimed */\n\t\t\t\t\tg_atomic_int_set(&session->transport_gone, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tjanus_mutex_unlock(&sessions_mutex);\n}""}, {""func_name"": ""janus_process_incoming_request"", ""file_path"": ""janus.c"", ""func_code"": ""int janus_process_incoming_request(janus_request *request) {\n\tint ret = -1;\n\tif(request == NULL) {\n\t\tJANUS_LOG(LOG_ERR, \""Missing request or payload to process, giving up...\\n\"");\n\t\treturn ret;\n\t}\n\tint error_code = 0;\n\tchar error_cause[100];\n\tjson_t *root = request->message;\n\t/* Ok, let's start with the ids */\n\tguint64 session_id = 0, handle_id = 0;\n\tjson_t *s = json_object_get(root, \""session_id\"");\n\tif(s && json_is_integer(s))\n\t\tsession_id = json_integer_value(s);\n\tjson_t *h = json_object_get(root, \""handle_id\"");\n\tif(h && json_is_integer(h))\n\t\thandle_id = json_integer_value(h);\n\n\tjanus_session *session = NULL;\n\tjanus_ice_handle *handle = NULL;\n\n\t/* Get transaction and message request */\n\tJANUS_VALIDATE_JSON_OBJECT(root, incoming_request_parameters,\n\t\terror_code, error_cause, FALSE,\n\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\tif(error_code != 0) {\n\t\tret = janus_process_error_string(request, session_id, NULL, error_code, error_cause);\n\t\tgoto jsondone;\n\t}\n\tjson_t *transaction = json_object_get(root, \""transaction\"");\n\tconst gchar *transaction_text = json_string_value(transaction);\n\tjson_t *message = json_object_get(root, \""janus\"");\n\tconst gchar *message_text = json_string_value(message);\n\n\tif(session_id == 0 && handle_id == 0) {\n\t\t/* Can only be a 'Create new session', a 'Get info' or a 'Ping/Pong' request */\n\t\tif(!strcasecmp(message_text, \""info\"")) {\n\t\t\tret = janus_process_success(request, janus_info(transaction_text));\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(!strcasecmp(message_text, \""ping\"")) {\n\t\t\t/* Prepare JSON reply */\n\t\t\tjson_t *reply = janus_create_message(\""pong\"", 0, transaction_text);\n\t\t\tret = janus_process_success(request, reply);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(strcasecmp(message_text, \""create\"")) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Make sure we're accepting new sessions */\n\t\tif(!accept_new_sessions) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_NOT_ACCEPTING_SESSIONS, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Any secret/token to check? */\n\t\tret = janus_request_check_secret(request, session_id, transaction_text);\n\t\tif(ret != 0) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = 0;\n\t\tjson_t *id = json_object_get(root, \""id\"");\n\t\tif(id != NULL) {\n\t\t\t/* The application provided the session ID to use */\n\t\t\tsession_id = json_integer_value(id);\n\t\t\tif(session_id > 0 && (session = janus_session_find(session_id)) != NULL) {\n\t\t\t\t/* Session ID already taken */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_CONFLICT, \""Session ID already in use\"");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t}\n\t\t/* Handle it */\n\t\tsession = janus_session_create(session_id);\n\t\tif(session == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Memory error\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tsession_id = session->session_id;\n\t\t/* We increase the counter as this request is using the session */\n\t\tjanus_refcount_increase(&session->ref);\n\t\t/* Take note of the request source that originated this session (HTTP, WebSockets, RabbitMQ?) */\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the source that a new session has been created */\n\t\trequest->transport->session_created(request->instance, session->session_id);\n\t\t/* Notify event handlers */\n\t\tif(janus_events_is_enabled()) {\n\t\t\t/* Session created, add info on the transport that originated it */\n\t\t\tjson_t *transport = json_object();\n\t\t\tjson_object_set_new(transport, \""transport\"", json_string(session->source->transport->get_package()));\n\t\t\tchar id[32];\n\t\t\tmemset(id, 0, sizeof(id));\n\t\t\tg_snprintf(id, sizeof(id), \""%p\"", session->source->instance);\n\t\t\tjson_object_set_new(transport, \""id\"", json_string(id));\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \""created\"", transport);\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", 0, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \""id\"", json_integer(session_id));\n\t\tjson_object_set_new(reply, \""data\"", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\tgoto jsondone;\n\t}\n\tif(session_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \""Invalid session\\n\"");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\tif(h && handle_id < 1) {\n\t\tJANUS_LOG(LOG_ERR, \""Invalid handle\\n\"");\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* Go on with the processing */\n\tret = janus_request_check_secret(request, session_id, transaction_text);\n\tif(ret != 0) {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED, NULL);\n\t\tgoto jsondone;\n\t}\n\n\t/* If we got here, make sure we have a session (and/or a handle) */\n\tsession = janus_session_find(session_id);\n\tif(!session) {\n\t\tJANUS_LOG(LOG_ERR, \""Couldn't find any session %\""SCNu64\""...\\n\"", session_id);\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_SESSION_NOT_FOUND, \""No such session %\""SCNu64\""\"", session_id);\n\t\tgoto jsondone;\n\t}\n\t/* Update the last activity timer */\n\tsession->last_activity = janus_get_monotonic_time();\n\thandle = NULL;\n\tif(handle_id > 0) {\n\t\thandle = janus_session_handles_find(session, handle_id);\n\t\tif(!handle) {\n\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't find any handle %\""SCNu64\"" in session %\""SCNu64\""...\\n\"", handle_id, session_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_HANDLE_NOT_FOUND, \""No such handle %\""SCNu64\"" in session %\""SCNu64\""\"", handle_id, session_id);\n\t\t\tgoto jsondone;\n\t\t}\n\t}\n\n\t/* What is this? */\n\tif(!strcasecmp(message_text, \""keepalive\"")) {\n\t\t/* Just a keep-alive message, reply with an ack */\n\t\tJANUS_LOG(LOG_VERB, \""Got a keep-alive on session %\""SCNu64\""\\n\"", session_id);\n\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""attach\"")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Attach is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, attach_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *plugin = json_object_get(root, \""plugin\"");\n\t\tconst gchar *plugin_text = json_string_value(plugin);\n\t\tjanus_plugin *plugin_t = janus_plugin_find(plugin_text);\n\t\tif(plugin_t == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_NOT_FOUND, \""No such plugin '%s'\"", plugin_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* If the auth token mechanism is enabled, we should check if this token can access this plugin */\n\t\tif(janus_auth_is_enabled()) {\n\t\t\tjson_t *token = json_object_get(root, \""token\"");\n\t\t\tif(token != NULL) {\n\t\t\t\tconst char *token_value = json_string_value(token);\n\t\t\t\tif(token_value && !janus_auth_check_plugin(token_value, plugin_t)) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Token '%s' can't access plugin '%s'\\n\"", token_value, plugin_text);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNAUTHORIZED_PLUGIN, \""Provided token can't access plugin '%s'\"", plugin_text);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjson_t *opaque = json_object_get(root, \""opaque_id\"");\n\t\tconst char *opaque_id = opaque ? json_string_value(opaque) : NULL;\n\t\t/* Create handle */\n\t\thandle = janus_ice_handle_create(session, opaque_id);\n\t\tif(handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Memory error\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\thandle_id = handle->handle_id;\n\t\t/* We increase the counter as this request is using the handle */\n\t\tjanus_refcount_increase(&handle->ref);\n\t\t/* Attach to the plugin */\n\t\tint error = 0;\n\t\tif((error = janus_ice_handle_attach_plugin(session, handle, plugin_t)) != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tjanus_session_handles_remove(session, handle);\n\t\t\tJANUS_LOG(LOG_ERR, \""Couldn't attach to plugin '%s', error '%d'\\n\"", plugin_text, error);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_ATTACH, \""Couldn't attach to plugin: error '%d'\"", error);\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\tjson_t *data = json_object();\n\t\tjson_object_set_new(data, \""id\"", json_integer(handle_id));\n\t\tjson_object_set_new(reply, \""data\"", data);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""destroy\"")) {\n\t\tif(handle != NULL) {\n\t\t\t/* Query is a session-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&sessions_mutex);\n\t\tg_hash_table_remove(sessions, &session->session_id);\n\t\tjanus_mutex_unlock(&sessions_mutex);\n\t\t/* Notify the source that the session has been destroyed */\n\t\tjanus_mutex_lock(&session->mutex);\n\t\tif(session->source && session->source->transport)\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, FALSE);\n\t\tjanus_mutex_unlock(&session->mutex);\n\t\t/* Schedule the session for deletion */\n\t\tjanus_session_destroy(session);\n\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t\t/* Notify event handlers as well */\n\t\tif(janus_events_is_enabled())\n\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_SESSION, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\tsession_id, \""destroyed\"", NULL);\n\t} else if(!strcasecmp(message_text, \""detach\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""No plugin to detach from\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tint error = janus_session_handles_remove(session, handle);\n\t\tif(error != 0) {\n\t\t\t/* TODO Make error struct to pass verbose information */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""Couldn't detach from plugin: error '%d'\"", error);\n\t\t\t/* TODO Delete handle instance */\n\t\t\tgoto jsondone;\n\t\t}\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""hangup\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_DETACH, \""No plugin attached\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_ice_webrtc_hangup(handle, \""Janus API\"");\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = janus_create_message(\""success\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""claim\"")) {\n\t\tjanus_mutex_lock(&session->mutex);\n\t\tif(session->source != NULL) {\n\t\t\t/* If we're claiming from the same transport, ignore */\n\t\t\tif(session->source->instance == request->instance) {\n\t\t\t\tjanus_mutex_unlock(&session->mutex);\n\t\t\t\t/* Prepare JSON reply */\n\t\t\t\tjson_t *reply = json_object();\n\t\t\t\tjson_object_set_new(reply, \""janus\"", json_string(\""success\""));\n\t\t\t\tjson_object_set_new(reply, \""session_id\"", json_integer(session_id));\n\t\t\t\tjson_object_set_new(reply, \""transaction\"", json_string(transaction_text));\n\t\t\t\t/* Send the success reply */\n\t\t\t\tret = janus_process_success(request, reply);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Notify the old transport that this session is over for them, but has been reclaimed */\n\t\t\tsession->source->transport->session_over(session->source->instance, session->session_id, FALSE, TRUE);\n\t\t\tjanus_request_destroy(session->source);\n\t\t\tsession->source = NULL;\n\t\t}\n\t\tsession->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL);\n\t\t/* Notify the new transport that it has claimed a session */\n\t\tsession->source->transport->session_claimed(session->source->instance, session->session_id);\n\t\t/* Previous transport may be gone, clear flag */\n\t\tg_atomic_int_set(&session->transport_gone, 0);\n\t\tjanus_mutex_unlock(&session->mutex);\n\t\t/* Prepare JSON reply */\n\t\tjson_t *reply = json_object();\n\t\tjson_object_set_new(reply, \""janus\"", json_string(\""success\""));\n\t\tjson_object_set_new(reply, \""session_id\"", json_integer(session_id));\n\t\tjson_object_set_new(reply, \""transaction\"", json_string(transaction_text));\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else if(!strcasecmp(message_text, \""message\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Query is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || handle->app_handle == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this message\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin *plugin_t = (janus_plugin *)handle->app;\n\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] There's a message for %s\\n\"", handle->handle_id, plugin_t->get_name());\n\t\tJANUS_VALIDATE_JSON_OBJECT(root, body_parameters,\n\t\t\terror_code, error_cause, FALSE,\n\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\tif(error_code != 0) {\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *body = json_object_get(root, \""body\"");\n\t\t/* Is there an SDP attached? */\n\t\tjson_t *jsep = json_object_get(root, \""jsep\"");\n\t\tchar *jsep_type = NULL;\n\t\tchar *jsep_sdp = NULL, *jsep_sdp_stripped = NULL;\n\t\tgboolean renegotiation = FALSE;\n\t\tif(jsep != NULL) {\n\t\t\tif(!json_is_object(jsep)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON_OBJECT, \""Invalid jsep object\"");\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_VALIDATE_JSON_OBJECT_FORMAT(\""JSEP error: missing mandatory element (%s)\"",\n\t\t\t\t\""JSEP error: invalid element type (%s should be %s)\"",\n\t\t\t\tjsep, jsep_parameters, error_code, error_cause, FALSE,\n\t\t\t\tJANUS_ERROR_MISSING_MANDATORY_ELEMENT, JANUS_ERROR_INVALID_ELEMENT_TYPE);\n\t\t\tif(error_code != 0) {\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, error_code, error_cause);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *type = json_object_get(jsep, \""type\"");\n\t\t\tjsep_type = g_strdup(json_string_value(type));\n\t\t\ttype = NULL;\n\t\t\tgboolean do_trickle = TRUE;\n\t\t\tjson_t *jsep_trickle = json_object_get(jsep, \""trickle\"");\n\t\t\tdo_trickle = jsep_trickle ? json_is_true(jsep_trickle) : TRUE;\n\t\t\t/* Are we still cleaning up from a previous media session? */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Still cleaning up from a previous media session, let's wait a bit...\\n\"", handle->handle_id);\n\t\t\t\tgint64 waited = 0;\n\t\t\t\twhile(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\t\t\tg_usleep(100000);\n\t\t\t\t\twaited += 100000;\n\t\t\t\t\tif(waited >= 3*G_USEC_PER_SEC) {\n\t\t\t\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""]   -- Waited 3 seconds, that's enough!\\n\"", handle->handle_id);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \""Still cleaning a previous session\"");\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if we're renegotiating (if we have an answer, we did an offer/answer round already) */\n\t\t\trenegotiation = janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t/* Check the JSEP type */\n\t\t\tjanus_mutex_lock(&handle->mutex);\n\t\t\tint offer = 0;\n\t\t\tif(!strcasecmp(jsep_type, \""offer\"")) {\n\t\t\t\toffer = 1;\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t} else if(!strcasecmp(jsep_type, \""answer\"")) {\n\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER);\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_NEGOTIATED);\n\t\t\t\toffer = 0;\n\t\t\t} else {\n\t\t\t\t/* TODO Handle other message types as well */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_UNKNOWN_TYPE, \""JSEP error: unknown message type '%s'\"", jsep_type);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjson_t *sdp = json_object_get(jsep, \""sdp\"");\n\t\t\tjsep_sdp = (char *)json_string_value(sdp);\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Remote SDP:\\n%s\"", handle->handle_id, jsep_sdp);\n\t\t\t/* Is this valid SDP? */\n\t\t\tchar error_str[512];\n\t\t\tint audio = 0, video = 0, data = 0;\n\t\t\tjanus_sdp *parsed_sdp = janus_sdp_preparse(handle, jsep_sdp, error_str, sizeof(error_str), &audio, &video, &data);\n\t\t\tif(parsed_sdp == NULL) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, error_str);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Notify event handlers */\n\t\t\tif(janus_events_is_enabled()) {\n\t\t\t\tjanus_events_notify_handlers(JANUS_EVENT_TYPE_JSEP, JANUS_EVENT_SUBTYPE_NONE,\n\t\t\t\t\tsession_id, handle_id, handle->opaque_id, \""remote\"", jsep_type, jsep_sdp);\n\t\t\t}\n\t\t\t/* FIXME We're only handling single audio/video lines for now... */\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Audio %s been negotiated, Video %s been negotiated, SCTP/DataChannels %s been negotiated\\n\"",\n\t\t\t                    handle->handle_id,\n\t\t\t                    audio ? \""has\"" : \""has NOT\"",\n\t\t\t                    video ? \""has\"" : \""has NOT\"",\n\t\t\t                    data ? \""have\"" : \""have NOT\"");\n\t\t\tif(audio > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one audio line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n\t\t\tif(video > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one video line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n\t\t\tif(data > 1) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] More than one data line? only going to negotiate one...\\n\"", handle->handle_id);\n\t\t\t}\n#ifndef HAVE_SCTP\n\t\t\tif(data) {\n\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""]   -- DataChannels have been negotiated, but support for them has not been compiled...\\n\"", handle->handle_id);\n\t\t\t}\n#endif\n\t\t\t/* We behave differently if it's a new session or an update... */\n\t\t\tif(!renegotiation) {\n\t\t\t\t/* New session */\n\t\t\t\tif(offer) {\n\t\t\t\t\t/* Setup ICE locally (we received an offer) */\n\t\t\t\t\tif(janus_ice_setup_local(handle, offer, audio, video, data, do_trickle) < 0) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error setting ICE locally\\n\"");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN, \""Error setting ICE locally\"");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Make sure we're waiting for an ANSWER in the first place */\n\t\t\t\t\tif(!handle->agent) {\n\t\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Unexpected ANSWER (did we offer?)\\n\"");\n\t\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \""Unexpected ANSWER (did we offer?)\"");\n\t\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\t\tgoto jsondone;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, FALSE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error processing SDP\\n\"");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \""Error processing SDP\"");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Set remote candidates now (we received an answer) */\n\t\t\t\t\tif(do_trickle) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t\t\t\t}\n\t\t\t\t\tjanus_request_ice_handle_answer(handle, audio, video, data, jsep_sdp);\n\t\t\t\t} else {\n\t\t\t\t\t/* Check if the mid RTP extension is being negotiated */\n\t\t\t\t\thandle->stream->mid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_MID);\n\t\t\t\t\t/* Check if the RTP Stream ID extension is being negotiated */\n\t\t\t\t\thandle->stream->rid_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_RID);\n\t\t\t\t\thandle->stream->ridrtx_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_REPAIRED_RID);\n\t\t\t\t\t/* Check if the audio level ID extension is being negotiated */\n\t\t\t\t\thandle->stream->audiolevel_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_AUDIO_LEVEL);\n\t\t\t\t\t/* Check if the video orientation ID extension is being negotiated */\n\t\t\t\t\thandle->stream->videoorientation_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_VIDEO_ORIENTATION);\n\t\t\t\t\t/* Check if the frame marking ID extension is being negotiated */\n\t\t\t\t\thandle->stream->framemarking_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_FRAME_MARKING);\n\t\t\t\t\t/* Check if transport wide CC is supported */\n\t\t\t\t\tint transport_wide_cc_ext_id = janus_rtp_header_extension_get_id(jsep_sdp, JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC);\n\t\t\t\t\thandle->stream->do_transport_wide_cc = transport_wide_cc_ext_id > 0 ? TRUE : FALSE;\n\t\t\t\t\thandle->stream->transport_wide_cc_ext_id = transport_wide_cc_ext_id;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* FIXME This is a renegotiation: we can currently only handle simple changes in media\n\t\t\t\t * direction and ICE restarts: anything more complex than that will result in an error */\n\t\t\t\tJANUS_LOG(LOG_INFO, \""[%\""SCNu64\""] Negotiation update, checking what changed...\\n\"", handle->handle_id);\n\t\t\t\tif(janus_sdp_process(handle, parsed_sdp, TRUE) < 0) {\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \""Error processing SDP\\n\"");\n\t\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\t\tg_free(jsep_type);\n\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNEXPECTED_ANSWER, \""Error processing SDP\"");\n\t\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\t\tgoto jsondone;\n\t\t\t\t}\n\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART)) {\n\t\t\t\t\tJANUS_LOG(LOG_INFO, \""[%\""SCNu64\""] Restarting ICE...\\n\"", handle->handle_id);\n\t\t\t\t\t/* Update remote credentials for ICE */\n\t\t\t\t\tif(handle->stream) {\n\t\t\t\t\t\tnice_agent_set_remote_credentials(handle->agent, handle->stream->stream_id,\n\t\t\t\t\t\t\thandle->stream->ruser, handle->stream->rpass);\n\t\t\t\t\t}\n\t\t\t\t\t/* FIXME We only need to do that for offers: if it's an answer, we did that already */\n\t\t\t\t\tif(offer) {\n\t\t\t\t\t\tjanus_ice_restart(handle);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_ICE_RESTART);\n\t\t\t\t\t}\n\t\t\t\t\t/* If we're full-trickling, we'll need to resend the candidates later */\n\t\t\t\t\tif(janus_ice_is_full_trickle_enabled()) {\n\t\t\t\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_RESEND_TRICKLES);\n\t\t\t\t\t}\n\t\t\t\t}\n#ifdef HAVE_SCTP\n\t\t\t\tif(!offer) {\n\t\t\t\t\t/* Were datachannels just added? */\n\t\t\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_DATA_CHANNELS)) {\n\t\t\t\t\t\tjanus_ice_stream *stream = handle->stream;\n\t\t\t\t\t\tif(stream != NULL && stream->component != NULL\n\t\t\t\t\t\t\t\t&& stream->component->dtls != NULL && stream->component->dtls->sctp == NULL) {\n\t\t\t\t\t\t\t/* Create SCTP association as well */\n\t\t\t\t\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] Creating datachannels...\\n\"", handle->handle_id);\n\t\t\t\t\t\t\tjanus_dtls_srtp_create_sctp(stream->component->dtls);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tchar *tmp = handle->remote_sdp;\n\t\t\thandle->remote_sdp = g_strdup(jsep_sdp);\n\t\t\tg_free(tmp);\n\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t/* Anonymize SDP */\n\t\t\tif(janus_sdp_anonymize(parsed_sdp) < 0) {\n\t\t\t\t/* Invalid SDP */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_JSEP_INVALID_SDP, \""JSEP error: invalid SDP\"");\n\t\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\t\tg_free(jsep_type);\n\t\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tjsep_sdp_stripped = janus_sdp_write(parsed_sdp);\n\t\t\tjanus_sdp_destroy(parsed_sdp);\n\t\t\tsdp = NULL;\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t}\n\n\t\t/* Make sure the app handle is still valid */\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this message\"");\n\t\t\tg_free(jsep_type);\n\t\t\tg_free(jsep_sdp_stripped);\n\t\t\tjanus_flags_clear(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER);\n\t\t\tgoto jsondone;\n\t\t}\n\n\t\t/* Send the message to the plugin (which must eventually free transaction_text and unref the two objects, body and jsep) */\n\t\tjson_incref(body);\n\t\tjson_t *body_jsep = NULL;\n\t\tif(jsep_sdp_stripped) {\n\t\t\tbody_jsep = json_pack(\""{ssss}\"", \""type\"", jsep_type, \""sdp\"", jsep_sdp_stripped);\n\t\t\t/* Check if simulcasting is enabled */\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_HAS_VIDEO)) {\n\t\t\t\tif(handle->stream && (handle->stream->rid[0] || handle->stream->video_ssrc_peer[1])) {\n\t\t\t\t\tjson_t *simulcast = json_object();\n\t\t\t\t\t/* If we have rids, pass those, otherwise pass the SSRCs */\n\t\t\t\t\tif(handle->stream->rid[0]) {\n\t\t\t\t\t\tjson_t *rids = json_array();\n\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[0]));\n\t\t\t\t\t\tif(handle->stream->rid[1])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[1]));\n\t\t\t\t\t\tif(handle->stream->rid[2])\n\t\t\t\t\t\t\tjson_array_append_new(rids, json_string(handle->stream->rid[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""rids\"", rids);\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""rid-ext\"", json_integer(handle->stream->rid_ext_id));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjson_t *ssrcs = json_array();\n\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[0]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[1])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[1]));\n\t\t\t\t\t\tif(handle->stream->video_ssrc_peer[2])\n\t\t\t\t\t\t\tjson_array_append_new(ssrcs, json_integer(handle->stream->video_ssrc_peer[2]));\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""ssrcs\"", ssrcs);\n\t\t\t\t\t}\n\t\t\t\t\tif(handle->stream->framemarking_ext_id > 0)\n\t\t\t\t\t\tjson_object_set_new(simulcast, \""framemarking-ext\"", json_integer(handle->stream->framemarking_ext_id));\n\t\t\t\t\tjson_object_set_new(body_jsep, \""simulcast\"", simulcast);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Check if this is a renegotiation or update */\n\t\t\tif(renegotiation)\n\t\t\t\tjson_object_set_new(body_jsep, \""update\"", json_true());\n\t\t}\n\t\tjanus_plugin_result *result = plugin_t->handle_message(handle->app_handle,\n\t\t\tg_strdup((char *)transaction_text), body, body_jsep);\n\t\tg_free(jsep_type);\n\t\tg_free(jsep_sdp_stripped);\n\t\tif(result == NULL) {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""Plugin didn't give a result\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(result->type == JANUS_PLUGIN_OK) {\n\t\t\t/* The plugin gave a result already (synchronous request/response) */\n\t\t\tif(result->content == NULL || !json_is_object(result->content)) {\n\t\t\t\t/* Missing content, or not a JSON object */\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t\tresult->content == NULL ?\n\t\t\t\t\t\t\""Plugin didn't provide any content for this synchronous response\"" :\n\t\t\t\t\t\t\""Plugin returned an invalid JSON response\"");\n\t\t\t\tjanus_plugin_result_destroy(result);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\t/* Reference the content, as destroying the result instance will decref it */\n\t\t\tjson_incref(result->content);\n\t\t\t/* Prepare JSON response */\n\t\t\tjson_t *reply = janus_create_message(\""success\"", session->session_id, transaction_text);\n\t\t\tjson_object_set_new(reply, \""sender\"", json_integer(handle->handle_id));\n\t\t\tif(janus_is_opaqueid_in_api_enabled() && handle->opaque_id != NULL)\n\t\t\t\tjson_object_set_new(reply, \""opaque_id\"", json_string(handle->opaque_id));\n\t\t\tjson_t *plugin_data = json_object();\n\t\t\tjson_object_set_new(plugin_data, \""plugin\"", json_string(plugin_t->get_package()));\n\t\t\tjson_object_set_new(plugin_data, \""data\"", result->content);\n\t\t\tjson_object_set_new(reply, \""plugindata\"", plugin_data);\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else if(result->type == JANUS_PLUGIN_OK_WAIT) {\n\t\t\t/* The plugin received the request but didn't process it yet, send an ack (asynchronous notifications may follow) */\n\t\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t\tif(result->text)\n\t\t\t\tjson_object_set_new(reply, \""hint\"", json_string(result->text));\n\t\t\t/* Send the success reply */\n\t\t\tret = janus_process_success(request, reply);\n\t\t} else {\n\t\t\t/* Something went horribly wrong! */\n\t\t\tret = janus_process_error_string(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE,\n\t\t\t\t(char *)(result->text ? result->text : \""Plugin returned a severe (unknown) error\""));\n\t\t\tjanus_plugin_result_destroy(result);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_plugin_result_destroy(result);\n\t} else if(!strcasecmp(message_text, \""trickle\"")) {\n\t\tif(handle == NULL) {\n\t\t\t/* Trickle is an handle-level command */\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_REQUEST_PATH, \""Unhandled request '%s' at this path\"", message_text);\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(handle->app == NULL || !janus_plugin_session_is_alive(handle->app_handle)) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_PLUGIN_MESSAGE, \""No plugin to handle this trickle candidate\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjson_t *candidate = json_object_get(root, \""candidate\"");\n\t\tjson_t *candidates = json_object_get(root, \""candidates\"");\n\t\tif(candidate == NULL && candidates == NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_MISSING_MANDATORY_ELEMENT, \""Missing mandatory element (candidate|candidates)\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(candidate != NULL && candidates != NULL) {\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_JSON, \""Can't have both candidate and candidates\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_CLEANING)) {\n\t\t\tJANUS_LOG(LOG_ERR, \""[%\""SCNu64\""] Received a trickle, but still cleaning a previous session\\n\"", handle->handle_id);\n\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_WEBRTC_STATE, \""Still cleaning a previous session\"");\n\t\t\tgoto jsondone;\n\t\t}\n\t\tjanus_mutex_lock(&handle->mutex);\n\t\tif(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE)) {\n\t\t\t/* It looks like this peer supports Trickle, after all */\n\t\t\tJANUS_LOG(LOG_VERB, \""Handle %\""SCNu64\"" supports trickle even if it didn't negotiate it...\\n\"", handle->handle_id);\n\t\t\tjanus_flags_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_TRICKLE);\n\t\t}\n\t\t/* Is there any stream ready? this trickle may get here before the SDP it relates to */\n\t\tif(handle->stream == NULL) {\n\t\t\tJANUS_LOG(LOG_WARN, \""[%\""SCNu64\""] No stream, queueing this trickle as it got here before the SDP...\\n\"", handle->handle_id);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\t/* Is the ICE stack ready already? */\n\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER) ||\n\t\t\t\t!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER)) {\n\t\t\tconst char *cause = NULL;\n\t\t\tif(janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_PROCESSING_OFFER))\n\t\t\t\tcause = \""processing the offer\"";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_ANSWER))\n\t\t\t\tcause = \""waiting for the answer\"";\n\t\t\telse if(!janus_flags_is_set(&handle->webrtc_flags, JANUS_ICE_HANDLE_WEBRTC_GOT_OFFER))\n\t\t\t\tcause = \""waiting for the offer\"";\n\t\t\tJANUS_LOG(LOG_VERB, \""[%\""SCNu64\""] Still %s, queueing this trickle to wait until we're done there...\\n\"",\n\t\t\t\thandle->handle_id, cause);\n\t\t\t/* Enqueue this trickle candidate(s), we'll process this later */\n\t\t\tjanus_ice_trickle *early_trickle = janus_ice_trickle_new(transaction_text, candidate ? candidate : candidates);\n\t\t\thandle->pending_trickles = g_list_append(handle->pending_trickles, early_trickle);\n\t\t\t/* Send the ack right away, an event will tell the application if the candidate(s) failed */\n\t\t\tgoto trickledone;\n\t\t}\n\t\tif(candidate != NULL) {\n\t\t\t/* We got a single candidate */\n\t\t\tint error = 0;\n\t\t\tconst char *error_string = NULL;\n\t\t\tif((error = janus_ice_trickle_parse(handle, candidate, &error_string)) != 0) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, error, \""%s\"", error_string);\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t} else {\n\t\t\t/* We got multiple candidates in an array */\n\t\t\tif(!json_is_array(candidates)) {\n\t\t\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_INVALID_ELEMENT_TYPE, \""candidates is not an array\"");\n\t\t\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t\t\tgoto jsondone;\n\t\t\t}\n\t\t\tJANUS_LOG(LOG_VERB, \""Got multiple candidates (%zu)\\n\"", json_array_size(candidates));\n\t\t\tif(json_array_size(candidates) > 0) {\n\t\t\t\t/* Handle remote candidates */\n\t\t\t\tsize_t i = 0;\n\t\t\t\tfor(i=0; i<json_array_size(candidates); i++) {\n\t\t\t\t\tjson_t *c = json_array_get(candidates, i);\n\t\t\t\t\t/* FIXME We don't care if any trickle fails to parse */\n\t\t\t\t\tjanus_ice_trickle_parse(handle, c, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ntrickledone:\n\t\tjanus_mutex_unlock(&handle->mutex);\n\t\t/* We reply right away, not to block the web server... */\n\t\tjson_t *reply = janus_create_message(\""ack\"", session_id, transaction_text);\n\t\t/* Send the success reply */\n\t\tret = janus_process_success(request, reply);\n\t} else {\n\t\tret = janus_process_error(request, session_id, transaction_text, JANUS_ERROR_UNKNOWN_REQUEST, \""Unknown request '%s'\"", message_text);\n\t}\n\njsondone:\n\t/* Done processing */\n\tif(handle != NULL)\n\t\tjanus_refcount_decrease(&handle->ref);\n\tif(session != NULL)\n\t\tjanus_refcount_decrease(&session->ref);\n\treturn ret;\n}""}]","{""value"": 3, ""function"": 4}","[{""source"": ""value_info(file:janus.c, value:session->source)"", ""result"": {""value_trace"": [{""full_code"": ""session->source = NULL"", ""line"": 572, ""func_name"": ""janus_session_free""}, {""full_code"": ""session->source = NULL"", ""line"": 659, ""func_name"": ""janus_session_create""}, {""full_code"": ""session->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL)"", ""line"": 974, ""func_name"": ""janus_process_incoming_request""}, {""full_code"": ""session->source = NULL"", ""line"": 1167, ""func_name"": ""janus_process_incoming_request""}, {""full_code"": ""session->source = janus_request_new(request->transport, request->instance, NULL, FALSE, NULL)"", ""line"": 1169, ""func_name"": ""janus_process_incoming_request""}], ""struct_var"": ""session"", ""struct_type"": ""janus_session*"", ""struct_definition"": ""typedef struct janus_session {\n\t/*! \\brief Janus Core-Client session ID */\n\tguint64 session_id;\n\t/*! \\brief Map of handles this session is managing */\n\tGHashTable *ice_handles;\n\t/*! \\brief Time of the last activity on the session */\n\tgint64 last_activity;\n\t/*! \\brief Pointer to the request instance (and the transport that originated the session) */\n\tjanus_request *source;\n\t/*! \\brief Flag to notify there's been a session timeout */\n\tvolatile gint timeout;\n\t/*! \\brief Flag to notify that transport is gone */\n\tvolatile gint transport_gone;\n\t/*! \\brief Mutex to lock/unlock this session */\n\tjanus_mutex mutex;\n\t/*! \\brief Atomic flag to check if this instance has been destroyed */\n\tvolatile gint destroyed;\n\t/*! \\brief Reference counter for this instance */\n\tjanus_refcount ref;\n}\n\ntypedef struct janus_session {\n\t/*! \\brief Janus Core-Client session ID */\n\tguint64 session_id;\n\t/*! \\brief Map of handles this session is managing */\n\tGHashTable *ice_handles;\n\t/*! \\brief Time of the last activity on the session */\n\tgint64 last_activity;\n\t/*! \\brief Pointer to the request instance (and the transport that originated the session) */\n\tjanus_request *source;\n\t/*! \\brief Flag to notify there's been a session timeout */\n\tvolatile gint timeout;\n\t/*! \\brief Flag to notify that transport is gone */\n\tvolatile gint transport_gone;\n\t/*! \\brief Mutex to lock/unlock this session */\n\tjanus_mutex mutex;\n\t/*! \\brief Atomic flag to check if this instance has been destroyed */\n\tvolatile gint destroyed;\n\t/*! \\brief Reference counter for this instance */\n\tjanus_refcount ref;\n} janus_session;""}}, {""source"": ""func_info(func:janus_session_create)"", ""result"": [{""code"": ""janus_session *janus_session_create(guint64 session_id) {\n\tjanus_session *session = NULL;\n\tif(session_id == 0) {\n\t\twhile(session_id == 0) {\n\t\t\tsession_id = janus_random_uint64();\n\t\t\tsession = janus_se"", ""start_line"": 642, ""end_line"": 670, ""full_name"": ""janus_session_create"", ""file_path"": ""janus.c""}]}, {""source"": ""func_info(func:janus_request_destroy)"", ""result"": [{""code"": ""void janus_request_destroy(janus_request *request) {\n\tif(request == NULL || request == &exit_message)\n\t\treturn;\n\trequest->transport = NULL;\n\tjanus_refcount_decrease(&request->instance->ref);\n\trequest-"", ""start_line"": 788, ""end_line"": 799, ""full_name"": ""janus_request_destroy"", ""file_path"": ""janus.c""}]}, {""source"": ""func_info(func:janus_request_new)"", ""result"": [{""code"": ""janus_request *janus_request_new(janus_transport *transport, janus_transport_session *instance, void *request_id, gboolean admin, json_t *message) {\n\tjanus_request *request = g_malloc(sizeof(janus_req"", ""start_line"": 777, ""end_line"": 786, ""full_name"": ""janus_request_new"", ""file_path"": ""janus.c""}]}, {""source"": ""func_info(func:janus_session_destroy)"", ""result"": [{""code"": ""gint janus_session_destroy(janus_session *session) {\n\tguint64 session_id = session->session_id;\n\tJANUS_LOG(LOG_INFO, \""Destroying session %\""SCNu64\""; %p\\n\"", session_id, session);\n\tif(!g_atomic_int_compa"", ""start_line"": 697, ""end_line"": 707, ""full_name"": ""janus_session_destroy"", ""file_path"": ""janus.c""}]}, {""source"": ""value_info(file:janus.c, value:janus_request)"", ""result"": {""value_trace"": [{""full_code"": ""janus_request"", ""line"": 778, ""func_name"": null}], ""struct_var"": ""janus_request"", ""struct_type"": ""janus_request"", ""struct_definition"": ""struct janus_request {\n\t/*! \\brief Pointer to the transport plugin */\n\tjanus_transport *transport;\n\t/*! \\brief Pointer to the transport-provided session instance */\n\tjanus_transport_session *instance;\n\t/*! \\brief Opaque pointer to the request ID, if available */\n\tvoid *request_id;\n\t/*! \\brief Whether this is a Janus API or admin API request */\n\tgboolean admin;\n\t/*! \\brief Pointer to the original request, if available */\n\tjson_t *message;\n}\n\ntypedef struct janus_request\n\ntypedef struct janus_request janus_request;""}}, {""source"": ""value_info(file:janus.c, value:janus_transport)"", ""result"": {""value_trace"": [{""full_code"": ""*janus_transport = create()"", ""line"": 5028, ""func_name"": ""main<duplicate>1""}], ""struct_var"": ""janus_transport"", ""struct_type"": ""janus_transport*"", ""struct_definition"": ""struct janus_transport {\n\t/*! \\brief Transport plugin initialization/constructor\n\t * @param[in] callback The callback instance the transport plugin can use to contact the Janus core\n\t * @param[in] config_path Path of the folder where the configuration for this transport plugin can be found\n\t * @returns 0 in case of success, a negative integer in case of error */\n\tint (* const init)(janus_transport_callbacks *callback, const char *config_path);\n\t/*! \\brief Transport plugin deinitialization/destructor */\n\tvoid (* const destroy)(void);\n\n\t/*! \\brief Informative method to request the API version this transport plugin was compiled against\n\t *  \\note All transport plugins MUST implement this method and return JANUS_TRANSPORT_API_VERSION\n\t * to make this work, or they will be rejected by the core. */\n\tint (* const get_api_compatibility)(void);\n\t/*! \\brief Informative method to request the numeric version of the transport plugin */\n\tint (* const get_version)(void);\n\t/*! \\brief Informative me...\n\ntypedef struct janus_transport\n\ntypedef struct janus_transport janus_transport;""}}]","The race condition arises from concurrent threads accessing/modify session->source without synchronization in:\n1. janus_process_incoming_request (janus.c:1109-1113): session->source accessed during destruction without lock (patch added mutex).\n2. janus_session_notify_event (janus.c:685-695): session->source checked/used without lock (patch added mutex).\n3. janus_process_incoming_request (janus.c:1163-1183): session->source modified during claim handling (mutex added).\nSession->source is assigned in janus_session_create (janus.c:659), janus_process_incoming_request (janus.c:974, 1169), and cleared in janus_session_free (janus.c:572). No further code evidence was found for thread interaction patterns or additional access points.",0.95,./github/other_context/CVE-2020-10577
55,CVE-2020-19824,CWE-362,c_cpp,An issue in MPV v.0.29.1 fixed in v0.30 allows attackers to execute arbitrary code and crash program via the ao_c parameter.,https://github.com/mpv-player/mpv/commit/5858e3cdbd6fbae3ed80366912dd5df0af4fa126,"audio: fix use-after-free with fuzzed file\n\nreinit_audio_filters_and_output() can fully shutdown the audio chain on\nfailure. Specifically, it will deallocate mpctx->ao_chain. The value of\nthat field was cached in ao_c. The code after the call did not account\nthat the audio chain can be shutdown, and used the stale ao_c value.\n\nFixes: #6808",1,"[{""func_name"": ""fill_audio_out_buffers"", ""file_path"": ""player/audio.c"", ""func_code"": ""void fill_audio_out_buffers(struct MPContext *mpctx)\n{\n    struct MPOpts *opts = mpctx->opts;\n    bool was_eof = mpctx->audio_status == STATUS_EOF;\n\n    dump_audio_stats(mpctx);\n\n    if (mpctx->ao && ao_query_and_reset_events(mpctx->ao, AO_EVENT_RELOAD))\n        reload_audio_output(mpctx);\n\n    if (mpctx->ao && ao_query_and_reset_events(mpctx->ao,\n                                               AO_EVENT_INITIAL_UNBLOCK))\n        ao_unblock(mpctx->ao);\n\n    struct ao_chain *ao_c = mpctx->ao_chain;\n    if (!ao_c)\n        return;\n\n    if (ao_c->filter->failed_output_conversion) {\n        error_on_track(mpctx, ao_c->track);\n        return;\n    }\n\n    // (if AO is set due to gapless from previous file, then we can try to\n    // filter normally until the filter tells us to change the AO)\n    if (!mpctx->ao) {\n        // Probe the initial audio format.\n        mp_pin_out_request_data(ao_c->filter->f->pins[1]);\n        reinit_audio_filters_and_output(mpctx);\n        if (ao_c->filter->got_output_eof &&\n            mpctx->audio_status != STATUS_EOF)\n        {\n            mpctx->audio_status = STATUS_EOF;\n            MP_VERBOSE(mpctx, \""audio EOF without any data\\n\"");\n            mp_filter_reset(ao_c->filter->f);\n            encode_lavc_stream_eof(mpctx->encode_lavc_ctx, STREAM_AUDIO);\n        }\n        return; // try again next iteration\n    }\n\n    if (ao_c->ao_resume_time > mp_time_sec()) {\n        double remaining = ao_c->ao_resume_time - mp_time_sec();\n        mp_set_timeout(mpctx, remaining);\n        return;\n    }\n\n    if (mpctx->vo_chain && ao_c->track && ao_c->track->dec &&\n        ao_c->track->dec->pts_reset)\n    {\n        MP_VERBOSE(mpctx, \""Reset playback due to audio timestamp reset.\\n\"");\n        reset_playback_state(mpctx);\n        mp_wakeup_core(mpctx);\n        return;\n    }\n\n    int ao_rate;\n    int ao_format;\n    struct mp_chmap ao_channels;\n    ao_get_format(mpctx->ao, &ao_rate, &ao_format, &ao_channels);\n    double play_samplerate = ao_rate / mpctx->audio_speed;\n    int align = af_format_sample_alignment(ao_format);\n\n    // If audio is infinitely fast, somehow try keeping approximate A/V sync.\n    if (mpctx->audio_status == STATUS_PLAYING && ao_untimed(mpctx->ao) &&\n        mpctx->video_status != STATUS_EOF && mpctx->delay > 0)\n        return;\n\n    int playsize = ao_get_space(mpctx->ao);\n\n    int skip = 0;\n    bool sync_known = get_sync_samples(mpctx, &skip);\n    if (skip > 0) {\n        playsize = MPMIN(skip + 1, MPMAX(playsize, 2500)); // buffer extra data\n    } else if (skip < 0) {\n        playsize = MPMAX(1, playsize + skip); // silence will be prepended\n    }\n\n    int skip_duplicate = 0; // >0: skip, <0: duplicate\n    double drop_limit =\n        (opts->sync_max_audio_change + opts->sync_max_video_change) / 100;\n    if (mpctx->display_sync_active && opts->video_sync == VS_DISP_ADROP &&\n        fabs(mpctx->last_av_difference) >= opts->sync_audio_drop_size &&\n        mpctx->audio_drop_throttle < drop_limit &&\n        mpctx->audio_status == STATUS_PLAYING)\n    {\n        int samples = ceil(opts->sync_audio_drop_size * play_samplerate);\n        samples = (samples + align / 2) / align * align;\n\n        skip_duplicate = mpctx->last_av_difference >= 0 ? -samples : samples;\n\n        playsize = MPMAX(playsize, samples);\n\n        mpctx->audio_drop_throttle += 1 - drop_limit - samples / play_samplerate;\n    }\n\n    playsize = playsize / align * align;\n\n    int status = mpctx->audio_status >= STATUS_DRAINING ? AD_EOF : AD_OK;\n    bool working = false;\n    if (playsize > mp_audio_buffer_samples(ao_c->ao_buffer)) {\n        status = filter_audio(mpctx, ao_c->ao_buffer, playsize);\n        if (ao_c->filter->ao_needs_update) {\n            reinit_audio_filters_and_output(mpctx);\n            mp_wakeup_core(mpctx);\n            return; // retry on next iteration\n        }\n        if (status == AD_WAIT)\n            return;\n        working = true;\n    }\n\n    // If EOF was reached before, but now something can be decoded, try to\n    // restart audio properly. This helps with video files where audio starts\n    // later. Retrying is needed to get the correct sync PTS.\n    if (mpctx->audio_status >= STATUS_DRAINING &&\n        mp_audio_buffer_samples(ao_c->ao_buffer) > 0)\n    {\n        mpctx->audio_status = STATUS_SYNCING;\n        return; // retry on next iteration\n    }\n\n    bool end_sync = false;\n    if (skip >= 0) {\n        int max = mp_audio_buffer_samples(ao_c->ao_buffer);\n        mp_audio_buffer_skip(ao_c->ao_buffer, MPMIN(skip, max));\n        // If something is left, we definitely reached the target time.\n        end_sync |= sync_known && skip < max;\n        working |= skip > 0;\n    } else if (skip < 0) {\n        if (-skip > playsize) { // heuristic against making the buffer too large\n            ao_reset(mpctx->ao); // some AOs repeat data on underflow\n            mpctx->audio_status = STATUS_DRAINING;\n            mpctx->delay = 0;\n            return;\n        }\n        mp_audio_buffer_prepend_silence(ao_c->ao_buffer, -skip);\n        end_sync = true;\n    }\n\n    if (skip_duplicate) {\n        int max = mp_audio_buffer_samples(ao_c->ao_buffer);\n        if (abs(skip_duplicate) > max)\n            skip_duplicate = skip_duplicate >= 0 ? max : -max;\n        mpctx->last_av_difference += skip_duplicate / play_samplerate;\n        if (skip_duplicate >= 0) {\n            mp_audio_buffer_skip(ao_c->ao_buffer, skip_duplicate);\n            MP_STATS(mpctx, \""drop-audio\"");\n        } else {\n            mp_audio_buffer_duplicate(ao_c->ao_buffer, -skip_duplicate);\n            MP_STATS(mpctx, \""duplicate-audio\"");\n        }\n        MP_VERBOSE(mpctx, \""audio skip_duplicate=%d\\n\"", skip_duplicate);\n    }\n\n    if (mpctx->audio_status == STATUS_SYNCING) {\n        if (end_sync)\n            mpctx->audio_status = STATUS_FILLING;\n        if (status != AD_OK && !mp_audio_buffer_samples(ao_c->ao_buffer))\n            mpctx->audio_status = STATUS_EOF;\n        if (working || end_sync)\n            mp_wakeup_core(mpctx);\n        return; // continue on next iteration\n    }\n\n    assert(mpctx->audio_status >= STATUS_FILLING);\n\n    // We already have as much data as the audio device wants, and can start\n    // writing it any time.\n    if (mpctx->audio_status == STATUS_FILLING)\n        mpctx->audio_status = STATUS_READY;\n\n    // Even if we're done decoding and syncing, let video start first - this is\n    // required, because sending audio to the AO already starts playback.\n    if (mpctx->audio_status == STATUS_READY) {\n        // Warning: relies on handle_playback_restart() being called afterwards.\n        return;\n    }\n\n    bool audio_eof = status == AD_EOF;\n    bool partial_fill = false;\n    int playflags = 0;\n\n    if (playsize > mp_audio_buffer_samples(ao_c->ao_buffer)) {\n        playsize = mp_audio_buffer_samples(ao_c->ao_buffer);\n        partial_fill = true;\n    }\n\n    audio_eof &= partial_fill;\n\n    // With gapless audio, delay this to ao_uninit. There must be only\n    // 1 final chunk, and that is handled when calling ao_uninit().\n    if (audio_eof && !opts->gapless_audio)\n        playflags |= AOPLAY_FINAL_CHUNK;\n\n    uint8_t **planes;\n    int samples;\n    mp_audio_buffer_peek(ao_c->ao_buffer, &planes, &samples);\n    if (audio_eof || samples >= align)\n        samples = samples / align * align;\n    samples = MPMIN(samples, mpctx->paused ? 0 : playsize);\n    int played = write_to_ao(mpctx, planes, samples, playflags);\n    assert(played >= 0 && played <= samples);\n    mp_audio_buffer_skip(ao_c->ao_buffer, played);\n\n    mpctx->audio_drop_throttle =\n        MPMAX(0, mpctx->audio_drop_throttle - played / play_samplerate);\n\n    dump_audio_stats(mpctx);\n\n    mpctx->audio_status = STATUS_PLAYING;\n    if (audio_eof && !playsize) {\n        mpctx->audio_status = STATUS_DRAINING;\n        // Wait until the AO has played all queued data. In the gapless case,\n        // we trigger EOF immediately, and let it play asynchronously.\n        if (ao_eof_reached(mpctx->ao) || opts->gapless_audio) {\n            mpctx->audio_status = STATUS_EOF;\n            if (!was_eof) {\n                MP_VERBOSE(mpctx, \""audio EOF reached\\n\"");\n                mp_wakeup_core(mpctx);\n                encode_lavc_stream_eof(mpctx->encode_lavc_ctx, STREAM_AUDIO);\n            }\n        }\n    }\n}"", ""target"": 0}]","[{""func_name"": ""fill_audio_out_buffers"", ""file_path"": ""player/audio.c"", ""func_code"": ""void fill_audio_out_buffers(struct MPContext *mpctx)\n{\n    struct MPOpts *opts = mpctx->opts;\n    bool was_eof = mpctx->audio_status == STATUS_EOF;\n\n    dump_audio_stats(mpctx);\n\n    if (mpctx->ao && ao_query_and_reset_events(mpctx->ao, AO_EVENT_RELOAD))\n        reload_audio_output(mpctx);\n\n    if (mpctx->ao && ao_query_and_reset_events(mpctx->ao,\n                                               AO_EVENT_INITIAL_UNBLOCK))\n        ao_unblock(mpctx->ao);\n\n    struct ao_chain *ao_c = mpctx->ao_chain;\n    if (!ao_c)\n        return;\n\n    if (ao_c->filter->failed_output_conversion) {\n        error_on_track(mpctx, ao_c->track);\n        return;\n    }\n\n    // (if AO is set due to gapless from previous file, then we can try to\n    // filter normally until the filter tells us to change the AO)\n    if (!mpctx->ao) {\n        // Probe the initial audio format.\n        mp_pin_out_request_data(ao_c->filter->f->pins[1]);\n        reinit_audio_filters_and_output(mpctx);\n        if (!mpctx->ao_chain)\n            return;\n        if (ao_c->filter->got_output_eof &&\n            mpctx->audio_status != STATUS_EOF)\n        {\n            mpctx->audio_status = STATUS_EOF;\n            MP_VERBOSE(mpctx, \""audio EOF without any data\\n\"");\n            mp_filter_reset(ao_c->filter->f);\n            encode_lavc_stream_eof(mpctx->encode_lavc_ctx, STREAM_AUDIO);\n        }\n        return; // try again next iteration\n    }\n\n    if (ao_c->ao_resume_time > mp_time_sec()) {\n        double remaining = ao_c->ao_resume_time - mp_time_sec();\n        mp_set_timeout(mpctx, remaining);\n        return;\n    }\n\n    if (mpctx->vo_chain && ao_c->track && ao_c->track->dec &&\n        ao_c->track->dec->pts_reset)\n    {\n        MP_VERBOSE(mpctx, \""Reset playback due to audio timestamp reset.\\n\"");\n        reset_playback_state(mpctx);\n        mp_wakeup_core(mpctx);\n        return;\n    }\n\n    int ao_rate;\n    int ao_format;\n    struct mp_chmap ao_channels;\n    ao_get_format(mpctx->ao, &ao_rate, &ao_format, &ao_channels);\n    double play_samplerate = ao_rate / mpctx->audio_speed;\n    int align = af_format_sample_alignment(ao_format);\n\n    // If audio is infinitely fast, somehow try keeping approximate A/V sync.\n    if (mpctx->audio_status == STATUS_PLAYING && ao_untimed(mpctx->ao) &&\n        mpctx->video_status != STATUS_EOF && mpctx->delay > 0)\n        return;\n\n    int playsize = ao_get_space(mpctx->ao);\n\n    int skip = 0;\n    bool sync_known = get_sync_samples(mpctx, &skip);\n    if (skip > 0) {\n        playsize = MPMIN(skip + 1, MPMAX(playsize, 2500)); // buffer extra data\n    } else if (skip < 0) {\n        playsize = MPMAX(1, playsize + skip); // silence will be prepended\n    }\n\n    int skip_duplicate = 0; // >0: skip, <0: duplicate\n    double drop_limit =\n        (opts->sync_max_audio_change + opts->sync_max_video_change) / 100;\n    if (mpctx->display_sync_active && opts->video_sync == VS_DISP_ADROP &&\n        fabs(mpctx->last_av_difference) >= opts->sync_audio_drop_size &&\n        mpctx->audio_drop_throttle < drop_limit &&\n        mpctx->audio_status == STATUS_PLAYING)\n    {\n        int samples = ceil(opts->sync_audio_drop_size * play_samplerate);\n        samples = (samples + align / 2) / align * align;\n\n        skip_duplicate = mpctx->last_av_difference >= 0 ? -samples : samples;\n\n        playsize = MPMAX(playsize, samples);\n\n        mpctx->audio_drop_throttle += 1 - drop_limit - samples / play_samplerate;\n    }\n\n    playsize = playsize / align * align;\n\n    int status = mpctx->audio_status >= STATUS_DRAINING ? AD_EOF : AD_OK;\n    bool working = false;\n    if (playsize > mp_audio_buffer_samples(ao_c->ao_buffer)) {\n        status = filter_audio(mpctx, ao_c->ao_buffer, playsize);\n        if (ao_c->filter->ao_needs_update) {\n            reinit_audio_filters_and_output(mpctx);\n            mp_wakeup_core(mpctx);\n            return; // retry on next iteration\n        }\n        if (status == AD_WAIT)\n            return;\n        working = true;\n    }\n\n    // If EOF was reached before, but now something can be decoded, try to\n    // restart audio properly. This helps with video files where audio starts\n    // later. Retrying is needed to get the correct sync PTS.\n    if (mpctx->audio_status >= STATUS_DRAINING &&\n        mp_audio_buffer_samples(ao_c->ao_buffer) > 0)\n    {\n        mpctx->audio_status = STATUS_SYNCING;\n        return; // retry on next iteration\n    }\n\n    bool end_sync = false;\n    if (skip >= 0) {\n        int max = mp_audio_buffer_samples(ao_c->ao_buffer);\n        mp_audio_buffer_skip(ao_c->ao_buffer, MPMIN(skip, max));\n        // If something is left, we definitely reached the target time.\n        end_sync |= sync_known && skip < max;\n        working |= skip > 0;\n    } else if (skip < 0) {\n        if (-skip > playsize) { // heuristic against making the buffer too large\n            ao_reset(mpctx->ao); // some AOs repeat data on underflow\n            mpctx->audio_status = STATUS_DRAINING;\n            mpctx->delay = 0;\n            return;\n        }\n        mp_audio_buffer_prepend_silence(ao_c->ao_buffer, -skip);\n        end_sync = true;\n    }\n\n    if (skip_duplicate) {\n        int max = mp_audio_buffer_samples(ao_c->ao_buffer);\n        if (abs(skip_duplicate) > max)\n            skip_duplicate = skip_duplicate >= 0 ? max : -max;\n        mpctx->last_av_difference += skip_duplicate / play_samplerate;\n        if (skip_duplicate >= 0) {\n            mp_audio_buffer_skip(ao_c->ao_buffer, skip_duplicate);\n            MP_STATS(mpctx, \""drop-audio\"");\n        } else {\n            mp_audio_buffer_duplicate(ao_c->ao_buffer, -skip_duplicate);\n            MP_STATS(mpctx, \""duplicate-audio\"");\n        }\n        MP_VERBOSE(mpctx, \""audio skip_duplicate=%d\\n\"", skip_duplicate);\n    }\n\n    if (mpctx->audio_status == STATUS_SYNCING) {\n        if (end_sync)\n            mpctx->audio_status = STATUS_FILLING;\n        if (status != AD_OK && !mp_audio_buffer_samples(ao_c->ao_buffer))\n            mpctx->audio_status = STATUS_EOF;\n        if (working || end_sync)\n            mp_wakeup_core(mpctx);\n        return; // continue on next iteration\n    }\n\n    assert(mpctx->audio_status >= STATUS_FILLING);\n\n    // We already have as much data as the audio device wants, and can start\n    // writing it any time.\n    if (mpctx->audio_status == STATUS_FILLING)\n        mpctx->audio_status = STATUS_READY;\n\n    // Even if we're done decoding and syncing, let video start first - this is\n    // required, because sending audio to the AO already starts playback.\n    if (mpctx->audio_status == STATUS_READY) {\n        // Warning: relies on handle_playback_restart() being called afterwards.\n        return;\n    }\n\n    bool audio_eof = status == AD_EOF;\n    bool partial_fill = false;\n    int playflags = 0;\n\n    if (playsize > mp_audio_buffer_samples(ao_c->ao_buffer)) {\n        playsize = mp_audio_buffer_samples(ao_c->ao_buffer);\n        partial_fill = true;\n    }\n\n    audio_eof &= partial_fill;\n\n    // With gapless audio, delay this to ao_uninit. There must be only\n    // 1 final chunk, and that is handled when calling ao_uninit().\n    if (audio_eof && !opts->gapless_audio)\n        playflags |= AOPLAY_FINAL_CHUNK;\n\n    uint8_t **planes;\n    int samples;\n    mp_audio_buffer_peek(ao_c->ao_buffer, &planes, &samples);\n    if (audio_eof || samples >= align)\n        samples = samples / align * align;\n    samples = MPMIN(samples, mpctx->paused ? 0 : playsize);\n    int played = write_to_ao(mpctx, planes, samples, playflags);\n    assert(played >= 0 && played <= samples);\n    mp_audio_buffer_skip(ao_c->ao_buffer, played);\n\n    mpctx->audio_drop_throttle =\n        MPMAX(0, mpctx->audio_drop_throttle - played / play_samplerate);\n\n    dump_audio_stats(mpctx);\n\n    mpctx->audio_status = STATUS_PLAYING;\n    if (audio_eof && !playsize) {\n        mpctx->audio_status = STATUS_DRAINING;\n        // Wait until the AO has played all queued data. In the gapless case,\n        // we trigger EOF immediately, and let it play asynchronously.\n        if (ao_eof_reached(mpctx->ao) || opts->gapless_audio) {\n            mpctx->audio_status = STATUS_EOF;\n            if (!was_eof) {\n                MP_VERBOSE(mpctx, \""audio EOF reached\\n\"");\n                mp_wakeup_core(mpctx);\n                encode_lavc_stream_eof(mpctx->encode_lavc_ctx, STREAM_AUDIO);\n            }\n        }\n    }\n}""}]","{""value"": 1, ""function"": 1}","[{""source"": ""value_info(file:audio.c, value:ao_c)"", ""result"": {""value_trace"": [{""full_code"": ""*ao_c = mpctx->ao_chain"", ""line"": 53, ""func_name"": ""update_speed_filters""}, {""full_code"": ""*ao_c = mpctx->ao_chain"", ""line"": 70, ""func_name"": ""recreate_audio_filters""}, {""full_code"": ""*ao_c = mpctx->ao_chain"", ""line"": 89, ""func_name"": ""reinit_audio_filters""}, {""full_code"": ""*ao_c = mpctx->ao_chain"", ""line"": 157, ""func_name"": ""audio_update_volume""}, {""full_code"": ""*ao_c = mpctx->ao_chain"", ""line"": 292, ""func_name"": ""reinit_audio_filters_and_output""}], ""struct_var"": ""ao_c"", ""struct_type"": ""ao_chain*"", ""struct_definition"": ""struct ao_chain\n\nstruct ao_chain {\n    struct mp_log *log;\n\n    bool spdif_passthrough, spdif_failed;\n\n    struct mp_output_chain *filter;\n\n    struct ao *ao;\n    struct mp_audio_buffer *ao_buffer;\n    double ao_resume_time;\n\n    // 1-element output frame queue.\n    struct mp_aframe *output_frame;\n    bool out_eof;\n\n    double last_out_pts;\n\n    struct track *track;\n    struct mp_pin *filter_src;\n    struct mp_pin *dec_src;\n}\n\nstruct ao_chain""}}, {""source"": ""func_info(file:audio.c, func:reinit_audio_filters_and_output)"", ""result"": [{""code"": ""static void reinit_audio_filters_and_output(struct MPContext *mpctx)\n{\n    struct MPOpts *opts = mpctx->opts;\n    struct ao_chain *ao_c = mpctx->ao_chain;\n    assert(ao_c);\n    struct track *track = ao_c->track;\n\n    if (!ao_c->filter->ao_needs_update)\n        return;\n\n    TA_FREEP(&ao_c->output_frame); // stale?\n\n    // The \""ideal\"" filter output format\n    struct mp_aframe *out_fmt = mp_aframe_new_ref(ao_c->filter->output_aformat);\n    if (!out_fmt)\n        abort();\n\n    if (!mp_aframe_config_is_valid(out_fmt)) {\n        talloc_free(out_fmt);\n        goto init_error;\n    }\n\n    if (af_fmt_is_pcm(mp_aframe_get_format(out_fmt))) {\n        if (opts->force_srate)\n            mp_aframe_set_rate(out_fmt, opts->force_srate);\n        if (opts->audio_output_format)\n            mp_aframe_set_format(out_fmt, opts->audio_output_format);\n        if (opts->audio_output_channels.num_chmaps == 1)\n            mp_aframe_set_chmap(out_fmt, &opts->audio_output_channels.chmaps[0]);\n    }\n\n    // Weak gapless audio: if the filter output format is the same as the\n    // previous one, keep the AO and don't reinit anything.\n    // Strong gapless: always keep the AO\n    if ((mpctx->ao_filter_fmt && mpctx->ao && opts->gapless_audio < 0 &&\n         keep_weak_gapless_format(mpctx->ao_filter_fmt, out_fmt)) ||\n        (mpctx->ao && opts->gapless_audio > 0))\n    {\n        mp_output_chain_set_ao(ao_c->filter, mpctx->ao);\n        talloc_free(out_fmt);\n        return;\n    }\n\n    uninit_audio_out(mpctx);\n\n    int out_rate = mp_aframe_get_rate(out_fmt);\n    int out_format = mp_aframe_get_format(out_fmt);\n    struct mp_chmap out_channels = {0};\n    mp_aframe_get_chmap(out_fmt, &out_channels);\n\n    int ao_flags = 0;\n    bool spdif_fallback = af_fmt_is_spdif(out_format) &&\n                          ao_c->spdif_passthrough;\n\n    if (opts->ao_null_fallback && !spdif_fallback)\n        ao_flags |= AO_INIT_NULL_FALLBACK;\n\n    if (opts->audio_stream_silence)\n        ao_flags |= AO_INIT_STREAM_SILENCE;\n\n    if (opts->audio_exclusive)\n        ao_flags |= AO_INIT_EXCLUSIVE;\n\n    if (af_fmt_is_pcm(out_format)) {\n        if (!opts->audio_output_channels.set ||\n            opts->audio_output_channels.auto_safe)\n            ao_flags |= AO_INIT_SAFE_MULTICHANNEL_ONLY;\n\n        mp_chmap_sel_list(&out_channels,\n                          opts->audio_output_channels.chmaps,\n                          opts->audio_output_channels.num_chmaps);\n    }\n\n    mpctx->ao_filter_fmt = out_fmt;\n\n    mpctx->ao = ao_init_best(mpctx->global, ao_flags, mp_wakeup_core_cb,\n                             mpctx, mpctx->encode_lavc_ctx, out_rate,\n                             out_format, out_channels);\n    ao_c->ao = mpctx->ao;\n\n    int ao_rate = 0;\n    int ao_format = 0;\n    struct mp_chmap ao_channels = {0};\n    if (mpctx->ao)\n        ao_get_format(mpctx->ao, &ao_rate, &ao_format, &ao_channels);\n\n    // Verify passthrough format was not changed.\n    if (mpctx->ao && af_fmt_is_spdif(out_format)) {\n        if (out_rate != ao_rate || out_format != ao_format ||\n            !mp_chmap_equals(&out_channels, &ao_channels))\n        {\n            MP_ERR(mpctx, \""Passthrough format unsupported.\\n\"");\n            ao_uninit(mpctx->ao);\n            mpctx->ao = NULL;\n            ao_c->ao = NULL;\n        }\n    }\n\n    if (!mpctx->ao) {\n        // If spdif was used, try to fallback to PCM.\n        if (spdif_fallback && ao_c->track && ao_c->track->dec) {\n            MP_VERBOSE(mpctx, \""Falling back to PCM output.\\n\"");\n            ao_c->spdif_passthrough = false;\n            ao_c->spdif_failed = true;\n            ao_c->track->dec->try_spdif = false;\n            if (!mp_decoder_wrapper_reinit(ao_c->track->dec))\n                goto init_error;\n            reset_audio_state(mpctx);\n            mp_output_chain_reset_harder(ao_c->filter);\n            mp_wakeup_core(mpctx); // reinit with new format next time\n            return;\n        }\n\n        MP_ERR(mpctx, \""Could not open/initialize audio device -> no sound.\\n\"");\n        mpctx->error_playing = MPV_ERROR_AO_INIT_FAILED;\n        goto init_error;\n    }\n\n    mp_audio_buffer_reinit_fmt(ao_c->ao_buffer, ao_format, &ao_channels,\n                                ao_rate);\n\n    char tmp[192];\n    MP_INFO(mpctx, \""AO: [%s] %s\\n\"", ao_get_name(mpctx->ao),\n            audio_config_to_str_buf(tmp, sizeof(tmp), ao_rate, ao_format,\n                                    ao_channels));\n    MP_VERBOSE(mpctx, \""AO: Description: %s\\n\"", ao_get_description(mpctx->ao));\n    update_window_title(mpctx, true);\n\n    ao_c->ao_resume_time =\n        opts->audio_wait_open > 0 ? mp_time_sec() + opts->audio_wait_open : 0;\n\n    mp_output_chain_set_ao(ao_c->filter, mpctx->ao);\n\n    audio_update_volume(mpctx);\n\n    mp_notify(mpctx, MPV_EVENT_AUDIO_RECONFIG, NULL);\n\n    return;\n\ninit_error:\n    uninit_audio_chain(mpctx);\n    uninit_audio_out(mpctx);\n    error_on_track(mpctx, track);\n}\n"", ""start_line"": 289, ""end_line"": 432, ""full_name"": ""reinit_audio_filters_and_output"", ""file_path"": ""player/audio.c""}]}]","player/audio.c:814-816: In 'fill_audio_out_buffers()', 'reinit_audio_filters_and_output(mpctx)' may deallocate 'mpctx->ao_chain' (e.g., via 'uninit_audio_chain()' on failure). The cached 'ao_c' (initialized from 'mpctx->ao_chain' in 'player/audio.c:292') is used afterward without validation. The patch adds 'if (!mpctx->ao_chain) return;' to prevent using the stale pointer. 'reinit_audio_filters_and_output()' (player/audio.c:289-432) triggers deallocation via 'uninit_audio_chain()' in failure paths (e.g., 'init_error' label).",0.95,./github/other_context/CVE-2020-19824
56,CVE-2020-25599,"CWE-362, CWE-119",c_cpp,"An issue was discovered in Xen through 4.14.x. There are evtchn_reset() race conditions. Uses of EVTCHNOP_reset (potentially by a guest on itself) or XEN_DOMCTL_soft_reset (by itself covered by XSA-77) can lead to the violation of various internal assumptions. This may lead to out of bounds memory accesses or triggering of bug checks. In particular, x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable.",https://github.com/xen-project/xen/commit/e045199c7c9c5433d7f1461a741ed539a75cbfad,"evtchn: address races with evtchn_reset()\n\nNeither d->evtchn_port_ops nor max_evtchns(d) may be used in an entirely\nlock-less manner, as both may change by a racing evtchn_reset(). In the\ncommon case, at least one of the domain's event lock or the per-channel\nlock needs to be held. In the specific case of the inter-domain sending\nby evtchn_send() and notify_via_xen_event_channel() holding the other\nside's per-channel lock is sufficient, as the channel can't change state\nwithout both per-channel locks held. Without such a channel changing\nstate, evtchn_reset() can't complete successfully.\n\nLock-free accesses continue to be permitted for the shim (calling some\notherwise internal event channel functions), as this happens while the\ndomain is in effectively single-threaded mode. Special care also needs\ntaking for the shim's marking of in-use ports as ECS_RESERVED (allowing\nuse of such ports in the shim case is okay because switching into and\nhence also out of FIFO mode is impossihble there).\n\nAs a side effect, certain operations on Xen bound event channels which\nwere mistakenly permitted so far (e.g. unmask or poll) will be refused\nnow.\n\nThis is part of XSA-343.\n\nReported-by: Julien Grall <jgrall@amazon.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nAcked-by: Julien Grall <jgrall@amazon.com>",33,"[{""func_name"": ""evtchn_fifo_is_masked"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_masked(const struct domain *d, evtchn_port_t port)\n{\n    const event_word_t *word = evtchn_fifo_word_from_port(d, port);\n\n    return !word || guest_test_bit(d, EVTCHN_FIFO_MASKED, word);\n}"", ""target"": 0}, {""func_name"": ""evtchn_fifo_is_busy"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_busy(const struct domain *d, evtchn_port_t port)\n{\n    const event_word_t *word = evtchn_fifo_word_from_port(d, port);\n\n    return word && guest_test_bit(d, EVTCHN_FIFO_LINKED, word);\n}"", ""target"": 0}, {""func_name"": ""evtchn_fifo_is_pending"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool evtchn_fifo_is_pending(const struct domain *d, evtchn_port_t port)\n{\n    const event_word_t *word = evtchn_fifo_word_from_port(d, port);\n\n    return word && guest_test_bit(d, EVTCHN_FIFO_PENDING, word);\n}"", ""target"": 0}, {""func_name"": ""pv_shim_inject_evtchn"", ""file_path"": ""xen/arch/x86/pv/shim.c"", ""func_code"": ""void pv_shim_inject_evtchn(unsigned int port)\n{\n    if ( port_is_valid(guest, port) )\n    {\n        struct evtchn *chn = evtchn_from_port(guest, port);\n\n        evtchn_port_set_pending(guest, chn->notify_vcpu_id, chn);\n    }\n}"", ""target"": 0}, {""func_name"": ""dump_irqs"", ""file_path"": ""xen/arch/x86/irq.c"", ""func_code"": ""static void dump_irqs(unsigned char key)\n{\n    int i, irq, pirq;\n    struct irq_desc *desc;\n    irq_guest_action_t *action;\n    struct domain *d;\n    const struct pirq *info;\n    unsigned long flags;\n    char *ssid;\n\n    printk(\""IRQ information:\\n\"");\n\n    for ( irq = 0; irq < nr_irqs; irq++ )\n    {\n        if ( !(irq & 0x1f) )\n            process_pending_softirqs();\n\n        desc = irq_to_desc(irq);\n\n        if ( !irq_desc_initialized(desc) || desc->handler == &no_irq_type )\n            continue;\n\n        ssid = in_irq() ? NULL : xsm_show_irq_sid(irq);\n\n        spin_lock_irqsave(&desc->lock, flags);\n\n        printk(\""   IRQ:%4d vec:%02x %-15s status=%03x aff:{%*pbl}/{%*pbl} \"",\n               irq, desc->arch.vector, desc->handler->typename, desc->status,\n               CPUMASK_PR(desc->affinity), CPUMASK_PR(desc->arch.cpu_mask));\n\n        if ( ssid )\n            printk(\""Z=%-25s \"", ssid);\n\n        if ( desc->status & IRQ_GUEST )\n        {\n            action = (irq_guest_action_t *)desc->action;\n\n            printk(\""in-flight=%d%c\"",\n                   action->in_flight, action->nr_guests ? ' ' : '\\n');\n\n            for ( i = 0; i < action->nr_guests; )\n            {\n                d = action->guest[i++];\n                pirq = domain_irq_to_pirq(d, irq);\n                info = pirq_info(d, pirq);\n                printk(\""d%d:%3d(%c%c%c)%c\"",\n                       d->domain_id, pirq,\n                       evtchn_port_is_pending(d, info->evtchn) ? 'P' : '-',\n                       evtchn_port_is_masked(d, info->evtchn) ? 'M' : '-',\n                       info->masked ? 'M' : '-',\n                       i < action->nr_guests ? ',' : '\\n');\n            }\n        }\n        else if ( desc->action )\n            printk(\""%ps()\\n\"", desc->action->handler);\n        else\n            printk(\""mapped, unbound\\n\"");\n\n        spin_unlock_irqrestore(&desc->lock, flags);\n\n        xfree(ssid);\n    }\n\n    process_pending_softirqs();\n    printk(\""Direct vector information:\\n\"");\n    for ( i = FIRST_DYNAMIC_VECTOR; i < X86_NR_VECTORS; ++i )\n        if ( direct_apic_vector[i] )\n            printk(\""   %#02x -> %ps()\\n\"", i, direct_apic_vector[i]);\n\n    dump_ioapic_irq_info();\n}"", ""target"": 0}, {""func_name"": ""send_guest_pirq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void send_guest_pirq(struct domain *d, const struct pirq *pirq)\n{\n    int port;\n    struct evtchn *chn;\n\n    /*\n     * PV guests: It should not be possible to race with __evtchn_close(). The\n     *     caller of this function must synchronise with pirq_guest_unbind().\n     * HVM guests: Port is legitimately zero when the guest disables the\n     *     emulated interrupt/evtchn.\n     */\n    if ( pirq == NULL || (port = pirq->evtchn) == 0 )\n    {\n        BUG_ON(!is_hvm_domain(d));\n        return;\n    }\n\n    chn = evtchn_from_port(d, port);\n    evtchn_port_set_pending(d, chn->notify_vcpu_id, chn);\n}"", ""target"": 0}, {""func_name"": ""domain_dump_evtchn_info"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static void domain_dump_evtchn_info(struct domain *d)\n{\n    unsigned int port;\n    int irq;\n\n    printk(\""Event channel information for domain %d:\\n\""\n           \""Polling vCPUs: {%*pbl}\\n\""\n           \""    port [p/m/s]\\n\"", d->domain_id, d->max_vcpus, d->poll_mask);\n\n    spin_lock(&d->event_lock);\n\n    for ( port = 1; port_is_valid(d, port); ++port )\n    {\n        const struct evtchn *chn;\n        char *ssid;\n\n        chn = evtchn_from_port(d, port);\n        if ( chn->state == ECS_FREE )\n            continue;\n\n        printk(\""    %4u [%d/%d/\"",\n               port,\n               evtchn_port_is_pending(d, port),\n               evtchn_port_is_masked(d, port));\n        evtchn_port_print_state(d, chn);\n        printk(\""]: s=%d n=%d x=%d\"",\n               chn->state, chn->notify_vcpu_id, chn->xen_consumer);\n\n        switch ( chn->state )\n        {\n        case ECS_UNBOUND:\n            printk(\"" d=%d\"", chn->u.unbound.remote_domid);\n            break;\n        case ECS_INTERDOMAIN:\n            printk(\"" d=%d p=%d\"",\n                   chn->u.interdomain.remote_dom->domain_id,\n                   chn->u.interdomain.remote_port);\n            break;\n        case ECS_PIRQ:\n            irq = domain_pirq_to_irq(d, chn->u.pirq.irq);\n            printk(\"" p=%d i=%d\"", chn->u.pirq.irq, irq);\n            break;\n        case ECS_VIRQ:\n            printk(\"" v=%d\"", chn->u.virq);\n            break;\n        }\n\n        ssid = xsm_show_security_evtchn(d, chn);\n        if (ssid) {\n            printk(\"" Z=%s\\n\"", ssid);\n            xfree(ssid);\n        } else {\n            printk(\""\\n\"");\n        }\n    }\n\n    spin_unlock(&d->event_lock);\n}"", ""target"": 0}, {""func_name"": ""evtchn_allocate_port"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_allocate_port(struct domain *d, evtchn_port_t port)\n{\n    if ( port > d->max_evtchn_port || port >= max_evtchns(d) )\n        return -ENOSPC;\n\n    if ( port_is_valid(d, port) )\n    {\n        if ( evtchn_from_port(d, port)->state != ECS_FREE ||\n             evtchn_port_is_busy(d, port) )\n            return -EBUSY;\n    }\n    else\n    {\n        struct evtchn *chn;\n        struct evtchn **grp;\n\n        if ( !group_from_port(d, port) )\n        {\n            grp = xzalloc_array(struct evtchn *, BUCKETS_PER_GROUP);\n            if ( !grp )\n                return -ENOMEM;\n            group_from_port(d, port) = grp;\n        }\n\n        chn = alloc_evtchn_bucket(d, port);\n        if ( !chn )\n            return -ENOMEM;\n        bucket_from_port(d, port) = chn;\n\n        /*\n         * d->valid_evtchns is used to check whether the bucket can be\n         * accessed without the per-domain lock. Therefore,\n         * d->valid_evtchns should be seen *after* the new bucket has\n         * been setup.\n         */\n        smp_wmb();\n        write_atomic(&d->valid_evtchns, d->valid_evtchns + EVTCHNS_PER_BUCKET);\n    }\n\n    write_atomic(&d->active_evtchns, d->active_evtchns + 1);\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""send_guest_global_virq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void send_guest_global_virq(struct domain *d, uint32_t virq)\n{\n    unsigned long flags;\n    int port;\n    struct vcpu *v;\n    struct evtchn *chn;\n\n    ASSERT(virq_is_global(virq));\n\n    if ( unlikely(d == NULL) || unlikely(d->vcpu == NULL) )\n        return;\n\n    v = d->vcpu[0];\n    if ( unlikely(v == NULL) )\n        return;\n\n    spin_lock_irqsave(&v->virq_lock, flags);\n\n    port = v->virq_to_evtchn[virq];\n    if ( unlikely(port == 0) )\n        goto out;\n\n    chn = evtchn_from_port(d, port);\n    evtchn_port_set_pending(d, chn->notify_vcpu_id, chn);\n\n out:\n    spin_unlock_irqrestore(&v->virq_lock, flags);\n}"", ""target"": 0}, {""func_name"": ""send_guest_vcpu_virq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void send_guest_vcpu_virq(struct vcpu *v, uint32_t virq)\n{\n    unsigned long flags;\n    int port;\n    struct domain *d;\n\n    ASSERT(!virq_is_global(virq));\n\n    spin_lock_irqsave(&v->virq_lock, flags);\n\n    port = v->virq_to_evtchn[virq];\n    if ( unlikely(port == 0) )\n        goto out;\n\n    d = v->domain;\n    evtchn_port_set_pending(d, v->vcpu_id, evtchn_from_port(d, port));\n\n out:\n    spin_unlock_irqrestore(&v->virq_lock, flags);\n}"", ""target"": 0}, {""func_name"": ""evtchn_unmask"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_unmask(unsigned int port)\n{\n    struct domain *d = current->domain;\n    struct evtchn *evtchn;\n\n    if ( unlikely(!port_is_valid(d, port)) )\n        return -EINVAL;\n\n    evtchn = evtchn_from_port(d, port);\n    evtchn_port_unmask(d, evtchn);\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""evtchn_2l_is_masked"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool evtchn_2l_is_masked(const struct domain *d, evtchn_port_t port)\n{\n    unsigned int max_ports = BITS_PER_EVTCHN_WORD(d) * BITS_PER_EVTCHN_WORD(d);\n\n    ASSERT(port < max_ports);\n    return (port >= max_ports ||\n            guest_test_bit(d, port, &shared_info(d, evtchn_mask)));\n}"", ""target"": 0}, {""func_name"": ""evtchn_2l_is_pending"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool evtchn_2l_is_pending(const struct domain *d, evtchn_port_t port)\n{\n    unsigned int max_ports = BITS_PER_EVTCHN_WORD(d) * BITS_PER_EVTCHN_WORD(d);\n\n    ASSERT(port < max_ports);\n    return (port < max_ports &&\n            guest_test_bit(d, port, &shared_info(d, evtchn_pending)));\n}"", ""target"": 0}, {""func_name"": ""evtchn_bind_pirq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_bind_pirq(evtchn_bind_pirq_t *bind)\n{\n    struct evtchn *chn;\n    struct domain *d = current->domain;\n    struct vcpu   *v = d->vcpu[0];\n    struct pirq   *info;\n    int            port, pirq = bind->pirq;\n    long           rc;\n\n    if ( (pirq < 0) || (pirq >= d->nr_pirqs) )\n        return -EINVAL;\n\n    if ( !is_hvm_domain(d) && !pirq_access_permitted(d, pirq) )\n        return -EPERM;\n\n    spin_lock(&d->event_lock);\n\n    if ( pirq_to_evtchn(d, pirq) != 0 )\n        ERROR_EXIT(-EEXIST);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT(port);\n\n    chn = evtchn_from_port(d, port);\n\n    info = pirq_get_info(d, pirq);\n    if ( !info )\n        ERROR_EXIT(-ENOMEM);\n    info->evtchn = port;\n    rc = (!is_hvm_domain(d)\n          ? pirq_guest_bind(v, info,\n                            !!(bind->flags & BIND_PIRQ__WILL_SHARE))\n          : 0);\n    if ( rc != 0 )\n    {\n        info->evtchn = 0;\n        pirq_cleanup_check(info, d);\n        goto out;\n    }\n\n    spin_lock(&chn->lock);\n\n    chn->state  = ECS_PIRQ;\n    chn->u.pirq.irq = pirq;\n    link_pirq_port(port, chn, v);\n    evtchn_port_init(d, chn);\n\n    spin_unlock(&chn->lock);\n\n    bind->port = port;\n\n    arch_evtchn_bind_pirq(d, pirq);\n\n out:\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""evtchn_reset"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_reset(struct domain *d)\n{\n    unsigned int i;\n\n    if ( d != current->domain && !d->controller_pause_count )\n        return -EINVAL;\n\n    for ( i = 0; port_is_valid(d, i); i++ )\n        evtchn_close(d, i, 1);\n\n    spin_lock(&d->event_lock);\n\n    if ( d->evtchn_fifo )\n    {\n        /* Switching back to 2-level ABI. */\n        evtchn_fifo_destroy(d);\n        evtchn_2l_init(d);\n    }\n\n    spin_unlock(&d->event_lock);\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""evtchn_alloc_unbound"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_alloc_unbound(evtchn_alloc_unbound_t *alloc)\n{\n    struct evtchn *chn;\n    struct domain *d;\n    int            port;\n    domid_t        dom = alloc->dom;\n    long           rc;\n\n    d = rcu_lock_domain_by_any_id(dom);\n    if ( d == NULL )\n        return -ESRCH;\n\n    spin_lock(&d->event_lock);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT_DOM(port, d);\n    chn = evtchn_from_port(d, port);\n\n    rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, alloc->remote_dom);\n    if ( rc )\n        goto out;\n\n    spin_lock(&chn->lock);\n\n    chn->state = ECS_UNBOUND;\n    if ( (chn->u.unbound.remote_domid = alloc->remote_dom) == DOMID_SELF )\n        chn->u.unbound.remote_domid = current->domain->domain_id;\n    evtchn_port_init(d, chn);\n\n    spin_unlock(&chn->lock);\n\n    alloc->port = port;\n\n out:\n    spin_unlock(&d->event_lock);\n    rcu_unlock_domain(d);\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""evtchn_allocate_port"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_allocate_port(struct domain *d, evtchn_port_t port)\n{\n    if ( port > d->max_evtchn_port || port >= max_evtchns(d) )\n        return -ENOSPC;\n\n    if ( port_is_valid(d, port) )\n    {\n        if ( evtchn_from_port(d, port)->state != ECS_FREE ||\n             evtchn_port_is_busy(d, port) )\n            return -EBUSY;\n    }\n    else\n    {\n        struct evtchn *chn;\n        struct evtchn **grp;\n\n        if ( !group_from_port(d, port) )\n        {\n            grp = xzalloc_array(struct evtchn *, BUCKETS_PER_GROUP);\n            if ( !grp )\n                return -ENOMEM;\n            group_from_port(d, port) = grp;\n        }\n\n        chn = alloc_evtchn_bucket(d, port);\n        if ( !chn )\n            return -ENOMEM;\n        bucket_from_port(d, port) = chn;\n\n        /*\n         * d->valid_evtchns is used to check whether the bucket can be\n         * accessed without the per-domain lock. Therefore,\n         * d->valid_evtchns should be seen *after* the new bucket has\n         * been setup.\n         */\n        smp_wmb();\n        write_atomic(&d->valid_evtchns, d->valid_evtchns + EVTCHNS_PER_BUCKET);\n    }\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""evtchn_init"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_init(struct domain *d, unsigned int max_port)\n{\n    evtchn_2l_init(d);\n    d->max_evtchn_port = min_t(unsigned int, max_port, INT_MAX);\n\n    d->evtchn = alloc_evtchn_bucket(d, 0);\n    if ( !d->evtchn )\n        return -ENOMEM;\n    d->valid_evtchns = EVTCHNS_PER_BUCKET;\n\n    spin_lock_init_prof(d, event_lock);\n    if ( get_free_port(d) != 0 )\n    {\n        free_evtchn_bucket(d, d->evtchn);\n        return -EINVAL;\n    }\n    evtchn_from_port(d, 0)->state = ECS_RESERVED;\n\n#if MAX_VIRT_CPUS > BITS_PER_LONG\n    d->poll_mask = xzalloc_array(unsigned long, BITS_TO_LONGS(d->max_vcpus));\n    if ( !d->poll_mask )\n    {\n        free_evtchn_bucket(d, d->evtchn);\n        return -ENOMEM;\n    }\n#endif\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""evtchn_destroy"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void evtchn_destroy(struct domain *d)\n{\n    unsigned int i;\n\n    /* After this barrier no new event-channel allocations can occur. */\n    BUG_ON(!d->is_dying);\n    spin_barrier(&d->event_lock);\n\n    /* Close all existing event channels. */\n    for ( i = 0; port_is_valid(d, i); i++ )\n        evtchn_close(d, i, 0);\n\n    clear_global_virq_handlers(d);\n\n    evtchn_fifo_destroy(d);\n}"", ""target"": 1}, {""func_name"": ""alloc_unbound_xen_event_channel"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int alloc_unbound_xen_event_channel(\n    struct domain *ld, unsigned int lvcpu, domid_t remote_domid,\n    xen_event_channel_notification_t notification_fn)\n{\n    struct evtchn *chn;\n    int            port, rc;\n\n    spin_lock(&ld->event_lock);\n\n    rc = get_free_port(ld);\n    if ( rc < 0 )\n        goto out;\n    port = rc;\n    chn = evtchn_from_port(ld, port);\n\n    rc = xsm_evtchn_unbound(XSM_TARGET, ld, chn, remote_domid);\n    if ( rc )\n        goto out;\n\n    spin_lock(&chn->lock);\n\n    chn->state = ECS_UNBOUND;\n    chn->xen_consumer = get_xen_consumer(notification_fn);\n    chn->notify_vcpu_id = lvcpu;\n    chn->u.unbound.remote_domid = remote_domid;\n\n    spin_unlock(&chn->lock);\n\n out:\n    spin_unlock(&ld->event_lock);\n\n    return rc < 0 ? rc : port;\n}"", ""target"": 0}, {""func_name"": ""evtchn_free"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void evtchn_free(struct domain *d, struct evtchn *chn)\n{\n    /* Clear pending event to avoid unexpected behavior on re-bind. */\n    evtchn_port_clear_pending(d, chn);\n\n    /* Reset binding to vcpu0 when the channel is freed. */\n    chn->state          = ECS_FREE;\n    chn->notify_vcpu_id = 0;\n    chn->xen_consumer   = 0;\n\n    xsm_evtchn_close_post(chn);\n}"", ""target"": 0}, {""func_name"": ""evtchn_bind_interdomain"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_bind_interdomain(evtchn_bind_interdomain_t *bind)\n{\n    struct evtchn *lchn, *rchn;\n    struct domain *ld = current->domain, *rd;\n    int            lport, rport = bind->remote_port;\n    domid_t        rdom = bind->remote_dom;\n    long           rc;\n\n    if ( rdom == DOMID_SELF )\n        rdom = current->domain->domain_id;\n\n    if ( (rd = rcu_lock_domain_by_id(rdom)) == NULL )\n        return -ESRCH;\n\n    /* Avoid deadlock by first acquiring lock of domain with smaller id. */\n    if ( ld < rd )\n    {\n        spin_lock(&ld->event_lock);\n        spin_lock(&rd->event_lock);\n    }\n    else\n    {\n        if ( ld != rd )\n            spin_lock(&rd->event_lock);\n        spin_lock(&ld->event_lock);\n    }\n\n    if ( (lport = get_free_port(ld)) < 0 )\n        ERROR_EXIT(lport);\n    lchn = evtchn_from_port(ld, lport);\n\n    if ( !port_is_valid(rd, rport) )\n        ERROR_EXIT_DOM(-EINVAL, rd);\n    rchn = evtchn_from_port(rd, rport);\n    if ( (rchn->state != ECS_UNBOUND) ||\n         (rchn->u.unbound.remote_domid != ld->domain_id) )\n        ERROR_EXIT_DOM(-EINVAL, rd);\n\n    rc = xsm_evtchn_interdomain(XSM_HOOK, ld, lchn, rd, rchn);\n    if ( rc )\n        goto out;\n\n    double_evtchn_lock(lchn, rchn);\n\n    lchn->u.interdomain.remote_dom  = rd;\n    lchn->u.interdomain.remote_port = rport;\n    lchn->state                     = ECS_INTERDOMAIN;\n    evtchn_port_init(ld, lchn);\n    \n    rchn->u.interdomain.remote_dom  = ld;\n    rchn->u.interdomain.remote_port = lport;\n    rchn->state                     = ECS_INTERDOMAIN;\n\n    /*\n     * We may have lost notifications on the remote unbound port. Fix that up\n     * here by conservatively always setting a notification on the local port.\n     */\n    evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn);\n\n    double_evtchn_unlock(lchn, rchn);\n\n    bind->local_port = lport;\n\n out:\n    spin_unlock(&ld->event_lock);\n    if ( ld != rd )\n        spin_unlock(&rd->event_lock);\n    \n    rcu_unlock_domain(rd);\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""evtchn_bind_virq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_bind_virq(evtchn_bind_virq_t *bind, evtchn_port_t port)\n{\n    struct evtchn *chn;\n    struct vcpu   *v;\n    struct domain *d = current->domain;\n    int            virq = bind->virq, vcpu = bind->vcpu;\n    int            rc = 0;\n\n    if ( (virq < 0) || (virq >= ARRAY_SIZE(v->virq_to_evtchn)) )\n        return -EINVAL;\n\n   /*\n    * Make sure the guest controlled value virq is bounded even during\n    * speculative execution.\n    */\n    virq = array_index_nospec(virq, ARRAY_SIZE(v->virq_to_evtchn));\n\n    if ( virq_is_global(virq) && (vcpu != 0) )\n        return -EINVAL;\n\n    if ( (v = domain_vcpu(d, vcpu)) == NULL )\n        return -ENOENT;\n\n    spin_lock(&d->event_lock);\n\n    if ( v->virq_to_evtchn[virq] != 0 )\n        ERROR_EXIT(-EEXIST);\n\n    if ( port != 0 )\n    {\n        if ( (rc = evtchn_allocate_port(d, port)) != 0 )\n            ERROR_EXIT(rc);\n    }\n    else\n    {\n        int alloc_port = get_free_port(d);\n\n        if ( alloc_port < 0 )\n            ERROR_EXIT(alloc_port);\n        port = alloc_port;\n    }\n\n    chn = evtchn_from_port(d, port);\n\n    spin_lock(&chn->lock);\n\n    chn->state          = ECS_VIRQ;\n    chn->notify_vcpu_id = vcpu;\n    chn->u.virq         = virq;\n    evtchn_port_init(d, chn);\n\n    spin_unlock(&chn->lock);\n\n    v->virq_to_evtchn[virq] = bind->port = port;\n\n out:\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""evtchn_bind_pirq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_bind_pirq(evtchn_bind_pirq_t *bind)\n{\n    struct evtchn *chn;\n    struct domain *d = current->domain;\n    struct vcpu   *v = d->vcpu[0];\n    struct pirq   *info;\n    int            port = 0, pirq = bind->pirq;\n    long           rc;\n\n    if ( (pirq < 0) || (pirq >= d->nr_pirqs) )\n        return -EINVAL;\n\n    if ( !is_hvm_domain(d) && !pirq_access_permitted(d, pirq) )\n        return -EPERM;\n\n    spin_lock(&d->event_lock);\n\n    if ( pirq_to_evtchn(d, pirq) != 0 )\n        ERROR_EXIT(-EEXIST);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT(port);\n\n    chn = evtchn_from_port(d, port);\n\n    info = pirq_get_info(d, pirq);\n    if ( !info )\n        ERROR_EXIT(-ENOMEM);\n    info->evtchn = port;\n    rc = (!is_hvm_domain(d)\n          ? pirq_guest_bind(v, info,\n                            !!(bind->flags & BIND_PIRQ__WILL_SHARE))\n          : 0);\n    if ( rc != 0 )\n    {\n        info->evtchn = 0;\n        pirq_cleanup_check(info, d);\n        goto out;\n    }\n\n    spin_lock(&chn->lock);\n\n    chn->state  = ECS_PIRQ;\n    chn->u.pirq.irq = pirq;\n    link_pirq_port(port, chn, v);\n    evtchn_port_init(d, chn);\n\n    spin_unlock(&chn->lock);\n\n    bind->port = port;\n\n    arch_evtchn_bind_pirq(d, pirq);\n\n out:\n    check_free_port(d, port);\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""evtchn_alloc_unbound"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_alloc_unbound(evtchn_alloc_unbound_t *alloc)\n{\n    struct evtchn *chn;\n    struct domain *d;\n    int            port;\n    domid_t        dom = alloc->dom;\n    long           rc;\n\n    d = rcu_lock_domain_by_any_id(dom);\n    if ( d == NULL )\n        return -ESRCH;\n\n    spin_lock(&d->event_lock);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT_DOM(port, d);\n    chn = evtchn_from_port(d, port);\n\n    rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, alloc->remote_dom);\n    if ( rc )\n        goto out;\n\n    spin_lock(&chn->lock);\n\n    chn->state = ECS_UNBOUND;\n    if ( (chn->u.unbound.remote_domid = alloc->remote_dom) == DOMID_SELF )\n        chn->u.unbound.remote_domid = current->domain->domain_id;\n    evtchn_port_init(d, chn);\n\n    spin_unlock(&chn->lock);\n\n    alloc->port = port;\n\n out:\n    check_free_port(d, port);\n    spin_unlock(&d->event_lock);\n    rcu_unlock_domain(d);\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""double_evtchn_lock"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static void double_evtchn_lock(struct evtchn *lchn, struct evtchn *rchn)\n{\n    if ( lchn < rchn )\n    {\n        spin_lock(&lchn->lock);\n        spin_lock(&rchn->lock);\n    }\n    else\n    {\n        if ( lchn != rchn )\n            spin_lock(&rchn->lock);\n        spin_lock(&lchn->lock);\n    }\n}"", ""target"": 0}, {""func_name"": ""double_evtchn_unlock"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static void double_evtchn_unlock(struct evtchn *lchn, struct evtchn *rchn)\n{\n    spin_unlock(&lchn->lock);\n    if ( lchn != rchn )\n        spin_unlock(&rchn->lock);\n}"", ""target"": 0}, {""func_name"": ""alloc_unbound_xen_event_channel"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int alloc_unbound_xen_event_channel(\n    struct domain *ld, unsigned int lvcpu, domid_t remote_domid,\n    xen_event_channel_notification_t notification_fn)\n{\n    struct evtchn *chn;\n    int            port, rc;\n\n    spin_lock(&ld->event_lock);\n\n    port = rc = get_free_port(ld);\n    if ( rc < 0 )\n        goto out;\n    chn = evtchn_from_port(ld, port);\n\n    rc = xsm_evtchn_unbound(XSM_TARGET, ld, chn, remote_domid);\n    if ( rc )\n        goto out;\n\n    spin_lock(&chn->lock);\n\n    chn->state = ECS_UNBOUND;\n    chn->xen_consumer = get_xen_consumer(notification_fn);\n    chn->notify_vcpu_id = lvcpu;\n    chn->u.unbound.remote_domid = remote_domid;\n\n    spin_unlock(&chn->lock);\n\n    write_atomic(&ld->xen_evtchns, ld->xen_evtchns + 1);\n\n out:\n    check_free_port(ld, port);\n    spin_unlock(&ld->event_lock);\n\n    return rc < 0 ? rc : port;\n}"", ""target"": 0}, {""func_name"": ""evtchn_bind_ipi"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_bind_ipi(evtchn_bind_ipi_t *bind)\n{\n    struct evtchn *chn;\n    struct domain *d = current->domain;\n    int            port, vcpu = bind->vcpu;\n    long           rc = 0;\n\n    if ( domain_vcpu(d, vcpu) == NULL )\n        return -ENOENT;\n\n    spin_lock(&d->event_lock);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT(port);\n\n    chn = evtchn_from_port(d, port);\n\n    spin_lock(&chn->lock);\n\n    chn->state          = ECS_IPI;\n    chn->notify_vcpu_id = vcpu;\n    evtchn_port_init(d, chn);\n\n    spin_unlock(&chn->lock);\n\n    bind->port = port;\n\n out:\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""evtchn_send"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_send(struct domain *ld, unsigned int lport)\n{\n    struct evtchn *lchn, *rchn;\n    struct domain *rd;\n    int            rport, ret = 0;\n\n    if ( !port_is_valid(ld, lport) )\n        return -EINVAL;\n\n    lchn = evtchn_from_port(ld, lport);\n\n    spin_lock(&lchn->lock);\n\n    /* Guest cannot send via a Xen-attached event channel. */\n    if ( unlikely(consumer_is_xen(lchn)) )\n    {\n        ret = -EINVAL;\n        goto out;\n    }\n\n    ret = xsm_evtchn_send(XSM_HOOK, ld, lchn);\n    if ( ret )\n        goto out;\n\n    switch ( lchn->state )\n    {\n    case ECS_INTERDOMAIN:\n        rd    = lchn->u.interdomain.remote_dom;\n        rport = lchn->u.interdomain.remote_port;\n        rchn  = evtchn_from_port(rd, rport);\n        if ( consumer_is_xen(rchn) )\n            xen_notification_fn(rchn)(rd->vcpu[rchn->notify_vcpu_id], rport);\n        else\n            evtchn_port_set_pending(rd, rchn->notify_vcpu_id, rchn);\n        break;\n    case ECS_IPI:\n        evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn);\n        break;\n    case ECS_UNBOUND:\n        /* silently drop the notification */\n        break;\n    default:\n        ret = -EINVAL;\n    }\n\nout:\n    spin_unlock(&lchn->lock);\n\n    return ret;\n}"", ""target"": 0}, {""func_name"": ""evtchn_close"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_close(struct domain *d1, int port1, bool guest)\n{\n    struct domain *d2 = NULL;\n    struct vcpu   *v;\n    struct evtchn *chn1, *chn2;\n    int            port2;\n    long           rc = 0;\n\n again:\n    spin_lock(&d1->event_lock);\n\n    if ( !port_is_valid(d1, port1) )\n    {\n        rc = -EINVAL;\n        goto out;\n    }\n\n    chn1 = evtchn_from_port(d1, port1);\n\n    /* Guest cannot close a Xen-attached event channel. */\n    if ( unlikely(consumer_is_xen(chn1)) && guest )\n    {\n        rc = -EINVAL;\n        goto out;\n    }\n\n    switch ( chn1->state )\n    {\n    case ECS_FREE:\n    case ECS_RESERVED:\n        rc = -EINVAL;\n        goto out;\n\n    case ECS_UNBOUND:\n        break;\n\n    case ECS_PIRQ: {\n        struct pirq *pirq = pirq_info(d1, chn1->u.pirq.irq);\n\n        if ( !pirq )\n            break;\n        if ( !is_hvm_domain(d1) )\n            pirq_guest_unbind(d1, pirq);\n        pirq->evtchn = 0;\n        pirq_cleanup_check(pirq, d1);\n        unlink_pirq_port(chn1, d1->vcpu[chn1->notify_vcpu_id]);\n#ifdef CONFIG_X86\n        if ( is_hvm_domain(d1) && domain_pirq_to_irq(d1, pirq->pirq) > 0 )\n            unmap_domain_pirq_emuirq(d1, pirq->pirq);\n#endif\n        break;\n    }\n\n    case ECS_VIRQ:\n        for_each_vcpu ( d1, v )\n        {\n            if ( v->virq_to_evtchn[chn1->u.virq] != port1 )\n                continue;\n            v->virq_to_evtchn[chn1->u.virq] = 0;\n            spin_barrier(&v->virq_lock);\n        }\n        break;\n\n    case ECS_IPI:\n        break;\n\n    case ECS_INTERDOMAIN:\n        if ( d2 == NULL )\n        {\n            d2 = chn1->u.interdomain.remote_dom;\n\n            /* If we unlock d1 then we could lose d2. Must get a reference. */\n            if ( unlikely(!get_domain(d2)) )\n                BUG();\n\n            if ( d1 < d2 )\n            {\n                spin_lock(&d2->event_lock);\n            }\n            else if ( d1 != d2 )\n            {\n                spin_unlock(&d1->event_lock);\n                spin_lock(&d2->event_lock);\n                goto again;\n            }\n        }\n        else if ( d2 != chn1->u.interdomain.remote_dom )\n        {\n            /*\n             * We can only get here if the port was closed and re-bound after\n             * unlocking d1 but before locking d2 above. We could retry but\n             * it is easier to return the same error as if we had seen the\n             * port in ECS_CLOSED. It must have passed through that state for\n             * us to end up here, so it's a valid error to return.\n             */\n            rc = -EINVAL;\n            goto out;\n        }\n\n        port2 = chn1->u.interdomain.remote_port;\n        BUG_ON(!port_is_valid(d2, port2));\n\n        chn2 = evtchn_from_port(d2, port2);\n        BUG_ON(chn2->state != ECS_INTERDOMAIN);\n        BUG_ON(chn2->u.interdomain.remote_dom != d1);\n\n        double_evtchn_lock(chn1, chn2);\n\n        evtchn_free(d1, chn1);\n\n        chn2->state = ECS_UNBOUND;\n        chn2->u.unbound.remote_domid = d1->domain_id;\n\n        double_evtchn_unlock(chn1, chn2);\n\n        goto out;\n\n    default:\n        BUG();\n    }\n\n    spin_lock(&chn1->lock);\n    evtchn_free(d1, chn1);\n    spin_unlock(&chn1->lock);\n\n out:\n    if ( d2 != NULL )\n    {\n        if ( d1 != d2 )\n            spin_unlock(&d2->event_lock);\n        put_domain(d2);\n    }\n\n    spin_unlock(&d1->event_lock);\n\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""notify_via_xen_event_channel"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void notify_via_xen_event_channel(struct domain *ld, int lport)\n{\n    struct evtchn *lchn, *rchn;\n    struct domain *rd;\n\n    ASSERT(port_is_valid(ld, lport));\n    lchn = evtchn_from_port(ld, lport);\n\n    spin_lock(&lchn->lock);\n\n    if ( likely(lchn->state == ECS_INTERDOMAIN) )\n    {\n        ASSERT(consumer_is_xen(lchn));\n        rd    = lchn->u.interdomain.remote_dom;\n        rchn  = evtchn_from_port(rd, lchn->u.interdomain.remote_port);\n        evtchn_port_set_pending(rd, rchn->notify_vcpu_id, rchn);\n    }\n\n    spin_unlock(&lchn->lock);\n}"", ""target"": 0}, {""func_name"": ""evtchn_bind_interdomain"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_bind_interdomain(evtchn_bind_interdomain_t *bind)\n{\n    struct evtchn *lchn, *rchn;\n    struct domain *ld = current->domain, *rd;\n    int            lport, rport = bind->remote_port;\n    domid_t        rdom = bind->remote_dom;\n    long           rc;\n\n    if ( rdom == DOMID_SELF )\n        rdom = current->domain->domain_id;\n\n    if ( (rd = rcu_lock_domain_by_id(rdom)) == NULL )\n        return -ESRCH;\n\n    /* Avoid deadlock by first acquiring lock of domain with smaller id. */\n    if ( ld < rd )\n    {\n        spin_lock(&ld->event_lock);\n        spin_lock(&rd->event_lock);\n    }\n    else\n    {\n        if ( ld != rd )\n            spin_lock(&rd->event_lock);\n        spin_lock(&ld->event_lock);\n    }\n\n    if ( (lport = get_free_port(ld)) < 0 )\n        ERROR_EXIT(lport);\n    lchn = evtchn_from_port(ld, lport);\n\n    if ( !port_is_valid(rd, rport) )\n        ERROR_EXIT_DOM(-EINVAL, rd);\n    rchn = evtchn_from_port(rd, rport);\n    if ( (rchn->state != ECS_UNBOUND) ||\n         (rchn->u.unbound.remote_domid != ld->domain_id) )\n        ERROR_EXIT_DOM(-EINVAL, rd);\n\n    rc = xsm_evtchn_interdomain(XSM_HOOK, ld, lchn, rd, rchn);\n    if ( rc )\n        goto out;\n\n    double_evtchn_lock(lchn, rchn);\n\n    lchn->u.interdomain.remote_dom  = rd;\n    lchn->u.interdomain.remote_port = rport;\n    lchn->state                     = ECS_INTERDOMAIN;\n    evtchn_port_init(ld, lchn);\n    \n    rchn->u.interdomain.remote_dom  = ld;\n    rchn->u.interdomain.remote_port = lport;\n    rchn->state                     = ECS_INTERDOMAIN;\n\n    /*\n     * We may have lost notifications on the remote unbound port. Fix that up\n     * here by conservatively always setting a notification on the local port.\n     */\n    evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn);\n\n    double_evtchn_unlock(lchn, rchn);\n\n    bind->local_port = lport;\n\n out:\n    check_free_port(ld, lport);\n    spin_unlock(&ld->event_lock);\n    if ( ld != rd )\n        spin_unlock(&rd->event_lock);\n    \n    rcu_unlock_domain(rd);\n\n    return rc;\n}"", ""target"": 0}]","[{""func_name"": ""evtchn_fifo_is_masked"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_masked(const struct domain *d,\n                                    const struct evtchn *evtchn)\n{\n    const event_word_t *word = evtchn_fifo_word_from_port(d, evtchn->port);\n\n    return !word || guest_test_bit(d, EVTCHN_FIFO_MASKED, word);\n}""}, {""func_name"": ""evtchn_fifo_is_busy"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_busy(const struct domain *d,\n                                  const struct evtchn *evtchn)\n{\n    const event_word_t *word = evtchn_fifo_word_from_port(d, evtchn->port);\n\n    return word && guest_test_bit(d, EVTCHN_FIFO_LINKED, word);\n}""}, {""func_name"": ""evtchn_fifo_is_pending"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool evtchn_fifo_is_pending(const struct domain *d,\n                                   const struct evtchn *evtchn)\n{\n    const event_word_t *word = evtchn_fifo_word_from_port(d, evtchn->port);\n\n    return word && guest_test_bit(d, EVTCHN_FIFO_PENDING, word);\n}""}, {""func_name"": ""pv_shim_inject_evtchn"", ""file_path"": ""xen/arch/x86/pv/shim.c"", ""func_code"": ""void pv_shim_inject_evtchn(unsigned int port)\n{\n    if ( port_is_valid(guest, port) )\n    {\n        struct evtchn *chn = evtchn_from_port(guest, port);\n        unsigned long flags;\n\n        spin_lock_irqsave(&chn->lock, flags);\n        evtchn_port_set_pending(guest, chn->notify_vcpu_id, chn);\n        spin_unlock_irqrestore(&chn->lock, flags);\n    }\n}""}, {""func_name"": ""dump_irqs"", ""file_path"": ""xen/arch/x86/irq.c"", ""func_code"": ""static void dump_irqs(unsigned char key)\n{\n    int i, irq, pirq;\n    struct irq_desc *desc;\n    irq_guest_action_t *action;\n    struct domain *d;\n    const struct pirq *info;\n    unsigned long flags;\n    char *ssid;\n\n    printk(\""IRQ information:\\n\"");\n\n    for ( irq = 0; irq < nr_irqs; irq++ )\n    {\n        if ( !(irq & 0x1f) )\n            process_pending_softirqs();\n\n        desc = irq_to_desc(irq);\n\n        if ( !irq_desc_initialized(desc) || desc->handler == &no_irq_type )\n            continue;\n\n        ssid = in_irq() ? NULL : xsm_show_irq_sid(irq);\n\n        spin_lock_irqsave(&desc->lock, flags);\n\n        printk(\""   IRQ:%4d vec:%02x %-15s status=%03x aff:{%*pbl}/{%*pbl} \"",\n               irq, desc->arch.vector, desc->handler->typename, desc->status,\n               CPUMASK_PR(desc->affinity), CPUMASK_PR(desc->arch.cpu_mask));\n\n        if ( ssid )\n            printk(\""Z=%-25s \"", ssid);\n\n        if ( desc->status & IRQ_GUEST )\n        {\n            action = (irq_guest_action_t *)desc->action;\n\n            printk(\""in-flight=%d%c\"",\n                   action->in_flight, action->nr_guests ? ' ' : '\\n');\n\n            for ( i = 0; i < action->nr_guests; )\n            {\n                struct evtchn *evtchn;\n                unsigned int pending = 2, masked = 2;\n\n                d = action->guest[i++];\n                pirq = domain_irq_to_pirq(d, irq);\n                info = pirq_info(d, pirq);\n                evtchn = evtchn_from_port(d, info->evtchn);\n                local_irq_disable();\n                if ( spin_trylock(&evtchn->lock) )\n                {\n                    pending = evtchn_is_pending(d, evtchn);\n                    masked = evtchn_is_masked(d, evtchn);\n                    spin_unlock(&evtchn->lock);\n                }\n                local_irq_enable();\n                printk(\""d%d:%3d(%c%c%c)%c\"",\n                       d->domain_id, pirq, \""-P?\""[pending],\n                       \""-M?\""[masked], info->masked ? 'M' : '-',\n                       i < action->nr_guests ? ',' : '\\n');\n            }\n        }\n        else if ( desc->action )\n            printk(\""%ps()\\n\"", desc->action->handler);\n        else\n            printk(\""mapped, unbound\\n\"");\n\n        spin_unlock_irqrestore(&desc->lock, flags);\n\n        xfree(ssid);\n    }\n\n    process_pending_softirqs();\n    printk(\""Direct vector information:\\n\"");\n    for ( i = FIRST_DYNAMIC_VECTOR; i < X86_NR_VECTORS; ++i )\n        if ( direct_apic_vector[i] )\n            printk(\""   %#02x -> %ps()\\n\"", i, direct_apic_vector[i]);\n\n    dump_ioapic_irq_info();\n}""}, {""func_name"": ""send_guest_pirq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void send_guest_pirq(struct domain *d, const struct pirq *pirq)\n{\n    int port;\n    struct evtchn *chn;\n    unsigned long flags;\n\n    /*\n     * PV guests: It should not be possible to race with __evtchn_close(). The\n     *     caller of this function must synchronise with pirq_guest_unbind().\n     * HVM guests: Port is legitimately zero when the guest disables the\n     *     emulated interrupt/evtchn.\n     */\n    if ( pirq == NULL || (port = pirq->evtchn) == 0 )\n    {\n        BUG_ON(!is_hvm_domain(d));\n        return;\n    }\n\n    chn = evtchn_from_port(d, port);\n    spin_lock_irqsave(&chn->lock, flags);\n    evtchn_port_set_pending(d, chn->notify_vcpu_id, chn);\n    spin_unlock_irqrestore(&chn->lock, flags);\n}""}, {""func_name"": ""domain_dump_evtchn_info"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static void domain_dump_evtchn_info(struct domain *d)\n{\n    unsigned int port;\n    int irq;\n\n    printk(\""Event channel information for domain %d:\\n\""\n           \""Polling vCPUs: {%*pbl}\\n\""\n           \""    port [p/m/s]\\n\"", d->domain_id, d->max_vcpus, d->poll_mask);\n\n    spin_lock(&d->event_lock);\n\n    for ( port = 1; port_is_valid(d, port); ++port )\n    {\n        const struct evtchn *chn;\n        char *ssid;\n\n        chn = evtchn_from_port(d, port);\n        if ( chn->state == ECS_FREE )\n            continue;\n\n        printk(\""    %4u [%d/%d/\"",\n               port,\n               evtchn_is_pending(d, chn),\n               evtchn_is_masked(d, chn));\n        evtchn_port_print_state(d, chn);\n        printk(\""]: s=%d n=%d x=%d\"",\n               chn->state, chn->notify_vcpu_id, chn->xen_consumer);\n\n        switch ( chn->state )\n        {\n        case ECS_UNBOUND:\n            printk(\"" d=%d\"", chn->u.unbound.remote_domid);\n            break;\n        case ECS_INTERDOMAIN:\n            printk(\"" d=%d p=%d\"",\n                   chn->u.interdomain.remote_dom->domain_id,\n                   chn->u.interdomain.remote_port);\n            break;\n        case ECS_PIRQ:\n            irq = domain_pirq_to_irq(d, chn->u.pirq.irq);\n            printk(\"" p=%d i=%d\"", chn->u.pirq.irq, irq);\n            break;\n        case ECS_VIRQ:\n            printk(\"" v=%d\"", chn->u.virq);\n            break;\n        }\n\n        ssid = xsm_show_security_evtchn(d, chn);\n        if (ssid) {\n            printk(\"" Z=%s\\n\"", ssid);\n            xfree(ssid);\n        } else {\n            printk(\""\\n\"");\n        }\n    }\n\n    spin_unlock(&d->event_lock);\n}""}, {""func_name"": ""evtchn_allocate_port"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_allocate_port(struct domain *d, evtchn_port_t port)\n{\n    if ( port > d->max_evtchn_port || port >= max_evtchns(d) )\n        return -ENOSPC;\n\n    if ( port_is_valid(d, port) )\n    {\n        const struct evtchn *chn = evtchn_from_port(d, port);\n\n        if ( chn->state != ECS_FREE || evtchn_is_busy(d, chn) )\n            return -EBUSY;\n    }\n    else\n    {\n        struct evtchn *chn;\n        struct evtchn **grp;\n\n        if ( !group_from_port(d, port) )\n        {\n            grp = xzalloc_array(struct evtchn *, BUCKETS_PER_GROUP);\n            if ( !grp )\n                return -ENOMEM;\n            group_from_port(d, port) = grp;\n        }\n\n        chn = alloc_evtchn_bucket(d, port);\n        if ( !chn )\n            return -ENOMEM;\n        bucket_from_port(d, port) = chn;\n\n        /*\n         * d->valid_evtchns is used to check whether the bucket can be\n         * accessed without the per-domain lock. Therefore,\n         * d->valid_evtchns should be seen *after* the new bucket has\n         * been setup.\n         */\n        smp_wmb();\n        write_atomic(&d->valid_evtchns, d->valid_evtchns + EVTCHNS_PER_BUCKET);\n    }\n\n    write_atomic(&d->active_evtchns, d->active_evtchns + 1);\n\n    return 0;\n}""}, {""func_name"": ""send_guest_global_virq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void send_guest_global_virq(struct domain *d, uint32_t virq)\n{\n    unsigned long flags;\n    int port;\n    struct vcpu *v;\n    struct evtchn *chn;\n\n    ASSERT(virq_is_global(virq));\n\n    if ( unlikely(d == NULL) || unlikely(d->vcpu == NULL) )\n        return;\n\n    v = d->vcpu[0];\n    if ( unlikely(v == NULL) )\n        return;\n\n    spin_lock_irqsave(&v->virq_lock, flags);\n\n    port = v->virq_to_evtchn[virq];\n    if ( unlikely(port == 0) )\n        goto out;\n\n    chn = evtchn_from_port(d, port);\n    spin_lock(&chn->lock);\n    evtchn_port_set_pending(d, chn->notify_vcpu_id, chn);\n    spin_unlock(&chn->lock);\n\n out:\n    spin_unlock_irqrestore(&v->virq_lock, flags);\n}""}, {""func_name"": ""send_guest_vcpu_virq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void send_guest_vcpu_virq(struct vcpu *v, uint32_t virq)\n{\n    unsigned long flags;\n    int port;\n    struct domain *d;\n    struct evtchn *chn;\n\n    ASSERT(!virq_is_global(virq));\n\n    spin_lock_irqsave(&v->virq_lock, flags);\n\n    port = v->virq_to_evtchn[virq];\n    if ( unlikely(port == 0) )\n        goto out;\n\n    d = v->domain;\n    chn = evtchn_from_port(d, port);\n    spin_lock(&chn->lock);\n    evtchn_port_set_pending(d, v->vcpu_id, chn);\n    spin_unlock(&chn->lock);\n\n out:\n    spin_unlock_irqrestore(&v->virq_lock, flags);\n}""}, {""func_name"": ""evtchn_unmask"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_unmask(unsigned int port)\n{\n    struct domain *d = current->domain;\n    struct evtchn *evtchn;\n    unsigned long flags;\n\n    if ( unlikely(!port_is_valid(d, port)) )\n        return -EINVAL;\n\n    evtchn = evtchn_from_port(d, port);\n    spin_lock_irqsave(&evtchn->lock, flags);\n    evtchn_port_unmask(d, evtchn);\n    spin_unlock_irqrestore(&evtchn->lock, flags);\n\n    return 0;\n}""}, {""func_name"": ""evtchn_2l_is_masked"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool evtchn_2l_is_masked(const struct domain *d,\n                                const struct evtchn *evtchn)\n{\n    evtchn_port_t port = evtchn->port;\n    unsigned int max_ports = BITS_PER_EVTCHN_WORD(d) * BITS_PER_EVTCHN_WORD(d);\n\n    ASSERT(port < max_ports);\n    return (port >= max_ports ||\n            guest_test_bit(d, port, &shared_info(d, evtchn_mask)));\n}""}, {""func_name"": ""evtchn_2l_is_pending"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool evtchn_2l_is_pending(const struct domain *d,\n                                 const struct evtchn *evtchn)\n{\n    evtchn_port_t port = evtchn->port;\n    unsigned int max_ports = BITS_PER_EVTCHN_WORD(d) * BITS_PER_EVTCHN_WORD(d);\n\n    ASSERT(port < max_ports);\n    return (port < max_ports &&\n            guest_test_bit(d, port, &shared_info(d, evtchn_pending)));\n}""}, {""func_name"": ""evtchn_bind_pirq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_bind_pirq(evtchn_bind_pirq_t *bind)\n{\n    struct evtchn *chn;\n    struct domain *d = current->domain;\n    struct vcpu   *v = d->vcpu[0];\n    struct pirq   *info;\n    int            port = 0, pirq = bind->pirq;\n    long           rc;\n\n    if ( (pirq < 0) || (pirq >= d->nr_pirqs) )\n        return -EINVAL;\n\n    if ( !is_hvm_domain(d) && !pirq_access_permitted(d, pirq) )\n        return -EPERM;\n\n    spin_lock(&d->event_lock);\n\n    if ( pirq_to_evtchn(d, pirq) != 0 )\n        ERROR_EXIT(-EEXIST);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT(port);\n\n    chn = evtchn_from_port(d, port);\n\n    info = pirq_get_info(d, pirq);\n    if ( !info )\n        ERROR_EXIT(-ENOMEM);\n    info->evtchn = port;\n    rc = (!is_hvm_domain(d)\n          ? pirq_guest_bind(v, info,\n                            !!(bind->flags & BIND_PIRQ__WILL_SHARE))\n          : 0);\n    if ( rc != 0 )\n    {\n        info->evtchn = 0;\n        pirq_cleanup_check(info, d);\n        goto out;\n    }\n\n    spin_lock(&chn->lock);\n\n    chn->state  = ECS_PIRQ;\n    chn->u.pirq.irq = pirq;\n    link_pirq_port(port, chn, v);\n    evtchn_port_init(d, chn);\n\n    spin_unlock(&chn->lock);\n\n    bind->port = port;\n\n    arch_evtchn_bind_pirq(d, pirq);\n\n out:\n    check_free_port(d, port);\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}""}, {""func_name"": ""evtchn_reset"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_reset(struct domain *d)\n{\n    unsigned int i;\n    int rc = 0;\n\n    if ( d != current->domain && !d->controller_pause_count )\n        return -EINVAL;\n\n    for ( i = 0; port_is_valid(d, i); i++ )\n        evtchn_close(d, i, 1);\n\n    spin_lock(&d->event_lock);\n\n    if ( d->active_evtchns > d->xen_evtchns )\n        rc = -EAGAIN;\n    else if ( d->evtchn_fifo )\n    {\n        /* Switching back to 2-level ABI. */\n        evtchn_fifo_destroy(d);\n        evtchn_2l_init(d);\n    }\n\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}""}, {""func_name"": ""evtchn_alloc_unbound"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_alloc_unbound(evtchn_alloc_unbound_t *alloc)\n{\n    struct evtchn *chn;\n    struct domain *d;\n    int            port;\n    domid_t        dom = alloc->dom;\n    long           rc;\n\n    d = rcu_lock_domain_by_any_id(dom);\n    if ( d == NULL )\n        return -ESRCH;\n\n    spin_lock(&d->event_lock);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT_DOM(port, d);\n    chn = evtchn_from_port(d, port);\n\n    rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, alloc->remote_dom);\n    if ( rc )\n        goto out;\n\n    spin_lock(&chn->lock);\n\n    chn->state = ECS_UNBOUND;\n    if ( (chn->u.unbound.remote_domid = alloc->remote_dom) == DOMID_SELF )\n        chn->u.unbound.remote_domid = current->domain->domain_id;\n    evtchn_port_init(d, chn);\n\n    spin_unlock(&chn->lock);\n\n    alloc->port = port;\n\n out:\n    check_free_port(d, port);\n    spin_unlock(&d->event_lock);\n    rcu_unlock_domain(d);\n\n    return rc;\n}""}, {""func_name"": ""evtchn_allocate_port"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_allocate_port(struct domain *d, evtchn_port_t port)\n{\n    if ( port > d->max_evtchn_port || port >= max_evtchns(d) )\n        return -ENOSPC;\n\n    if ( port_is_valid(d, port) )\n    {\n        if ( evtchn_from_port(d, port)->state != ECS_FREE ||\n             evtchn_port_is_busy(d, port) )\n            return -EBUSY;\n    }\n    else\n    {\n        struct evtchn *chn;\n        struct evtchn **grp;\n\n        if ( !group_from_port(d, port) )\n        {\n            grp = xzalloc_array(struct evtchn *, BUCKETS_PER_GROUP);\n            if ( !grp )\n                return -ENOMEM;\n            group_from_port(d, port) = grp;\n        }\n\n        chn = alloc_evtchn_bucket(d, port);\n        if ( !chn )\n            return -ENOMEM;\n        bucket_from_port(d, port) = chn;\n\n        /*\n         * d->valid_evtchns is used to check whether the bucket can be\n         * accessed without the per-domain lock. Therefore,\n         * d->valid_evtchns should be seen *after* the new bucket has\n         * been setup.\n         */\n        smp_wmb();\n        write_atomic(&d->valid_evtchns, d->valid_evtchns + EVTCHNS_PER_BUCKET);\n    }\n\n    write_atomic(&d->active_evtchns, d->active_evtchns + 1);\n\n    return 0;\n}""}, {""func_name"": ""evtchn_init"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_init(struct domain *d, unsigned int max_port)\n{\n    evtchn_2l_init(d);\n    d->max_evtchn_port = min_t(unsigned int, max_port, INT_MAX);\n\n    d->evtchn = alloc_evtchn_bucket(d, 0);\n    if ( !d->evtchn )\n        return -ENOMEM;\n    d->valid_evtchns = EVTCHNS_PER_BUCKET;\n\n    spin_lock_init_prof(d, event_lock);\n    if ( get_free_port(d) != 0 )\n    {\n        free_evtchn_bucket(d, d->evtchn);\n        return -EINVAL;\n    }\n    evtchn_from_port(d, 0)->state = ECS_RESERVED;\n    write_atomic(&d->active_evtchns, 0);\n\n#if MAX_VIRT_CPUS > BITS_PER_LONG\n    d->poll_mask = xzalloc_array(unsigned long, BITS_TO_LONGS(d->max_vcpus));\n    if ( !d->poll_mask )\n    {\n        free_evtchn_bucket(d, d->evtchn);\n        return -ENOMEM;\n    }\n#endif\n\n    return 0;\n}""}, {""func_name"": ""evtchn_destroy"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void evtchn_destroy(struct domain *d)\n{\n    unsigned int i;\n\n    /* After this barrier no new event-channel allocations can occur. */\n    BUG_ON(!d->is_dying);\n    spin_barrier(&d->event_lock);\n\n    /* Close all existing event channels. */\n    for ( i = 0; port_is_valid(d, i); i++ )\n        evtchn_close(d, i, 0);\n\n    ASSERT(!d->active_evtchns);\n\n    clear_global_virq_handlers(d);\n\n    evtchn_fifo_destroy(d);\n}""}, {""func_name"": ""alloc_unbound_xen_event_channel"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int alloc_unbound_xen_event_channel(\n    struct domain *ld, unsigned int lvcpu, domid_t remote_domid,\n    xen_event_channel_notification_t notification_fn)\n{\n    struct evtchn *chn;\n    int            port, rc;\n\n    spin_lock(&ld->event_lock);\n\n    port = rc = get_free_port(ld);\n    if ( rc < 0 )\n        goto out;\n    chn = evtchn_from_port(ld, port);\n\n    rc = xsm_evtchn_unbound(XSM_TARGET, ld, chn, remote_domid);\n    if ( rc )\n        goto out;\n\n    spin_lock(&chn->lock);\n\n    chn->state = ECS_UNBOUND;\n    chn->xen_consumer = get_xen_consumer(notification_fn);\n    chn->notify_vcpu_id = lvcpu;\n    chn->u.unbound.remote_domid = remote_domid;\n\n    spin_unlock(&chn->lock);\n\n    write_atomic(&ld->xen_evtchns, ld->xen_evtchns + 1);\n\n out:\n    check_free_port(ld, port);\n    spin_unlock(&ld->event_lock);\n\n    return rc < 0 ? rc : port;\n}""}, {""func_name"": ""evtchn_free"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void evtchn_free(struct domain *d, struct evtchn *chn)\n{\n    /* Clear pending event to avoid unexpected behavior on re-bind. */\n    evtchn_port_clear_pending(d, chn);\n\n    if ( consumer_is_xen(chn) )\n        write_atomic(&d->xen_evtchns, d->xen_evtchns - 1);\n    write_atomic(&d->active_evtchns, d->active_evtchns - 1);\n\n    /* Reset binding to vcpu0 when the channel is freed. */\n    chn->state          = ECS_FREE;\n    chn->notify_vcpu_id = 0;\n    chn->xen_consumer   = 0;\n\n    xsm_evtchn_close_post(chn);\n}""}, {""func_name"": ""evtchn_bind_interdomain"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_bind_interdomain(evtchn_bind_interdomain_t *bind)\n{\n    struct evtchn *lchn, *rchn;\n    struct domain *ld = current->domain, *rd;\n    int            lport, rport = bind->remote_port;\n    domid_t        rdom = bind->remote_dom;\n    long           rc;\n\n    if ( rdom == DOMID_SELF )\n        rdom = current->domain->domain_id;\n\n    if ( (rd = rcu_lock_domain_by_id(rdom)) == NULL )\n        return -ESRCH;\n\n    /* Avoid deadlock by first acquiring lock of domain with smaller id. */\n    if ( ld < rd )\n    {\n        spin_lock(&ld->event_lock);\n        spin_lock(&rd->event_lock);\n    }\n    else\n    {\n        if ( ld != rd )\n            spin_lock(&rd->event_lock);\n        spin_lock(&ld->event_lock);\n    }\n\n    if ( (lport = get_free_port(ld)) < 0 )\n        ERROR_EXIT(lport);\n    lchn = evtchn_from_port(ld, lport);\n\n    if ( !port_is_valid(rd, rport) )\n        ERROR_EXIT_DOM(-EINVAL, rd);\n    rchn = evtchn_from_port(rd, rport);\n    if ( (rchn->state != ECS_UNBOUND) ||\n         (rchn->u.unbound.remote_domid != ld->domain_id) )\n        ERROR_EXIT_DOM(-EINVAL, rd);\n\n    rc = xsm_evtchn_interdomain(XSM_HOOK, ld, lchn, rd, rchn);\n    if ( rc )\n        goto out;\n\n    double_evtchn_lock(lchn, rchn);\n\n    lchn->u.interdomain.remote_dom  = rd;\n    lchn->u.interdomain.remote_port = rport;\n    lchn->state                     = ECS_INTERDOMAIN;\n    evtchn_port_init(ld, lchn);\n    \n    rchn->u.interdomain.remote_dom  = ld;\n    rchn->u.interdomain.remote_port = lport;\n    rchn->state                     = ECS_INTERDOMAIN;\n\n    /*\n     * We may have lost notifications on the remote unbound port. Fix that up\n     * here by conservatively always setting a notification on the local port.\n     */\n    evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn);\n\n    double_evtchn_unlock(lchn, rchn);\n\n    bind->local_port = lport;\n\n out:\n    check_free_port(ld, lport);\n    spin_unlock(&ld->event_lock);\n    if ( ld != rd )\n        spin_unlock(&rd->event_lock);\n    \n    rcu_unlock_domain(rd);\n\n    return rc;\n}""}, {""func_name"": ""evtchn_bind_virq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_bind_virq(evtchn_bind_virq_t *bind, evtchn_port_t port)\n{\n    struct evtchn *chn;\n    struct vcpu   *v;\n    struct domain *d = current->domain;\n    int            virq = bind->virq, vcpu = bind->vcpu;\n    int            rc = 0;\n    unsigned long  flags;\n\n    if ( (virq < 0) || (virq >= ARRAY_SIZE(v->virq_to_evtchn)) )\n        return -EINVAL;\n\n   /*\n    * Make sure the guest controlled value virq is bounded even during\n    * speculative execution.\n    */\n    virq = array_index_nospec(virq, ARRAY_SIZE(v->virq_to_evtchn));\n\n    if ( virq_is_global(virq) && (vcpu != 0) )\n        return -EINVAL;\n\n    if ( (v = domain_vcpu(d, vcpu)) == NULL )\n        return -ENOENT;\n\n    spin_lock(&d->event_lock);\n\n    if ( v->virq_to_evtchn[virq] != 0 )\n        ERROR_EXIT(-EEXIST);\n\n    if ( port != 0 )\n    {\n        if ( (rc = evtchn_allocate_port(d, port)) != 0 )\n            ERROR_EXIT(rc);\n    }\n    else\n    {\n        int alloc_port = get_free_port(d);\n\n        if ( alloc_port < 0 )\n            ERROR_EXIT(alloc_port);\n        port = alloc_port;\n    }\n\n    chn = evtchn_from_port(d, port);\n\n    spin_lock_irqsave(&chn->lock, flags);\n\n    chn->state          = ECS_VIRQ;\n    chn->notify_vcpu_id = vcpu;\n    chn->u.virq         = virq;\n    evtchn_port_init(d, chn);\n\n    spin_unlock_irqrestore(&chn->lock, flags);\n\n    v->virq_to_evtchn[virq] = bind->port = port;\n\n out:\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}""}, {""func_name"": ""evtchn_bind_pirq"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_bind_pirq(evtchn_bind_pirq_t *bind)\n{\n    struct evtchn *chn;\n    struct domain *d = current->domain;\n    struct vcpu   *v = d->vcpu[0];\n    struct pirq   *info;\n    int            port = 0, pirq = bind->pirq;\n    long           rc;\n    unsigned long  flags;\n\n    if ( (pirq < 0) || (pirq >= d->nr_pirqs) )\n        return -EINVAL;\n\n    if ( !is_hvm_domain(d) && !pirq_access_permitted(d, pirq) )\n        return -EPERM;\n\n    spin_lock(&d->event_lock);\n\n    if ( pirq_to_evtchn(d, pirq) != 0 )\n        ERROR_EXIT(-EEXIST);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT(port);\n\n    chn = evtchn_from_port(d, port);\n\n    info = pirq_get_info(d, pirq);\n    if ( !info )\n        ERROR_EXIT(-ENOMEM);\n    info->evtchn = port;\n    rc = (!is_hvm_domain(d)\n          ? pirq_guest_bind(v, info,\n                            !!(bind->flags & BIND_PIRQ__WILL_SHARE))\n          : 0);\n    if ( rc != 0 )\n    {\n        info->evtchn = 0;\n        pirq_cleanup_check(info, d);\n        goto out;\n    }\n\n    spin_lock_irqsave(&chn->lock, flags);\n\n    chn->state  = ECS_PIRQ;\n    chn->u.pirq.irq = pirq;\n    link_pirq_port(port, chn, v);\n    evtchn_port_init(d, chn);\n\n    spin_unlock_irqrestore(&chn->lock, flags);\n\n    bind->port = port;\n\n    arch_evtchn_bind_pirq(d, pirq);\n\n out:\n    check_free_port(d, port);\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}""}, {""func_name"": ""evtchn_alloc_unbound"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_alloc_unbound(evtchn_alloc_unbound_t *alloc)\n{\n    struct evtchn *chn;\n    struct domain *d;\n    int            port;\n    domid_t        dom = alloc->dom;\n    long           rc;\n    unsigned long  flags;\n\n    d = rcu_lock_domain_by_any_id(dom);\n    if ( d == NULL )\n        return -ESRCH;\n\n    spin_lock(&d->event_lock);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT_DOM(port, d);\n    chn = evtchn_from_port(d, port);\n\n    rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, alloc->remote_dom);\n    if ( rc )\n        goto out;\n\n    spin_lock_irqsave(&chn->lock, flags);\n\n    chn->state = ECS_UNBOUND;\n    if ( (chn->u.unbound.remote_domid = alloc->remote_dom) == DOMID_SELF )\n        chn->u.unbound.remote_domid = current->domain->domain_id;\n    evtchn_port_init(d, chn);\n\n    spin_unlock_irqrestore(&chn->lock, flags);\n\n    alloc->port = port;\n\n out:\n    check_free_port(d, port);\n    spin_unlock(&d->event_lock);\n    rcu_unlock_domain(d);\n\n    return rc;\n}""}, {""func_name"": ""double_evtchn_lock"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static unsigned long double_evtchn_lock(struct evtchn *lchn,\n                                        struct evtchn *rchn)\n{\n    unsigned long flags;\n\n    if ( lchn <= rchn )\n    {\n        spin_lock_irqsave(&lchn->lock, flags);\n        if ( lchn != rchn )\n            spin_lock(&rchn->lock);\n    }\n    else\n    {\n        spin_lock_irqsave(&rchn->lock, flags);\n        spin_lock(&lchn->lock);\n    }\n\n    return flags;\n}""}, {""func_name"": ""double_evtchn_unlock"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static void double_evtchn_unlock(struct evtchn *lchn, struct evtchn *rchn,\n                                 unsigned long flags)\n{\n    if ( lchn != rchn )\n        spin_unlock(&lchn->lock);\n    spin_unlock_irqrestore(&rchn->lock, flags);\n}""}, {""func_name"": ""alloc_unbound_xen_event_channel"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int alloc_unbound_xen_event_channel(\n    struct domain *ld, unsigned int lvcpu, domid_t remote_domid,\n    xen_event_channel_notification_t notification_fn)\n{\n    struct evtchn *chn;\n    int            port, rc;\n    unsigned long  flags;\n\n    spin_lock(&ld->event_lock);\n\n    port = rc = get_free_port(ld);\n    if ( rc < 0 )\n        goto out;\n    chn = evtchn_from_port(ld, port);\n\n    rc = xsm_evtchn_unbound(XSM_TARGET, ld, chn, remote_domid);\n    if ( rc )\n        goto out;\n\n    spin_lock_irqsave(&chn->lock, flags);\n\n    chn->state = ECS_UNBOUND;\n    chn->xen_consumer = get_xen_consumer(notification_fn);\n    chn->notify_vcpu_id = lvcpu;\n    chn->u.unbound.remote_domid = remote_domid;\n\n    spin_unlock_irqrestore(&chn->lock, flags);\n\n    write_atomic(&ld->xen_evtchns, ld->xen_evtchns + 1);\n\n out:\n    check_free_port(ld, port);\n    spin_unlock(&ld->event_lock);\n\n    return rc < 0 ? rc : port;\n}""}, {""func_name"": ""evtchn_bind_ipi"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_bind_ipi(evtchn_bind_ipi_t *bind)\n{\n    struct evtchn *chn;\n    struct domain *d = current->domain;\n    int            port, vcpu = bind->vcpu;\n    long           rc = 0;\n    unsigned long  flags;\n\n    if ( domain_vcpu(d, vcpu) == NULL )\n        return -ENOENT;\n\n    spin_lock(&d->event_lock);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT(port);\n\n    chn = evtchn_from_port(d, port);\n\n    spin_lock_irqsave(&chn->lock, flags);\n\n    chn->state          = ECS_IPI;\n    chn->notify_vcpu_id = vcpu;\n    evtchn_port_init(d, chn);\n\n    spin_unlock_irqrestore(&chn->lock, flags);\n\n    bind->port = port;\n\n out:\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}""}, {""func_name"": ""evtchn_send"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_send(struct domain *ld, unsigned int lport)\n{\n    struct evtchn *lchn, *rchn;\n    struct domain *rd;\n    int            rport, ret = 0;\n    unsigned long  flags;\n\n    if ( !port_is_valid(ld, lport) )\n        return -EINVAL;\n\n    lchn = evtchn_from_port(ld, lport);\n\n    spin_lock_irqsave(&lchn->lock, flags);\n\n    /* Guest cannot send via a Xen-attached event channel. */\n    if ( unlikely(consumer_is_xen(lchn)) )\n    {\n        ret = -EINVAL;\n        goto out;\n    }\n\n    ret = xsm_evtchn_send(XSM_HOOK, ld, lchn);\n    if ( ret )\n        goto out;\n\n    switch ( lchn->state )\n    {\n    case ECS_INTERDOMAIN:\n        rd    = lchn->u.interdomain.remote_dom;\n        rport = lchn->u.interdomain.remote_port;\n        rchn  = evtchn_from_port(rd, rport);\n        if ( consumer_is_xen(rchn) )\n            xen_notification_fn(rchn)(rd->vcpu[rchn->notify_vcpu_id], rport);\n        else\n            evtchn_port_set_pending(rd, rchn->notify_vcpu_id, rchn);\n        break;\n    case ECS_IPI:\n        evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn);\n        break;\n    case ECS_UNBOUND:\n        /* silently drop the notification */\n        break;\n    default:\n        ret = -EINVAL;\n    }\n\nout:\n    spin_unlock_irqrestore(&lchn->lock, flags);\n\n    return ret;\n}""}, {""func_name"": ""evtchn_close"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_close(struct domain *d1, int port1, bool guest)\n{\n    struct domain *d2 = NULL;\n    struct vcpu   *v;\n    struct evtchn *chn1, *chn2;\n    int            port2;\n    long           rc = 0;\n    unsigned long  flags;\n\n again:\n    spin_lock(&d1->event_lock);\n\n    if ( !port_is_valid(d1, port1) )\n    {\n        rc = -EINVAL;\n        goto out;\n    }\n\n    chn1 = evtchn_from_port(d1, port1);\n\n    /* Guest cannot close a Xen-attached event channel. */\n    if ( unlikely(consumer_is_xen(chn1)) && guest )\n    {\n        rc = -EINVAL;\n        goto out;\n    }\n\n    switch ( chn1->state )\n    {\n    case ECS_FREE:\n    case ECS_RESERVED:\n        rc = -EINVAL;\n        goto out;\n\n    case ECS_UNBOUND:\n        break;\n\n    case ECS_PIRQ: {\n        struct pirq *pirq = pirq_info(d1, chn1->u.pirq.irq);\n\n        if ( !pirq )\n            break;\n        if ( !is_hvm_domain(d1) )\n            pirq_guest_unbind(d1, pirq);\n        pirq->evtchn = 0;\n        pirq_cleanup_check(pirq, d1);\n        unlink_pirq_port(chn1, d1->vcpu[chn1->notify_vcpu_id]);\n#ifdef CONFIG_X86\n        if ( is_hvm_domain(d1) && domain_pirq_to_irq(d1, pirq->pirq) > 0 )\n            unmap_domain_pirq_emuirq(d1, pirq->pirq);\n#endif\n        break;\n    }\n\n    case ECS_VIRQ:\n        for_each_vcpu ( d1, v )\n        {\n            if ( v->virq_to_evtchn[chn1->u.virq] != port1 )\n                continue;\n            v->virq_to_evtchn[chn1->u.virq] = 0;\n            spin_barrier(&v->virq_lock);\n        }\n        break;\n\n    case ECS_IPI:\n        break;\n\n    case ECS_INTERDOMAIN:\n        if ( d2 == NULL )\n        {\n            d2 = chn1->u.interdomain.remote_dom;\n\n            /* If we unlock d1 then we could lose d2. Must get a reference. */\n            if ( unlikely(!get_domain(d2)) )\n                BUG();\n\n            if ( d1 < d2 )\n            {\n                spin_lock(&d2->event_lock);\n            }\n            else if ( d1 != d2 )\n            {\n                spin_unlock(&d1->event_lock);\n                spin_lock(&d2->event_lock);\n                goto again;\n            }\n        }\n        else if ( d2 != chn1->u.interdomain.remote_dom )\n        {\n            /*\n             * We can only get here if the port was closed and re-bound after\n             * unlocking d1 but before locking d2 above. We could retry but\n             * it is easier to return the same error as if we had seen the\n             * port in ECS_CLOSED. It must have passed through that state for\n             * us to end up here, so it's a valid error to return.\n             */\n            rc = -EINVAL;\n            goto out;\n        }\n\n        port2 = chn1->u.interdomain.remote_port;\n        BUG_ON(!port_is_valid(d2, port2));\n\n        chn2 = evtchn_from_port(d2, port2);\n        BUG_ON(chn2->state != ECS_INTERDOMAIN);\n        BUG_ON(chn2->u.interdomain.remote_dom != d1);\n\n        flags = double_evtchn_lock(chn1, chn2);\n\n        evtchn_free(d1, chn1);\n\n        chn2->state = ECS_UNBOUND;\n        chn2->u.unbound.remote_domid = d1->domain_id;\n\n        double_evtchn_unlock(chn1, chn2, flags);\n\n        goto out;\n\n    default:\n        BUG();\n    }\n\n    spin_lock_irqsave(&chn1->lock, flags);\n    evtchn_free(d1, chn1);\n    spin_unlock_irqrestore(&chn1->lock, flags);\n\n out:\n    if ( d2 != NULL )\n    {\n        if ( d1 != d2 )\n            spin_unlock(&d2->event_lock);\n        put_domain(d2);\n    }\n\n    spin_unlock(&d1->event_lock);\n\n    return rc;\n}""}, {""func_name"": ""notify_via_xen_event_channel"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""void notify_via_xen_event_channel(struct domain *ld, int lport)\n{\n    struct evtchn *lchn, *rchn;\n    struct domain *rd;\n    unsigned long flags;\n\n    ASSERT(port_is_valid(ld, lport));\n    lchn = evtchn_from_port(ld, lport);\n\n    spin_lock_irqsave(&lchn->lock, flags);\n\n    if ( likely(lchn->state == ECS_INTERDOMAIN) )\n    {\n        ASSERT(consumer_is_xen(lchn));\n        rd    = lchn->u.interdomain.remote_dom;\n        rchn  = evtchn_from_port(rd, lchn->u.interdomain.remote_port);\n        evtchn_port_set_pending(rd, rchn->notify_vcpu_id, rchn);\n    }\n\n    spin_unlock_irqrestore(&lchn->lock, flags);\n}""}, {""func_name"": ""evtchn_bind_interdomain"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static long evtchn_bind_interdomain(evtchn_bind_interdomain_t *bind)\n{\n    struct evtchn *lchn, *rchn;\n    struct domain *ld = current->domain, *rd;\n    int            lport, rport = bind->remote_port;\n    domid_t        rdom = bind->remote_dom;\n    long           rc;\n    unsigned long  flags;\n\n    if ( rdom == DOMID_SELF )\n        rdom = current->domain->domain_id;\n\n    if ( (rd = rcu_lock_domain_by_id(rdom)) == NULL )\n        return -ESRCH;\n\n    /* Avoid deadlock by first acquiring lock of domain with smaller id. */\n    if ( ld < rd )\n    {\n        spin_lock(&ld->event_lock);\n        spin_lock(&rd->event_lock);\n    }\n    else\n    {\n        if ( ld != rd )\n            spin_lock(&rd->event_lock);\n        spin_lock(&ld->event_lock);\n    }\n\n    if ( (lport = get_free_port(ld)) < 0 )\n        ERROR_EXIT(lport);\n    lchn = evtchn_from_port(ld, lport);\n\n    if ( !port_is_valid(rd, rport) )\n        ERROR_EXIT_DOM(-EINVAL, rd);\n    rchn = evtchn_from_port(rd, rport);\n    if ( (rchn->state != ECS_UNBOUND) ||\n         (rchn->u.unbound.remote_domid != ld->domain_id) )\n        ERROR_EXIT_DOM(-EINVAL, rd);\n\n    rc = xsm_evtchn_interdomain(XSM_HOOK, ld, lchn, rd, rchn);\n    if ( rc )\n        goto out;\n\n    flags = double_evtchn_lock(lchn, rchn);\n\n    lchn->u.interdomain.remote_dom  = rd;\n    lchn->u.interdomain.remote_port = rport;\n    lchn->state                     = ECS_INTERDOMAIN;\n    evtchn_port_init(ld, lchn);\n    \n    rchn->u.interdomain.remote_dom  = ld;\n    rchn->u.interdomain.remote_port = lport;\n    rchn->state                     = ECS_INTERDOMAIN;\n\n    /*\n     * We may have lost notifications on the remote unbound port. Fix that up\n     * here by conservatively always setting a notification on the local port.\n     */\n    evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn);\n\n    double_evtchn_unlock(lchn, rchn, flags);\n\n    bind->local_port = lport;\n\n out:\n    check_free_port(ld, lport);\n    spin_unlock(&ld->event_lock);\n    if ( ld != rd )\n        spin_unlock(&rd->event_lock);\n    \n    rcu_unlock_domain(rd);\n\n    return rc;\n}""}]","{""function"": 4, ""code"": 2, ""value"": 2}","[{""source"": ""func_info(func:evtchn_from_port)"", ""result"": [{""code"": ""static inline struct evtchn *evtchn_from_port(struct domain *d, unsigned int p)\n{\n    if ( p < EVTCHNS_PER_BUCKET )\n        return &d->evtchn[array_index_nospec(p, EVTCHNS_PER_BUCKET)];\n    return bucket_from_port(d, p) + (p % EVTCHNS_PER_BUCKET);\n}"", ""start_line"": 129, ""end_line"": 134, ""full_name"": ""evtchn_from_port"", ""file_path"": ""xen/include/xen/event.h""}]}, {""source"": ""code_info(file:event_channel.c, lines:10-30)"", ""result"": "" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <xen/init.h>\n#include <xen/lib.h>\n#include <xen/errno.h>\n#include <xen/sched.h>\n#include <xen/event.h>\n#include <xen/irq.h>\n#include <xen/iocap.h>\n#include <xen/compat.h>\n#include <xen/guest_access.h>\n#include <xen/keyhandler.h>\n#include <xen/event_fifo.h>\n#include <asm/current.h>\n\n#include <public/xen.h>\n""}, {""source"": ""func_info(func:evtchn_reset)"", ""result"": [{""code"": ""int evtchn_reset(struct domain *d)\n{\n    unsigned int i;\n    int rc = 0;\n\n    if ( d != current->domain && !d->controller_pause_count )\n        return -EINVAL;\n\n    for ( i = 0; port_is_valid(d, i); i++ )\n        evtchn_close(d, i, 1);\n\n    spin_lock(&d->event_lock);\n\n    if ( d->active_evtchns > d->xen_evtchns )\n        rc = -EAGAIN;\n    else if ( d->evtchn_fifo )\n    {\n        /* Switching back to 2-level ABI. */\n        evtchn_fifo_destroy(d);\n        evtchn_2l_init(d);\n    }\n\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}"", ""start_line"": 1047, ""end_line"": 1072, ""full_name"": ""evtchn_reset"", ""file_path"": ""xen/common/event_channel.c""}]}, {""source"": ""code_info(file:event_channel.c, lines:1048-1069)"", ""result"": ""{\n    unsigned int i;\n    int rc = 0;\n\n    if ( d != current->domain && !d->controller_pause_count )\n        return -EINVAL;\n\n    for ( i = 0; port_is_valid(d, i); i++ )\n        evtchn_close(d, i, 1);\n\n    spin_lock(&d->event_lock);\n\n    if ( d->active_evtchns > d->xen_evtchns )\n        rc = -EAGAIN;\n    else if ( d->evtchn_fifo )\n    {\n        /* Switching back to 2-level ABI. */\n        evtchn_fifo_destroy(d);\n        evtchn_2l_init(d);\n    }\n\n    spin_unlock(&d->event_lock);\n""}, {""source"": ""func_info(func:double_evtchn_lock)"", ""result"": [{""code"": ""static unsigned long double_evtchn_lock(struct evtchn *lchn,\n                                        struct evtchn *rchn)\n{\n    unsigned long flags;\n\n    if ( lchn <= rchn )\n    {\n        spin_lock_irqsave(&lchn->lock, flags);\n        if ( lchn != rchn )\n            spin_lock(&rchn->lock);\n    }\n    else\n    {\n        spin_lock_irqsave(&rchn->lock, flags);\n        spin_lock(&lchn->lock);\n    }\n\n    return flags;\n}"", ""start_line"": 287, ""end_line"": 305, ""full_name"": ""double_evtchn_lock"", ""file_path"": ""xen/common/event_channel.c""}]}, {""source"": ""func_info(func:double_evtchn_unlock)"", ""result"": [{""code"": ""static void double_evtchn_unlock(struct evtchn *lchn, struct evtchn *rchn,\n                                 unsigned long flags)\n{\n    if ( lchn != rchn )\n        spin_unlock(&lchn->lock);\n    spin_unlock_irqrestore(&rchn->lock, flags);\n}"", ""start_line"": 307, ""end_line"": 313, ""full_name"": ""double_evtchn_unlock"", ""file_path"": ""xen/common/event_channel.c""}]}, {""source"": ""value_info(file:event.h, value:EVTCHNS_PER_BUCKET)"", ""result"": {""value_trace"": [{""full_code"": ""EVTCHNS_PER_BUCKET"", ""line"": 131, ""func_name"": null}], ""struct_var"": ""EVTCHNS_PER_BUCKET"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:event.h, value:array_index_nospec)"", ""result"": {""value_trace"": [{""full_code"": ""d->arch.altp2m_eptp[array_index_nospec(i, MAX_EPTP)] = ept->eptp"", ""line"": 1393, ""func_name"": ""p2m_init_altp2m_ept""}, {""full_code"": ""d->arch.altp2m_visible_eptp[array_index_nospec(i, MAX_EPTP)] = ept->eptp"", ""line"": 1394, ""func_name"": ""p2m_init_altp2m_ept""}], ""struct_var"": ""array_index_nospec"", ""struct_type"": null, ""struct_definition"": null}}]","Unprotected port-based access to event channels allowed concurrent modifications by evtchn_reset(). Functions like evtchn_send() (xen/common/event_channel.c:718-760) and notify_via_xen_event_channel() (xen/common/event_channel.c:1295-1310) now use spin_lock_irqsave to block resets during access. evtchn_reset() (xen/common/event_channel.c:1048-1069) closes all channels and modifies event channel state under the domain's event_lock. evtchn_from_port() (xen/include/xen/event.h:129-134) converts port numbers to evtchn pointers without enforcing lock holdings, creating a race where evtchn_reset() could invalidate ports during access. This leads to out-of-bounds memory accesses or invalid operations on freed channels.",0.95,./github/other_context/CVE-2020-25599
57,CVE-2020-25603,CWE-670,c_cpp,"An issue was discovered in Xen through 4.14.x. There are missing memory barriers when accessing/allocating an event channel. Event channels control structures can be accessed lockless as long as the port is considered to be valid. Such a sequence is missing an appropriate memory barrier (e.g., smp_*mb()) to prevent both the compiler and CPU from re-ordering access. A malicious guest may be able to cause a hypervisor crash resulting in a Denial of Service (DoS). Information leak and privilege escalation cannot be excluded. Systems running all versions of Xen are affected. Whether a system is vulnerable will depend on the CPU and compiler used to build Xen. For all systems, the presence and the scope of the vulnerability depend on the precise re-ordering performed by the compiler used to build Xen. We have not been able to survey compilers; consequently we cannot say which compiler(s) might produce vulnerable code (with which code generation options). GCC documentation clearly suggests that re-ordering is possible. Arm systems will also be vulnerable if the CPU is able to re-order memory access. Please consult your CPU vendor. x86 systems are only vulnerable if a compiler performs re-ordering.",https://github.com/xen-project/xen/commit/112992b05b2d2ca63f3c78eefe1cf8d192d7303a,"xen/evtchn: Add missing barriers when accessing/allocating an event channel\n\nWhile the allocation of a bucket is always performed with the per-domain\nlock, the bucket may be accessed without the lock taken (for instance, see\nevtchn_send()).\n\nInstead such sites relies on port_is_valid() to return a non-zero value\nwhen the port has a struct evtchn associated to it. The function will\nmostly check whether the port is less than d->valid_evtchns as all the\nbuckets/event channels should be allocated up to that point.\n\nUnfortunately a compiler is free to re-order the assignment in\nevtchn_allocate_port() so it would be possible to have d->valid_evtchns\nupdated before the new bucket has finish to allocate.\n\nAdditionally on Arm, even if this was compiled ""correctly"", the\nprocessor can still re-order the memory access.\n\nAdd a write memory barrier in the allocation side and a read memory\nbarrier when the port is valid to prevent any re-ordering issue.\n\nThis is XSA-340.\n\nReported-by: Julien Grall <jgrall@amazon.com>\nSigned-off-by: Julien Grall <jgrall@amazon.com>\nReviewed-by: Stefano Stabellini <sstabellini@kernel.org>",2,"[{""func_name"": ""port_is_valid"", ""file_path"": ""xen/include/xen/event.h"", ""func_code"": ""static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    return p < read_atomic(&d->valid_evtchns);\n}"", ""target"": 0}, {""func_name"": ""evtchn_allocate_port"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_allocate_port(struct domain *d, evtchn_port_t port)\n{\n    if ( port > d->max_evtchn_port || port >= d->max_evtchns )\n        return -ENOSPC;\n\n    if ( port_is_valid(d, port) )\n    {\n        if ( evtchn_from_port(d, port)->state != ECS_FREE ||\n             evtchn_port_is_busy(d, port) )\n            return -EBUSY;\n    }\n    else\n    {\n        struct evtchn *chn;\n        struct evtchn **grp;\n\n        if ( !group_from_port(d, port) )\n        {\n            grp = xzalloc_array(struct evtchn *, BUCKETS_PER_GROUP);\n            if ( !grp )\n                return -ENOMEM;\n            group_from_port(d, port) = grp;\n        }\n\n        chn = alloc_evtchn_bucket(d, port);\n        if ( !chn )\n            return -ENOMEM;\n        bucket_from_port(d, port) = chn;\n\n        write_atomic(&d->valid_evtchns, d->valid_evtchns + EVTCHNS_PER_BUCKET);\n    }\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""port_is_valid"", ""file_path"": ""xen/include/xen/event.h"", ""func_code"": ""static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    if ( p >= read_atomic(&d->valid_evtchns) )\n        return false;\n\n    /*\n     * The caller will usually access the event channel afterwards and\n     * may be done without taking the per-domain lock. The barrier is\n     * going in pair the smp_wmb() barrier in evtchn_allocate_port().\n     */\n    smp_rmb();\n\n    return true;\n}""}, {""func_name"": ""evtchn_allocate_port"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""int evtchn_allocate_port(struct domain *d, evtchn_port_t port)\n{\n    if ( port > d->max_evtchn_port || port >= d->max_evtchns )\n        return -ENOSPC;\n\n    if ( port_is_valid(d, port) )\n    {\n        if ( evtchn_from_port(d, port)->state != ECS_FREE ||\n             evtchn_port_is_busy(d, port) )\n            return -EBUSY;\n    }\n    else\n    {\n        struct evtchn *chn;\n        struct evtchn **grp;\n\n        if ( !group_from_port(d, port) )\n        {\n            grp = xzalloc_array(struct evtchn *, BUCKETS_PER_GROUP);\n            if ( !grp )\n                return -ENOMEM;\n            group_from_port(d, port) = grp;\n        }\n\n        chn = alloc_evtchn_bucket(d, port);\n        if ( !chn )\n            return -ENOMEM;\n        bucket_from_port(d, port) = chn;\n\n        /*\n         * d->valid_evtchns is used to check whether the bucket can be\n         * accessed without the per-domain lock. Therefore,\n         * d->valid_evtchns should be seen *after* the new bucket has\n         * been setup.\n         */\n        smp_wmb();\n        write_atomic(&d->valid_evtchns, d->valid_evtchns + EVTCHNS_PER_BUCKET);\n    }\n\n    return 0;\n}""}]","{""caller"": 4, ""code"": 1, ""value"": 1, ""function"": 1}","[{""source"": ""caller_info(file:event.h, func:port_is_valid)"", ""result"": [{""call_line"": 183, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static void evtchn_reserve(struct domain *d, unsigned int port)\n{\n    ASSERT(port_is_valid(d, port));\n    evtchn_from_port(d, port)->state = ECS_RESERVED;\n    BUG_ON(xen_hypercall_evtchn_unmask(port));\n}"", ""caller_start"": 181, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 190, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static bool evtchn_handled(struct domain *d, unsigned int port)\n{\n    ASSERT(port_is_valid(d, port));\n    /* The shim manages VIRQs, the rest is forwarded to L0. */\n    return evtchn_from_port(d, port)->state == ECS_VIRQ;\n}"", ""caller_start"": 188, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 198, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static void evtchn_assign_vcpu(struct domain *d, unsigned int port,\n                               unsigned int vcpu)\n{\n    ASSERT(port_is_valid(d, port));\n    evtchn_from_port(d, port)->notify_vcpu_id = vcpu;\n}"", ""caller_start"": 195, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 373, ""call_code"": ""port_is_valid(d, i)"", ""caller_code"": ""int pv_shim_shutdown(uint8_t reason)\n{\n    struct domain *d = current->domain;\n    struct vcpu *v;\n    unsigned int i;\n    uint64_t old_store_pfn, old_console_pfn = 0, store_pfn, console_pfn;\n    uint64_t store_evtchn, console_evtchn;\n    long rc;\n\n    if ( reason != SHUTDOWN_suspend )\n        /* Forward to L0. */\n        return xen_hypercall_shutdown(reason);\n\n    BUG_ON(current->vcpu_id != 0);\n\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_PFN, &old_store_pfn));\n    if ( !pv_console )\n        BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_PFN,\n                                           &old_console_pfn));\n\n    /* Pause the other vcpus before starting the migration. */\n    for_each_vcpu ( d, v )\n        if ( v != current )\n            vcpu_pause_by_systemcontroller(v);\n\n    /* Prepare timekeeping code to suspend.*/\n    time_suspend();\n\n    rc = xen_hypercall_shutdown(SHUTDOWN_suspend);\n    if ( rc )\n    {\n        time_resume();\n        for_each_vcpu ( d, v )\n            if ( v != current )\n                vcpu_unpause_by_systemcontroller(v);\n\n        return rc;\n    }\n\n    /* Resume the shim itself and timekeeping first. */\n    hypervisor_resume();\n    time_resume();\n\n    /*\n     * ATM there's nothing Xen can do if the console/store pfn changes,\n     * because Xen won't have a page_info struct for it.\n     */\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_PFN, &store_pfn));\n    BUG_ON(old_store_pfn != store_pfn);\n    if ( !pv_console )\n    {\n        BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_PFN,\n                                           &console_pfn));\n        BUG_ON(old_console_pfn != console_pfn);\n    }\n\n    /* Update domain id. */\n    d->domain_id = get_initial_domain_id();\n\n    /* Clean the iomem range. */\n    BUG_ON(iomem_deny_access(d, 0, ~0UL));\n\n    /* Clean grant frames. */\n    xfree(grant_frames);\n    grant_frames = NULL;\n    nr_grant_list = 0;\n\n    /* Clean event channels. */\n    for ( i = 0; i < EVTCHN_2L_NR_CHANNELS; i++ )\n    {\n        if ( !port_is_valid(d, i) )\n            continue;\n\n        if ( evtchn_handled(d, i) )\n            evtchn_close(d, i, false);\n        else\n            evtchn_free(d, evtchn_from_port(d, i));\n    }\n\n    /* Reserve store/console event channel. */\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_EVTCHN, &store_evtchn));\n    BUG_ON(evtchn_allocate_port(d, store_evtchn));\n    evtchn_reserve(d, store_evtchn);\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_EVTCHN,\n                                       &console_evtchn));\n    BUG_ON(evtchn_allocate_port(d, console_evtchn));\n    evtchn_reserve(d, console_evtchn);\n\n    /* Clean watchdogs. */\n    watchdog_domain_destroy(d);\n    watchdog_domain_init(d);\n\n    /* Clean the PIRQ EOI page. */\n    if ( d->arch.pirq_eoi_map != NULL )\n    {\n        unmap_domain_page_global(d->arch.pirq_eoi_map);\n        put_page_and_type(mfn_to_page(_mfn(d->arch.pirq_eoi_map_mfn)));\n        d->arch.pirq_eoi_map = NULL;\n        d->arch.pirq_eoi_map_mfn = 0;\n        d->arch.auto_unmask = 0;\n    }\n\n    /*\n     * NB: there's no need to fixup the p2m, since the mfns assigned\n     * to the PV guest have not changed at all. Just re-write the\n     * start_info fields with the appropriate value.\n     */\n    write_start_info(d);\n\n    for_each_vcpu ( d, v )\n    {\n        /* Unmap guest vcpu_info pages. */\n        unmap_vcpu_info(v);\n\n        /* Reset the periodic timer to the default value. */\n        vcpu_set_periodic_timer(v, MILLISECS(10));\n        /* Stop the singleshot timer. */\n        stop_timer(&v->singleshot_timer);\n\n        if ( test_bit(_VPF_down, &v->pause_flags) )\n            BUG_ON(vcpu_reset(v));\n\n        if ( v != current )\n            vcpu_unpause_by_systemcontroller(v);\n    }\n\n    return 0;\n}\n"", ""caller_start"": 303, ""file_path"": ""xen/arch/x86/pv/shim.c""}]}, {""source"": ""code_info(file:event.h, lines:100-120)"", ""result"": "" *\n * The first bucket is directly accessed via d->evtchn.\n */\n#define group_from_port(d, p) \\\n    array_access_nospec((d)->evtchn_group, (p) / EVTCHNS_PER_GROUP)\n#define bucket_from_port(d, p) \\\n    ((group_from_port(d, p))[((p) % EVTCHNS_PER_GROUP) / EVTCHNS_PER_BUCKET])\n\nstatic inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    return p < read_atomic(&d->valid_evtchns);\n}\n\nstatic inline struct evtchn *evtchn_from_port(struct domain *d, unsigned int p)\n{\n    if ( p < EVTCHNS_PER_BUCKET )\n        return &d->evtchn[array_index_nospec(p, EVTCHNS_PER_BUCKET)];\n    return bucket_from_port(d, p) + (p % EVTCHNS_PER_BUCKET);\n}\n\n/* Wait on a Xen-attached event channel. */\n""}, {""source"": ""value_info(file:event_channel.c, value:d->valid_evtchns)"", ""result"": {""value_trace"": [{""full_code"": ""d->valid_evtchns = EVTCHNS_PER_BUCKET"", ""line"": 1301, ""func_name"": ""evtchn_init""}], ""struct_var"": ""d"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:event.h, func:port_is_valid)"", ""result"": [{""call_line"": 183, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static void evtchn_reserve(struct domain *d, unsigned int port)\n{\n    ASSERT(port_is_valid(d, port));\n    evtchn_from_port(d, port)->state = ECS_RESERVED;\n    BUG_ON(xen_hypercall_evtchn_unmask(port));\n}"", ""caller_start"": 181, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 190, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static bool evtchn_handled(struct domain *d, unsigned int port)\n{\n    ASSERT(port_is_valid(d, port));\n    /* The shim manages VIRQs, the rest is forwarded to L0. */\n    return evtchn_from_port(d, port)->state == ECS_VIRQ;\n}"", ""caller_start"": 188, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 198, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static void evtchn_assign_vcpu(struct domain *d, unsigned int port,\n                               unsigned int vcpu)\n{\n    ASSERT(port_is_valid(d, port));\n    evtchn_from_port(d, port)->notify_vcpu_id = vcpu;\n}"", ""caller_start"": 195, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 373, ""call_code"": ""port_is_valid(d, i)"", ""caller_code"": ""int pv_shim_shutdown(uint8_t reason)\n{\n    struct domain *d = current->domain;\n    struct vcpu *v;\n    unsigned int i;\n    uint64_t old_store_pfn, old_console_pfn = 0, store_pfn, console_pfn;\n    uint64_t store_evtchn, console_evtchn;\n    long rc;\n\n    if ( reason != SHUTDOWN_suspend )\n        /* Forward to L0. */\n        return xen_hypercall_shutdown(reason);\n\n    BUG_ON(current->vcpu_id != 0);\n\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_PFN, &old_store_pfn));\n    if ( !pv_console )\n        BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_PFN,\n                                           &old_console_pfn));\n\n    /* Pause the other vcpus before starting the migration. */\n    for_each_vcpu ( d, v )\n        if ( v != current )\n            vcpu_pause_by_systemcontroller(v);\n\n    /* Prepare timekeeping code to suspend.*/\n    time_suspend();\n\n    rc = xen_hypercall_shutdown(SHUTDOWN_suspend);\n    if ( rc )\n    {\n        time_resume();\n        for_each_vcpu ( d, v )\n            if ( v != current )\n                vcpu_unpause_by_systemcontroller(v);\n\n        return rc;\n    }\n\n    /* Resume the shim itself and timekeeping first. */\n    hypervisor_resume();\n    time_resume();\n\n    /*\n     * ATM there's nothing Xen can do if the console/store pfn changes,\n     * because Xen won't have a page_info struct for it.\n     */\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_PFN, &store_pfn));\n    BUG_ON(old_store_pfn != store_pfn);\n    if ( !pv_console )\n    {\n        BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_PFN,\n                                           &console_pfn));\n        BUG_ON(old_console_pfn != console_pfn);\n    }\n\n    /* Update domain id. */\n    d->domain_id = get_initial_domain_id();\n\n    /* Clean the iomem range. */\n    BUG_ON(iomem_deny_access(d, 0, ~0UL));\n\n    /* Clean grant frames. */\n    xfree(grant_frames);\n    grant_frames = NULL;\n    nr_grant_list = 0;\n\n    /* Clean event channels. */\n    for ( i = 0; i < EVTCHN_2L_NR_CHANNELS; i++ )\n    {\n        if ( !port_is_valid(d, i) )\n            continue;\n\n        if ( evtchn_handled(d, i) )\n            evtchn_close(d, i, false);\n        else\n            evtchn_free(d, evtchn_from_port(d, i));\n    }\n\n    /* Reserve store/console event channel. */\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_EVTCHN, &store_evtchn));\n    BUG_ON(evtchn_allocate_port(d, store_evtchn));\n    evtchn_reserve(d, store_evtchn);\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_EVTCHN,\n                                       &console_evtchn));\n    BUG_ON(evtchn_allocate_port(d, console_evtchn));\n    evtchn_reserve(d, console_evtchn);\n\n    /* Clean watchdogs. */\n    watchdog_domain_destroy(d);\n    watchdog_domain_init(d);\n\n    /* Clean the PIRQ EOI page. */\n    if ( d->arch.pirq_eoi_map != NULL )\n    {\n        unmap_domain_page_global(d->arch.pirq_eoi_map);\n        put_page_and_type(mfn_to_page(_mfn(d->arch.pirq_eoi_map_mfn)));\n        d->arch.pirq_eoi_map = NULL;\n        d->arch.pirq_eoi_map_mfn = 0;\n        d->arch.auto_unmask = 0;\n    }\n\n    /*\n     * NB: there's no need to fixup the p2m, since the mfns assigned\n     * to the PV guest have not changed at all. Just re-write the\n     * start_info fields with the appropriate value.\n     */\n    write_start_info(d);\n\n    for_each_vcpu ( d, v )\n    {\n        /* Unmap guest vcpu_info pages. */\n        unmap_vcpu_info(v);\n\n        /* Reset the periodic timer to the default value. */\n        vcpu_set_periodic_timer(v, MILLISECS(10));\n        /* Stop the singleshot timer. */\n        stop_timer(&v->singleshot_timer);\n\n        if ( test_bit(_VPF_down, &v->pause_flags) )\n            BUG_ON(vcpu_reset(v));\n\n        if ( v != current )\n            vcpu_unpause_by_systemcontroller(v);\n    }\n\n    return 0;\n}\n"", ""caller_start"": 303, ""file_path"": ""xen/arch/x86/pv/shim.c""}]}, {""source"": ""func_info(func:evtchn_send)"", ""result"": [{""code"": ""int evtchn_send(struct domain *ld, unsigned int lport)\n{\n    struct evtchn *lchn, *rchn;\n    struct domain *rd;\n    int            rport, ret = 0;\n\n    if ( !port_is_valid(ld, lport) )\n        return -EINVAL;\n\n    lchn = evtchn_from_port(ld, lport);\n\n    spin_lock(&lchn->lock);\n\n    /* Guest cannot send via a Xen-attached event channel. */\n    if ( unlikely(consumer_is_xen(lchn)) )\n    {\n        ret = -EINVAL;\n        goto out;\n    }\n\n    ret = xsm_evtchn_send(XSM_HOOK, ld, lchn);\n    if ( ret )\n        goto out;\n\n    switch ( lchn->state )\n    {\n    case ECS_INTERDOMAIN:\n        rd    = lchn->u.interdomain.remote_dom;\n        rport = lchn->u.interdomain.remote_port;\n        rchn  = evtchn_from_port(rd, rport);\n        if ( consumer_is_xen(rchn) )\n            xen_notification_fn(rchn)(rd->vcpu[rchn->notify_vcpu_id], rport);\n        else\n            evtchn_port_set_pending(rd, rchn->notify_vcpu_id, rchn);\n        break;\n    case ECS_IPI:\n        evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn);\n        break;\n    case ECS_UNBOUND:\n        /* silently drop the notification */\n        break;\n    default:\n        ret = -EINVAL;\n    }\n\nout:\n    spin_unlock(&lchn->lock);\n\n    return ret;\n}\n"", ""start_line"": 676, ""end_line"": 725, ""full_name"": ""evtchn_send"", ""file_path"": ""xen/common/event_channel.c""}]}, {""source"": ""caller_info(func:port_is_valid)"", ""result"": [{""call_line"": 183, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static void evtchn_reserve(struct domain *d, unsigned int port)\n{\n    ASSERT(port_is_valid(d, port));\n    evtchn_from_port(d, port)->state = ECS_RESERVED;\n    BUG_ON(xen_hypercall_evtchn_unmask(port));\n}"", ""caller_start"": 181, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 190, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static bool evtchn_handled(struct domain *d, unsigned int port)\n{\n    ASSERT(port_is_valid(d, port));\n    /* The shim manages VIRQs, the rest is forwarded to L0. */\n    return evtchn_from_port(d, port)->state == ECS_VIRQ;\n}"", ""caller_start"": 188, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 198, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static void evtchn_assign_vcpu(struct domain *d, unsigned int port,\n                               unsigned int vcpu)\n{\n    ASSERT(port_is_valid(d, port));\n    evtchn_from_port(d, port)->notify_vcpu_id = vcpu;\n}"", ""caller_start"": 195, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 373, ""call_code"": ""port_is_valid(d, i)"", ""caller_code"": ""int pv_shim_shutdown(uint8_t reason)\n{\n    struct domain *d = current->domain;\n    struct vcpu *v;\n    unsigned int i;\n    uint64_t old_store_pfn, old_console_pfn = 0, store_pfn, console_pfn;\n    uint64_t store_evtchn, console_evtchn;\n    long rc;\n\n    if ( reason != SHUTDOWN_suspend )\n        /* Forward to L0. */\n        return xen_hypercall_shutdown(reason);\n\n    BUG_ON(current->vcpu_id != 0);\n\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_PFN, &old_store_pfn));\n    if ( !pv_console )\n        BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_PFN,\n                                           &old_console_pfn));\n\n    /* Pause the other vcpus before starting the migration. */\n    for_each_vcpu ( d, v )\n        if ( v != current )\n            vcpu_pause_by_systemcontroller(v);\n\n    /* Prepare timekeeping code to suspend.*/\n    time_suspend();\n\n    rc = xen_hypercall_shutdown(SHUTDOWN_suspend);\n    if ( rc )\n    {\n        time_resume();\n        for_each_vcpu ( d, v )\n            if ( v != current )\n                vcpu_unpause_by_systemcontroller(v);\n\n        return rc;\n    }\n\n    /* Resume the shim itself and timekeeping first. */\n    hypervisor_resume();\n    time_resume();\n\n    /*\n     * ATM there's nothing Xen can do if the console/store pfn changes,\n     * because Xen won't have a page_info struct for it.\n     */\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_PFN, &store_pfn));\n    BUG_ON(old_store_pfn != store_pfn);\n    if ( !pv_console )\n    {\n        BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_PFN,\n                                           &console_pfn));\n        BUG_ON(old_console_pfn != console_pfn);\n    }\n\n    /* Update domain id. */\n    d->domain_id = get_initial_domain_id();\n\n    /* Clean the iomem range. */\n    BUG_ON(iomem_deny_access(d, 0, ~0UL));\n\n    /* Clean grant frames. */\n    xfree(grant_frames);\n    grant_frames = NULL;\n    nr_grant_list = 0;\n\n    /* Clean event channels. */\n    for ( i = 0; i < EVTCHN_2L_NR_CHANNELS; i++ )\n    {\n        if ( !port_is_valid(d, i) )\n            continue;\n\n        if ( evtchn_handled(d, i) )\n            evtchn_close(d, i, false);\n        else\n            evtchn_free(d, evtchn_from_port(d, i));\n    }\n\n    /* Reserve store/console event channel. */\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_EVTCHN, &store_evtchn));\n    BUG_ON(evtchn_allocate_port(d, store_evtchn));\n    evtchn_reserve(d, store_evtchn);\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_EVTCHN,\n                                       &console_evtchn));\n    BUG_ON(evtchn_allocate_port(d, console_evtchn));\n    evtchn_reserve(d, console_evtchn);\n\n    /* Clean watchdogs. */\n    watchdog_domain_destroy(d);\n    watchdog_domain_init(d);\n\n    /* Clean the PIRQ EOI page. */\n    if ( d->arch.pirq_eoi_map != NULL )\n    {\n        unmap_domain_page_global(d->arch.pirq_eoi_map);\n        put_page_and_type(mfn_to_page(_mfn(d->arch.pirq_eoi_map_mfn)));\n        d->arch.pirq_eoi_map = NULL;\n        d->arch.pirq_eoi_map_mfn = 0;\n        d->arch.auto_unmask = 0;\n    }\n\n    /*\n     * NB: there's no need to fixup the p2m, since the mfns assigned\n     * to the PV guest have not changed at all. Just re-write the\n     * start_info fields with the appropriate value.\n     */\n    write_start_info(d);\n\n    for_each_vcpu ( d, v )\n    {\n        /* Unmap guest vcpu_info pages. */\n        unmap_vcpu_info(v);\n\n        /* Reset the periodic timer to the default value. */\n        vcpu_set_periodic_timer(v, MILLISECS(10));\n        /* Stop the singleshot timer. */\n        stop_timer(&v->singleshot_timer);\n\n        if ( test_bit(_VPF_down, &v->pause_flags) )\n            BUG_ON(vcpu_reset(v));\n\n        if ( v != current )\n            vcpu_unpause_by_systemcontroller(v);\n    }\n\n    return 0;\n}\n"", ""caller_start"": 303, ""file_path"": ""xen/arch/x86/pv/shim.c""}]}, {""source"": ""caller_info(func:port_is_valid)"", ""result"": [{""call_line"": 183, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static void evtchn_reserve(struct domain *d, unsigned int port)\n{\n    ASSERT(port_is_valid(d, port));\n    evtchn_from_port(d, port)->state = ECS_RESERVED;\n    BUG_ON(xen_hypercall_evtchn_unmask(port));\n}"", ""caller_start"": 181, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 190, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static bool evtchn_handled(struct domain *d, unsigned int port)\n{\n    ASSERT(port_is_valid(d, port));\n    /* The shim manages VIRQs, the rest is forwarded to L0. */\n    return evtchn_from_port(d, port)->state == ECS_VIRQ;\n}"", ""caller_start"": 188, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 198, ""call_code"": ""port_is_valid(d, port)"", ""caller_code"": ""static void evtchn_assign_vcpu(struct domain *d, unsigned int port,\n                               unsigned int vcpu)\n{\n    ASSERT(port_is_valid(d, port));\n    evtchn_from_port(d, port)->notify_vcpu_id = vcpu;\n}"", ""caller_start"": 195, ""file_path"": ""xen/arch/x86/pv/shim.c""}, {""call_line"": 373, ""call_code"": ""port_is_valid(d, i)"", ""caller_code"": ""int pv_shim_shutdown(uint8_t reason)\n{\n    struct domain *d = current->domain;\n    struct vcpu *v;\n    unsigned int i;\n    uint64_t old_store_pfn, old_console_pfn = 0, store_pfn, console_pfn;\n    uint64_t store_evtchn, console_evtchn;\n    long rc;\n\n    if ( reason != SHUTDOWN_suspend )\n        /* Forward to L0. */\n        return xen_hypercall_shutdown(reason);\n\n    BUG_ON(current->vcpu_id != 0);\n\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_PFN, &old_store_pfn));\n    if ( !pv_console )\n        BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_PFN,\n                                           &old_console_pfn));\n\n    /* Pause the other vcpus before starting the migration. */\n    for_each_vcpu ( d, v )\n        if ( v != current )\n            vcpu_pause_by_systemcontroller(v);\n\n    /* Prepare timekeeping code to suspend.*/\n    time_suspend();\n\n    rc = xen_hypercall_shutdown(SHUTDOWN_suspend);\n    if ( rc )\n    {\n        time_resume();\n        for_each_vcpu ( d, v )\n            if ( v != current )\n                vcpu_unpause_by_systemcontroller(v);\n\n        return rc;\n    }\n\n    /* Resume the shim itself and timekeeping first. */\n    hypervisor_resume();\n    time_resume();\n\n    /*\n     * ATM there's nothing Xen can do if the console/store pfn changes,\n     * because Xen won't have a page_info struct for it.\n     */\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_PFN, &store_pfn));\n    BUG_ON(old_store_pfn != store_pfn);\n    if ( !pv_console )\n    {\n        BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_PFN,\n                                           &console_pfn));\n        BUG_ON(old_console_pfn != console_pfn);\n    }\n\n    /* Update domain id. */\n    d->domain_id = get_initial_domain_id();\n\n    /* Clean the iomem range. */\n    BUG_ON(iomem_deny_access(d, 0, ~0UL));\n\n    /* Clean grant frames. */\n    xfree(grant_frames);\n    grant_frames = NULL;\n    nr_grant_list = 0;\n\n    /* Clean event channels. */\n    for ( i = 0; i < EVTCHN_2L_NR_CHANNELS; i++ )\n    {\n        if ( !port_is_valid(d, i) )\n            continue;\n\n        if ( evtchn_handled(d, i) )\n            evtchn_close(d, i, false);\n        else\n            evtchn_free(d, evtchn_from_port(d, i));\n    }\n\n    /* Reserve store/console event channel. */\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_STORE_EVTCHN, &store_evtchn));\n    BUG_ON(evtchn_allocate_port(d, store_evtchn));\n    evtchn_reserve(d, store_evtchn);\n    BUG_ON(xen_hypercall_hvm_get_param(HVM_PARAM_CONSOLE_EVTCHN,\n                                       &console_evtchn));\n    BUG_ON(evtchn_allocate_port(d, console_evtchn));\n    evtchn_reserve(d, console_evtchn);\n\n    /* Clean watchdogs. */\n    watchdog_domain_destroy(d);\n    watchdog_domain_init(d);\n\n    /* Clean the PIRQ EOI page. */\n    if ( d->arch.pirq_eoi_map != NULL )\n    {\n        unmap_domain_page_global(d->arch.pirq_eoi_map);\n        put_page_and_type(mfn_to_page(_mfn(d->arch.pirq_eoi_map_mfn)));\n        d->arch.pirq_eoi_map = NULL;\n        d->arch.pirq_eoi_map_mfn = 0;\n        d->arch.auto_unmask = 0;\n    }\n\n    /*\n     * NB: there's no need to fixup the p2m, since the mfns assigned\n     * to the PV guest have not changed at all. Just re-write the\n     * start_info fields with the appropriate value.\n     */\n    write_start_info(d);\n\n    for_each_vcpu ( d, v )\n    {\n        /* Unmap guest vcpu_info pages. */\n        unmap_vcpu_info(v);\n\n        /* Reset the periodic timer to the default value. */\n        vcpu_set_periodic_timer(v, MILLISECS(10));\n        /* Stop the singleshot timer. */\n        stop_timer(&v->singleshot_timer);\n\n        if ( test_bit(_VPF_down, &v->pause_flags) )\n            BUG_ON(vcpu_reset(v));\n\n        if ( v != current )\n            vcpu_unpause_by_systemcontroller(v);\n    }\n\n    return 0;\n}\n"", ""caller_start"": 303, ""file_path"": ""xen/arch/x86/pv/shim.c""}]}]","Missing smp_wmb() in xen/common/event_channel.c:179-185 allowed d->valid_evtchns to be updated before bucket initialization, risking access to uninitialized memory. Missing smp_rmb() in xen/include/xen/event.h:109-119 permitted reordering in port_is_valid(). The patch adds paired barriers, enforced in lockless paths like evtchn_send (xen/common/event_channel.c:676-725) and xen/arch/x86/pv/shim.c callers.",0.95,./github/other_context/CVE-2020-25603
58,CVE-2020-35573,CWE-834,c_cpp,srs2.c in PostSRSd before 1.10 allows remote attackers to cause a denial of service (CPU consumption) via a long timestamp tag in an SRS address.,https://github.com/roehling/postsrsd/commit/4733fb11f6bec6524bb8518c5e1a699288c26bac,"SECURITY: Fix potential denial of service attack against PostSRSd\n\nI discovered that PostSRSd could be tricked into consuming a lot of CPU\ntime with an SRS address that has an excessively long time stamp tag,\ne.g.\n\nSRS0=HHHH=TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT=0@example.com",1,"[{""func_name"": ""srs_timestamp_check"", ""file_path"": ""srs2.c"", ""func_code"": ""int\nsrs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\n\t/* We had better go around this loop exactly twice! */\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}"", ""target"": 0}]","[{""func_name"": ""srs_timestamp_check"", ""file_path"": ""srs2.c"", ""func_code"": ""int\nsrs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\n\tif (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;\n\t/* We had better go around this loop exactly twice! */\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}""}]","{""caller"": 1, ""value"": 1}","[{""source"": ""caller_info(file:srs2.c, func:srs_timestamp_check)"", ""result"": [{""call_line"": 533, ""call_code"": ""srs_timestamp_check(srs, srsstamp)"", ""caller_code"": ""int\nsrs_parse_shortcut(srs_t *srs, char *buf, unsigned buflen, char *senduser)\n{\n\tchar\t*srshash;\n\tchar\t*srsstamp;\n\tchar\t*srshost;\n\tchar\t*srsuser;\n\tint\t\t ret;\n\n\tif (strncasecmp(senduser, SRS0TAG, 4) == 0) {\n\t\tsrshash = senduser + 5;\n\t\tif (!STRINGP(srshash))\n\t\t\treturn SRS_ENOSRS0HASH;\n\t\tsrsstamp = strchr(srshash, SRSSEP);\n\t\tif (!STRINGP(srsstamp))\n\t\t\treturn SRS_ENOSRS0STAMP;\n\t\t*srsstamp++ = '\\0';\n\t\tsrshost = strchr(srsstamp, SRSSEP);\n\t\tif (!STRINGP(srshost))\n\t\t\treturn SRS_ENOSRS0HOST;\n\t\t*srshost++ = '\\0';\n\t\tsrsuser = strchr(srshost, SRSSEP);\n\t\tif (!STRINGP(srsuser))\n\t\t\treturn SRS_ENOSRS0USER;\n\t\t*srsuser++ = '\\0';\n\t\tret = srs_timestamp_check(srs, srsstamp);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tret = srs_hash_check(srs, srshash, 3, srsstamp,\n\t\t\t\t\t\tsrshost, srsuser);\n\t\tif (ret != SRS_SUCCESS)\n\t\t\treturn ret;\n\t\tsnprintf(buf, buflen, \""%s@%s\"", srsuser, srshost);\n\t\treturn SRS_SUCCESS;\n\t}\n\n\treturn SRS_ENOTSRSADDRESS;\n}"", ""caller_start"": 508, ""file_path"": ""srs2.c""}]}, {""source"": ""value_info(file:srs2.c, value:stamp)"", ""result"": {""value_trace"": [{""full_code"": ""srsstamp[SRS_TIME_SIZE + 1]"", ""line"": 400, ""func_name"": ""srs_compile_shortcut""}, {""full_code"": ""srsstamp = strchr(srshash, SRSSEP)"", ""line"": 521, ""func_name"": ""srs_parse_shortcut""}, {""full_code"": ""*srsstamp++ = '\\0'"", ""line"": 524, ""func_name"": ""srs_parse_shortcut""}], ""struct_var"": ""stamp"", ""struct_type"": null, ""struct_definition"": null}}]","srs2.c:231: The 'stamp' parameter (extracted in srs_parse_shortcut() at srs2.c:521 via 'srsstamp = strchr(srshash, SRSSEP)') is passed to srs_timestamp_check() without length validation. The loop 'for (sp = stamp; *sp; sp++)' processes each character of 'stamp', leading to O(n) CPU usage. The patch adds 'strlen(stamp) != 2' to reject non-2-character timestamps, mitigating the issue.",0.95,./github/other_context/CVE-2020-35573
59,CVE-2020-6019,CWE-248,c_cpp,"Valve's Game Networking Sockets prior to version v1.2.0 improperly handles inlined statistics messages in function CConnectionTransportUDPBase::Received_Data(), leading to an exception thrown from libprotobuf and resulting in a crash.",https://github.com/ValveSoftware/GameNetworkingSockets/commit/d944a10808891d202bb1d5e1998de6e0423af678,Tweak pointer math to avoid possible integer overflow,1,"[{""func_name"": ""CConnectionTransportUDPBase::Received_Data"", ""file_path"": ""src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"", ""func_code"": ""void CConnectionTransportUDPBase::Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )\n{\n\n\tif ( cbPkt < sizeof(UDPDataMsgHdr) )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Packet of size %d is too small.\"", cbPkt );\n\t\treturn;\n\t}\n\n\t// Check cookie\n\tconst UDPDataMsgHdr *hdr = (const UDPDataMsgHdr *)pPkt;\n\tif ( LittleDWord( hdr->m_unToConnectionID ) != ConnectionIDLocal() )\n\t{\n\n\t\t// Wrong session.  It could be an old session, or it could be spoofed.\n\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Incorrect connection ID\"" );\n\t\tif ( BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t\t{\n\t\t\tSendNoConnection( LittleDWord( hdr->m_unToConnectionID ), 0 );\n\t\t}\n\t\treturn;\n\t}\n\tuint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\t// Ignore it.  We don't have the SteamID of whoever is on the other end yet,\n\t\t\t// their encryption keys, etc.  The most likely cause is that a server sent\n\t\t\t// a ConnectOK, which dropped.  So they think we're connected but we don't\n\t\t\t// have everything yet.\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP, but might be used for derived class\n\n\t\t\t// We'll process the chunk\n\t\t\tbreak;\n\t}\n\n\tconst uint8 *pIn = pPkt + sizeof(*hdr);\n\tconst uint8 *pPktEnd = pPkt + cbPkt;\n\n\t// Inline stats?\n\tstatic CMsgSteamSockets_UDP_Stats msgStats;\n\tCMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;\n\tuint32 cbStatsMsgIn = 0;\n\tif ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )\n\t{\n\t\t//Msg_Verbose( \""Received inline stats from %s\"", server.m_szName );\n\n\t\tpIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );\n\t\tif ( pIn == NULL )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Failed to varint decode size of stats blob\"" );\n\t\t\treturn;\n\t\t}\n\t\tif ( pIn + cbStatsMsgIn > pPktEnd )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""stats message size doesn't make sense.  Stats message size %d, packet size %d\"", cbStatsMsgIn, cbPkt );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""protobuf failed to parse inline stats message\"" );\n\t\t\treturn;\n\t\t}\n\n\t\t// Shove sequence number so we know what acks to pend, etc\n\t\tpMsgStatsIn = &msgStats;\n\n\t\t// Advance pointer\n\t\tpIn += cbStatsMsgIn;\n\t}\n\n\tconst void *pChunk = pIn;\n\tint cbChunk = pPktEnd - pIn;\n\n\t// Decrypt it, and check packet number\n\tUDPRecvPacketContext_t ctx;\n\tctx.m_usecNow = usecNow;\n\tctx.m_pTransport = this;\n\tctx.m_pStatsIn = pMsgStatsIn;\n\tif ( !m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, ctx ) )\n\t\treturn;\n\n\t// This is a valid packet.  P2P connections might want to make a note of this\n\tRecvValidUDPDataPacket( ctx );\n\n\t// Process plaintext\n\tint usecTimeSinceLast = 0; // FIXME - should we plumb this through so we can measure jitter?\n\tif ( !m_connection.ProcessPlainTextDataChunk( usecTimeSinceLast, ctx ) )\n\t\treturn;\n\n\t// Process the stats, if any\n\tif ( pMsgStatsIn )\n\t\tRecvStats( *pMsgStatsIn, usecNow );\n}"", ""target"": 0}]","[{""func_name"": ""CConnectionTransportUDPBase::Received_Data"", ""file_path"": ""src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp"", ""func_code"": ""void CConnectionTransportUDPBase::Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )\n{\n\n\tif ( cbPkt < sizeof(UDPDataMsgHdr) )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Packet of size %d is too small.\"", cbPkt );\n\t\treturn;\n\t}\n\n\t// Check cookie\n\tconst UDPDataMsgHdr *hdr = (const UDPDataMsgHdr *)pPkt;\n\tif ( LittleDWord( hdr->m_unToConnectionID ) != ConnectionIDLocal() )\n\t{\n\n\t\t// Wrong session.  It could be an old session, or it could be spoofed.\n\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Incorrect connection ID\"" );\n\t\tif ( BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t\t{\n\t\t\tSendNoConnection( LittleDWord( hdr->m_unToConnectionID ), 0 );\n\t\t}\n\t\treturn;\n\t}\n\tuint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\t// Ignore it.  We don't have the SteamID of whoever is on the other end yet,\n\t\t\t// their encryption keys, etc.  The most likely cause is that a server sent\n\t\t\t// a ConnectOK, which dropped.  So they think we're connected but we don't\n\t\t\t// have everything yet.\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP, but might be used for derived class\n\n\t\t\t// We'll process the chunk\n\t\t\tbreak;\n\t}\n\n\tconst uint8 *pIn = pPkt + sizeof(*hdr);\n\tconst uint8 *pPktEnd = pPkt + cbPkt;\n\n\t// Inline stats?\n\tstatic CMsgSteamSockets_UDP_Stats msgStats;\n\tCMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;\n\tuint32 cbStatsMsgIn = 0;\n\tif ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )\n\t{\n\t\t//Msg_Verbose( \""Received inline stats from %s\"", server.m_szName );\n\n\t\tpIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );\n\t\tif ( pIn == NULL )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Failed to varint decode size of stats blob\"" );\n\t\t\treturn;\n\t\t}\n\t\tif ( cbStatsMsgIn > pPktEnd - pIn )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""stats message size doesn't make sense.  Stats message size %u, packet size %d\"", cbStatsMsgIn, cbPkt );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""protobuf failed to parse inline stats message\"" );\n\t\t\treturn;\n\t\t}\n\n\t\t// Shove sequence number so we know what acks to pend, etc\n\t\tpMsgStatsIn = &msgStats;\n\n\t\t// Advance pointer\n\t\tpIn += cbStatsMsgIn;\n\t}\n\n\tconst void *pChunk = pIn;\n\tint cbChunk = pPktEnd - pIn;\n\n\t// Decrypt it, and check packet number\n\tUDPRecvPacketContext_t ctx;\n\tctx.m_usecNow = usecNow;\n\tctx.m_pTransport = this;\n\tctx.m_pStatsIn = pMsgStatsIn;\n\tif ( !m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, ctx ) )\n\t\treturn;\n\n\t// This is a valid packet.  P2P connections might want to make a note of this\n\tRecvValidUDPDataPacket( ctx );\n\n\t// Process plaintext\n\tint usecTimeSinceLast = 0; // FIXME - should we plumb this through so we can measure jitter?\n\tif ( !m_connection.ProcessPlainTextDataChunk( usecTimeSinceLast, ctx ) )\n\t\treturn;\n\n\t// Process the stats, if any\n\tif ( pMsgStatsIn )\n\t\tRecvStats( *pMsgStatsIn, usecNow );\n}""}]","{""value"": 1, ""code"": 1, ""function"": 1}","[{""source"": ""value_info(file:steamnetworkingsockets_udp.cpp, value:cbStatsMsgIn)"", ""result"": {""value_trace"": [{""full_code"": ""cbStatsMsgIn = 0"", ""line"": 832, ""func_name"": ""SteamNetworkingSocketsLib.CConnectionTransportUDPBase.Received_Data:void(uint8*,int,SteamNetworkingMicroseconds)""}], ""struct_var"": ""cbStatsMsgIn"", ""struct_type"": ""uint32"", ""struct_definition"": ""typedef unsigned int uint32;\n\ntypedef unsigned int uint32;\n\nuint32""}}, {""source"": ""code_info(file:steamnetworkingsockets_udp.cpp, lines:832-841)"", ""result"": ""\tuint32 cbStatsMsgIn = 0;\n\tif ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )\n\t{\n\t\t//Msg_Verbose( \""Received inline stats from %s\"", server.m_szName );\n\n\t\tpIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );\n\t\tif ( pIn == NULL )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \""DataPacket\"", \""Failed to varint decode size of stats blob\"" );\n\t\t\treturn;\n""}, {""source"": ""func_info(func:DeserializeVarInt)"", ""result"": [{""code"": ""inline byte *DeserializeVarInt( byte *p, const byte *end, T &x )\n{\n\tif ( p >= end )\n\t\treturn nullptr;\n\tT nResult = *p & 0x7f; // use local variable for working, to make sure compiler doesn't try to worry about pointer aliasing\n\tunsigned nShift = 7;\n\twhile ( *(p++) & 0x80 )\n\t{\n\t\tif ( p >= end )\n\t\t\treturn nullptr;\n\t\tnResult |= ( T( *p & 0x7f ) << nShift );\n\t\tnShift += 7;\n\t}\n\tx = nResult;\n\treturn p;\n}"", ""start_line"": 376, ""end_line"": 391, ""full_name"": ""SteamNetworkingSocketsLib.DeserializeVarInt:byte(byte*,byte*,T&)"", ""file_path"": ""src/steamnetworkingsockets/steamnetworkingsockets_internal.h""}, {""code"": ""inline const byte *DeserializeVarInt( const byte *p, const byte *end, T &x )\n{\n\treturn DeserializeVarInt( const_cast<byte*>( p ), end, x );\n}"", ""start_line"": 395, ""end_line"": 398, ""full_name"": ""SteamNetworkingSocketsLib.DeserializeVarInt<duplicate>0:byte(byte*,byte*,T&)"", ""file_path"": ""src/steamnetworkingsockets/steamnetworkingsockets_internal.h""}]}]","The vulnerability stems from unbounded varint decoding in `DeserializeVarInt` (src/steamnetworkingsockets/steamnetworkingsockets_internal.h:376-391), which assigns the decoded value to `cbStatsMsgIn` (src/steamnetworkingsockets/clientlib/steamnetworkingsockets_udp.cpp:835) without validation. The original bounds check `pIn + cbStatsMsgIn > pPktEnd` (line 841) could overflow if `cbStatsMsgIn` is large, leading to incorrect bounds validation and out-of-bounds memory access. The patch replaces the check with `cbStatsMsgIn > pPktEnd - pIn` to avoid overflow.",0.95,./github/other_context/CVE-2020-6019
60,CVE-2021-28676,CWE-835,c_cpp,"An issue was discovered in Pillow before 8.2.0. For FLI data, FliDecode did not properly check that the block advance was non-zero, potentially leading to an infinite loop on load.",https://github.com/python-pillow/Pillow/commit/bb6c11fb889e6c11b0ee122b828132ee763b5856,"Fix FLI DOS -- CVE-2021-28676\n\n* FliDecode did not properly check that the block advance was\n  non-zero, potentally leading to an infinite loop on load.\n* This dates to the PIL Fork\n* Found with oss-fuzz",1,"[{""func_name"": ""ImagingFliDecode"", ""file_path"": ""src/libImaging/FliDecode.c"", ""func_code"": ""int\nImagingFliDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {\n    UINT8 *ptr;\n    int framesize;\n    int c, chunks, advance;\n    int l, lines;\n    int i, j, x = 0, y, ymax;\n\n    /* If not even the chunk size is present, we'd better leave */\n\n    if (bytes < 4) {\n        return 0;\n    }\n\n    /* We don't decode anything unless we have a full chunk in the\n       input buffer */\n\n    ptr = buf;\n\n    framesize = I32(ptr);\n    if (framesize < I32(ptr)) {\n        return 0;\n    }\n\n    /* Make sure this is a frame chunk.  The Python driver takes\n       case of other chunk types. */\n\n    if (bytes < 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    if (I16(ptr + 4) != 0xF1FA) {\n        state->errcode = IMAGING_CODEC_UNKNOWN;\n        return -1;\n    }\n\n    chunks = I16(ptr + 6);\n    ptr += 16;\n    bytes -= 16;\n\n    /* Process subchunks */\n    for (c = 0; c < chunks; c++) {\n        UINT8 *data;\n        if (bytes < 10) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        data = ptr + 6;\n        switch (I16(ptr + 4)) {\n            case 4:\n            case 11:\n                /* FLI COLOR chunk */\n                break; /* ignored; handled by Python code */\n            case 7:\n                /* FLI SS2 chunk (word delta) */\n                /* OOB ok, we've got 4 bytes min on entry */\n                lines = I16(data);\n                data += 2;\n                for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    int p, packets;\n                    ERR_IF_DATA_OOB(2)\n                    packets = I16(data);\n                    data += 2;\n                    while (packets & 0x8000) {\n                        /* flag word */\n                        if (packets & 0x4000) {\n                            y += 65536 - packets; /* skip lines */\n                            if (y >= state->ysize) {\n                                state->errcode = IMAGING_CODEC_OVERRUN;\n                                return -1;\n                            }\n                            local_buf = (UINT8 *)im->image[y];\n                        } else {\n                            /* store last byte (used if line width is odd) */\n                            local_buf[state->xsize - 1] = (UINT8)packets;\n                        }\n                        ERR_IF_DATA_OOB(2)\n                        packets = I16(data);\n                        data += 2;\n                    }\n                    for (p = x = 0; p < packets; p++) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* pixel skip */\n                        if (data[1] >= 128) {\n                            ERR_IF_DATA_OOB(4)\n                            i = 256 - data[1]; /* run */\n                            if (x + i + i > state->xsize) {\n                                break;\n                            }\n                            for (j = 0; j < i; j++) {\n                                local_buf[x++] = data[2];\n                                local_buf[x++] = data[3];\n                            }\n                            data += 2 + 2;\n                        } else {\n                            i = 2 * (int)data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(local_buf + x, data + 2, i);\n                            data += 2 + i;\n                            x += i;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (l < lines) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 12:\n                /* FLI LC chunk (byte delta) */\n                /* OOB Check ok, we have 4 bytes min here */\n                y = I16(data);\n                ymax = y + I16(data + 2);\n                data += 4;\n                for (; y < ymax && y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    ERR_IF_DATA_OOB(1)\n                    int p, packets = *data++;\n                    for (p = x = 0; p < packets; p++, x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* skip pixels */\n                        if (data[1] & 0x80) {\n                            i = 256 - data[1]; /* run */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(3)\n                            memset(out + x, data[2], i);\n                            data += 3;\n                        } else {\n                            i = data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(out + x, data + 2, i);\n                            data += i + 2;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (y < ymax) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 13:\n                /* FLI BLACK chunk */\n                for (y = 0; y < state->ysize; y++) {\n                    memset(im->image[y], 0, state->xsize);\n                }\n                break;\n            case 15:\n                /* FLI BRUN chunk */\n                /* OOB, ok, we've got 4 bytes min on entry */\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    data += 1; /* ignore packetcount byte */\n                    for (x = 0; x < state->xsize; x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        if (data[0] & 0x80) {\n                            i = 256 - data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            ERR_IF_DATA_OOB(i + 1)\n                            memcpy(out + x, data + 1, i);\n                            data += i + 1;\n                        } else {\n                            i = data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            memset(out + x, data[1], i);\n                            data += 2;\n                        }\n                    }\n                    if (x != state->xsize) {\n                        /* didn't unpack whole line */\n                        state->errcode = IMAGING_CODEC_OVERRUN;\n                        return -1;\n                    }\n                }\n                break;\n            case 16:\n                /* COPY chunk */\n                if (state->xsize > bytes / state->ysize) {\n                    /* not enough data for frame */\n                    return ptr - buf; /* bytes consumed */\n                }\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    memcpy(local_buf, data, state->xsize);\n                    data += state->xsize;\n                }\n                break;\n            case 18:\n                /* PSTAMP chunk */\n                break; /* ignored */\n            default:\n                /* unknown chunk */\n                /* printf(\""unknown FLI/FLC chunk: %d\\n\"", I16(ptr+4)); */\n                state->errcode = IMAGING_CODEC_UNKNOWN;\n                return -1;\n        }\n        advance = I32(ptr);\n        if (advance < 0 || advance > bytes) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        ptr += advance;\n        bytes -= advance;\n    }\n\n    return -1; /* end of frame */\n}"", ""target"": 0}]","[{""func_name"": ""ImagingFliDecode"", ""file_path"": ""src/libImaging/FliDecode.c"", ""func_code"": ""int\nImagingFliDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {\n    UINT8 *ptr;\n    int framesize;\n    int c, chunks, advance;\n    int l, lines;\n    int i, j, x = 0, y, ymax;\n\n    /* If not even the chunk size is present, we'd better leave */\n\n    if (bytes < 4) {\n        return 0;\n    }\n\n    /* We don't decode anything unless we have a full chunk in the\n       input buffer */\n\n    ptr = buf;\n\n    framesize = I32(ptr);\n    if (framesize < I32(ptr)) {\n        return 0;\n    }\n\n    /* Make sure this is a frame chunk.  The Python driver takes\n       case of other chunk types. */\n\n    if (bytes < 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    if (I16(ptr + 4) != 0xF1FA) {\n        state->errcode = IMAGING_CODEC_UNKNOWN;\n        return -1;\n    }\n\n    chunks = I16(ptr + 6);\n    ptr += 16;\n    bytes -= 16;\n\n    /* Process subchunks */\n    for (c = 0; c < chunks; c++) {\n        UINT8 *data;\n        if (bytes < 10) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        data = ptr + 6;\n        switch (I16(ptr + 4)) {\n            case 4:\n            case 11:\n                /* FLI COLOR chunk */\n                break; /* ignored; handled by Python code */\n            case 7:\n                /* FLI SS2 chunk (word delta) */\n                /* OOB ok, we've got 4 bytes min on entry */\n                lines = I16(data);\n                data += 2;\n                for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    int p, packets;\n                    ERR_IF_DATA_OOB(2)\n                    packets = I16(data);\n                    data += 2;\n                    while (packets & 0x8000) {\n                        /* flag word */\n                        if (packets & 0x4000) {\n                            y += 65536 - packets; /* skip lines */\n                            if (y >= state->ysize) {\n                                state->errcode = IMAGING_CODEC_OVERRUN;\n                                return -1;\n                            }\n                            local_buf = (UINT8 *)im->image[y];\n                        } else {\n                            /* store last byte (used if line width is odd) */\n                            local_buf[state->xsize - 1] = (UINT8)packets;\n                        }\n                        ERR_IF_DATA_OOB(2)\n                        packets = I16(data);\n                        data += 2;\n                    }\n                    for (p = x = 0; p < packets; p++) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* pixel skip */\n                        if (data[1] >= 128) {\n                            ERR_IF_DATA_OOB(4)\n                            i = 256 - data[1]; /* run */\n                            if (x + i + i > state->xsize) {\n                                break;\n                            }\n                            for (j = 0; j < i; j++) {\n                                local_buf[x++] = data[2];\n                                local_buf[x++] = data[3];\n                            }\n                            data += 2 + 2;\n                        } else {\n                            i = 2 * (int)data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(local_buf + x, data + 2, i);\n                            data += 2 + i;\n                            x += i;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (l < lines) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 12:\n                /* FLI LC chunk (byte delta) */\n                /* OOB Check ok, we have 4 bytes min here */\n                y = I16(data);\n                ymax = y + I16(data + 2);\n                data += 4;\n                for (; y < ymax && y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    ERR_IF_DATA_OOB(1)\n                    int p, packets = *data++;\n                    for (p = x = 0; p < packets; p++, x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* skip pixels */\n                        if (data[1] & 0x80) {\n                            i = 256 - data[1]; /* run */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(3)\n                            memset(out + x, data[2], i);\n                            data += 3;\n                        } else {\n                            i = data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(out + x, data + 2, i);\n                            data += i + 2;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (y < ymax) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 13:\n                /* FLI BLACK chunk */\n                for (y = 0; y < state->ysize; y++) {\n                    memset(im->image[y], 0, state->xsize);\n                }\n                break;\n            case 15:\n                /* FLI BRUN chunk */\n                /* OOB, ok, we've got 4 bytes min on entry */\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    data += 1; /* ignore packetcount byte */\n                    for (x = 0; x < state->xsize; x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        if (data[0] & 0x80) {\n                            i = 256 - data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            ERR_IF_DATA_OOB(i + 1)\n                            memcpy(out + x, data + 1, i);\n                            data += i + 1;\n                        } else {\n                            i = data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            memset(out + x, data[1], i);\n                            data += 2;\n                        }\n                    }\n                    if (x != state->xsize) {\n                        /* didn't unpack whole line */\n                        state->errcode = IMAGING_CODEC_OVERRUN;\n                        return -1;\n                    }\n                }\n                break;\n            case 16:\n                /* COPY chunk */\n                if (state->xsize > bytes / state->ysize) {\n                    /* not enough data for frame */\n                    return ptr - buf; /* bytes consumed */\n                }\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    memcpy(local_buf, data, state->xsize);\n                    data += state->xsize;\n                }\n                break;\n            case 18:\n                /* PSTAMP chunk */\n                break; /* ignored */\n            default:\n                /* unknown chunk */\n                /* printf(\""unknown FLI/FLC chunk: %d\\n\"", I16(ptr+4)); */\n                state->errcode = IMAGING_CODEC_UNKNOWN;\n                return -1;\n        }\n        advance = I32(ptr);\n        if (advance == 0 ) {\n            // If there's no advance, we're in in infinite loop\n            state->errcode = IMAGING_CODEC_BROKEN;\n            return -1;\n        }\n        if (advance < 0 || advance > bytes) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        ptr += advance;\n        bytes -= advance;\n    }\n\n    return -1; /* end of frame */\n}""}]","{""code"": 1}","[{""source"": ""code_info(file:FliDecode.c, lines:250-260)"", ""result"": ""        ptr += advance;\n        bytes -= advance;\n    }\n\n    return -1; /* end of frame */\n}\n""}]","src/libImaging/FliDecode.c:245-250: 'advance' is read from input via I32(ptr) without checking for zero. When 'advance' is zero, 'ptr += advance' and 'bytes -= advance' (lines 250-260) do not modify 'ptr' or 'bytes', causing an infinite loop. Patch adds a check for 'advance == 0' to prevent this.",0.95,./github/other_context/CVE-2021-28676
61,CVE-2022-23588,CWE-617,c_cpp,"Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that Grappler optimizer would attempt to build a tensor using a reference `dtype`. This would result in a crash due to a `CHECK`-fail in the `Tensor` constructor as reference types are not allowed. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",https://github.com/tensorflow/tensorflow/commit/6b5adc0877de832b2a7c189532dbbbc64622eeb6,"Prevent `CHECK`-fail when building reference tensor.\n\nThe tensor constructor does not allow reference dtypes, as these should not show up explicitly. However, when passed these invalid types instead of building an invalid object the constructor crashes via a `CHECK`-fail. We have a static builder that properly handles this case but is not applicable given current usage.\n\nInstead, before calling the constructor, we can check that the dtype is not a reference type and return an error otherwise, given that the dtype is user controlled so malicious users can trigger denial of service.\n\nPiperOrigin-RevId: 409662503\nChange-Id: I5892f831fde7f276cd7ab34519cf6b8061c71a59",1,"[{""func_name"": ""CreateConstantTensorAttrValue"", ""file_path"": ""tensorflow/core/grappler/optimizers/constant_folding.cc"", ""func_code"": ""Status CreateConstantTensorAttrValue(DataType type, double value,\n                                     const TensorShapeProto& shape,\n                                     AttrValue* attr_tensor) {\n  TensorProto* t = attr_tensor->mutable_tensor();\n  t->set_dtype(type);\n  *t->mutable_tensor_shape() = shape;\n  switch (type) {\n    case DT_HALF:\n      t->add_half_val(\n          Eigen::numext::bit_cast<uint16>(static_cast<Eigen::half>(value)));\n      break;\n    case DT_BFLOAT16:\n      t->add_half_val(\n          Eigen::numext::bit_cast<uint16>(static_cast<bfloat16>(value)));\n      break;\n      SET_TENSOR_VAL_CASE(DT_FLOAT, float, float);\n      SET_TENSOR_VAL_CASE(DT_DOUBLE, double, double);\n      SET_TENSOR_VAL_CASE(DT_INT64, int64_t, int64);\n      SET_TENSOR_VAL_CASE(DT_UINT64, int64_t, int64);\n      SET_TENSOR_VAL_CASE(DT_INT32, int32, int);\n      SET_TENSOR_VAL_CASE(DT_UINT32, int32, int);\n      SET_TENSOR_VAL_CASE(DT_INT16, int32, int);\n      SET_TENSOR_VAL_CASE(DT_UINT16, int32, int);\n      SET_TENSOR_VAL_CASE(DT_INT8, int32, int);\n      SET_TENSOR_VAL_CASE(DT_UINT8, int32, int);\n      SET_TENSOR_VAL_CASE(DT_QINT32, int32, int);\n      SET_TENSOR_VAL_CASE(DT_QINT16, int32, int);\n      SET_TENSOR_VAL_CASE(DT_QUINT16, int32, int);\n      SET_TENSOR_VAL_CASE(DT_QINT8, int32, int);\n      SET_TENSOR_VAL_CASE(DT_QUINT8, int32, int);\n      SET_TENSOR_VAL_CASE(DT_BOOL, bool, bool);\n    default:\n      return errors::InvalidArgument(\n          \""Unsupported type in CreateConstantTensorAttrValue: \"",\n          DataTypeString(type));\n  }\n  return Status::OK();\n}\n\n#undef SET_TENSOR_CAL_CASE\n\nDataType GetDataTypeFromNodeOrProps(const NodeDef& node,\n                                    const GraphProperties& properties) {\n  DataType dtype = DT_INVALID;\n  if (node.attr().count(\""T\"") == 1) {\n    dtype = node.attr().at(\""T\"").type();\n  } else if (node.attr().count(\""dtype\"") == 1) {\n    dtype = node.attr().at(\""dtype\"").type();\n  } else if (IsLogicalOr(node) || IsLogicalAnd(node)) {\n    dtype = DT_BOOL;\n  } else {\n    auto output_props = properties.GetOutputProperties(node.name());\n    if (!output_props.empty()) {\n      dtype = output_props[0].dtype();\n    }\n  }\n  return dtype;\n}\n\n// Checks whether the shape of the const input of the Mul op is valid to perform\n// the MulConvPushDown optimization.\nbool IsValidConstShapeForMulConvPushDown(\n    const string& data_format, const TensorShapeProto& filter_shape,\n    const TensorShapeProto& mul_const_input_shape) {\n  // If the const is a scalar, or it has fewer or same number of dimensions\n  // than the filter and it only has single element, the optimization should\n  // work.\n  if (mul_const_input_shape.dim_size() <=\n          static_cast<int>(data_format.size()) &&\n      TensorShape(mul_const_input_shape).num_elements() == 1) {\n    return true;\n  }\n\n  // Otherwise, check the eligibility according to data format.\n  if (data_format == \""NHWC\"" || data_format == \""NDHWC\"") {\n    TensorShapeProto new_filter_shape;\n    if (!ShapeAfterBroadcast(filter_shape, mul_const_input_shape,\n                             &new_filter_shape)) {\n      return false;\n    }\n    if (!ShapesSymbolicallyEqual(filter_shape, new_filter_shape)) {\n      return false;\n    }\n    // Only the last dimension could be larger than one, since broadcasting over\n    // the last dimension (the output channel) will result in invalid filter.\n    for (int i = 0; i < mul_const_input_shape.dim_size() - 1; ++i) {\n      if (mul_const_input_shape.dim(i).size() > 1) return false;\n    }\n    return true;\n  } else if (data_format == \""NCHW\"" || data_format == \""NCDHW\"") {\n    // TODO(laigd): support NCHW and NCDHW (b/111214513).\n    return false;\n  }\n  return false;\n}\n\n}  // namespace\n\n// static\nStatus ConstantFolding::CreateNodeDef(const string& name,\n                                      const TensorValue& tensor, NodeDef* node,\n                                      size_t original_size) {\n  node->set_name(name);\n  node->set_op(\""Const\"");\n\n  AttrValue attr_type;\n  attr_type.set_type(tensor->dtype());\n  node->mutable_attr()->insert({\""dtype\"", attr_type});\n\n  AttrValue attr_tensor;\n  TensorProto* t = attr_tensor.mutable_tensor();\n  bool optimized = false;\n  size_t encoded_size;\n  // Use the packed representation whenever possible to avoid generating large\n  // graphdefs. Moreover, avoid repeating the last values if they're equal.\n  if (tensor->NumElements() > 4) {\n#define POPULATE_TENSOR_PROTO(tensor, t, TYPE, FIELDTYPE)                      \\\n  {                                                                            \\\n    const auto* val_ptr = tensor->flat<TYPE>().data();                         \\\n    auto last = *val_ptr;                                                      \\\n    int64_t last_index = 0;                                                    \\\n    for (int64_t i = 0; i < tensor->NumElements(); ++i) {                      \\\n      TYPE cur = *val_ptr++;                                                   \\\n      if (PackedValuesNotEqual(cur, last)) {                                   \\\n        last = cur;                                                            \\\n        last_index = i;                                                        \\\n      }                                                                        \\\n    }                                                                          \\\n    encoded_size = (last_index + 1) * sizeof(FIELDTYPE);                       \\\n    if (encoded_size < kint32max) {                                            \\\n      optimized = true;                                                        \\\n      t->mutable_##FIELDTYPE##_val()->Reserve(last_index + 1);                 \\\n      const auto* src_ptr = tensor->flat<TYPE>().data();                       \\\n      auto* dst_ptr =                                                          \\\n          t->mutable_##FIELDTYPE##_val()->AddNAlreadyReserved(last_index + 1); \\\n      std::copy(src_ptr, src_ptr + last_index + 1, dst_ptr);                   \\\n    }                                                                          \\\n  }                                                                            \\\n  break\n\n    switch (tensor->dtype()) {\n      case DT_FLOAT:\n        POPULATE_TENSOR_PROTO(tensor, t, float, float);\n      case DT_DOUBLE:\n        POPULATE_TENSOR_PROTO(tensor, t, double, double);\n      case DT_INT64:\n        POPULATE_TENSOR_PROTO(tensor, t, int64_t, int64);\n      case DT_UINT64:\n        POPULATE_TENSOR_PROTO(tensor, t, uint64, uint64);\n      case DT_INT32:\n        POPULATE_TENSOR_PROTO(tensor, t, int32_t, int);\n      case DT_UINT32:\n        POPULATE_TENSOR_PROTO(tensor, t, uint32, uint32);\n      case DT_INT16:\n        POPULATE_TENSOR_PROTO(tensor, t, int16_t, int);\n      case DT_UINT16:\n        POPULATE_TENSOR_PROTO(tensor, t, uint16, int);\n      case DT_INT8:\n        POPULATE_TENSOR_PROTO(tensor, t, int8_t, int);\n      case DT_UINT8:\n        POPULATE_TENSOR_PROTO(tensor, t, uint8, int);\n      case DT_BOOL:\n        POPULATE_TENSOR_PROTO(tensor, t, bool, bool);\n      default:\n        /* Do nothing. */\n        break;\n    }\n  }\n  if (optimized) {\n    // Also specify type and shape.\n    t->set_dtype(tensor->dtype());\n    tensor->shape().AsProto(t->mutable_tensor_shape());\n  } else {\n    // DT_HALF, DT_BFLOAT16, DT_QINT32, DT_QINT16, DT_QUINT16, DT_QINT8,\n    // DT_QUINT8\n    tensor->AsProtoTensorContent(t);\n    encoded_size = t->tensor_content().size();\n  }\n  node->mutable_attr()->insert({\""value\"", attr_tensor});\n\n  if (encoded_size > original_size && encoded_size >= kMaxConstantSize) {\n    return errors::InvalidArgument(\n        strings::StrCat(\""Can't fold \"", name, \"", its size would be too large (\"",\n                        encoded_size, \"" >= \"", kMaxConstantSize, \"" bytes)\""));\n  }\n  return Status::OK();\n}\n\nStatus ConstantFolding::EvaluateNode(const NodeDef& node,\n                                     const TensorVector& inputs,\n                                     TensorVector* output) const {\n  return ::tensorflow::grappler::EvaluateNode(node, inputs, cpu_device_,\n                                              resource_mgr_.get(), output);\n}\n\nStatus ConstantFolding::EvaluateOneFoldable(const NodeDef& node,\n                                            std::vector<NodeDef>* outputs,\n                                            bool* result_too_large) {\n  TensorVector inputs;\n  TensorVector output_tensors;\n  auto inputs_cleanup = gtl::MakeCleanup([&inputs, &output_tensors] {\n    for (const auto& input : inputs) {\n      delete input.tensor;\n    }\n    for (const auto& output : output_tensors) {\n      if (output.tensor) {\n        delete output.tensor;\n      }\n    }\n  });\n\n  size_t total_inputs_size = 0;\n  for (const auto& input : node.input()) {\n    const TensorId input_tensor = ParseTensorName(input);\n    if (input_tensor.index() < 0) {\n      // Control dependency\n      break;\n    }\n    const NodeDef* input_node = node_map_->GetNode(input);\n    if (!IsReallyConstant(*input_node)) {\n      return Status(error::INVALID_ARGUMENT,\n                    strings::StrCat(\""Can't fold \"", node.name(), \"", its \"", input,\n                                    \"" isn't constant\""));\n    }\n    TF_RETURN_IF_ERROR(CheckAttrExists(*input_node, \""value\""));\n    const TensorProto& raw_val = input_node->attr().at(\""value\"").tensor();\n    if (raw_val.dtype() == DT_INVALID) {\n      return Status(\n          error::INVALID_ARGUMENT,\n          strings::StrCat(\""A tensor in the input node, with TensorId of \"",\n                          input_tensor.ToString(),\n                          \"" has a dtype of DT_INVALID.\""));\n    }\n    Tensor* value = new Tensor(raw_val.dtype(), raw_val.tensor_shape());\n    if (!value->FromProto(raw_val)) {\n      delete (value);\n      return errors::InvalidArgument(\""Unable to make Tensor from proto for \"",\n                                     node.name(), \"" with shape \"",\n                                     raw_val.tensor_shape().DebugString());\n    }\n    inputs.emplace_back(value);\n    total_inputs_size += value->TotalBytes();\n  }\n\n  TF_RETURN_IF_ERROR(EvaluateNode(node, inputs, &output_tensors));\n  if (output_tensors.empty()) {\n    return Status(error::INVALID_ARGUMENT, \""Expected at least one output.\"");\n  }\n\n  outputs->resize(output_tensors.size());\n  for (size_t i = 0; i < output_tensors.size(); i++) {\n    string node_name = OptimizedNodeName(node, \""-folded\"");\n    if (output_tensors.size() > 1) {\n      node_name = strings::StrCat(node_name, \""-\"", i);\n    }\n    if (output_tensors[i].tensor) {\n      Status s = CreateNodeDef(node_name, output_tensors[i], &outputs->at(i),\n                               total_inputs_size);\n      if (!s.ok()) {\n        *result_too_large = true;\n        return s;\n      }\n    } else {\n      // Create an empty NodeDef to identify dead outputs (e.g. the output of a\n      // switch that's not selected by the switch predicate).\n      outputs->at(i) = NodeDef();\n    }\n  }\n  return Status::OK();\n}\n\nStatus ConstantFolding::FoldMergeNode(NodeDef* node, GraphDef* output_graph) {\n  // Merge nodes are special, in the sense that they execute as soon as one of\n  // their input is ready. We can therefore fold a merge node iff it has at\n  // least one constant input without control dependency.\n  // We still need to ensure that the nodes in the fanin of the merge node are\n  // scheduled. We'll therefore add a control dependency from the merge node\n  // to the folded constant. We end up with:\n  //  * the merge node and its inputs are preserved as is\n  //  * a new constant node C1, driven by the merge node through a control\n  //  dependency, initialized to the value of the folded input\n  //  * a new constant node C2, driven by the merge node through a control\n  //  dependency, initialized to the index of the folded input\n  //  * the fanout of the merge nodes is rewired to be driven by either C1 or\n  //  C2.\n  for (int input_index = 0; input_index < node->input_size(); ++input_index) {\n    const auto& input = node->input(input_index);\n    if (IsControlInput(input)) {\n      // Try the next input.\n      continue;\n    }\n    NodeDef* input_node = node_map_->GetNode(input);\n    if (!IsReallyConstant(*input_node)) {\n      continue;\n    }\n    bool valid_input = true;\n    for (const string& fanin_of_input : input_node->input()) {\n      if (IsControlInput(fanin_of_input)) {\n        valid_input = false;\n        break;\n      }\n    }\n    if (!valid_input) {\n      // Try the next input\n      continue;\n    }\n\n    string const_out_name = OptimizedNodeName(*node, \""_const\"");\n    string const_index_name = OptimizedNodeName(*node, \""_index\"");\n    if (node_map_->GetNode(const_out_name) ||\n        node_map_->GetNode(const_index_name)) {\n      // Intended name already exists.\n      return errors::AlreadyExists(\n          strings::StrCat(const_out_name, \"" or \"", const_index_name,\n                          \"" already present in the graph\""));\n    }\n\n    NodeDef* const_out = output_graph->add_node();\n    *const_out = *input_node;\n    const_out->set_name(const_out_name);\n    const_out->set_device(node->device());\n    *const_out->add_input() = AsControlDependency(*node);\n    node_map_->AddNode(const_out->name(), const_out);\n    node_map_->AddOutput(node->name(), const_out->name());\n\n    NodeDef* const_index = output_graph->add_node();\n    const_index->set_op(\""Const\"");\n    Tensor index(DT_INT32, TensorShape({}));\n    index.flat<int32>()(0) = input_index;\n    (*const_index->mutable_attr())[\""dtype\""].set_type(DT_INT32);\n    index.AsProtoTensorContent(\n        (*const_index->mutable_attr())[\""value\""].mutable_tensor());\n    const_index->set_name(const_index_name);\n    const_index->set_device(node->device());\n    *const_index->add_input() = AsControlDependency(*node);\n    node_map_->AddNode(const_index->name(), const_index);\n    node_map_->AddOutput(node->name(), const_index->name());\n\n    // We make a copy because we mutate the nodes.\n    auto outputs = node_map_->GetOutputs(node->name());\n    for (NodeDef* output : outputs) {\n      for (int i = 0; i < output->input_size(); i++) {\n        int port;\n        string node_name = ParseNodeName(output->input(i), &port);\n        if (node_name == node->name()) {\n          if (port == 0) {\n            *output->mutable_input(i) = const_out->name();\n            node_map_->AddOutput(const_out->name(), output->name());\n          } else if (port == 1) {\n            *output->mutable_input(i) = const_index->name();\n            node_map_->AddOutput(const_index->name(), output->name());\n          } else {\n            // This is a control dependency (or an invalid edge since the\n            // merge node has only 2 outputs): preserve them.\n          }\n        }\n      }\n    }\n    return Status::OK();\n  }\n  return Status::OK();\n}\n\nStatus ConstantFolding::FoldNode(NodeDef* node, GraphDef* output_graph,\n                                 bool* result_too_large) {\n  *result_too_large = false;\n  if (IsMerge(*node)) {\n    return FoldMergeNode(node, output_graph);\n  }\n\n  std::vector<NodeDef> const_nodes;\n  TF_RETURN_IF_ERROR(\n      EvaluateOneFoldable(*node, &const_nodes, result_too_large));\n  VLOG(2) << \""Folded node: \"" << SummarizeNodeDef(*node);\n\n  NodeDef* constant_output = nullptr;\n  for (int i = 0, end = const_nodes.size(); i < end; i++) {\n    NodeDef* const_node = &const_nodes[i];\n    VLOG(3) << \""Generated constant node: \"" << SummarizeNodeDef(*const_node);\n    if (const_node->name().empty()) {\n      // Dead output: we can't create a constant to encode its value, so we'll\n      // just skip it. We'll preserve the edges that originate from that\n      // output below to preserve the overall behavior of the graph wrt dead\n      // edges.\n      continue;\n    }\n\n    // Returns `true` iff `const_node` already has control input named `input`.\n    const auto is_duplicate_control_input = [&](const string& input) -> bool {\n      auto it = absl::c_find(const_node->input(), input);\n      return it != const_node->input().end();\n    };\n\n    // Forward control dependencies.\n    for (const string& input : node->input()) {\n      // Forward control dependencies from folded node.\n      if (IsControlInput(input)) {\n        if (!is_duplicate_control_input(input)) {\n          *const_node->add_input() = input;\n        }\n      }\n\n      // Forward control dependencies from constant inputs to folded node.\n      if (!IsControlInput(input)) {\n        NodeDef* input_node = node_map_->GetNode(input);\n        for (const string& fanin_of_input : input_node->input()) {\n          if (!is_duplicate_control_input(fanin_of_input)) {\n            *const_node->add_input() = fanin_of_input;\n          }\n        }\n      }\n    }\n\n    // We rewrite the existing node if it only has a single output, and\n    // create new nodes otherwise.\n    if (const_nodes.size() == 1) {\n      node->set_op(\""Const\"");\n      // Note we need to clear the inputs in NodeMap before we clear the inputs\n      // in the node, otherwise NodeMap would see empty inputs and effectively\n      // does nothing.\n      node_map_->RemoveInputs(node->name());\n      node->clear_input();\n      *node->mutable_input() = const_node->input();\n      for (const auto& input : node->input()) {\n        node_map_->AddOutput(NodeName(input), node->name());\n      }\n      *node->mutable_attr() = const_node->attr();\n      break;\n    } else {\n      if (node_map_->GetNode(const_node->name())) {\n        // Intended name already exists.\n        return errors::AlreadyExists(strings::StrCat(\n            const_node->name(), \"" already present in the graph\""));\n      }\n      NodeDef* added_node = output_graph->add_node();\n      *added_node = *const_node;\n      added_node->set_device(node->device());\n      node_map_->AddNode(added_node->name(), added_node);\n      for (const auto& input : added_node->input()) {\n        node_map_->AddOutput(NodeName(input), added_node->name());\n      }\n      // All the constant nodes encoding output values have the same control\n      // dependencies (since these are the control dependencies of the node\n      // we're trying to fold). Record one such constant node.\n      constant_output = added_node;\n    }\n  }\n\n  if (const_nodes.size() > 1) {\n    // We make a copy because we mutate the nodes.\n    auto outputs = node_map_->GetOutputs(node->name());\n    for (NodeDef* output : outputs) {\n      for (int i = 0; i < output->input_size(); i++) {\n        int port;\n        string node_name = ParseNodeName(output->input(i), &port);\n        if (node_name == node->name()) {\n          if (port < 0) {\n            // Propagate control dependencies if possible. If not, we'll just\n            // preserve the existing control dependencies.\n            if (constant_output != nullptr) {\n              node_map_->UpdateInput(node_name, NodeName(output->input(i)),\n                                     constant_output->name());\n              *output->mutable_input(i) = AsControlDependency(*constant_output);\n            }\n          } else if (port < static_cast<int>(const_nodes.size()) &&\n                     !const_nodes[port].name().empty()) {\n            // Replace alive outputs with the corresponding constant.\n            node_map_->UpdateInput(output->name(), NodeName(output->input(i)),\n                                   const_nodes[port].name());\n            *output->mutable_input(i) = const_nodes[port].name();\n          } else {\n            // Leave this edge alone.\n            VLOG(3) << \""Preserving edge from \"" << node->name() << \"":\"" << port\n                    << \""[\"" << node->op() << \""] to \"" << output->name() << \"":\""\n                    << i << \""[\"" << output->op() << \""]\"";\n          }\n        }\n      }\n    }\n    outputs = node_map_->GetOutputs(node->name());\n    if (outputs.empty() && has_fetch_ &&\n        nodes_to_preserve_.find(node->name()) == nodes_to_preserve_.end()) {\n      node_map_->RemoveInputs(node->name());\n      node->clear_input();\n    }\n  }\n  return Status::OK();\n}\n\nStatus ConstantFolding::FoldGraph(\n    const GraphProperties& properties, GraphDef* optimized_graph,\n    absl::flat_hash_set<string>* nodes_to_not_simplify) {\n  // We build a new optimized_graph by inserting the folded nodes into it, then\n  // copy other nodes that might be needed at the end of this function.\n  absl::flat_hash_set<string> processed_nodes;\n  std::deque<NodeDef*> queue;\n  for (int i = 0; i < graph_->node_size(); i++) {\n    const NodeDef& node = graph_->node(i);\n    if (IsFoldable(node, &properties) &&\n        !nodes_to_not_simplify->count(node.name())) {\n      queue.push_back(graph_->mutable_node(i));\n    }\n  }\n  while (!queue.empty()) {\n    NodeDef* node = queue.front();\n    queue.pop_front();\n    if (processed_nodes.count(node->name())) {\n      continue;\n    }\n    // We need to record a copy of output nodes before FoldNode() modifies it.\n    // We also need to ensure that the fanout is sorted deterministically.\n    std::vector<NodeDef*> fanout =\n        node_map_->GetOutputsOrderedByNodeName(node->name());\n    bool result_too_large = false;\n    Status s = FoldNode(node, optimized_graph, &result_too_large);\n    processed_nodes.insert(node->name());\n    if (!s.ok()) {\n      VLOG(1) << \""Failed to fold node \"" << node->DebugString()\n              << \""\\nError message: \"" << s;\n      if (result_too_large) {\n        nodes_to_not_simplify->emplace(node->name());\n      }\n    } else {\n      for (auto& fanout_node : fanout) {\n        if (IsFoldable(*fanout_node, &properties) &&\n            !nodes_to_not_simplify->count(fanout_node->name())) {\n          queue.push_back(fanout_node);\n        }\n      }\n    }\n  }\n\n  // Delete the newly created nodes that don't feed anything.\n  std::vector<int> nodes_to_delete;\n  for (int i = 0; i < optimized_graph->node_size(); i++) {\n    const auto& fanout = node_map_->GetOutputs(optimized_graph->node(i).name());\n    if (fanout.empty()) nodes_to_delete.push_back(i);\n  }\n  EraseNodesFromGraph(std::move(nodes_to_delete), optimized_graph);\n\n  for (int i = 0; i < graph_->node_size(); ++i) {\n    NodeDef* node = graph_->mutable_node(i);\n    // If no fetch nodes is provided, we conservatively\n    // move all nodes in the original graph to the output, in case users need\n    // to fetch their values.\n    const auto& fanout = node_map_->GetOutputs(node->name());\n    if (!fanout.empty() || !has_fetch_ ||\n        nodes_to_preserve_.find(node->name()) != nodes_to_preserve_.end()) {\n      *(optimized_graph->add_node()) = std::move(*node);\n    }\n  }\n  return Status::OK();\n}\n\nStatus ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return errors::Internal(\""Node \"", node.name(), \"" is not a Reshape node\"");\n  }\n  if (2 > node.input_size()) {\n    return errors::Internal(\""Node \"", node.name(),\n                            \"" must have at most 2 inputs but has \"",\n                            node.input_size());\n  }\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return errors::Internal(\""Node \"", node.name(), \"" has shape \"",\n                            new_shape->DebugString(),\n                            \"" which is not a constant\"");\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return errors::Internal(\""Could not evaluate node \"", node.name());\n  }\n  if (outputs.size() != 1) {\n    return errors::Internal(\""Node \"", node.name(),\n                            \"" must have exactly 1 output but has \"",\n                            outputs.size());\n  }\n\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return errors::Internal(\""Node \"", node.name(), \"" has no properties\"");\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return errors::Internal(\""Node \"", node.name(), \"" has property \"",\n                            prop.DebugString(), \"" with invalid dtype\"");\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return errors::Internal(\""Node \"", node.name(), \"" has property \"",\n                            prop.DebugString(), \"" with shape \"",\n                            shape.DebugString(), \"" which is not fully defined\"");\n  }\n\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n  }\n\n  if (!shape.IsCompatibleWith(new_dims)) {\n    return errors::Internal(\""Expected shape \"", shape.DebugString(),\n                            \""to be compatible with \"", new_dims.DebugString());\n  }\n\n  return Status::OK();\n}\n\n#define IS_VALUE_CASE(DTYPE, VALUE)                   \\\n  case DTYPE:                                         \\\n    return AllValuesAre<EnumToDataType<DTYPE>::Type>( \\\n        node.attr().at(\""value\"").tensor(), EnumToDataType<DTYPE>::Type(VALUE))\n\n#define IS_ONES_CASE(TYPE) IS_VALUE_CASE(TYPE, 1)\n#define IS_ZEROS_CASE(TYPE) IS_VALUE_CASE(TYPE, 0)\n\nbool ConstantFolding::IsOnes(const NodeDef& node) const {\n  if (feed_nodes_.find(node.name()) != feed_nodes_.end()) {\n    return false;\n  }\n  if (IsOnesLike(node)) return true;\n  if (IsZerosLike(node)) return false;\n  if (node.op() == \""Fill\"") {\n    NodeDef* values = node_map_->GetNode(NodeName(node.input(1)));\n    return values != nullptr && IsOnes(*values);\n  }\n  if (node.op() != \""Const\"") return false;\n  if (node.attr().count(\""dtype\"") == 0) return false;\n  const auto dtype = node.attr().at(\""dtype\"").type();\n  switch (dtype) {\n    IS_ONES_CASE(DT_BOOL);\n    IS_ONES_CASE(DT_HALF);\n    IS_ONES_CASE(DT_BFLOAT16);\n    IS_ONES_CASE(DT_FLOAT);\n    IS_ONES_CASE(DT_DOUBLE);\n    IS_ONES_CASE(DT_COMPLEX64);\n    IS_ONES_CASE(DT_COMPLEX128);\n    IS_ONES_CASE(DT_UINT8);\n    IS_ONES_CASE(DT_INT8);\n    IS_ONES_CASE(DT_UINT16);\n    IS_ONES_CASE(DT_INT16);\n    IS_ONES_CASE(DT_INT32);\n    IS_ONES_CASE(DT_INT64);\n    IS_ONES_CASE(DT_QINT32);\n    IS_ONES_CASE(DT_QINT16);\n    IS_ONES_CASE(DT_QUINT16);\n    IS_ONES_CASE(DT_QINT8);\n    IS_ONES_CASE(DT_QUINT8);\n    default:\n      VLOG(1) << \""Unsupported type \"" << DataTypeString(dtype);\n      return false;\n  }\n  return false;\n}"", ""target"": 0}]","[{""func_name"": ""CreateConstantTensorAttrValue"", ""file_path"": ""tensorflow/core/grappler/optimizers/constant_folding.cc"", ""func_code"": ""Status CreateConstantTensorAttrValue(DataType type, double value,\n                                     const TensorShapeProto& shape,\n                                     AttrValue* attr_tensor) {\n  TensorProto* t = attr_tensor->mutable_tensor();\n  t->set_dtype(type);\n  *t->mutable_tensor_shape() = shape;\n  switch (type) {\n    case DT_HALF:\n      t->add_half_val(\n          Eigen::numext::bit_cast<uint16>(static_cast<Eigen::half>(value)));\n      break;\n    case DT_BFLOAT16:\n      t->add_half_val(\n          Eigen::numext::bit_cast<uint16>(static_cast<bfloat16>(value)));\n      break;\n      SET_TENSOR_VAL_CASE(DT_FLOAT, float, float);\n      SET_TENSOR_VAL_CASE(DT_DOUBLE, double, double);\n      SET_TENSOR_VAL_CASE(DT_INT64, int64_t, int64);\n      SET_TENSOR_VAL_CASE(DT_UINT64, int64_t, int64);\n      SET_TENSOR_VAL_CASE(DT_INT32, int32, int);\n      SET_TENSOR_VAL_CASE(DT_UINT32, int32, int);\n      SET_TENSOR_VAL_CASE(DT_INT16, int32, int);\n      SET_TENSOR_VAL_CASE(DT_UINT16, int32, int);\n      SET_TENSOR_VAL_CASE(DT_INT8, int32, int);\n      SET_TENSOR_VAL_CASE(DT_UINT8, int32, int);\n      SET_TENSOR_VAL_CASE(DT_QINT32, int32, int);\n      SET_TENSOR_VAL_CASE(DT_QINT16, int32, int);\n      SET_TENSOR_VAL_CASE(DT_QUINT16, int32, int);\n      SET_TENSOR_VAL_CASE(DT_QINT8, int32, int);\n      SET_TENSOR_VAL_CASE(DT_QUINT8, int32, int);\n      SET_TENSOR_VAL_CASE(DT_BOOL, bool, bool);\n    default:\n      return errors::InvalidArgument(\n          \""Unsupported type in CreateConstantTensorAttrValue: \"",\n          DataTypeString(type));\n  }\n  return Status::OK();\n}\n\n#undef SET_TENSOR_CAL_CASE\n\nDataType GetDataTypeFromNodeOrProps(const NodeDef& node,\n                                    const GraphProperties& properties) {\n  DataType dtype = DT_INVALID;\n  if (node.attr().count(\""T\"") == 1) {\n    dtype = node.attr().at(\""T\"").type();\n  } else if (node.attr().count(\""dtype\"") == 1) {\n    dtype = node.attr().at(\""dtype\"").type();\n  } else if (IsLogicalOr(node) || IsLogicalAnd(node)) {\n    dtype = DT_BOOL;\n  } else {\n    auto output_props = properties.GetOutputProperties(node.name());\n    if (!output_props.empty()) {\n      dtype = output_props[0].dtype();\n    }\n  }\n  return dtype;\n}\n\n// Checks whether the shape of the const input of the Mul op is valid to perform\n// the MulConvPushDown optimization.\nbool IsValidConstShapeForMulConvPushDown(\n    const string& data_format, const TensorShapeProto& filter_shape,\n    const TensorShapeProto& mul_const_input_shape) {\n  // If the const is a scalar, or it has fewer or same number of dimensions\n  // than the filter and it only has single element, the optimization should\n  // work.\n  if (mul_const_input_shape.dim_size() <=\n          static_cast<int>(data_format.size()) &&\n      TensorShape(mul_const_input_shape).num_elements() == 1) {\n    return true;\n  }\n\n  // Otherwise, check the eligibility according to data format.\n  if (data_format == \""NHWC\"" || data_format == \""NDHWC\"") {\n    TensorShapeProto new_filter_shape;\n    if (!ShapeAfterBroadcast(filter_shape, mul_const_input_shape,\n                             &new_filter_shape)) {\n      return false;\n    }\n    if (!ShapesSymbolicallyEqual(filter_shape, new_filter_shape)) {\n      return false;\n    }\n    // Only the last dimension could be larger than one, since broadcasting over\n    // the last dimension (the output channel) will result in invalid filter.\n    for (int i = 0; i < mul_const_input_shape.dim_size() - 1; ++i) {\n      if (mul_const_input_shape.dim(i).size() > 1) return false;\n    }\n    return true;\n  } else if (data_format == \""NCHW\"" || data_format == \""NCDHW\"") {\n    // TODO(laigd): support NCHW and NCDHW (b/111214513).\n    return false;\n  }\n  return false;\n}\n\n}  // namespace\n\n// static\nStatus ConstantFolding::CreateNodeDef(const string& name,\n                                      const TensorValue& tensor, NodeDef* node,\n                                      size_t original_size) {\n  node->set_name(name);\n  node->set_op(\""Const\"");\n\n  AttrValue attr_type;\n  attr_type.set_type(tensor->dtype());\n  node->mutable_attr()->insert({\""dtype\"", attr_type});\n\n  AttrValue attr_tensor;\n  TensorProto* t = attr_tensor.mutable_tensor();\n  bool optimized = false;\n  size_t encoded_size;\n  // Use the packed representation whenever possible to avoid generating large\n  // graphdefs. Moreover, avoid repeating the last values if they're equal.\n  if (tensor->NumElements() > 4) {\n#define POPULATE_TENSOR_PROTO(tensor, t, TYPE, FIELDTYPE)                      \\\n  {                                                                            \\\n    const auto* val_ptr = tensor->flat<TYPE>().data();                         \\\n    auto last = *val_ptr;                                                      \\\n    int64_t last_index = 0;                                                    \\\n    for (int64_t i = 0; i < tensor->NumElements(); ++i) {                      \\\n      TYPE cur = *val_ptr++;                                                   \\\n      if (PackedValuesNotEqual(cur, last)) {                                   \\\n        last = cur;                                                            \\\n        last_index = i;                                                        \\\n      }                                                                        \\\n    }                                                                          \\\n    encoded_size = (last_index + 1) * sizeof(FIELDTYPE);                       \\\n    if (encoded_size < kint32max) {                                            \\\n      optimized = true;                                                        \\\n      t->mutable_##FIELDTYPE##_val()->Reserve(last_index + 1);                 \\\n      const auto* src_ptr = tensor->flat<TYPE>().data();                       \\\n      auto* dst_ptr =                                                          \\\n          t->mutable_##FIELDTYPE##_val()->AddNAlreadyReserved(last_index + 1); \\\n      std::copy(src_ptr, src_ptr + last_index + 1, dst_ptr);                   \\\n    }                                                                          \\\n  }                                                                            \\\n  break\n\n    switch (tensor->dtype()) {\n      case DT_FLOAT:\n        POPULATE_TENSOR_PROTO(tensor, t, float, float);\n      case DT_DOUBLE:\n        POPULATE_TENSOR_PROTO(tensor, t, double, double);\n      case DT_INT64:\n        POPULATE_TENSOR_PROTO(tensor, t, int64_t, int64);\n      case DT_UINT64:\n        POPULATE_TENSOR_PROTO(tensor, t, uint64, uint64);\n      case DT_INT32:\n        POPULATE_TENSOR_PROTO(tensor, t, int32_t, int);\n      case DT_UINT32:\n        POPULATE_TENSOR_PROTO(tensor, t, uint32, uint32);\n      case DT_INT16:\n        POPULATE_TENSOR_PROTO(tensor, t, int16_t, int);\n      case DT_UINT16:\n        POPULATE_TENSOR_PROTO(tensor, t, uint16, int);\n      case DT_INT8:\n        POPULATE_TENSOR_PROTO(tensor, t, int8_t, int);\n      case DT_UINT8:\n        POPULATE_TENSOR_PROTO(tensor, t, uint8, int);\n      case DT_BOOL:\n        POPULATE_TENSOR_PROTO(tensor, t, bool, bool);\n      default:\n        /* Do nothing. */\n        break;\n    }\n  }\n  if (optimized) {\n    // Also specify type and shape.\n    t->set_dtype(tensor->dtype());\n    tensor->shape().AsProto(t->mutable_tensor_shape());\n  } else {\n    // DT_HALF, DT_BFLOAT16, DT_QINT32, DT_QINT16, DT_QUINT16, DT_QINT8,\n    // DT_QUINT8\n    tensor->AsProtoTensorContent(t);\n    encoded_size = t->tensor_content().size();\n  }\n  node->mutable_attr()->insert({\""value\"", attr_tensor});\n\n  if (encoded_size > original_size && encoded_size >= kMaxConstantSize) {\n    return errors::InvalidArgument(\n        strings::StrCat(\""Can't fold \"", name, \"", its size would be too large (\"",\n                        encoded_size, \"" >= \"", kMaxConstantSize, \"" bytes)\""));\n  }\n  return Status::OK();\n}\n\nStatus ConstantFolding::EvaluateNode(const NodeDef& node,\n                                     const TensorVector& inputs,\n                                     TensorVector* output) const {\n  return ::tensorflow::grappler::EvaluateNode(node, inputs, cpu_device_,\n                                              resource_mgr_.get(), output);\n}\n\nStatus ConstantFolding::EvaluateOneFoldable(const NodeDef& node,\n                                            std::vector<NodeDef>* outputs,\n                                            bool* result_too_large) {\n  TensorVector inputs;\n  TensorVector output_tensors;\n  auto inputs_cleanup = gtl::MakeCleanup([&inputs, &output_tensors] {\n    for (const auto& input : inputs) {\n      delete input.tensor;\n    }\n    for (const auto& output : output_tensors) {\n      if (output.tensor) {\n        delete output.tensor;\n      }\n    }\n  });\n\n  size_t total_inputs_size = 0;\n  for (const auto& input : node.input()) {\n    const TensorId input_tensor = ParseTensorName(input);\n    if (input_tensor.index() < 0) {\n      // Control dependency\n      break;\n    }\n    const NodeDef* input_node = node_map_->GetNode(input);\n    if (!IsReallyConstant(*input_node)) {\n      return Status(error::INVALID_ARGUMENT,\n                    strings::StrCat(\""Can't fold \"", node.name(), \"", its \"", input,\n                                    \"" isn't constant\""));\n    }\n    TF_RETURN_IF_ERROR(CheckAttrExists(*input_node, \""value\""));\n    const TensorProto& raw_val = input_node->attr().at(\""value\"").tensor();\n    if (raw_val.dtype() == DT_INVALID) {\n      return Status(\n          error::INVALID_ARGUMENT,\n          strings::StrCat(\""A tensor in the input node, with TensorId of \"",\n                          input_tensor.ToString(),\n                          \"" has a dtype of DT_INVALID.\""));\n    }\n    if (IsRefType(raw_val.dtype())) {\n      return errors::InvalidArgument(\n          \""Not allowed to construct a tensor with reference dtype, got \"",\n          DataTypeString(raw_val.dtype()));\n    }\n    Tensor* value = new Tensor(raw_val.dtype(), raw_val.tensor_shape());\n    if (!value->FromProto(raw_val)) {\n      delete (value);\n      return errors::InvalidArgument(\""Unable to make Tensor from proto for \"",\n                                     node.name(), \"" with shape \"",\n                                     raw_val.tensor_shape().DebugString());\n    }\n    inputs.emplace_back(value);\n    total_inputs_size += value->TotalBytes();\n  }\n\n  TF_RETURN_IF_ERROR(EvaluateNode(node, inputs, &output_tensors));\n  if (output_tensors.empty()) {\n    return Status(error::INVALID_ARGUMENT, \""Expected at least one output.\"");\n  }\n\n  outputs->resize(output_tensors.size());\n  for (size_t i = 0; i < output_tensors.size(); i++) {\n    string node_name = OptimizedNodeName(node, \""-folded\"");\n    if (output_tensors.size() > 1) {\n      node_name = strings::StrCat(node_name, \""-\"", i);\n    }\n    if (output_tensors[i].tensor) {\n      Status s = CreateNodeDef(node_name, output_tensors[i], &outputs->at(i),\n                               total_inputs_size);\n      if (!s.ok()) {\n        *result_too_large = true;\n        return s;\n      }\n    } else {\n      // Create an empty NodeDef to identify dead outputs (e.g. the output of a\n      // switch that's not selected by the switch predicate).\n      outputs->at(i) = NodeDef();\n    }\n  }\n  return Status::OK();\n}\n\nStatus ConstantFolding::FoldMergeNode(NodeDef* node, GraphDef* output_graph) {\n  // Merge nodes are special, in the sense that they execute as soon as one of\n  // their input is ready. We can therefore fold a merge node iff it has at\n  // least one constant input without control dependency.\n  // We still need to ensure that the nodes in the fanin of the merge node are\n  // scheduled. We'll therefore add a control dependency from the merge node\n  // to the folded constant. We end up with:\n  //  * the merge node and its inputs are preserved as is\n  //  * a new constant node C1, driven by the merge node through a control\n  //  dependency, initialized to the value of the folded input\n  //  * a new constant node C2, driven by the merge node through a control\n  //  dependency, initialized to the index of the folded input\n  //  * the fanout of the merge nodes is rewired to be driven by either C1 or\n  //  C2.\n  for (int input_index = 0; input_index < node->input_size(); ++input_index) {\n    const auto& input = node->input(input_index);\n    if (IsControlInput(input)) {\n      // Try the next input.\n      continue;\n    }\n    NodeDef* input_node = node_map_->GetNode(input);\n    if (!IsReallyConstant(*input_node)) {\n      continue;\n    }\n    bool valid_input = true;\n    for (const string& fanin_of_input : input_node->input()) {\n      if (IsControlInput(fanin_of_input)) {\n        valid_input = false;\n        break;\n      }\n    }\n    if (!valid_input) {\n      // Try the next input\n      continue;\n    }\n\n    string const_out_name = OptimizedNodeName(*node, \""_const\"");\n    string const_index_name = OptimizedNodeName(*node, \""_index\"");\n    if (node_map_->GetNode(const_out_name) ||\n        node_map_->GetNode(const_index_name)) {\n      // Intended name already exists.\n      return errors::AlreadyExists(\n          strings::StrCat(const_out_name, \"" or \"", const_index_name,\n                          \"" already present in the graph\""));\n    }\n\n    NodeDef* const_out = output_graph->add_node();\n    *const_out = *input_node;\n    const_out->set_name(const_out_name);\n    const_out->set_device(node->device());\n    *const_out->add_input() = AsControlDependency(*node);\n    node_map_->AddNode(const_out->name(), const_out);\n    node_map_->AddOutput(node->name(), const_out->name());\n\n    NodeDef* const_index = output_graph->add_node();\n    const_index->set_op(\""Const\"");\n    Tensor index(DT_INT32, TensorShape({}));\n    index.flat<int32>()(0) = input_index;\n    (*const_index->mutable_attr())[\""dtype\""].set_type(DT_INT32);\n    index.AsProtoTensorContent(\n        (*const_index->mutable_attr())[\""value\""].mutable_tensor());\n    const_index->set_name(const_index_name);\n    const_index->set_device(node->device());\n    *const_index->add_input() = AsControlDependency(*node);\n    node_map_->AddNode(const_index->name(), const_index);\n    node_map_->AddOutput(node->name(), const_index->name());\n\n    // We make a copy because we mutate the nodes.\n    auto outputs = node_map_->GetOutputs(node->name());\n    for (NodeDef* output : outputs) {\n      for (int i = 0; i < output->input_size(); i++) {\n        int port;\n        string node_name = ParseNodeName(output->input(i), &port);\n        if (node_name == node->name()) {\n          if (port == 0) {\n            *output->mutable_input(i) = const_out->name();\n            node_map_->AddOutput(const_out->name(), output->name());\n          } else if (port == 1) {\n            *output->mutable_input(i) = const_index->name();\n            node_map_->AddOutput(const_index->name(), output->name());\n          } else {\n            // This is a control dependency (or an invalid edge since the\n            // merge node has only 2 outputs): preserve them.\n          }\n        }\n      }\n    }\n    return Status::OK();\n  }\n  return Status::OK();\n}\n\nStatus ConstantFolding::FoldNode(NodeDef* node, GraphDef* output_graph,\n                                 bool* result_too_large) {\n  *result_too_large = false;\n  if (IsMerge(*node)) {\n    return FoldMergeNode(node, output_graph);\n  }\n\n  std::vector<NodeDef> const_nodes;\n  TF_RETURN_IF_ERROR(\n      EvaluateOneFoldable(*node, &const_nodes, result_too_large));\n  VLOG(2) << \""Folded node: \"" << SummarizeNodeDef(*node);\n\n  NodeDef* constant_output = nullptr;\n  for (int i = 0, end = const_nodes.size(); i < end; i++) {\n    NodeDef* const_node = &const_nodes[i];\n    VLOG(3) << \""Generated constant node: \"" << SummarizeNodeDef(*const_node);\n    if (const_node->name().empty()) {\n      // Dead output: we can't create a constant to encode its value, so we'll\n      // just skip it. We'll preserve the edges that originate from that\n      // output below to preserve the overall behavior of the graph wrt dead\n      // edges.\n      continue;\n    }\n\n    // Returns `true` iff `const_node` already has control input named `input`.\n    const auto is_duplicate_control_input = [&](const string& input) -> bool {\n      auto it = absl::c_find(const_node->input(), input);\n      return it != const_node->input().end();\n    };\n\n    // Forward control dependencies.\n    for (const string& input : node->input()) {\n      // Forward control dependencies from folded node.\n      if (IsControlInput(input)) {\n        if (!is_duplicate_control_input(input)) {\n          *const_node->add_input() = input;\n        }\n      }\n\n      // Forward control dependencies from constant inputs to folded node.\n      if (!IsControlInput(input)) {\n        NodeDef* input_node = node_map_->GetNode(input);\n        for (const string& fanin_of_input : input_node->input()) {\n          if (!is_duplicate_control_input(fanin_of_input)) {\n            *const_node->add_input() = fanin_of_input;\n          }\n        }\n      }\n    }\n\n    // We rewrite the existing node if it only has a single output, and\n    // create new nodes otherwise.\n    if (const_nodes.size() == 1) {\n      node->set_op(\""Const\"");\n      // Note we need to clear the inputs in NodeMap before we clear the inputs\n      // in the node, otherwise NodeMap would see empty inputs and effectively\n      // does nothing.\n      node_map_->RemoveInputs(node->name());\n      node->clear_input();\n      *node->mutable_input() = const_node->input();\n      for (const auto& input : node->input()) {\n        node_map_->AddOutput(NodeName(input), node->name());\n      }\n      *node->mutable_attr() = const_node->attr();\n      break;\n    } else {\n      if (node_map_->GetNode(const_node->name())) {\n        // Intended name already exists.\n        return errors::AlreadyExists(strings::StrCat(\n            const_node->name(), \"" already present in the graph\""));\n      }\n      NodeDef* added_node = output_graph->add_node();\n      *added_node = *const_node;\n      added_node->set_device(node->device());\n      node_map_->AddNode(added_node->name(), added_node);\n      for (const auto& input : added_node->input()) {\n        node_map_->AddOutput(NodeName(input), added_node->name());\n      }\n      // All the constant nodes encoding output values have the same control\n      // dependencies (since these are the control dependencies of the node\n      // we're trying to fold). Record one such constant node.\n      constant_output = added_node;\n    }\n  }\n\n  if (const_nodes.size() > 1) {\n    // We make a copy because we mutate the nodes.\n    auto outputs = node_map_->GetOutputs(node->name());\n    for (NodeDef* output : outputs) {\n      for (int i = 0; i < output->input_size(); i++) {\n        int port;\n        string node_name = ParseNodeName(output->input(i), &port);\n        if (node_name == node->name()) {\n          if (port < 0) {\n            // Propagate control dependencies if possible. If not, we'll just\n            // preserve the existing control dependencies.\n            if (constant_output != nullptr) {\n              node_map_->UpdateInput(node_name, NodeName(output->input(i)),\n                                     constant_output->name());\n              *output->mutable_input(i) = AsControlDependency(*constant_output);\n            }\n          } else if (port < static_cast<int>(const_nodes.size()) &&\n                     !const_nodes[port].name().empty()) {\n            // Replace alive outputs with the corresponding constant.\n            node_map_->UpdateInput(output->name(), NodeName(output->input(i)),\n                                   const_nodes[port].name());\n            *output->mutable_input(i) = const_nodes[port].name();\n          } else {\n            // Leave this edge alone.\n            VLOG(3) << \""Preserving edge from \"" << node->name() << \"":\"" << port\n                    << \""[\"" << node->op() << \""] to \"" << output->name() << \"":\""\n                    << i << \""[\"" << output->op() << \""]\"";\n          }\n        }\n      }\n    }\n    outputs = node_map_->GetOutputs(node->name());\n    if (outputs.empty() && has_fetch_ &&\n        nodes_to_preserve_.find(node->name()) == nodes_to_preserve_.end()) {\n      node_map_->RemoveInputs(node->name());\n      node->clear_input();\n    }\n  }\n  return Status::OK();\n}\n\nStatus ConstantFolding::FoldGraph(\n    const GraphProperties& properties, GraphDef* optimized_graph,\n    absl::flat_hash_set<string>* nodes_to_not_simplify) {\n  // We build a new optimized_graph by inserting the folded nodes into it, then\n  // copy other nodes that might be needed at the end of this function.\n  absl::flat_hash_set<string> processed_nodes;\n  std::deque<NodeDef*> queue;\n  for (int i = 0; i < graph_->node_size(); i++) {\n    const NodeDef& node = graph_->node(i);\n    if (IsFoldable(node, &properties) &&\n        !nodes_to_not_simplify->count(node.name())) {\n      queue.push_back(graph_->mutable_node(i));\n    }\n  }\n  while (!queue.empty()) {\n    NodeDef* node = queue.front();\n    queue.pop_front();\n    if (processed_nodes.count(node->name())) {\n      continue;\n    }\n    // We need to record a copy of output nodes before FoldNode() modifies it.\n    // We also need to ensure that the fanout is sorted deterministically.\n    std::vector<NodeDef*> fanout =\n        node_map_->GetOutputsOrderedByNodeName(node->name());\n    bool result_too_large = false;\n    Status s = FoldNode(node, optimized_graph, &result_too_large);\n    processed_nodes.insert(node->name());\n    if (!s.ok()) {\n      VLOG(1) << \""Failed to fold node \"" << node->DebugString()\n              << \""\\nError message: \"" << s;\n      if (result_too_large) {\n        nodes_to_not_simplify->emplace(node->name());\n      }\n    } else {\n      for (auto& fanout_node : fanout) {\n        if (IsFoldable(*fanout_node, &properties) &&\n            !nodes_to_not_simplify->count(fanout_node->name())) {\n          queue.push_back(fanout_node);\n        }\n      }\n    }\n  }\n\n  // Delete the newly created nodes that don't feed anything.\n  std::vector<int> nodes_to_delete;\n  for (int i = 0; i < optimized_graph->node_size(); i++) {\n    const auto& fanout = node_map_->GetOutputs(optimized_graph->node(i).name());\n    if (fanout.empty()) nodes_to_delete.push_back(i);\n  }\n  EraseNodesFromGraph(std::move(nodes_to_delete), optimized_graph);\n\n  for (int i = 0; i < graph_->node_size(); ++i) {\n    NodeDef* node = graph_->mutable_node(i);\n    // If no fetch nodes is provided, we conservatively\n    // move all nodes in the original graph to the output, in case users need\n    // to fetch their values.\n    const auto& fanout = node_map_->GetOutputs(node->name());\n    if (!fanout.empty() || !has_fetch_ ||\n        nodes_to_preserve_.find(node->name()) != nodes_to_preserve_.end()) {\n      *(optimized_graph->add_node()) = std::move(*node);\n    }\n  }\n  return Status::OK();\n}\n\nStatus ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return errors::Internal(\""Node \"", node.name(), \"" is not a Reshape node\"");\n  }\n  if (2 > node.input_size()) {\n    return errors::Internal(\""Node \"", node.name(),\n                            \"" must have at most 2 inputs but has \"",\n                            node.input_size());\n  }\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return errors::Internal(\""Node \"", node.name(), \"" has shape \"",\n                            new_shape->DebugString(),\n                            \"" which is not a constant\"");\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return errors::Internal(\""Could not evaluate node \"", node.name());\n  }\n  if (outputs.size() != 1) {\n    return errors::Internal(\""Node \"", node.name(),\n                            \"" must have exactly 1 output but has \"",\n                            outputs.size());\n  }\n\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return errors::Internal(\""Node \"", node.name(), \"" has no properties\"");\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return errors::Internal(\""Node \"", node.name(), \"" has property \"",\n                            prop.DebugString(), \"" with invalid dtype\"");\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return errors::Internal(\""Node \"", node.name(), \"" has property \"",\n                            prop.DebugString(), \"" with shape \"",\n                            shape.DebugString(), \"" which is not fully defined\"");\n  }\n\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n  }\n\n  if (!shape.IsCompatibleWith(new_dims)) {\n    return errors::Internal(\""Expected shape \"", shape.DebugString(),\n                            \""to be compatible with \"", new_dims.DebugString());\n  }\n\n  return Status::OK();\n}\n\n#define IS_VALUE_CASE(DTYPE, VALUE)                   \\\n  case DTYPE:                                         \\\n    return AllValuesAre<EnumToDataType<DTYPE>::Type>( \\\n        node.attr().at(\""value\"").tensor(), EnumToDataType<DTYPE>::Type(VALUE))\n\n#define IS_ONES_CASE(TYPE) IS_VALUE_CASE(TYPE, 1)\n#define IS_ZEROS_CASE(TYPE) IS_VALUE_CASE(TYPE, 0)\n\nbool ConstantFolding::IsOnes(const NodeDef& node) const {\n  if (feed_nodes_.find(node.name()) != feed_nodes_.end()) {\n    return false;\n  }\n  if (IsOnesLike(node)) return true;\n  if (IsZerosLike(node)) return false;\n  if (node.op() == \""Fill\"") {\n    NodeDef* values = node_map_->GetNode(NodeName(node.input(1)));\n    return values != nullptr && IsOnes(*values);\n  }\n  if (node.op() != \""Const\"") return false;\n  if (node.attr().count(\""dtype\"") == 0) return false;\n  const auto dtype = node.attr().at(\""dtype\"").type();\n  switch (dtype) {\n    IS_ONES_CASE(DT_BOOL);\n    IS_ONES_CASE(DT_HALF);\n    IS_ONES_CASE(DT_BFLOAT16);\n    IS_ONES_CASE(DT_FLOAT);\n    IS_ONES_CASE(DT_DOUBLE);\n    IS_ONES_CASE(DT_COMPLEX64);\n    IS_ONES_CASE(DT_COMPLEX128);\n    IS_ONES_CASE(DT_UINT8);\n    IS_ONES_CASE(DT_INT8);\n    IS_ONES_CASE(DT_UINT16);\n    IS_ONES_CASE(DT_INT16);\n    IS_ONES_CASE(DT_INT32);\n    IS_ONES_CASE(DT_INT64);\n    IS_ONES_CASE(DT_QINT32);\n    IS_ONES_CASE(DT_QINT16);\n    IS_ONES_CASE(DT_QUINT16);\n    IS_ONES_CASE(DT_QINT8);\n    IS_ONES_CASE(DT_QUINT8);\n    default:\n      VLOG(1) << \""Unsupported type \"" << DataTypeString(dtype);\n      return false;\n  }\n  return false;\n}""}]","{""function"": 1, ""code"": 3, ""value"": 3}","[{""source"": ""func_info(func:IsRefType)"", ""result"": [{""code"": ""inline bool IsRefType(DataType dtype) {\n  return dtype > static_cast<DataType>(kDataTypeRefOffset);\n}"", ""start_line"": 239, ""end_line"": 241, ""full_name"": ""tensorflow.IsRefType:bool(DataType)"", ""file_path"": ""tensorflow/core/framework/types.h""}]}, {""source"": ""code_info(file:types.h, lines:235-245)"", ""result"": ""}\n\n// DT_FLOAT + kDataTypeRefOffset == DT_FLOAT_REF, etc.\nenum { kDataTypeRefOffset = 100 };\ninline bool IsRefType(DataType dtype) {\n  return dtype > static_cast<DataType>(kDataTypeRefOffset);\n}\ninline DataType MakeRefType(DataType dtype) {\n  DCHECK(!IsRefType(dtype));\n  return static_cast<DataType>(dtype + kDataTypeRefOffset);\n}\n""}, {""source"": ""value_info(file:constant_folding.cc, value:raw_val)"", ""result"": {""value_trace"": [{""full_code"": ""const TensorProto & raw_val"", ""line"": 474, ""func_name"": null}, {""full_code"": ""const TensorProto & raw_val"", ""line"": 586, ""func_name"": null}, {""full_code"": ""const TensorProto & raw_val"", ""line"": 1358, ""func_name"": null}], ""struct_var"": ""raw_val"", ""struct_type"": ""tensorflow.TensorProto&"", ""struct_definition"": null}}, {""source"": ""value_info(file:constant_folding.cc, value:raw_val)"", ""result"": {""value_trace"": [{""full_code"": ""const TensorProto & raw_val"", ""line"": 474, ""func_name"": null}, {""full_code"": ""const TensorProto & raw_val"", ""line"": 586, ""func_name"": null}, {""full_code"": ""const TensorProto & raw_val"", ""line"": 1358, ""func_name"": null}], ""struct_var"": ""raw_val"", ""struct_type"": ""tensorflow.TensorProto&"", ""struct_definition"": null}}, {""source"": ""value_info(file:constant_folding.cc, value:raw_val)"", ""result"": {""value_trace"": [{""full_code"": ""const TensorProto & raw_val"", ""line"": 474, ""func_name"": null}, {""full_code"": ""const TensorProto & raw_val"", ""line"": 586, ""func_name"": null}, {""full_code"": ""const TensorProto & raw_val"", ""line"": 1358, ""func_name"": null}], ""struct_var"": ""raw_val"", ""struct_type"": ""tensorflow.TensorProto&"", ""struct_definition"": null}}, {""source"": ""code_info(file:constant_folding.cc, lines:470-480)"", ""result"": ""        // checks. A 0 sized array that can't grow isn't useful anyway.\n        if (array_size->attr().count(\""value\"") == 0) {\n          continue;\n        }\n        const TensorProto& raw_val = array_size->attr().at(\""value\"").tensor();\n        if (raw_val.dtype() != DT_INT32) {\n          continue;\n        }\n        Tensor value(raw_val.dtype(), raw_val.tensor_shape());\n        if (!value.FromProto(raw_val)) {\n          continue;\n""}, {""source"": ""code_info(file:constant_folding.cc, lines:1350-1370)"", ""result"": ""    }\n    const NodeDef* input_node = node_map_->GetNode(input);\n    if (!IsReallyConstant(*input_node)) {\n      return Status(error::INVALID_ARGUMENT,\n                    strings::StrCat(\""Can't fold \"", node.name(), \"", its \"", input,\n                                    \"" isn't constant\""));\n    }\n    TF_RETURN_IF_ERROR(CheckAttrExists(*input_node, \""value\""));\n    const TensorProto& raw_val = input_node->attr().at(\""value\"").tensor();\n    if (raw_val.dtype() == DT_INVALID) {\n      return Status(\n          error::INVALID_ARGUMENT,\n          strings::StrCat(\""A tensor in the input node, with TensorId of \"",\n                          input_tensor.ToString(),\n                          \"" has a dtype of DT_INVALID.\""));\n    }\n    Tensor* value = new Tensor(raw_val.dtype(), raw_val.tensor_shape());\n    if (!value->FromProto(raw_val)) {\n      delete (value);\n      return errors::InvalidArgument(\""Unable to make Tensor from proto for \"",\n                                     node.name(), \"" with shape \"",\n""}]","The vulnerability arises when a user-controlled TensorProto in a SavedModel specifies a reference dtype (e.g., DT_FLOAT_REF). This TensorProto is parsed into a NodeDef's ""value"" attribute (tensorflow/core/grappler/optimizers/constant_folding.cc:474, 1358), and its dtype is extracted as `raw_val.dtype()`. If `IsRefType(raw_val.dtype())` (tensorflow/core/framework/types.h:239-241) returns true (i.e., dtype > kDataTypeRefOffset=100), the Tensor constructor at `Tensor* value = new Tensor(...)` (tensorflow/core/grappler/optimizers/constant_folding.cc:1367) triggers a CHECK-fail. The patch adds a guard to return an error instead.",0.95,./github/other_context/CVE-2022-23588
