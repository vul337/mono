id,cve_id,cwe_id,language,description,commit_url,commit_msg,patch_nums,func_before,func_after,context_nums,context_data,root_cause,confidence_score,other_context_path
1,CVE-2012-3236,CWE-476,c_cpp,"fits-io.c in GIMP before 2.8.1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a malformed XTENSION header of a .fit file, as demonstrated using a long string.",https://github.com/GNOME/gimp/commit/0474376d234bc3d0901fd5e86f89d778a6473dd8,Bug 676804 - file handling DoS for fit file format\n\nApply patch from joe@reactionis.co.uk which fixes a buffer overflow on\nbroken/malicious fits files.\n(cherry picked from commit ace45631595e8781a1420842582d67160097163c),1,"[{""func_name"": ""fits_decode_header"", ""file_path"": ""plug-ins/file-fits/fits-io.c"", ""func_code"": ""static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *hdr,\n                        long hdr_offset, long dat_offset)\n\n{FITS_HDU_LIST *hdulist;\n FITS_DATA *fdat;\n char errmsg[80], key[9];\n int k, bpp, random_groups;\n long mul_axis, data_size, bitpix_supported;\n\n#define FITS_DECODE_CARD(mhdr,mkey,mfdat,mtyp) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(mhdr,mhdu,mkey,mvar,mtyp,unionvar) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n hdulist = fits_new_hdulist ();\n if (hdulist == NULL)\n   FITS_RETURN (\""fits_decode_header: Not enough memory\"", NULL);\n\n /* Initialize the header data */\n hdulist->header_offset = hdr_offset;\n hdulist->data_offset = dat_offset;\n\n hdulist->used.simple = (strncmp (hdr->data, \""SIMPLE  \"", 8) == 0);\n hdulist->used.xtension = (strncmp (hdr->data, \""XTENSION\"", 8) == 0);\n if (hdulist->used.xtension)\n {\n   fdat = fits_decode_card (fits_search_card (hdr, \""XTENSION\""), typ_fstring);\n   strcpy (hdulist->xtension, fdat->fstring);\n }\n\n FITS_DECODE_CARD (hdr, \""NAXIS\"", fdat, typ_flong);\n hdulist->naxis = fdat->flong;\n\n FITS_DECODE_CARD (hdr, \""BITPIX\"", fdat, typ_flong);\n bpp = hdulist->bitpix = (int)fdat->flong;\n if (   (bpp != 8) && (bpp != 16) && (bpp != 32)\n     && (bpp != -32) && (bpp != -64))\n {\n   strcpy (errmsg, \""fits_decode_header: Invalid BITPIX-value\"");\n   goto err_return;\n }\n if (bpp < 0) bpp = -bpp;\n bpp /= 8;\n hdulist->bpp = bpp;\n\n FITS_TRY_CARD (hdr, hdulist, \""GCOUNT\"", gcount, typ_flong, flong);\n FITS_TRY_CARD (hdr, hdulist, \""PCOUNT\"", pcount, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \""GROUPS\"", groups, typ_fbool, fbool);\n random_groups = hdulist->used.groups && hdulist->groups;\n\n FITS_TRY_CARD (hdr, hdulist, \""EXTEND\"", extend, typ_fbool, fbool);\n\n if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */\n {\n   if ((!hdulist->used.gcount) || (!hdulist->used.pcount))\n   {\n     strcpy (errmsg, \""fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\"");\n     goto err_return;\n   }\n }\n\n mul_axis = 1;\n\n /* Find all NAXISx-cards */\n for (k = 1; k <= FITS_MAX_AXIS; k++)\n {char naxisn[9];\n\n   sprintf (naxisn, \""NAXIS%-3d\"", k);\n   fdat = fits_decode_card (fits_search_card (hdr, naxisn), typ_flong);\n   if (fdat == NULL)\n   {\n     k--;   /* Save the last NAXISk read */\n     break;\n   }\n   hdulist->naxisn[k-1] = (int)fdat->flong;\n   if (hdulist->naxisn[k-1] < 0)\n   {\n     strcpy (errmsg, \""fits_decode_header: Negative value in NAXISn\"");\n     goto err_return;\n   }\n   if ((k == 1) && (random_groups))\n   {\n     if (hdulist->naxisn[0] != 0)\n     {\n       strcpy (errmsg, \""fits_decode_header: Random groups with NAXIS1 != 0\"");\n       goto err_return;\n     }\n   }\n   else\n     mul_axis *= hdulist->naxisn[k-1];\n }\n\n if ((hdulist->naxis > 0) && (k < hdulist->naxis))\n {\n   strcpy (errmsg, \""fits_decode_card: Not enough NAXISn-cards\"");\n   goto err_return;\n }\n\n /* If we have only one dimension, just set the second to size one. */\n /* So we dont have to check for naxis < 2 in some places. */\n if (hdulist->naxis < 2)\n   hdulist->naxisn[1] = 1;\n if (hdulist->naxis < 1)\n {\n   mul_axis = 0;\n   hdulist->naxisn[0] = 1;\n }\n\n if (hdulist->used.xtension)\n   data_size = bpp*hdulist->gcount*(hdulist->pcount + mul_axis);\n else\n   data_size = bpp*mul_axis;\n hdulist->udata_size = data_size;  /* Used data size without padding */\n\n /* Datasize must be a multiple of the FITS logical record size */\n data_size = (data_size + FITS_RECORD_SIZE - 1) / FITS_RECORD_SIZE;\n data_size *= FITS_RECORD_SIZE;\n hdulist->data_size = data_size;\n\n\n FITS_TRY_CARD (hdr, hdulist, \""BLANK\"", blank, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \""DATAMIN\"", datamin, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \""DATAMAX\"", datamax, typ_fdouble, fdouble);\n\n FITS_TRY_CARD (hdr, hdulist, \""BZERO\"", bzero, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \""BSCALE\"", bscale, typ_fdouble, fdouble);\n\n /* Evaluate number of interpretable images for this HDU */\n hdulist->numpic = 0;\n\n /* We must support this format */\n bitpix_supported =    (hdulist->bitpix > 0)\n                    || (   (hdulist->bitpix == -64)\n                        && (fits_ieee64_intel || fits_ieee64_motorola))\n                    || (   (hdulist->bitpix == -32)\n                        && (   fits_ieee32_intel || fits_ieee32_motorola\n                            || fits_ieee64_intel || fits_ieee64_motorola));\n\n if (bitpix_supported)\n {\n   if (hdulist->used.simple)\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n   else if (   hdulist->used.xtension\n            && (strncmp (hdulist->xtension, \""IMAGE\"", 5) == 0))\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n }\n else\n {char msg[160];\n   sprintf (msg, \""fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\"", hdulist->bitpix);\n   fits_set_error (msg);\n }\n\n hdulist->header_record_list = hdr;  /* Add header records to the list */\n return (hdulist);\n\nerr_missing:\n sprintf (errmsg, \""fits_decode_header: missing/invalid %s card\"", key);\n\nerr_return:\n fits_delete_hdulist (hdulist);\n fits_set_error (errmsg);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}"", ""target"": 0}]","[{""func_name"": ""fits_decode_header"", ""file_path"": ""plug-ins/file-fits/fits-io.c"", ""func_code"": ""static FITS_HDU_LIST *fits_decode_header (FITS_RECORD_LIST *hdr,\n                        long hdr_offset, long dat_offset)\n\n{FITS_HDU_LIST *hdulist;\n FITS_DATA *fdat;\n char errmsg[80], key[9];\n int k, bpp, random_groups;\n long mul_axis, data_size, bitpix_supported;\n\n#define FITS_DECODE_CARD(mhdr,mkey,mfdat,mtyp) \\\n {strcpy (key, mkey); \\\n  mfdat = fits_decode_card (fits_search_card (mhdr, mkey), mtyp); \\\n  if (mfdat == NULL) goto err_missing; }\n\n#define FITS_TRY_CARD(mhdr,mhdu,mkey,mvar,mtyp,unionvar) \\\n {FITS_DATA *mfdat = fits_decode_card (fits_search_card (mhdr,mkey), mtyp); \\\n  mhdu->used.mvar = (mfdat != NULL); \\\n  if (mhdu->used.mvar) mhdu->mvar = mfdat->unionvar; }\n\n hdulist = fits_new_hdulist ();\n if (hdulist == NULL)\n   FITS_RETURN (\""fits_decode_header: Not enough memory\"", NULL);\n\n /* Initialize the header data */\n hdulist->header_offset = hdr_offset;\n hdulist->data_offset = dat_offset;\n\n hdulist->used.simple = (strncmp (hdr->data, \""SIMPLE  \"", 8) == 0);\n hdulist->used.xtension = (strncmp (hdr->data, \""XTENSION\"", 8) == 0);\n if (hdulist->used.xtension)\n   {\n     fdat = fits_decode_card (fits_search_card (hdr, \""XTENSION\""), typ_fstring);\n     if (fdat != NULL)\n       {\n         strcpy (hdulist->xtension, fdat->fstring);\n       }\n     else\n       {\n         strcpy (errmsg, \""No valid XTENSION header found.\"");\n         goto err_return;\n       }\n   }\n\n FITS_DECODE_CARD (hdr, \""NAXIS\"", fdat, typ_flong);\n hdulist->naxis = fdat->flong;\n\n FITS_DECODE_CARD (hdr, \""BITPIX\"", fdat, typ_flong);\n bpp = hdulist->bitpix = (int)fdat->flong;\n if (   (bpp != 8) && (bpp != 16) && (bpp != 32)\n     && (bpp != -32) && (bpp != -64))\n {\n   strcpy (errmsg, \""fits_decode_header: Invalid BITPIX-value\"");\n   goto err_return;\n }\n if (bpp < 0) bpp = -bpp;\n bpp /= 8;\n hdulist->bpp = bpp;\n\n FITS_TRY_CARD (hdr, hdulist, \""GCOUNT\"", gcount, typ_flong, flong);\n FITS_TRY_CARD (hdr, hdulist, \""PCOUNT\"", pcount, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \""GROUPS\"", groups, typ_fbool, fbool);\n random_groups = hdulist->used.groups && hdulist->groups;\n\n FITS_TRY_CARD (hdr, hdulist, \""EXTEND\"", extend, typ_fbool, fbool);\n\n if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */\n {\n   if ((!hdulist->used.gcount) || (!hdulist->used.pcount))\n   {\n     strcpy (errmsg, \""fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION\"");\n     goto err_return;\n   }\n }\n\n mul_axis = 1;\n\n /* Find all NAXISx-cards */\n for (k = 1; k <= FITS_MAX_AXIS; k++)\n {char naxisn[9];\n\n   sprintf (naxisn, \""NAXIS%-3d\"", k);\n   fdat = fits_decode_card (fits_search_card (hdr, naxisn), typ_flong);\n   if (fdat == NULL)\n   {\n     k--;   /* Save the last NAXISk read */\n     break;\n   }\n   hdulist->naxisn[k-1] = (int)fdat->flong;\n   if (hdulist->naxisn[k-1] < 0)\n   {\n     strcpy (errmsg, \""fits_decode_header: Negative value in NAXISn\"");\n     goto err_return;\n   }\n   if ((k == 1) && (random_groups))\n   {\n     if (hdulist->naxisn[0] != 0)\n     {\n       strcpy (errmsg, \""fits_decode_header: Random groups with NAXIS1 != 0\"");\n       goto err_return;\n     }\n   }\n   else\n     mul_axis *= hdulist->naxisn[k-1];\n }\n\n if ((hdulist->naxis > 0) && (k < hdulist->naxis))\n {\n   strcpy (errmsg, \""fits_decode_card: Not enough NAXISn-cards\"");\n   goto err_return;\n }\n\n /* If we have only one dimension, just set the second to size one. */\n /* So we dont have to check for naxis < 2 in some places. */\n if (hdulist->naxis < 2)\n   hdulist->naxisn[1] = 1;\n if (hdulist->naxis < 1)\n {\n   mul_axis = 0;\n   hdulist->naxisn[0] = 1;\n }\n\n if (hdulist->used.xtension)\n   data_size = bpp*hdulist->gcount*(hdulist->pcount + mul_axis);\n else\n   data_size = bpp*mul_axis;\n hdulist->udata_size = data_size;  /* Used data size without padding */\n\n /* Datasize must be a multiple of the FITS logical record size */\n data_size = (data_size + FITS_RECORD_SIZE - 1) / FITS_RECORD_SIZE;\n data_size *= FITS_RECORD_SIZE;\n hdulist->data_size = data_size;\n\n\n FITS_TRY_CARD (hdr, hdulist, \""BLANK\"", blank, typ_flong, flong);\n\n FITS_TRY_CARD (hdr, hdulist, \""DATAMIN\"", datamin, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \""DATAMAX\"", datamax, typ_fdouble, fdouble);\n\n FITS_TRY_CARD (hdr, hdulist, \""BZERO\"", bzero, typ_fdouble, fdouble);\n FITS_TRY_CARD (hdr, hdulist, \""BSCALE\"", bscale, typ_fdouble, fdouble);\n\n /* Evaluate number of interpretable images for this HDU */\n hdulist->numpic = 0;\n\n /* We must support this format */\n bitpix_supported =    (hdulist->bitpix > 0)\n                    || (   (hdulist->bitpix == -64)\n                        && (fits_ieee64_intel || fits_ieee64_motorola))\n                    || (   (hdulist->bitpix == -32)\n                        && (   fits_ieee32_intel || fits_ieee32_motorola\n                            || fits_ieee64_intel || fits_ieee64_motorola));\n\n if (bitpix_supported)\n {\n   if (hdulist->used.simple)\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n   else if (   hdulist->used.xtension\n            && (strncmp (hdulist->xtension, \""IMAGE\"", 5) == 0))\n   {\n     if (hdulist->naxis > 0)\n     {\n       hdulist->numpic = 1;\n       for (k = 3; k <= hdulist->naxis; k++)\n         hdulist->numpic *= hdulist->naxisn[k-1];\n     }\n   }\n }\n else\n {char msg[160];\n   sprintf (msg, \""fits_decode_header: IEEE floating point format required for\\\n BITPIX=%d\\nis not supported on this machine\"", hdulist->bitpix);\n   fits_set_error (msg);\n }\n\n hdulist->header_record_list = hdr;  /* Add header records to the list */\n return (hdulist);\n\nerr_missing:\n sprintf (errmsg, \""fits_decode_header: missing/invalid %s card\"", key);\n\nerr_return:\n fits_delete_hdulist (hdulist);\n fits_set_error (errmsg);\n return (NULL);\n\n#undef FITS_DECODE_CARD\n}""}]","{""function"": 2}","[{""source"": ""func_info(file:fits-io.c, func:fits_search_card)"", ""result"": [{""code"": ""char *fits_search_card (FITS_RECORD_LIST *rl, char *keyword)\n\n{int key_len, k;\n char *card;\n char key[9];\n\n key_len = strlen (keyword);\n if (key_len > 8) key_len = 8;\n if (key_len == 0)\n   FITS_RETURN (\""fits_search_card: Invalid parameter\"", NULL);\n\n strcpy (key, \""        \"");\n memcpy (key, keyword, key_len);\n\n while (rl != NULL)\n {\n   card = (char *)rl->data;\n   for (k = 0; k < FITS_RECORD_SIZE / FITS_CARD_SIZE; k++)\n   {\n     if (strncmp (card, key, 8) == 0) return (card);\n     card += FITS_CARD_SIZE;\n   }\n   rl = rl->next_record;\n }\n return (NULL);\n}"", ""start_line"": 1652, ""end_line"": 1677, ""full_name"": ""fits_search_card"", ""file_path"": ""plug-ins/file-fits/fits-io.c""}]}, {""source"": ""func_info(file:fits-io.c, func:fits_decode_card)"", ""result"": [{""code"": ""FITS_DATA *fits_decode_card (const char *card, FITS_DATA_TYPES data_type)\n\n{static FITS_DATA data;\n long l_long;\n double l_double;\n char l_card[FITS_CARD_SIZE+1], msg[256];\n char *cp, *dst, *end;\n int ErrCount = 0;\n\n if (card == NULL) return (NULL);\n\n memcpy (l_card, card, FITS_CARD_SIZE);\n l_card[FITS_CARD_SIZE] = '\\0';\n\n if (strncmp (card+8, \""= \"", 2) != 0)\n {\n   sprintf (msg, \""fits_decode_card (warning): Missing value indicator\\\n '= ' for %8.8s\"", l_card);\n   fits_set_error (msg);\n   ErrCount++;\n }\n\n switch (data_type)\n {\n   case typ_bitpix8:\n     data.bitpix8 = (FITS_BITPIX8)(l_card[10]);\n     break;\n\n   case typ_bitpix16:\n     if (sscanf (l_card+10, \""%ld\"", &l_long) != 1)\n     {\n       fits_set_error (\""fits_decode_card: error decoding typ_bitpix16\"");\n       ErrCount++;\n       break;\n     }\n     data.bitpix16 = (FITS_BITPIX16)l_long;\n     break;\n\n   case typ_bitpix32:\n     if (sscanf (l_card+10, \""%ld\"", &l_long) != 1)\n     {\n       fits_set_error (\""fits_decode_card: error decoding t..."", ""start_line"": 1489, ""end_line"": 1628, ""full_name"": ""fits_decode_card"", ""file_path"": ""plug-ins/file-fits/fits-io.c""}]}]","plug-ins/file-fits/fits-io.c:1058-1063: Original code calls fits_search_card(hdr, ""XTENSION"") without checking if it returns NULL. If the XTENSION keyword is missing, fits_search_card (plug-ins/file-fits/fits-io.c:1652-1677) returns NULL, which is passed to fits_decode_card. fits_decode_card (plug-ins/file-fits/fits-io.c:1489-1628) returns NULL when given a NULL card, leaving fdat as NULL. The subsequent strcpy(hdulist->xtension, fdat->fstring) dereferences the NULL pointer, causing a crash.",0.95,./github/other_context/CVE-2012-3236
2,CVE-2013-4119,CWE-476,c_cpp,FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished.,7,"[{""func_name"": ""peer_recv_callback"", ""file_path"": ""libfreerdp/core/peer.c"", ""func_code"": ""static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \""Invalid state %d\\n\"", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""credssp_new"", ""file_path"": ""libfreerdp/core/nla.c"", ""func_code"": ""rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\""Software\\\\FreeRDP\\\\Server\""),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\""SspiModule\""), NULL, &dwType, NULL, &dwSize);\n\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\""SspiModule\""), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\""Using SSPI Module: %s\\n\""), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn credssp;\n}"", ""target"": 0}, {""func_name"": ""DeleteSecurityContext"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->DeleteSecurityContext(phContext);\n\n\treturn status;\n}"", ""target"": 0}, {""func_name"": ""sspi_SecureHandleGetUpperPointer"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle)\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\n\treturn pointer;\n}"", ""target"": 0}, {""func_name"": ""sspi_SecureHandleGetLowerPointer"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle)\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\n\treturn pointer;\n}"", ""target"": 0}, {""func_name"": ""transport_connect_nla"", ""file_path"": ""libfreerdp/core/transport.c"", ""func_code"": ""BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\n\t\tfprintf(stderr, \""Authentication failure, check credentials.\\n\""\n\t\t\t\""If credentials are valid, the NTLMSSP implementation may be to blame.\\n\"");\n\n\t\tcredssp_free(transport->credssp);\n\t\treturn FALSE;\n\t}\n\n\tcredssp_free(transport->credssp);\n\n\treturn TRUE;\n}"", ""target"": 0}, {""func_name"": ""transport_accept_nla"", ""file_path"": ""libfreerdp/core/transport.c"", ""func_code"": ""BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \""client authentication failure\\n\"");\n\t\tcredssp_free(transport->credssp);\n\t\treturn FALSE;\n\t}\n\n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}"", ""target"": 1}]","[{""func_name"": ""peer_recv_callback"", ""file_path"": ""libfreerdp/core/peer.c"", ""func_code"": ""static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n\t\t\t\trdp->nego->transport->credssp = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \""Invalid state %d\\n\"", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}""}, {""func_name"": ""credssp_new"", ""file_path"": ""libfreerdp/core/nla.c"", ""func_code"": ""rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\t\tSecInvalidateHandle(&credssp->context);\n\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\""Software\\\\FreeRDP\\\\Server\""),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\""SspiModule\""), NULL, &dwType, NULL, &dwSize);\n\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\""SspiModule\""), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\""Using SSPI Module: %s\\n\""), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn credssp;\n}""}, {""func_name"": ""DeleteSecurityContext"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name = NULL;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->DeleteSecurityContext(phContext);\n\n\treturn status;\n}""}, {""func_name"": ""sspi_SecureHandleGetUpperPointer"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle || !SecIsValidHandle(handle))\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\n\treturn pointer;\n}""}, {""func_name"": ""sspi_SecureHandleGetLowerPointer"", ""file_path"": ""winpr/libwinpr/sspi/sspi.c"", ""func_code"": ""void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle || !SecIsValidHandle(handle))\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\n\treturn pointer;\n}""}, {""func_name"": ""transport_connect_nla"", ""file_path"": ""libfreerdp/core/transport.c"", ""func_code"": ""BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\n\t\tfprintf(stderr, \""Authentication failure, check credentials.\\n\""\n\t\t\t\""If credentials are valid, the NTLMSSP implementation may be to blame.\\n\"");\n\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\n\tcredssp_free(transport->credssp);\n\n\treturn TRUE;\n}""}, {""func_name"": ""transport_accept_nla"", ""file_path"": ""libfreerdp/core/transport.c"", ""func_code"": ""BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \""client authentication failure\\n\"");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}""}]","{""value"": 1, ""caller"": 2}","[{""source"": ""value_info(file:nla.c, value:credssp)"", ""result"": {""value_trace"": [{""full_code"": ""credssp = (rdpCredssp*) malloc(sizeof(rdpCredssp))"", ""line"": 1229, ""func_name"": ""credssp_new""}], ""struct_var"": ""credssp"", ""struct_type"": ""rdpCredssp*"", ""struct_definition"": ""typedef struct rdp_credssp rdpCredssp;""}}, {""source"": ""caller_info(func:sspi_SecureHandleGetUpperPointer)"", ""result"": [{""call_line"": 725, ""call_code"": ""sspi_SecureHandleGetUpperPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY FreeCredentialsHandle(PCredHandle phCredential)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->FreeCredentialsHandle == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->FreeCredentialsHandle(phCredential);\n\n\treturn status;\n}"", ""caller_start"": 719, ""file_path"": ""winpr/libwinpr/sspi/sspi.c""}, {""call_line"": 759, ""call_code"": ""sspi_SecureHandleGetUpperPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY QueryCredentialsAttributesW(PCredHandle phCredential, ULONG ulAttribute, void* pBuffer)\n{\n\tSEC_WCHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableW* table;\n\n\tName = (SEC_WCHAR*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableWByNameW(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryCredentialsAttributesW == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryCredentialsAttributesW(phCredential, ulAttribute, pBuffer);\n\n\treturn status;\n}"", ""caller_start"": 753, ""file_path"": ""winpr/libwinpr/sspi/sspi.c""}, {""call_line"": 783, ""call_code"": ""sspi_SecureHandleGetUpperPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY QueryCredentialsAttributesA(PCredHandle phCredential, ULONG ulAttribute, void* pBuffer)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryCredentialsAttributesA == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryCredentialsAttributesA(phCredential, ulAttribute, pBuffer);\n\n\treturn status;\n}"", ""caller_start"": 777, ""file_path"": ""winpr/libwinpr/sspi/sspi.c""}, {""call_line"": 811, ""call_code"": ""sspi_SecureHandleGetUpperPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY AcceptSecurityContext(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tPSecBufferDesc pInput, ULONG fContextReq, ULONG TargetDataRep, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsTimeStamp)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->AcceptSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->AcceptSecurityContext(phCredential, phContext, pInput, fContextReq,\n\t\t\tTargetDataRep, phNewContext, pOutput, pfContextAttr, ptsTimeStamp);\n\n\treturn status;\n}"", ""caller_start"": 803, ""file_path"": ""winpr/libwinpr/sspi/sspi.c""}]}, {""source"": ""caller_info(func:sspi_SecureHandleGetLowerPointer)"", ""result"": [{""call_line"": 49, ""call_code"": ""sspi_SecureHandleGetLowerPointer(phContext)"", ""caller_code"": ""SEC_ENTRY credssp_InitializeSecurityContextA(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tSEC_CHAR* pszTargetName, ULONG fContextReq, ULONG Reserved1, ULONG TargetDataRep,\n\t\tPSecBufferDesc pInput, ULONG Reserved2, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsExpiry)\n{\n\tCREDSSP_CONTEXT* context;\n\tCREDENTIALS* credentials;\n\n\tcontext = sspi_SecureHandleGetLowerPointer(phContext);\n\n\tif (!context)\n\t{\n\t\tcontext = credssp_ContextNew();\n\n\t\tcredentials = (CREDENTIALS*) sspi_SecureHandleGetLowerPointer(phCredential);\n\n\t\tsspi_SecureHandleSetLowerPointer(phNewContext, context);\n\t\tsspi_SecureHandleSetUpperPointer(phNewContext, (void*) CREDSSP_PACKAGE_NAME);\n\t}\n\n\treturn SEC_E_OK;\n\n}"", ""caller_start"": 41, ""file_path"": ""winpr/libwinpr/sspi/CredSSP/credssp.c""}, {""call_line"": 55, ""call_code"": ""sspi_SecureHandleGetLowerPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY credssp_InitializeSecurityContextA(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tSEC_CHAR* pszTargetName, ULONG fContextReq, ULONG Reserved1, ULONG TargetDataRep,\n\t\tPSecBufferDesc pInput, ULONG Reserved2, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsExpiry)\n{\n\tCREDSSP_CONTEXT* context;\n\tCREDENTIALS* credentials;\n\n\tcontext = sspi_SecureHandleGetLowerPointer(phContext);\n\n\tif (!context)\n\t{\n\t\tcontext = credssp_ContextNew();\n\n\t\tcredentials = (CREDENTIALS*) sspi_SecureHandleGetLowerPointer(phCredential);\n\n\t\tsspi_SecureHandleSetLowerPointer(phNewContext, context);\n\t\tsspi_SecureHandleSetUpperPointer(phNewContext, (void*) CREDSSP_PACKAGE_NAME);\n\t}\n\n\treturn SEC_E_OK;\n\n}"", ""caller_start"": 41, ""file_path"": ""winpr/libwinpr/sspi/CredSSP/credssp.c""}, {""call_line"": 139, ""call_code"": ""sspi_SecureHandleGetLowerPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY credssp_QueryCredentialsAttributesA(PCredHandle phCredential, ULONG ulAttribute, void* pBuffer)\n{\n\tif (ulAttribute == SECPKG_CRED_ATTR_NAMES)\n\t{\n\t\tCREDENTIALS* credentials;\n\n\t\tcredentials = (CREDENTIALS*) sspi_SecureHandleGetLowerPointer(phCredential);\n\n\t\treturn SEC_E_OK;\n\t}\n\n\treturn SEC_E_UNSUPPORTED_FUNCTION;\n}"", ""caller_start"": 133, ""file_path"": ""winpr/libwinpr/sspi/CredSSP/credssp.c""}, {""call_line"": 154, ""call_code"": ""sspi_SecureHandleGetLowerPointer(phCredential)"", ""caller_code"": ""SEC_ENTRY credssp_FreeCredentialsHandle(PCredHandle phCredential)\n{\n\tCREDENTIALS* credentials;\n\n\tif (!phCredential)\n\t\treturn SEC_E_INVALID_HANDLE;\n\n\tcredentials = (CREDENTIALS*) sspi_SecureHandleGetLowerPointer(phCredential);\n\n\tif (!credentials)\n\t\treturn SEC_E_INVALID_HANDLE;\n\n\tsspi_CredentialsFree(credentials);\n\n\treturn SEC_E_OK;\n}"", ""caller_start"": 147, ""file_path"": ""winpr/libwinpr/sspi/CredSSP/credssp.c""}]}]",libfreerdp/core/peer.c:273 (credssp pointer not NULL after free) → libfreerdp/core/transport.c:160 (similar issue) → winpr/libwinpr/sspi/sspi.c:249/269 (dereference without handle validity check). Patch adds NULLing and SecInvalidateHandle in libfreerdp/core/nla.c:1246 and SecIsValidHandle checks in sspi.c to prevent invalid dereference.,0.95,./github/other_context/CVE-2013-4119
3,CVE-2015-6569,"CWE-362, CWE-476",java,Race condition in the LoadBalancer module in the Atlassian Floodlight Controller before 1.2 allows remote attackers to cause a denial of service (NULL pointer dereference and thread crash) via a state manipulation attack.,https://github.com/floodlight/floodlight/commit/7f5bedb625eec3ff4d29987c31cef2553a962b36,fix data races bug in LoadBalancer module,2,"[{""func_name"": ""processPacketIn"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx) {\n        \n        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);\n        IPacket pkt = eth.getPayload(); \n \n        if (eth.isBroadcast() || eth.isMulticast()) {\n            // handle ARP for VIP\n            if (pkt instanceof ARP) {\n                // retrieve arp to determine target IP address                                                       \n                ARP arpRequest = (ARP) eth.getPayload();\n\n                IPv4Address targetProtocolAddress = arpRequest.getTargetProtocolAddress();\n\n                if (vipIpToId.containsKey(targetProtocolAddress.getInt())) {\n                    String vipId = vipIpToId.get(targetProtocolAddress.getInt());\n                    vipProxyArpReply(sw, pi, cntx, vipId);\n                    return Command.STOP;\n                }\n            }\n        } else {\n            // currently only load balance IPv4 packets - no-op for other traffic \n            if (pkt instanceof IPv4) {\n                IPv4 ip_pkt = (IPv4) pkt;\n                \n                // If match Vip and port, check pool and choose member\n                int destIpAddress = ip_pkt.getDestinationAddress().getInt();\n                \n                if (vipIpToId.containsKey(destIpAddress)){\n                    IPClient client = new IPClient();\n                    client.ipAddress = ip_pkt.getSourceAddress();\n                    client.nw_proto = ip_pkt.getProtocol();\n                    if (ip_pkt.getPayload() instanceof TCP) {\n                        TCP tcp_pkt = (TCP) ip_pkt.getPayload();\n                        client.srcPort = tcp_pkt.getSourcePort();\n                        client.targetPort = tcp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof UDP) {\n                        UDP udp_pkt = (UDP) ip_pkt.getPayload();\n                        client.srcPort = udp_pkt.getSourcePort();\n                        client.targetPort = udp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof ICMP) {\n                        client.srcPort = TransportPort.of(8); \n                        client.targetPort = TransportPort.of(0); \n                    }\n                    \n                    LBVip vip = vips.get(vipIpToId.get(destIpAddress));\n                    LBPool pool = pools.get(vip.pickPool(client));\n                    LBMember member = members.get(pool.pickMember(client));\n\n                    // for chosen member, check device manager and find and push routes, in both directions                    \n                    pushBidirectionalVipRoutes(sw, pi, cntx, client, member);\n                   \n                    // packet out based on table rule\n                    pushPacket(pkt, sw, pi.getBufferId(), (pi.getVersion().compareTo(OFVersion.OF_12) < 0) ? pi.getInPort() : pi.getMatch().get(MatchField.IN_PORT), OFPort.TABLE,\n                                cntx, true);\n\n                    return Command.STOP;\n                }\n            }\n        }\n        // bypass non-load-balanced traffic for normal processing (forwarding)\n        return Command.CONTINUE;\n    }"", ""target"": 0}, {""func_name"": ""removePool"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""@Override\n    public int removePool(String poolId) {\n        LBPool pool;\n        if (pools != null) {\n            pool = pools.get(poolId);\n            if (pool.vipId != null)\n                vips.get(pool.vipId).pools.remove(poolId);\n            pools.remove(poolId);\n            return 0;\n        } else {\n            return -1;\n        }\n    }"", ""target"": 0}]","[{""func_name"": ""processPacketIn"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx) {\n        \n        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);\n        IPacket pkt = eth.getPayload(); \n \n        if (eth.isBroadcast() || eth.isMulticast()) {\n            // handle ARP for VIP\n            if (pkt instanceof ARP) {\n                // retrieve arp to determine target IP address                                                       \n                ARP arpRequest = (ARP) eth.getPayload();\n\n                IPv4Address targetProtocolAddress = arpRequest.getTargetProtocolAddress();\n\n                if (vipIpToId.containsKey(targetProtocolAddress.getInt())) {\n                    String vipId = vipIpToId.get(targetProtocolAddress.getInt());\n                    vipProxyArpReply(sw, pi, cntx, vipId);\n                    return Command.STOP;\n                }\n            }\n        } else {\n            // currently only load balance IPv4 packets - no-op for other traffic \n            if (pkt instanceof IPv4) {\n                IPv4 ip_pkt = (IPv4) pkt;\n                \n                // If match Vip and port, check pool and choose member\n                int destIpAddress = ip_pkt.getDestinationAddress().getInt();\n                \n                if (vipIpToId.containsKey(destIpAddress)){\n                    IPClient client = new IPClient();\n                    client.ipAddress = ip_pkt.getSourceAddress();\n                    client.nw_proto = ip_pkt.getProtocol();\n                    if (ip_pkt.getPayload() instanceof TCP) {\n                        TCP tcp_pkt = (TCP) ip_pkt.getPayload();\n                        client.srcPort = tcp_pkt.getSourcePort();\n                        client.targetPort = tcp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof UDP) {\n                        UDP udp_pkt = (UDP) ip_pkt.getPayload();\n                        client.srcPort = udp_pkt.getSourcePort();\n                        client.targetPort = udp_pkt.getDestinationPort();\n                    }\n                    if (ip_pkt.getPayload() instanceof ICMP) {\n                        client.srcPort = TransportPort.of(8); \n                        client.targetPort = TransportPort.of(0); \n                    }\n                    \n                    LBVip vip = vips.get(vipIpToId.get(destIpAddress));\n                    if (vip == null)\t\t\t// fix deference violations           \n                    \treturn Command.CONTINUE;\n                    LBPool pool = pools.get(vip.pickPool(client));\n                    if (pool == null)\t\t\t// fix deference violations\n                    \treturn Command.CONTINUE;\n                    LBMember member = members.get(pool.pickMember(client));\n                    if(member == null)\t\t\t//fix deference violations\n                    \treturn Command.CONTINUE;\n                    \n                    // for chosen member, check device manager and find and push routes, in both directions                    \n                    pushBidirectionalVipRoutes(sw, pi, cntx, client, member);\n                   \n                    // packet out based on table rule\n                    pushPacket(pkt, sw, pi.getBufferId(), (pi.getVersion().compareTo(OFVersion.OF_12) < 0) ? pi.getInPort() : pi.getMatch().get(MatchField.IN_PORT), OFPort.TABLE,\n                                cntx, true);\n\n                    return Command.STOP;\n                }\n            }\n        }\n        // bypass non-load-balanced traffic for normal processing (forwarding)\n        return Command.CONTINUE;\n    }""}, {""func_name"": ""removePool"", ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java"", ""func_code"": ""@Override\n    public int removePool(String poolId) {\n        LBPool pool;\n        if (pools != null) {\n            pool = pools.get(poolId);\n            if (pool == null)\t// fix deference violations\n            \treturn -1;\n            if (pool.vipId != null)\n                vips.get(pool.vipId).pools.remove(poolId);\n            pools.remove(poolId);\n            return 0;\n        } else {\n            return -1;\n        }\n    }""}]","{""code"": 3, ""value"": 3, ""caller"": 1}","[{""source"": ""code_info(file:LoadBalancer.java, lines:100-150)"", ""result"": ""    protected IFloodlightProviderService floodlightProviderService;\n    protected IRestApiService restApiService;\n    \n    protected IDebugCounterService debugCounterService;\n    private IDebugCounter counterPacketOut;\n    protected IDeviceService deviceManagerService;\n    protected IRoutingService routingEngineService;\n    protected ITopologyService topologyService;\n    protected IStaticFlowEntryPusherService sfpService;\n    protected IOFSwitchService switchService;\n    \n    protected HashMap<String, LBVip> vips;\n    protected HashMap<String, LBPool> pools;\n    protected HashMap<String, LBMember> members;\n    protected HashMap<Integer, String> vipIpToId;\n    protected HashMap<Integer, MacAddress> vipIpToMac;\n    protected HashMap<Integer, String> memberIpToId;\n    protected HashMap<IPClient, LBMember> clientToMember;\n    \n    //Copied from Forwarding with message damper routine for pushing proxy Arp \n    protected static int OFMESSAGE_DAMPER_CAPACITY = 10000; // ms. \n    protected static int OFMESSAGE_DAMPER_TIMEOUT = 250; // ms \n    protected static String LB_ETHER_TYPE = \""0x800\"";\n    protected static int LB_PRIORITY = 32768;\n    \n    // Comparator for sorting by SwitchCluster\n    public Comparator<SwitchPort> clusterIdComparator =\n            new Comparator<SwitchPort>() {\n                @Override\n                public int compare(SwitchPort d1, SwitchPort d2) {\n                    DatapathId d1ClusterId = topologyService.getL2DomainId(d1.getSwitchDPID());\n                    DatapathId d2ClusterId = topologyService.getL2DomainId(d2.getSwitchDPID());\n                    return d1ClusterId.compareTo(d2ClusterId);\n                }\n            };\n\n    // data structure for storing connected\n    public class IPClient {\n        IPv4Address ipAddress;\n        IpProtocol nw_proto;\n        TransportPort srcPort; // tcp/udp src port. icmp type (OFMatch convention)\n        TransportPort targetPort; // tcp/udp dst port, icmp code (OFMatch convention)\n        \n        public IPClient() {\n            ipAddress = IPv4Address.NONE;\n            nw_proto = IpProtocol.NONE;\n            srcPort = TransportPort.NONE;\n            targetPort = TransportPort.NONE;\n        }\n    }\n    \n    @Override\n""}, {""source"": ""value_info(file:LoadBalancer.java, value:vips)"", ""result"": {""value_trace"": [{""full_code"": ""this.vips = new HashMap<String, LBVip>()"", ""line"": 810, ""func_name"": ""net.floodlightcontroller.loadbalancer.LoadBalancer.init:void(net.floodlightcontroller.core.module.FloodlightModuleContext)""}], ""struct_var"": ""vips"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:LoadBalancer.java, value:pools)"", ""result"": {""value_trace"": [{""full_code"": ""this.pools = new HashMap<String, LBPool>()"", ""line"": 811, ""func_name"": ""net.floodlightcontroller.loadbalancer.LoadBalancer.init:void(net.floodlightcontroller.core.module.FloodlightModuleContext)""}], ""struct_var"": ""pools"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:LoadBalancer.java, value:members)"", ""result"": {""value_trace"": [{""full_code"": ""this.members = new HashMap<String, LBMember>()"", ""line"": 812, ""func_name"": ""net.floodlightcontroller.loadbalancer.LoadBalancer.init:void(net.floodlightcontroller.core.module.FloodlightModuleContext)""}], ""struct_var"": ""members"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:LoadBalancer.java, lines:800-820)"", ""result"": ""                                                 throws FloodlightModuleException {\n        floodlightProviderService = context.getServiceImpl(IFloodlightProviderService.class);\n        restApiService = context.getServiceImpl(IRestApiService.class);\n        debugCounterService = context.getServiceImpl(IDebugCounterService.class);\n        deviceManagerService = context.getServiceImpl(IDeviceService.class);\n        routingEngineService = context.getServiceImpl(IRoutingService.class);\n        topologyService = context.getServiceImpl(ITopologyService.class);\n        sfpService = context.getServiceImpl(IStaticFlowEntryPusherService.class);\n        switchService = context.getServiceImpl(IOFSwitchService.class);\n        \n        vips = new HashMap<String, LBVip>();\n        pools = new HashMap<String, LBPool>();\n        members = new HashMap<String, LBMember>();\n        vipIpToId = new HashMap<Integer, String>();\n        vipIpToMac = new HashMap<Integer, MacAddress>();\n        memberIpToId = new HashMap<Integer, String>();\n    }\n\n    @Override\n    public void startUp(FloodlightModuleContext context) {\n        floodlightProviderService.addOFMessageListener(OFType.PACKET_IN, this);\n        restApiService.addRestletRoutable(new LoadBalancerWebRoutable());\n""}, {""source"": ""caller_info(file:LoadBalancer.java, func:processPacketIn)"", ""result"": [{""call_line"": 174, ""call_code"": ""processPacketIn(sw, (OFPacketIn) msg, cntx)"", ""caller_code"": ""    @Override\n    public net.floodlightcontroller.core.IListener.Command\n            receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {\n        switch (msg.getType()) {\n            case PACKET_IN:\n                return processPacketIn(sw, (OFPacketIn)msg, cntx);\n            default:\n                break;\n        }\n        log.warn(\""Received unexpected message {}\"", msg);\n        return Command.CONTINUE;\n    }\n"", ""caller_start"": 169, ""file_path"": ""src/main/java/net/floodlightcontroller/loadbalancer/LoadBalancer.java""}, {""call_line"": 347, ""call_code"": ""processPacketIn(sw, (OFPacketIn) msg, cntx)"", ""caller_code"": ""\t@Override\n\tpublic Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {\n\t\tswitch (msg.getType()) {\n\t\tcase PACKET_IN:\n\t\t\treturn processPacketIn(sw, (OFPacketIn)msg, cntx);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tlog.warn(\""Received unexpected message {}\"", msg);\n\t\treturn Command.CONTINUE;\n\t}\n"", ""caller_start"": 343, ""file_path"": ""src/main/java/net/floodlightcontroller/virtualnetwork/VirtualNetworkFilter.java""}]}, {""source"": ""code_info(file:LoadBalancer.java, lines:150-200)"", ""result"": ""    \n    @Override\n    public String getName() {\n        return \""loadbalancer\"";\n    }\n\n    @Override\n    public boolean isCallbackOrderingPrereq(OFType type, String name) {\n        return (type.equals(OFType.PACKET_IN) && \n                (name.equals(\""topology\"") || \n                 name.equals(\""devicemanager\"") ||\n                 name.equals(\""virtualizer\"")));\n    }\n\n    @Override\n    public boolean isCallbackOrderingPostreq(OFType type, String name) {\n        return (type.equals(OFType.PACKET_IN) && name.equals(\""forwarding\""));\n   }\n\n    @Override\n    public net.floodlightcontroller.core.IListener.Command\n            receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {\n        switch (msg.getType()) {\n            case PACKET_IN:\n                return processPacketIn(sw, (OFPacketIn)msg, cntx);\n            default:\n                break;\n        }\n        log.warn(\""Received unexpected message {}\"", msg);\n        return Command.CONTINUE;\n    }\n\n    private net.floodlightcontroller.core.IListener.Command processPacketIn(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx) {\n        \n        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);\n        IPacket pkt = eth.getPayload(); \n \n        if (eth.isBroadcast() || eth.isMulticast()) {\n            // handle ARP for VIP\n            if (pkt instanceof ARP) {\n                // retrieve arp to determine target IP address                                                       \n                ARP arpRequest = (ARP) eth.getPayload();\n\n                IPv4Address targetProtocolAddress = arpRequest.getTargetProtocolAddress();\n\n                if (vipIpToId.containsKey(targetProtocolAddress.getInt())) {\n                    String vipId = vipIpToId.get(targetProtocolAddress.getInt());\n                    vipProxyArpReply(sw, pi, cntx, vipId);\n                    return Command.STOP;\n                }\n            }\n        } else {\n""}]","Race condition in concurrent access of shared HashMaps (vips, pools, members) in LoadBalancer.java. These collections are initialized as non-thread-safe HashMaps (LoadBalancer.java:810-812) and accessed/modified without synchronization. For example: \n1. `processPacketIn` (LoadBalancer.java:227-233) accesses `vips`, `pools`, and `members` without synchronization. \n2. `removePool` (LoadBalancer.java:90-92) modifies `pools` and `vips` without synchronization. \nConcurrent execution of these functions can lead to NULL dereference when entries are removed during access.",0.95,./github/other_context/CVE-2015-6569
4,CVE-2016-10129,CWE-476,c_cpp,The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.,https://github.com/libgit2/libgit2/commit/2fdef641fd0dd2828bd948234ae86de75221a11a,"smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line ""0004""). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.",3,"[{""func_name"": ""git_pkt_parse_line"", ""file_path"": ""src/transports/smart_pkt.c"", ""func_code"": ""int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \""PACK\"")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ACK\""))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""NAK\""))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \""ERR \""))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ok\""))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ng\""))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""unpack\""))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}"", ""target"": 0}, {""func_name"": ""parse_report"", ""file_path"": ""src/transports/smart_protocol.c"", ""func_code"": ""static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \""early EOF\"");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \""report-status: Error reported: %s\"",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \""Incomplete pack data pkt-line\"");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}"", ""target"": 0}, {""func_name"": ""add_push_report_sideband_pkt"", ""file_path"": ""src/transports/smart_protocol.c"", ""func_code"": ""static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}"", ""target"": 0}]","[{""func_name"": ""git_pkt_parse_line"", ""file_path"": ""src/transports/smart_pkt.c"", ""func_code"": ""int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \""PACK\"")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * The Git protocol does not specify empty lines as part\n\t * of the protocol. Not knowing what to do with an empty\n\t * line, we should return an error upon hitting one.\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \""Invalid empty packet\"");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ACK\""))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""NAK\""))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \""ERR \""))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ok\""))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""ng\""))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \""unpack\""))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}""}, {""func_name"": ""parse_report"", ""file_path"": ""src/transports/smart_protocol.c"", ""func_code"": ""static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \""early EOF\"");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \""report-status: Error reported: %s\"",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \""Incomplete pack data pkt-line\"");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}""}, {""func_name"": ""add_push_report_sideband_pkt"", ""file_path"": ""src/transports/smart_protocol.c"", ""func_code"": ""static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}""}]","{""caller"": 1}","[{""source"": ""caller_info(file:smart_pkt.c, func:git_pkt_parse_line)"", ""result"": [{""call_line"": 42, ""call_code"": ""git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset)"", ""caller_code"": ""int git_smart__store_refs(transport_smart *t, int flushes)\n{\n\tgitno_buffer *buf = &t->buffer;\n\tgit_vector *refs = &t->refs;\n\tint error, flush = 0, recvd;\n\tconst char *line_end = NULL;\n\tgit_pkt *pkt = NULL;\n\tsize_t i;\n\n\t/* Clear existing refs in case git_remote_connect() is called again\n\t * after git_remote_disconnect().\n\t */\n\tgit_vector_foreach(refs, i, pkt) {\n\t\tgit_pkt_free(pkt);\n\t}\n\tgit_vector_clear(refs);\n\tpkt = NULL;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\t\treturn recvd;\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \""early EOF\"");\n\t\t\t\treturn GIT_EEOF;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\t\tif (pkt->type == GIT_PKT_ERR) {\n\t\t\tgiterr_set(GITERR_NET, \""Remote error: %s\"", ((git_pkt_err *)pkt)->error);\n\t\t\tgit__free(pkt);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pkt->..."", ""caller_start"": 22, ""file_path"": ""src/transports/smart_protocol.c""}, {""call_line"": 215, ""call_code"": ""git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset)"", ""caller_code"": ""static int recv_pkt(git_pkt **out, gitno_buffer *buf)\n{\n\tconst char *ptr = buf->data, *line_end = ptr;\n\tgit_pkt *pkt = NULL;\n\tint pkt_type, error = 0, ret;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, ptr, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error == 0)\n\t\t\tbreak; /* return the pkt */\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif ((ret = gitno_recv(buf)) < 0) {\n\t\t\treturn ret;\n\t\t} else if (ret == 0) {\n\t\t\tgiterr_set(GITERR_NET, \""early EOF\"");\n\t\t\treturn GIT_EEOF;\n\t\t}\n\t} while (error);\n\n\tgitno_consume(buf, line_end);\n\tpkt_type = pkt->type;\n\tif (out != NULL)\n\t\t*out = pkt;\n\telse\n\t\tgit__free(pkt);\n\n\treturn pkt_type;\n}"", ""caller_start"": 207, ""file_path"": ""src/transports/smart_protocol.c""}, {""call_line"": 749, ""call_code"": ""git_pkt_parse_line(&pkt, line, &line_end, line_len)"", ""caller_code"": ""static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t..."", ""caller_start"": 728, ""file_path"": ""src/transports/smart_protocol.c""}, {""call_line"": 800, ""call_code"": ""git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset)"", ""caller_code"": ""static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \""early EOF\"");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\n\t\terror = 0;\n\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (pkt->type) {\n\t\t\tcase GIT_PKT_DATA:\n\t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITE..."", ""caller_start"": 790, ""file_path"": ""src/transports/smart_protocol.c""}]}]","src/transports/smart_pkt.c:438-445: git_pkt_parse_line returned 0 with *head = NULL for empty packet lines (e.g., ""0004""). Callers like parse_report (src/transports/smart_protocol.c:800) and add_push_report_sideband_pkt (src/transports/smart_protocol.c:749) used pkt without checking for NULL, causing a NULL dereference when accessing pkt->type. The patch fixes this by returning GIT_ERROR, which is propagated and checked by callers (e.g., error handling in git_smart__store_refs (src/transports/smart_protocol.c:42)).",0.95,./github/other_context/CVE-2016-10129
5,CVE-2016-9631,CWE-476,c_cpp,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-33. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.,https://github.com/tats/w3m/commit/a8cba1bd912a65ed40acded2bd5013d1f01253e1,Prevent deref null pointer in HTMLlineproc0()\n\nBug-Debian: https://github.com/tats/w3m/issues/42\nOrigin: https://anonscm.debian.org/cgit/collab-maint/w3m.git/commit/?id=ecfdcbe1131591502c5e7f9ff4f34b24c5a2db97,1,"[{""func_name"": ""HTMLlineproc0"", ""file_path"": ""file.c"", ""func_code"": ""void\nHTMLlineproc0(char *line, struct html_feed_environ *h_env, int internal)\n{\n    Lineprop mode;\n    int cmd;\n    struct readbuffer *obuf = h_env->obuf;\n    int indent, delta;\n    struct parsed_tag *tag;\n    Str tokbuf;\n    struct table *tbl = NULL;\n    struct table_mode *tbl_mode = NULL;\n    int tbl_width = 0;\n#ifdef USE_M17N\n    int is_hangul, prev_is_hangul = 0;\n#endif\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *f = fopen(\""zzzproc1\"", \""a\"");\n\tfprintf(f, \""%c%c%c%c\"",\n\t\t(obuf->flag & RB_PREMODE) ? 'P' : ' ',\n\t\t(obuf->table_level >= 0) ? 'T' : ' ',\n\t\t(obuf->flag & RB_INTXTA) ? 'X' : ' ',\n\t\t(obuf->flag & (RB_SCRIPT | RB_STYLE)) ? 'S' : ' ');\n\tfprintf(f, \""HTMLlineproc1(\\\""%s\\\"",%d,%lx)\\n\"", line, h_env->limit,\n\t\t(unsigned long)h_env);\n\tfclose(f);\n    }\n#endif\n\n    tokbuf = Strnew();\n\n  table_start:\n    if (obuf->table_level >= 0) {\n\tint level = min(obuf->table_level, MAX_TABLE - 1);\n\ttbl = tables[level];\n\ttbl_mode = &table_mode[level];\n\ttbl_width = table_width(h_env, level);\n    }\n\n    while (*line != '\\0') {\n\tchar *str, *p;\n\tint is_tag = FALSE;\n\tint pre_mode = (obuf->table_level >= 0) ? tbl_mode->pre_mode :\n\t    obuf->flag;\n\tint end_tag = (obuf->table_level >= 0) ? tbl_mode->end_tag :\n\t    obuf->end_tag;\n\n\tif (*line == '<' || obuf->status != R_ST_NORMAL) {\n\t    /* \n\t     * Tag processing\n\t     */\n\t    if (obuf->status == R_ST_EOL)\n\t\tobuf->status = R_ST_NORMAL;\n\t    else {\n\t\tread_token(h_env->tagbuf, &line, &obuf->status,\n\t\t\t   pre_mode & RB_PREMODE, obuf->status != R_ST_NORMAL);\n\t\tif (obuf->status != R_ST_NORMAL)\n\t\t    return;\n\t    }\n\t    if (h_env->tagbuf->length == 0)\n\t\tcontinue;\n\t    str = h_env->tagbuf->ptr;\n\t    if (*str == '<') {\n\t\tif (str[1] && REALLY_THE_BEGINNING_OF_A_TAG(str))\n\t\t    is_tag = TRUE;\n\t\telse if (!(pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT |\n\t\t\t\t       RB_SCRIPT | RB_STYLE | RB_TITLE))) {\n\t\t    line = Strnew_m_charp(str + 1, line, NULL)->ptr;\n\t\t    str = \""&lt;\"";\n\t\t}\n\t    }\n\t}\n\telse {\n\t    read_token(tokbuf, &line, &obuf->status, pre_mode & RB_PREMODE, 0);\n\t    if (obuf->status != R_ST_NORMAL)\t/* R_ST_AMP ? */\n\t\tobuf->status = R_ST_NORMAL;\n\t    str = tokbuf->ptr;\n\t}\n\n\tif (pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT | RB_SCRIPT |\n\t\t\tRB_STYLE | RB_TITLE)) {\n\t    if (is_tag) {\n\t\tp = str;\n\t\tif ((tag = parse_tag(&p, internal))) {\n\t\t    if (tag->tagid == end_tag ||\n\t\t\t(pre_mode & RB_INSELECT && tag->tagid == HTML_N_FORM)\n\t\t\t|| (pre_mode & RB_TITLE\n\t\t\t    && (tag->tagid == HTML_N_HEAD\n\t\t\t\t|| tag->tagid == HTML_BODY)))\n\t\t\tgoto proc_normal;\n\t\t}\n\t    }\n\t    /* title */\n\t    if (pre_mode & RB_TITLE) {\n\t\tfeed_title(str);\n\t\tcontinue;\n\t    }\n\t    /* select */\n\t    if (pre_mode & RB_INSELECT) {\n\t\tif (obuf->table_level >= 0)\n\t\t    goto proc_normal;\n\t\tfeed_select(str);\n\t\tcontinue;\n\t    }\n\t    if (is_tag) {\n\t\tif (strncmp(str, \""<!--\"", 4) && (p = strchr(str + 1, '<'))) {\n\t\t    str = Strnew_charp_n(str, p - str)->ptr;\n\t\t    line = Strnew_m_charp(p, line, NULL)->ptr;\n\t\t}\n\t\tis_tag = FALSE;\n\t    }\n\t    if (obuf->table_level >= 0)\n\t\tgoto proc_normal;\n\t    /* textarea */\n\t    if (pre_mode & RB_INTXTA) {\n\t\tfeed_textarea(str);\n\t\tcontinue;\n\t    }\n\t    /* script */\n\t    if (pre_mode & RB_SCRIPT)\n\t\tcontinue;\n\t    /* style */\n\t    if (pre_mode & RB_STYLE)\n\t\tcontinue;\n\t}\n\n      proc_normal:\n\tif (obuf->table_level >= 0) {\n\t    /* \n\t     * within table: in <table>..</table>, all input tokens\n\t     * are fed to the table renderer, and then the renderer\n\t     * makes HTML output.\n\t     */\n\t    switch (feed_table(tbl, str, tbl_mode, tbl_width, internal)) {\n\t    case 0:\n\t\t/* </table> tag */\n\t\tobuf->table_level--;\n\t\tif (obuf->table_level >= MAX_TABLE - 1)\n\t\t    continue;\n\t\tend_table(tbl);\n\t\tif (obuf->table_level >= 0) {\n\t\t    struct table *tbl0 = tables[obuf->table_level];\n\t\t    str = Sprintf(\""<table_alt tid=%d>\"", tbl0->ntable)->ptr;\n\t\t    pushTable(tbl0, tbl);\n\t\t    tbl = tbl0;\n\t\t    tbl_mode = &table_mode[obuf->table_level];\n\t\t    tbl_width = table_width(h_env, obuf->table_level);\n\t\t    feed_table(tbl, str, tbl_mode, tbl_width, TRUE);\n\t\t    continue;\n\t\t    /* continue to the next */\n\t\t}\n\t\tif (obuf->flag & RB_DEL)\n\t\t    continue;\n\t\t/* all tables have been read */\n\t\tif (tbl->vspace > 0 && !(obuf->flag & RB_IGNORE_P)) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t}\n\t\tsave_fonteffect(h_env, obuf);\n\t\tinitRenderTable();\n\t\trenderTable(tbl, tbl_width, h_env);\n\t\trestore_fonteffect(h_env, obuf);\n\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\tif (tbl->vspace > 0) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    obuf->flag |= RB_IGNORE_P;\n\t\t}\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t\tcontinue;\n\t    case 1:\n\t\t/* <table> tag */\n\t\tbreak;\n\t    default:\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (is_tag) {\n/*** Beginning of a new tag ***/\n\t    if ((tag = parse_tag(&str, internal)))\n\t\tcmd = tag->tagid;\n\t    else\n\t\tcontinue;\n\t    /* process tags */\n\t    if (HTMLtagproc1(tag, h_env) == 0) {\n\t\t/* preserve the tag for second-stage processing */\n\t\tif (parsedtag_need_reconstruct(tag))\n\t\t    h_env->tagbuf = parsedtag2str(tag);\n\t\tpush_tag(obuf, h_env->tagbuf->ptr, cmd);\n\t    }\n#ifdef ID_EXT\n\t    else {\n\t\tprocess_idattr(obuf, cmd, tag);\n\t    }\n#endif\t\t\t\t/* ID_EXT */\n\t    obuf->bp.init_flag = 1;\n\t    clear_ignore_p_flag(cmd, obuf);\n\t    if (cmd == HTML_TABLE)\n\t\tgoto table_start;\n\t    else\n\t\tcontinue;\n\t}\n\n\tif (obuf->flag & (RB_DEL | RB_S))\n\t    continue;\n\twhile (*str) {\n\t    mode = get_mctype(str);\n\t    delta = get_mcwidth(str);\n\t    if (obuf->flag & (RB_SPECIAL & ~RB_NOBR)) {\n\t\tchar ch = *str;\n\t\tif (!(obuf->flag & RB_PLAIN) && (*str == '&')) {\n\t\t    char *p = str;\n\t\t    int ech = getescapechar(&p);\n\t\t    if (ech == '\\n' || ech == '\\r') {\n\t\t\tch = '\\n';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t    else if (ech == '\\t') {\n\t\t\tch = '\\t';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t}\n\t\tif (ch != '\\n')\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif (ch == '\\n') {\n\t\t    str++;\n\t\t    if (obuf->flag & RB_IGNORE_P) {\n\t\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (obuf->flag & RB_PRE_INT)\n\t\t\tPUSH(' ');\n\t\t    else\n\t\t\tflushline(h_env, obuf, h_env->envs[h_env->envc].indent,\n\t\t\t\t  1, h_env->limit);\n\t\t}\n\t\telse if (ch == '\\t') {\n\t\t    do {\n\t\t\tPUSH(' ');\n\t\t    } while ((h_env->envs[h_env->envc].indent + obuf->pos)\n\t\t\t     % Tabstop != 0);\n\t\t    str++;\n\t\t}\n\t\telse if (obuf->flag & RB_PLAIN) {\n\t\t    char *p = html_quote_char(*str);\n\t\t    if (p) {\n\t\t\tpush_charp(obuf, 1, p, PC_ASCII);\n\t\t\tstr++;\n\t\t    }\n\t\t    else {\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t}\n\t\tif (obuf->flag & (RB_SPECIAL & ~RB_PRE_INT))\n\t\t    continue;\n\t    }\n\t    else {\n\t\tif (!IS_SPACE(*str))\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif ((mode == PC_ASCII || mode == PC_CTRL) && IS_SPACE(*str)) {\n\t\t    if (*obuf->prevchar->ptr != ' ') {\n\t\t\tPUSH(' ');\n\t\t    }\n\t\t    str++;\n\t\t}\n\t\telse {\n#ifdef USE_M17N\n\t\t    if (mode == PC_KANJI1)\n\t\t\tis_hangul = wtf_is_hangul((wc_uchar *) str);\n\t\t    else\n\t\t\tis_hangul = 0;\n\t\t    if (!SimplePreserveSpace && mode == PC_KANJI1 &&\n\t\t\t!is_hangul && !prev_is_hangul &&\n\t\t\tobuf->pos > h_env->envs[h_env->envc].indent &&\n\t\t\tStrlastchar(obuf->line) == ' ') {\n\t\t\twhile (obuf->line->length >= 2 &&\n\t\t\t       !strncmp(obuf->line->ptr + obuf->line->length -\n\t\t\t\t\t2, \""  \"", 2)\n\t\t\t       && obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t\tif (obuf->line->length >= 3 &&\n\t\t\t    obuf->prev_ctype == PC_KANJI1 &&\n\t\t\t    Strlastchar(obuf->line) == ' ' &&\n\t\t\t    obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t    }\n\t\t    prev_is_hangul = is_hangul;\n#endif\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, obuf->flag & RB_SPECIAL, delta, &str,\n\t\t\t\t   mode);\n\t\t}\n\t    }\n\t    if (need_flushline(h_env, obuf, mode)) {\n\t\tchar *bp = obuf->line->ptr + obuf->bp.len;\n\t\tchar *tp = bp - obuf->bp.tlen;\n\t\tint i = 0;\n\n\t\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t\t    i = 1;\n\n\t\tindent = h_env->envs[h_env->envc].indent;\n\t\tif (obuf->bp.pos - i > indent) {\n\t\t    Str line;\n\t\t    append_tags(obuf);\n\t\t    line = Strnew_charp(bp);\n\t\t    Strshrink(obuf->line, obuf->line->length - obuf->bp.len);\n#ifdef FORMAT_NICE\n\t\t    if (obuf->pos - i > h_env->limit)\n\t\t\tobuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    back_to_breakpoint(obuf);\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    HTMLlineproc1(line->ptr, h_env);\n\t\t}\n\t    }\n\t}\n    }\n    if (!(obuf->flag & (RB_SPECIAL | RB_INTXTA | RB_INSELECT))) {\n\tchar *tp;\n\tint i = 0;\n\n\tif (obuf->bp.pos == obuf->pos) {\n\t    tp = &obuf->line->ptr[obuf->bp.len - obuf->bp.tlen];\n\t}\n\telse {\n\t    tp = &obuf->line->ptr[obuf->line->length];\n\t}\n\n\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t    i = 1;\n\tindent = h_env->envs[h_env->envc].indent;\n\tif (obuf->pos - i > h_env->limit) {\n#ifdef FORMAT_NICE\n\t    obuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t}\n    }\n}"", ""target"": 0}]","[{""func_name"": ""HTMLlineproc0"", ""file_path"": ""file.c"", ""func_code"": ""void\nHTMLlineproc0(char *line, struct html_feed_environ *h_env, int internal)\n{\n    Lineprop mode;\n    int cmd;\n    struct readbuffer *obuf = h_env->obuf;\n    int indent, delta;\n    struct parsed_tag *tag;\n    Str tokbuf;\n    struct table *tbl = NULL;\n    struct table_mode *tbl_mode = NULL;\n    int tbl_width = 0;\n#ifdef USE_M17N\n    int is_hangul, prev_is_hangul = 0;\n#endif\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *f = fopen(\""zzzproc1\"", \""a\"");\n\tfprintf(f, \""%c%c%c%c\"",\n\t\t(obuf->flag & RB_PREMODE) ? 'P' : ' ',\n\t\t(obuf->table_level >= 0) ? 'T' : ' ',\n\t\t(obuf->flag & RB_INTXTA) ? 'X' : ' ',\n\t\t(obuf->flag & (RB_SCRIPT | RB_STYLE)) ? 'S' : ' ');\n\tfprintf(f, \""HTMLlineproc1(\\\""%s\\\"",%d,%lx)\\n\"", line, h_env->limit,\n\t\t(unsigned long)h_env);\n\tfclose(f);\n    }\n#endif\n\n    tokbuf = Strnew();\n\n  table_start:\n    if (obuf->table_level >= 0) {\n\tint level = min(obuf->table_level, MAX_TABLE - 1);\n\ttbl = tables[level];\n\ttbl_mode = &table_mode[level];\n\ttbl_width = table_width(h_env, level);\n    }\n\n    while (*line != '\\0') {\n\tchar *str, *p;\n\tint is_tag = FALSE;\n\tint pre_mode = (obuf->table_level >= 0 && tbl_mode) ?\n\t    tbl_mode->pre_mode : obuf->flag;\n\tint end_tag = (obuf->table_level >= 0 && tbl_mode) ?\n\t    tbl_mode->end_tag : obuf->end_tag;\n\n\tif (*line == '<' || obuf->status != R_ST_NORMAL) {\n\t    /* \n\t     * Tag processing\n\t     */\n\t    if (obuf->status == R_ST_EOL)\n\t\tobuf->status = R_ST_NORMAL;\n\t    else {\n\t\tread_token(h_env->tagbuf, &line, &obuf->status,\n\t\t\t   pre_mode & RB_PREMODE, obuf->status != R_ST_NORMAL);\n\t\tif (obuf->status != R_ST_NORMAL)\n\t\t    return;\n\t    }\n\t    if (h_env->tagbuf->length == 0)\n\t\tcontinue;\n\t    str = h_env->tagbuf->ptr;\n\t    if (*str == '<') {\n\t\tif (str[1] && REALLY_THE_BEGINNING_OF_A_TAG(str))\n\t\t    is_tag = TRUE;\n\t\telse if (!(pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT |\n\t\t\t\t       RB_SCRIPT | RB_STYLE | RB_TITLE))) {\n\t\t    line = Strnew_m_charp(str + 1, line, NULL)->ptr;\n\t\t    str = \""&lt;\"";\n\t\t}\n\t    }\n\t}\n\telse {\n\t    read_token(tokbuf, &line, &obuf->status, pre_mode & RB_PREMODE, 0);\n\t    if (obuf->status != R_ST_NORMAL)\t/* R_ST_AMP ? */\n\t\tobuf->status = R_ST_NORMAL;\n\t    str = tokbuf->ptr;\n\t}\n\n\tif (pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT | RB_SCRIPT |\n\t\t\tRB_STYLE | RB_TITLE)) {\n\t    if (is_tag) {\n\t\tp = str;\n\t\tif ((tag = parse_tag(&p, internal))) {\n\t\t    if (tag->tagid == end_tag ||\n\t\t\t(pre_mode & RB_INSELECT && tag->tagid == HTML_N_FORM)\n\t\t\t|| (pre_mode & RB_TITLE\n\t\t\t    && (tag->tagid == HTML_N_HEAD\n\t\t\t\t|| tag->tagid == HTML_BODY)))\n\t\t\tgoto proc_normal;\n\t\t}\n\t    }\n\t    /* title */\n\t    if (pre_mode & RB_TITLE) {\n\t\tfeed_title(str);\n\t\tcontinue;\n\t    }\n\t    /* select */\n\t    if (pre_mode & RB_INSELECT) {\n\t\tif (obuf->table_level >= 0)\n\t\t    goto proc_normal;\n\t\tfeed_select(str);\n\t\tcontinue;\n\t    }\n\t    if (is_tag) {\n\t\tif (strncmp(str, \""<!--\"", 4) && (p = strchr(str + 1, '<'))) {\n\t\t    str = Strnew_charp_n(str, p - str)->ptr;\n\t\t    line = Strnew_m_charp(p, line, NULL)->ptr;\n\t\t}\n\t\tis_tag = FALSE;\n\t    }\n\t    if (obuf->table_level >= 0)\n\t\tgoto proc_normal;\n\t    /* textarea */\n\t    if (pre_mode & RB_INTXTA) {\n\t\tfeed_textarea(str);\n\t\tcontinue;\n\t    }\n\t    /* script */\n\t    if (pre_mode & RB_SCRIPT)\n\t\tcontinue;\n\t    /* style */\n\t    if (pre_mode & RB_STYLE)\n\t\tcontinue;\n\t}\n\n      proc_normal:\n\tif (obuf->table_level >= 0 && tbl && tbl_mode) {\n\t    /* \n\t     * within table: in <table>..</table>, all input tokens\n\t     * are fed to the table renderer, and then the renderer\n\t     * makes HTML output.\n\t     */\n\t    switch (feed_table(tbl, str, tbl_mode, tbl_width, internal)) {\n\t    case 0:\n\t\t/* </table> tag */\n\t\tobuf->table_level--;\n\t\tif (obuf->table_level >= MAX_TABLE - 1)\n\t\t    continue;\n\t\tend_table(tbl);\n\t\tif (obuf->table_level >= 0) {\n\t\t    struct table *tbl0 = tables[obuf->table_level];\n\t\t    str = Sprintf(\""<table_alt tid=%d>\"", tbl0->ntable)->ptr;\n\t\t    pushTable(tbl0, tbl);\n\t\t    tbl = tbl0;\n\t\t    tbl_mode = &table_mode[obuf->table_level];\n\t\t    tbl_width = table_width(h_env, obuf->table_level);\n\t\t    feed_table(tbl, str, tbl_mode, tbl_width, TRUE);\n\t\t    continue;\n\t\t    /* continue to the next */\n\t\t}\n\t\tif (obuf->flag & RB_DEL)\n\t\t    continue;\n\t\t/* all tables have been read */\n\t\tif (tbl->vspace > 0 && !(obuf->flag & RB_IGNORE_P)) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t}\n\t\tsave_fonteffect(h_env, obuf);\n\t\tinitRenderTable();\n\t\trenderTable(tbl, tbl_width, h_env);\n\t\trestore_fonteffect(h_env, obuf);\n\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\tif (tbl->vspace > 0) {\n\t\t    int indent = h_env->envs[h_env->envc].indent;\n\t\t    do_blankline(h_env, obuf, indent, 0, h_env->limit);\n\t\t    obuf->flag |= RB_IGNORE_P;\n\t\t}\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t\tcontinue;\n\t    case 1:\n\t\t/* <table> tag */\n\t\tbreak;\n\t    default:\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (is_tag) {\n/*** Beginning of a new tag ***/\n\t    if ((tag = parse_tag(&str, internal)))\n\t\tcmd = tag->tagid;\n\t    else\n\t\tcontinue;\n\t    /* process tags */\n\t    if (HTMLtagproc1(tag, h_env) == 0) {\n\t\t/* preserve the tag for second-stage processing */\n\t\tif (parsedtag_need_reconstruct(tag))\n\t\t    h_env->tagbuf = parsedtag2str(tag);\n\t\tpush_tag(obuf, h_env->tagbuf->ptr, cmd);\n\t    }\n#ifdef ID_EXT\n\t    else {\n\t\tprocess_idattr(obuf, cmd, tag);\n\t    }\n#endif\t\t\t\t/* ID_EXT */\n\t    obuf->bp.init_flag = 1;\n\t    clear_ignore_p_flag(cmd, obuf);\n\t    if (cmd == HTML_TABLE)\n\t\tgoto table_start;\n\t    else\n\t\tcontinue;\n\t}\n\n\tif (obuf->flag & (RB_DEL | RB_S))\n\t    continue;\n\twhile (*str) {\n\t    mode = get_mctype(str);\n\t    delta = get_mcwidth(str);\n\t    if (obuf->flag & (RB_SPECIAL & ~RB_NOBR)) {\n\t\tchar ch = *str;\n\t\tif (!(obuf->flag & RB_PLAIN) && (*str == '&')) {\n\t\t    char *p = str;\n\t\t    int ech = getescapechar(&p);\n\t\t    if (ech == '\\n' || ech == '\\r') {\n\t\t\tch = '\\n';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t    else if (ech == '\\t') {\n\t\t\tch = '\\t';\n\t\t\tstr = p - 1;\n\t\t    }\n\t\t}\n\t\tif (ch != '\\n')\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif (ch == '\\n') {\n\t\t    str++;\n\t\t    if (obuf->flag & RB_IGNORE_P) {\n\t\t\tobuf->flag &= ~RB_IGNORE_P;\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (obuf->flag & RB_PRE_INT)\n\t\t\tPUSH(' ');\n\t\t    else\n\t\t\tflushline(h_env, obuf, h_env->envs[h_env->envc].indent,\n\t\t\t\t  1, h_env->limit);\n\t\t}\n\t\telse if (ch == '\\t') {\n\t\t    do {\n\t\t\tPUSH(' ');\n\t\t    } while ((h_env->envs[h_env->envc].indent + obuf->pos)\n\t\t\t     % Tabstop != 0);\n\t\t    str++;\n\t\t}\n\t\telse if (obuf->flag & RB_PLAIN) {\n\t\t    char *p = html_quote_char(*str);\n\t\t    if (p) {\n\t\t\tpush_charp(obuf, 1, p, PC_ASCII);\n\t\t\tstr++;\n\t\t    }\n\t\t    else {\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, 1, delta, &str, mode);\n\t\t}\n\t\tif (obuf->flag & (RB_SPECIAL & ~RB_PRE_INT))\n\t\t    continue;\n\t    }\n\t    else {\n\t\tif (!IS_SPACE(*str))\n\t\t    obuf->flag &= ~RB_IGNORE_P;\n\t\tif ((mode == PC_ASCII || mode == PC_CTRL) && IS_SPACE(*str)) {\n\t\t    if (*obuf->prevchar->ptr != ' ') {\n\t\t\tPUSH(' ');\n\t\t    }\n\t\t    str++;\n\t\t}\n\t\telse {\n#ifdef USE_M17N\n\t\t    if (mode == PC_KANJI1)\n\t\t\tis_hangul = wtf_is_hangul((wc_uchar *) str);\n\t\t    else\n\t\t\tis_hangul = 0;\n\t\t    if (!SimplePreserveSpace && mode == PC_KANJI1 &&\n\t\t\t!is_hangul && !prev_is_hangul &&\n\t\t\tobuf->pos > h_env->envs[h_env->envc].indent &&\n\t\t\tStrlastchar(obuf->line) == ' ') {\n\t\t\twhile (obuf->line->length >= 2 &&\n\t\t\t       !strncmp(obuf->line->ptr + obuf->line->length -\n\t\t\t\t\t2, \""  \"", 2)\n\t\t\t       && obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t\tif (obuf->line->length >= 3 &&\n\t\t\t    obuf->prev_ctype == PC_KANJI1 &&\n\t\t\t    Strlastchar(obuf->line) == ' ' &&\n\t\t\t    obuf->pos >= h_env->envs[h_env->envc].indent) {\n\t\t\t    Strshrink(obuf->line, 1);\n\t\t\t    obuf->pos--;\n\t\t\t}\n\t\t    }\n\t\t    prev_is_hangul = is_hangul;\n#endif\n\t\t    if (*str == '&')\n\t\t\tproc_escape(obuf, &str);\n\t\t    else\n\t\t\tproc_mchar(obuf, obuf->flag & RB_SPECIAL, delta, &str,\n\t\t\t\t   mode);\n\t\t}\n\t    }\n\t    if (need_flushline(h_env, obuf, mode)) {\n\t\tchar *bp = obuf->line->ptr + obuf->bp.len;\n\t\tchar *tp = bp - obuf->bp.tlen;\n\t\tint i = 0;\n\n\t\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t\t    i = 1;\n\n\t\tindent = h_env->envs[h_env->envc].indent;\n\t\tif (obuf->bp.pos - i > indent) {\n\t\t    Str line;\n\t\t    append_tags(obuf);\n\t\t    line = Strnew_charp(bp);\n\t\t    Strshrink(obuf->line, obuf->line->length - obuf->bp.len);\n#ifdef FORMAT_NICE\n\t\t    if (obuf->pos - i > h_env->limit)\n\t\t\tobuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    back_to_breakpoint(obuf);\n\t\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t\t    HTMLlineproc1(line->ptr, h_env);\n\t\t}\n\t    }\n\t}\n    }\n    if (!(obuf->flag & (RB_SPECIAL | RB_INTXTA | RB_INSELECT))) {\n\tchar *tp;\n\tint i = 0;\n\n\tif (obuf->bp.pos == obuf->pos) {\n\t    tp = &obuf->line->ptr[obuf->bp.len - obuf->bp.tlen];\n\t}\n\telse {\n\t    tp = &obuf->line->ptr[obuf->line->length];\n\t}\n\n\tif (tp > obuf->line->ptr && tp[-1] == ' ')\n\t    i = 1;\n\tindent = h_env->envs[h_env->envc].indent;\n\tif (obuf->pos - i > h_env->limit) {\n#ifdef FORMAT_NICE\n\t    obuf->flag |= RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t    flushline(h_env, obuf, indent, 0, h_env->limit);\n#ifdef FORMAT_NICE\n\t    obuf->flag &= ~RB_FILL;\n#endif\t\t\t\t/* FORMAT_NICE */\n\t}\n    }\n}""}]","{""value"": 2}","[{""source"": ""value_info(file:file.c, value:tbl)"", ""result"": {""value_trace"": [{""full_code"": ""*tbl = NULL"", ""line"": 6271, ""func_name"": ""HTMLlineproc0""}, {""full_code"": ""tbl = tables[level]"", ""line"": 6297, ""func_name"": ""HTMLlineproc0""}, {""full_code"": ""tbl = tbl0"", ""line"": 6407, ""func_name"": ""HTMLlineproc0""}], ""struct_var"": ""tbl"", ""struct_type"": ""table*"", ""struct_definition"": ""static struct table\n\nextern struct table\n\nextern struct table\n\nstruct table\n\nstruct table {\n    int row;\n    int col;\n    int maxrow;\n    int maxcol;\n    int max_rowsize;\n    int border_mode;\n    int total_width;\n    int total_height;\n    int tabcontentssize;\n    int indent;\n    int cellspacing;\n    int cellpadding;\n    int vcellpadding;\n    int vspace;\n    int flag;\n#ifdef TABLE_EXPAND\n    int real_width;\n#endif\t\t\t\t/* TABLE_EXPAND */\n    Str caption;\n#ifdef ID_EXT\n    Str id;\n#endif\n    GeneralList ***tabdata;\n    table_attr **tabattr;\n    table_attr trattr;\n#ifdef ID_EXT\n    Str **tabidvalue;\n    Str *tridvalue;\n#endif\n    short tabwidth[MAXCOL];\n    short minimum_width[MAXCOL];\n    short fixed_width[MAXCOL];\n    struct table_cell cell;\n    short *tabheight;\n    struct table_in *tables;\n    short ntable;\n    short tables_size;\n    TextList *suspended_data;\n    /* use for counting skipped spaces */\n    struct table_linfo linfo;\n#ifdef MATRIX\n    MAT *matrix;\n    VEC *vector;\n#endif\t\t\t\t/* MATRIX */\n    int sloppy_width;\n}""}}, {""source"": ""value_info(file:file.c, value:tbl_mode)"", ""result"": {""value_trace"": [{""full_code"": ""*tbl_mode = NULL"", ""line"": 6272, ""func_name"": ""HTMLlineproc0""}, {""full_code"": ""tbl_mode = &table_mode[level]"", ""line"": 6298, ""func_name"": ""HTMLlineproc0""}, {""full_code"": ""tbl_mode = &table_mode[obuf->table_level]"", ""line"": 6408, ""func_name"": ""HTMLlineproc0""}], ""struct_var"": ""tbl_mode"", ""struct_type"": ""table_mode*"", ""struct_definition"": ""static struct table_mode\n\nstruct table_mode {\n    unsigned int pre_mode;\n    char indent_level;\n    char caption;\n    short nobr_offset;\n    char nobr_level;\n    short anchor_offset;\n    unsigned char end_tag;\n}""}}]","In 'HTMLlineproc0' (file.c:6303-6307, 6388), 'tbl_mode' and 'tbl' are dereferenced without null checks. 'tbl_mode' is assigned from 'table_mode[level]' (file.c:6298, 6408), and 'tbl' from 'tables[level]' (file.c:6297, 6407). If 'obuf->table_level' is valid (>=0) but 'table_mode' or 'tables' arrays are not initialized for that level, 'tbl_mode' or 'tbl' become NULL. Dereferencing them (e.g., 'tbl_mode->pre_mode') causes a segfault. The patch adds checks for 'tbl_mode' and 'tbl' being non-NULL.",0.95,./github/other_context/CVE-2016-9631
6,CVE-2017-12858,"CWE-415, CWE-416",c_cpp,Double free vulnerability in the _zip_dirent_read function in zip_dirent.c in libzip allows attackers to have unspecified impact via unknown vectors.,https://github.com/nih-at/libzip/commit/2217022b7d1142738656d891e00b3d2d9179b796,Fix double free().\n\nFound by Brian 'geeknik' Carpenter using AFL.,1,"[{""func_name"": ""_zip_dirent_read"", ""file_path"": ""lib/zip_dirent.c"", ""func_code"": ""zip_int64_t\n_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    bool from_buffer = (buffer != NULL);\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn -1;\n    }\n\n    /* convert buffercontents to zip_dirent */\n\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n\n    /* convert to time_t */\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    /* TODO */\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            return -1;\n        }\n    }\n    else {\n        _zip_buffer_free(buffer);\n\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n            if (zip_error_code_zip(error) == ZIP_ER_EOF) {\n                zip_error_set(error, ZIP_ER_INCONS, 0);\n            }\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t    free(ef);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n\n    /* Zip64 */\n\n    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {\n\tzip_uint16_t got_len;\n        zip_buffer_t *ef_buffer;\n\tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);\n\t/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n\n\tif (zde->uncomp_size == ZIP_UINT32_MAX)\n\t    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);\n\telse if (local) {\n\t    /* From appnote.txt: This entry in the Local header MUST\n\t       include BOTH original and compressed file size fields. */\n            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */\n\t}\n\tif (zde->comp_size == ZIP_UINT32_MAX)\n\t    zde->comp_size = _zip_buffer_get_64(ef_buffer);\n\tif (!local) {\n\t    if (zde->offset == ZIP_UINT32_MAX)\n\t\tzde->offset = _zip_buffer_get_64(ef_buffer);\n\t    if (zde->disk_number == ZIP_UINT16_MAX)\n\t\tzde->disk_number = _zip_buffer_get_32(buffer);\n\t}\n\n        if (!_zip_buffer_eof(ef_buffer)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(ef_buffer);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n        _zip_buffer_free(ef_buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (!from_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */\n    if (zde->offset > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn -1;\n    }\n\n    if (!_zip_dirent_process_winzip_aes(zde, error)) {\n\tif (!from_buffer) {\n\t    _zip_buffer_free(buffer);\n\t}\n\treturn -1;\n    }\n\n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n\n    return (zip_int64_t)(size + variable_size);\n}"", ""target"": 0}]","[{""func_name"": ""_zip_dirent_read"", ""file_path"": ""lib/zip_dirent.c"", ""func_code"": ""zip_int64_t\n_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    bool from_buffer = (buffer != NULL);\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn -1;\n    }\n\n    /* convert buffercontents to zip_dirent */\n\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n\n    /* convert to time_t */\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    /* TODO */\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            return -1;\n        }\n    }\n    else {\n        _zip_buffer_free(buffer);\n\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n            if (zip_error_code_zip(error) == ZIP_ER_EOF) {\n                zip_error_set(error, ZIP_ER_INCONS, 0);\n            }\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t    free(ef);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n\n    /* Zip64 */\n\n    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {\n\tzip_uint16_t got_len;\n        zip_buffer_t *ef_buffer;\n\tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);\n\t/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n\n\tif (zde->uncomp_size == ZIP_UINT32_MAX)\n\t    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);\n\telse if (local) {\n\t    /* From appnote.txt: This entry in the Local header MUST\n\t       include BOTH original and compressed file size fields. */\n            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */\n\t}\n\tif (zde->comp_size == ZIP_UINT32_MAX)\n\t    zde->comp_size = _zip_buffer_get_64(ef_buffer);\n\tif (!local) {\n\t    if (zde->offset == ZIP_UINT32_MAX)\n\t\tzde->offset = _zip_buffer_get_64(ef_buffer);\n\t    if (zde->disk_number == ZIP_UINT16_MAX)\n\t\tzde->disk_number = _zip_buffer_get_32(buffer);\n\t}\n\n        if (!_zip_buffer_eof(ef_buffer)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(ef_buffer);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n        _zip_buffer_free(ef_buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (!from_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */\n    if (zde->offset > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn -1;\n    }\n\n    if (!_zip_dirent_process_winzip_aes(zde, error)) {\n\treturn -1;\n    }\n\n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n\n    return (zip_int64_t)(size + variable_size);\n}""}]","{""code"": 5, ""value"": 1, ""function"": 6}","[{""source"": ""code_info(file:zip_dirent.c, lines:550-610)"", ""result"": ""\t\tzde->disk_number = _zip_buffer_get_32(buffer);\n\t}\n\n        if (!_zip_buffer_eof(ef_buffer)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(ef_buffer);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n        _zip_buffer_free(ef_buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (!from_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */\n    if (zde->offset > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn -1;\n    }\n\n    if (!_zip_dirent_process_winzip_aes(zde, error)) {\n\tif (!from_buffer) {\n\t    _zip_buffer_free(buffer);\n\t}\n\treturn -1;\n    }\n\n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n\n    return (zip_int64_t)(size + variable_size);\n}\n\n\nstatic zip_string_t *\n_zip_dirent_process_ef_utf_8(const zip_dirent_t *de, zip_uint16_t id, zip_string_t *str)\n{\n    zip_uint16_t ef_len;\n    zip_uint32_t ef_crc;\n    zip_buffer_t *buffer;\n\n    const zip_uint8_t *ef = _zip_ef_get_by_id(de->extra_fields, &ef_len, id, 0, ZIP_EF_BOTH, NULL);\n\n    if (ef == NULL || ef_len < 5 || ef[0] != 1) {\n\treturn str;\n    }\n\n    if ((buffer = _zip_buffer_new((zip_uint8_t *)ef, ef_len)) == NULL) {\n        return str;\n    }\n\n    _zip_buffer_get_8(buffer);\n""}, {""source"": ""value_info(file:zip_dirent.c, value:from_buffer)"", ""result"": {""value_trace"": [{""full_code"": ""from_buffer = (buffer != NULL)"", ""line"": 347, ""func_name"": ""_zip_dirent_read""}], ""struct_var"": ""from_buffer"", ""struct_type"": ""bool"", ""struct_definition"": ""typedef char bool;""}}, {""source"": ""func_info(func:_zip_dirent_process_winzip_aes)"", ""result"": [{""code"": ""static bool\n_zip_dirent_process_winzip_aes(zip_dirent_t *de, zip_error_t *error)\n{\n    zip_uint16_t ef_len;\n    zip_buffer_t *buffer;\n    const zip_uint8_t *ef;\n    bool crc_valid;\n    zip_uint16_t en"", ""start_line"": 630, ""end_line"": 711, ""full_name"": ""_zip_dirent_process_winzip_aes"", ""file_path"": ""lib/zip_dirent.c""}]}, {""source"": ""code_info(file:zip_dirent.c, lines:300-360)"", ""result"": ""    de->encryption_method = ZIP_EM_NONE;\n    de->password = NULL;\n}\n\n\nbool\n_zip_dirent_needs_zip64(const zip_dirent_t *de, zip_flags_t flags)\n{\n    if (de->uncomp_size >= ZIP_UINT32_MAX || de->comp_size >= ZIP_UINT32_MAX\n\t|| ((flags & ZIP_FL_CENTRAL) && de->offset >= ZIP_UINT32_MAX))\n\treturn true;\n\n    return false;\n}\n\n\nzip_dirent_t *\n_zip_dirent_new(void)\n{\n    zip_dirent_t *de;\n\n    if ((de=(zip_dirent_t *)malloc(sizeof(*de))) == NULL)\n\treturn NULL;\n\n    _zip_dirent_init(de);\n    return de;\n}\n\n\n/* _zip_dirent_read(zde, fp, bufp, left, localp, error):\n   Fills the zip directory entry zde.\n\n   If buffer is non-NULL, data is taken from there; otherwise data is read from fp as needed.\n\n   If local is true, it reads a local header instead of a central directory entry.\n\n   Returns size of dirent read if successful. On error, error is filled in and -1 is returned.\n*/\n\nzip_int64_t\n_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    bool from_buffer = (buffer != NULL);\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n""}, {""source"": ""func_info(func:_zip_buffer_new)"", ""result"": [{""code"": ""zip_buffer_t *\n_zip_buffer_new(zip_uint8_t *data, zip_uint64_t size)\n{\n    bool free_data = (data == NULL);\n    zip_buffer_t *buffer;\n\n    if (data == NULL) {\n        if ((data = (zip_uint8_t *)malloc"", ""start_line"": 156, ""end_line"": 182, ""full_name"": ""_zip_buffer_new"", ""file_path"": ""lib/zip_buffer.c""}]}, {""source"": ""func_info(func:_zip_buffer_free)"", ""result"": [{""code"": ""void\n_zip_buffer_free(zip_buffer_t *buffer)\n{\n    if (buffer == NULL) {\n        return;\n    }\n\n    if (buffer->free_data) {\n        free(buffer->data);\n    }\n\n    free(buffer);\n}"", ""start_line"": 46, ""end_line"": 58, ""full_name"": ""_zip_buffer_free"", ""file_path"": ""lib/zip_buffer.c""}]}, {""source"": ""code_info(file:zip_dirent.c, lines:300-400)"", ""result"": ""    de->encryption_method = ZIP_EM_NONE;\n    de->password = NULL;\n}\n\n\nbool\n_zip_dirent_needs_zip64(const zip_dirent_t *de, zip_flags_t flags)\n{\n    if (de->uncomp_size >= ZIP_UINT32_MAX || de->comp_size >= ZIP_UINT32_MAX\n\t|| ((flags & ZIP_FL_CENTRAL) && de->offset >= ZIP_UINT32_MAX))\n\treturn true;\n\n    return false;\n}\n\n\nzip_dirent_t *\n_zip_dirent_new(void)\n{\n    zip_dirent_t *de;\n\n    if ((de=(zip_dirent_t *)malloc(sizeof(*de))) == NULL)\n\treturn NULL;\n\n    _zip_dirent_init(de);\n    return de;\n}\n\n\n/* _zip_dirent_read(zde, fp, bufp, left, localp, error):\n   Fills the zip directory entry zde.\n\n   If buffer is non-NULL, data is taken from there; otherwise data is read from fp as needed.\n\n   If local is true, it reads a local header instead of a central directory entry.\n\n   Returns size of dirent read if successful. On error, error is filled in and -1 is returned.\n*/\n\nzip_int64_t\n_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    bool from_buffer = (buffer != NULL);\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn -1;\n    }\n\n    /* convert buffercontents to zip_dirent */\n\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n\n    /* convert to time_t */\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n""}, {""source"": ""func_info(func:_zip_buffer_new_from_source)"", ""result"": [{""code"": ""zip_buffer_t *\n_zip_buffer_new_from_source(zip_source_t *src, zip_uint64_t size, zip_uint8_t *buf, zip_error_t *error)\n{\n    zip_buffer_t *buffer;\n\n    if ((buffer = _zip_buffer_new(buf, size)) == NUL"", ""start_line"": 185, ""end_line"": 201, ""full_name"": ""_zip_buffer_new_from_source"", ""file_path"": ""lib/zip_buffer.c""}]}, {""source"": ""code_info(file:zip_dirent.c, lines:400-500)"", ""result"": ""    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    /* TODO */\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            return -1;\n        }\n    }\n    else {\n        _zip_buffer_free(buffer);\n\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n            if (zip_error_code_zip(error) == ZIP_ER_EOF) {\n                zip_error_set(error, ZIP_ER_INCONS, 0);\n            }\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t    free(ef);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n""}, {""source"": ""func_info(func:_zip_dirent_process_winzip_aes)"", ""result"": [{""code"": ""static bool\n_zip_dirent_process_winzip_aes(zip_dirent_t *de, zip_error_t *error)\n{\n    zip_uint16_t ef_len;\n    zip_buffer_t *buffer;\n    const zip_uint8_t *ef;\n    bool crc_valid;\n    zip_uint16_t en"", ""start_line"": 630, ""end_line"": 711, ""full_name"": ""_zip_dirent_process_winzip_aes"", ""file_path"": ""lib/zip_dirent.c""}]}, {""source"": ""code_info(file:zip_dirent.c, lines:630-711)"", ""result"": ""static bool\n_zip_dirent_process_winzip_aes(zip_dirent_t *de, zip_error_t *error)\n{\n    zip_uint16_t ef_len;\n    zip_buffer_t *buffer;\n    const zip_uint8_t *ef;\n    bool crc_valid;\n    zip_uint16_t enc_method;\n\n\n    if (de->comp_method != ZIP_CM_WINZIP_AES) {\n\treturn true;\n    }\n\n    ef = _zip_ef_get_by_id(de->extra_fields, &ef_len, ZIP_EF_WINZIP_AES, 0, ZIP_EF_BOTH, NULL);\n\n    if (ef == NULL || ef_len < 7) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn false;\n    }\n\n    if ((buffer = _zip_buffer_new((zip_uint8_t *)ef, ef_len)) == NULL) {\n\tzip_error_set(error, ZIP_ER_INTERNAL, 0);\n        return false;\n    }\n\n    /* version */\n\n    crc_valid = true;\n    switch (_zip_buffer_get_16(buffer)) {\n    case 1:\n\tbreak;\n\n    case 2:\n\tif (de->uncomp_size < 20 /* TODO: constant */) {\n\t    crc_valid = false;\n\t}\n\tbreak;\n\n    default:\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    /* vendor */\n    if (memcmp(_zip_buffer_get(buffer, 2), \""AE\"", 2) != 0) {\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    /* mode */\n    switch (_zip_buffer_get_8(buffer)) {\n    case 1:\n\tenc_method = ZIP_EM_AES_128;\n\tbreak;\n    case 2:\n\tenc_method = ZIP_EM_AES_192;\n\tbreak;\n    case 3:\n\tenc_method = ZIP_EM_AES_256;\n\tbreak;\n    default:\n\tzip_error_set(error, ZIP_ER_ENCRNOTSUPP, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    if (ef_len != 7) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\t_zip_buffer_free(buffer);\n\treturn false;\n    }\n\n    de->crc_valid = crc_valid;\n    de->encryption_method = enc_method;\n    de->comp_method = _zip_buffer_get_16(buffer);\n\n    _zip_buffer_free(buffer);\n    return true;\n}\n\n""}, {""source"": ""func_info(func:_zip_dirent_process_winzip_aes)"", ""result"": [{""code"": ""static bool\n_zip_dirent_process_winzip_aes(zip_dirent_t *de, zip_error_t *error)\n{\n    zip_uint16_t ef_len;\n    zip_buffer_t *buffer;\n    const zip_uint8_t *ef;\n    bool crc_valid;\n    zip_uint16_t en"", ""start_line"": 630, ""end_line"": 711, ""full_name"": ""_zip_dirent_process_winzip_aes"", ""file_path"": ""lib/zip_dirent.c""}]}]","1. Buffer allocation: `_zip_dirent_read` allocates `buffer` via `_zip_buffer_new_from_source` when `from_buffer = false` (lib/zip_dirent.c:358). 2. Ownership flag: `from_buffer` is set to `false` if `buffer` is allocated by the function (lib/zip_dirent.c:347). 3. Multiple error paths in `_zip_dirent_read` free `buffer` when `!from_buffer` (lib/zip_dirent.c:552, 582, 593, 612). 4. `_zip_dirent_process_winzip_aes` also allocates and frees `buffer` in error paths (lib/zip_dirent.c:672, 679, 687, 693). 5. Patch removes one redundant free in `_zip_dirent_process_winzip_aes` (lib/zip_dirent.c:-580:-582), but other frees in `_zip_dirent_read` remain, leading to double free.",1.0,./github/other_context/CVE-2017-12858
7,CVE-2017-14318,CWE-476,c_cpp,"An issue was discovered in Xen 4.5.x through 4.9.x. The function `__gnttab_cache_flush` handles GNTTABOP_cache_flush grant table operations. It checks to see if the calling domain is the owner of the page that is to be operated on. If it is not, the owner's grant table is checked to see if a grant mapping to the calling domain exists for the page in question. However, the function does not check to see if the owning domain actually has a grant table or not. Some special domains, such as `DOMID_XEN`, `DOMID_IO` and `DOMID_COW` are created without grant tables. Hence, if __gnttab_cache_flush operates on a page owned by these special domains, it will attempt to dereference a NULL pointer in the domain struct.",https://github.com/xen-project/xen/commit/c3d830b244998b3686e2eb64db95996be5eb5e5c,"grant_table: fix GNTTABOP_cache_flush handling\n\nDon't fall over a NULL grant_table pointer when the owner of the domain\nis a system domain (DOMID_{XEN,IO} etc).\n\nThis is CVE-2017-14318 / XSA-232.\n\nReported-by: Matthew Daley <mattd@bugfuzz.com>\nSigned-off-by: Andrew Cooper <andrew.cooper3@citrix.com>\nReviewed-by: Jan Beulich <jbeulich@suse.com>",1,"[{""func_name"": ""cache_flush"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""static int cache_flush(gnttab_cache_flush_t *cflush, grant_ref_t *cur_ref)\n{\n    struct domain *d, *owner;\n    struct page_info *page;\n    unsigned long mfn;\n    void *v;\n    int ret;\n\n    if ( (cflush->offset >= PAGE_SIZE) ||\n         (cflush->length > PAGE_SIZE) ||\n         (cflush->offset + cflush->length > PAGE_SIZE) )\n        return -EINVAL;\n\n    if ( cflush->length == 0 || cflush->op == 0 )\n        return 0;\n\n    /* currently unimplemented */\n    if ( cflush->op & GNTTAB_CACHE_SOURCE_GREF )\n        return -EOPNOTSUPP;\n\n    if ( cflush->op & ~(GNTTAB_CACHE_INVAL|GNTTAB_CACHE_CLEAN) )\n        return -EINVAL;\n\n    d = rcu_lock_current_domain();\n    mfn = cflush->a.dev_bus_addr >> PAGE_SHIFT;\n\n    if ( !mfn_valid(_mfn(mfn)) )\n    {\n        rcu_unlock_domain(d);\n        return -EINVAL;\n    }\n\n    page = mfn_to_page(mfn);\n    owner = page_get_owner_and_reference(page);\n    if ( !owner )\n    {\n        rcu_unlock_domain(d);\n        return -EPERM;\n    }\n\n    if ( d != owner )\n    {\n        grant_read_lock(owner->grant_table);\n\n        ret = grant_map_exists(d, owner->grant_table, mfn, cur_ref);\n        if ( ret != 0 )\n        {\n            grant_read_unlock(owner->grant_table);\n            rcu_unlock_domain(d);\n            put_page(page);\n            return ret;\n        }\n    }\n\n    v = map_domain_page(_mfn(mfn));\n    v += cflush->offset;\n\n    if ( (cflush->op & GNTTAB_CACHE_INVAL) && (cflush->op & GNTTAB_CACHE_CLEAN) )\n        ret = clean_and_invalidate_dcache_va_range(v, cflush->length);\n    else if ( cflush->op & GNTTAB_CACHE_INVAL )\n        ret = invalidate_dcache_va_range(v, cflush->length);\n    else if ( cflush->op & GNTTAB_CACHE_CLEAN )\n        ret = clean_dcache_va_range(v, cflush->length);\n    else\n        ret = 0;\n\n    if ( d != owner )\n        grant_read_unlock(owner->grant_table);\n    unmap_domain_page(v);\n    put_page(page);\n\n    return ret;\n}"", ""target"": 0}]","[{""func_name"": ""cache_flush"", ""file_path"": ""xen/common/grant_table.c"", ""func_code"": ""static int cache_flush(gnttab_cache_flush_t *cflush, grant_ref_t *cur_ref)\n{\n    struct domain *d, *owner;\n    struct page_info *page;\n    unsigned long mfn;\n    void *v;\n    int ret;\n\n    if ( (cflush->offset >= PAGE_SIZE) ||\n         (cflush->length > PAGE_SIZE) ||\n         (cflush->offset + cflush->length > PAGE_SIZE) )\n        return -EINVAL;\n\n    if ( cflush->length == 0 || cflush->op == 0 )\n        return 0;\n\n    /* currently unimplemented */\n    if ( cflush->op & GNTTAB_CACHE_SOURCE_GREF )\n        return -EOPNOTSUPP;\n\n    if ( cflush->op & ~(GNTTAB_CACHE_INVAL|GNTTAB_CACHE_CLEAN) )\n        return -EINVAL;\n\n    d = rcu_lock_current_domain();\n    mfn = cflush->a.dev_bus_addr >> PAGE_SHIFT;\n\n    if ( !mfn_valid(_mfn(mfn)) )\n    {\n        rcu_unlock_domain(d);\n        return -EINVAL;\n    }\n\n    page = mfn_to_page(mfn);\n    owner = page_get_owner_and_reference(page);\n    if ( !owner || !owner->grant_table )\n    {\n        rcu_unlock_domain(d);\n        return -EPERM;\n    }\n\n    if ( d != owner )\n    {\n        grant_read_lock(owner->grant_table);\n\n        ret = grant_map_exists(d, owner->grant_table, mfn, cur_ref);\n        if ( ret != 0 )\n        {\n            grant_read_unlock(owner->grant_table);\n            rcu_unlock_domain(d);\n            put_page(page);\n            return ret;\n        }\n    }\n\n    v = map_domain_page(_mfn(mfn));\n    v += cflush->offset;\n\n    if ( (cflush->op & GNTTAB_CACHE_INVAL) && (cflush->op & GNTTAB_CACHE_CLEAN) )\n        ret = clean_and_invalidate_dcache_va_range(v, cflush->length);\n    else if ( cflush->op & GNTTAB_CACHE_INVAL )\n        ret = invalidate_dcache_va_range(v, cflush->length);\n    else if ( cflush->op & GNTTAB_CACHE_CLEAN )\n        ret = clean_dcache_va_range(v, cflush->length);\n    else\n        ret = 0;\n\n    if ( d != owner )\n        grant_read_unlock(owner->grant_table);\n    unmap_domain_page(v);\n    put_page(page);\n\n    return ret;\n}""}]",{},[],"The code in `cache_flush` did not verify if `owner->grant_table` was non-NULL before using it. The patch adds this check at xen/common/grant_table.c:3047, ensuring domains without grant tables (e.g., system domains) are handled safely.",0.95,./github/other_context/CVE-2017-14318
8,CVE-2017-14625,CWE-476,c_cpp,ImageMagick 7.0.7-0 Q16 has a NULL Pointer Dereference vulnerability in the function sixel_output_create in coders/sixel.c.,https://github.com/ImageMagick/ImageMagick/commit/cc797c296c30f3ec31cd02418b58a2c27549b0a9,https://github.com/ImageMagick/ImageMagick/issues/721,2,"[{""func_name"": ""WriteSIXELImage"", ""file_path"": ""coders/sixel.c"", ""func_code"": ""static MagickBooleanType WriteSIXELImage(const ImageInfo *image_info,Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  register const IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    opacity,\n    y;\n\n  sixel_output_t\n    *output;\n\n  unsigned char\n    sixel_palette[256 * 3],\n    *sixel_pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",image->filename);\n  exception=(&image->exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace);\n  opacity=(-1);\n  if (image->matte == MagickFalse)\n    {\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteType);\n    }\n  else\n    {\n      MagickRealType\n        alpha,\n        beta;\n\n      /*\n        Identify transparent colormap index.\n      */\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteBilevelMatteType);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        if (image->colormap[i].opacity != OpaqueOpacity)\n          {\n            if (opacity < 0)\n              {\n                opacity=i;\n                continue;\n              }\n            alpha=(MagickRealType) image->colormap[i].opacity;\n            beta=(MagickRealType) image->colormap[opacity].opacity;\n            if (alpha > beta)\n              opacity=i;\n          }\n      if (opacity == -1)\n        {\n          (void) SetImageType(image,PaletteBilevelMatteType);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            if (image->colormap[i].opacity != OpaqueOpacity)\n              {\n                if (opacity < 0)\n                  {\n                    opacity=i;\n                    continue;\n                  }\n                alpha=(MagickRealType) image->colormap[i].opacity;\n                beta=(MagickRealType) image->colormap[opacity].opacity;\n                if (alpha > beta)\n                  opacity=i;\n              }\n        }\n      if (opacity >= 0)\n        {\n          image->colormap[opacity].red=image->transparent_color.red;\n          image->colormap[opacity].green=image->transparent_color.green;\n          image->colormap[opacity].blue=image->transparent_color.blue;\n        }\n    }\n  /*\n    SIXEL header.\n  */\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    sixel_palette[i * 3 + 0] = ScaleQuantumToChar(image->colormap[i].red);\n    sixel_palette[i * 3 + 1] = ScaleQuantumToChar(image->colormap[i].green);\n    sixel_palette[i * 3 + 2] = ScaleQuantumToChar(image->colormap[i].blue);\n  }\n\n  /*\n    Define SIXEL pixels.\n  */\n  output = sixel_output_create(image);\n  sixel_pixels =(unsigned char *) AcquireQuantumMemory(image->columns , image->rows);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    (void) GetVirtualPixels(image,0,y,image->columns,1,exception);\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n      sixel_pixels[y * image->columns + x] = (unsigned char) ((ssize_t) GetPixelIndex(indexes + x));\n  }\n  status = sixel_encode_impl(sixel_pixels, image->columns, image->rows,\n                          sixel_palette, image->colors, -1,\n                          output);\n  sixel_pixels =(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  output = (sixel_output_t *) RelinquishMagickMemory(output);\n  (void) CloseBlob(image);\n  return(status);\n}"", ""target"": 0}, {""func_name"": ""sixel_output_create"", ""file_path"": ""coders/sixel.c"", ""func_code"": ""sixel_output_t *sixel_output_create(Image *image)\n{\n    sixel_output_t *output;\n\n    output = (sixel_output_t *) AcquireQuantumMemory(sizeof(sixel_output_t) + SIXEL_OUTPUT_PACKET_SIZE * 2, 1);\n    output->has_8bit_control = 0;\n    output->save_pixel = 0;\n    output->save_count = 0;\n    output->active_palette = (-1);\n    output->node_top = NULL;\n    output->node_free = NULL;\n    output->image = image;\n    output->pos = 0;\n\n    return output;\n}"", ""target"": 0}]","[{""func_name"": ""WriteSIXELImage"", ""file_path"": ""coders/sixel.c"", ""func_code"": ""static MagickBooleanType WriteSIXELImage(const ImageInfo *image_info,Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  register const IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    opacity,\n    y;\n\n  sixel_output_t\n    *output;\n\n  unsigned char\n    sixel_palette[256 * 3],\n    *sixel_pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\""%s\"",image->filename);\n  exception=(&image->exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace);\n  opacity=(-1);\n  if (image->matte == MagickFalse)\n    {\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteType);\n    }\n  else\n    {\n      MagickRealType\n        alpha,\n        beta;\n\n      /*\n        Identify transparent colormap index.\n      */\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteBilevelMatteType);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        if (image->colormap[i].opacity != OpaqueOpacity)\n          {\n            if (opacity < 0)\n              {\n                opacity=i;\n                continue;\n              }\n            alpha=(MagickRealType) image->colormap[i].opacity;\n            beta=(MagickRealType) image->colormap[opacity].opacity;\n            if (alpha > beta)\n              opacity=i;\n          }\n      if (opacity == -1)\n        {\n          (void) SetImageType(image,PaletteBilevelMatteType);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            if (image->colormap[i].opacity != OpaqueOpacity)\n              {\n                if (opacity < 0)\n                  {\n                    opacity=i;\n                    continue;\n                  }\n                alpha=(MagickRealType) image->colormap[i].opacity;\n                beta=(MagickRealType) image->colormap[opacity].opacity;\n                if (alpha > beta)\n                  opacity=i;\n              }\n        }\n      if (opacity >= 0)\n        {\n          image->colormap[opacity].red=image->transparent_color.red;\n          image->colormap[opacity].green=image->transparent_color.green;\n          image->colormap[opacity].blue=image->transparent_color.blue;\n        }\n    }\n  /*\n    SIXEL header.\n  */\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    sixel_palette[i * 3 + 0] = ScaleQuantumToChar(image->colormap[i].red);\n    sixel_palette[i * 3 + 1] = ScaleQuantumToChar(image->colormap[i].green);\n    sixel_palette[i * 3 + 2] = ScaleQuantumToChar(image->colormap[i].blue);\n  }\n\n  /*\n    Define SIXEL pixels.\n  */\n  output = sixel_output_create(image);\n  if (output == (sixel_output_t *) NULL)\n    ThrowWriterException(ResourceLimitError,\""MemoryAllocationFailed\"");\n  sixel_pixels =(unsigned char *) AcquireQuantumMemory(image->columns,\n    image->rows*sizeof(*sixel_pixels));\n  if (sixel_pixels == (unsigned char *) NULL)\n    {\n      output = (sixel_output_t *) RelinquishMagickMemory(output);\n      ThrowWriterException(ResourceLimitError,\""MemoryAllocationFailed\"");\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const PixelPacket\n      *p;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n      sixel_pixels[y*image->columns+x]=(unsigned char)\n        ((ssize_t) GetPixelIndex(indexes+x));\n  }\n  status = sixel_encode_impl(sixel_pixels, image->columns, image->rows,\n    sixel_palette, image->colors, -1, output);\n  sixel_pixels =(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  output = (sixel_output_t *) RelinquishMagickMemory(output);\n  (void) CloseBlob(image);\n  return(status);\n}""}, {""func_name"": ""sixel_output_create"", ""file_path"": ""coders/sixel.c"", ""func_code"": ""sixel_output_t *sixel_output_create(Image *image)\n{\n    sixel_output_t *output;\n\n    output = (sixel_output_t *) AcquireQuantumMemory(sizeof(sixel_output_t) + SIXEL_OUTPUT_PACKET_SIZE * 2, 1);\n    if (output == (sixel_output_t *) NULL)\n      return((sixel_output_t *) NULL);\n    output->has_8bit_control = 0;\n    output->save_pixel = 0;\n    output->save_count = 0;\n    output->active_palette = (-1);\n    output->node_top = NULL;\n    output->node_free = NULL;\n    output->image = image;\n    output->pos = 0;\n\n    return output;\n}""}]","{""code"": 1, ""function"": 2}","[{""source"": ""code_info(file:sixel.c, lines:545-555)"", ""result"": ""}\n\nsixel_output_t *sixel_output_create(Image *image)\n{\n    sixel_output_t *output;\n\n    output = (sixel_output_t *) AcquireQuantumMemory(sizeof(sixel_output_t) + SIXEL_OUTPUT_PACKET_SIZE * 2, 1);\n    output->has_8bit_control = 0;\n    output->save_pixel = 0;\n    output->save_count = 0;\n    output->active_palette = (-1);\n    output->node_top = NULL;\n""}, {""source"": ""func_info(func:AcquireQuantumMemory)"", ""result"": [{""code"": ""void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}"", ""start_line"": 530, ""end_line"": 539, ""full_name"": ""AcquireQuantumMemory"", ""file_path"": ""magick/memory.c""}]}, {""source"": ""func_info(func:GetVirtualPixels)"", ""result"": [{""code"": ""const PixelPacket *GetVirtualPixels(const Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_virtual_pixel_handler !=\n       (GetVirtualPixelHandler) NULL)\n    return(cache_info->methods.get_virtual_pixel_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,columns,rows,exception));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    columns,rows,cache_info->nexus_info[id],exception));\n}"", ""start_line"": 3423, ""end_line"": 3445, ""full_name"": ""GetVirtualPixels"", ""file_path"": ""magick/cache.c""}]}]","1. In coders/sixel.c:550, sixel_output_create calls AcquireQuantumMemory without checking if the returned 'output' is NULL. 2. AcquireQuantumMemory (memory.c:530-539) returns NULL on allocation failure (e.g., memory exhaustion). 3. Unchecked 'output' is used in coders/sixel.c:1294-1297 in WriteSIXELImage, leading to dereference in sixel_encode_impl when 'output' is NULL. 4. Original code lacked validation for GetVirtualPixels (cache.c:3423-3445) and memory allocation failures in sixel_pixels.",0.95,./github/other_context/CVE-2017-14625
9,CVE-2017-5836,CWE-415,c_cpp,The plist_free_data function in plist.c in libplist allows attackers to cause a denial of service (crash) via vectors involving an integer node that is treated as a PLIST_KEY and then triggers an invalid free.,https://github.com/libimobiledevice/libplist/commit/7a28a14cf6ed547dfd2e52a4db17f47242bfdef9,"bplist: Disallow key nodes with non-string node types\n\nAs reported in #86, the binary plist parser would force the type of the\nkey node to be of type PLIST_KEY while the node might be of a different\ni.e. non-string type. A following plist_free() might then call free() on\nan invalid pointer; e.g. if the node is of type integer, its value would\nbe considered a pointer, and free() would cause an error.\nWe prevent this issue by disallowing non-string key nodes during parsing.",1,"[{""func_name"": ""parse_dict_node"", ""file_path"": ""src/bplist.c"", ""func_code"": ""static plist_t parse_dict_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_i = 0, str_j = 0;\n    uint64_t index1, index2;\n    plist_data_t data = plist_new_plist_data();\n    const char *const end_data = bplist->data + bplist->size;\n    const char *index1_ptr = NULL;\n    const char *index2_ptr = NULL;\n\n    data->type = PLIST_DICT;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_i = j * bplist->dict_size;\n        str_j = (j + size) * bplist->dict_size;\n        index1_ptr = (*bnode) + str_i;\n        index2_ptr = (*bnode) + str_j;\n\n        if ((index1_ptr < bplist->data || index1_ptr + bplist->dict_size >= end_data) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->dict_size >= end_data)) {\n            plist_free(node);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->dict_size);\n        index2 = UINT_TO_HOST(index2_ptr, bplist->dict_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        if (index2 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process key node */\n        plist_t key = parse_bin_node_at_index(bplist, index1);\n        if (!key) {\n            plist_free(node);\n            return NULL;\n        }\n        /* enforce key type */\n        plist_get_data(key)->type = PLIST_KEY;\n        if (!plist_get_data(key)->strval) {\n            fprintf(stderr, \""ERROR: Malformed binary plist dict, invalid key node encountered!\\n\"");\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index2);\n        if (!val) {\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, key);\n        node_attach(node, val);\n    }\n\n    return node;\n}"", ""target"": 0}]","[{""func_name"": ""parse_dict_node"", ""file_path"": ""src/bplist.c"", ""func_code"": ""static plist_t parse_dict_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_i = 0, str_j = 0;\n    uint64_t index1, index2;\n    plist_data_t data = plist_new_plist_data();\n    const char *const end_data = bplist->data + bplist->size;\n    const char *index1_ptr = NULL;\n    const char *index2_ptr = NULL;\n\n    data->type = PLIST_DICT;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_i = j * bplist->dict_size;\n        str_j = (j + size) * bplist->dict_size;\n        index1_ptr = (*bnode) + str_i;\n        index2_ptr = (*bnode) + str_j;\n\n        if ((index1_ptr < bplist->data || index1_ptr + bplist->dict_size >= end_data) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->dict_size >= end_data)) {\n            plist_free(node);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->dict_size);\n        index2 = UINT_TO_HOST(index2_ptr, bplist->dict_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        if (index2 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process key node */\n        plist_t key = parse_bin_node_at_index(bplist, index1);\n        if (!key) {\n            plist_free(node);\n            return NULL;\n        }\n\n        if (plist_get_data(key)->type != PLIST_STRING) {\n            fprintf(stderr, \""ERROR: Malformed binary plist dict, invalid node type for key!\\n\"");\n            plist_free(node);\n            return NULL;\n        }\n\n        /* enforce key type */\n        plist_get_data(key)->type = PLIST_KEY;\n        if (!plist_get_data(key)->strval) {\n            fprintf(stderr, \""ERROR: Malformed binary plist dict, invalid key node encountered!\\n\"");\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index2);\n        if (!val) {\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, key);\n        node_attach(node, val);\n    }\n\n    return node;\n}""}]","{""function"": 1, ""code"": 2, ""caller"": 1}","[{""source"": ""func_info(file:bplist.c, func:parse_dict_node)"", ""result"": [{""code"": ""static plist_t parse_dict_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_i = 0, str_j = 0;\n    uint64_t index1, index2;\n    plist_data_t data = plist_new_plist_data();\n    const char *const end_data = bplist->data + bplist->size;\n    const char *index1_ptr = NULL;\n    const char *index2_ptr = NULL;\n\n    data->type = PLIST_DICT;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_i = j * bplist->dict_size;\n        str_j = (j + size) * bplist->dict_size;\n        index1_ptr = (*bnode) + str_i;\n        index2_ptr = (*bnode) + str_j;\n\n        if ((index1_ptr < bplist->data || index1_ptr + bplist->dict_size >= end_data) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->dict_size >= end_data)) {\n            plist_free(node);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->dict_size);\n        index2 = UINT_TO_HO..."", ""start_line"": 399, ""end_line"": 466, ""full_name"": ""parse_dict_node"", ""file_path"": ""src/bplist.c""}]}, {""source"": ""code_info(file:bplist.c, lines:420-460)"", ""result"": ""        if ((index1_ptr < bplist->data || index1_ptr + bplist->dict_size >= end_data) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->dict_size >= end_data)) {\n            plist_free(node);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->dict_size);\n        index2 = UINT_TO_HOST(index2_ptr, bplist->dict_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        if (index2 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process key node */\n        plist_t key = parse_bin_node_at_index(bplist, index1);\n        if (!key) {\n            plist_free(node);\n            return NULL;\n        }\n        /* enforce key type */\n        plist_get_data(key)->type = PLIST_KEY;\n        if (!plist_get_data(key)->strval) {\n            fprintf(stderr, \""ERROR: Malformed binary plist dict, invalid key node encountered!\\n\"");\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index2);\n        if (!val) {\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, key);\n""}, {""source"": ""caller_info(file:bplist.c, func:parse_dict_node)"", ""result"": [{""call_line"": 654, ""call_code"": ""parse_dict_node(bplist, object, size)"", ""caller_code"": ""static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)\n{\n    uint16_t type = 0;\n    uint64_t size = 0;\n\n    if (!object)\n        return NULL;\n\n    type = (**object) & BPLIST_MASK;\n    size = (**object) & BPLIST_FILL;\n    (*object)++;\n\n    switch (type)\n    {\n\n    case BPLIST_NULL:\n        switch (size)\n        {\n\n        case BPLIST_TRUE:\n        {\n            plist_data_t data = plist_new_plist_data();\n            data->type = PLIST_BOOLEAN;\n            data->boolval = TRUE;\n            data->length = 1;\n            return node_create(NULL, data);\n        }\n\n        case BPLIST_FALSE:\n        {\n            plist_data_t data = plist_new_plist_data();\n            data->type = PLIST_BOOLEAN;\n            data->boolval = FALSE;\n            data->length = 1;\n            return node_create(NULL, data);\n        }\n\n        case BPLIST_NULL:\n        default:\n            return NULL;\n        }\n\n    case BPLIST_UINT:\n        if (*object - bplist->data + (uint64_t)(1 << ..."", ""caller_start"": 528, ""file_path"": ""src/bplist.c""}]}, {""source"": ""code_info(file:bplist.c, lines:528-600)"", ""result"": ""static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)\n{\n    uint16_t type = 0;\n    uint64_t size = 0;\n\n    if (!object)\n        return NULL;\n\n    type = (**object) & BPLIST_MASK;\n    size = (**object) & BPLIST_FILL;\n    (*object)++;\n\n    switch (type)\n    {\n\n    case BPLIST_NULL:\n        switch (size)\n        {\n\n        case BPLIST_TRUE:\n        {\n            plist_data_t data = plist_new_plist_data();\n            data->type = PLIST_BOOLEAN;\n            data->boolval = TRUE;\n            data->length = 1;\n            return node_create(NULL, data);\n        }\n\n        case BPLIST_FALSE:\n        {\n            plist_data_t data = plist_new_plist_data();\n            data->type = PLIST_BOOLEAN;\n            data->boolval = FALSE;\n            data->length = 1;\n            return node_create(NULL, data);\n        }\n\n        case BPLIST_NULL:\n        default:\n            return NULL;\n        }\n\n    case BPLIST_UINT:\n        if (*object - bplist->data + (uint64_t)(1 << size) >= bplist->size)\n            return NULL;\n        return parse_uint_node(object, size);\n\n    case BPLIST_REAL:\n        if (*object - bplist->data + (uint64_t)(1 << size) >= bplist->size)\n            return NULL;\n        return parse_real_node(object, size);\n\n    case BPLIST_DATE:\n        if (3 != size)\n            return NULL;\n        if (*object - bplist->data + (uint64_t)(1 << size) >= bplist->size)\n            return NULL;\n        return parse_date_node(object, size);\n\n    case BPLIST_DATA:\n        if (BPLIST_FILL == size) {\n            plist_t size_node = parse_bin_node(bplist, object);\n            if (plist_get_node_type(size_node) != PLIST_UINT)\n                return NULL;\n            plist_get_uint_val(size_node, &size);\n            plist_free(size_node);\n        }\n\n        if (*object - bplist->data + size >= bplist->size)\n            return NULL;\n        return parse_data_node(object, size);\n\n    case BPLIST_STRING:\n        if (BPLIST_FILL == size) {\n""}]","src/bplist.c:447-449 (parse_dict_node) enforces PLIST_KEY on key nodes without verifying they are originally PLIST_STRING. Non-string nodes (e.g., PLIST_UINT from src/bplist.c:528-600) are treated as keys. During freeing in plist_free(), the node's data (integer) is misinterpreted as a pointer. The trigger is a malformed binary plist with non-string keys parsed via parse_bin_node (src/bplist.c:528-600) → parse_dict_node (src/bplist.c:447).",0.95,./github/other_context/CVE-2017-5836
10,CVE-2017-7274,CWE-476,c_cpp,The r_pkcs7_parse_cms function in libr/util/r_pkcs7.c in radare2 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted PE file.,https://github.com/radareorg/radare2/commit/7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf,Fix #7152 - Null deref in cms,1,"[{""func_name"": ""r_pkcs7_parse_cms"", ""file_path"": ""libr/util/r_pkcs7.c"", ""func_code"": ""RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}"", ""target"": 0}]","[{""func_name"": ""r_pkcs7_parse_cms"", ""file_path"": ""libr/util/r_pkcs7.c"", ""func_code"": ""RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects ||\n\t\t!object->list.objects[0] || !object->list.objects[1] ||\n\t\tobject->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}""}]","{""function"": 1, ""value"": 2, ""code"": 1}","[{""source"": ""func_info(func:r_asn1_create_object)"", ""result"": [{""code"": ""RASN1Object *r_asn1_create_object (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object = asn1_parse_header (buffer, length);\n\tif (object && (object->form == FORM_CONSTRUCTED || object->tag == TAG_BITSTRING || object->tag == TAG_OCTETSTRING)) {\n\t\tut32 i, count;\n\t\tRASN1Object *inner = NULL;\n\t\tconst ut8 *next = object->sector;\n\t\tconst ut8 *end = next + object->length;\n\t\tif (end > buffer + length) {\n\t\t\tfree (object);\n\t\t\treturn NULL;\n\t\t}\n\t\tcount = r_asn1_count_objects (object->sector, object->length);\n\t\tif (count > 0) {\n\t\t\tobject->list.length = count;\n\t\t\tobject->list.objects = R_NEWS0 (RASN1Object*, count);\n\t\t\tif (!object->list.objects) {\n\t\t\t\tr_asn1_free_object (object);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (i = 0; next >= buffer && next < end && i < count; ++i) {\n\t\t\t\tinner = r_asn1_create_object (next, end - next);\n\t\t\t\tif (!inner || next == inner->sector) {\n\t\t\t\t\tr_asn1_free_object (inner);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext = inner->sector + inner->length;\n\t\t\t\tR_PTR_MOVE (object->list.objects[i], in..."", ""start_line"": 398, ""end_line"": 429, ""full_name"": ""r_asn1_create_object"", ""file_path"": ""libr/util/r_asn1.c""}]}, {""source"": ""value_info(file:r_pkcs7.c, value:object->list.objects)"", ""result"": {""value_trace"": [{""full_code"": ""object->list.objects = NULL"", ""line"": 444, ""func_name"": ""r_asn1_free_object""}], ""struct_var"": ""object"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:r_asn1.c, lines:430-450)"", ""result"": ""\nvoid r_asn1_free_object (RASN1Object *object) {\n\tut32 i;\n\tif (!object) {\n\t\treturn;\n\t}\n\t//this shall not be freed. it's a pointer into the buffer.\n\tobject->sector = 0;\n\tif (object->list.objects) {\n\t\tfor (i = 0; i < object->list.length; ++i) {\n\t\t\tr_asn1_free_object (object->list.objects[i]);\n\t\t}\n\t\tR_FREE (object->list.objects);\n\t}\n\tobject->list.objects = NULL;\n\tobject->list.length = 0;\n\tR_FREE (object);\n}\n\nvoid r_asn1_free_string (RASN1String* str) {\n\tif (str) {\n\t\tif (str->allocated) {\n""}, {""source"": ""value_info(file:r_asn1.c, value:object->list)"", ""result"": {""value_trace"": [{""full_code"": ""object->list.length = count"", ""line"": 411, ""func_name"": ""r_asn1_create_object""}, {""full_code"": ""object->list.objects = NULL"", ""line"": 444, ""func_name"": ""r_asn1_free_object""}, {""full_code"": ""object->list.length = 0"", ""line"": 445, ""func_name"": ""r_asn1_free_object""}], ""struct_var"": ""object"", ""struct_type"": null, ""struct_definition"": null}}]","libr/util/r_pkcs7.c:285-287: The original code assumes object->list.objects[0]/[1] are non-NULL. In libr/util/r_asn1.c:398-429, r_asn1_create_object allocates object->list.objects via R_NEWS0 (zero-initialized) but may break early during inner object creation (e.g., if 'inner' is NULL). This leaves object->list.objects[1] as NULL when count=2. Accessing object->list.objects[1]->list.length without validating the pointer causes a NULL dereference. The 'list' structure (libr/util/r_asn1.c) contains 'length' and 'objects' members, with 'objects' being an array of RASN1Object* that may contain NULL entries in error cases.",0.95,./github/other_context/CVE-2017-7274
11,CVE-2017-7453,"CWE-476, CWE-125",c_cpp,The iwgif_record_pixel function in imagew-gif.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted file.,https://github.com/jsummers/imageworsener/commit/dc74009a3cbcbc51dd29b3856043754d3c107449,"Fixed a GIF decoding bug (buffer overrun)\n\nFixes issues #9, #11",2,"[{""func_name"": ""iwgif_read_image"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static int iwgif_read_image(struct iwgifrcontext *rctx)\n{\n\tint retval=0;\n\tstruct lzwdeccontext d;\n\tsize_t subblocksize;\n\tint has_local_ct;\n\tint local_ct_size;\n\n\tunsigned int root_codesize;\n\n\t// Read image header information\n\tif(!iwgif_read(rctx,rctx->rbuf,9)) goto done;\n\n\trctx->image_left = (int)iw_get_ui16le(&rctx->rbuf[0]);\n\trctx->image_top = (int)iw_get_ui16le(&rctx->rbuf[2]);\n\t// image_left and _top may be updated in iwgif_init_screen().\n\n\trctx->image_width = (int)iw_get_ui16le(&rctx->rbuf[4]);\n\trctx->image_height = (int)iw_get_ui16le(&rctx->rbuf[6]);\n\n\trctx->interlaced = (int)((rctx->rbuf[8]>>6)&0x01);\n\n\thas_local_ct = (int)((rctx->rbuf[8]>>7)&0x01);\n\tif(has_local_ct) {\n\t\tlocal_ct_size = (int)(rctx->rbuf[8]&0x07);\n\t\trctx->colortable.num_entries = 1<<(1+local_ct_size);\n\t}\n\n\tif(has_local_ct) {\n\t\t// We only support one image, so we don't need to keep both a global and a\n\t\t// local color table. If an image has both, the local table will overwrite\n\t\t// the global one.\n\t\tif(!iwgif_read_color_table(rctx,&rctx->colortable)) goto done;\n\t}\n\n\t// Make the transparent color transparent.\n\tif(rctx->has_transparency) {\n\t    rctx->colortable.entry[rctx->trans_color_index].a = 0;\n\t}\n\n\t// Read LZW code size\n\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\troot_codesize = (unsigned int)rctx->rbuf[0];\n\n\t// The spec does not allow the \""minimum code size\"" to be less than 2.\n\t// Sizes >=12 are impossible to support.\n\t// There's no reason for the size to be larger than 8, but the spec\n\t// does not seem to forbid it.\n\tif(root_codesize<2 || root_codesize>11) {\n\t\tiw_set_error(rctx->ctx,\""Invalid LZW minimum code size\"");\n\t\tgoto done;\n\t}\n\n\t// The creation of the global \""screen\"" was deferred until now, to wait until\n\t// we know whether the image has transparency.\n\t// (And if !rctx->include_screen, to wait until we know the size of the image.)\n\tif(!iwgif_init_screen(rctx)) goto done;\n\n\trctx->total_npixels = rctx->image_width * rctx->image_height;\n\n\tif(!iwgif_make_row_pointers(rctx)) goto done;\n\n\tlzw_init(&d,root_codesize);\n\tlzw_clear(&d);\n\n\twhile(1) {\n\t\t// Read size of next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\t\tsubblocksize = (size_t)rctx->rbuf[0];\n\t\tif(subblocksize==0) break;\n\n\t\t// Read next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,subblocksize)) goto done;\n\t\tif(!lzw_process_bytes(rctx,&d,rctx->rbuf,subblocksize)) goto done;\n\n\t\tif(d.eoi_flag) break;\n\n\t\t// Stop if we reached the end of the image. We don't care if we've read an\n\t\t// EOI code or not.\n\t\tif(rctx->pixels_set >= rctx->total_npixels) break;\n\t}\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}"", ""target"": 0}, {""func_name"": ""iwgif_record_pixel"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static void iwgif_record_pixel(struct iwgifrcontext *rctx, unsigned int coloridx,\n\t\tint offset)\n{\n\tstruct iw_image *img;\n\tunsigned int r,g,b,a;\n\tsize_t pixnum;\n\tsize_t xi,yi; // position in image coordinates\n\tsize_t xs /*,ys*/; // position in screen coordinates\n\tiw_byte *ptr;\n\n\timg = rctx->img;\n\n\t// Figure out which pixel to set.\n\n\tpixnum = rctx->pixels_set + offset;\n\txi = pixnum%rctx->image_width;\n\tyi = pixnum/rctx->image_width;\n\txs = rctx->image_left + xi;\n\t// ys = rctx->image_top + yi;\n\n\t// Check if the x-coordinate is on the screen.\n\tif(xs>=(size_t)rctx->screen_width) return;\n\n\t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n\t// is on the screen. The easiest way is to check if the row pointer is NULL.\n\tif(rctx->row_pointers[yi]==NULL) return;\n\n\t// Figure out what color to set the pixel to.\n\n\tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n\t\tr=rctx->colortable.entry[coloridx].r;\n\t\tg=rctx->colortable.entry[coloridx].g;\n\t\tb=rctx->colortable.entry[coloridx].b;\n\t\ta=rctx->colortable.entry[coloridx].a;\n\t}\n\telse {\n\t\treturn; // Illegal palette index\n\t}\n\n\t// Set the pixel.\n\n\tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n\tptr[0]=r; ptr[1]=g; ptr[2]=b;\n\tif(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tptr[3]=a;\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""iwgif_read_image"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static int iwgif_read_image(struct iwgifrcontext *rctx)\n{\n\tint retval=0;\n\tstruct lzwdeccontext d;\n\tsize_t subblocksize;\n\tint has_local_ct;\n\tint local_ct_size;\n\n\tunsigned int root_codesize;\n\n\t// Read image header information\n\tif(!iwgif_read(rctx,rctx->rbuf,9)) goto done;\n\n\trctx->image_left = (int)iw_get_ui16le(&rctx->rbuf[0]);\n\trctx->image_top = (int)iw_get_ui16le(&rctx->rbuf[2]);\n\t// image_left and _top may be updated in iwgif_init_screen().\n\n\trctx->image_width = (int)iw_get_ui16le(&rctx->rbuf[4]);\n\trctx->image_height = (int)iw_get_ui16le(&rctx->rbuf[6]);\n\n\trctx->interlaced = (int)((rctx->rbuf[8]>>6)&0x01);\n\n\thas_local_ct = (int)((rctx->rbuf[8]>>7)&0x01);\n\tif(has_local_ct) {\n\t\tlocal_ct_size = (int)(rctx->rbuf[8]&0x07);\n\t\trctx->colortable.num_entries = 1<<(1+local_ct_size);\n\t}\n\n\tif(has_local_ct) {\n\t\t// We only support one image, so we don't need to keep both a global and a\n\t\t// local color table. If an image has both, the local table will overwrite\n\t\t// the global one.\n\t\tif(!iwgif_read_color_table(rctx,&rctx->colortable)) goto done;\n\t}\n\n\t// Make the transparent color transparent.\n\tif(rctx->has_transparency) {\n\t    rctx->colortable.entry[rctx->trans_color_index].a = 0;\n\t}\n\n\t// Read LZW code size\n\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\troot_codesize = (unsigned int)rctx->rbuf[0];\n\n\t// The spec does not allow the \""minimum code size\"" to be less than 2.\n\t// Sizes >=12 are impossible to support.\n\t// There's no reason for the size to be larger than 8, but the spec\n\t// does not seem to forbid it.\n\tif(root_codesize<2 || root_codesize>11) {\n\t\tiw_set_error(rctx->ctx,\""Invalid LZW minimum code size\"");\n\t\tgoto done;\n\t}\n\n\t// The creation of the global \""screen\"" was deferred until now, to wait until\n\t// we know whether the image has transparency.\n\t// (And if !rctx->include_screen, to wait until we know the size of the image.)\n\tif(!iwgif_init_screen(rctx)) goto done;\n\n\trctx->total_npixels = (size_t)rctx->image_width * (size_t)rctx->image_height;\n\n\tif(!iwgif_make_row_pointers(rctx)) goto done;\n\n\tlzw_init(&d,root_codesize);\n\tlzw_clear(&d);\n\n\twhile(1) {\n\t\t// Read size of next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,1)) goto done;\n\t\tsubblocksize = (size_t)rctx->rbuf[0];\n\t\tif(subblocksize==0) break;\n\n\t\t// Read next subblock\n\t\tif(!iwgif_read(rctx,rctx->rbuf,subblocksize)) goto done;\n\t\tif(!lzw_process_bytes(rctx,&d,rctx->rbuf,subblocksize)) goto done;\n\n\t\tif(d.eoi_flag) break;\n\n\t\t// Stop if we reached the end of the image. We don't care if we've read an\n\t\t// EOI code or not.\n\t\tif(rctx->pixels_set >= rctx->total_npixels) break;\n\t}\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}""}, {""func_name"": ""iwgif_record_pixel"", ""file_path"": ""src/imagew-gif.c"", ""func_code"": ""static void iwgif_record_pixel(struct iwgifrcontext *rctx, unsigned int coloridx,\n\t\tint offset)\n{\n\tstruct iw_image *img;\n\tunsigned int r,g,b,a;\n\tsize_t pixnum;\n\tsize_t xi,yi; // position in image coordinates\n\tsize_t xs,ys; // position in screen coordinates\n\tiw_byte *ptr;\n\n\timg = rctx->img;\n\n\t// Figure out which pixel to set.\n\n\tpixnum = rctx->pixels_set + offset;\n\txi = pixnum%rctx->image_width;\n\tyi = pixnum/rctx->image_width;\n\txs = rctx->image_left + xi;\n\tys = rctx->image_top + yi;\n\n\t// Make sure the coordinate is within the image, and on the screen.\n\tif(yi>=(size_t)rctx->image_height) return;\n\tif(xs>=(size_t)rctx->screen_width) return;\n\tif(ys>=(size_t)rctx->screen_height) return;\n\n\t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n\t// is on the screen. The easiest way is to check if the row pointer is NULL.\n\tif(rctx->row_pointers[yi]==NULL) return;\n\n\t// Figure out what color to set the pixel to.\n\n\tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n\t\tr=rctx->colortable.entry[coloridx].r;\n\t\tg=rctx->colortable.entry[coloridx].g;\n\t\tb=rctx->colortable.entry[coloridx].b;\n\t\ta=rctx->colortable.entry[coloridx].a;\n\t}\n\telse {\n\t\treturn; // Illegal palette index\n\t}\n\n\t// Set the pixel.\n\n\tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n\tptr[0]=r; ptr[1]=g; ptr[2]=b;\n\tif(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tptr[3]=a;\n\t}\n}""}]","{""code"": 3, ""value"": 3}","[{""source"": ""code_info(file:imagew-gif.c, lines:220-230)"", ""result"": ""\n\t// Because of how we de-interlace, it's not obvious whether the Y coordinate\n\t// is on the screen. The easiest way is to check if the row pointer is NULL.\n\tif(rctx->row_pointers[yi]==NULL) return;\n\n\t// Figure out what color to set the pixel to.\n\n\tif(coloridx<(unsigned int)rctx->colortable.num_entries) {\n\t\tr=rctx->colortable.entry[coloridx].r;\n\t\tg=rctx->colortable.entry[coloridx].g;\n\t\tb=rctx->colortable.entry[coloridx].b;\n\t\ta=rctx->colortable.entry[coloridx].a;\n""}, {""source"": ""value_info(file:imagew-gif.c, value:ptr)"", ""result"": {""value_trace"": [{""full_code"": ""ptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi]"", ""line"": 239, ""func_name"": ""iwgif_record_pixel""}], ""struct_var"": ""ptr"", ""struct_type"": ""uint8_t*"", ""struct_definition"": ""uint8_t""}}, {""source"": ""value_info(file:imagew-gif.c, value:img)"", ""result"": {""value_trace"": [{""full_code"": ""img = rctx->img"", ""line"": 208, ""func_name"": ""iwgif_record_pixel""}, {""full_code"": ""img = rctx->img"", ""line"": 457, ""func_name"": ""iwgif_init_screen""}, {""full_code"": ""img = rctx->img"", ""line"": 522, ""func_name"": ""iwgif_make_row_pointers""}], ""struct_var"": ""img"", ""struct_type"": ""iw_image*"", ""struct_definition"": ""struct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image\n\nstruct iw_image {\n\tint imgtype;  // IW_IMGTYPE_*\n\tint bit_depth;\n\tint sampletype; // IW_SAMPLETYPE_*\n\n\t// This is the logical width and height, which does not necessarily\n\t// indicate the order of the pixels in ->pixels.\n\t// (The order is indicated by ->orient_transform.)\n\tint width, height;\n\n\t// Caution: Multi-byte samples with an integer data type use big-endian\n\t// byte order, while floating-point samples use the native byte order of\n\t// the host system (usually little-endian).\n\tiw_byte *pixels;\n\tsize_t bpr; // bytes per row\n\n\t// Describes orientation transformations that need to be made to the\n\t// pixels.\n\t// Used with input images only.\n\tunsigned int orient_transform;\n\n\tint native_grayscale; // For input images: Was the image encoded as grayscale?\n\tint density_code; // IW_DENSITY_*\n\tdouble density_x, density_y;\n\tint has_colorkey_trns;\n\tunsigned int colorkey[3]; // Indexed by IW_CHANNELTYPE_[RED..BLUE]\n\tint reduced_maxcolors;\n\tunsigned int maxcolorcode[5];  // Indexed by IW_CHAN...""}}, {""source"": ""code_info(file:imagew-gif.c, lines:522-540)"", ""result"": ""\timg = rctx->img;\n\n\tif(rctx->interlaced) {\n\t\t// Image is interlaced. Rearrange the row pointers, so that it will be\n\t\t// de-interlaced as it is decoded.\n\t\trowcount=0;\n\t\tfor(pass=1;pass<=4;pass++) {\n\t\t\tif(pass==1) { startrow=0; rowskip=8; }\n\t\t\telse if(pass==2) { startrow=4; rowskip=8; }\n\t\t\telse if(pass==3) { startrow=2; rowskip=4; }\n\t\t\telse { startrow=1; rowskip=2; }\n\n\t\t\tfor(row=startrow;row<rctx->image_height;row+=rowskip) {\n\t\t\t\tif(rctx->image_top+row < rctx->screen_height) {\n\t\t\t\t\trctx->row_pointers[rowcount] = &img->pixels[(rctx->image_top+row)*img->bpr + (rctx->image_left)*rctx->bytes_per_pixel];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trctx->row_pointers[rowcount] = NULL;\n\t\t\t\t}\n\t\t\t\trowcount++;\n""}, {""source"": ""value_info(file:imagew-gif.c, value:rctx->row_pointers)"", ""result"": {""value_trace"": [{""full_code"": ""rctx->row_pointers = (iw_byte**)iw_malloc(rctx->ctx, sizeof(iw_byte*)*rctx->image_height)"", ""line"": 519, ""func_name"": ""iwgif_make_row_pointers""}], ""struct_var"": ""rctx"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:imagew-gif.c, lines:239-245)"", ""result"": ""\tptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi];\n\tptr[0]=r; ptr[1]=g; ptr[2]=b;\n\tif(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tptr[3]=a;\n\t}\n}\n\n////////////////////////////////////////////////////////\n""}]","In src/imagew-gif.c:iwgif_record_pixel, coordinates (yi, xs, ys) derived from GIF data were not validated against image/screen dimensions before being used to index into rctx->row_pointers (src/imagew-gif.c:214-216). This allowed out-of-bounds memory access via ptr = &rctx->row_pointers[yi][rctx->bytes_per_pixel*xi] (src/imagew-gif.c:239). The patch adds bounds checks for yi, xs, and ys (src/imagew-gif.c:214-216) and prevents overflow in total_npixels calculation (src/imagew-gif.c:652).",0.95,./github/other_context/CVE-2017-7453
12,CVE-2018-1000877,CWE-415,c_cpp,"libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted RAR archive.",https://github.com/libarchive/libarchive/commit/021efa522ad729ff0f5806c4ce53e4a6cc1daa31,"Avoid a double-free when a window size of 0 is specified\n\nnew_size can be 0 with a malicious or corrupted RAR archive.\n\nrealloc(area, 0) is equivalent to free(area), so the region would\nbe free()d here and the free()d again in the cleanup function.\n\nFound with a setup running AFL, afl-rb, and qsym.",1,"[{""func_name"": ""parse_codes"", ""file_path"": ""libarchive/archive_read_support_format_rar.c"", ""func_code"": ""static int\nparse_codes(struct archive_read *a)\n{\n  int i, j, val, n, r;\n  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;\n  unsigned int maxorder;\n  struct huffman_code precode;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  free_codes(a);\n\n  /* Skip to the next byte */\n  rar_br_consume_unalined_bits(br);\n\n  /* PPMd block flag */\n  if (!rar_br_read_ahead(a, br, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)\n  {\n    rar_br_consume(br, 1);\n    if (!rar_br_read_ahead(a, br, 7))\n      goto truncated_data;\n    ppmd_flags = rar_br_bits(br, 7);\n    rar_br_consume(br, 7);\n\n    /* Memory is allocated in MB */\n    if (ppmd_flags & 0x20)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;\n      rar_br_consume(br, 8);\n    }\n\n    if (ppmd_flags & 0x40)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);\n      rar_br_consume(br, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (ppmd_flags & 0x20)\n    {\n      maxorder = (ppmd_flags & 0x1F) + 1;\n      if(maxorder > 16)\n        maxorder = 16 + (maxorder - 16) * 3;\n\n      if (maxorder == 1)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \""Truncated RAR file data\"");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Make sure ppmd7_contest is freed before Ppmd7_Construct\n       * because reading a broken file cause this abnormal sequence. */\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n\n      rar->bytein.a = a;\n      rar->bytein.Read = &ppmd_read;\n      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \""Invalid zero dictionary size\"");\n\t      return (ARCHIVE_FATAL);\n      }\n\n      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size))\n      {\n        archive_set_error(&a->archive, ENOMEM,\n                          \""Out of memory\"");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \""Unable to initialize PPMd range decoder\"");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \""Invalid PPMd sequence\"");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \""Unable to initialize PPMd range decoder\"");\n        return (ARCHIVE_FATAL);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(br, 1);\n\n    /* Keep existing table flag */\n    if (!rar_br_read_ahead(a, br, 1))\n      goto truncated_data;\n    if (!rar_br_bits(br, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(br, 1);\n\n    memset(&bitlengths, 0, sizeof(bitlengths));\n    for (i = 0; i < MAX_SYMBOLS;)\n    {\n      if (!rar_br_read_ahead(a, br, 4))\n        goto truncated_data;\n      bitlengths[i++] = rar_br_bits(br, 4);\n      rar_br_consume(br, 4);\n      if (bitlengths[i-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(a, br, 4))\n          goto truncated_data;\n        zerocount = rar_br_bits(br, 4);\n        rar_br_consume(br, 4);\n        if (zerocount)\n        {\n          i--;\n          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)\n            bitlengths[i++] = 0;\n        }\n      }\n    }\n\n    memset(&precode, 0, sizeof(precode));\n    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK) {\n      free(precode.tree);\n      free(precode.table);\n      return (r);\n    }\n\n    for (i = 0; i < HUFFMAN_TABLE_SIZE;)\n    {\n      if ((val = read_next_symbol(a, &precode)) < 0) {\n        free(precode.tree);\n        free(precode.table);\n        return (ARCHIVE_FATAL);\n      }\n      if (val < 16)\n      {\n        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;\n        i++;\n      }\n      else if (val < 18)\n      {\n        if (i == 0)\n        {\n          free(precode.tree);\n          free(precode.table);\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \""Internal error extracting RAR file.\"");\n          return (ARCHIVE_FATAL);\n        }\n\n        if(val == 16) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n        {\n          rar->lengthtable[i] = rar->lengthtable[i-1];\n          i++;\n        }\n      }\n      else\n      {\n        if(val == 18) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n          rar->lengthtable[i++] = 0;\n      }\n    }\n    free(precode.tree);\n    free(precode.table);\n\n    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,\n                MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],\n                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lowoffsetcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],\n                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lengthcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +\n                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* Seems as though dictionary sizes are not used. Even so, minimize\n     * memory usage as much as possible.\n     */\n    void *new_window;\n    unsigned int new_size;\n\n    if (rar->unp_size >= DICTIONARY_MAX_SIZE)\n      new_size = DICTIONARY_MAX_SIZE;\n    else\n      new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n    new_window = realloc(rar->lzss.window, new_size);\n    if (new_window == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \""Unable to allocate memory for uncompressed data.\"");\n      return (ARCHIVE_FATAL);\n    }\n    rar->lzss.window = (unsigned char *)new_window;\n    rar->dictionary_size = new_size;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (ARCHIVE_OK);\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \""Truncated RAR file data\"");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\n}"", ""target"": 0}]","[{""func_name"": ""parse_codes"", ""file_path"": ""libarchive/archive_read_support_format_rar.c"", ""func_code"": ""static int\nparse_codes(struct archive_read *a)\n{\n  int i, j, val, n, r;\n  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;\n  unsigned int maxorder;\n  struct huffman_code precode;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  free_codes(a);\n\n  /* Skip to the next byte */\n  rar_br_consume_unalined_bits(br);\n\n  /* PPMd block flag */\n  if (!rar_br_read_ahead(a, br, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)\n  {\n    rar_br_consume(br, 1);\n    if (!rar_br_read_ahead(a, br, 7))\n      goto truncated_data;\n    ppmd_flags = rar_br_bits(br, 7);\n    rar_br_consume(br, 7);\n\n    /* Memory is allocated in MB */\n    if (ppmd_flags & 0x20)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;\n      rar_br_consume(br, 8);\n    }\n\n    if (ppmd_flags & 0x40)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);\n      rar_br_consume(br, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (ppmd_flags & 0x20)\n    {\n      maxorder = (ppmd_flags & 0x1F) + 1;\n      if(maxorder > 16)\n        maxorder = 16 + (maxorder - 16) * 3;\n\n      if (maxorder == 1)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \""Truncated RAR file data\"");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Make sure ppmd7_contest is freed before Ppmd7_Construct\n       * because reading a broken file cause this abnormal sequence. */\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n\n      rar->bytein.a = a;\n      rar->bytein.Read = &ppmd_read;\n      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \""Invalid zero dictionary size\"");\n\t      return (ARCHIVE_FATAL);\n      }\n\n      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size))\n      {\n        archive_set_error(&a->archive, ENOMEM,\n                          \""Out of memory\"");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \""Unable to initialize PPMd range decoder\"");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \""Invalid PPMd sequence\"");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \""Unable to initialize PPMd range decoder\"");\n        return (ARCHIVE_FATAL);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(br, 1);\n\n    /* Keep existing table flag */\n    if (!rar_br_read_ahead(a, br, 1))\n      goto truncated_data;\n    if (!rar_br_bits(br, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(br, 1);\n\n    memset(&bitlengths, 0, sizeof(bitlengths));\n    for (i = 0; i < MAX_SYMBOLS;)\n    {\n      if (!rar_br_read_ahead(a, br, 4))\n        goto truncated_data;\n      bitlengths[i++] = rar_br_bits(br, 4);\n      rar_br_consume(br, 4);\n      if (bitlengths[i-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(a, br, 4))\n          goto truncated_data;\n        zerocount = rar_br_bits(br, 4);\n        rar_br_consume(br, 4);\n        if (zerocount)\n        {\n          i--;\n          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)\n            bitlengths[i++] = 0;\n        }\n      }\n    }\n\n    memset(&precode, 0, sizeof(precode));\n    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK) {\n      free(precode.tree);\n      free(precode.table);\n      return (r);\n    }\n\n    for (i = 0; i < HUFFMAN_TABLE_SIZE;)\n    {\n      if ((val = read_next_symbol(a, &precode)) < 0) {\n        free(precode.tree);\n        free(precode.table);\n        return (ARCHIVE_FATAL);\n      }\n      if (val < 16)\n      {\n        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;\n        i++;\n      }\n      else if (val < 18)\n      {\n        if (i == 0)\n        {\n          free(precode.tree);\n          free(precode.table);\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \""Internal error extracting RAR file.\"");\n          return (ARCHIVE_FATAL);\n        }\n\n        if(val == 16) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n        {\n          rar->lengthtable[i] = rar->lengthtable[i-1];\n          i++;\n        }\n      }\n      else\n      {\n        if(val == 18) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n          rar->lengthtable[i++] = 0;\n      }\n    }\n    free(precode.tree);\n    free(precode.table);\n\n    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,\n                MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],\n                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lowoffsetcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],\n                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lengthcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +\n                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* Seems as though dictionary sizes are not used. Even so, minimize\n     * memory usage as much as possible.\n     */\n    void *new_window;\n    unsigned int new_size;\n\n    if (rar->unp_size >= DICTIONARY_MAX_SIZE)\n      new_size = DICTIONARY_MAX_SIZE;\n    else\n      new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n    if (new_size == 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \""Zero window size is invalid.\"");\n      return (ARCHIVE_FATAL);\n    }\n    new_window = realloc(rar->lzss.window, new_size);\n    if (new_window == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \""Unable to allocate memory for uncompressed data.\"");\n      return (ARCHIVE_FATAL);\n    }\n    rar->lzss.window = (unsigned char *)new_window;\n    rar->dictionary_size = new_size;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (ARCHIVE_OK);\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \""Truncated RAR file data\"");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\n}""}]","{""code"": 7, ""value"": 3, ""function"": 1}","[{""source"": ""code_info(file:archive_read_support_format_rar.c, lines:2290-2310)"", ""result"": ""\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* Seems as though dictionary sizes are not used. Even so, minimize\n     * memory usage as much as possible.\n     */\n    void *new_window;\n    unsigned int new_size;\n\n    if (rar->unp_size >= DICTIONARY_MAX_SIZE)\n      new_size = DICTIONARY_MAX_SIZE;\n    else\n      new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n    new_window = realloc(rar->lzss.window, new_size);\n    if (new_window == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \""Unable to allocate memory for uncompressed data.\"");\n      return (ARCHIVE_FATAL);\n    }\n    rar->lzss.window = (unsigned char *)new_window;\n    rar->dictionary_size = new_size;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n""}, {""source"": ""value_info(file:archive_read_support_format_rar.c, value:new_size)"", ""result"": {""value_trace"": [{""full_code"": ""new_size = DICTIONARY_MAX_SIZE"", ""line"": 2300, ""func_name"": ""parse_codes""}, {""full_code"": ""new_size = rar_fls((unsigned int)rar->unp_size) << 1"", ""line"": 2302, ""func_name"": ""parse_codes""}], ""struct_var"": ""new_size"", ""struct_type"": ""unsigned int"", ""struct_definition"": ""unsigned int""}}, {""source"": ""value_info(file:archive_read_support_format_rar.c, value:unp_size)"", ""result"": {""value_trace"": [{""full_code"": ""unp_size[8]"", ""line"": 1262, ""func_name"": ""read_header<duplicate>0""}], ""struct_var"": ""unp_size"", ""struct_type"": ""char[8]"", ""struct_definition"": null}}, {""source"": ""code_info(file:archive_read_support_format_rar.c, lines:1250-1270)"", ""result"": ""            char head_type)\n{\n  const void *h;\n  const char *p, *endp;\n  struct rar *rar;\n  struct rar_header rar_header;\n  struct rar_file_header file_header;\n  int64_t header_size;\n  unsigned filename_size, end;\n  char *filename;\n  char *strp;\n  char packed_size[8];\n  char unp_size[8];\n  int ttime;\n  struct archive_string_conv *sconv, *fn_sconv;\n  unsigned long crc32_val;\n  int ret = (ARCHIVE_OK), ret2;\n\n  rar = (struct rar *)(a->format->data);\n\n  /* Setup a string conversion object for non-rar-unicode filenames. */\n  sconv = rar->opt_sconv;\n""}, {""source"": ""code_info(file:archive_read_support_format_rar.c, lines:1270-1290)"", ""result"": ""  /* Setup a string conversion object for non-rar-unicode filenames. */\n  sconv = rar->opt_sconv;\n  if (sconv == NULL) {\n    if (!rar->init_default_conversion) {\n      rar->sconv_default =\n          archive_string_default_conversion_for_read(\n            &(a->archive));\n      rar->init_default_conversion = 1;\n    }\n    sconv = rar->sconv_default;\n  }\n\n\n  if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n  p = h;\n  memcpy(&rar_header, p, sizeof(rar_header));\n  rar->file_flags = archive_le16dec(rar_header.flags);\n  header_size = archive_le16dec(rar_header.size);\n  if (header_size < (int64_t)sizeof(file_header) + 7) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \""Invalid header size\"");\n""}, {""source"": ""func_info(file:archive_read_support_format_rar.c, func:rar_fls)"", ""result"": [{""code"": ""static inline int\nrar_fls(unsigned int word)\n{\n  word |= (word >>  1);\n  word |= (word >>  2);\n  word |= (word >>  4);\n  word |= (word >>  8);\n  word |= (word >> 16);\n  return word - (word >> 1);\n}"", ""start_line"": 513, ""end_line"": 522, ""full_name"": ""rar_fls"", ""file_path"": ""libarchive/archive_read_support_format_rar.c""}]}, {""source"": ""code_info(file:archive_read_support_format_rar.c, lines:1290-1310)"", ""result"": ""    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \""Invalid header size\"");\n    return (ARCHIVE_FATAL);\n  }\n  crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);\n  __archive_read_consume(a, 7);\n\n  if (!(rar->file_flags & FHD_SOLID))\n  {\n    rar->compression_method = 0;\n    rar->packed_size = 0;\n    rar->unp_size = 0;\n    rar->mtime = 0;\n    rar->ctime = 0;\n    rar->atime = 0;\n    rar->arctime = 0;\n    rar->mode = 0;\n    memset(&rar->salt, 0, sizeof(rar->salt));\n    rar->atime = 0;\n    rar->ansec = 0;\n    rar->ctime = 0;\n    rar->cnsec = 0;\n""}, {""source"": ""value_info(file:archive_read_support_format_rar.c, value:rar->unp_size)"", ""result"": {""value_trace"": [{""full_code"": ""rar->unp_size = 0"", ""line"": 1301, ""func_name"": ""read_header<duplicate>0""}, {""full_code"": ""rar->unp_size = archive_le64dec(&unp_size)"", ""line"": 1368, ""func_name"": ""read_header<duplicate>0""}, {""full_code"": ""rar->unp_size = archive_le32dec(file_header.unp_size)"", ""line"": 1373, ""func_name"": ""read_header<duplicate>0""}], ""struct_var"": ""rar"", ""struct_type"": ""rar*"", ""struct_definition"": ""struct rar\n{\n  /* Entries from main RAR header */\n  unsigned main_flags;\n  unsigned long file_crc;\n  char reserved1[2];\n  char reserved2[4];\n  char encryptver;\n\n  /* File header entries */\n  char compression_method;\n  unsigned file_flags;\n  int64_t packed_size;\n  int64_t unp_size;\n  time_t mtime;\n  long mnsec;\n  mode_t mode;\n  char *filename;\n  char *filename_save;\n  size_t filename_save_size;\n  size_t filename_allocated;\n\n  /* File header optional entries */\n  char salt[8];\n  time_t atime;\n  long ansec;\n  time_t ctime;\n  long cnsec;\n  time_t arctime;\n  long arcnsec;\n\n  /* Fields to help with tracking decompression of files. */\n  int64_t bytes_unconsumed;\n  int64_t bytes_remaining;\n  int64_t bytes_uncopied;\n  int64_t offset;\n  int64_t offset_outgoing;\n  int64_t offset_seek;\n  char valid;\n  unsigned int unp_offset;\n  unsigned int unp_buffer_size;\n  unsigned char *unp_buffer;\n  unsigned int dictionary_size;\n  char start_new_block;\n  char entry_eof;\n  unsigned long crc_calculated;\n  in...""}}, {""source"": ""code_info(file:archive_read_support_format_rar.c, lines:1310-1330)"", ""result"": ""    rar->ctime = 0;\n    rar->cnsec = 0;\n    rar->mtime = 0;\n    rar->mnsec = 0;\n    rar->arctime = 0;\n    rar->arcnsec = 0;\n  }\n  else\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \""RAR solid archive support unavailable.\"");\n    return (ARCHIVE_FATAL);\n  }\n\n  if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n\n  /* File Header CRC check. */\n  crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));\n  if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \""Header CRC error\"");\n""}, {""source"": ""code_info(file:archive_read_support_format_rar.c, lines:1330-1350)"", ""result"": ""    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \""Header CRC error\"");\n    return (ARCHIVE_FATAL);\n  }\n  /* If no CRC error, Go on parsing File Header. */\n  p = h;\n  endp = p + header_size - 7;\n  memcpy(&file_header, p, sizeof(file_header));\n  p += sizeof(file_header);\n\n  rar->compression_method = file_header.method;\n\n  ttime = archive_le32dec(file_header.file_time);\n  rar->mtime = get_time(ttime);\n\n  rar->file_crc = archive_le32dec(file_header.file_crc);\n\n  if (rar->file_flags & FHD_PASSWORD)\n  {\n\tarchive_entry_set_is_data_encrypted(entry, 1);\n\trar->has_encrypted_entries = 1;\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n""}, {""source"": ""code_info(file:archive_read_support_format_rar.c, lines:1350-1370)"", ""result"": ""\trar->has_encrypted_entries = 1;\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \""RAR encryption support unavailable.\"");\n    /* Since it is only the data part itself that is encrypted we can at least\n       extract information about the currently processed entry and don't need\n       to return ARCHIVE_FATAL here. */\n    /*return (ARCHIVE_FATAL);*/\n  }\n\n  if (rar->file_flags & FHD_LARGE)\n  {\n    memcpy(packed_size, file_header.pack_size, 4);\n    memcpy(packed_size + 4, p, 4); /* High pack size */\n    p += 4;\n    memcpy(unp_size, file_header.unp_size, 4);\n    memcpy(unp_size + 4, p, 4); /* High unpack size */\n    p += 4;\n    rar->packed_size = archive_le64dec(&packed_size);\n    rar->unp_size = archive_le64dec(&unp_size);\n  }\n  else\n  {\n""}]","libarchive/archive_read_support_format_rar.c:2306 calls realloc(rar->lzss.window, new_size). If rar->unp_size is 0 (set via archive_le64dec/unp_size array in lines 1368/1373), new_size = rar_fls(0) << 1 = 0. realloc(..., 0) frees the memory, leading to double-free during cleanup. The patch (lines 2301-2306) rejects new_size == 0. The trigger chain begins with a malicious RAR archive setting `unp_size` in the header to 0, which is decoded into `rar->unp_size = 0` (lines 1368/1373) via `memcpy` (line 1350-1370) from attacker-controlled input.",0.95,./github/other_context/CVE-2018-1000877
13,CVE-2018-16428,CWE-476,c_cpp,"In GNOME GLib 2.56.1, g_markup_parse_context_end_parse() in gmarkup.c has a NULL pointer dereference.",https://github.com/GNOME/glib/commit/fccef3cc822af74699cca84cd202719ae61ca3b9,"gmarkup: Fix crash in error handling path for closing elements\n\nIf something which looks like a closing tag is left unfinished, but\nisn’t paired to an opening tag in the document, the error handling code\nwould do a null pointer dereference. Avoid that, at the cost of\nintroducing a new translatable error message.\n\nIncludes a test case, courtesy of pdknsk.\n\nSigned-off-by: Philip Withnall <withnall@endlessm.com>\n\nhttps://gitlab.gnome.org/GNOME/glib/issues/1461",1,"[{""func_name"": ""g_markup_parse_context_end_parse"", ""file_path"": ""glib/gmarkup.c"", ""func_code"": ""gboolean\ng_markup_parse_context_end_parse (GMarkupParseContext  *context,\n                                  GError              **error)\n{\n  g_return_val_if_fail (context != NULL, FALSE);\n  g_return_val_if_fail (!context->parsing, FALSE);\n  g_return_val_if_fail (context->state != STATE_ERROR, FALSE);\n\n  if (context->partial_chunk != NULL)\n    {\n      g_string_free (context->partial_chunk, TRUE);\n      context->partial_chunk = NULL;\n    }\n\n  if (context->document_empty)\n    {\n      set_error_literal (context, error, G_MARKUP_ERROR_EMPTY,\n                         _(\""Document was empty or contained only whitespace\""));\n      return FALSE;\n    }\n\n  context->parsing = TRUE;\n\n  switch (context->state)\n    {\n    case STATE_START:\n      /* Nothing to do */\n      break;\n\n    case STATE_AFTER_OPEN_ANGLE:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly just after an open angle bracket \u201c<\u201d\""));\n      break;\n\n    case STATE_AFTER_CLOSE_ANGLE:\n      if (context->tag_stack != NULL)\n        {\n          /* Error message the same as for INSIDE_TEXT */\n          set_error (context, error, G_MARKUP_ERROR_PARSE,\n                     _(\""Document ended unexpectedly with elements still open \u2014 \""\n                       \""\u201c%s\u201d was the last element opened\""),\n                     current_element (context));\n        }\n      break;\n\n    case STATE_AFTER_ELISION_SLASH:\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\""Document ended unexpectedly, expected to see a close angle \""\n                   \""bracket ending the tag <%s/>\""), current_element (context));\n      break;\n\n    case STATE_INSIDE_OPEN_TAG_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an element name\""));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_NAME:\n    case STATE_AFTER_ATTRIBUTE_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an attribute name\""));\n      break;\n\n    case STATE_BETWEEN_ATTRIBUTES:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an element-opening \""\n                           \""tag.\""));\n      break;\n\n    case STATE_AFTER_ATTRIBUTE_EQUALS_SIGN:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly after the equals sign \""\n                           \""following an attribute name; no attribute value\""));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_VALUE_SQ:\n    case STATE_INSIDE_ATTRIBUTE_VALUE_DQ:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly while inside an attribute \""\n                           \""value\""));\n      break;\n\n    case STATE_INSIDE_TEXT:\n      g_assert (context->tag_stack != NULL);\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\""Document ended unexpectedly with elements still open \u2014 \""\n                   \""\u201c%s\u201d was the last element opened\""),\n                 current_element (context));\n      break;\n\n    case STATE_AFTER_CLOSE_TAG_SLASH:\n    case STATE_INSIDE_CLOSE_TAG_NAME:\n    case STATE_AFTER_CLOSE_TAG_NAME:\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\""Document ended unexpectedly inside the close tag for \""\n                   \""element \u201c%s\u201d\""), current_element (context));\n      break;\n\n    case STATE_INSIDE_PASSTHROUGH:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside a comment or \""\n                           \""processing instruction\""));\n      break;\n\n    case STATE_ERROR:\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n  context->parsing = FALSE;\n\n  return context->state != STATE_ERROR;\n}"", ""target"": 0}]","[{""func_name"": ""g_markup_parse_context_end_parse"", ""file_path"": ""glib/gmarkup.c"", ""func_code"": ""gboolean\ng_markup_parse_context_end_parse (GMarkupParseContext  *context,\n                                  GError              **error)\n{\n  g_return_val_if_fail (context != NULL, FALSE);\n  g_return_val_if_fail (!context->parsing, FALSE);\n  g_return_val_if_fail (context->state != STATE_ERROR, FALSE);\n\n  if (context->partial_chunk != NULL)\n    {\n      g_string_free (context->partial_chunk, TRUE);\n      context->partial_chunk = NULL;\n    }\n\n  if (context->document_empty)\n    {\n      set_error_literal (context, error, G_MARKUP_ERROR_EMPTY,\n                         _(\""Document was empty or contained only whitespace\""));\n      return FALSE;\n    }\n\n  context->parsing = TRUE;\n\n  switch (context->state)\n    {\n    case STATE_START:\n      /* Nothing to do */\n      break;\n\n    case STATE_AFTER_OPEN_ANGLE:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly just after an open angle bracket \u201c<\u201d\""));\n      break;\n\n    case STATE_AFTER_CLOSE_ANGLE:\n      if (context->tag_stack != NULL)\n        {\n          /* Error message the same as for INSIDE_TEXT */\n          set_error (context, error, G_MARKUP_ERROR_PARSE,\n                     _(\""Document ended unexpectedly with elements still open \u2014 \""\n                       \""\u201c%s\u201d was the last element opened\""),\n                     current_element (context));\n        }\n      break;\n\n    case STATE_AFTER_ELISION_SLASH:\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\""Document ended unexpectedly, expected to see a close angle \""\n                   \""bracket ending the tag <%s/>\""), current_element (context));\n      break;\n\n    case STATE_INSIDE_OPEN_TAG_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an element name\""));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_NAME:\n    case STATE_AFTER_ATTRIBUTE_NAME:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an attribute name\""));\n      break;\n\n    case STATE_BETWEEN_ATTRIBUTES:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside an element-opening \""\n                           \""tag.\""));\n      break;\n\n    case STATE_AFTER_ATTRIBUTE_EQUALS_SIGN:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly after the equals sign \""\n                           \""following an attribute name; no attribute value\""));\n      break;\n\n    case STATE_INSIDE_ATTRIBUTE_VALUE_SQ:\n    case STATE_INSIDE_ATTRIBUTE_VALUE_DQ:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly while inside an attribute \""\n                           \""value\""));\n      break;\n\n    case STATE_INSIDE_TEXT:\n      g_assert (context->tag_stack != NULL);\n      set_error (context, error, G_MARKUP_ERROR_PARSE,\n                 _(\""Document ended unexpectedly with elements still open \u2014 \""\n                   \""\u201c%s\u201d was the last element opened\""),\n                 current_element (context));\n      break;\n\n    case STATE_AFTER_CLOSE_TAG_SLASH:\n    case STATE_INSIDE_CLOSE_TAG_NAME:\n    case STATE_AFTER_CLOSE_TAG_NAME:\n      if (context->tag_stack != NULL)\n        set_error (context, error, G_MARKUP_ERROR_PARSE,\n                   _(\""Document ended unexpectedly inside the close tag for \""\n                     \""element \u201c%s\u201d\""), current_element (context));\n      else\n        set_error (context, error, G_MARKUP_ERROR_PARSE,\n                   _(\""Document ended unexpectedly inside the close tag for an \""\n                     \""unopened element\""));\n      break;\n\n    case STATE_INSIDE_PASSTHROUGH:\n      set_error_literal (context, error, G_MARKUP_ERROR_PARSE,\n                         _(\""Document ended unexpectedly inside a comment or \""\n                           \""processing instruction\""));\n      break;\n\n    case STATE_ERROR:\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n  context->parsing = FALSE;\n\n  return context->state != STATE_ERROR;\n}""}]","{""function"": 1}","[{""source"": ""func_info(file:gmarkup.c, func:current_element)"", ""result"": [{""code"": ""static inline const gchar*\ncurrent_element (GMarkupParseContext *context)\n{\n  return context->tag_stack->data;\n}"", ""start_line"": 890, ""end_line"": 894, ""full_name"": ""current_element"", ""file_path"": ""glib/gmarkup.c""}]}]","Original code: glib/gmarkup.c:1845-1847: `current_element(context)` is called without checking if `context->tag_stack` is NULL. `current_element` (glib/gmarkup.c:890-894) dereferences `context->tag_stack->data`, causing a crash if `tag_stack` is NULL. The patch (glib/gmarkup.c:1845-1855) adds a NULL check, confirming the vulnerability arises from unvalidated access to `tag_stack`.",0.95,./github/other_context/CVE-2018-16428
14,CVE-2018-15861,CWE-476,c_cpp,Unchecked NULL pointer usage in ExprResolveLhs in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file that triggers an xkb_intern_atom failure.,https://github.com/xkbcommon/libxkbcommon/commit/38e1766bc6e20108948aec8a0b222a4bad0254e9,"xkbcomp: Don't falsely promise from ExprResolveLhs\n\nEvery user of ExprReturnLhs goes on to unconditionally dereference the\nfield return, which can be NULL if xkb_intern_atom fails. Return false\nif this is the case, so we fail safely.\n\ntestcase: splice geometry data into interp\n\nSigned-off-by: Daniel Stone <daniels@collabora.com>",1,"[{""func_name"": ""ExprResolveLhs"", ""file_path"": ""src/xkbcomp/expr.c"", ""func_code"": ""bool\nExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \""Unexpected operator %d in ResolveLhs\\n\"", expr->expr.op);\n    return false;\n}"", ""target"": 0}]","[{""func_name"": ""ExprResolveLhs"", ""file_path"": ""src/xkbcomp/expr.c"", ""func_code"": ""bool\nExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \""Unexpected operator %d in ResolveLhs\\n\"", expr->expr.op);\n    return false;\n}""}]","{""function"": 6, ""code"": 6, ""caller"": 1}","[{""source"": ""func_info(func:xkb_atom_text)"", ""result"": [{""code"": ""const char *\nxkb_atom_text(struct xkb_context *ctx, xkb_atom_t atom)\n{\n    return atom_text(ctx->atom_table, atom);\n}"", ""start_line"": 70, ""end_line"": 74, ""full_name"": ""xkb_atom_text"", ""file_path"": ""src/context-priv.c""}]}, {""source"": ""code_info(file:expr.c, lines:43-50)"", ""result"": ""        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n""}, {""source"": ""caller_info(file:expr.c, func:ExprResolveLhs)"", ""result"": [{""call_line"": 829, ""call_code"": ""ExprResolveLhs(ctx, field, &elemRtrn, &fieldRtrn, &arrayRtrn)"", ""caller_code"": ""bool\nHandleActionDef(struct xkb_context *ctx, ActionsInfo *info,\n                const struct xkb_mod_set *mods, ExprDef *def,\n                union xkb_action *action)\n{\n    ExprDef *arg;\n    const char *str;\n    enum xkb_action_type handler_type;\n\n    if (def->expr.op != EXPR_ACTION_DECL) {\n        log_err(ctx, \""Expected an action definition, found %s\\n\"",\n                expr_op_type_to_string(def->expr.op));\n        return false;\n    }\n\n    str = xkb_atom_text(ctx, def->action.name);\n    if (!stringToAction(str, &handler_type)) {\n        log_err(ctx, \""Unknown action %s\\n\"", str);\n        return false;\n    }\n\n    /*\n     * Get the default values for this action type, as modified by\n     * statements such as:\n     *     latchMods.clearLocks = True;\n     */\n    *action = info->actions[handler_type];\n\n    /*\n     * Now change the action properties as specified for this\n     * particular instance, e.g. \""modifiers\"" and \""clearLocks\"" in:\n     *     SetMods(modifiers=Alt,clearLocks);\n     ..."", ""caller_start"": 776, ""file_path"": ""src/xkbcomp/action.c""}, {""call_line"": 636, ""call_code"": ""ExprResolveLhs(info->ctx, stmt->name, &elem, &field, &ndx)"", ""caller_code"": ""static bool\nHandleGlobalVar(CompatInfo *info, VarDef *stmt)\n{\n    const char *elem, *field;\n    ExprDef *ndx;\n    bool ret;\n\n    if (!ExprResolveLhs(info->ctx, stmt->name, &elem, &field, &ndx))\n        ret = false;\n    else if (elem && istreq(elem, \""interpret\""))\n        ret = SetInterpField(info, &info->default_interp, field, ndx,\n                             stmt->value);\n    else if (elem && istreq(elem, \""indicator\""))\n        ret = SetLedMapField(info, &info->default_led, field, ndx,\n                             stmt->value);\n    else\n        ret = SetActionField(info->ctx, info->actions, &info->mods,\n                             elem, field, ndx, stmt->value);\n    return ret;\n}"", ""caller_start"": 629, ""file_path"": ""src/xkbcomp/compat.c""}, {""call_line"": 666, ""call_code"": ""ExprResolveLhs(info->ctx, def->name, &elem, &field, &arrayNdx)"", ""caller_code"": ""static bool\nHandleInterpBody(CompatInfo *info, VarDef *def, SymInterpInfo *si)\n{\n    bool ok = true;\n    const char *elem, *field;\n    ExprDef *arrayNdx;\n\n    for (; def; def = (VarDef *) def->common.next) {\n        if (def->name && def->name->expr.op == EXPR_FIELD_REF) {\n            log_err(info->ctx,\n                    \""Cannot set a global default value from within an interpret statement; \""\n                    \""Move statements to the global file scope\\n\"");\n            ok = false;\n            continue;\n        }\n\n        ok = ExprResolveLhs(info->ctx, def->name, &elem, &field, &arrayNdx);\n        if (!ok)\n            continue;\n\n        ok = SetInterpField(info, si, field, arrayNdx, def->value);\n    }\n\n    return ok;\n}"", ""caller_start"": 650, ""file_path"": ""src/xkbcomp/compat.c""}, {""call_line"": 727, ""call_code"": ""ExprResolveLhs(info->ctx, var->name, &elem, &field, &arrayNdx)"", ""caller_code"": ""static bool\nHandleLedMapDef(CompatInfo *info, LedMapDef *def, enum merge_mode merge)\n{\n    LedInfo ledi;\n    VarDef *var;\n    bool ok;\n\n    if (def->merge != MERGE_DEFAULT)\n        merge = def->merge;\n\n    ledi = info->default_led;\n    ledi.merge = merge;\n    ledi.led.name = def->name;\n\n    ok = true;\n    for (var = def->body; var != NULL; var = (VarDef *) var->common.next) {\n        const char *elem, *field;\n        ExprDef *arrayNdx;\n        if (!ExprResolveLhs(info->ctx, var->name, &elem, &field, &arrayNdx)) {\n            ok = false;\n            continue;\n        }\n\n        if (elem) {\n            log_err(info->ctx,\n                    \""Cannot set defaults for \\\""%s\\\"" element in indicator map; \""\n                    \""Assignment to %s.%s ignored\\n\"", elem, elem, field);\n            ok = false;\n        }\n        else {\n            ok = SetLedMapField(info, &ledi, field, arrayNdx, var->value) && ok;\n        }\n    }\n\n    if (ok)\n        return AddLedMap(info, &ledi, true);\n\n    return f..."", ""caller_start"": 709, ""file_path"": ""src/xkbcomp/compat.c""}]}, {""source"": ""code_info(file:expr.c, lines:100-200)"", ""result"": ""    if (type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n    if (!str)\n        return false;\n\n    if (istreq(str, \""all\"")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    if (istreq(str, \""none\"")) {\n        *val_rtrn = 0;\n        return true;\n    }\n\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n\n    *val_rtrn = (1u << ndx);\n    return true;\n}\n\nbool\nExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \""Found constant of type %s where boolean was expected\\n\"",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \""true\"") ||\n                istreq(ident, \""yes\"") ||\n                istreq(ident, \""on\"")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \""false\"") ||\n                     istreq(ident, \""no\"") ||\n                     istreq(ident, \""off\"")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \""Identifier \\\""%s\\\"" of type boolean is unknown\\n\"", ident);\n        return false;\n\n    case EXPR_FIELD_REF:\n        log_err(ctx, \""Default \\\""%s.%s\\\"" of type boolean is unknown\\n\"",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n\n    case EXPR_INVERT:\n    case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);\n        if (ok)\n            *set_rtrn = !*set_rtrn;\n        return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \""%s of boolean values not permitted\\n\"",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n\n    default:\n        log_wsgo(ctx, \""Unknown operator %d in ResolveBoolean\\n\"",\n                 expr->expr.op);\n        break;\n    }\n\n    return false;\n}\n\nbool\nExprResolveKeyCode(struct xkb_context *ctx, const ExprDef *expr,\n                   xkb_keycode_t *kc)\n{\n    xkb_keycode_t leftRtrn, rightRtrn;\n\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n""}, {""source"": ""code_info(file:action.c, lines:776-800)"", ""result"": ""bool\nHandleActionDef(struct xkb_context *ctx, ActionsInfo *info,\n                const struct xkb_mod_set *mods, ExprDef *def,\n                union xkb_action *action)\n{\n    ExprDef *arg;\n    const char *str;\n    enum xkb_action_type handler_type;\n\n    if (def->expr.op != EXPR_ACTION_DECL) {\n        log_err(ctx, \""Expected an action definition, found %s\\n\"",\n                expr_op_type_to_string(def->expr.op));\n        return false;\n    }\n\n    str = xkb_atom_text(ctx, def->action.name);\n    if (!stringToAction(str, &handler_type)) {\n        log_err(ctx, \""Unknown action %s\\n\"", str);\n        return false;\n    }\n\n    /*\n     * Get the default values for this action type, as modified by\n     * statements such as:\n     *     latchMods.clearLocks = True;\n     */\n""}, {""source"": ""code_info(file:compat.c, lines:629-650)"", ""result"": ""static bool\nHandleGlobalVar(CompatInfo *info, VarDef *stmt)\n{\n    const char *elem, *field;\n    ExprDef *ndx;\n    bool ret;\n\n    if (!ExprResolveLhs(info->ctx, stmt->name, &elem, &field, &ndx))\n        ret = false;\n    else if (elem && istreq(elem, \""interpret\""))\n        ret = SetInterpField(info, &info->default_interp, field, ndx,\n                             stmt->value);\n    else if (elem && istreq(elem, \""indicator\""))\n        ret = SetLedMapField(info, &info->default_led, field, ndx,\n                             stmt->value);\n    else\n        ret = SetActionField(info->ctx, info->actions, &info->mods,\n                             elem, field, ndx, stmt->value);\n    return ret;\n}\n\nstatic bool\nHandleInterpBody(CompatInfo *info, VarDef *def, SymInterpInfo *si)\n""}, {""source"": ""func_info(file:action.c, func:SetActionField)"", ""result"": [{""code"": ""bool\nSetActionField(struct xkb_context *ctx, ActionsInfo *info,\n               struct xkb_mod_set *mods, const char *elem,\n               const char *field, ExprDef *array_ndx, ExprDef *value)\n{\n    enum xkb_action_type action;\n    enum action_field action_field;\n\n    if (!stringToAction(elem, &action))\n        return false;\n\n    if (!stringToField(field, &action_field)) {\n        log_err(ctx, \""\\\""%s\\\"" is not a legal field name\\n\"", field);\n        return false;\n    }\n\n    return handleAction[action](ctx, mods, &info->actions[action],\n                                action_field, array_ndx, value);\n}"", ""start_line"": 853, ""end_line"": 871, ""full_name"": ""SetActionField"", ""file_path"": ""src/xkbcomp/action.c""}]}, {""source"": ""func_info(file:compat.c, func:SetInterpField)"", ""result"": [{""code"": ""static bool\nSetInterpField(CompatInfo *info, SymInterpInfo *si, const char *field,\n               ExprDef *arrayNdx, ExprDef *value)\n{\n    xkb_mod_index_t ndx;\n\n    if (istreq(field, \""action\"")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!HandleActionDef(info->ctx, info->actions, &info->mods,\n                             value, &si->interp.action))\n            return false;\n\n        si->defined |= SI_FIELD_ACTION;\n    }\n    else if (istreq(field, \""virtualmodifier\"") ||\n             istreq(field, \""virtualmod\"")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveMod(info->ctx, value, MOD_VIRT, &info->mods, &ndx))\n            return ReportSIBadType(info, si, field, \""virtual modifier\"");\n\n        si->interp.virtual_mod = ndx;\n        si->defined |= SI_FIELD_VIRTUAL_MOD;\n    }\n    else if (istreq(field, \""repeat\"")) {\n        bool set;\n\n        if (arrayNdx)\n            return ReportSINotArray(..."", ""start_line"": 464, ""end_line"": 528, ""full_name"": ""SetInterpField"", ""file_path"": ""src/xkbcomp/compat.c""}]}, {""source"": ""func_info(file:action.c, func:stringToField)"", ""result"": [{""code"": ""static bool\nstringToField(const char *str, enum action_field *field_rtrn)\n{\n    return LookupString(fieldStrings, str, field_rtrn);\n}"", ""start_line"": 176, ""end_line"": 180, ""full_name"": ""stringToField"", ""file_path"": ""src/xkbcomp/action.c""}]}, {""source"": ""code_info(file:action.c, lines:853-871)"", ""result"": ""bool\nSetActionField(struct xkb_context *ctx, ActionsInfo *info,\n               struct xkb_mod_set *mods, const char *elem,\n               const char *field, ExprDef *array_ndx, ExprDef *value)\n{\n    enum xkb_action_type action;\n    enum action_field action_field;\n\n    if (!stringToAction(elem, &action))\n        return false;\n\n    if (!stringToField(field, &action_field)) {\n        log_err(ctx, \""\\\""%s\\\"" is not a legal field name\\n\"", field);\n        return false;\n    }\n\n    return handleAction[action](ctx, mods, &info->actions[action],\n                                action_field, array_ndx, value);\n}\n""}, {""source"": ""code_info(file:compat.c, lines:464-528)"", ""result"": ""static bool\nSetInterpField(CompatInfo *info, SymInterpInfo *si, const char *field,\n               ExprDef *arrayNdx, ExprDef *value)\n{\n    xkb_mod_index_t ndx;\n\n    if (istreq(field, \""action\"")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!HandleActionDef(info->ctx, info->actions, &info->mods,\n                             value, &si->interp.action))\n            return false;\n\n        si->defined |= SI_FIELD_ACTION;\n    }\n    else if (istreq(field, \""virtualmodifier\"") ||\n             istreq(field, \""virtualmod\"")) {\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveMod(info->ctx, value, MOD_VIRT, &info->mods, &ndx))\n            return ReportSIBadType(info, si, field, \""virtual modifier\"");\n\n        si->interp.virtual_mod = ndx;\n        si->defined |= SI_FIELD_VIRTUAL_MOD;\n    }\n    else if (istreq(field, \""repeat\"")) {\n        bool set;\n\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveBoolean(info->ctx, value, &set))\n            return ReportSIBadType(info, si, field, \""boolean\"");\n\n        si->interp.repeat = set;\n\n        si->defined |= SI_FIELD_AUTO_REPEAT;\n    }\n    else if (istreq(field, \""locking\"")) {\n        log_dbg(info->ctx,\n                \""The \\\""locking\\\"" field in symbol interpretation is unsupported; \""\n                \""Ignored\\n\"");\n    }\n    else if (istreq(field, \""usemodmap\"") ||\n             istreq(field, \""usemodmapmods\"")) {\n        unsigned int val;\n\n        if (arrayNdx)\n            return ReportSINotArray(info, si, field);\n\n        if (!ExprResolveEnum(info->ctx, value, &val, useModMapValueNames))\n            return ReportSIBadType(info, si, field, \""level specification\"");\n\n        si->interp.level_one_only = val;\n        si->defined |= SI_FIELD_LEVEL_ONE_ONLY;\n    }\n    else {\n        return ReportBadField(info->ctx, \""symbol interpretation\"", field,\n                              siText(si, info));\n    }\n\n    return true;\n}\n\n""}, {""source"": ""func_info(func:LookupString)"", ""result"": [{""code"": ""bool\nLookupString(const LookupEntry tab[], const char *string,\n              unsigned int *value_rtrn)\n{\n    if (!string)\n        return false;\n\n    for (const LookupEntry *entry = tab; entry->name; entry++) {\n        if (istreq(entry->name, string)) {\n            *value_rtrn = entry->value;\n            return true;\n        }\n    }\n\n    return false;\n}"", ""start_line"": 30, ""end_line"": 45, ""full_name"": ""LookupString"", ""file_path"": ""src/text.c""}]}, {""source"": ""func_info(func:istreq)"", ""result"": [{""code"": ""static inline bool\nistreq(const char *s1, const char *s2)\n{\n    return istrcmp(s1, s2) == 0;\n}"", ""start_line"": 69, ""end_line"": 73, ""full_name"": ""istreq"", ""file_path"": ""src/utils.h""}]}]","src/xkbcomp/expr.c:43: *field_rtrn = xkb_atom_text(ctx, expr->ident.ident) may be NULL. Original code returns true, allowing callers to dereference *field_rtrn. Patch returns (*field_rtrn != NULL). Callers like HandleGlobalVar (compat.c:629) pass *field_rtrn to SetInterpField (compat.c:464-528), which uses istreq(field, 'action') (utils.h:69-73) without NULL checks, causing a NULL dereference.",0.95,./github/other_context/CVE-2018-15861
15,CVE-2018-17282,CWE-476,c_cpp,An issue was discovered in Exiv2 v0.26. The function Exiv2::DataValue::copy in value.cpp has a NULL pointer dereference.,https://github.com/Exiv2/exiv2/commit/670fb73dd5ee8acab90971c4878de29f9fc43a02,Fix #457,1,"[{""func_name"": ""TiffImage::readMetadata"", ""file_path"": ""src/tiffimage.cpp"", ""func_code"": ""void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \""Reading TIFF file \"" << io_->path() << \""\\n\"";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \""TIFF\"");\n        }\n        clearMetadata();\n\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n\n        // read profile from the metadata\n        Exiv2::ExifKey            key(\""Exif.Image.InterColorProfile\"");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count()*pos->typeSize());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n\n    }"", ""target"": 0}]","[{""func_name"": ""TiffImage::readMetadata"", ""file_path"": ""src/tiffimage.cpp"", ""func_code"": ""void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \""Reading TIFF file \"" << io_->path() << \""\\n\"";\n#endif\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \""TIFF\"");\n        }\n        clearMetadata();\n\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n\n        // read profile from the metadata\n        Exiv2::ExifKey            key(\""Exif.Image.InterColorProfile\"");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end() ) {\n            long size = pos->count() * pos->typeSize();\n            if (size == 0) {\n                throw Error(kerFailedToReadImageData);\n            }\n            iccProfile_.alloc(size);\n            pos->copy(iccProfile_.pData_,bo);\n        }\n\n    }""}]","{""function"": 6, ""code"": 1, ""value"": 1}","[{""source"": ""func_info(func:copy)"", ""result"": [{""code"": ""long ValueType<T>::copy(byte* buf, ByteOrder byteOrder) const\n    {\n        long offset = 0;\n        typename ValueList::const_iterator end = value_.end();\n        for (typename ValueList::const_iterator i = value_.begin(); i != end; ++i) {\n            offset += toData(buf + offset, *i, byteOrder);\n        }\n        return offset;\n    }"", ""start_line"": 1598, ""end_line"": 1606, ""full_name"": ""Exiv2.ValueType.copy:long(Exiv2.byte*,Exiv2.ByteOrder)<const>"", ""file_path"": ""include/exiv2/value.hpp""}, {""code"": ""long Exifdatum::copy(byte* buf, ByteOrder byteOrder) const\n    {\n        return value_.get() == 0 ? 0 : value_->copy(buf, byteOrder);\n    }"", ""start_line"": 355, ""end_line"": 358, ""full_name"": ""Exifdatum.copy:long(byte*,ByteOrder)<const>"", ""file_path"": ""src/exif.cpp""}, {""code"": ""DataBuf ExifThumbC::copy() const\n    {\n        Thumbnail::AutoPtr thumbnail = Thumbnail::create(exifData_);\n        if (thumbnail.get() == 0) return DataBuf();\n        return thumbnail->copy(exifData_);\n    }"", ""start_line"": 430, ""end_line"": 435, ""full_name"": ""ExifThumbC.copy:DataBuf()<const>"", ""file_path"": ""src/exif.cpp""}]}, {""source"": ""code_info(file:tiffimage.cpp, lines:200-210)"", ""result"": ""    void TiffImage::writeMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \""Writing TIFF file \"" << io_->path() << \""\\n\"";\n#endif\n        ByteOrder bo = byteOrder();\n        byte* pData = 0;\n        long size = 0;\n        IoCloser closer(*io_);\n        if (io_->open() == 0) {\n            // Ensure that this is the correct image type\n            if (isTiffType(*io_, false)) {\n""}, {""source"": ""value_info(file:tiffimage.cpp, value:iccProfile_)"", ""result"": {""value_trace"": [{""full_code"": ""iccProfile_ = iccProfile"", ""line"": 661, ""func_name"": ""Image.setIccProfile:void(Exiv2.DataBuf&,bool)""}], ""struct_var"": ""iccProfile_"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""func_info(file:value.hpp, func:toData)"", ""result"": [{""code"": ""inline long toData(byte* buf, uint16_t t, ByteOrder byteOrder)\n    {\n        return us2Data(buf, t, byteOrder);\n    }"", ""start_line"": 1439, ""end_line"": 1442, ""full_name"": ""toData:long(Exiv2.byte*,uint16_t,Exiv2.ByteOrder)"", ""file_path"": ""include/exiv2/value.hpp""}, {""code"": ""inline long toData(byte* buf, uint32_t t, ByteOrder byteOrder)\n    {\n        return ul2Data(buf, t, byteOrder);\n    }"", ""start_line"": 1448, ""end_line"": 1451, ""full_name"": ""toData:long(Exiv2.byte*,uint32_t,Exiv2.ByteOrder)"", ""file_path"": ""include/exiv2/value.hpp""}, {""code"": ""inline long toData(byte* buf, URational t, ByteOrder byteOrder)\n    {\n        return ur2Data(buf, t, byteOrder);\n    }"", ""start_line"": 1457, ""end_line"": 1460, ""full_name"": ""toData:long(Exiv2.byte*,Exiv2.URational,Exiv2.ByteOrder)"", ""file_path"": ""include/exiv2/value.hpp""}]}, {""source"": ""func_info(func:us2Data)"", ""result"": [{""code"": ""long us2Data(byte* buf, uint16_t s, ByteOrder byteOrder)\n    {\n        if (byteOrder == littleEndian) {\n            buf[0] = (byte) (s & 0x00ff);\n            buf[1] = (byte)((s & 0xff00) >> 8);\n        }\n        else {\n            buf[0] = (byte)((s & 0xff00) >> 8);\n            buf[1] = (byte) (s & 0x00ff);\n        }\n        return 2;\n    }"", ""start_line"": 394, ""end_line"": 405, ""full_name"": ""Exiv2.us2Data:long(Exiv2.byte*,uint16_t,Exiv2.ByteOrder)"", ""file_path"": ""src/types.cpp""}]}, {""source"": ""func_info(func:ul2Data)"", ""result"": [{""code"": ""long ul2Data(byte* buf, uint32_t l, ByteOrder byteOrder)\n    {\n        if (byteOrder == littleEndian) {\n            buf[0] = (byte) (l & 0x000000ff);\n            buf[1] = (byte)((l & 0x0000ff00) >> 8);\n            buf[2] = (byte)((l & 0x00ff0000) >> 16);\n            buf[3] = (byte)((l & 0xff000000) >> 24);\n        }\n        else {\n            buf[0] = (byte)((l & 0xff000000) >> 24);\n            buf[1] = (byte)((l & 0x00ff0000) >> 16);\n            buf[2] = (byte)((l & 0x0000ff00) >> 8);\n            buf[3] = (byte) (l & 0x000000ff);\n        }\n        return 4;\n    }"", ""start_line"": 407, ""end_line"": 422, ""full_name"": ""Exiv2.ul2Data:long(Exiv2.byte*,uint32_t,Exiv2.ByteOrder)"", ""file_path"": ""src/types.cpp""}]}, {""source"": ""func_info(func:ur2Data)"", ""result"": [{""code"": ""long ur2Data(byte* buf, URational l, ByteOrder byteOrder)\n    {\n        long o = ul2Data(buf, l.first, byteOrder);\n        o += ul2Data(buf+o, l.second, byteOrder);\n        return o;\n    }"", ""start_line"": 424, ""end_line"": 429, ""full_name"": ""Exiv2.ur2Data:long(Exiv2.byte*,Exiv2.URational,Exiv2.ByteOrder)"", ""file_path"": ""src/types.cpp""}]}, {""source"": ""func_info(func:alloc)"", ""result"": [{""code"": ""void DataBuf::alloc(long size)\n    {\n        if (size > size_) {\n            delete[] pData_;\n            pData_ = 0;\n            size_ = 0;\n            pData_ = new byte[size];\n            size_ = size;\n        }\n    }"", ""start_line"": 160, ""end_line"": 169, ""full_name"": ""DataBuf.alloc:void(long)"", ""file_path"": ""src/types.cpp""}]}]","src/tiffimage.cpp:194-198: Zero-size allocation check prevents iccProfile_.pData_ from being NULL. Previously, if pos->count() * pos->typeSize() == 0, iccProfile_.alloc(0) would leave pData_ as NULL (src/types.cpp:160-169). The subsequent call to pos->copy(iccProfile_.pData_, bo) passed NULL to Exifdatum::copy (src/exif.cpp:355-358), which invoked ValueType<T>::copy (value.hpp:1598-1606). The loop in ValueType<T>::copy called toData(), which relied on us2Data/ul2Data (src/types.cpp:394-429) that directly dereferenced the NULL buffer (e.g., buf[0] = ...).",0.95,./github/other_context/CVE-2018-17282
16,CVE-2018-18873,CWE-476,c_cpp,An issue was discovered in JasPer 2.0.14. There is a NULL pointer dereference in the function ras_putdatastd in ras/ras_enc.c.,https://github.com/jasper-software/jasper/commit/12db8078ba17a8ffc5cc2429fb506988f0f11b44,"ras_enc: check components for RGB, fixes NULL pointer dereference\n\nFixes CVE-2018-18873\n\nCloses https://github.com/jasper-maint/jasper/issues/15\nCloses https://github.com/mdadams/jasper/issues/184",1,"[{""func_name"": ""ras_putdatastd"", ""file_path"": ""src/libjasper/ras/ras_enc.c"", ""func_code"": ""static int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image,  int numcmpts, int *cmpts)\n{\n\tint rowsize;\n\tint pad;\n\tunsigned int z;\n\tint nz;\n\tint c;\n\tint x;\n\tint y;\n\tint v;\n\tjas_matrix_t *data[3];\n\tint i;\n\n\tassert(numcmpts <= 3);\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tdata[i] = 0;\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(data[i] = jas_matrix_create(jas_image_height(image),\n\t\t  jas_image_width(image)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trowsize = RAS_ROWSIZE(hdr);\n\tpad = rowsize - (hdr->width * hdr->depth + 7) / 8;\n\n\thdr->length = hdr->height * rowsize;\n\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tfor (i = 0; i < numcmpts; ++i) {\n\t\t\tif (jas_image_readcmpt(image, cmpts[i], 0, y,\n\t\t\t\t\tjas_image_width(image), 1, data[i])) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tz = 0;\n\t\tnz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\tz <<= hdr->depth;\n\t\t\tif (RAS_ISRGB(hdr)) {\n\t\t\t\tv = RAS_RED((jas_matrix_getv(data[0], x))) |\n\t\t\t\t  RAS_GREEN((jas_matrix_getv(data[1], x))) |\n\t\t\t\t  RAS_BLUE((jas_matrix_getv(data[2], x)));\n\t\t\t} else {\n\t\t\t\tv = (jas_matrix_getv(data[0], x));\n\t\t\t}\n\t\t\tz |= v & RAS_ONES(hdr->depth);\n\t\t\tnz += hdr->depth;\n\t\t\twhile (nz >= 8) {\n\t\t\t\tc = (z >> (nz - 8)) & 0xff;\n\t\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tnz -= 8;\n\t\t\t\tz &= RAS_ONES(nz);\n\t\t\t}\n\t\t}\n\t\tif (nz > 0) {\n\t\t\tc = (z >> (8 - nz)) & RAS_ONES(nz);\n\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (pad % 2) {\n\t\t\tif (jas_stream_putc(out, 0) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t\tdata[i] = 0;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (data[i]) {\n\t\t\tjas_matrix_destroy(data[i]);\n\t\t}\n\t}\n\treturn -1;\n}"", ""target"": 0}]","[{""func_name"": ""ras_putdatastd"", ""file_path"": ""src/libjasper/ras/ras_enc.c"", ""func_code"": ""static int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image,  int numcmpts, int *cmpts)\n{\n\tint rowsize;\n\tint pad;\n\tunsigned int z;\n\tint nz;\n\tint c;\n\tint x;\n\tint y;\n\tint v;\n\tjas_matrix_t *data[3];\n\tint i;\n\n\tassert(numcmpts <= 3);\n\n\tif (RAS_ISRGB(hdr) && numcmpts < 3) {\n\t\t/* need 3 components for RGB */\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tdata[i] = 0;\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(data[i] = jas_matrix_create(jas_image_height(image),\n\t\t  jas_image_width(image)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trowsize = RAS_ROWSIZE(hdr);\n\tpad = rowsize - (hdr->width * hdr->depth + 7) / 8;\n\n\thdr->length = hdr->height * rowsize;\n\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tfor (i = 0; i < numcmpts; ++i) {\n\t\t\tif (jas_image_readcmpt(image, cmpts[i], 0, y,\n\t\t\t\t\tjas_image_width(image), 1, data[i])) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tz = 0;\n\t\tnz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\tz <<= hdr->depth;\n\t\t\tif (RAS_ISRGB(hdr)) {\n\t\t\t\tv = RAS_RED((jas_matrix_getv(data[0], x))) |\n\t\t\t\t  RAS_GREEN((jas_matrix_getv(data[1], x))) |\n\t\t\t\t  RAS_BLUE((jas_matrix_getv(data[2], x)));\n\t\t\t} else {\n\t\t\t\tv = (jas_matrix_getv(data[0], x));\n\t\t\t}\n\t\t\tz |= v & RAS_ONES(hdr->depth);\n\t\t\tnz += hdr->depth;\n\t\t\twhile (nz >= 8) {\n\t\t\t\tc = (z >> (nz - 8)) & 0xff;\n\t\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tnz -= 8;\n\t\t\t\tz &= RAS_ONES(nz);\n\t\t\t}\n\t\t}\n\t\tif (nz > 0) {\n\t\t\tc = (z >> (8 - nz)) & RAS_ONES(nz);\n\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (pad % 2) {\n\t\t\tif (jas_stream_putc(out, 0) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t\tdata[i] = 0;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (data[i]) {\n\t\t\tjas_matrix_destroy(data[i]);\n\t\t}\n\t}\n\treturn -1;\n}""}]","{""value"": 2, ""code"": 2}","[{""source"": ""value_info(file:ras_enc.c, value:data)"", ""result"": {""value_trace"": [{""full_code"": ""*data[3]"", ""line"": 230, ""func_name"": ""ras_putdatastd""}], ""struct_var"": ""data"", ""struct_type"": ""jas_matrix_t**[3]"", ""struct_definition"": null}}, {""source"": ""code_info(file:ras_enc.c, lines:200-250)"", ""result"": ""\t}\n\n\treturn 0;\n}\n\nstatic int ras_putdata(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image, int numcmpts, int *cmpts)\n{\n\tint ret;\n\n\tswitch (hdr->type) {\n\tcase RAS_TYPE_STD:\n\t\tret = ras_putdatastd(out, hdr, image, numcmpts, cmpts);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image,  int numcmpts, int *cmpts)\n{\n\tint rowsize;\n\tint pad;\n\tunsigned int z;\n\tint nz;\n\tint c;\n\tint x;\n\tint y;\n\tint v;\n\tjas_matrix_t *data[3];\n\tint i;\n\n\tassert(numcmpts <= 3);\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tdata[i] = 0;\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(data[i] = jas_matrix_create(jas_image_height(image),\n\t\t  jas_image_width(image)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trowsize = RAS_ROWSIZE(hdr);\n\tpad = rowsize - (hdr->width * hdr->depth + 7) / 8;\n\n\thdr->length = hdr->height * rowsize;\n\n\tfor (y = 0; y < hdr->height; y++) {\n""}, {""source"": ""value_info(file:ras_enc.c, value:data)"", ""result"": {""value_trace"": [{""full_code"": ""*data[3]"", ""line"": 230, ""func_name"": ""ras_putdatastd""}], ""struct_var"": ""data"", ""struct_type"": ""jas_matrix_t**[3]"", ""struct_definition"": null}}, {""source"": ""code_info(file:ras_enc.c, lines:250-300)"", ""result"": ""\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tfor (i = 0; i < numcmpts; ++i) {\n\t\t\tif (jas_image_readcmpt(image, cmpts[i], 0, y,\n\t\t\t\t\tjas_image_width(image), 1, data[i])) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tz = 0;\n\t\tnz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\tz <<= hdr->depth;\n\t\t\tif (RAS_ISRGB(hdr)) {\n\t\t\t\tv = RAS_RED((jas_matrix_getv(data[0], x))) |\n\t\t\t\t  RAS_GREEN((jas_matrix_getv(data[1], x))) |\n\t\t\t\t  RAS_BLUE((jas_matrix_getv(data[2], x)));\n\t\t\t} else {\n\t\t\t\tv = (jas_matrix_getv(data[0], x));\n\t\t\t}\n\t\t\tz |= v & RAS_ONES(hdr->depth);\n\t\t\tnz += hdr->depth;\n\t\t\twhile (nz >= 8) {\n\t\t\t\tc = (z >> (nz - 8)) & 0xff;\n\t\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tnz -= 8;\n\t\t\t\tz &= RAS_ONES(nz);\n\t\t\t}\n\t\t}\n\t\tif (nz > 0) {\n\t\t\tc = (z >> (8 - nz)) & RAS_ONES(nz);\n\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (pad % 2) {\n\t\t\tif (jas_stream_putc(out, 0) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t\tdata[i] = 0;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < numcmpts; ++i) {\n""}]","src/libjasper/ras/ras_enc.c:237-239 accesses 'data[i]' in a loop assuming 3 components. When RAS_ISRGB(hdr) is true and numcmpts < 3 (unvalidated pre-patch), data[0..2] is partially initialized (only i < numcmpts). src/libjasper/ras/ras_enc.c:250-300 dereferences data[0], data[1], data[2] during pixel processing. For i >= numcmpts, data[i] remains NULL, causing a dereference. Patch adds src/libjasper/ras/ras_enc.c:234-236 to return -1 in this case.",0.95,./github/other_context/CVE-2018-18873
17,CVE-2018-8099,CWE-415,c_cpp,"Incorrect returning of an error code in the index.c:read_entry() function leads to a double free in libgit2 before v0.26.2, which allows an attacker to cause a denial of service via a crafted repository index file.",https://github.com/libgit2/libgit2/commit/58a6fe94cb851f71214dbefac3f9bffee437d6fe,"index: convert `read_entry` to return entry size via an out-param\n\nThe function `read_entry` does not conform to our usual coding style of\nreturning stuff via the out parameter and to use the return value for\nreporting errors. Due to most of our code conforming to that pattern, it\nhas become quite natural for us to actually return `-1` in case there is\nany error, which has also slipped in with commit 5625d86b9 (index:\nsupport index v4, 2016-05-17). As the function returns an `size_t` only,\nthough, the return value is wrapped around, causing the caller of\n`read_tree` to continue with an invalid index entry. Ultimately, this\ncan lead to a double-free.\n\nImprove code and fix the bug by converting the function to return the\nindex entry size via an out parameter and only using the return value to\nindicate errors.\n\nReported-by: Krishna Ram Prakash R <krp@gtux.in>\nReported-by: Vivek Parikh <viv0411.parikh@gmail.com>",2,"[{""func_name"": ""parse_index"", ""file_path"": ""src/index.c"", ""func_code"": ""static int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\tconst char *last = NULL;\n\tconst char *empty = \""\"";\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\""ran out of data while parsing\""); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\""insufficient buffer space\"");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tindex->version = header.version;\n\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\tlast = empty;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tgit_idxmap_resize(index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry = NULL;\n\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);\n\n\t\t/* 0 bytes read means an object corruption */\n\t\tif (entry_size == 0) {\n\t\t\terror = index_error_invalid(\""invalid entry\"");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, &error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\t\tlast = entry->path;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\""header entries changed while parsing\"");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\""extension is truncated\"");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\""buffer size does not match index footer size\"");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\""calculated checksum does not match expected\"");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}"", ""target"": 0}, {""func_name"": ""read_entry"", ""file_path"": ""src/index.c"", ""func_code"": ""static size_t read_entry(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn 0;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn 0;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\""incorrect prefix length\"");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn 0;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn 0;\n\t}\n\n\tgit__free(tmp_path);\n\treturn entry_size;\n}"", ""target"": 0}]","[{""func_name"": ""parse_index"", ""file_path"": ""src/index.c"", ""func_code"": ""static int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\tconst char *last = NULL;\n\tconst char *empty = \""\"";\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\""ran out of data while parsing\""); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\""insufficient buffer space\"");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tindex->version = header.version;\n\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\tlast = empty;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tgit_idxmap_resize(index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry = NULL;\n\t\tsize_t entry_size;\n\n\t\tif ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {\n\t\t\terror = index_error_invalid(\""invalid entry\"");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, &error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\t\tlast = entry->path;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\""header entries changed while parsing\"");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\""extension is truncated\"");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\""buffer size does not match index footer size\"");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\""calculated checksum does not match expected\"");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}""}, {""func_name"": ""read_entry"", ""file_path"": ""src/index.c"", ""func_code"": ""static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\""incorrect prefix length\"");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}""}]",{},[],"src/index.c:2303-2388: read_entry returned 0 for errors (e.g., buffer overflow) due to using size_t. This was misinterpreted as a valid entry size (0 bytes) by callers like parse_index, leading to invalid entries being processed. The patch changes return type to int, uses -1 for errors, and adds an out-param for size. parse_index now checks for negative returns (src/index.c:2500-2509), preventing invalid entries.",0.95,./github/other_context/CVE-2018-8099
18,CVE-2018-9336,CWE-415,c_cpp,openvpnserv.exe (aka the interactive service helper) in OpenVPN 2.4.x before 2.4.6 allows a local attacker to cause a double-free of memory by sending a malformed request to the interactive service. This could cause a denial-of-service through memory corruption or possibly have unspecified other impact including privilege escalation.,https://github.com/OpenVPN/openvpn/commit/1394192b210cb3c6624a7419bcf3ff966742e79b,"Fix potential double-free() in Interactive Service (CVE-2018-9336)\n\nMalformed input data on the service pipe towards the OpenVPN interactive\nservice (normally used by the OpenVPN GUI to request openvpn instances\nfrom the service) can result in a double free() in the error handling code.\n\nThis usually only leads to a process crash (DoS by an unprivileged local\naccount) but since it could possibly lead to memory corruption if\nhappening while multiple other threads are active at the same time,\nCVE-2018-9336 has been assigned to acknowledge this risk.\n\nFix by ensuring that sud->directory is set to NULL in GetStartUpData()\nfor all error cases (thus not being free()ed in FreeStartupData()).\n\nRewrite control flow to use explicit error label for error exit.\n\nDiscovered and reported by Jacob Baines <jbaines@tenable.com>.\n\nCVE: 2018-9336\n\nSigned-off-by: Gert Doering <gert@greenie.muc.de>\nAcked-by: Selva Nair <selva.nair@gmail.com>\nMessage-Id: <20180414072617.25075-1-gert@greenie.muc.de>\nURL: https://www.mail-archive.com/search?l=mid&q=20180414072617.25075-1-gert@greenie.muc.de\n\nSigned-off-by: Gert Doering <gert@greenie.muc.de>",1,"[{""func_name"": ""GetStartupData"", ""file_path"": ""src/openvpnserv/interactive.c"", ""func_code"": ""static BOOL\nGetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n{\n    size_t size, len;\n    BOOL ret = FALSE;\n    WCHAR *data = NULL;\n    DWORD bytes, read;\n\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\""PeekNamedPipeAsync failed\""));\n        ReturnLastError(pipe, L\""PeekNamedPipeAsync\"");\n        goto out;\n    }\n\n    size = bytes / sizeof(*data);\n    if (size == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\""malformed startup data: 1 byte received\""));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n        goto out;\n    }\n\n    data = malloc(bytes);\n    if (data == NULL)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\""malloc failed\""));\n        ReturnLastError(pipe, L\""malloc\"");\n        goto out;\n    }\n\n    read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n    if (bytes != read)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\""ReadPipeAsync failed\""));\n        ReturnLastError(pipe, L\""ReadPipeAsync\"");\n        goto out;\n    }\n\n    if (data[size - 1] != 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\""Startup data is not NULL terminated\""));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n        goto out;\n    }\n\n    sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\""Startup data ends at working directory\""));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n        goto out;\n    }\n\n    sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\""Startup data ends at command line options\""));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n        goto out;\n    }\n\n    sud->std_input = sud->options + len;\n    data = NULL; /* don't free data */\n    ret = TRUE;\n\nout:\n    free(data);\n    return ret;\n}"", ""target"": 0}]","[{""func_name"": ""GetStartupData"", ""file_path"": ""src/openvpnserv/interactive.c"", ""func_code"": ""static BOOL\nGetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n{\n    size_t size, len;\n    WCHAR *data = NULL;\n    DWORD bytes, read;\n\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\""PeekNamedPipeAsync failed\""));\n        ReturnLastError(pipe, L\""PeekNamedPipeAsync\"");\n        goto err;\n    }\n\n    size = bytes / sizeof(*data);\n    if (size == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\""malformed startup data: 1 byte received\""));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n        goto err;\n    }\n\n    data = malloc(bytes);\n    if (data == NULL)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\""malloc failed\""));\n        ReturnLastError(pipe, L\""malloc\"");\n        goto err;\n    }\n\n    read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n    if (bytes != read)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\""ReadPipeAsync failed\""));\n        ReturnLastError(pipe, L\""ReadPipeAsync\"");\n        goto err;\n    }\n\n    if (data[size - 1] != 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\""Startup data is not NULL terminated\""));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n        goto err;\n    }\n\n    sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\""Startup data ends at working directory\""));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n        goto err;\n    }\n\n    sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\""Startup data ends at command line options\""));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\""GetStartupData\"", 1, &exit_event);\n        goto err;\n    }\n\n    sud->std_input = sud->options + len;\n    return TRUE;\n\nerr:\n    sud->directory = NULL;\t\t/* caller must not free() */\n    free(data);\n    return FALSE;\n}""}]","{""function"": 1}","[{""source"": ""func_info(file:interactive.c, func:FreeStartupData)"", ""result"": [{""code"": ""static VOID\nFreeStartupData(STARTUP_DATA *sud)\n{\n    free(sud->directory);\n}"", ""start_line"": 529, ""end_line"": 533, ""full_name"": ""FreeStartupData"", ""file_path"": ""src/openvpnserv/interactive.c""}]}]","Malformed input triggers error handling in GetStartupData() (interactive.c:454-515). In the original code, error paths (e.g., PeekNamedPipeAsync failure, non-NULL-terminated data) jumped to 'out' instead of 'err', freeing 'data' but leaving 'sud->directory' pointing to it. FreeStartupData() (interactive.c:529-533) then frees 'sud->directory' again, causing a double-free. The patch ensures 'sud->directory = NULL' in all error paths via the 'err' label.",0.95,./github/other_context/CVE-2018-9336
19,CVE-2019-19725,CWE-415,c_cpp,sysstat through 12.2.0 has a double free in check_file_actlst in sa_common.c.,https://github.com/sysstat/sysstat/commit/a5c8abd4a481ee6e27a3acf00e6d9b0f023e20ed,Fix #242: Double free in check_file_actlst()\n\nAvoid freeing buffer() twice.\n\nSigned-off-by: Sebastien GODARD <sysstat@users.noreply.github.com>,1,"[{""func_name"": ""check_file_actlst"", ""file_path"": ""sa_common.c"", ""func_code"": ""void check_file_actlst(int *ifd, char *dfile, struct activity *act[], uint64_t flags,\n\t\t       struct file_magic *file_magic, struct file_header *file_hdr,\n\t\t       struct file_activity **file_actlst, unsigned int id_seq[],\n\t\t       int ignore, int *endian_mismatch, int *arch_64)\n{\n\tint i, j, k, p;\n\tstruct file_activity *fal;\n\tvoid *buffer = NULL;\n\tsize_t bh_size = FILE_HEADER_SIZE;\n\tsize_t ba_size = FILE_ACTIVITY_SIZE;\n\n\t/* Open sa data file and read its magic structure */\n\tif (sa_open_read_magic(ifd, dfile, file_magic, ignore, endian_mismatch, TRUE) < 0)\n\t\t/*\n\t\t * Not current sysstat's format.\n\t\t * Return now so that sadf -H can display at least\n\t\t * file's version and magic number.\n\t\t */\n\t\treturn;\n\n\t/*\n\t * We know now that we have a *compatible* sysstat datafile format\n\t * (correct FORMAT_MAGIC value), and in this case, we should have\n\t * checked header_size value. Anyway, with a corrupted datafile,\n\t * this may not be the case. So check again.\n\t */\n\tif ((file_magic->header_size <= MIN_FILE_HEADER_SIZE) ||\n\t    (file_magic->header_size > MAX_FILE_HEADER_SIZE)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \""%s: header_size=%u\\n\"",\n\t\t\t__FUNCTION__, file_magic->header_size);\n#endif\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_header structure */\n\tif (file_magic->header_size > FILE_HEADER_SIZE) {\n\t\tbh_size = file_magic->header_size;\n\t}\n\tSREALLOC(buffer, char, bh_size);\n\n\t/* Read sa data file standard header and allocate activity list */\n\tsa_fread(*ifd, buffer, (size_t) file_magic->header_size, HARD_SIZE, UEOF_STOP);\n\t/*\n\t * Data file header size (file_magic->header_size) may be greater or\n\t * smaller than FILE_HEADER_SIZE. Remap the fields of the file header\n\t * then copy its contents to the expected structure.\n\t */\n\tif (remap_struct(hdr_types_nr, file_magic->hdr_types_nr, buffer,\n\t\t\t file_magic->header_size, FILE_HEADER_SIZE, bh_size) < 0)\n\t\tgoto format_error;\n\n\tmemcpy(file_hdr, buffer, FILE_HEADER_SIZE);\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Tell that data come from a 64 bit machine */\n\t*arch_64 = (file_hdr->sa_sizeof_long == SIZEOF_LONG_64BIT);\n\n\t/* Normalize endianness for file_hdr structure */\n\tif (*endian_mismatch) {\n\t\tswap_struct(hdr_types_nr, file_hdr, *arch_64);\n\t}\n\n\t/*\n\t * Sanity checks.\n\t * NB: Compare against MAX_NR_ACT and not NR_ACT because\n\t * we are maybe reading a datafile from a future sysstat version\n\t * with more activities than known today.\n\t */\n\tif ((file_hdr->sa_act_nr > MAX_NR_ACT) ||\n\t    (file_hdr->act_size > MAX_FILE_ACTIVITY_SIZE) ||\n\t    (file_hdr->rec_size > MAX_RECORD_HEADER_SIZE) ||\n\t    (MAP_SIZE(file_hdr->act_types_nr) > file_hdr->act_size) ||\n\t    (MAP_SIZE(file_hdr->rec_types_nr) > file_hdr->rec_size)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \""%s: sa_act_nr=%d act_size=%u rec_size=%u map_size(act)=%u map_size(rec)=%u\\n\"",\n\t\t\t__FUNCTION__, file_hdr->sa_act_nr, file_hdr->act_size, file_hdr->rec_size,\n\t\t\tMAP_SIZE(file_hdr->act_types_nr), MAP_SIZE(file_hdr->rec_types_nr));\n#endif\n\t\t/* Maybe a \""false positive\"" sysstat datafile? */\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_activity structures */\n\tif (file_hdr->act_size > FILE_ACTIVITY_SIZE) {\n\t\tba_size = file_hdr->act_size;\n\t}\n\tSREALLOC(buffer, char, ba_size);\n\tSREALLOC(*file_actlst, struct file_activity, FILE_ACTIVITY_SIZE * file_hdr->sa_act_nr);\n\tfal = *file_actlst;\n\n\t/* Read activity list */\n\tj = 0;\n\tfor (i = 0; i < file_hdr->sa_act_nr; i++, fal++) {\n\n\t\t/* Read current file_activity structure from file */\n\t\tsa_fread(*ifd, buffer, (size_t) file_hdr->act_size, HARD_SIZE, UEOF_STOP);\n\t\t/*\n\t\t* Data file_activity size (file_hdr->act_size) may be greater or\n\t\t* smaller than FILE_ACTIVITY_SIZE. Remap the fields of the file's structure\n\t\t* then copy its contents to the expected structure.\n\t\t*/\n\t\tif (remap_struct(act_types_nr, file_hdr->act_types_nr, buffer,\n\t\t\t     file_hdr->act_size, FILE_ACTIVITY_SIZE, ba_size) < 0)\n\t\t\tgoto format_error;\n\t\tmemcpy(fal, buffer, FILE_ACTIVITY_SIZE);\n\n\t\t/* Normalize endianness for file_activity structures */\n\t\tif (*endian_mismatch) {\n\t\t\tswap_struct(act_types_nr, fal, *arch_64);\n\t\t}\n\n\t\t/*\n\t\t * Every activity, known or unknown, should have\n\t\t * at least one item and sub-item, and a positive size value.\n\t\t * Also check that the number of items and sub-items\n\t\t * doesn't exceed a max value. This is necessary\n\t\t * because we will use @nr and @nr2 to\n\t\t * allocate memory to read the file contents. So we\n\t\t * must make sure the file is not corrupted.\n\t\t * NB: Another check will be made below for known\n\t\t * activities which have each a specific max value.\n\t\t */\n\t\tif ((fal->nr < 1) || (fal->nr2 < 1) ||\n\t\t    (fal->nr > NR_MAX) || (fal->nr2 > NR2_MAX) ||\n\t\t    (fal->size <= 0)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: id=%d nr=%d nr2=%d\\n\"",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, fal->nr2);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif ((p = get_activity_position(act, fal->id, RESUME_IF_NOT_FOUND)) < 0)\n\t\t\t/* Unknown activity */\n\t\t\tcontinue;\n\n\t\tif (act[p]->magic != fal->magic) {\n\t\t\t/* Bad magical number */\n\t\t\tif (ignore) {\n\t\t\t\t/*\n\t\t\t\t * This is how sadf -H knows that this\n\t\t\t\t * activity has an unknown format.\n\t\t\t\t */\n\t\t\t\tact[p]->magic = ACTIVITY_MAGIC_UNKNOWN;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check max value for known activities */\n\t\tif (fal->nr > act[p]->nr_max) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: id=%d nr=%d nr_max=%d\\n\"",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, act[p]->nr_max);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\t/*\n\t\t * Number of fields of each type (\""long long\"", or \""long\""\n\t\t * or \""int\"") composing the structure with statistics may\n\t\t * only increase with new sysstat versions. Here, we may\n\t\t * be reading a file created by current sysstat version,\n\t\t * or by an older or a newer version.\n\t\t */\n\t\tif (!(((fal->types_nr[0] >= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] >= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] >= act[p]->gtypes_nr[2]))\n\t\t     ||\n\t\t     ((fal->types_nr[0] <= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] <= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] <= act[p]->gtypes_nr[2]))) && !ignore) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: id=%d file=%d,%d,%d activity=%d,%d,%d\\n\"",\n\t\t\t\t__FUNCTION__, fal->id, fal->types_nr[0], fal->types_nr[1], fal->types_nr[2],\n\t\t\t\tact[p]->gtypes_nr[0], act[p]->gtypes_nr[1], act[p]->gtypes_nr[2]);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif (MAP_SIZE(fal->types_nr) > fal->size) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \""%s: id=%d size=%u map_size=%u\\n\"",\n\t\t\t__FUNCTION__, fal->id, fal->size, MAP_SIZE(fal->types_nr));\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tfor (k = 0; k < 3; k++) {\n\t\t\tact[p]->ftypes_nr[k] = fal->types_nr[k];\n\t\t}\n\n\t\tif (fal->size > act[p]->msize) {\n\t\t\tact[p]->msize = fal->size;\n\t\t}\n\n\t\tact[p]->nr_ini = fal->nr;\n\t\tact[p]->nr2    = fal->nr2;\n\t\tact[p]->fsize  = fal->size;\n\t\t/*\n\t\t * This is a known activity with a known format\n\t\t * (magical number). Only such activities will be displayed.\n\t\t * (Well, this may also be an unknown format if we have entered sadf -H.)\n\t\t */\n\t\tid_seq[j++] = fal->id;\n\t}\n\n\twhile (j < NR_ACT) {\n\t\tid_seq[j++] = 0;\n\t}\n\n\tfree(buffer);\n\n\t/* Check that at least one activity selected by the user is available in file */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!IS_SELECTED(act[i]->options))\n\t\t\tcontinue;\n\n\t\t/* Here is a selected activity: Does it exist in file? */\n\t\tfal = *file_actlst;\n\t\tfor (j = 0; j < file_hdr->sa_act_nr; j++, fal++) {\n\t\t\tif (act[i]->id == fal->id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == file_hdr->sa_act_nr) {\n\t\t\t/* No: Unselect it */\n\t\t\tact[i]->options &= ~AO_SELECTED;\n\t\t}\n\t}\n\n\t/*\n\t * None of selected activities exist in file: Abort.\n\t * NB: Error is ignored if we only want to display\n\t * datafile header (sadf -H).\n\t */\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES) && !DISPLAY_HDR_ONLY(flags)) {\n\t\tfprintf(stderr, _(\""Requested activities not available in file %s\\n\""),\n\t\t\tdfile);\n\t\tclose(*ifd);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Check if there are some extra structures.\n\t * We will just skip them as they are unknown for now.\n\t */\n\tif (file_hdr->extra_next && (skip_extra_struct(*ifd, *endian_mismatch, *arch_64) < 0))\n\t\tgoto format_error;\n\n\treturn;\n\nformat_error:\n\tif (buffer) {\n\t\tfree(buffer);\n\t}\n\thandle_invalid_sa_file(*ifd, file_magic, dfile, 0);\n}"", ""target"": 0}]","[{""func_name"": ""check_file_actlst"", ""file_path"": ""sa_common.c"", ""func_code"": ""void check_file_actlst(int *ifd, char *dfile, struct activity *act[], uint64_t flags,\n\t\t       struct file_magic *file_magic, struct file_header *file_hdr,\n\t\t       struct file_activity **file_actlst, unsigned int id_seq[],\n\t\t       int ignore, int *endian_mismatch, int *arch_64)\n{\n\tint i, j, k, p;\n\tstruct file_activity *fal;\n\tvoid *buffer = NULL;\n\tsize_t bh_size = FILE_HEADER_SIZE;\n\tsize_t ba_size = FILE_ACTIVITY_SIZE;\n\n\t/* Open sa data file and read its magic structure */\n\tif (sa_open_read_magic(ifd, dfile, file_magic, ignore, endian_mismatch, TRUE) < 0)\n\t\t/*\n\t\t * Not current sysstat's format.\n\t\t * Return now so that sadf -H can display at least\n\t\t * file's version and magic number.\n\t\t */\n\t\treturn;\n\n\t/*\n\t * We know now that we have a *compatible* sysstat datafile format\n\t * (correct FORMAT_MAGIC value), and in this case, we should have\n\t * checked header_size value. Anyway, with a corrupted datafile,\n\t * this may not be the case. So check again.\n\t */\n\tif ((file_magic->header_size <= MIN_FILE_HEADER_SIZE) ||\n\t    (file_magic->header_size > MAX_FILE_HEADER_SIZE)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \""%s: header_size=%u\\n\"",\n\t\t\t__FUNCTION__, file_magic->header_size);\n#endif\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_header structure */\n\tif (file_magic->header_size > FILE_HEADER_SIZE) {\n\t\tbh_size = file_magic->header_size;\n\t}\n\tSREALLOC(buffer, char, bh_size);\n\n\t/* Read sa data file standard header and allocate activity list */\n\tsa_fread(*ifd, buffer, (size_t) file_magic->header_size, HARD_SIZE, UEOF_STOP);\n\t/*\n\t * Data file header size (file_magic->header_size) may be greater or\n\t * smaller than FILE_HEADER_SIZE. Remap the fields of the file header\n\t * then copy its contents to the expected structure.\n\t */\n\tif (remap_struct(hdr_types_nr, file_magic->hdr_types_nr, buffer,\n\t\t\t file_magic->header_size, FILE_HEADER_SIZE, bh_size) < 0)\n\t\tgoto format_error;\n\n\tmemcpy(file_hdr, buffer, FILE_HEADER_SIZE);\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Tell that data come from a 64 bit machine */\n\t*arch_64 = (file_hdr->sa_sizeof_long == SIZEOF_LONG_64BIT);\n\n\t/* Normalize endianness for file_hdr structure */\n\tif (*endian_mismatch) {\n\t\tswap_struct(hdr_types_nr, file_hdr, *arch_64);\n\t}\n\n\t/*\n\t * Sanity checks.\n\t * NB: Compare against MAX_NR_ACT and not NR_ACT because\n\t * we are maybe reading a datafile from a future sysstat version\n\t * with more activities than known today.\n\t */\n\tif ((file_hdr->sa_act_nr > MAX_NR_ACT) ||\n\t    (file_hdr->act_size > MAX_FILE_ACTIVITY_SIZE) ||\n\t    (file_hdr->rec_size > MAX_RECORD_HEADER_SIZE) ||\n\t    (MAP_SIZE(file_hdr->act_types_nr) > file_hdr->act_size) ||\n\t    (MAP_SIZE(file_hdr->rec_types_nr) > file_hdr->rec_size)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \""%s: sa_act_nr=%d act_size=%u rec_size=%u map_size(act)=%u map_size(rec)=%u\\n\"",\n\t\t\t__FUNCTION__, file_hdr->sa_act_nr, file_hdr->act_size, file_hdr->rec_size,\n\t\t\tMAP_SIZE(file_hdr->act_types_nr), MAP_SIZE(file_hdr->rec_types_nr));\n#endif\n\t\t/* Maybe a \""false positive\"" sysstat datafile? */\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_activity structures */\n\tif (file_hdr->act_size > FILE_ACTIVITY_SIZE) {\n\t\tba_size = file_hdr->act_size;\n\t}\n\tSREALLOC(buffer, char, ba_size);\n\tSREALLOC(*file_actlst, struct file_activity, FILE_ACTIVITY_SIZE * file_hdr->sa_act_nr);\n\tfal = *file_actlst;\n\n\t/* Read activity list */\n\tj = 0;\n\tfor (i = 0; i < file_hdr->sa_act_nr; i++, fal++) {\n\n\t\t/* Read current file_activity structure from file */\n\t\tsa_fread(*ifd, buffer, (size_t) file_hdr->act_size, HARD_SIZE, UEOF_STOP);\n\t\t/*\n\t\t* Data file_activity size (file_hdr->act_size) may be greater or\n\t\t* smaller than FILE_ACTIVITY_SIZE. Remap the fields of the file's structure\n\t\t* then copy its contents to the expected structure.\n\t\t*/\n\t\tif (remap_struct(act_types_nr, file_hdr->act_types_nr, buffer,\n\t\t\t     file_hdr->act_size, FILE_ACTIVITY_SIZE, ba_size) < 0)\n\t\t\tgoto format_error;\n\t\tmemcpy(fal, buffer, FILE_ACTIVITY_SIZE);\n\n\t\t/* Normalize endianness for file_activity structures */\n\t\tif (*endian_mismatch) {\n\t\t\tswap_struct(act_types_nr, fal, *arch_64);\n\t\t}\n\n\t\t/*\n\t\t * Every activity, known or unknown, should have\n\t\t * at least one item and sub-item, and a positive size value.\n\t\t * Also check that the number of items and sub-items\n\t\t * doesn't exceed a max value. This is necessary\n\t\t * because we will use @nr and @nr2 to\n\t\t * allocate memory to read the file contents. So we\n\t\t * must make sure the file is not corrupted.\n\t\t * NB: Another check will be made below for known\n\t\t * activities which have each a specific max value.\n\t\t */\n\t\tif ((fal->nr < 1) || (fal->nr2 < 1) ||\n\t\t    (fal->nr > NR_MAX) || (fal->nr2 > NR2_MAX) ||\n\t\t    (fal->size <= 0)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: id=%d nr=%d nr2=%d\\n\"",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, fal->nr2);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif ((p = get_activity_position(act, fal->id, RESUME_IF_NOT_FOUND)) < 0)\n\t\t\t/* Unknown activity */\n\t\t\tcontinue;\n\n\t\tif (act[p]->magic != fal->magic) {\n\t\t\t/* Bad magical number */\n\t\t\tif (ignore) {\n\t\t\t\t/*\n\t\t\t\t * This is how sadf -H knows that this\n\t\t\t\t * activity has an unknown format.\n\t\t\t\t */\n\t\t\t\tact[p]->magic = ACTIVITY_MAGIC_UNKNOWN;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check max value for known activities */\n\t\tif (fal->nr > act[p]->nr_max) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: id=%d nr=%d nr_max=%d\\n\"",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, act[p]->nr_max);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\t/*\n\t\t * Number of fields of each type (\""long long\"", or \""long\""\n\t\t * or \""int\"") composing the structure with statistics may\n\t\t * only increase with new sysstat versions. Here, we may\n\t\t * be reading a file created by current sysstat version,\n\t\t * or by an older or a newer version.\n\t\t */\n\t\tif (!(((fal->types_nr[0] >= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] >= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] >= act[p]->gtypes_nr[2]))\n\t\t     ||\n\t\t     ((fal->types_nr[0] <= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] <= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] <= act[p]->gtypes_nr[2]))) && !ignore) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: id=%d file=%d,%d,%d activity=%d,%d,%d\\n\"",\n\t\t\t\t__FUNCTION__, fal->id, fal->types_nr[0], fal->types_nr[1], fal->types_nr[2],\n\t\t\t\tact[p]->gtypes_nr[0], act[p]->gtypes_nr[1], act[p]->gtypes_nr[2]);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif (MAP_SIZE(fal->types_nr) > fal->size) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \""%s: id=%d size=%u map_size=%u\\n\"",\n\t\t\t__FUNCTION__, fal->id, fal->size, MAP_SIZE(fal->types_nr));\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tfor (k = 0; k < 3; k++) {\n\t\t\tact[p]->ftypes_nr[k] = fal->types_nr[k];\n\t\t}\n\n\t\tif (fal->size > act[p]->msize) {\n\t\t\tact[p]->msize = fal->size;\n\t\t}\n\n\t\tact[p]->nr_ini = fal->nr;\n\t\tact[p]->nr2    = fal->nr2;\n\t\tact[p]->fsize  = fal->size;\n\t\t/*\n\t\t * This is a known activity with a known format\n\t\t * (magical number). Only such activities will be displayed.\n\t\t * (Well, this may also be an unknown format if we have entered sadf -H.)\n\t\t */\n\t\tid_seq[j++] = fal->id;\n\t}\n\n\twhile (j < NR_ACT) {\n\t\tid_seq[j++] = 0;\n\t}\n\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Check that at least one activity selected by the user is available in file */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!IS_SELECTED(act[i]->options))\n\t\t\tcontinue;\n\n\t\t/* Here is a selected activity: Does it exist in file? */\n\t\tfal = *file_actlst;\n\t\tfor (j = 0; j < file_hdr->sa_act_nr; j++, fal++) {\n\t\t\tif (act[i]->id == fal->id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == file_hdr->sa_act_nr) {\n\t\t\t/* No: Unselect it */\n\t\t\tact[i]->options &= ~AO_SELECTED;\n\t\t}\n\t}\n\n\t/*\n\t * None of selected activities exist in file: Abort.\n\t * NB: Error is ignored if we only want to display\n\t * datafile header (sadf -H).\n\t */\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES) && !DISPLAY_HDR_ONLY(flags)) {\n\t\tfprintf(stderr, _(\""Requested activities not available in file %s\\n\""),\n\t\t\tdfile);\n\t\tclose(*ifd);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Check if there are some extra structures.\n\t * We will just skip them as they are unknown for now.\n\t */\n\tif (file_hdr->extra_next && (skip_extra_struct(*ifd, *endian_mismatch, *arch_64) < 0))\n\t\tgoto format_error;\n\n\treturn;\n\nformat_error:\n\tif (buffer) {\n\t\tfree(buffer);\n\t}\n\thandle_invalid_sa_file(*ifd, file_magic, dfile, 0);\n}""}]","{""code"": 2}","[{""source"": ""code_info(file:sa_common.c, lines:2155-2175)"", ""result"": ""\tfree(buffer);\n\n\t/* Check that at least one activity selected by the user is available in file */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!IS_SELECTED(act[i]->options))\n\t\t\tcontinue;\n\n\t\t/* Here is a selected activity: Does it exist in file? */\n\t\tfal = *file_actlst;\n\t\tfor (j = 0; j < file_hdr->sa_act_nr; j++, fal++) {\n\t\t\tif (act[i]->id == fal->id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == file_hdr->sa_act_nr) {\n\t\t\t/* No: Unselect it */\n\t\t\tact[i]->options &= ~AO_SELECTED;\n\t\t}\n\t}\n\n\t/*\n\t * None of selected activities exist in file: Abort.\n""}, {""source"": ""code_info(file:sa_common.c, lines:2176-2200)"", ""result"": ""\t * None of selected activities exist in file: Abort.\n\t * NB: Error is ignored if we only want to display\n\t * datafile header (sadf -H).\n\t */\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES) && !DISPLAY_HDR_ONLY(flags)) {\n\t\tfprintf(stderr, _(\""Requested activities not available in file %s\\n\""),\n\t\t\tdfile);\n\t\tclose(*ifd);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Check if there are some extra structures.\n\t * We will just skip them as they are unknown for now.\n\t */\n\tif (file_hdr->extra_next && (skip_extra_struct(*ifd, *endian_mismatch, *arch_64) < 0))\n\t\tgoto format_error;\n\n\treturn;\n\nformat_error:\n\tif (buffer) {\n\t\tfree(buffer);\n\t}\n\thandle_invalid_sa_file(*ifd, file_magic, dfile, 0);\n}\n""}]",sa_common.c:2154: First free(buffer) occurs here. sa_common.c:2197-2200: Second free(buffer) occurs in the 'format_error' error-handling block if buffer is non-NULL. The absence of 'buffer = NULL;' before the patch allowed the second free to dereference a freed pointer.,0.95,./github/other_context/CVE-2019-19725
20,CVE-2019-19270,"CWE-476, CWE-295",c_cpp,"An issue was discovered in tls_verify_crl in ProFTPD through 1.3.6b. Failure to check for the appropriate field of a CRL entry (checking twice for subject, rather than once for subject and once for issuer) prevents some valid CRLs from being taken into account, and can allow clients whose certificates have been revoked to proceed with a connection to the server.",https://github.com/proftpd/proftpd/commit/81cc5dce4fc0285629a1b08a07a109af10c208dd,"Issue #859, #861: Fix handling of CRL lookups by properly using issuer for\nlookups, and guarding against null pointers.",1,"[{""func_name"": ""tls_verify_crl"", ""file_path"": ""contrib/mod_tls.c"", ""func_code"": ""static int tls_verify_crl(int ok, X509_STORE_CTX *ctx) {\n  register int i = 0;\n  X509_NAME *subject = NULL, *issuer = NULL;\n  X509 *xs = NULL;\n  STACK_OF(X509_CRL) *crls = NULL;\n  X509_STORE_CTX *store_ctx = NULL;\n  int n, res;\n\n  /* Unless a revocation store for CRLs was created we cannot do any\n   * CRL-based verification, of course.\n   */\n  if (!tls_crl_store) {\n    return ok;\n  }\n\n  tls_log(\""%s\"",\n    \""CRL store present, checking client certificate against configured CRLs\"");\n\n  /* Determine certificate ingredients in advance. */\n  xs = X509_STORE_CTX_get_current_cert(ctx);\n\n  subject = X509_get_subject_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: subject = '%s'\"", tls_x509_name_oneline(subject));\n\n  issuer = X509_get_issuer_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: issuer = '%s'\"", tls_x509_name_oneline(issuer));\n\n  /* OpenSSL provides the general mechanism to deal with CRLs but does not\n   * use them automatically when verifying certificates, so we do it\n   * explicitly here. We will check the CRL for the currently checked\n   * certificate, if there is such a CRL in the store.\n   *\n   * We come through this procedure for each certificate in the certificate\n   * chain, starting with the root-CA's certificate. At each step we've to\n   * both verify the signature on the CRL (to make sure it's a valid CRL)\n   * and its revocation list (to make sure the current certificate isn't\n   * revoked).  But because to check the signature on the CRL we need the\n   * public key of the issuing CA certificate (which was already processed\n   * one round before), we've a little problem. But we can both solve it and\n   * at the same time optimize the processing by using the following\n   * verification scheme (idea and code snippets borrowed from the GLOBUS\n   * project):\n   *\n   * 1. We'll check the signature of a CRL in each step when we find a CRL\n   *    through the _subject_ name of the current certificate. This CRL\n   *    itself will be needed the first time in the next round, of course.\n   *    But we do the signature processing one round before this where the\n   *    public key of the CA is available.\n   *\n   * 2. We'll check the revocation list of a CRL in each step when\n   *    we find a CRL through the _issuer_ name of the current certificate.\n   *    This CRLs signature was then already verified one round before.\n   *\n   * This verification scheme allows a CA to revoke its own certificate as\n   * well, of course.\n   */\n\n  /* Try to retrieve a CRL corresponding to the _subject_ of\n   * the current certificate in order to verify its integrity.\n   */\n  store_ctx = X509_STORE_CTX_new();\n#if OPENSSL_VERSION_NUMBER > 0x000907000L\n  if (X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL) <= 0) {\n    tls_log(\""error initializing CRL store context: %s\"", tls_get_errors());\n    X509_STORE_CTX_free(store_ctx);\n    return ok;\n  }\n#else\n  X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL);\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      X509_CRL *crl = NULL;\n      EVP_PKEY *pubkey;\n      char buf[512];\n      int len;\n      BIO *b = BIO_new(BIO_s_mem());\n\n      crl = sk_X509_CRL_value(crls, i);\n      BIO_printf(b, \""CA CRL: Issuer: \"");\n      X509_NAME_print(b, issuer, 0);\n\n      BIO_printf(b, \"", lastUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_lastUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->lastUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      BIO_printf(b, \"", nextUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_nextUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->nextUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      len = BIO_read(b, buf, sizeof(buf) - 1);\n      if ((size_t) len >= sizeof(buf)) {\n        len = sizeof(buf)-1;\n      }\n      buf[len] = '\\0';\n\n      BIO_free(b);\n      tls_log(\""%s\"", buf);\n\n      pubkey = X509_get_pubkey(xs);\n\n      /* Verify the signature on this CRL */\n      res = X509_CRL_verify(crl, pubkey);\n      if (pubkey) {\n        EVP_PKEY_free(pubkey);\n      }\n\n      if (res <= 0) {\n        tls_log(\""invalid signature on CRL: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_SIGNATURE_FAILURE);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      /* Check date of CRL to make sure it's not expired */\n      res = X509_cmp_current_time(X509_CRL_get_nextUpdate(crl));\n      if (res == 0) {\n        tls_log(\""CRL has invalid nextUpdate field: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx,\n          X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      if (res < 0) {\n        /* XXX This is a bit draconian, rejecting all certificates if the CRL\n         * has expired.  See also Bug#3216, about automatically reloading\n         * the CRL file when it has expired.\n         */\n        tls_log(\""%s\"", \""CRL is expired, revoking all certificates until an \""\n          \""updated CRL is obtained\"");\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n    crls = NULL;\n  }\n\n  /* Try to retrieve a CRL corresponding to the _issuer_ of\n   * the current certificate in order to check for revocation.\n   */\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      register int j;\n      X509_CRL *crl;\n\n      crl = sk_X509_CRL_value(crls, i);\n\n      /* Check if the current certificate is revoked by this CRL */\n      n = sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n      for (j = 0; j < n; j++) {\n        X509_REVOKED *revoked;\n        ASN1_INTEGER *sn;\n\n        revoked = sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), j);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n        sn = X509_REVOKED_get0_serialNumber(revoked);\n#else\n        sn = revoked->serialNumber;\n#endif /* OpenSSL-1.1.x and later */\n\n        if (ASN1_INTEGER_cmp(sn, X509_get_serialNumber(xs)) == 0) {\n          long serial = ASN1_INTEGER_get(sn);\n          char *cp = tls_x509_name_oneline(issuer);\n\n          tls_log(\""certificate with serial number %ld (0x%lX) revoked per CRL \""\n            \""from issuer '%s'\"", serial, serial, cp ? cp : \""(ERROR)\"");\n\n          X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);\n          sk_X509_CRL_free(crls);\n          X509_STORE_CTX_cleanup(store_ctx);\n          X509_STORE_CTX_free(store_ctx);\n          return FALSE;\n        }\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n  }\n\n  X509_STORE_CTX_cleanup(store_ctx);\n  X509_STORE_CTX_free(store_ctx);\n  return ok;\n}"", ""target"": 0}]","[{""func_name"": ""tls_verify_crl"", ""file_path"": ""contrib/mod_tls.c"", ""func_code"": ""static int tls_verify_crl(int ok, X509_STORE_CTX *ctx) {\n  register int i = 0;\n  X509_NAME *subject = NULL, *issuer = NULL;\n  X509 *xs = NULL;\n  STACK_OF(X509_CRL) *crls = NULL;\n  X509_STORE_CTX *store_ctx = NULL;\n  int n, res;\n\n  /* Unless a revocation store for CRLs was created we cannot do any\n   * CRL-based verification, of course.\n   */\n  if (!tls_crl_store) {\n    return ok;\n  }\n\n  tls_log(\""%s\"",\n    \""CRL store present, checking client certificate against configured CRLs\"");\n\n  /* Determine certificate ingredients in advance. */\n  xs = X509_STORE_CTX_get_current_cert(ctx);\n\n  subject = X509_get_subject_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: subject = '%s'\"", tls_x509_name_oneline(subject));\n\n  issuer = X509_get_issuer_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \""verifying cert: issuer = '%s'\"", tls_x509_name_oneline(issuer));\n\n  /* OpenSSL provides the general mechanism to deal with CRLs but does not\n   * use them automatically when verifying certificates, so we do it\n   * explicitly here. We will check the CRL for the currently checked\n   * certificate, if there is such a CRL in the store.\n   *\n   * We come through this procedure for each certificate in the certificate\n   * chain, starting with the root-CA's certificate. At each step we've to\n   * both verify the signature on the CRL (to make sure it's a valid CRL)\n   * and its revocation list (to make sure the current certificate isn't\n   * revoked).  But because to check the signature on the CRL we need the\n   * public key of the issuing CA certificate (which was already processed\n   * one round before), we've a little problem. But we can both solve it and\n   * at the same time optimize the processing by using the following\n   * verification scheme (idea and code snippets borrowed from the GLOBUS\n   * project):\n   *\n   * 1. We'll check the signature of a CRL in each step when we find a CRL\n   *    through the _subject_ name of the current certificate. This CRL\n   *    itself will be needed the first time in the next round, of course.\n   *    But we do the signature processing one round before this where the\n   *    public key of the CA is available.\n   *\n   * 2. We'll check the revocation list of a CRL in each step when\n   *    we find a CRL through the _issuer_ name of the current certificate.\n   *    This CRLs signature was then already verified one round before.\n   *\n   * This verification scheme allows a CA to revoke its own certificate as\n   * well, of course.\n   */\n\n  /* Try to retrieve a CRL corresponding to the _subject_ of\n   * the current certificate in order to verify its integrity.\n   */\n  store_ctx = X509_STORE_CTX_new();\n#if OPENSSL_VERSION_NUMBER > 0x000907000L\n  if (X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL) <= 0) {\n    tls_log(\""error initializing CRL store context: %s\"", tls_get_errors());\n    X509_STORE_CTX_free(store_ctx);\n    return ok;\n  }\n#else\n  X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL);\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      X509_CRL *crl = NULL;\n      EVP_PKEY *pubkey;\n      char buf[512];\n      int len;\n      BIO *b = BIO_new(BIO_s_mem());\n\n      crl = sk_X509_CRL_value(crls, i);\n      BIO_printf(b, \""CA CRL: Issuer: \"");\n      X509_NAME_print(b, issuer, 0);\n\n      BIO_printf(b, \"", lastUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_lastUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->lastUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      BIO_printf(b, \"", nextUpdate: \"");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_nextUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->nextUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      len = BIO_read(b, buf, sizeof(buf) - 1);\n      if ((size_t) len >= sizeof(buf)) {\n        len = sizeof(buf)-1;\n      }\n      buf[len] = '\\0';\n\n      BIO_free(b);\n      tls_log(\""%s\"", buf);\n\n      pubkey = X509_get_pubkey(xs);\n\n      /* Verify the signature on this CRL */\n      res = X509_CRL_verify(crl, pubkey);\n      if (pubkey) {\n        EVP_PKEY_free(pubkey);\n      }\n\n      if (res <= 0) {\n        tls_log(\""invalid signature on CRL: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_SIGNATURE_FAILURE);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      /* Check date of CRL to make sure it's not expired */\n      res = X509_cmp_current_time(X509_CRL_get_nextUpdate(crl));\n      if (res == 0) {\n        tls_log(\""CRL has invalid nextUpdate field: %s\"", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx,\n          X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      if (res < 0) {\n        /* XXX This is a bit draconian, rejecting all certificates if the CRL\n         * has expired.  See also Bug#3216, about automatically reloading\n         * the CRL file when it has expired.\n         */\n        tls_log(\""%s\"", \""CRL is expired, revoking all certificates until an \""\n          \""updated CRL is obtained\"");\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n    crls = NULL;\n  }\n\n  /* Try to retrieve a CRL corresponding to the _issuer_ of\n   * the current certificate in order to check for revocation.\n   */\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, issuer);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, issuer);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      register int j;\n      X509_CRL *crl;\n\n      crl = sk_X509_CRL_value(crls, i);\n\n      /* Check if the current certificate is revoked by this CRL */\n      n = sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n      for (j = 0; j < n; j++) {\n        X509_REVOKED *revoked;\n        ASN1_INTEGER *sn;\n\n        revoked = sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), j);\n        if (revoked == NULL) {\n          continue;\n        }\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n        sn = X509_REVOKED_get0_serialNumber(revoked);\n#else\n        sn = revoked->serialNumber;\n#endif /* OpenSSL-1.1.x and later */\n\n        if (ASN1_INTEGER_cmp(sn, X509_get_serialNumber(xs)) == 0) {\n          long serial = ASN1_INTEGER_get(sn);\n          char *cp = tls_x509_name_oneline(issuer);\n\n          tls_log(\""certificate with serial number %ld (0x%lX) revoked per CRL \""\n            \""from issuer '%s'\"", serial, serial, cp ? cp : \""(ERROR)\"");\n\n          X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);\n          sk_X509_CRL_free(crls);\n          X509_STORE_CTX_cleanup(store_ctx);\n          X509_STORE_CTX_free(store_ctx);\n          return FALSE;\n        }\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n  }\n\n  X509_STORE_CTX_cleanup(store_ctx);\n  X509_STORE_CTX_free(store_ctx);\n  return ok;\n}""}]","{""value"": 2, ""caller"": 1}","[{""source"": ""value_info(file:mod_tls.c, value:subject)"", ""result"": {""value_trace"": [{""full_code"": ""*subject = NULL"", ""line"": 9607, ""func_name"": ""tls_verify_crl""}, {""full_code"": ""subject = X509_get_subject_name(xs)"", ""line"": 9626, ""func_name"": ""tls_verify_crl""}], ""struct_var"": ""subject"", ""struct_type"": ""X509_NAME*"", ""struct_definition"": null}}, {""source"": ""value_info(file:mod_tls.c, value:issuer)"", ""result"": {""value_trace"": [{""full_code"": ""*issuer = NULL"", ""line"": 9607, ""func_name"": ""tls_verify_crl""}, {""full_code"": ""issuer = X509_get_issuer_name(xs)"", ""line"": 9630, ""func_name"": ""tls_verify_crl""}], ""struct_var"": ""issuer"", ""struct_type"": ""X509_NAME*"", ""struct_definition"": null}}, {""source"": ""caller_info(file:mod_tls.c, func:tls_verify_crl)"", ""result"": [{""call_line"": 9500, ""call_code"": ""tls_verify_crl(ok, ctx)"", ""caller_code"": ""static int tls_verify_cb(int ok, X509_STORE_CTX *ctx) {\n  config_rec *c;\n  int verify_err = 0;\n\n  /* We can configure the server to skip the peer's cert verification */\n  if (!(tls_flags & TLS_SESS_VERIFY_CLIENT_REQUIRED) &&\n      !(tls_flags & TLS_SESS_VERIFY_CLIENT_OPTIONAL)) {\n    return 1;\n  }\n\n  c = find_config(main_server->conf, CONF_PARAM, \""TLSVerifyOrder\"", FALSE);\n  if (c) {\n    register unsigned int i;\n\n    for (i = 0; i < c->argc; i++) {\n      char *mech = c->argv[i];\n\n      if (strncasecmp(mech, \""crl\"", 4) == 0) {\n        ok = tls_verify_crl(ok, ctx);\n        if (!ok) {\n          break;\n        }\n\n      } else if (strncasecmp(mech, \""ocsp\"", 5) == 0) {\n        ok = tls_verify_ocsp(ok, ctx);\n        if (!ok) {\n          break;\n        }\n      }\n    }\n\n  } else {\n    /* If no TLSVerifyOrder was specified, default to the old behavior of\n     * always checking CRLs, if configured, and not paying attention to\n     * any AIA attributes (i.e. no use of OCSP).\n     */\n    ok = tls_v..."", ""caller_start"": 9482, ""file_path"": ""contrib/mod_tls.c""}, {""call_line"": 9518, ""call_code"": ""tls_verify_crl(ok, ctx)"", ""caller_code"": ""static int tls_verify_cb(int ok, X509_STORE_CTX *ctx) {\n  config_rec *c;\n  int verify_err = 0;\n\n  /* We can configure the server to skip the peer's cert verification */\n  if (!(tls_flags & TLS_SESS_VERIFY_CLIENT_REQUIRED) &&\n      !(tls_flags & TLS_SESS_VERIFY_CLIENT_OPTIONAL)) {\n    return 1;\n  }\n\n  c = find_config(main_server->conf, CONF_PARAM, \""TLSVerifyOrder\"", FALSE);\n  if (c) {\n    register unsigned int i;\n\n    for (i = 0; i < c->argc; i++) {\n      char *mech = c->argv[i];\n\n      if (strncasecmp(mech, \""crl\"", 4) == 0) {\n        ok = tls_verify_crl(ok, ctx);\n        if (!ok) {\n          break;\n        }\n\n      } else if (strncasecmp(mech, \""ocsp\"", 5) == 0) {\n        ok = tls_verify_ocsp(ok, ctx);\n        if (!ok) {\n          break;\n        }\n      }\n    }\n\n  } else {\n    /* If no TLSVerifyOrder was specified, default to the old behavior of\n     * always checking CRLs, if configured, and not paying attention to\n     * any AIA attributes (i.e. no use of OCSP).\n     */\n    ok = tls_v..."", ""caller_start"": 9482, ""file_path"": ""contrib/mod_tls.c""}]}]","In contrib/mod_tls.c:tls_verify_crl(), the code incorrectly used 'subject = X509_get_subject_name(xs)' (line 9626) instead of 'issuer = X509_get_issuer_name(xs)' (line 9630) when calling X509_STORE_*_get1_crls (lines 9778-9779). This caused CRL lookups to filter by the certificate's subject name rather than its issuer name, ignoring valid CRLs issued by the correct CA. The patch replaces 'subject' with 'issuer' in the CRL lookup, ensuring revoked certificates are properly checked.",0.95,./github/other_context/CVE-2019-19270
21,CVE-2016-8690,CWE-476,c_cpp,The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer before 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted BMP image in an imginfo command.,https://github.com/jasper-software/jasper/commit/8f62b4761711d036fd8964df256b938c809b7fca,"Fixed a sanitizer failure in the BMP codec.\nAlso, added a --debug-level command line option to the imginfo command\nfor debugging purposes.",3,"[{""func_name"": ""main"", ""file_path"": ""src/appl/imginfo.c"", ""func_code"": ""int main(int argc, char **argv)\n{\n\tint fmtid;\n\tint id;\n\tchar *infile;\n\tjas_stream_t *instream;\n\tjas_image_t *image;\n\tint width;\n\tint height;\n\tint depth;\n\tint numcmpts;\n\tint verbose;\n\tchar *fmtname;\n\n\tif (jas_init()) {\n\t\tabort();\n\t}\n\n\tcmdname = argv[0];\n\n\tinfile = 0;\n\tverbose = 0;\n\n\t/* Parse the command line options. */\n\twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {\n\t\tswitch (id) {\n\t\tcase OPT_VERBOSE:\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase OPT_VERSION:\n\t\t\tprintf(\""%s\\n\"", JAS_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase OPT_INFILE:\n\t\t\tinfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase OPT_HELP:\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Open the image file. */\n\tif (infile) {\n\t\t/* The image is to be read from a file. */\n\t\tif (!(instream = jas_stream_fopen(infile, \""rb\""))) {\n\t\t\tfprintf(stderr, \""cannot open input image file %s\\n\"", infile);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else {\n\t\t/* The image is to be read from standard input. */\n\t\tif (!(instream = jas_stream_fdopen(0, \""rb\""))) {\n\t\t\tfprintf(stderr, \""cannot open standard input\\n\"");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif ((fmtid = jas_image_getfmt(instream)) < 0) {\n\t\tfprintf(stderr, \""unknown image format\\n\"");\n\t}\n\n\t/* Decode the image. */\n\tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n\t\tfprintf(stderr, \""cannot load image\\n\"");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t/* Close the image file. */\n\tjas_stream_close(instream);\n\n\tnumcmpts = jas_image_numcmpts(image);\n\twidth = jas_image_cmptwidth(image, 0);\n\theight = jas_image_cmptheight(image, 0);\n\tdepth = jas_image_cmptprec(image, 0);\n\tif (!(fmtname = jas_image_fmttostr(fmtid))) {\n\t\tabort();\n\t}\n\tprintf(\""%s %d %d %d %d %ld\\n\"", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));\n\n\tjas_image_destroy(image);\n\tjas_image_clearfmts();\n\n\treturn EXIT_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""bmp_decode"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c"", ""func_code"": ""jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\""warning: ignoring BMP decoder options\\n\"");\n\t}\n\n\tjas_eprintf(\n\t  \""THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\""\n\t  \""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\""\n\t  \""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\""\n\t  \""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\""\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\""cannot get header\\n\"");\n\t\treturn 0;\n\t}\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\""cannot get info\\n\"");\n\t\treturn 0;\n\t}\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\""error: unsupported BMP encoding\\n\"");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\""error: possibly bad bitmap offset?\\n\"");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\""skipping unknown data in BMP file\\n\"");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}"", ""target"": 1}, {""func_name"": ""bmp_getint32"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c"", ""func_code"": ""static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (c << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""main"", ""file_path"": ""src/appl/imginfo.c"", ""func_code"": ""int main(int argc, char **argv)\n{\n\tint fmtid;\n\tint id;\n\tchar *infile;\n\tjas_stream_t *instream;\n\tjas_image_t *image;\n\tint width;\n\tint height;\n\tint depth;\n\tint numcmpts;\n\tint verbose;\n\tchar *fmtname;\n\tint debug;\n\n\tif (jas_init()) {\n\t\tabort();\n\t}\n\n\tcmdname = argv[0];\n\n\tinfile = 0;\n\tverbose = 0;\n\tdebug = 0;\n\n\t/* Parse the command line options. */\n\twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {\n\t\tswitch (id) {\n\t\tcase OPT_VERBOSE:\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase OPT_VERSION:\n\t\t\tprintf(\""%s\\n\"", JAS_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\tdebug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase OPT_INFILE:\n\t\t\tinfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase OPT_HELP:\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_setdbglevel(debug);\n\n\t/* Open the image file. */\n\tif (infile) {\n\t\t/* The image is to be read from a file. */\n\t\tif (!(instream = jas_stream_fopen(infile, \""rb\""))) {\n\t\t\tfprintf(stderr, \""cannot open input image file %s\\n\"", infile);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else {\n\t\t/* The image is to be read from standard input. */\n\t\tif (!(instream = jas_stream_fdopen(0, \""rb\""))) {\n\t\t\tfprintf(stderr, \""cannot open standard input\\n\"");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif ((fmtid = jas_image_getfmt(instream)) < 0) {\n\t\tfprintf(stderr, \""unknown image format\\n\"");\n\t}\n\n\t/* Decode the image. */\n\tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n\t\tjas_stream_close(instream);\n\t\tfprintf(stderr, \""cannot load image\\n\"");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t/* Close the image file. */\n\tjas_stream_close(instream);\n\n\tnumcmpts = jas_image_numcmpts(image);\n\twidth = jas_image_cmptwidth(image, 0);\n\theight = jas_image_cmptheight(image, 0);\n\tdepth = jas_image_cmptprec(image, 0);\n\tif (!(fmtname = jas_image_fmttostr(fmtid))) {\n\t\tabort();\n\t}\n\tprintf(\""%s %d %d %d %d %ld\\n\"", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));\n\n\tjas_image_destroy(image);\n\tjas_image_clearfmts();\n\n\treturn EXIT_SUCCESS;\n}""}, {""func_name"": ""bmp_decode"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c"", ""func_code"": ""jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\""warning: ignoring BMP decoder options\\n\"");\n\t}\n\n\tjas_eprintf(\n\t  \""THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\""\n\t  \""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\""\n\t  \""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\""\n\t  \""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\""\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\""cannot get header\\n\"");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\"",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\""cannot get info\\n\"");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\""BMP information: len %d; width %d; height %d; numplanes %d; \""\n\t  \""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \""\n\t  \""mincolors %d\\n\"", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\""error: unsupported BMP encoding\\n\"");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\""error: possibly bad bitmap offset?\\n\"");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\""skipping unknown data in BMP file\\n\"");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}""}, {""func_name"": ""bmp_getint32"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c"", ""func_code"": ""static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}""}]","{""function"": 4, ""query"": 1, ""value"": 1, ""code"": 1}","[{""source"": ""func_info(file:bmp_dec.c, func:bmp_getdata)"", ""result"": [{""code"": ""static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t..."", ""start_line"": 309, ""end_line"": 415, ""full_name"": ""bmp_getdata"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c""}]}, {""source"": ""func_info(file:bmp_dec.c, func:bmp_getint32)"", ""result"": [{""code"": ""static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (c << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}"", ""start_line"": 434, ""end_line"": 453, ""full_name"": ""bmp_getint32"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c""}]}, {""source"": ""query_info(query:cpg.call.name(\""bmp_getint32\"").file.name(\""src/libja...)"", ""result"": [""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>"", ""<empty>""]}, {""source"": ""value_info(file:bmp_dec.c, value:bmp_info_t)"", ""result"": {""value_trace"": [{""full_code"": ""bmp_info_t"", ""line"": 89, ""func_name"": null}, {""full_code"": ""typedef struct { int_fast32_t len; /* The length of the bitmap information header in bytes. */ int_fast32_t width; /* The width of the bitmap in pixels. */ int_fast32_t height; /* The height of the bitmap in pixels. */ int_fast8_t topdown; /* The bitmap data is specified in top-down order. */ int_fast16_t numplanes; /* The number of planes. This must be set to a value of one. */ int_fast16_t depth; /* The number of bits per pixel. */ int_fast32_t enctype; /* The type of compression used. */ int_fast32_t siz; /* The size of the image in bytes. */ int_fast32_t hres; /* The horizontal resolution in pixels/metre. */ int_fast32_t vres; /* The vertical resolution in pixels/metre. */ int_fast32_t numcolors; /* The number of color indices used by the bitmap. */ int_fast32_t mincolors; /* The number of color indices important for displaying the bitmap. */ bmp_palent_t *palents; /* The colors should be listed in order of importance. */ } bmp_info_t"", ""line"": 186, ""func_name"": null}], ""struct_var"": ""bmp_info_t"", ""struct_type"": ""bmp_info_t"", ""struct_definition"": ""typedef struct {\n\n\tint_fast32_t len;\n\t/* The length of the bitmap information header in bytes. */\n\n\tint_fast32_t width;\n\t/* The width of the bitmap in pixels. */\n\n\tint_fast32_t height;\n\t/* The height of the bitmap in pixels. */\n\n\tint_fast8_t topdown;\n\t/* The bitmap data is specified in top-down order. */\n\n\tint_fast16_t numplanes;\n\t/* The number of planes.  This must be set to a value of one. */\n\n\tint_fast16_t depth;\n\t/* The number of bits per pixel. */\n\n\tint_fast32_t enctype;\n\t/* The type of compression used. */\n\n\tint_fast32_t siz;\n\t/* The size of the image in bytes. */\n\n\tint_fast32_t hres;\n\t/* The horizontal resolution in pixels/metre. */\n\n\tint_fast32_t vres;\n\t/* The vertical resolution in pixels/metre. */\n\n\tint_fast32_t numcolors;\n\t/* The number of color indices used by the bitmap. */\n\n\tint_fast32_t mincolors;\n\t/* The number of color indices important for displaying the bitmap. */\n\n\tbmp_palent_t *palents;\n\t/* The colors should be listed in order of importance. */\n\n}""}}, {""source"": ""func_info(file:bmp_dec.c, func:bmp_getint32)"", ""result"": [{""code"": ""static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (c << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}"", ""start_line"": 434, ""end_line"": 453, ""full_name"": ""bmp_getint32"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c""}]}, {""source"": ""code_info(file:bmp_dec.c, lines:1-200)"", ""result"": ""/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \""User\"") obtaining a copy of this software and associated documentation\n * files (the \""Software\""), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \""AS IS\"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\""HIGH\n * RISK ACTIVITIES\"").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Windows Bitmap File Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n\n#include \""jasper/jas_types.h\""\n#include \""jasper/jas_stream.h\""\n#include \""jasper/jas_image.h\""\n#include \""jasper/jas_malloc.h\""\n\n#include \""bmp_cod.h\""\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic int bmp_gethdr(jas_stream_t *in, bmp_hdr_t *hdr);\nstatic bmp_info_t *bmp_getinfo(jas_stream_t *in);\nstatic int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image);\nstatic int bmp_getint16(jas_stream_t *in, int_fast16_t *val);\nstatic int bmp_getint32(jas_stream_t *in, int_fast32_t *val);\nstatic int bmp_gobble(jas_stream_t *in, long n);\n\n/******************************************************************************\\\n* Interface functions.\n\\******************************************************************************/\n\njas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\""warning: ignoring BMP decoder options\\n\"");\n\t}\n\n\tjas_eprintf(\n\t  \""THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\""\n\t  \""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\""\n\t  \""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\""\n\t  \""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\""\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\""cannot get header\\n\"");\n\t\treturn 0;\n\t}\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\""cannot get info\\n\"");\n\t\treturn 0;\n\t}\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\""error: unsupported BMP encoding\\n\"");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\""error: possibly bad bitmap offset?\\n\"");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\""skipping unknown data in BMP file\\n\"");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}\n\nint bmp_validate(jas_stream_t *in)\n""}, {""source"": ""func_info(file:bmp_dec.c, func:bmp_getinfo)"", ""result"": [{""code"": ""static bmp_info_t *bmp_getinfo(jas_stream_t *in)\n{\n\tbmp_info_t *info;\n\tint i;\n\tbmp_palent_t *palent;\n\n\tif (!(info = bmp_info_create())) {\n\t\treturn 0;\n\t}\n\n\tif (bmp_getint32(in, &info->len) || info->len != 40 ||\n\t  bmp_getint32(in, &info->width) || bmp_getint32(in, &info->height) ||\n\t  bmp_getint16(in, &info->numplanes) ||\n\t  bmp_getint16(in, &info->depth) || bmp_getint32(in, &info->enctype) ||\n\t  bmp_getint32(in, &info->siz) ||\n\t  bmp_getint32(in, &info->hres) || bmp_getint32(in, &info->vres) ||\n\t  bmp_getint32(in, &info->numcolors) ||\n\t  bmp_getint32(in, &info->mincolors)) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->height < 0) {\n\t\tinfo->topdown = 1;\n\t\tinfo->height = -info->height;\n\t} else {\n\t\tinfo->topdown = 0;\n\t}\n\n\tif (info->width <= 0 || info->height <= 0 || info->numplanes <= 0 ||\n\t  info->depth <= 0  || info->numcolors < 0 || info->mincolors < 0) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (info->enctype != BMP_ENC_RGB) {\n\t\tjas_eprintf(\""unsupported BMP encoding\\n..."", ""start_line"": 244, ""end_line"": 307, ""full_name"": ""bmp_getinfo"", ""file_path"": ""src/libjasper/bmp/bmp_dec.c""}]}]","src/libjasper/bmp/bmp_dec.c:441-447: Improper handling of byte-to-32-bit integer conversion in `bmp_getint32` causes sign extension, leading to invalid `bmp_info_t` fields (e.g., `width`, `height`) during header parsing in `bmp_getinfo` (src/libjasper/bmp/bmp_dec.c:244-307). These invalid values are passed to `bmp_getdata` (src/libjasper/bmp/bmp_dec.c:309-415), which uses them in memory operations (e.g., `jas_matrix_create(1, info->width)`) to allocate matrices. If `info->width` is zero or invalid due to sign extension, `jas_matrix_create` returns NULL, and subsequent dereference of `cmpts[i]` in `bmp_getdata` causes a NULL pointer dereference.",0.95,./github/other_context/CVE-2016-8690
22,CVE-2018-11243,CWE-415,c_cpp,"PackLinuxElf64::unpack in p_lx_elf.cpp in UPX 3.95 allows remote attackers to cause a denial of service (double free), limit the ability of a malware scanner to operate on the entire original data, or possibly have unspecified other impact via a crafted file.",https://github.com/upx/upx/commit/d9288213ec156dffc435566b9d393d23e87c6914,More checking of PT_DYNAMIC and its contents.\n\nhttps://github.com/upx/upx/issues/206\n	modified:   p_lx_elf.cpp,6,"[{""func_name"": ""PackLinuxElf32::check_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""unsigned  // checked .p_offset; sz_dynseg set\nPackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    if (s < t || file_size < (off_t)s\n    ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \""bad PT_DYNAMIC phdr[%u]\"",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}"", ""target"": 1}, {""func_name"": ""PackLinuxElf64::calls_crt1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    for (; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;\n        if (0==strcmp(symnam, \""__libc_start_main\"")  // glibc\n        ||  0==strcmp(symnam, \""__libc_init\"")  // Android\n        ||  0==strcmp(symnam, \""__uClibc_main\"")\n        ||  0==strcmp(symnam, \""__uClibc_start_main\""))\n            return true;\n    }\n    return false;\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf32::canPack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\""invalid Ehdr e_ehsize; try '--force-execve'\"");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\""non-contiguous Ehdr/Phdr; try '--force-execve'\"");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack(\""too many ElfXX_Phdr; try '--force-execve'\"");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: '~': zero extending 'unsigned int' to 'upx_uint64_t' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\"");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\""first PT_LOAD.p_offset != 0; try '--force-execve'\"");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (PT_NOTE32 == p_type) {\n            unsigned const x = get_te32(&phdr->p_memsz);\n            if ( sizeof(elfout.notes) < x  // beware overflow of note_size\n            ||  (sizeof(elfout.notes) < (note_size += x)) ) {\n                throwCantPack(\""PT_NOTEs too big; try '--force-execve'\"");\n                return false;\n            }\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te32(&sec_strndx->sh_offset) + file_image);\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)\"".shstrtab\"",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack(\""bad e_shstrndx\"");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        // Apparently glibc-2.13.90 insists on 0==e_ident[EI_PAD..15],\n        // so compressing shared libraries may be doomed anyway.\n        // 2011-06-01: stub.shlib-init.S works around by installing hatch\n        // at end of .text.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack(\""DT_TEXTREL found; re-compile with -fPIC\"");\n                goto abandon;\n            }\n            Elf32_Shdr const *shdr = shdri;\n            xct_va = ~0u;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te32(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te32(&shdr->sh_offset);\n                        user_init_va = get_te32(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n                        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n                        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED) ) {\n                throwCantPack(\""DT_ tag above stub\"");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    unsigned const vaddr = get_te32(&phdr->p_vaddr);\n                    if (PT_NOTE32 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           \""PT_NOTE %#x above stub\"", vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \""shlib canPack: xct_va=%#lx  xct_off=%lx\\n\"",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack(\""need DT_INIT; try \\\""void _init(void){}\\\""\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}"", ""target"": 1}, {""func_name"": ""PackLinuxElf64::canPack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\""invalid Ehdr e_ehsize; try '--force-execve'\"");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\""non-contiguous Ehdr/Phdr; try '--force-execve'\"");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack(\""too many ElfXX_Phdr; try '--force-execve'\"");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\"");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\""first PT_LOAD.p_offset != 0; try '--force-execve'\"");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te64(&sec_strndx->sh_offset) + file_image);\n        if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)\"".shstrtab\"",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack(\""bad e_shstrndx\"");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack(\""DT_TEXTREL found; re-compile with -fPIC\"");\n                goto abandon;\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te64(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        user_init_va = get_te64(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED) ) {\n                throwCantPack(\""DT_ tag above stub\"");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           \""PT_NOTE %#lx above stub\"", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \""shlib canPack: xct_va=%#lx  xct_off=%lx\\n\"",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack(\""need DT_INIT; try \\\""void _init(void){}\\\""\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}"", ""target"": 1}, {""func_name"": ""PackLinuxElf32::calls_crt1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    for (; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;\n        if (0==strcmp(symnam, \""__libc_start_main\"")  // glibc\n        ||  0==strcmp(symnam, \""__libc_init\"")  // Android\n        ||  0==strcmp(symnam, \""__uClibc_main\"")\n        ||  0==strcmp(symnam, \""__uClibc_start_main\""))\n            return true;\n    }\n    return false;\n}"", ""target"": 2}, {""func_name"": ""PackLinuxElf64::check_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""upx_uint64_t  // checked .p_offset; sz_dynseg set\nPackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)\n{\n    upx_uint64_t t = get_te64(&phdr->p_offset), s = sizeof(Elf64_Dyn) + t;\n    upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);\n    if (s < t || (upx_uint64_t)file_size < s\n    ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)\n    ||  filesz < sizeof(Elf64_Dyn)\n    ||  memsz  < sizeof(Elf64_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \""bad PT_DYNAMIC phdr[%u]\"",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}"", ""target"": 0}]","[{""func_name"": ""PackLinuxElf32::check_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""unsigned  // checked .p_offset; sz_dynseg set\nPackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned vaddr = get_te32(&phdr->p_vaddr);\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    if (s < t || file_size < (off_t)s\n    ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n    ||  (-1+ page_size) & (t ^ vaddr)\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \""bad PT_DYNAMIC phdr[%u]\"",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}""}, {""func_name"": ""PackLinuxElf64::calls_crt1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;\n        if (0==strcmp(symnam, \""__libc_start_main\"")  // glibc\n        ||  0==strcmp(symnam, \""__libc_init\"")  // Android\n        ||  0==strcmp(symnam, \""__uClibc_main\"")\n        ||  0==strcmp(symnam, \""__uClibc_start_main\""))\n            return true;\n    }\n    return false;\n}""}, {""func_name"": ""PackLinuxElf32::canPack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\""invalid Ehdr e_ehsize; try '--force-execve'\"");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\""non-contiguous Ehdr/Phdr; try '--force-execve'\"");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack(\""too many ElfXX_Phdr; try '--force-execve'\"");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: '~': zero extending 'unsigned int' to 'upx_uint64_t' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\"");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\""first PT_LOAD.p_offset != 0; try '--force-execve'\"");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (PT_NOTE32 == p_type) {\n            unsigned const x = get_te32(&phdr->p_memsz);\n            if ( sizeof(elfout.notes) < x  // beware overflow of note_size\n            ||  (sizeof(elfout.notes) < (note_size += x)) ) {\n                throwCantPack(\""PT_NOTEs too big; try '--force-execve'\"");\n                return false;\n            }\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te32(&sec_strndx->sh_offset) + file_image);\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)\"".shstrtab\"",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack(\""bad e_shstrndx\"");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        // Apparently glibc-2.13.90 insists on 0==e_ident[EI_PAD..15],\n        // so compressing shared libraries may be doomed anyway.\n        // 2011-06-01: stub.shlib-init.S works around by installing hatch\n        // at end of .text.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack(\""DT_TEXTREL found; re-compile with -fPIC\"");\n                goto abandon;\n            }\n            Elf32_Shdr const *shdr = shdri;\n            xct_va = ~0u;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te32(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te32(&shdr->sh_offset);\n                        user_init_va = get_te32(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n                        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n                        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            unsigned y = 0;\n            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))\n            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB))\n            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB))\n            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL))\n            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA))\n            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL))\n            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF))\n            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM))\n            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED)) ) {\n                static char const *which[] = {\n                    \""unknown\"",\n                    \""DT_GNU_HASH\"",\n                    \""DT_HASH\"",\n                    \""DT_STRTAB\"",\n                    \""DT_SYMTAB\"",\n                    \""DT_REL\"",\n                    \""DT_RELA\"",\n                    \""DT_JMPREL\"",\n                    \""DT_VERDEF\"",\n                    \""DT_VERSYM\"",\n                    \""DT_VERNEEDED\"",\n                };\n                char buf[30]; snprintf(buf, sizeof(buf), \""%s above stub\"", which[y]);\n                throwCantPack(buf);\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    unsigned const vaddr = get_te32(&phdr->p_vaddr);\n                    if (PT_NOTE32 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           \""PT_NOTE %#x above stub\"", vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \""shlib canPack: xct_va=%#lx  xct_off=%lx\\n\"",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack(\""need DT_INIT; try \\\""void _init(void){}\\\""\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}""}, {""func_name"": ""PackLinuxElf64::canPack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\""invalid Ehdr e_ehsize; try '--force-execve'\"");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\""non-contiguous Ehdr/Phdr; try '--force-execve'\"");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack(\""too many ElfXX_Phdr; try '--force-execve'\"");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\"");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\""first PT_LOAD.p_offset != 0; try '--force-execve'\"");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te64(&sec_strndx->sh_offset) + file_image);\n        if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)\"".shstrtab\"",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack(\""bad e_shstrndx\"");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack(\""DT_TEXTREL found; re-compile with -fPIC\"");\n                goto abandon;\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te64(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        user_init_va = get_te64(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            unsigned y = 0;\n            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))\n            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB))\n            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB))\n            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL))\n            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA))\n            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL))\n            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF))\n            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM))\n            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) {\n                static char const *which[] = {\n                    \""unknown\"",\n                    \""DT_GNU_HASH\"",\n                    \""DT_HASH\"",\n                    \""DT_STRTAB\"",\n                    \""DT_SYMTAB\"",\n                    \""DT_REL\"",\n                    \""DT_RELA\"",\n                    \""DT_JMPREL\"",\n                    \""DT_VERDEF\"",\n                    \""DT_VERSYM\"",\n                    \""DT_VERNEEDED\"",\n                };\n                char buf[30]; snprintf(buf, sizeof(buf), \""%s above stub\"", which[y]);\n                throwCantPack(buf);\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           \""PT_NOTE %#lx above stub\"", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \""shlib canPack: xct_va=%#lx  xct_off=%lx\\n\"",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack(\""need DT_INIT; try \\\""void _init(void){}\\\""\"");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}""}, {""func_name"": ""PackLinuxElf32::calls_crt1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;\n        if (0==strcmp(symnam, \""__libc_start_main\"")  // glibc\n        ||  0==strcmp(symnam, \""__libc_init\"")  // Android\n        ||  0==strcmp(symnam, \""__uClibc_main\"")\n        ||  0==strcmp(symnam, \""__uClibc_start_main\""))\n            return true;\n    }\n    return false;\n}""}, {""func_name"": ""PackLinuxElf64::check_pt_dynamic"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""upx_uint64_t  // checked .p_offset; sz_dynseg set\nPackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)\n{\n    upx_uint64_t t = get_te64(&phdr->p_offset), s = sizeof(Elf64_Dyn) + t;\n    upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);\n    upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);\n    if (s < t || (upx_uint64_t)file_size < s\n    ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)\n    ||  (-1+ page_size) & (t ^ vaddr)\n    ||  filesz < sizeof(Elf64_Dyn)\n    ||  memsz  < sizeof(Elf64_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \""bad PT_DYNAMIC phdr[%u]\"",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}""}]","{""caller"": 2, ""value"": 2, ""function"": 5, ""code"": 3}","[{""source"": ""caller_info(file:p_lx_elf.cpp, func:calls_crt1)"", ""result"": [{""call_line"": 1845, ""call_code"": ""calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))"", ""caller_code"": ""bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\""invalid Ehdr e_ehsize; try '--force-execve'\"");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\""non-contiguous Ehdr/Phdr; try '--force-execve'\"");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr ..."", ""caller_start"": 1694, ""file_path"": ""src/p_lx_elf.cpp""}, {""call_line"": 1847, ""call_code"": ""calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))"", ""caller_code"": ""bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\""invalid Ehdr e_ehsize; try '--force-execve'\"");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\""non-contiguous Ehdr/Phdr; try '--force-execve'\"");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr ..."", ""caller_start"": 1694, ""file_path"": ""src/p_lx_elf.cpp""}, {""call_line"": 2082, ""call_code"": ""calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))"", ""caller_code"": ""bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\""invalid Ehdr e_ehsize; try '--force-execve'\"");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\""non-contiguous Ehdr/Phdr; try '--force-execve'\"");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n   ..."", ""caller_start"": 1981, ""file_path"": ""src/p_lx_elf.cpp""}, {""call_line"": 2084, ""call_code"": ""calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))"", ""caller_code"": ""bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\""invalid Ehdr e_ehsize; try '--force-execve'\"");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\""non-contiguous Ehdr/Phdr; try '--force-execve'\"");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n   ..."", ""caller_start"": 1981, ""file_path"": ""src/p_lx_elf.cpp""}]}, {""source"": ""caller_info(file:p_lx_elf.cpp, func:check_pt_dynamic)"", ""result"": [{""call_line"": 301, ""call_code"": ""check_pt_dynamic(phdr)"", ""caller_code"": ""void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\""0==e_phnum\"");\n    e_phoff = get_te32(&ehdri.e_phoff);\n    unsigned const last_Phdr = e_phoff + e_phnum * sizeof(Elf32_Phdr);\n    if (last_Phdr < e_phoff || (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    e_shoff = get_te32(&ehdri.e_shoff);\n    uns..."", ""caller_start"": 240, ""file_path"": ""src/p_lx_elf.cpp""}, {""call_line"": 771, ""call_code"": ""check_pt_dynamic(phdr)"", ""caller_code"": ""void\nPackLinuxElf64::PackLinuxElf64help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\""0==e_phnum\"");\n    e_phoff = get_te64(&ehdri.e_phoff);\n    upx_uint64_t const last_Phdr = e_phoff + e_phnum * sizeof(Elf64_Phdr);\n    if (last_Phdr < e_phoff || (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    e_shoff = get_te64(&ehdri.e_shoff);\n   ..."", ""caller_start"": 710, ""file_path"": ""src/p_lx_elf.cpp""}, {""call_line"": 1835, ""call_code"": ""check_pt_dynamic(phdr)"", ""caller_code"": ""bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\""invalid Ehdr e_ehsize; try '--force-execve'\"");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\""non-contiguous Ehdr/Phdr; try '--force-execve'\"");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr ..."", ""caller_start"": 1694, ""file_path"": ""src/p_lx_elf.cpp""}, {""call_line"": 2072, ""call_code"": ""check_pt_dynamic(phdr)"", ""caller_code"": ""bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\""invalid Ehdr e_ehsize; try '--force-execve'\"");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\""non-contiguous Ehdr/Phdr; try '--force-execve'\"");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n   ..."", ""caller_start"": 1981, ""file_path"": ""src/p_lx_elf.cpp""}]}, {""source"": ""value_info(file:p_lx_elf.cpp, value:dynsym)"", ""result"": {""value_trace"": [{""full_code"": ""sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM)"", ""line"": 290, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB)"", ""line"": 307, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM)"", ""line"": 760, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}, {""full_code"": ""dynsym = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB)"", ""line"": 777, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}, {""full_code"": ""sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM)"", ""line"": 1822, ""func_name"": ""PackLinuxElf32.canPack:bool()""}], ""struct_var"": ""dynsym"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:p_lx_elf.cpp, value:dynstr)"", ""result"": {""value_trace"": [{""full_code"": ""sec_dynstr = &shdri[t]"", ""line"": 295, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB)"", ""line"": 306, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""sec_dynstr = &shdri[t]"", ""line"": 765, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}, {""full_code"": ""dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB)"", ""line"": 776, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}, {""full_code"": ""sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri"", ""line"": 1824, ""func_name"": ""PackLinuxElf32.canPack:bool()""}], ""struct_var"": ""dynstr"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:p_lx_elf.cpp, func:unpack)"", ""result"": [{""code"": ""void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\""l_info corrupted\"");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te..."", ""start_line"": 3844, ""end_line"": 4161, ""full_name"": ""PackLinuxElf64.unpack:void(OutputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}, {""code"": ""void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\""l_info corrupted\"");\n    ..."", ""start_line"": 4604, ""end_line"": 4922, ""full_name"": ""PackLinuxElf32.unpack:void(OutputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}, {""code"": ""void PackLinuxElf::unpack(OutputFile * /*fo*/)\n{\n    throwCantUnpack(\""internal error\"");\n}"", ""start_line"": 4924, ""end_line"": 4927, ""full_name"": ""PackLinuxElf.unpack:void(OutputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}]}, {""source"": ""func_info(file:p_lx_elf.cpp, func:unpack)"", ""result"": [{""code"": ""void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\""l_info corrupted\"");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te..."", ""start_line"": 3844, ""end_line"": 4161, ""full_name"": ""PackLinuxElf64.unpack:void(OutputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}, {""code"": ""void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\""l_info corrupted\"");\n    ..."", ""start_line"": 4604, ""end_line"": 4922, ""full_name"": ""PackLinuxElf32.unpack:void(OutputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}, {""code"": ""void PackLinuxElf::unpack(OutputFile * /*fo*/)\n{\n    throwCantUnpack(\""internal error\"");\n}"", ""start_line"": 4924, ""end_line"": 4927, ""full_name"": ""PackLinuxElf.unpack:void(OutputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}]}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:3844-4161)"", ""result"": ""void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\""l_info corrupted\"");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\""p_info corrupted\"");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack(\""b_info corrupted\"");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\""ElfXX_Ehdr corrupted\"");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 1024\n    if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n        throwCantUnpack(\""bad compressed e_phnum\"");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te64(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n            upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n            Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n                \""bad dynsym\"", off_dynsym, sz_dynsym);\n            Elf64_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                upx_uint64_t symval = get_te64(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf64_Sym::SHN_UNDEF != symsec\n                &&  Elf64_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te64(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        upx_uint64_t load_off = 0;\n        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                load_va = get_te64(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf64_Phdr *dynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);\n                    upx_uint64_t dt_relasz(0), dt_rela(0);\n                    upx_uint64_t const dyn_len = get_te64(&dynhdr->p_filesz);\n                    upx_uint64_t const dyn_off = get_te64(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]\n                    }\n                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n                        upx_uint64_t       val = get_te64(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf64_Dyn::DT_PLTGOT:\n                        case Elf64_Dyn::DT_PREINIT_ARRAY:\n                        case Elf64_Dyn::DT_INIT_ARRAY:\n                        case Elf64_Dyn::DT_FINI_ARRAY:\n                        case Elf64_Dyn::DT_FINI: {\n                            set_te64(&dyn->d_val, val - asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf64_Dyn::DT_INIT == tag) {\n                                set_te64(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te64(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relasz && dt_rela) {\n                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                                \""bad Rela offset\"", dt_rela, dt_relasz);\n                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                                \""bad Jmprel offset\"", dt_jmprel, dt_pltrelsz);\n                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRela64\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n\n""}, {""source"": ""func_info(file:p_lx_elf.cpp, func:unpack)"", ""result"": [{""code"": ""void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\""l_info corrupted\"");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te..."", ""start_line"": 3844, ""end_line"": 4161, ""full_name"": ""PackLinuxElf64.unpack:void(OutputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}, {""code"": ""void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\""l_info corrupted\"");\n    ..."", ""start_line"": 4604, ""end_line"": 4922, ""full_name"": ""PackLinuxElf32.unpack:void(OutputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}, {""code"": ""void PackLinuxElf::unpack(OutputFile * /*fo*/)\n{\n    throwCantUnpack(\""internal error\"");\n}"", ""start_line"": 4924, ""end_line"": 4927, ""full_name"": ""PackLinuxElf.unpack:void(OutputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}]}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:3844-4161)"", ""result"": ""void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\""l_info corrupted\"");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\""p_info corrupted\"");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack(\""b_info corrupted\"");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\""ElfXX_Ehdr corrupted\"");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 1024\n    if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n        throwCantUnpack(\""bad compressed e_phnum\"");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te64(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n            upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n            Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n                \""bad dynsym\"", off_dynsym, sz_dynsym);\n            Elf64_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                upx_uint64_t symval = get_te64(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf64_Sym::SHN_UNDEF != symsec\n                &&  Elf64_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te64(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        upx_uint64_t load_off = 0;\n        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                load_va = get_te64(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf64_Phdr *dynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);\n                    upx_uint64_t dt_relasz(0), dt_rela(0);\n                    upx_uint64_t const dyn_len = get_te64(&dynhdr->p_filesz);\n                    upx_uint64_t const dyn_off = get_te64(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]\n                    }\n                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n                        upx_uint64_t       val = get_te64(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf64_Dyn::DT_PLTGOT:\n                        case Elf64_Dyn::DT_PREINIT_ARRAY:\n                        case Elf64_Dyn::DT_INIT_ARRAY:\n                        case Elf64_Dyn::DT_FINI_ARRAY:\n                        case Elf64_Dyn::DT_FINI: {\n                            set_te64(&dyn->d_val, val - asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf64_Dyn::DT_INIT == tag) {\n                                set_te64(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te64(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relasz && dt_rela) {\n                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                                \""bad Rela offset\"", dt_rela, dt_relasz);\n                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                                \""bad Jmprel offset\"", dt_jmprel, dt_pltrelsz);\n                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRela64\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n\n""}, {""source"": ""func_info(func:subref)"", ""result"": [{""code"": ""unsigned char *MemBuffer::subref(char const *errfmt, unsigned skip, unsigned take)\n{\n    if ((take + skip) < take  // wrap-around\n    ||  (take + skip) > b_size  // overrun\n    ) {\n        char buf[100]; snprintf(buf, sizeof(buf), errfmt, skip, take);\n        throwCantPack(buf);\n    }\n    return &b[skip];\n}"", ""start_line"": 77, ""end_line"": 86, ""full_name"": ""MemBuffer.subref:unsigned char*(char*,unsigned,unsigned)"", ""file_path"": ""src/mem.cpp""}]}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:3844-4161)"", ""result"": ""void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\""l_info corrupted\"");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\""p_info corrupted\"");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack(\""b_info corrupted\"");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\""ElfXX_Ehdr corrupted\"");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 1024\n    if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n        throwCantUnpack(\""bad compressed e_phnum\"");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te64(&ehdri.e_shoff);\n        if (e_shoff && shdri) { // --android-shlib\n            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n            upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n            Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n                \""bad dynsym\"", off_dynsym, sz_dynsym);\n            Elf64_Sym *sym = sym0;\n            for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                upx_uint64_t symval = get_te64(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf64_Sym::SHN_UNDEF != symsec\n                &&  Elf64_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te64(&sym->st_value, symval - asl_delta);\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n            is_asl = 1u& d_info[1];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        upx_uint64_t load_off = 0;\n        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                load_va = get_te64(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf64_Phdr *dynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++dynhdr)\n                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&dynhdr->p_type)) {\n                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);\n                    upx_uint64_t dt_relasz(0), dt_rela(0);\n                    upx_uint64_t const dyn_len = get_te64(&dynhdr->p_filesz);\n                    upx_uint64_t const dyn_off = get_te64(&dynhdr->p_offset);\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]\n                    }\n                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg);\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n                        upx_uint64_t       val = get_te64(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf64_Dyn::DT_PLTGOT:\n                        case Elf64_Dyn::DT_PREINIT_ARRAY:\n                        case Elf64_Dyn::DT_INIT_ARRAY:\n                        case Elf64_Dyn::DT_FINI_ARRAY:\n                        case Elf64_Dyn::DT_FINI: {\n                            set_te64(&dyn->d_val, val - asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf64_Dyn::DT_INIT == tag) {\n                                set_te64(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else { // DT_INIT_ARRAY, DT_PREINIT_ARRAY\n                                set_te64(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relasz && dt_rela) {\n                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                                \""bad Rela offset\"", dt_rela, dt_relasz);\n                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                                \""bad Jmprel offset\"", dt_jmprel, dt_pltrelsz);\n                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRela64\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}\n\n""}, {""source"": ""func_info(func:unRela64)"", ""result"": [{""code"": ""void\nPackLinuxElf64::unRela64(\n    upx_uint64_t dt_rela,\n    Elf64_Rela *rela0,\n    unsigned relasz,\n    MemBuffer &ptload1,\n    upx_uint64_t const load_off,\n    OutputFile *fo\n)\n{\n    Elf64_Rela *rela = rela0;\n    for (int k = relasz / sizeof(Elf64_Rela); --k >= 0; ++rela) {\n        upx_uint64_t r_addend = get_te64(&rela->r_addend);\n        upx_uint64_t r_offset = get_te64(&rela->r_offset);\n        upx_uint64_t r_info   = get_te64(&rela->r_info);\n        unsigned r_type = ELF64_R_TYPE(r_info);\n        if (xct_off <= r_offset) {\n            set_te64(&rela->r_offset, r_offset - asl_delta);\n        }\n        if (Elf64_Ehdr::EM_AARCH64 == e_machine) {\n            if (R_AARCH64_RELATIVE == r_type) {\n                if (xct_off <= r_addend) {\n                    set_te64(&rela->r_addend, r_addend - asl_delta);\n                }\n            }\n            if (R_AARCH64_JUMP_SLOT == r_type) {\n                ++n_jmp_slot;\n                // .rela.plt contains offset of the \""first time\"" targ..."", ""start_line"": 3801, ""end_line"": 3842, ""full_name"": ""PackLinuxElf64.unRela64:void(upx_uint64_t,Elf64_Rela*,unsigned,MemBuffer&,upx_uint64_t,OutputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}]}]","1. Malformed PT_DYNAMIC segment bypasses alignment checks in check_pt_dynamic (src/p_lx_elf.cpp:4343, pre-patch). 2. Uninitialized 'dynsym' and 'dynstr' (src/p_lx_elf.cpp:777, 776) are used in calls_crt1 (src/p_lx_elf.cpp:1667, pre-patch). 3. In PackLinuxElf64::unpack (src/p_lx_elf.cpp:3844-4161), 'ibuf.subref' (src/mem.cpp:77-86) accesses 'dynsym' with invalid 'off_dynsym'/'sz_dynsym' derived from the malformed PT_DYNAMIC. 4. Relocation processing (e.g., unRela64) manipulates invalid memory, causing double-free during 'fo->rewrite' or MemBuffer destruction.",0.95,./github/other_context/CVE-2018-11243
23,CVE-2018-13301,CWE-476,c_cpp,"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",https://github.com/FFmpeg/FFmpeg/commit/2aa9047486dbff12d9e040f917e5f799ed2fd78b,"avcodec/mpeg4videodec: Check read profile before setting it\n\nFixes: null pointer dereference\nFixes: ffmpeg_crash_7.avi\n\nFound-by: Thuan Pham, Marcel Böhme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",2,"[{""func_name"": ""mpeg4_decode_profile_level"", ""file_path"": ""libavcodec/mpeg4videodec.c"", ""func_code"": ""static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)\n{\n\n    s->avctx->profile = get_bits(gb, 4);\n    s->avctx->level   = get_bits(gb, 4);\n\n    // for Simple profile, level 0\n    if (s->avctx->profile == 0 && s->avctx->level == 8) {\n        s->avctx->level = 0;\n    }\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""ff_mpeg4_decode_picture_header"", ""file_path"": ""libavcodec/mpeg4videodec.c"", ""func_code"": ""int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    // If we have not switched to studio profile than we also did not switch bps\n    // that means something else (like a previous instance) outside set bps which\n    // would be inconsistant with the currect state, thus reset it\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\""WV1F\"") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\""QMP4\"")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \""frame skip %d\\n\"", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \""startcode: %3X \"", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Start\"");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Layer Start\"");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Reserved\"");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FGS bp start\"");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Reserved\"");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Seq Start\"");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Seq End\"");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \""User Data\"");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Group of VOP start\"");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Session Error\"");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Start\"");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Plane start\"");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \""slice start\"");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \""extension start\"");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \""fgs start\"");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FBA Object start\"");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FBA Object Plane start\"");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Mesh Object start\"");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Mesh Object Plane start\"");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Still Texture Object start\"");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Spatial Layer start\"");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture SNR Layer start\"");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Tile start\"");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Shape Layer start\"");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \""stuffing start\"");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \""reserved\"");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""System start\"");\n            av_log(s->avctx, AV_LOG_DEBUG, \"" at %d\\n\"", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \""Ignoring multiple VOL headers\\n\"");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            mpeg4_decode_profile_level(s, gb);\n            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (s->avctx->level > 0 && s->avctx->level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            }\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Missing VOL header\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}"", ""target"": 0}]","[{""func_name"": ""mpeg4_decode_profile_level"", ""file_path"": ""libavcodec/mpeg4videodec.c"", ""func_code"": ""static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)\n{\n\n    *profile = get_bits(gb, 4);\n    *level   = get_bits(gb, 4);\n\n    // for Simple profile, level 0\n    if (*profile == 0 && *level == 8) {\n        *level = 0;\n    }\n\n    return 0;\n}""}, {""func_name"": ""ff_mpeg4_decode_picture_header"", ""file_path"": ""libavcodec/mpeg4videodec.c"", ""func_code"": ""int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    unsigned startcode, v;\n    int ret;\n    int vol = 0;\n\n    /* search next start code */\n    align_get_bits(gb);\n\n    // If we have not switched to studio profile than we also did not switch bps\n    // that means something else (like a previous instance) outside set bps which\n    // would be inconsistant with the currect state, thus reset it\n    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n        s->avctx->bits_per_raw_sample = 0;\n\n    if (s->codec_tag == AV_RL32(\""WV1F\"") && show_bits(gb, 24) == 0x575630) {\n        skip_bits(gb, 24);\n        if (get_bits(gb, 8) == 0xF0)\n            goto end;\n    }\n\n    startcode = 0xff;\n    for (;;) {\n        if (get_bits_count(gb) >= gb->size_in_bits) {\n            if (gb->size_in_bits == 8 &&\n                (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(\""QMP4\"")) {\n                av_log(s->avctx, AV_LOG_VERBOSE, \""frame skip %d\\n\"", gb->size_in_bits);\n                return FRAME_SKIPPED;  // divx bug\n            } else\n                return AVERROR_INVALIDDATA;  // end of stream\n        }\n\n        /* use the bits after the test */\n        v = get_bits(gb, 8);\n        startcode = ((startcode << 8) | v) & 0xffffffff;\n\n        if ((startcode & 0xFFFFFF00) != 0x100)\n            continue;  // no startcode\n\n        if (s->avctx->debug & FF_DEBUG_STARTCODE) {\n            av_log(s->avctx, AV_LOG_DEBUG, \""startcode: %3X \"", startcode);\n            if (startcode <= 0x11F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Start\"");\n            else if (startcode <= 0x12F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Layer Start\"");\n            else if (startcode <= 0x13F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Reserved\"");\n            else if (startcode <= 0x15F)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FGS bp start\"");\n            else if (startcode <= 0x1AF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Reserved\"");\n            else if (startcode == 0x1B0)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Seq Start\"");\n            else if (startcode == 0x1B1)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Seq End\"");\n            else if (startcode == 0x1B2)\n                av_log(s->avctx, AV_LOG_DEBUG, \""User Data\"");\n            else if (startcode == 0x1B3)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Group of VOP start\"");\n            else if (startcode == 0x1B4)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Session Error\"");\n            else if (startcode == 0x1B5)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Visual Object Start\"");\n            else if (startcode == 0x1B6)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Video Object Plane start\"");\n            else if (startcode == 0x1B7)\n                av_log(s->avctx, AV_LOG_DEBUG, \""slice start\"");\n            else if (startcode == 0x1B8)\n                av_log(s->avctx, AV_LOG_DEBUG, \""extension start\"");\n            else if (startcode == 0x1B9)\n                av_log(s->avctx, AV_LOG_DEBUG, \""fgs start\"");\n            else if (startcode == 0x1BA)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FBA Object start\"");\n            else if (startcode == 0x1BB)\n                av_log(s->avctx, AV_LOG_DEBUG, \""FBA Object Plane start\"");\n            else if (startcode == 0x1BC)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Mesh Object start\"");\n            else if (startcode == 0x1BD)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Mesh Object Plane start\"");\n            else if (startcode == 0x1BE)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Still Texture Object start\"");\n            else if (startcode == 0x1BF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Spatial Layer start\"");\n            else if (startcode == 0x1C0)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture SNR Layer start\"");\n            else if (startcode == 0x1C1)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Tile start\"");\n            else if (startcode == 0x1C2)\n                av_log(s->avctx, AV_LOG_DEBUG, \""Texture Shape Layer start\"");\n            else if (startcode == 0x1C3)\n                av_log(s->avctx, AV_LOG_DEBUG, \""stuffing start\"");\n            else if (startcode <= 0x1C5)\n                av_log(s->avctx, AV_LOG_DEBUG, \""reserved\"");\n            else if (startcode <= 0x1FF)\n                av_log(s->avctx, AV_LOG_DEBUG, \""System start\"");\n            av_log(s->avctx, AV_LOG_DEBUG, \"" at %d\\n\"", get_bits_count(gb));\n        }\n\n        if (startcode >= 0x120 && startcode <= 0x12F) {\n            if (vol) {\n                av_log(s->avctx, AV_LOG_WARNING, \""Ignoring multiple VOL headers\\n\"");\n                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            int profile, level;\n            mpeg4_decode_profile_level(s, gb, &profile, &level);\n            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (level > 0 && level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            } else if (s->studio_profile) {\n                avpriv_request_sample(s->avctx, \""Mixes studio and non studio profile\\n\"");\n                return AVERROR_PATCHWELCOME;\n            }\n            s->avctx->profile = profile;\n            s->avctx->level   = level;\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Missing VOL header\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}""}]",{},[],"libavcodec/mpeg4videodec.c:1984-1987 previously wrote unvalidated profile/level values directly to s->avctx without checking their validity. The patch (libavcodec/mpeg4videodec.c:3212-3245) now validates these values in local variables before assignment, preventing NULL dereference when s->avctx is accessed with invalid state.",0.95,./github/other_context/CVE-2018-13301
24,CVE-2018-16391,"CWE-415, CWE-119",c_cpp,Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad,fixed out of bounds writes\n\nThanks to Eric Sesterhenn from X41 D-SEC GmbH\nfor reporting the problems.,13,"[{""func_name"": ""cac_get_serial_nr_from_CUID"", ""file_path"": ""src/libopensc/card-cac.c"", ""func_code"": ""static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n        }\n\tif (priv->cac_id_len) {\n\t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}"", ""target"": 0}, {""func_name"": ""decrypt_response"", ""file_path"": ""src/libopensc/card-epass2003.c"", ""func_code"": ""static int\ndecrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* no cipher */\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\n\t/* parse cipher length */\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\n\t/* decrypt */\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\n\t/* unpadding */\n\twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n\t\tcipher_len--;\n\n\tif (2 == cipher_len)\n\t\treturn -1;\n\n\tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""epass2003_sm_unwrap_apdu"", ""file_path"": ""src/libopensc/card-epass2003.c"", ""func_code"": ""static int\nepass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_check_sw(card, sm->sw1, sm->sw2);\n\tif (r == SC_SUCCESS) {\n\t\tif (exdata->sm) {\n\t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \""unwrapped APDU: resplen %\""SC_FORMAT_LEN_SIZE_T\""u, SW %02X%02X\"",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}"", ""target"": 0}, {""func_name"": ""tcos_select_file"", ""file_path"": ""src/libopensc/card-tcos.c"", ""func_code"": ""static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \""\\x3F\\x00\"", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \""APDU transmit failed\"");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \""received invalid template %02X\\n\"", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \""invalid file type %02X in file descriptor\\n\"", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""gemsafe_get_cert_len"", ""file_path"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""func_code"": ""static int gemsafe_get_cert_len(sc_card_t *card)\n{\n\tint r;\n\tu8  ibuf[GEMSAFE_MAX_OBJLEN];\n\tu8 *iptr;\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tsize_t objlen, certlen;\n\tunsigned int ind, i=0;\n\n\tsc_format_path(GEMSAFE_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Initial read */\n\tr = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Actual stored object size is encoded in first 2 bytes\n\t * (allocated EF space is much greater!)\n\t */\n\tobjlen = (((size_t) ibuf[0]) << 8) | ibuf[1];\n\tsc_log(card->ctx, \""Stored object is of size: %\""SC_FORMAT_LEN_SIZE_T\""u\"",\n\t       objlen);\n\tif (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {\n\t    sc_log(card->ctx, \""Invalid object size: %\""SC_FORMAT_LEN_SIZE_T\""u\"",\n\t\t   objlen);\n\t    return SC_ERROR_INTERNAL;\n\t}\n\n\t/* It looks like the first thing in the block is a table of\n\t * which keys are allocated. The table is small and is in the\n\t * first 248 bytes. Example for a card with 10 key containers:\n\t * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated\n\t * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated\n\t * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated\n\t * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated\n\t * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated\n\t * ...\n\t * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated\n\t * For allocated keys, the fourth byte seems to indicate the\n\t * default key and the fifth byte indicates the key_ref of\n\t * the private key.\n\t */\n\tind = 2; /* skip length */\n\twhile (ibuf[ind] == 0x01) {\n\t\tif (ibuf[ind+1] == 0xFE) {\n\t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n\t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",\n\t\t\t\t\ti+1, gemsafe_prkeys[i].ref);\n\t\t\tind += 9;\n\t\t}\n\t\telse {\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t\tsc_log(card->ctx, \""Key container %d is unallocated\"", i+1);\n\t\t\tind += 8;\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * this card can't accommodate them.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tgemsafe_prkeys[i].label = NULL;\n\t\tgemsafe_cert[i].label = NULL;\n\t}\n\n\t/* Read entire file, then dissect in memory.\n\t * Gemalto ClassicClient seems to do it the same way.\n\t */\n\tiptr = ibuf + GEMSAFE_READ_QUANTUM;\n\twhile ((size_t)(iptr - ibuf) < objlen) {\n\t\tr = sc_read_binary(card, iptr - ibuf, iptr,\n\t\t\t\t   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);\n\t\tif (r < 0) {\n\t\t\tsc_log(card->ctx, \""Could not read cert object\"");\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tiptr += GEMSAFE_READ_QUANTUM;\n\t}\n\n\t/* Search buffer for certificates, they start with 0x3082. */\n\ti = 0;\n\twhile (ind < objlen - 1) {\n\t\tif (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {\n\t\t\t/* Find next allocated key container */\n\t\t\twhile (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)\n\t\t\t\ti++;\n\t\t\tif (i == gemsafe_cert_max) {\n\t\t\t\tsc_log(card->ctx, \""Warning: Found orphaned certificate at offset %d\"", ind);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\t\t\t/* DER cert len is encoded this way */\n\t\t\tif (ind+3 >= sizeof ibuf)\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\tcertlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;\n\t\t\tsc_log(card->ctx,\n\t\t\t       \""Found certificate of key container %d at offset %d, len %\""SC_FORMAT_LEN_SIZE_T\""u\"",\n\t\t\t       i+1, ind, certlen);\n\t\t\tgemsafe_cert[i].index = ind;\n\t\t\tgemsafe_cert[i].count = certlen;\n\t\t\tind += certlen;\n\t\t\ti++;\n\t\t} else\n\t\t\tind++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * they're missing on the card.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tif (gemsafe_cert[i].label) {\n\t\t\tsc_log(card->ctx, \""Warning: Certificate of key container %d is missing\"", i+1);\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""sc_pkcs15emu_sc_hsm_init"", ""file_path"": ""src/libopensc/pkcs15-sc-hsm.c"", ""func_code"": ""static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tsc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;\n\tsc_file_t *file = NULL;\n\tsc_path_t path;\n\tu8 filelist[MAX_EXT_APDU_LENGTH];\n\tint filelistlength;\n\tint r, i;\n\tsc_cvc_t devcert;\n\tstruct sc_app_info *appinfo;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tstruct sc_pin_cmd_data pindata;\n\tu8 efbin[1024];\n\tu8 *ptr;\n\tsize_t len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tappinfo = calloc(1, sizeof(struct sc_app_info));\n\n\tif (appinfo == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->aid = sc_hsm_aid;\n\n\tappinfo->ddo.aid = sc_hsm_aid;\n\tp15card->app = appinfo;\n\n\tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);\n\tr = sc_select_file(card, &path, &file);\n\tLOG_TEST_RET(card->ctx, r, \""Could not select SmartCard-HSM application\"");\n\n\tp15card->card->version.hw_major = 24;\t/* JCOP 2.4.1r3 */\n\tp15card->card->version.hw_minor = 13;\n\tif (file && file->prop_attr && file->prop_attr_len >= 2) {\n\t\tp15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];\n\t\tp15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];\n\t}\n\n\tsc_file_free(file);\n\n\t/* Read device certificate to determine serial number */\n\tif (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {\n\t\tptr = priv->EF_C_DevAut;\n\t\tlen = priv->EF_C_DevAut_len;\n\t} else {\n\t\tlen = sizeof efbin;\n\t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n\t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n\n\t\t/* save EF_C_DevAut for further use */\n\t\tptr = realloc(priv->EF_C_DevAut, len);\n\t\tif (ptr) {\n\t\t\tmemcpy(ptr, efbin, len);\n\t\t\tpriv->EF_C_DevAut = ptr;\n\t\t\tpriv->EF_C_DevAut_len = len;\n\t\t}\n\n\t\tptr = efbin;\n\t}\n\n\tmemset(&devcert, 0 ,sizeof(devcert));\n\tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);\n\tLOG_TEST_RET(card->ctx, r, \""Could not decode EF.C_DevAut\"");\n\n\tsc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);\n\n\tif (p15card->tokeninfo->label == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->label = strdup(\""GoID\"");\n\t\t} else {\n\t\t\tp15card->tokeninfo->label = strdup(\""SmartCard-HSM\"");\n\t\t}\n\t\tif (p15card->tokeninfo->label == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tif ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(\""(unknown)\"", p15card->tokeninfo->manufacturer_id)) {\n\t\tfree(p15card->tokeninfo->manufacturer_id);\n\t\tp15card->tokeninfo->manufacturer_id = NULL;\n\t}\n\n\tif (p15card->tokeninfo->manufacturer_id == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\""Bundesdruckerei GmbH\"");\n\t\t} else {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\""www.CardContact.de\"");\n\t\t}\n\t\tif (p15card->tokeninfo->manufacturer_id == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->label = strdup(p15card->tokeninfo->label);\n\tif (appinfo->label == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tlen = strnlen(devcert.chr, sizeof devcert.chr);\t\t/* Strip last 5 digit sequence number from CHR */\n\tassert(len >= 8);\n\tlen -= 5;\n\n\tp15card->tokeninfo->serial_number = calloc(len + 1, 1);\n\tif (p15card->tokeninfo->serial_number == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(p15card->tokeninfo->serial_number, devcert.chr, len);\n\t*(p15card->tokeninfo->serial_number + len) = 0;\n\n\tsc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&devcert);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 1;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x81;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length = 6;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 15;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 3;\n\tpin_info.max_tries = 3;\n\n\tpin_obj.auth_id.len = 1;\n\tpin_obj.auth_id.value[0] = 2;\n\tstrlcpy(pin_obj.label, \""UserPIN\"", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 2;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x88;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;\n\tpin_info.attrs.pin.min_length = 16;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 16;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 15;\n\tpin_info.max_tries = 15;\n\n\tstrlcpy(pin_obj.label, \""SOPIN\"", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\n\tif (card->type == SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t/* SC-HSM of this type always has a PIN-Pad */\n\t\tr = SC_SUCCESS;\n\t} else {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x85;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\tif (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x86;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\n\tif ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))\n\t\tcard->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;\n\n\n\tfilelistlength = sc_list_files(card, filelist, sizeof(filelist));\n\tLOG_TEST_RET(card->ctx, filelistlength, \""Could not enumerate file and key identifier\"");\n\n\tfor (i = 0; i < filelistlength; i += 2) {\n\t\tswitch(filelist[i]) {\n\t\tcase KEY_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase DCOD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase CD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \""Error %d adding elements to framework\"", r);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}"", ""target"": 0}, {""func_name"": ""read_private_key"", ""file_path"": ""src/tools/cryptoflex-tool.c"", ""func_code"": ""static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\""I0012\"", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \""Unable to select private key file: %s\\n\"", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = file->size;\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \""Unable to read private key file: %s\\n\"", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\""Key number %d not found.\\n\"", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}"", ""target"": 0}, {""func_name"": ""read_public_key"", ""file_path"": ""src/tools/cryptoflex-tool.c"", ""func_code"": ""static int read_public_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\""I1012\"", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = file->size;\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \""Unable to read public key file: %s\\n\"", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\""Key number %d not found.\\n\"", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_public_key(p, keysize, rsa);\n}"", ""target"": 0}, {""func_name"": ""sc_pkcs15emu_esteid_init"", ""file_path"": ""src/libopensc/pkcs15-esteid.c"", ""func_code"": ""static int\nsc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tunsigned char buff[128];\n\tint r, i;\n\tsize_t field_length = 0, modulus_length = 0;\n\tsc_path_t tmppath;\n\n\tset_string (&p15card->tokeninfo->label, \""ID-kaart\"");\n\tset_string (&p15card->tokeninfo->manufacturer_id, \""AS Sertifitseerimiskeskus\"");\n\n\t/* Select application directory */\n\tsc_format_path (\""3f00eeee5044\"", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""select esteid PD failed\"");\n\n\t/* read the serial (document number) */\n\tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n\tbuff[r] = '\\0';\n\tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n\n\tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION\n\t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT\n\t\t\t\t  | SC_PKCS15_TOKEN_READONLY;\n\n\t/* add certificates */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const char *esteid_cert_names[2] = {\n\t\t\t\""Isikutuvastus\"",\n\t\t\t\""Allkirjastamine\""};\n\t\tstatic char const *esteid_cert_paths[2] = {\n\t\t\t\""3f00eeeeaace\"",\n\t\t\t\""3f00eeeeddce\""};\n\t\tstatic int esteid_cert_ids[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info cert_info;\n\t\tstruct sc_pkcs15_object cert_obj;\n\n\t\tmemset(&cert_info, 0, sizeof(cert_info));\n\t\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\t\tcert_info.id.value[0] = esteid_cert_ids[i];\n\t\tcert_info.id.len = 1;\n\t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);\n\t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));\n\t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (i == 0) {\n\t\t\tsc_pkcs15_cert_t *cert = NULL;\n\t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);\n\t\t\tif (r < 0)\n\t\t\t\treturn SC_ERROR_INTERNAL;\n\t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)\n\t\t\t\tfield_length = cert->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *cn_name = NULL;\n\t\t\t\tsize_t cn_len = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,\n\t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);\n\t\t\t\tif (cn_len > 0) {\n\t\t\t\t\tchar *token_name = malloc(cn_len+1);\n\t\t\t\t\tif (token_name) {\n\t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);\n\t\t\t\t\t\ttoken_name[cn_len] = '\\0';\n\t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);\n\t\t\t\t\t\tfree(token_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(cn_name);\n\t\t\t\tsc_pkcs15_free_certificate(cert);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the file with key pin info (tries left) */\n\tsc_format_path (\""3f000016\"", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* add pins */\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char tries_left;\n\t\tstatic const char *esteid_pin_names[3] = {\n\t\t\t\""PIN1\"",\n\t\t\t\""PIN2\"",\n\t\t\t\""PUK\"" };\n\t\t\t\n\t\tstatic const int esteid_pin_min[3] = {4, 5, 8};\n\t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};\n\t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};\n\t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};\n\t\t\n\t\tstruct sc_pkcs15_auth_info pin_info;\n\t\tstruct sc_pkcs15_object pin_obj;\n\n\t\tmemset(&pin_info, 0, sizeof(pin_info));\n\t\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\t\t/* read the number of tries left for the PIN */\n\t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\ttries_left = buff[5];\n\n\t\tpin_info.auth_id.len = 1;\n\t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];\n\t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];\n\t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];\n\t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];\n\t\tpin_info.attrs.pin.stored_length = 12;\n\t\tpin_info.attrs.pin.max_length = 12;\n\t\tpin_info.attrs.pin.pad_char = '\\0';\n\t\tpin_info.tries_left = (int)tries_left;\n\t\tpin_info.max_tries = 3;\n\n\t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));\n\t\tpin_obj.flags = esteid_pin_flags[i];\n\n\t\t/* Link normal PINs with PUK */\n\t\tif (i < 2) {\n\t\t\tpin_obj.auth_id.len = 1;\n\t\t\tpin_obj.auth_id.value[0] = 3;\n\t\t}\n\n\t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* add private keys */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic int prkey_pin[2] = {1, 2};\n\n\t\tstatic const char *prkey_name[2] = {\n\t\t\t\""Isikutuvastus\"",\n\t\t\t\""Allkirjastamine\""};\n\n\t\tstruct sc_pkcs15_prkey_info prkey_info;\n\t\tstruct sc_pkcs15_object prkey_obj;\n\n\t\tmemset(&prkey_info, 0, sizeof(prkey_info));\n\t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));\n\n\t\tprkey_info.id.len = 1;\n\t\tprkey_info.id.value[0] = prkey_pin[i];\n\t\tprkey_info.native = 1;\n\t\tprkey_info.key_reference = i + 1;\n\t\tprkey_info.field_length = field_length;\n\t\tprkey_info.modulus_length = modulus_length;\n\t\tif (i == 1)\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;\n\t\telse if(field_length > 0) // ECC has sign and derive usage\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;\n\t\telse\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\n\t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));\n\t\tprkey_obj.auth_id.len = 1;\n\t\tprkey_obj.auth_id.value[0] = prkey_pin[i];\n\t\tprkey_obj.user_consent = 0;\n\t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\t\tif(field_length > 0)\n\t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);\n\t\telse\n\t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\treturn SC_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""util_acl_to_str"", ""file_path"": ""src/tools/util.c"", ""func_code"": ""const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \""N/A\"";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \""N/A\"";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \""NEVR\"";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \""NONE\"";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \""CHV\"");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \""%d\"", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \""TERM\"");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \""PROT\"");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \""AUTH\"");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \""%d\"", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \""Sec.Env. \"");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \""#%d\"", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \""Sec.ControlByte \"");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \""Ox%X\"", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \""PKCS#15 AuthID \"");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \""#%d\"", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \""????\"");\n\t\t\tbreak;\n\t\t}\n\t\tstrcat(line, buf);\n\t\tstrcat(line, \"" \"");\n\t\te = e->next;\n\t}\n\tline[strlen(line)-1] = 0; /* get rid of trailing space */\n\treturn line;\n}"", ""target"": 0}, {""func_name"": ""sc_file_set_sec_attr"", ""file_path"": ""src/libopensc/sc.c"", ""func_code"": ""int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""read_file"", ""file_path"": ""src/tools/egk-tool.c"", ""func_code"": ""int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}"", ""target"": 0}, {""func_name"": ""muscle_list_files"", ""file_path"": ""src/libopensc/card-muscle.c"", ""func_code"": ""static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n\tmscfs_check_cache(priv->fs);\n\n\tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid= fs->cache.array[x].objectId.id;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n\t\t\tbuf[1] = oid[3];\n\t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n\t\t\tbuf += 2;\n\t\t\tcount+=2;\n\t\t}\n\t}\n\treturn count;\n}"", ""target"": 0}]","[{""func_name"": ""cac_get_serial_nr_from_CUID"", ""file_path"": ""src/libopensc/card-cac.c"", ""func_code"": ""static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n        }\n\tif (priv->cac_id_len) {\n\t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}""}, {""func_name"": ""decrypt_response"", ""file_path"": ""src/libopensc/card-epass2003.c"", ""func_code"": ""static int\ndecrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* no cipher */\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\n\t/* parse cipher length */\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\n\t/* decrypt */\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\n\t/* unpadding */\n\twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n\t\tcipher_len--;\n\n\tif (2 == cipher_len || *out_len < cipher_len - 2)\n\t\treturn -1;\n\n\tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}""}, {""func_name"": ""epass2003_sm_unwrap_apdu"", ""file_path"": ""src/libopensc/card-epass2003.c"", ""func_code"": ""static int\nepass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_check_sw(card, sm->sw1, sm->sw2);\n\tif (r == SC_SUCCESS) {\n\t\tif (exdata->sm) {\n\t\t\tlen = plain->resplen;\n\t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \""unwrapped APDU: resplen %\""SC_FORMAT_LEN_SIZE_T\""u, SW %02X%02X\"",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}""}, {""func_name"": ""tcos_select_file"", ""file_path"": ""src/libopensc/card-tcos.c"", ""func_code"": ""static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \""\\x3F\\x00\"", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \""APDU transmit failed\"");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \""received invalid template %02X\\n\"", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \""invalid file type %02X in file descriptor\\n\"", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}""}, {""func_name"": ""gemsafe_get_cert_len"", ""file_path"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""func_code"": ""static int gemsafe_get_cert_len(sc_card_t *card)\n{\n\tint r;\n\tu8  ibuf[GEMSAFE_MAX_OBJLEN];\n\tu8 *iptr;\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tsize_t objlen, certlen;\n\tunsigned int ind, i=0;\n\n\tsc_format_path(GEMSAFE_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Initial read */\n\tr = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Actual stored object size is encoded in first 2 bytes\n\t * (allocated EF space is much greater!)\n\t */\n\tobjlen = (((size_t) ibuf[0]) << 8) | ibuf[1];\n\tsc_log(card->ctx, \""Stored object is of size: %\""SC_FORMAT_LEN_SIZE_T\""u\"",\n\t       objlen);\n\tif (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {\n\t    sc_log(card->ctx, \""Invalid object size: %\""SC_FORMAT_LEN_SIZE_T\""u\"",\n\t\t   objlen);\n\t    return SC_ERROR_INTERNAL;\n\t}\n\n\t/* It looks like the first thing in the block is a table of\n\t * which keys are allocated. The table is small and is in the\n\t * first 248 bytes. Example for a card with 10 key containers:\n\t * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated\n\t * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated\n\t * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated\n\t * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated\n\t * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated\n\t * ...\n\t * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated\n\t * For allocated keys, the fourth byte seems to indicate the\n\t * default key and the fifth byte indicates the key_ref of\n\t * the private key.\n\t */\n\tind = 2; /* skip length */\n\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n\t\tif (ibuf[ind+1] == 0xFE) {\n\t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n\t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",\n\t\t\t\t\ti+1, gemsafe_prkeys[i].ref);\n\t\t\tind += 9;\n\t\t}\n\t\telse {\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t\tsc_log(card->ctx, \""Key container %d is unallocated\"", i+1);\n\t\t\tind += 8;\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * this card can't accommodate them.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tgemsafe_prkeys[i].label = NULL;\n\t\tgemsafe_cert[i].label = NULL;\n\t}\n\n\t/* Read entire file, then dissect in memory.\n\t * Gemalto ClassicClient seems to do it the same way.\n\t */\n\tiptr = ibuf + GEMSAFE_READ_QUANTUM;\n\twhile ((size_t)(iptr - ibuf) < objlen) {\n\t\tr = sc_read_binary(card, iptr - ibuf, iptr,\n\t\t\t\t   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);\n\t\tif (r < 0) {\n\t\t\tsc_log(card->ctx, \""Could not read cert object\"");\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tiptr += GEMSAFE_READ_QUANTUM;\n\t}\n\n\t/* Search buffer for certificates, they start with 0x3082. */\n\ti = 0;\n\twhile (ind < objlen - 1) {\n\t\tif (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {\n\t\t\t/* Find next allocated key container */\n\t\t\twhile (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)\n\t\t\t\ti++;\n\t\t\tif (i == gemsafe_cert_max) {\n\t\t\t\tsc_log(card->ctx, \""Warning: Found orphaned certificate at offset %d\"", ind);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\t\t\t/* DER cert len is encoded this way */\n\t\t\tif (ind+3 >= sizeof ibuf)\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\tcertlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;\n\t\t\tsc_log(card->ctx,\n\t\t\t       \""Found certificate of key container %d at offset %d, len %\""SC_FORMAT_LEN_SIZE_T\""u\"",\n\t\t\t       i+1, ind, certlen);\n\t\t\tgemsafe_cert[i].index = ind;\n\t\t\tgemsafe_cert[i].count = certlen;\n\t\t\tind += certlen;\n\t\t\ti++;\n\t\t} else\n\t\t\tind++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * they're missing on the card.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tif (gemsafe_cert[i].label) {\n\t\t\tsc_log(card->ctx, \""Warning: Certificate of key container %d is missing\"", i+1);\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}""}, {""func_name"": ""sc_pkcs15emu_sc_hsm_init"", ""file_path"": ""src/libopensc/pkcs15-sc-hsm.c"", ""func_code"": ""static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tsc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;\n\tsc_file_t *file = NULL;\n\tsc_path_t path;\n\tu8 filelist[MAX_EXT_APDU_LENGTH];\n\tint filelistlength;\n\tint r, i;\n\tsc_cvc_t devcert;\n\tstruct sc_app_info *appinfo;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tstruct sc_pin_cmd_data pindata;\n\tu8 efbin[1024];\n\tu8 *ptr;\n\tsize_t len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tappinfo = calloc(1, sizeof(struct sc_app_info));\n\n\tif (appinfo == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->aid = sc_hsm_aid;\n\n\tappinfo->ddo.aid = sc_hsm_aid;\n\tp15card->app = appinfo;\n\n\tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);\n\tr = sc_select_file(card, &path, &file);\n\tLOG_TEST_RET(card->ctx, r, \""Could not select SmartCard-HSM application\"");\n\n\tp15card->card->version.hw_major = 24;\t/* JCOP 2.4.1r3 */\n\tp15card->card->version.hw_minor = 13;\n\tif (file && file->prop_attr && file->prop_attr_len >= 2) {\n\t\tp15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];\n\t\tp15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];\n\t}\n\n\tsc_file_free(file);\n\n\t/* Read device certificate to determine serial number */\n\tif (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {\n\t\tptr = priv->EF_C_DevAut;\n\t\tlen = priv->EF_C_DevAut_len;\n\t} else {\n\t\tlen = sizeof efbin;\n\t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n\t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n\n\t\tif (len > 0) {\n\t\t\t/* save EF_C_DevAut for further use */\n\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n\t\t\tif (ptr) {\n\t\t\t\tmemcpy(ptr, efbin, len);\n\t\t\t\tpriv->EF_C_DevAut = ptr;\n\t\t\t\tpriv->EF_C_DevAut_len = len;\n\t\t\t}\n\t\t}\n\n\t\tptr = efbin;\n\t}\n\n\tmemset(&devcert, 0 ,sizeof(devcert));\n\tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);\n\tLOG_TEST_RET(card->ctx, r, \""Could not decode EF.C_DevAut\"");\n\n\tsc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);\n\n\tif (p15card->tokeninfo->label == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->label = strdup(\""GoID\"");\n\t\t} else {\n\t\t\tp15card->tokeninfo->label = strdup(\""SmartCard-HSM\"");\n\t\t}\n\t\tif (p15card->tokeninfo->label == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tif ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(\""(unknown)\"", p15card->tokeninfo->manufacturer_id)) {\n\t\tfree(p15card->tokeninfo->manufacturer_id);\n\t\tp15card->tokeninfo->manufacturer_id = NULL;\n\t}\n\n\tif (p15card->tokeninfo->manufacturer_id == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\""Bundesdruckerei GmbH\"");\n\t\t} else {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\""www.CardContact.de\"");\n\t\t}\n\t\tif (p15card->tokeninfo->manufacturer_id == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->label = strdup(p15card->tokeninfo->label);\n\tif (appinfo->label == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tlen = strnlen(devcert.chr, sizeof devcert.chr);\t\t/* Strip last 5 digit sequence number from CHR */\n\tassert(len >= 8);\n\tlen -= 5;\n\n\tp15card->tokeninfo->serial_number = calloc(len + 1, 1);\n\tif (p15card->tokeninfo->serial_number == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(p15card->tokeninfo->serial_number, devcert.chr, len);\n\t*(p15card->tokeninfo->serial_number + len) = 0;\n\n\tsc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&devcert);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 1;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x81;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length = 6;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 15;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 3;\n\tpin_info.max_tries = 3;\n\n\tpin_obj.auth_id.len = 1;\n\tpin_obj.auth_id.value[0] = 2;\n\tstrlcpy(pin_obj.label, \""UserPIN\"", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 2;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x88;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;\n\tpin_info.attrs.pin.min_length = 16;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 16;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 15;\n\tpin_info.max_tries = 15;\n\n\tstrlcpy(pin_obj.label, \""SOPIN\"", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\n\tif (card->type == SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t/* SC-HSM of this type always has a PIN-Pad */\n\t\tr = SC_SUCCESS;\n\t} else {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x85;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\tif (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x86;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\n\tif ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))\n\t\tcard->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;\n\n\n\tfilelistlength = sc_list_files(card, filelist, sizeof(filelist));\n\tLOG_TEST_RET(card->ctx, filelistlength, \""Could not enumerate file and key identifier\"");\n\n\tfor (i = 0; i < filelistlength; i += 2) {\n\t\tswitch(filelist[i]) {\n\t\tcase KEY_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase DCOD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase CD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \""Error %d adding elements to framework\"", r);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}""}, {""func_name"": ""read_private_key"", ""file_path"": ""src/tools/cryptoflex-tool.c"", ""func_code"": ""static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\""I0012\"", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \""Unable to select private key file: %s\\n\"", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \""Unable to read private key file: %s\\n\"", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\""Key number %d not found.\\n\"", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}""}, {""func_name"": ""read_public_key"", ""file_path"": ""src/tools/cryptoflex-tool.c"", ""func_code"": ""static int read_public_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\""I1012\"", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \""Unable to read public key file: %s\\n\"", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\""Key number %d not found.\\n\"", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_public_key(p, keysize, rsa);\n}""}, {""func_name"": ""sc_pkcs15emu_esteid_init"", ""file_path"": ""src/libopensc/pkcs15-esteid.c"", ""func_code"": ""static int\nsc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tunsigned char buff[128];\n\tint r, i;\n\tsize_t field_length = 0, modulus_length = 0;\n\tsc_path_t tmppath;\n\n\tset_string (&p15card->tokeninfo->label, \""ID-kaart\"");\n\tset_string (&p15card->tokeninfo->manufacturer_id, \""AS Sertifitseerimiskeskus\"");\n\n\t/* Select application directory */\n\tsc_format_path (\""3f00eeee5044\"", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""select esteid PD failed\"");\n\n\t/* read the serial (document number) */\n\tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n\tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n\n\tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION\n\t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT\n\t\t\t\t  | SC_PKCS15_TOKEN_READONLY;\n\n\t/* add certificates */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const char *esteid_cert_names[2] = {\n\t\t\t\""Isikutuvastus\"",\n\t\t\t\""Allkirjastamine\""};\n\t\tstatic char const *esteid_cert_paths[2] = {\n\t\t\t\""3f00eeeeaace\"",\n\t\t\t\""3f00eeeeddce\""};\n\t\tstatic int esteid_cert_ids[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info cert_info;\n\t\tstruct sc_pkcs15_object cert_obj;\n\n\t\tmemset(&cert_info, 0, sizeof(cert_info));\n\t\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\t\tcert_info.id.value[0] = esteid_cert_ids[i];\n\t\tcert_info.id.len = 1;\n\t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);\n\t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));\n\t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (i == 0) {\n\t\t\tsc_pkcs15_cert_t *cert = NULL;\n\t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);\n\t\t\tif (r < 0)\n\t\t\t\treturn SC_ERROR_INTERNAL;\n\t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)\n\t\t\t\tfield_length = cert->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *cn_name = NULL;\n\t\t\t\tsize_t cn_len = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,\n\t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);\n\t\t\t\tif (cn_len > 0) {\n\t\t\t\t\tchar *token_name = malloc(cn_len+1);\n\t\t\t\t\tif (token_name) {\n\t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);\n\t\t\t\t\t\ttoken_name[cn_len] = '\\0';\n\t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);\n\t\t\t\t\t\tfree(token_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(cn_name);\n\t\t\t\tsc_pkcs15_free_certificate(cert);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the file with key pin info (tries left) */\n\tsc_format_path (\""3f000016\"", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* add pins */\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char tries_left;\n\t\tstatic const char *esteid_pin_names[3] = {\n\t\t\t\""PIN1\"",\n\t\t\t\""PIN2\"",\n\t\t\t\""PUK\"" };\n\t\t\t\n\t\tstatic const int esteid_pin_min[3] = {4, 5, 8};\n\t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};\n\t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};\n\t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};\n\t\t\n\t\tstruct sc_pkcs15_auth_info pin_info;\n\t\tstruct sc_pkcs15_object pin_obj;\n\n\t\tmemset(&pin_info, 0, sizeof(pin_info));\n\t\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\t\t/* read the number of tries left for the PIN */\n\t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\ttries_left = buff[5];\n\n\t\tpin_info.auth_id.len = 1;\n\t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];\n\t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];\n\t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];\n\t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];\n\t\tpin_info.attrs.pin.stored_length = 12;\n\t\tpin_info.attrs.pin.max_length = 12;\n\t\tpin_info.attrs.pin.pad_char = '\\0';\n\t\tpin_info.tries_left = (int)tries_left;\n\t\tpin_info.max_tries = 3;\n\n\t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));\n\t\tpin_obj.flags = esteid_pin_flags[i];\n\n\t\t/* Link normal PINs with PUK */\n\t\tif (i < 2) {\n\t\t\tpin_obj.auth_id.len = 1;\n\t\t\tpin_obj.auth_id.value[0] = 3;\n\t\t}\n\n\t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* add private keys */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic int prkey_pin[2] = {1, 2};\n\n\t\tstatic const char *prkey_name[2] = {\n\t\t\t\""Isikutuvastus\"",\n\t\t\t\""Allkirjastamine\""};\n\n\t\tstruct sc_pkcs15_prkey_info prkey_info;\n\t\tstruct sc_pkcs15_object prkey_obj;\n\n\t\tmemset(&prkey_info, 0, sizeof(prkey_info));\n\t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));\n\n\t\tprkey_info.id.len = 1;\n\t\tprkey_info.id.value[0] = prkey_pin[i];\n\t\tprkey_info.native = 1;\n\t\tprkey_info.key_reference = i + 1;\n\t\tprkey_info.field_length = field_length;\n\t\tprkey_info.modulus_length = modulus_length;\n\t\tif (i == 1)\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;\n\t\telse if(field_length > 0) // ECC has sign and derive usage\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;\n\t\telse\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\n\t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));\n\t\tprkey_obj.auth_id.len = 1;\n\t\tprkey_obj.auth_id.value[0] = prkey_pin[i];\n\t\tprkey_obj.user_consent = 0;\n\t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\t\tif(field_length > 0)\n\t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);\n\t\telse\n\t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\treturn SC_SUCCESS;\n}""}, {""func_name"": ""util_acl_to_str"", ""file_path"": ""src/tools/util.c"", ""func_code"": ""const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \""N/A\"";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \""N/A\"";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \""NEVR\"";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \""NONE\"";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \""CHV\"");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \""%d\"", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \""TERM\"");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \""PROT\"");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \""AUTH\"");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \""%d\"", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \""Sec.Env. \"");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \""#%d\"", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \""Sec.ControlByte \"");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \""Ox%X\"", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \""PKCS#15 AuthID \"");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \""#%d\"", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \""????\"");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \"" \"", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n\tline[strlen(line)-1] = 0; /* get rid of trailing space */\n\treturn line;\n}""}, {""func_name"": ""sc_file_set_sec_attr"", ""file_path"": ""src/libopensc/sc.c"", ""func_code"": ""int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL || sec_attr_len) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}""}, {""func_name"": ""read_file"", ""file_path"": ""src/tools/egk-tool.c"", ""func_code"": ""int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file && file->size > 0 ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}""}, {""func_name"": ""muscle_list_files"", ""file_path"": ""src/libopensc/card-muscle.c"", ""func_code"": ""static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n\tmscfs_check_cache(priv->fs);\n\n\tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid = fs->cache.array[x].objectId.id;\n\t\tif (bufLen < 2)\n\t\t\tbreak;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n\t\t\tbuf[1] = oid[3];\n\t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n\t\t\tbuf += 2;\n\t\t\tcount += 2;\n\t\t\tbufLen -= 2;\n\t\t}\n\t}\n\treturn count;\n}""}]",{},[],"In `muscle_list_files` (src/libopensc/card-muscle.c), the loop iterates over `fs->cache.array`, copying 2-byte file identifiers into `buf` without tracking remaining buffer space. The original code lacked a bounds check, allowing writes beyond `buf`'s allocated size. The patch introduces `bufLen` tracking and terminates the loop if `bufLen < 2`, preventing overflow.",0.95,./github/other_context/CVE-2018-16391
25,CVE-2018-5801,CWE-476,c_cpp,"An error within the ""LibRaw::unpack()"" function (src/libraw_cxx.cpp) in LibRaw versions prior to 0.18.7 can be exploited to trigger a NULL pointer dereference.",https://github.com/LibRaw/LibRaw/commit/0df5490b985c419de008d32168650bff17128914,SA79000 advisory fix,21,"[{""func_name"": ""sinar_4shot_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \""sinar_4shot_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}"", ""target"": 0}, {""func_name"": ""foveon_sd_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS foveon_sd_load_raw()\n{\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf = 0;\n  int pred[3], row, col, bit = -1, c, i;\n\n  read_shorts((ushort *)diff, 1024);\n  if (!load_flags)\n    foveon_decoder(1024, 0);\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model + 2) < 14)\n      get4();\n    for (col = bit = 0; col < width; col++)\n    {\n      if (load_flags)\n      {\n        bitbuf = get4();\n        FORC3 pred[2 - c] += diff[bitbuf >> c * 10 & 0x3ff];\n      }\n      else\n        FORC3\n        {\n          for (dindex = first_decode; dindex->branch[0];)\n          {\n            if ((bit = (bit - 1) & 31) == 31)\n              for (i = 0; i < 4; i++)\n                bitbuf = (bitbuf << 8) + fgetc(ifp);\n            dindex = dindex->branch[bitbuf >> bit & 1];\n          }\n          pred[c] += diff[dindex->leaf];\n          if (pred[c] >> 16 && ~pred[c] >> 16)\n            derror();\n        }\n      FORC3 image[row * width + col][c] = pred[c];\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""kodak_rgb_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""nikon_yuv_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }"", ""target"": 0}, {""func_name"": ""kodak_c330_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \""kodak_c330_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}"", ""target"": 0}, {""func_name"": ""kodak_radc_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }"", ""target"": 0}, {""func_name"": ""kodak_ycbcr_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""imacon_full_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image)\n    return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \""imacon_full_load_raw\"");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}"", ""target"": 0}, {""func_name"": ""kodak_c603_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \""kodak_c603_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}"", ""target"": 0}, {""func_name"": ""kodak_thumb_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}"", ""target"": 0}, {""func_name"": ""foveon_dp_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek(ifp, 8, SEEK_CUR);\n  foveon_huff(huff);\n  roff[0] = 48;\n  FORC3 roff[c + 1] = -(-(roff[c] + get4()) & -16);\n  FORC3\n  {\n    fseek(ifp, data_offset + roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n      {\n        diff = ljpeg_diff(huff);\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        image[row * width + col][c] = hpred[col & 1];\n      }\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""sinar_4shot_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \""sinar_4shot_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}"", ""target"": 0}, {""func_name"": ""kodak_rgb_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""nikon_yuv_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }"", ""target"": 0}, {""func_name"": ""kodak_c330_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \""kodak_c330_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}"", ""target"": 0}, {""func_name"": ""kodak_ycbcr_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""imacon_full_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image)\n    return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \""imacon_full_load_raw\"");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}"", ""target"": 0}, {""func_name"": ""kodak_c603_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \""kodak_c603_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}"", ""target"": 0}, {""func_name"": ""kodak_thumb_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}"", ""target"": 0}, {""func_name"": ""kodak_radc_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }"", ""target"": 0}, {""func_name"": ""LibRaw::unpack"", ""file_path"": ""src/libraw_cxx.cpp"", ""func_code"": ""int LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try\n  {\n\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 0, 2);\n    if (O.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if (!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if (imgdata.image)\n    {\n      free(imgdata.image);\n      imgdata.image = 0;\n    }\n    if (imgdata.rawdata.raw_alloc)\n    {\n      free(imgdata.rawdata.raw_alloc);\n      imgdata.rawdata.raw_alloc = 0;\n    }\n    if (libraw_internal_data.unpacker_data.meta_length)\n    {\n      libraw_internal_data.internal_data.meta_data = (char *)malloc(libraw_internal_data.unpacker_data.meta_length);\n      merror(libraw_internal_data.internal_data.meta_data, \""LibRaw::unpack()\"");\n    }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if (!IO.fuji_width)\n    {\n      // adjust non-Fuji allocation\n      if (rwidth < S.width + S.left_margin)\n        rwidth = S.width + S.left_margin;\n      if (rheight < S.height + S.top_margin)\n        rheight = S.height + S.top_margin;\n    }\n\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n    imgdata.rawdata.float_image = 0;\n    imgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n    if (imgdata.idata.dng_version && dnghost && imgdata.idata.raw_count == 1 && valid_for_dngsdk() &&\n        load_raw != &LibRaw::pentax_4shot_load_raw)\n    {\n      int rr = try_dngsdk();\n    }\n#endif\n\n#ifdef USE_RAWSPEED\n    if (!raw_was_read())\n    {\n      int rawspeed_enabled = 1;\n\n      if (imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.raw_count > 1)\n        rawspeed_enabled = 0;\n      if (!strncasecmp(imgdata.idata.software, \""Magic\"", 5))\n        rawspeed_enabled = 0;\n      // Disable rawspeed for double-sized Oly files\n      if (!strncasecmp(imgdata.idata.make, \""Olympus\"", 7) &&\n          ((imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model, \""SH-2\"", 4) ||\n           !strncasecmp(imgdata.idata.model, \""SH-3\"", 4) || !strncasecmp(imgdata.idata.model, \""TG-4\"", 4) ||\n           !strncasecmp(imgdata.idata.model, \""TG-5\"", 4)))\n        rawspeed_enabled = 0;\n\n      if (!strncasecmp(imgdata.idata.make, \""Canon\"", 5) && !strcasecmp(imgdata.idata.model, \""EOS 6D Mark II\""))\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.dng_version && imgdata.idata.filters == 0 &&\n          libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make, \""Nikon\"", 5) &&\n          (!strncasecmp(imgdata.idata.model, \""E\"", 1) || !strncasecmp(imgdata.idata.model, \""COOLPIX B\"", 9)))\n        rawspeed_enabled = 0;\n\n      // RawSpeed Supported,\n      if (O.use_rawspeed && rawspeed_enabled &&\n          !(is_sraw() &&\n            (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE))) &&\n          (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)\n      {\n        int rr = try_rawspeed();\n      }\n    }\n#endif\n    if (!raw_was_read()) // RawSpeed failed or not run\n    {\n      // Not allocated on RawSpeed call, try call LibRaow\n      int zero_rawimage = 0;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder and DNG float\n        // Do nothing! Decoder will allocate data internally\n      }\n      else if (imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image\n      {\n        imgdata.rawdata.raw_alloc = malloc(rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));\n        imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 2; // Bayer case, not set before\n      }\n      else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n      {\n        if (decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL)\n        {\n          S.raw_pitch = S.raw_width * 8;\n        }\n        else\n        {\n          S.iwidth = S.width;\n          S.iheight = S.height;\n          IO.shrink = 0;\n          if (!S.raw_pitch)\n            S.raw_pitch =\n                (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width * 8 : S.width * 8;\n        }\n        // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n        // allocate image as temporary buffer, size\n        imgdata.rawdata.raw_alloc = 0;\n        imgdata.image = (ushort(*)[4])calloc(unsigned(S.raw_width) * unsigned(S.raw_height), sizeof(*imgdata.image));\n        if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n          zero_rawimage = 1;\n        }\n      }\n      ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n      unsigned m_save = C.maximum;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = 65535;\n      (this->*load_raw)();\n      if (zero_rawimage)\n        imgdata.rawdata.raw_image = 0;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = m_save;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder only: do nothing\n      }\n      else if (!(imgdata.idata.filters || P1.colors == 1)) // legacy decoder, ownalloc handled above\n      {\n        // successfully decoded legacy image, attach image to raw_alloc\n        imgdata.rawdata.raw_alloc = imgdata.image;\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n        imgdata.image = 0;\n        // Restore saved values. Note: Foveon have masked frame\n        // Other 4-color legacy data: no borders\n        if (!(libraw_internal_data.unpacker_data.load_flags & 256) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          S.raw_width = S.width;\n          S.left_margin = 0;\n          S.raw_height = S.height;\n          S.top_margin = 0;\n        }\n      }\n    }\n\n    if (imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for (c = 0; c < 3; c++)\n      if (i > C.cblack[c])\n        i = C.cblack[c];\n    for (c = 0; c < 4; c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams, &libraw_internal_data.internal_output_params,\n            sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 1, 2);\n\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee)\n  {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}"", ""target"": 0}]","[{""func_name"": ""sinar_4shot_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \""sinar_4shot_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}""}, {""func_name"": ""foveon_sd_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS foveon_sd_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf = 0;\n  int pred[3], row, col, bit = -1, c, i;\n\n  read_shorts((ushort *)diff, 1024);\n  if (!load_flags)\n    foveon_decoder(1024, 0);\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model + 2) < 14)\n      get4();\n    for (col = bit = 0; col < width; col++)\n    {\n      if (load_flags)\n      {\n        bitbuf = get4();\n        FORC3 pred[2 - c] += diff[bitbuf >> c * 10 & 0x3ff];\n      }\n      else\n        FORC3\n        {\n          for (dindex = first_decode; dindex->branch[0];)\n          {\n            if ((bit = (bit - 1) & 31) == 31)\n              for (i = 0; i < 4; i++)\n                bitbuf = (bitbuf << 8) + fgetc(ifp);\n            dindex = dindex->branch[bitbuf >> bit & 1];\n          }\n          pred[c] += diff[dindex->leaf];\n          if (pred[c] >> 16 && ~pred[c] >> 16)\n            derror();\n        }\n      FORC3 image[row * width + col][c] = pred[c];\n    }\n  }\n}""}, {""func_name"": ""kodak_rgb_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_rgb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}""}, {""func_name"": ""nikon_yuv_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS nikon_yuv_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }""}, {""func_name"": ""kodak_c330_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_c330_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \""kodak_c330_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}""}, {""func_name"": ""kodak_radc_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_radc_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  // All kodak radc images are 768x512\n  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }""}, {""func_name"": ""kodak_ycbcr_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_ycbcr_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}""}, {""func_name"": ""imacon_full_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \""imacon_full_load_raw\"");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}""}, {""func_name"": ""kodak_c603_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_c603_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \""kodak_c603_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}""}, {""func_name"": ""kodak_thumb_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS kodak_thumb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}""}, {""func_name"": ""foveon_dp_load_raw"", ""file_path"": ""dcraw/dcraw.c"", ""func_code"": ""void CLASS foveon_dp_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek(ifp, 8, SEEK_CUR);\n  foveon_huff(huff);\n  roff[0] = 48;\n  FORC3 roff[c + 1] = -(-(roff[c] + get4()) & -16);\n  FORC3\n  {\n    fseek(ifp, data_offset + roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n      {\n        diff = ljpeg_diff(huff);\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        image[row * width + col][c] = hpred[col & 1];\n      }\n    }\n  }\n}""}, {""func_name"": ""sinar_4shot_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \""sinar_4shot_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}""}, {""func_name"": ""kodak_rgb_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_rgb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}""}, {""func_name"": ""nikon_yuv_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS nikon_yuv_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }""}, {""func_name"": ""kodak_c330_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_c330_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \""kodak_c330_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}""}, {""func_name"": ""kodak_ycbcr_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_ycbcr_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}""}, {""func_name"": ""imacon_full_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \""imacon_full_load_raw\"");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}""}, {""func_name"": ""kodak_c603_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_c603_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \""kodak_c603_load_raw()\"");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}""}, {""func_name"": ""kodak_thumb_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_thumb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}""}, {""func_name"": ""kodak_radc_load_raw"", ""file_path"": ""internal/dcraw_common.cpp"", ""func_code"": ""void CLASS kodak_radc_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  // All kodak radc images are 768x512\n  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }""}, {""func_name"": ""LibRaw::unpack"", ""file_path"": ""src/libraw_cxx.cpp"", ""func_code"": ""int LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try\n  {\n\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 0, 2);\n    if (O.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if (!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if (imgdata.image)\n    {\n      free(imgdata.image);\n      imgdata.image = 0;\n    }\n    if (imgdata.rawdata.raw_alloc)\n    {\n      free(imgdata.rawdata.raw_alloc);\n      imgdata.rawdata.raw_alloc = 0;\n    }\n    if (libraw_internal_data.unpacker_data.meta_length)\n    {\n      libraw_internal_data.internal_data.meta_data = (char *)malloc(libraw_internal_data.unpacker_data.meta_length);\n      merror(libraw_internal_data.internal_data.meta_data, \""LibRaw::unpack()\"");\n    }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if (!IO.fuji_width)\n    {\n      // adjust non-Fuji allocation\n      if (rwidth < S.width + S.left_margin)\n        rwidth = S.width + S.left_margin;\n      if (rheight < S.height + S.top_margin)\n        rheight = S.height + S.top_margin;\n    }\n\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n    imgdata.rawdata.float_image = 0;\n    imgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n    if (imgdata.idata.dng_version && dnghost && imgdata.idata.raw_count == 1 && valid_for_dngsdk() &&\n        load_raw != &LibRaw::pentax_4shot_load_raw)\n    {\n      int rr = try_dngsdk();\n    }\n#endif\n\n#ifdef USE_RAWSPEED\n    if (!raw_was_read())\n    {\n      int rawspeed_enabled = 1;\n\n      if (imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.raw_count > 1)\n        rawspeed_enabled = 0;\n      if (!strncasecmp(imgdata.idata.software, \""Magic\"", 5))\n        rawspeed_enabled = 0;\n      // Disable rawspeed for double-sized Oly files\n      if (!strncasecmp(imgdata.idata.make, \""Olympus\"", 7) &&\n          ((imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model, \""SH-2\"", 4) ||\n           !strncasecmp(imgdata.idata.model, \""SH-3\"", 4) || !strncasecmp(imgdata.idata.model, \""TG-4\"", 4) ||\n           !strncasecmp(imgdata.idata.model, \""TG-5\"", 4)))\n        rawspeed_enabled = 0;\n\n      if (!strncasecmp(imgdata.idata.make, \""Canon\"", 5) && !strcasecmp(imgdata.idata.model, \""EOS 6D Mark II\""))\n        rawspeed_enabled = 0;\n\n      if (imgdata.idata.dng_version && imgdata.idata.filters == 0 &&\n          libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n        rawspeed_enabled = 0;\n\n      if (load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make, \""Nikon\"", 5) &&\n          (!strncasecmp(imgdata.idata.model, \""E\"", 1) || !strncasecmp(imgdata.idata.model, \""COOLPIX B\"", 9)))\n        rawspeed_enabled = 0;\n\n      // RawSpeed Supported,\n      if (O.use_rawspeed && rawspeed_enabled &&\n          !(is_sraw() &&\n            (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE))) &&\n          (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)\n      {\n        int rr = try_rawspeed();\n      }\n    }\n#endif\n    if (!raw_was_read()) // RawSpeed failed or not run\n    {\n      // Not allocated on RawSpeed call, try call LibRaow\n      int zero_rawimage = 0;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder and DNG float\n        // Do nothing! Decoder will allocate data internally\n      }\n      else if (imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image\n      {\n        imgdata.rawdata.raw_alloc = malloc(rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));\n        imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;\n        if (!S.raw_pitch)\n          S.raw_pitch = S.raw_width * 2; // Bayer case, not set before\n      }\n      else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n      {\n        if (decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL)\n        {\n          S.raw_pitch = S.raw_width * 8;\n        }\n        else\n        {\n          S.iwidth = S.width;\n          S.iheight = S.height;\n          IO.shrink = 0;\n          if (!S.raw_pitch)\n            S.raw_pitch =\n                (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width * 8 : S.width * 8;\n        }\n        // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n        // allocate image as temporary buffer, size\n        imgdata.rawdata.raw_alloc = 0;\n        imgdata.image = (ushort(*)[4])calloc(unsigned(MAX(S.width,S.raw_width)) * unsigned(MAX(S.height,S.raw_height)), sizeof(*imgdata.image));\n        if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n          zero_rawimage = 1;\n        }\n      }\n      ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n      unsigned m_save = C.maximum;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = 65535;\n      (this->*load_raw)();\n      if (zero_rawimage)\n        imgdata.rawdata.raw_image = 0;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = m_save;\n      if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)\n      {\n        // x3f foveon decoder only: do nothing\n      }\n      else if (!(imgdata.idata.filters || P1.colors == 1)) // legacy decoder, ownalloc handled above\n      {\n        // successfully decoded legacy image, attach image to raw_alloc\n        imgdata.rawdata.raw_alloc = imgdata.image;\n        imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n        imgdata.image = 0;\n        // Restore saved values. Note: Foveon have masked frame\n        // Other 4-color legacy data: no borders\n        if (!(libraw_internal_data.unpacker_data.load_flags & 256) &&\n            !(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          S.raw_width = S.width;\n          S.left_margin = 0;\n          S.raw_height = S.height;\n          S.top_margin = 0;\n        }\n      }\n    }\n\n    if (imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for (c = 0; c < 3; c++)\n      if (i > C.cblack[c])\n        i = C.cblack[c];\n    for (c = 0; c < 4; c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams, &libraw_internal_data.internal_output_params,\n            sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 1, 2);\n\n    return 0;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee)\n  {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}""}]","{""code"": 1, ""value"": 1, ""caller"": 1}","[{""source"": ""code_info(file:libraw_cxx.cpp, lines:2780-2810)"", ""result"": ""        {\n          S.raw_pitch = S.raw_width * 8;\n        }\n        else\n        {\n          S.iwidth = S.width;\n          S.iheight = S.height;\n          IO.shrink = 0;\n          if (!S.raw_pitch)\n            S.raw_pitch =\n                (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width * 8 : S.width * 8;\n        }\n        // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n        // allocate image as temporary buffer, size\n        imgdata.rawdata.raw_alloc = 0;\n        imgdata.image = (ushort(*)[4])calloc(unsigned(S.raw_width) * unsigned(S.raw_height), sizeof(*imgdata.image));\n        if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n        {\n          imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n          zero_rawimage = 1;\n        }\n      }\n      ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n      unsigned m_save = C.maximum;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = 65535;\n      (this->*load_raw)();\n      if (zero_rawimage)\n        imgdata.rawdata.raw_image = 0;\n      if (load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make, \""Nikon\""))\n        C.maximum = m_save;\n""}, {""source"": ""value_info(file:libraw_cxx.cpp, value:imgdata.image)"", ""result"": {""value_trace"": [{""full_code"": ""imgdata.image = NULL"", ""line"": 574, ""func_name"": ""LibRaw.recycle:void()""}, {""full_code"": ""imgdata.image = 0"", ""line"": 2679, ""func_name"": ""LibRaw.unpack:int(void)""}, {""full_code"": ""imgdata.image = (ushort(*)[4])calloc(unsigned(S.raw_width) * unsigned(S.raw_height), sizeof(*imgdata.image))"", ""line"": 2795, ""func_name"": ""LibRaw.unpack:int(void)""}, {""full_code"": ""imgdata.image = 0"", ""line"": 2821, ""func_name"": ""LibRaw.unpack:int(void)""}], ""struct_var"": ""imgdata"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:libraw_cxx.cpp, func:unpack)"", ""result"": [{""call_line"": 105, ""call_code"": ""RawProcessor.unpack()"", ""caller_code"": ""int main(int ac, char *av[])\n{\n  int i, ret;\n  int autoscale = 0, black_subtraction = 1, use_gamma = 0;\n  char outfn[1024];\n\n  LibRaw RawProcessor;\n  if (ac < 2)\n  {\n  usage:\n    printf(\""4channels - LibRaw %s sample. %d cameras supported\\n\""\n           \""Usage: %s [-s N] [-g] [-A] [-B] [-N] raw-files....\\n\""\n           \""\\t-s N - select Nth image in file (default=0)\\n\""\n           \""\\t-g - use gamma correction with gamma 2.2 (not precise,use for visual inspection only)\\n\""\n           \""\\t-A - autoscaling (by integer factor)\\n\""\n           \""\\t-B - no black subtraction\\n\"",\n           LibRaw::version(), LibRaw::cameraCount(), av[0]);\n    return 0;\n  }\n\n#define P1 RawProcessor.imgdata.idata\n#define S RawProcessor.imgdata.sizes\n#define C RawProcessor.imgdata.color\n#define T RawProcessor.imgdata.thumbnail\n#define P2 RawProcessor.imgdata.other\n#define OUT RawProcessor.imgdata.params\n\n  OUT.output_bps = 16;\n  OUT.output_tiff = 1;\n  OUT.user_flip = 0;\n  OUT.no_auto_bright = 1;\n  OUT.half_size = 1;\n\n ..."", ""caller_start"": 36, ""file_path"": ""samples/4channels.cpp""}, {""call_line"": 576, ""call_code"": ""RawProcessor.unpack()"", ""caller_code"": ""int main(int argc, char *argv[])\n{\n  if (argc == 1)\n    usage(argv[0]);\n\n  LibRaw RawProcessor;\n  int i, arg, c, ret;\n  char opm, opt, *cp, *sp;\n  int use_bigfile = 0, use_timing = 0, use_mem = 0;\n#ifdef USE_DNGSDK\n  dng_host *dnghost = NULL;\n#endif\n#ifndef WIN32\n  int msize = 0, use_mmap = 0;\n\n#endif\n  void *iobuffer = 0;\n#ifdef OUT\n#undef OUT\n#endif\n\n#define OUT RawProcessor.imgdata.params\n\n  argv[argc] = (char *)\""\"";\n  for (arg = 1; (((opm = argv[arg][0]) - 2) | 2) == '+';)\n  {\n    char *optstr = argv[arg];\n    opt = argv[arg++][1];\n    if ((cp = strchr(sp = (char *)\""cnbrkStqmHABCgU\"", opt)) != 0)\n      for (i = 0; i < \""111411111144221\""[cp - sp] - '0'; i++)\n        if (!isdigit(argv[arg + i][0]) && !optstr[2])\n        {\n          fprintf(stderr, \""Non-numeric argument to \\\""-%c\\\""\\n\"", opt);\n          return 1;\n        }\n    if (!strchr(\""ftdeam\"", opt) && argv[arg - 1][2])\n      fprintf(stderr, \""Unknown option \\\""%s\\\"".\\n\"", argv[arg - 1]);\n    switch (opt)\n    {\n    case 'v':\n      verbos..."", ""caller_start"": 184, ""file_path"": ""samples/dcraw_emu.cpp""}, {""call_line"": 146, ""call_code"": ""RawProcessor.unpack()"", ""caller_code"": ""int main(int ac, char *av[])\n{\n  int i, ret, output_thumbs = 0;\n\n  // don't use fixed size buffers in real apps!\n\n  LibRaw RawProcessor;\n\n  if (ac < 2)\n  {\n    printf(\""mem_image - LibRaw sample, to illustrate work for memory buffers. Emulates dcraw [-4] [-1] [-e] [-h]\\n\""\n           \""Usage: %s [-D] [-T] [-v] [-e] raw-files....\\n\""\n           \""\\t-6 - output 16-bit PPM\\n\""\n           \""\\t-4 - linear 16-bit data\\n\""\n           \""\\t-e - extract thumbnails (same as dcraw -e in separate run)\\n\"",\n           \""\\t-h - use half_size\\n\"");\n    return 0;\n  }\n\n  putenv((char *)\""TZ=UTC\""); // dcraw compatibility, affects TIFF datestamp field\n\n#define P1 RawProcessor.imgdata.idata\n#define S RawProcessor.imgdata.sizes\n#define C RawProcessor.imgdata.color\n#define T RawProcessor.imgdata.thumbnail\n#define P2 RawProcessor.imgdata.other\n#define OUT RawProcessor.imgdata.params\n\n  for (i = 1; i < ac; i++)\n  {\n    if (av[i][0] == '-')\n    {\n      if (av[i][1] == '6' && av[i][2] == 0)\n        OUT.output_bps = 16;\n  ..."", ""caller_start"": 94, ""file_path"": ""samples/mem_image.cpp""}, {""call_line"": 86, ""call_code"": ""RawProcessor.unpack()"", ""caller_code"": ""int main(int ac, char *av[])\n{\n  int i, ret;\n\n  LibRaw RawProcessor;\n  if (ac < 2)\n  {\n    printf(\""multirender_test - LibRaw %s sample. Performs 4 different renderings of one file\\n\""\n           \"" %d cameras supported\\n\""\n           \""Usage: %s raw-files....\\n\"",\n           LibRaw::version(), LibRaw::cameraCount(), av[0]);\n    return 0;\n  }\n\n  for (i = 1; i < ac; i++)\n  {\n\n    printf(\""Processing file %s\\n\"", av[i]);\n\n    if ((ret = RawProcessor.open_file(av[i])) != LIBRAW_SUCCESS)\n    {\n      fprintf(stderr, \""Cannot open_file %s: %s\\n\"", av[i], libraw_strerror(ret));\n      continue; // no recycle b/c open file will recycle itself\n    }\n\n    if ((ret = RawProcessor.unpack()) != LIBRAW_SUCCESS)\n    {\n      fprintf(stderr, \""Cannot unpack %s: %s\\n\"", av[i], libraw_strerror(ret));\n      continue;\n    }\n    process_once(RawProcessor, 0, 0, 0, 1, -1, av[i]); // default flip\n    process_once(RawProcessor, 1, 0, 1, 2, -1, av[i]);\n    process_once(RawProcessor, 1, 1, 0, 3, -1, av[i]); // default fli..."", ""caller_start"": 61, ""file_path"": ""samples/multirender_test.cpp""}]}]","src/libraw_cxx.cpp:2793 (incorrect allocation size calculation in LibRaw::unpack() using S.raw_width * S.raw_height). If S.raw_width or S.raw_height is zero, calloc returns NULL. This NULL 'imgdata.image' is later dereferenced in functions like 'kodak_rgb_load_raw' (internal/dcraw_common.cpp:4069) without checks, causing a NULL pointer dereference.",0.95,./github/other_context/CVE-2018-5801
26,CVE-2018-9132,CWE-476,c_cpp,libming 0.4.8 has a NULL pointer dereference in the getInt function of the decompile.c file. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted swf file.,https://github.com/libming/libming/commit/dc65ba0497f4c5ca58be2018e2816e72baf63634,"decompile: Fix null pointer dereference in getInt\n\nWhen getInt is passed a PUSH_REGISTER parameter, it retrieves the\ncontent of this register and returns the value contained by this\nregister as an int. When this register is empty, we call getInt with\na NULL pointer and a null pointer dereference occurs.\n\nIn this patch we first make sure that regs[act->p.RegisterNumber] is\nnot NULL before doing anything with it.\n\nFixes #133 (CVE-2018-9132).",1,"[{""func_name"": ""getInt"", ""file_path"": ""util/decompile.c"", ""func_code"": ""static int\ngetInt(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_FLOAT: /* FLOAT -- also used for PROPERTY storing */\n\t\treturn ((int)act->p.Float);\n\tcase PUSH_NULL: /* NULL */\n\t\treturn 0;\n\tcase PUSH_REGISTER: /* REGISTER */\n\t\treturn getInt(regs[act->p.RegisterNumber]);\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\treturn (int)act->p.Double;\n\tcase PUSH_INT: /* INTEGER */\n\t\treturn act->p.Integer;\n\tdefault: \n\t\tfprintf (stderr,\""  Can't get int for type: %d\\n\"", act->Type);\n\t}\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""getInt"", ""file_path"": ""util/decompile.c"", ""func_code"": ""static int\ngetInt(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_FLOAT: /* FLOAT -- also used for PROPERTY storing */\n\t\treturn ((int)act->p.Float);\n\tcase PUSH_NULL: /* NULL */\n\t\treturn 0;\n\tcase PUSH_REGISTER: /* REGISTER */\n\t\tif (regs[act->p.RegisterNumber])\n\t\t{\n\t\t\treturn getInt(regs[act->p.RegisterNumber]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSWF_warn(\""WARNING: retrieving undefined register values.\\n\"");\n\t\t\tbreak;\n\t\t}\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\treturn (int)act->p.Double;\n\tcase PUSH_INT: /* INTEGER */\n\t\treturn act->p.Integer;\n\tdefault: \n\t\tfprintf (stderr,\""  Can't get int for type: %d\\n\"", act->Type);\n\t}\n\treturn 0;\n}""}]","{""value"": 5, ""code"": 3, ""function"": 2}","[{""source"": ""value_info(file:decompile.c, value:regs)"", ""result"": {""value_trace"": [{""full_code"": ""regs[0]=var"", ""line"": 1583, ""func_name"": ""decompileINCR_DECR""}, {""full_code"": ""regs[sact->Register] = data"", ""line"": 1639, ""func_name"": ""decompileSTOREREGISTER""}, {""full_code"": ""regs[0]=newVar3(getName(obj),\"".\"",getName(var))"", ""line"": 1776, ""func_name"": ""decompileSETMEMBER""}, {""full_code"": ""regs[sact->CatchRegister] = newVar(t)"", ""line"": 2722, ""func_name"": ""decompileTRY""}, {""full_code"": ""regs[sact->CatchRegister]=rsave"", ""line"": 2729, ""func_name"": ""decompileTRY""}], ""struct_var"": ""regs"", ""struct_type"": ""SWF_ACTIONPUSHPARAM*[256]"", ""struct_definition"": null}}, {""source"": ""value_info(file:decompile.c, value:act)"", ""result"": {""value_trace"": [{""full_code"": ""act = (SWF_ACTIONGOTOFRAME *)action"", ""line"": 931, ""func_name"": ""parseSWF_ACTIONRECORD""}, {""full_code"": ""act = (SWF_ACTIONGETURL *)action"", ""line"": 937, ""func_name"": ""parseSWF_ACTIONRECORD""}, {""full_code"": ""act = (SWF_ACTIONWAITFORFRAME *)action"", ""line"": 944, ""func_name"": ""parseSWF_ACTIONRECORD""}], ""struct_var"": ""act"", ""struct_type"": ""SWF_ACTIONGOTOFRAME*"", ""struct_definition"": ""struct SWF_ACTIONGOTOFRAME {\n\tUI8\tActionCode;\n\tUI16\tLength;\n\tUI32\tOffset;\n\tWORD\tFrame;\n}\n\nstruct SWF_ACTIONGOTOFRAME""}}, {""source"": ""code_info(file:decompile.c, lines:450-500)"", ""result"": ""\t\tif (act->p.Constant16 > poolcounter)\n\t\t{\n\t\t        SWF_warn(\""WARNING: retrieving constants not present in the pool.\\n\"");\n\t\t        break;\n\t\t}\n\t\tt=malloc(strlenext(pool[act->p.Constant16])+1);\n\t\tstrcpyext(t,pool[act->p.Constant16]);\n\t\tif(strlen(t)) /* Not a zero length string */\n\t\t\treturn t;\n\t\telse\n\t\t{\n\t\t\tt=realloc(t,6);\n\t\t\treturn strcpy(t,\""this\"");\n\t\t}\n\tdefault: \n\t\treturn getString(act);\n\t}\n\n\tt = malloc(sizeof(char));\n\tstrcpyext(t,\""\"");\n\n\treturn t;\n}\n\nstatic int\ngetInt(struct SWF_ACTIONPUSHPARAM *act)\n{\n\tswitch( act->Type ) \n\t{\n\tcase PUSH_FLOAT: /* FLOAT -- also used for PROPERTY storing */\n\t\treturn ((int)act->p.Float);\n\tcase PUSH_NULL: /* NULL */\n\t\treturn 0;\n\tcase PUSH_REGISTER: /* REGISTER */\n\t\treturn getInt(regs[act->p.RegisterNumber]);\n\tcase PUSH_DOUBLE: /* DOUBLE */\n\t\treturn (int)act->p.Double;\n\tcase PUSH_INT: /* INTEGER */\n\t\treturn act->p.Integer;\n\tdefault: \n\t\tfprintf (stderr,\""  Can't get int for type: %d\\n\"", act->Type);\n\t}\n\treturn 0;\n}\n\nstatic char *\ngetProperty(Property prop)\n{\n\tswitch(prop)\n\t{\n\tcase SWF_SETPROPERTY_X: \treturn(\""_x\""); break;\n\tcase SWF_SETPROPERTY_Y:\n""}, {""source"": ""func_info(func:parseSWF_ACTIONRECORD)"", ""result"": [{""code"": ""int\nparseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)\n{\n\tint thisaction = *thisactionp;\n\tSWF_ACTION *action = &(actions[thisaction]);\n\n\t//fprintf(stderr,\""ACTION[%d] Offset %d\\n\"", thisaction, fileOffset );\n\n\taction->SWF_ACTIONRECORD.Offset = fileOffset; /* remember where it came from */\n\tif( (action->SWF_ACTIONRECORD.ActionCode = readUInt8(f)) == SWFACTION_END )\n\t\treturn 0;\n\t/*\n\t * Actions without the high bit set take no additional\n\t * arguments, so we are done for these types.\n\t */\n\tif( !(action->SWF_ACTIONRECORD.ActionCode&0x80) ) {\n\t\taction->SWF_ACTIONRECORD.Length = 1; /* Fill in the size for later use */\n\t\treturn 1;\n\t}\n\n\taction->SWF_ACTIONRECORD.Length = 0; /* make valgrind happy */\n\t/*\n\t * Actions with the high bit set take additional\n\t * arguments, so we have to parse each one uniquely.\n\t */\n\tswitch( action->SWF_ACTIONRECORD.ActionCode ) {\n\t\t/* v3 actions */\n\tcase SWFACTION_GOTOFRAME:\n\t\t{\n\t\tACT_BEGIN(SWF_ACTIONGOTOFRAME)\n\t\tact->Frame = readUInt16(f);\n\t\tbr..."", ""start_line"": 902, ""end_line"": 1285, ""full_name"": ""parseSWF_ACTIONRECORD"", ""file_path"": ""util/parser.c""}]}, {""source"": ""code_info(file:decompile.c, lines:1-200)"", ""result"": ""/****************************************************************************\n *\n *  Copyright (C) 2006,2007 A.Kleine\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n ****************************************************************************/\n\n#define _GNU_SOURCE 1\n\n//#define DEBUGSTACK\n#define DECOMP_SWITCH\n// #define DEBUGSWITCH\n\n//#define STATEMENT_CLASS  \n//  I have uncommented some buggy class recognition stuff in decompileIF()\n//  to make work simple code lines like:  \""if(!a) trace(a);\""   - ak, November 2006\n\n//  To do: add some free()-calls for allocated blocks\n\n#include <assert.h>\n\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#include \""read.h\""\n#include \""action.h\""\n#include \""swftypes.h\""\n#include \""../src/blocks/error.h\""\n#include \""vasprintf.h\""\n\n\nstatic char **pool;\nstatic unsigned short poolcounter;\nstruct SWF_ACTIONPUSHPARAM *regs[256];\n\nstatic char *getName(struct SWF_ACTIONPUSHPARAM *act);\n\nstatic int offseoloop;\t// offset wherever a break can jump to (loops and switch)\n\nstatic void\ndumpRegs()\n{\nint i;\nfor(i=0;i<6;i++)\n\tif( regs[i] )\n\t\tprintf(\""reg[%d] %s\\n\"", i, getName(regs[i]));\n}\n\n/*\n * Start Package \n *\n * A package to build up a string that can be returned to the caller\n * ak/2006: Extended for temporary swichting to a 2nd buffer\n */\n#define USE_LIB 1\n\nstatic int strsize=0;\nstatic int strmaxsize=0;\nstatic char *dcstr=NULL;\nstatic char *dcptr=NULL;\n\n#define DCSTRSIZE 40960\n#define PARAM_STRSIZE 512\nvoid\ndcinit()\n{\n\tstrsize = 1; // We start with empty string, i.e. \\0\n\tstrmaxsize=DCSTRSIZE;\n\tdcstr=calloc(DCSTRSIZE,1);\n\tdcptr=dcstr;\n}\n\nvoid\ndcchkstr(int size)\n{\n\twhile( (strsize+size) > strmaxsize ) {\n\t\tdcstr=realloc(dcstr,strmaxsize+DCSTRSIZE);\n\t\tstrmaxsize+=DCSTRSIZE;\n\t\tdcptr=dcstr+strsize;\n\t}\n\n}\n\nvoid\ndcputs(const char *s)\n{\n\tint len=strlen(s);\n\tdcchkstr(len);\n\tstrcat(dcptr,s);\n\tdcptr+=len;\n\tstrsize+=len;\n}\n\nvoid\ndcputchar(char c)\n{\n\tdcchkstr(1);\n\n\t*dcptr++=c;\n\t*dcptr='\\000';\n\tstrsize++;\n}\n\nint\ndcprintf(char *format, ...)\n{\n\tchar *s;\n\tsize_t size;\n\tint ret;\n\n\tva_list args;\n\tva_start(args,format);\n\tret = vasprintf(&s,format,args);\n\tdcputs(s);\n\tsize=strlen(s);\n\tfree(s);\n\treturn size;\n}\n\nchar *\ndcgetstr()\n{\n\tchar *ret;\n\tret = dcstr;\n\tdcstr=NULL;\n\tstrmaxsize=0;\n\treturn ret;\n}\n\nstruct strbufinfo\n{\n\tint size;\n\tint maxsize;\n\tchar *str;\n\tchar *ptr;\n};\n\n\nstatic struct strbufinfo setTempString(void)\n{\n\tstruct strbufinfo current;\n\tcurrent.size=strsize;\n\tcurrent.maxsize=strmaxsize;\n\tcurrent.str=dcstr;\n\tcurrent.ptr=dcptr;\n\tdcinit();\n\treturn current;\n}\n\nstatic void setOrigString(struct strbufinfo old)\n{\n\tfree(dcstr);\t\t\t\t/* not needed anymore */\n\tstrsize=old.size;\n\tstrmaxsize=old.maxsize;\n\tdcstr=old.str;\n\tdcptr=old.ptr;\n}\n\n// a variant of setOrigString()\n// but for further usage of 2nd buffer\n//\nstatic char *\nswitchToOrigString(struct strbufinfo old)\n{\n\tchar *tmp=dcstr;\n\tstrsize=old.size;\n\tstrmaxsize=old.maxsize;\n\tdcstr=old.str;\n\tdcptr=old.ptr;\n\treturn tmp;\n}\n\n#if USE_LIB\n#define puts(s) dcputs(s)\n#define putchar(c) dcputchar(c)\n#define printf dcprintf\n#endif\n\n#define INDENT { int ii=gIndent; while(--ii>=0) { putchar(' '); putchar(' '); } }\n\n/* String used for terminating lines (see println) */\nstatic const char* newlinestring = \""\\\\\\n\"";\n\n/* Set the newline character. By default it is an escaped NL. */\nvoid\n""}, {""source"": ""value_info(file:decompile.c, value:act->p.RegisterNumber)"", ""result"": {""value_trace"": [{""full_code"": ""act->p.RegisterNumber"", ""line"": 329, ""func_name"": ""getString""}, {""full_code"": ""act->p.RegisterNumber"", ""line"": 330, ""func_name"": ""getString""}, {""full_code"": ""act->p.RegisterNumber"", ""line"": 331, ""func_name"": ""getString""}, {""full_code"": ""act->p.RegisterNumber"", ""line"": 333, ""func_name"": ""getString""}, {""full_code"": ""act->p.RegisterNumber"", ""line"": 338, ""func_name"": ""getString""}], ""struct_var"": ""act"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:parser.c, lines:1-200)"", ""result"": ""/****************************************************************************\n *\n *  Copyright (C) 2005-2006 \""Stuart R. Anderson\"" <anderson@netsweng.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n ****************************************************************************/\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/param.h>\n#include \""blocks/blocktypes.h\""\n#include \""abctypes.h\""\n#include \""action.h\""\n#include \""decompile.h\""\n#include \""parser.h\""\n#include \""read.h\""\n#include \""blocks/error.h\""\n\nextern struct Movie m;\nextern SWF_Parserstruct *blockParse (FILE *f, int length, SWFBlocktype header);\nconst char *blockName (SWFBlocktype header);\nvoid silentSkipBytes(FILE *f, int length);\n\n#define PAR_BEGIN(block) \t\t\t\t\t\t\\\n\tstruct block *parserrec; \t\t\t\t\t\\\n\tSWF_Parserstruct *pstruct; \t\t\t\t\t\\\n\tpstruct = calloc(1, sizeof(SWF_Parserstruct)); \t\t\t\\\n\tpstruct->length = length;\t\t\t\t\t\\\n\tpstruct->offset = fileOffset - ( (length >= 63 ) ? 6 : 2) ;\t\\\n\tparserrec= (struct block *)pstruct; \t\t\t\t\\\n\n#define PAR_END \\\n\treturn (SWF_Parserstruct *)parserrec;\n\n#define SKIP \\\n\tprintf(\""skipping %i bytes\\n\"", length); \\\n        readBytes(f, length);\n\n/* Parse Basic Flash types */\n\nvoid\nparseSWF_RGB (FILE * f, struct SWF_RGBA *rgb)\n{\n  rgb->red = readUInt8 (f);\n  rgb->green = readUInt8 (f);\n  rgb->blue = readUInt8 (f);\n  rgb->alpha = 255;\n}\n\nvoid\nparseSWF_RGBA (FILE * f, struct SWF_RGBA *rgb)\n{\n  rgb->red = readUInt8 (f);\n  rgb->green = readUInt8 (f);\n  rgb->blue = readUInt8 (f);\n  rgb->alpha = readUInt8 (f);\n}\n\nvoid\nparseSWF_RECT (FILE * f, struct SWF_RECT *rect)\n{\n  byteAlign ();\n\n  rect->Nbits = readBits (f, 5);\n  rect->Xmin = readSBits (f, rect->Nbits);\n  rect->Xmax = readSBits (f, rect->Nbits);\n  rect->Ymin = readSBits (f, rect->Nbits);\n  rect->Ymax = readSBits (f, rect->Nbits);\n}\n\nvoid\nparseSWF_MATRIX (FILE * f, struct SWF_MATRIX *matrix)\n{\n  byteAlign ();\n\n  matrix->HasScale = readBits (f, 1);\n  if (matrix->HasScale)\n    {\n      matrix->NScaleBits = readBits (f, 5);\n      matrix->ScaleX = (float) readSBits (f, matrix->NScaleBits) / 0x10000;\n      matrix->ScaleY = (float) readSBits (f, matrix->NScaleBits) / 0x10000;\n    }\n  matrix->HasRotate = readBits (f, 1);\n  if (matrix->HasRotate)\n    {\n      matrix->NRotateBits = readBits (f, 5);\n      matrix->RotateSkew0 =\n\t(float) readSBits (f, matrix->NRotateBits) / 0x10000;\n      matrix->RotateSkew1 =\n\t(float) readSBits (f, matrix->NRotateBits) / 0x10000;\n    }\n  matrix->NTranslateBits = readBits (f, 5);\n  matrix->TranslateX = readSBits (f, matrix->NTranslateBits);\n  matrix->TranslateY = readSBits (f, matrix->NTranslateBits);\n  byteAlign();\n}\n\nvoid \nparseSWF_FILTERLIST(FILE *f, SWF_FILTERLIST *list);\n\nint\nparseSWF_BUTTONRECORD (FILE * f, struct SWF_BUTTONRECORD *brec, int level)\n{\n  byteAlign ();\n\n  brec->ButtonReserved = readBits (f, 2);\n  brec->ButtonHasBlendMode = readBits(f, 1);\n  brec->ButtonHasFilterList = readBits(f, 1);\n  brec->ButtonStateHitTest = readBits (f, 1);\n  brec->ButtonStateDown = readBits (f, 1);\n  brec->ButtonStateOver = readBits (f, 1);\n  brec->ButtonStateUp = readBits (f, 1);\n  if( brec->ButtonStateHitTest == 0 &&\n      brec->ButtonStateDown == 0 &&\n      brec->ButtonStateOver == 0 &&\n      brec->ButtonStateUp == 0 &&\n      brec->ButtonHasBlendMode == 0 && \n      brec->ButtonHasFilterList == 0 &&\n      brec->ButtonReserved == 0)\n\t  return 0;  // CharacterEndFlag \n  brec->CharacterId = readUInt16 (f);\n  brec->PlaceDepth = readUInt16 (f);\n  parseSWF_MATRIX (f, &brec->PlaceMatrix);\n  if( level > 1 )\n  \tparseSWF_CXFORMWITHALPHA (f, &brec->ColorTransform);\n  if ( brec->ButtonHasFilterList )\n\tparseSWF_FILTERLIST(f, &brec->FilterList);\n  if ( brec->ButtonHasBlendMode )\n\tbrec->BlendMode = readUInt8(f);\n  return 1;\n}\n\nint\nparseSWF_BUTTONCONDACTION (FILE * f, struct SWF_BUTTONCONDACTION *bcarec, int end)\n{\n  int actionEnd, start;\n  byteAlign ();\n\n  start = fileOffset;\n  bcarec->CondActionSize = readUInt16 (f);\n  bcarec->CondIdleToOverDown = readBits (f, 1);\n  bcarec->CondOutDownToIdle = readBits (f, 1);\n  bcarec->CondOutDownToOverDown = readBits (f, 1);\n  bcarec->CondOverDownToOutDown = readBits (f, 1);\n  bcarec->CondOverDownToOverUp = readBits (f, 1);\n  bcarec->CondOverUpToOverDown = readBits (f, 1);\n  bcarec->CondOverUpToIdle = readBits (f, 1);\n  bcarec->CondIdleToOverUp = readBits (f, 1);\n  bcarec->CondKeyPress = readBits (f, 7);\n  bcarec->CondOverDownToIdle = readBits (f, 1);\n\n  bcarec->Actions =\n    (SWF_ACTION *) calloc (1, sizeof (SWF_ACTION));\n  bcarec->numActions = 0;\n  while ( parseSWF_ACTIONRECORD (f, &(bcarec->numActions), bcarec->Actions) ) {\n      bcarec->Actions = (SWF_ACTION *) realloc (bcarec->Actions,\n\t\t\t\t\t\t\t (++bcarec->\n\t\t\t\t\t\t\t  numActions +\n\t\t\t\t\t\t\t  1) *\n\t\t\t\t\t\t\t sizeof\n\t\t\t\t\t\t\t (SWF_ACTION));\n    }\n\n  if(bcarec->CondActionSize > 0)\n\tactionEnd = start + bcarec->CondActionSize;\n  else\n\tactionEnd = end;\n\n  if(fileOffset >= actionEnd)\n  {\n\tSWF_warn(\""parseSWF_BUTTONCONDACTION: expected actionEnd flag\\n\"");\n  \treturn bcarec->CondActionSize;\n  }\n\n  /* read end action flag only there are realy action records\n   * if there are no actionrecords parseSWF_ACTIONRECORD did already\n   * read end action\n   */\n  if(bcarec->numActions > 0)\n    readUInt8(f);\n  return bcarec->CondActionSize;\n}\n\nvoid\nparseSWF_CXFORM (FILE * f, struct SWF_CXFORM *cxform)\n{\n""}, {""source"": ""value_info(file:decompile.c, value:SWF_ACTIONPUSHPARAM)"", ""result"": {""value_trace"": [{""full_code"": ""struct SWF_ACTIONPUSHPARAM"", ""line"": 750, ""func_name"": null}, {""full_code"": ""struct SWF_ACTIONPUSHPARAM"", ""line"": 716, ""func_name"": null}, {""full_code"": ""struct SWF_ACTIONPUSHPARAM"", ""line"": 624, ""func_name"": null}, {""full_code"": ""struct SWF_ACTIONPUSHPARAM"", ""line"": 581, ""func_name"": null}, {""full_code"": ""struct SWF_ACTIONPUSHPARAM"", ""line"": 567, ""func_name"": null}], ""struct_var"": ""SWF_ACTIONPUSHPARAM"", ""struct_type"": ""SWF_ACTIONPUSHPARAM"", ""struct_definition"": ""struct SWF_ACTIONPUSHPARAM\n\nstruct SWF_ACTIONPUSHPARAM\n\nstruct SWF_ACTIONPUSHPARAM {\n\tUI8\tActionCode;\n\tUI16\tLength;\n\tUI32\tOffset;\n\tUI8\tType;\n\tunion {\n\t\tSTRING\tString;\n\t\tFLOAT\tFloat;\n\t\tint\tRegisterNumber;\n\t\tint\tBoolean;\n\t\tDOUBLE\tDouble;\n\t\tSI32\tInteger;\n\t\tUI8\tConstant8;\n\t\tUI16\tConstant16;\n\t} p;\n}\n\nstruct SWF_ACTIONPUSHPARAM""}}, {""source"": ""func_info(file:parser.c, func:parseSWF_ACTIONRECORD)"", ""result"": [{""code"": ""int\nparseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)\n{\n\tint thisaction = *thisactionp;\n\tSWF_ACTION *action = &(actions[thisaction]);\n\n\t//fprintf(stderr,\""ACTION[%d] Offset %d\\n\"", thisaction, fileOffset );\n\n\taction->SWF_ACTIONRECORD.Offset = fileOffset; /* remember where it came from */\n\tif( (action->SWF_ACTIONRECORD.ActionCode = readUInt8(f)) == SWFACTION_END )\n\t\treturn 0;\n\t/*\n\t * Actions without the high bit set take no additional\n\t * arguments, so we are done for these types.\n\t */\n\tif( !(action->SWF_ACTIONRECORD.ActionCode&0x80) ) {\n\t\taction->SWF_ACTIONRECORD.Length = 1; /* Fill in the size for later use */\n\t\treturn 1;\n\t}\n\n\taction->SWF_ACTIONRECORD.Length = 0; /* make valgrind happy */\n\t/*\n\t * Actions with the high bit set take additional\n\t * arguments, so we have to parse each one uniquely.\n\t */\n\tswitch( action->SWF_ACTIONRECORD.ActionCode ) {\n\t\t/* v3 actions */\n\tcase SWFACTION_GOTOFRAME:\n\t\t{\n\t\tACT_BEGIN(SWF_ACTIONGOTOFRAME)\n\t\tact->Frame = readUInt16(f);\n\t\tbr..."", ""start_line"": 902, ""end_line"": 1285, ""full_name"": ""parseSWF_ACTIONRECORD"", ""file_path"": ""util/parser.c""}]}, {""source"": ""value_info(file:parser.c, value:RegisterNumber)"", ""result"": {""value_trace"": [{""full_code"": ""param->p.RegisterNumber = readUInt8(f)"", ""line"": 987, ""func_name"": ""parseSWF_ACTIONRECORD""}], ""struct_var"": ""RegisterNumber"", ""struct_type"": null, ""struct_definition"": null}}]","util/decompile.c: getInt() dereferences 'regs[act->p.RegisterNumber]' without a NULL check in the PUSH_REGISTER case (line 482). 'regs' is a SWF_ACTIONPUSHPARAM*[256] array initialized in decompileSTOREREGISTER (util/decompile.c:1639) and decompileTRY (util/decompile.c:2722). 'act->p.RegisterNumber' is set via readUInt8(f) in parseSWF_ACTIONRECORD (util/parser.c:987), which directly parses SWF input. If a PUSH_REGISTER action specifies an uninitialized register index, 'regs[RegisterNumber]' is NULL, causing a dereference.",0.95,./github/other_context/CVE-2018-9132
27,CVE-2016-9438,CWE-476,c_cpp,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.,https://github.com/tats/w3m/commit/010b68580dc50ce183df11cc79721936ab5c4f25,Prevent segfault with malformed input_alt\n\nBug-Debian: https://github.com/tats/w3m/issues/18,1,"[{""func_name"": ""flushline"", ""file_path"": ""file.c"", ""func_code"": ""void\nflushline(struct html_feed_environ *h_env, struct readbuffer *obuf, int indent,\n\t  int force, int width)\n{\n    TextLineList *buf = h_env->buf;\n    FILE *f = h_env->f;\n    Str line = obuf->line, pass = NULL;\n    char *hidden_anchor = NULL, *hidden_img = NULL, *hidden_bold = NULL,\n\t*hidden_under = NULL, *hidden_italic = NULL, *hidden_strike = NULL,\n\t*hidden_ins = NULL, *hidden_input = NULL, *hidden = NULL;\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *df = fopen(\""zzzproc1\"", \""a\"");\n\tfprintf(df, \""flushline(%s,%d,%d,%d)\\n\"", obuf->line->ptr, indent, force,\n\t\twidth);\n\tif (buf) {\n\t    TextLineListItem *p;\n\t    for (p = buf->first; p; p = p->next) {\n\t\tfprintf(df, \""buf=\\\""%s\\\""\\n\"", p->ptr->line->ptr);\n\t    }\n\t}\n\tfclose(df);\n    }\n#endif\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && Strlastchar(line) == ' ') {\n\tStrshrink(line, 1);\n\tobuf->pos--;\n    }\n\n    append_tags(obuf);\n\n    if (obuf->anchor.url)\n\thidden = hidden_anchor = has_hidden_link(obuf, HTML_A);\n    if (obuf->img_alt) {\n\tif ((hidden_img = has_hidden_link(obuf, HTML_IMG_ALT)) != NULL) {\n\t    if (!hidden || hidden_img < hidden)\n\t\thidden = hidden_img;\n\t}\n    }\n    if (obuf->input_alt.in) {\n\tif ((hidden_input = has_hidden_link(obuf, HTML_INPUT_ALT)) != NULL) {\n\t    if (!hidden || hidden_input < hidden)\n\t\thidden = hidden_input;\n\t}\n    }\n    if (obuf->in_bold) {\n\tif ((hidden_bold = has_hidden_link(obuf, HTML_B)) != NULL) {\n\t    if (!hidden || hidden_bold < hidden)\n\t\thidden = hidden_bold;\n\t}\n    }\n    if (obuf->in_italic) {\n\tif ((hidden_italic = has_hidden_link(obuf, HTML_I)) != NULL) {\n\t    if (!hidden || hidden_italic < hidden)\n\t\thidden = hidden_italic;\n\t}\n    }\n    if (obuf->in_under) {\n\tif ((hidden_under = has_hidden_link(obuf, HTML_U)) != NULL) {\n\t    if (!hidden || hidden_under < hidden)\n\t\thidden = hidden_under;\n\t}\n    }\n    if (obuf->in_strike) {\n\tif ((hidden_strike = has_hidden_link(obuf, HTML_S)) != NULL) {\n\t    if (!hidden || hidden_strike < hidden)\n\t\thidden = hidden_strike;\n\t}\n    }\n    if (obuf->in_ins) {\n\tif ((hidden_ins = has_hidden_link(obuf, HTML_INS)) != NULL) {\n\t    if (!hidden || hidden_ins < hidden)\n\t\thidden = hidden_ins;\n\t}\n    }\n    if (hidden) {\n\tpass = Strnew_charp(hidden);\n\tStrshrink(line, line->ptr + line->length - hidden);\n    }\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && obuf->pos > width) {\n\tchar *tp = &line->ptr[obuf->bp.len - obuf->bp.tlen];\n\tchar *ep = &line->ptr[line->length];\n\n\tif (obuf->bp.pos == obuf->pos && tp <= ep &&\n\t    tp > line->ptr && tp[-1] == ' ') {\n\t    bcopy(tp, tp - 1, ep - tp + 1);\n\t    line->length--;\n\t    obuf->pos--;\n\t}\n    }\n\n    if (obuf->anchor.url && !hidden_anchor)\n\tStrcat_charp(line, \""</a>\"");\n    if (obuf->img_alt && !hidden_img)\n\tStrcat_charp(line, \""</img_alt>\"");\n    if (obuf->input_alt.in && !hidden_input)\n\tStrcat_charp(line, \""</input_alt>\"");\n    if (obuf->in_bold && !hidden_bold)\n\tStrcat_charp(line, \""</b>\"");\n    if (obuf->in_italic && !hidden_italic)\n\tStrcat_charp(line, \""</i>\"");\n    if (obuf->in_under && !hidden_under)\n\tStrcat_charp(line, \""</u>\"");\n    if (obuf->in_strike && !hidden_strike)\n\tStrcat_charp(line, \""</s>\"");\n    if (obuf->in_ins && !hidden_ins)\n\tStrcat_charp(line, \""</ins>\"");\n\n    if (obuf->top_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \""<pre_int>\"");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \""</pre_int>\"");\n\tfor (i = 0; i < obuf->top_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n\n    if (force == 1 || obuf->flag & RB_NFLUSHED) {\n\tTextLine *lbuf = newTextLine(line, obuf->pos);\n\tif (RB_GET_ALIGN(obuf) == RB_CENTER) {\n\t    align(lbuf, width, ALIGN_CENTER);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_RIGHT) {\n\t    align(lbuf, width, ALIGN_RIGHT);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_LEFT && obuf->flag & RB_INTABLE) {\n\t    align(lbuf, width, ALIGN_LEFT);\n\t}\n#ifdef FORMAT_NICE\n\telse if (obuf->flag & RB_FILL) {\n\t    char *p;\n\t    int rest, rrest;\n\t    int nspace, d, i;\n\n\t    rest = width - get_Str_strwidth(line);\n\t    if (rest > 1) {\n\t\tnspace = 0;\n\t\tfor (p = line->ptr + indent; *p; p++) {\n\t\t    if (*p == ' ')\n\t\t\tnspace++;\n\t\t}\n\t\tif (nspace > 0) {\n\t\t    int indent_here = 0;\n\t\t    d = rest / nspace;\n\t\t    p = line->ptr;\n\t\t    while (IS_SPACE(*p)) {\n\t\t\tp++;\n\t\t\tindent_here++;\n\t\t    }\n\t\t    rrest = rest - d * nspace;\n\t\t    line = Strnew_size(width + 1);\n\t\t    for (i = 0; i < indent_here; i++)\n\t\t\tStrcat_char(line, ' ');\n\t\t    for (; *p; p++) {\n\t\t\tStrcat_char(line, *p);\n\t\t\tif (*p == ' ') {\n\t\t\t    for (i = 0; i < d; i++)\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t    if (rrest > 0) {\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t\trrest--;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    lbuf = newTextLine(line, width);\n\t\t}\n\t    }\n\t}\n#endif\t\t\t\t/* FORMAT_NICE */\n#ifdef TABLE_DEBUG\n\tif (w3m_debug) {\n\t    FILE *f = fopen(\""zzzproc1\"", \""a\"");\n\t    fprintf(f, \""pos=%d,%d, maxlimit=%d\\n\"",\n\t\t    visible_length(lbuf->line->ptr), lbuf->pos,\n\t\t    h_env->maxlimit);\n\t    fclose(f);\n\t}\n#endif\n\tif (lbuf->pos > h_env->maxlimit)\n\t    h_env->maxlimit = lbuf->pos;\n\tif (buf)\n\t    pushTextLine(buf, lbuf);\n\telse if (f) {\n\t    Strfputs(Str_conv_to_halfdump(lbuf->line), f);\n\t    fputc('\\n', f);\n\t}\n\tif (obuf->flag & RB_SPECIAL || obuf->flag & RB_NFLUSHED)\n\t    h_env->blank_lines = 0;\n\telse\n\t    h_env->blank_lines++;\n    }\n    else {\n\tchar *p = line->ptr, *q;\n\tStr tmp = Strnew(), tmp2 = Strnew();\n\n#define APPEND(str) \\\n\tif (buf) \\\n\t    appendTextLine(buf,(str),0); \\\n\telse if (f) \\\n\t    Strfputs((str),f)\n\n\twhile (*p) {\n\t    q = p;\n\t    if (sloppy_parse_line(&p)) {\n\t\tStrcat_charp_n(tmp, q, p - q);\n\t\tif (force == 2) {\n\t\t    APPEND(tmp);\n\t\t}\n\t\telse\n\t\t    Strcat(tmp2, tmp);\n\t\tStrclear(tmp);\n\t    }\n\t}\n\tif (force == 2) {\n\t    if (pass) {\n\t\tAPPEND(pass);\n\t    }\n\t    pass = NULL;\n\t}\n\telse {\n\t    if (pass)\n\t\tStrcat(tmp2, pass);\n\t    pass = tmp2;\n\t}\n    }\n\n    if (obuf->bottom_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \""<pre_int>\"");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \""</pre_int>\"");\n\tfor (i = 0; i < obuf->bottom_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n    if (obuf->top_margin < 0 || obuf->bottom_margin < 0)\n\treturn;\n\n    obuf->line = Strnew_size(256);\n    obuf->pos = 0;\n    obuf->top_margin = 0;\n    obuf->bottom_margin = 0;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->bp.init_flag = 1;\n    obuf->flag &= ~RB_NFLUSHED;\n    set_breakpoint(obuf, 0);\n    obuf->prev_ctype = PC_ASCII;\n    link_stack = NULL;\n    fillline(obuf, indent);\n    if (pass)\n\tpassthrough(obuf, pass->ptr, 0);\n    if (!hidden_anchor && obuf->anchor.url) {\n\tStr tmp;\n\tif (obuf->anchor.hseq > 0)\n\t    obuf->anchor.hseq = -obuf->anchor.hseq;\n\ttmp = Sprintf(\""<A HSEQ=\\\""%d\\\"" HREF=\\\""\"", obuf->anchor.hseq);\n\tStrcat_charp(tmp, html_quote(obuf->anchor.url));\n\tif (obuf->anchor.target) {\n\t    Strcat_charp(tmp, \""\\\"" TARGET=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.target));\n\t}\n\tif (obuf->anchor.referer) {\n\t    Strcat_charp(tmp, \""\\\"" REFERER=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.referer));\n\t}\n\tif (obuf->anchor.title) {\n\t    Strcat_charp(tmp, \""\\\"" TITLE=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.title));\n\t}\n\tif (obuf->anchor.accesskey) {\n\t    char *c = html_quote_char(obuf->anchor.accesskey);\n\t    Strcat_charp(tmp, \""\\\"" ACCESSKEY=\\\""\"");\n\t    if (c)\n\t\tStrcat_charp(tmp, c);\n\t    else\n\t\tStrcat_char(tmp, obuf->anchor.accesskey);\n\t}\n\tStrcat_charp(tmp, \""\\\"">\"");\n\tpush_tag(obuf, tmp->ptr, HTML_A);\n    }\n    if (!hidden_img && obuf->img_alt) {\n\tStr tmp = Strnew_charp(\""<IMG_ALT SRC=\\\""\"");\n\tStrcat_charp(tmp, html_quote(obuf->img_alt->ptr));\n\tStrcat_charp(tmp, \""\\\"">\"");\n\tpush_tag(obuf, tmp->ptr, HTML_IMG_ALT);\n    }\n    if (!hidden_input && obuf->input_alt.in) {\n\tStr tmp;\n\tif (obuf->input_alt.hseq > 0)\n\t    obuf->input_alt.hseq = - obuf->input_alt.hseq;\n\ttmp = Sprintf(\""<INPUT_ALT hseq=\\\""%d\\\"" fid=\\\""%d\\\"" name=\\\""%s\\\"" type=\\\""%s\\\"" value=\\\""%s\\\"">\"",\n\t\t     obuf->input_alt.hseq,\n\t\t     obuf->input_alt.fid,\n\t\t     obuf->input_alt.name->ptr,\n\t\t     obuf->input_alt.type->ptr,\n\t\t     obuf->input_alt.value->ptr);\n\tpush_tag(obuf, tmp->ptr, HTML_INPUT_ALT);\n    }\n    if (!hidden_bold && obuf->in_bold)\n\tpush_tag(obuf, \""<B>\"", HTML_B);\n    if (!hidden_italic && obuf->in_italic)\n\tpush_tag(obuf, \""<I>\"", HTML_I);\n    if (!hidden_under && obuf->in_under)\n\tpush_tag(obuf, \""<U>\"", HTML_U);\n    if (!hidden_strike && obuf->in_strike)\n\tpush_tag(obuf, \""<S>\"", HTML_S);\n    if (!hidden_ins && obuf->in_ins)\n\tpush_tag(obuf, \""<INS>\"", HTML_INS);\n}"", ""target"": 0}]","[{""func_name"": ""flushline"", ""file_path"": ""file.c"", ""func_code"": ""void\nflushline(struct html_feed_environ *h_env, struct readbuffer *obuf, int indent,\n\t  int force, int width)\n{\n    TextLineList *buf = h_env->buf;\n    FILE *f = h_env->f;\n    Str line = obuf->line, pass = NULL;\n    char *hidden_anchor = NULL, *hidden_img = NULL, *hidden_bold = NULL,\n\t*hidden_under = NULL, *hidden_italic = NULL, *hidden_strike = NULL,\n\t*hidden_ins = NULL, *hidden_input = NULL, *hidden = NULL;\n\n#ifdef DEBUG\n    if (w3m_debug) {\n\tFILE *df = fopen(\""zzzproc1\"", \""a\"");\n\tfprintf(df, \""flushline(%s,%d,%d,%d)\\n\"", obuf->line->ptr, indent, force,\n\t\twidth);\n\tif (buf) {\n\t    TextLineListItem *p;\n\t    for (p = buf->first; p; p = p->next) {\n\t\tfprintf(df, \""buf=\\\""%s\\\""\\n\"", p->ptr->line->ptr);\n\t    }\n\t}\n\tfclose(df);\n    }\n#endif\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && Strlastchar(line) == ' ') {\n\tStrshrink(line, 1);\n\tobuf->pos--;\n    }\n\n    append_tags(obuf);\n\n    if (obuf->anchor.url)\n\thidden = hidden_anchor = has_hidden_link(obuf, HTML_A);\n    if (obuf->img_alt) {\n\tif ((hidden_img = has_hidden_link(obuf, HTML_IMG_ALT)) != NULL) {\n\t    if (!hidden || hidden_img < hidden)\n\t\thidden = hidden_img;\n\t}\n    }\n    if (obuf->input_alt.in) {\n\tif ((hidden_input = has_hidden_link(obuf, HTML_INPUT_ALT)) != NULL) {\n\t    if (!hidden || hidden_input < hidden)\n\t\thidden = hidden_input;\n\t}\n    }\n    if (obuf->in_bold) {\n\tif ((hidden_bold = has_hidden_link(obuf, HTML_B)) != NULL) {\n\t    if (!hidden || hidden_bold < hidden)\n\t\thidden = hidden_bold;\n\t}\n    }\n    if (obuf->in_italic) {\n\tif ((hidden_italic = has_hidden_link(obuf, HTML_I)) != NULL) {\n\t    if (!hidden || hidden_italic < hidden)\n\t\thidden = hidden_italic;\n\t}\n    }\n    if (obuf->in_under) {\n\tif ((hidden_under = has_hidden_link(obuf, HTML_U)) != NULL) {\n\t    if (!hidden || hidden_under < hidden)\n\t\thidden = hidden_under;\n\t}\n    }\n    if (obuf->in_strike) {\n\tif ((hidden_strike = has_hidden_link(obuf, HTML_S)) != NULL) {\n\t    if (!hidden || hidden_strike < hidden)\n\t\thidden = hidden_strike;\n\t}\n    }\n    if (obuf->in_ins) {\n\tif ((hidden_ins = has_hidden_link(obuf, HTML_INS)) != NULL) {\n\t    if (!hidden || hidden_ins < hidden)\n\t\thidden = hidden_ins;\n\t}\n    }\n    if (hidden) {\n\tpass = Strnew_charp(hidden);\n\tStrshrink(line, line->ptr + line->length - hidden);\n    }\n\n    if (!(obuf->flag & (RB_SPECIAL & ~RB_NOBR)) && obuf->pos > width) {\n\tchar *tp = &line->ptr[obuf->bp.len - obuf->bp.tlen];\n\tchar *ep = &line->ptr[line->length];\n\n\tif (obuf->bp.pos == obuf->pos && tp <= ep &&\n\t    tp > line->ptr && tp[-1] == ' ') {\n\t    bcopy(tp, tp - 1, ep - tp + 1);\n\t    line->length--;\n\t    obuf->pos--;\n\t}\n    }\n\n    if (obuf->anchor.url && !hidden_anchor)\n\tStrcat_charp(line, \""</a>\"");\n    if (obuf->img_alt && !hidden_img)\n\tStrcat_charp(line, \""</img_alt>\"");\n    if (obuf->input_alt.in && !hidden_input)\n\tStrcat_charp(line, \""</input_alt>\"");\n    if (obuf->in_bold && !hidden_bold)\n\tStrcat_charp(line, \""</b>\"");\n    if (obuf->in_italic && !hidden_italic)\n\tStrcat_charp(line, \""</i>\"");\n    if (obuf->in_under && !hidden_under)\n\tStrcat_charp(line, \""</u>\"");\n    if (obuf->in_strike && !hidden_strike)\n\tStrcat_charp(line, \""</s>\"");\n    if (obuf->in_ins && !hidden_ins)\n\tStrcat_charp(line, \""</ins>\"");\n\n    if (obuf->top_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \""<pre_int>\"");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \""</pre_int>\"");\n\tfor (i = 0; i < obuf->top_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n\n    if (force == 1 || obuf->flag & RB_NFLUSHED) {\n\tTextLine *lbuf = newTextLine(line, obuf->pos);\n\tif (RB_GET_ALIGN(obuf) == RB_CENTER) {\n\t    align(lbuf, width, ALIGN_CENTER);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_RIGHT) {\n\t    align(lbuf, width, ALIGN_RIGHT);\n\t}\n\telse if (RB_GET_ALIGN(obuf) == RB_LEFT && obuf->flag & RB_INTABLE) {\n\t    align(lbuf, width, ALIGN_LEFT);\n\t}\n#ifdef FORMAT_NICE\n\telse if (obuf->flag & RB_FILL) {\n\t    char *p;\n\t    int rest, rrest;\n\t    int nspace, d, i;\n\n\t    rest = width - get_Str_strwidth(line);\n\t    if (rest > 1) {\n\t\tnspace = 0;\n\t\tfor (p = line->ptr + indent; *p; p++) {\n\t\t    if (*p == ' ')\n\t\t\tnspace++;\n\t\t}\n\t\tif (nspace > 0) {\n\t\t    int indent_here = 0;\n\t\t    d = rest / nspace;\n\t\t    p = line->ptr;\n\t\t    while (IS_SPACE(*p)) {\n\t\t\tp++;\n\t\t\tindent_here++;\n\t\t    }\n\t\t    rrest = rest - d * nspace;\n\t\t    line = Strnew_size(width + 1);\n\t\t    for (i = 0; i < indent_here; i++)\n\t\t\tStrcat_char(line, ' ');\n\t\t    for (; *p; p++) {\n\t\t\tStrcat_char(line, *p);\n\t\t\tif (*p == ' ') {\n\t\t\t    for (i = 0; i < d; i++)\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t    if (rrest > 0) {\n\t\t\t\tStrcat_char(line, ' ');\n\t\t\t\trrest--;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    lbuf = newTextLine(line, width);\n\t\t}\n\t    }\n\t}\n#endif\t\t\t\t/* FORMAT_NICE */\n#ifdef TABLE_DEBUG\n\tif (w3m_debug) {\n\t    FILE *f = fopen(\""zzzproc1\"", \""a\"");\n\t    fprintf(f, \""pos=%d,%d, maxlimit=%d\\n\"",\n\t\t    visible_length(lbuf->line->ptr), lbuf->pos,\n\t\t    h_env->maxlimit);\n\t    fclose(f);\n\t}\n#endif\n\tif (lbuf->pos > h_env->maxlimit)\n\t    h_env->maxlimit = lbuf->pos;\n\tif (buf)\n\t    pushTextLine(buf, lbuf);\n\telse if (f) {\n\t    Strfputs(Str_conv_to_halfdump(lbuf->line), f);\n\t    fputc('\\n', f);\n\t}\n\tif (obuf->flag & RB_SPECIAL || obuf->flag & RB_NFLUSHED)\n\t    h_env->blank_lines = 0;\n\telse\n\t    h_env->blank_lines++;\n    }\n    else {\n\tchar *p = line->ptr, *q;\n\tStr tmp = Strnew(), tmp2 = Strnew();\n\n#define APPEND(str) \\\n\tif (buf) \\\n\t    appendTextLine(buf,(str),0); \\\n\telse if (f) \\\n\t    Strfputs((str),f)\n\n\twhile (*p) {\n\t    q = p;\n\t    if (sloppy_parse_line(&p)) {\n\t\tStrcat_charp_n(tmp, q, p - q);\n\t\tif (force == 2) {\n\t\t    APPEND(tmp);\n\t\t}\n\t\telse\n\t\t    Strcat(tmp2, tmp);\n\t\tStrclear(tmp);\n\t    }\n\t}\n\tif (force == 2) {\n\t    if (pass) {\n\t\tAPPEND(pass);\n\t    }\n\t    pass = NULL;\n\t}\n\telse {\n\t    if (pass)\n\t\tStrcat(tmp2, pass);\n\t    pass = tmp2;\n\t}\n    }\n\n    if (obuf->bottom_margin > 0) {\n\tint i;\n\tstruct html_feed_environ h;\n\tstruct readbuffer o;\n\tstruct environment e[1];\n\n\tinit_henv(&h, &o, e, 1, NULL, width, indent);\n\to.line = Strnew_size(width + 20);\n\to.pos = obuf->pos;\n\to.flag = obuf->flag;\n\to.top_margin = -1;\n\to.bottom_margin = -1;\n\tStrcat_charp(o.line, \""<pre_int>\"");\n\tfor (i = 0; i < o.pos; i++)\n\t    Strcat_char(o.line, ' ');\n\tStrcat_charp(o.line, \""</pre_int>\"");\n\tfor (i = 0; i < obuf->bottom_margin; i++)\n\t    flushline(h_env, &o, indent, force, width);\n    }\n    if (obuf->top_margin < 0 || obuf->bottom_margin < 0)\n\treturn;\n\n    obuf->line = Strnew_size(256);\n    obuf->pos = 0;\n    obuf->top_margin = 0;\n    obuf->bottom_margin = 0;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->bp.init_flag = 1;\n    obuf->flag &= ~RB_NFLUSHED;\n    set_breakpoint(obuf, 0);\n    obuf->prev_ctype = PC_ASCII;\n    link_stack = NULL;\n    fillline(obuf, indent);\n    if (pass)\n\tpassthrough(obuf, pass->ptr, 0);\n    if (!hidden_anchor && obuf->anchor.url) {\n\tStr tmp;\n\tif (obuf->anchor.hseq > 0)\n\t    obuf->anchor.hseq = -obuf->anchor.hseq;\n\ttmp = Sprintf(\""<A HSEQ=\\\""%d\\\"" HREF=\\\""\"", obuf->anchor.hseq);\n\tStrcat_charp(tmp, html_quote(obuf->anchor.url));\n\tif (obuf->anchor.target) {\n\t    Strcat_charp(tmp, \""\\\"" TARGET=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.target));\n\t}\n\tif (obuf->anchor.referer) {\n\t    Strcat_charp(tmp, \""\\\"" REFERER=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.referer));\n\t}\n\tif (obuf->anchor.title) {\n\t    Strcat_charp(tmp, \""\\\"" TITLE=\\\""\"");\n\t    Strcat_charp(tmp, html_quote(obuf->anchor.title));\n\t}\n\tif (obuf->anchor.accesskey) {\n\t    char *c = html_quote_char(obuf->anchor.accesskey);\n\t    Strcat_charp(tmp, \""\\\"" ACCESSKEY=\\\""\"");\n\t    if (c)\n\t\tStrcat_charp(tmp, c);\n\t    else\n\t\tStrcat_char(tmp, obuf->anchor.accesskey);\n\t}\n\tStrcat_charp(tmp, \""\\\"">\"");\n\tpush_tag(obuf, tmp->ptr, HTML_A);\n    }\n    if (!hidden_img && obuf->img_alt) {\n\tStr tmp = Strnew_charp(\""<IMG_ALT SRC=\\\""\"");\n\tStrcat_charp(tmp, html_quote(obuf->img_alt->ptr));\n\tStrcat_charp(tmp, \""\\\"">\"");\n\tpush_tag(obuf, tmp->ptr, HTML_IMG_ALT);\n    }\n    if (!hidden_input && obuf->input_alt.in) {\n\tStr tmp;\n\tif (obuf->input_alt.hseq > 0)\n\t    obuf->input_alt.hseq = - obuf->input_alt.hseq;\n\ttmp = Sprintf(\""<INPUT_ALT hseq=\\\""%d\\\"" fid=\\\""%d\\\"" name=\\\""%s\\\"" type=\\\""%s\\\"" value=\\\""%s\\\"">\"",\n\t\t     obuf->input_alt.hseq,\n\t\t     obuf->input_alt.fid,\n\t\t     obuf->input_alt.name ? obuf->input_alt.name->ptr : \""\"",\n\t\t     obuf->input_alt.type ? obuf->input_alt.type->ptr : \""\"",\n\t\t     obuf->input_alt.value ? obuf->input_alt.value->ptr : \""\"");\n\tpush_tag(obuf, tmp->ptr, HTML_INPUT_ALT);\n    }\n    if (!hidden_bold && obuf->in_bold)\n\tpush_tag(obuf, \""<B>\"", HTML_B);\n    if (!hidden_italic && obuf->in_italic)\n\tpush_tag(obuf, \""<I>\"", HTML_I);\n    if (!hidden_under && obuf->in_under)\n\tpush_tag(obuf, \""<U>\"", HTML_U);\n    if (!hidden_strike && obuf->in_strike)\n\tpush_tag(obuf, \""<S>\"", HTML_S);\n    if (!hidden_ins && obuf->in_ins)\n\tpush_tag(obuf, \""<INS>\"", HTML_INS);\n}""}]","{""value"": 2, ""function"": 1, ""query"": 3}","[{""source"": ""value_info(file:file.c, value:obuf->input_alt)"", ""result"": {""value_trace"": [{""full_code"": ""obuf->input_alt = obuf->bp.input_alt"", ""line"": 2476, ""func_name"": ""back_to_breakpoint""}], ""struct_var"": ""obuf"", ""struct_type"": ""readbuffer*"", ""struct_definition"": ""struct readbuffer {\n    Str line;\n    Lineprop cprop;\n    short pos;\n    Str prevchar;\n    long flag;\n    long flag_stack[RB_STACK_SIZE];\n    int flag_sp;\n    int status;\n    unsigned char end_tag;\n    short table_level;\n    short nobr_level;\n    Anchor anchor;\n    Str img_alt;\n    struct input_alt_attr input_alt;\n    char fontstat[FONTSTAT_SIZE];\n    char fontstat_stack[FONT_STACK_SIZE][FONTSTAT_SIZE];\n    int fontstat_sp;\n    Lineprop prev_ctype;\n    Breakpoint bp;\n    struct cmdtable *tag_stack[TAG_STACK_SIZE];\n    int tag_sp;\n    short top_margin;\n    short bottom_margin;\n}\n\nstruct readbuffer""}}, {""source"": ""value_info(value:input_alt)"", ""result"": {""value_trace"": [{""full_code"": ""obuf->bp.input_alt = obuf->input_alt"", ""line"": 2458, ""func_name"": ""set_breakpoint""}, {""full_code"": ""obuf->input_alt = obuf->bp.input_alt"", ""line"": 2476, ""func_name"": ""back_to_breakpoint""}, {""full_code"": ""obuf->input_alt.hseq = - obuf->input_alt.hseq"", ""line"": 3024, ""func_name"": ""flushline""}, {""full_code"": ""obuf->input_alt.hseq = hseq"", ""line"": 4952, ""func_name"": ""HTMLtagproc1""}, {""full_code"": ""obuf->input_alt.fid = i"", ""line"": 4955, ""func_name"": ""HTMLtagproc1""}], ""struct_var"": ""input_alt"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:HTMLtagproc1)"", ""result"": [{""code"": ""int\nHTMLtagproc1(struct parsed_tag *tag, struct html_feed_environ *h_env)\n{\n    char *p, *q, *r;\n    int i, w, x, y, z, count, width;\n    struct readbuffer *obuf = h_env->obuf;\n    struct environment *envs = h_env->envs;\n    Str tmp;\n    int hseq;\n    int cmd;\n#ifdef ID_EXT\n    char *id = NULL;\n#endif\t\t\t\t/* ID_EXT */\n\n    cmd = tag->tagid;\n\n    if (obuf->flag & RB_PRE) {\n\tswitch (cmd) {\n\tcase HTML_NOBR:\n\tcase HTML_N_NOBR:\n\tcase HTML_PRE_INT:\n\tcase HTML_N_PRE_INT:\n\t    return 1;\n\t}\n    }\n\n    switch (cmd) {\n    case HTML_B:\n\tobuf->in_bold++;\n\tif (obuf->in_bold > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_B:\n\tif (obuf->in_bold == 1 && close_effect0(obuf, HTML_B))\n\t    obuf->in_bold = 0;\n\tif (obuf->in_bold > 0) {\n\t    obuf->in_bold--;\n\t    if (obuf->in_bold == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_I:\n\tobuf->in_italic++;\n\tif (obuf->in_italic > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_I:\n\tif (obuf->in_italic == 1 && close_effect0(obuf, HTML_I))\n\t    obuf->in_italic = 0;\n\tif (obuf->in_italic > 0) {\n\t    obuf->in_italic--;\n\t    if (obuf->in_italic == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_U:\n\tobuf->in_under++;\n\tif (obuf->in_under > 1)\n\t    return 1;\n\treturn 0;\n    case HTML_N_U:\n\tif (obuf->in_under == 1 && close_effect0(obuf, HTML_U))\n\t    obuf->in_under = 0;\n\tif (obuf->in_under > 0) {\n\t    obuf->in_under--;\n\t    if (obuf->in_under == 0)\n\t\treturn 0;\n\t}\n\treturn 1;\n    case HTML_EM:\n\tHTMLlineproc1(\""<i>\"", h_env);\n\treturn 1;\n    case HTML_N_EM:\n\tHTMLlineproc1(\""</i>\"", h_env);\n\treturn 1;\n    case HTML_STRONG:\n\tHTMLlineproc1(\""<b>\"", h_env);\n\treturn 1;\n    case HTML_N_STRONG:\n\tHTMLlineproc1(\""</b>\"", h_env);\n\treturn 1;\n    case HTML_Q:\n\tHTMLlineproc1(\""`\"", h_env);\n\treturn 1;\n    case HTML_N_Q:\n\tHTMLlineproc1(\""'\"", h_env);\n\treturn 1;\n    case HTML_P:\n    case HTML_N_P:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 1, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\tif (cmd == HTML_P) {\n\t    set_alignment(obuf, tag);\n\t    obuf->flag |= RB_P;\n\t}\n\treturn 1;\n    case HTML_BR:\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 1, h_env->limit);\n\th_env->blank_lines = 0;\n\treturn 1;\n    case HTML_H:\n\tif (!(obuf->flag & (RB_PREMODE | RB_IGNORE_P))) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tHTMLlineproc1(\""<b>\"", h_env);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_H:\n\tHTMLlineproc1(\""</b>\"", h_env);\n\tif (!(obuf->flag & RB_PREMODE)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t}\n\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\tclose_anchor(h_env, obuf);\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_UL:\n    case HTML_OL:\n    case HTML_BLQ:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!(obuf->flag & RB_PREMODE) &&\n\t\t(h_env->envc == 0 || cmd == HTML_BLQ))\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\tPUSH_ENV(cmd);\n\tif (cmd == HTML_UL || cmd == HTML_OL) {\n\t    if (parsedtag_get_value(tag, ATTR_START, &count)) {\n\t\tenvs[h_env->envc].count = count - 1;\n\t    }\n\t}\n\tif (cmd == HTML_OL) {\n\t    envs[h_env->envc].type = '1';\n\t    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\t\tenvs[h_env->envc].type = (int)*p;\n\t    }\n\t}\n\tif (cmd == HTML_UL)\n\t    envs[h_env->envc].type = ul_type(tag, 0);\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 1;\n    case HTML_N_UL:\n    case HTML_N_OL:\n    case HTML_N_DL:\n    case HTML_N_BLQ:\n\tCLOSE_DT;\n\tCLOSE_A;\n\tif (h_env->envc > 0) {\n\t    flushline(h_env, obuf, envs[h_env->envc - 1].indent, 0,\n\t\t      h_env->limit);\n\t    POP_ENV;\n\t    if (!(obuf->flag & RB_PREMODE) &&\n\t\t(h_env->envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ)) {\n\t\tdo_blankline(h_env, obuf,\n\t\t\t     envs[h_env->envc].indent,\n\t\t\t     INDENT_INCR, h_env->limit);\n\t\tobuf->flag |= RB_IGNORE_P;\n\t    }\n\t}\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_DL:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!(obuf->flag & RB_PREMODE))\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\tPUSH_ENV(cmd);\n\tif (parsedtag_exists(tag, ATTR_COMPACT))\n\t    envs[h_env->envc].env = HTML_DL_COMPACT;\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_LI:\n\tCLOSE_A;\n\tCLOSE_DT;\n\tif (h_env->envc > 0) {\n\t    Str num;\n\t    flushline(h_env, obuf,\n\t\t      envs[h_env->envc - 1].indent, 0, h_env->limit);\n\t    envs[h_env->envc].count++;\n\t    if (parsedtag_get_value(tag, ATTR_VALUE, &p)) {\n\t\tcount = atoi(p);\n\t\tif (count > 0)\n\t\t    envs[h_env->envc].count = count;\n\t\telse\n\t\t    envs[h_env->envc].count = 0;\n\t    }\n\t    switch (envs[h_env->envc].env) {\n\t    case HTML_UL:\n\t\tenvs[h_env->envc].type = ul_type(tag, envs[h_env->envc].type);\n\t\tfor (i = 0; i < INDENT_INCR - 3; i++)\n\t\t    push_charp(obuf, 1, NBSP, PC_ASCII);\n\t\ttmp = Strnew();\n\t\tswitch (envs[h_env->envc].type) {\n\t\tcase 'd':\n\t\t    push_symbol(tmp, UL_SYMBOL_DISC, symbol_width, 1);\n\t\t    break;\n\t\tcase 'c':\n\t\t    push_symbol(tmp, UL_SYMBOL_CIRCLE, symbol_width, 1);\n\t\t    break;\n\t\tcase 's':\n\t\t    push_symbol(tmp, UL_SYMBOL_SQUARE, symbol_width, 1);\n\t\t    break;\n\t\tdefault:\n\t\t    push_symbol(tmp,\n\t\t\t\tUL_SYMBOL((h_env->envc_real -\n\t\t\t\t\t   1) % MAX_UL_LEVEL), symbol_width,\n\t\t\t\t1);\n\t\t    break;\n\t\t}\n\t\tif (symbol_width == 1)\n\t\t    push_charp(obuf, 1, NBSP, PC_ASCII);\n\t\tpush_str(obuf, symbol_width, tmp, PC_ASCII);\n\t\tpush_charp(obuf, 1, NBSP, PC_ASCII);\n\t\tset_space_to_prevchar(obuf->prevchar);\n\t\tbreak;\n\t    case HTML_OL:\n\t\tif (parsedtag_get_value(tag, ATTR_TYPE, &p))\n\t\t    envs[h_env->envc].type = (int)*p;\n\t\tswitch ((envs[h_env->envc].count > 0)? envs[h_env->envc].type: '1') {\n\t\tcase 'i':\n\t\t    num = romanNumeral(envs[h_env->envc].count);\n\t\t    break;\n\t\tcase 'I':\n\t\t    num = romanNumeral(envs[h_env->envc].count);\n\t\t    Strupper(num);\n\t\t    break;\n\t\tcase 'a':\n\t\t    num = romanAlphabet(envs[h_env->envc].count);\n\t\t    break;\n\t\tcase 'A':\n\t\t    num = romanAlphabet(envs[h_env->envc].count);\n\t\t    Strupper(num);\n\t\t    break;\n\t\tdefault:\n\t\t    num = Sprintf(\""%d\"", envs[h_env->envc].count);\n\t\t    break;\n\t\t}\n\t\tif (INDENT_INCR >= 4)\n\t\t    Strcat_charp(num, \"". \"");\n\t\telse\n\t\t    Strcat_char(num, '.');\n\t\tpush_spaces(obuf, 1, INDENT_INCR - num->length);\n\t\tpush_str(obuf, num->length, num, PC_ASCII);\n\t\tif (INDENT_INCR >= 4)\n\t\t    set_space_to_prevchar(obuf->prevchar);\n\t\tbreak;\n\t    default:\n\t\tpush_spaces(obuf, 1, INDENT_INCR);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    flushline(h_env, obuf, 0, 0, h_env->limit);\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_DT:\n\tCLOSE_A;\n\tif (h_env->envc == 0 ||\n\t    (h_env->envc_real < h_env->nenv &&\n\t     envs[h_env->envc].env != HTML_DL &&\n\t     envs[h_env->envc].env != HTML_DL_COMPACT)) {\n\t    PUSH_ENV(HTML_DL);\n\t}\n\tif (h_env->envc > 0) {\n\t    flushline(h_env, obuf,\n\t\t      envs[h_env->envc - 1].indent, 0, h_env->limit);\n\t}\n\tif (!(obuf->flag & RB_IN_DT)) {\n\t    HTMLlineproc1(\""<b>\"", h_env);\n\t    obuf->flag |= RB_IN_DT;\n\t}\n\tobuf->flag |= RB_IGNORE_P;\n\treturn 1;\n    case HTML_DD:\n\tCLOSE_A;\n\tCLOSE_DT;\n\tif (envs[h_env->envc].env == HTML_DL_COMPACT) {\n\t    if (obuf->pos > envs[h_env->envc].indent)\n\t\tflushline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t  h_env->limit);\n\t    else\n\t\tpush_spaces(obuf, 1, envs[h_env->envc].indent - obuf->pos);\n\t}\n\telse\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t/* obuf->flag |= RB_IGNORE_P; */\n\treturn 1;\n    case HTML_TITLE:\n\tclose_anchor(h_env, obuf);\n\tprocess_title(tag);\n\tobuf->flag |= RB_TITLE;\n\tobuf->end_tag = HTML_N_TITLE;\n\treturn 1;\n    case HTML_N_TITLE:\n\tif (!(obuf->flag & RB_TITLE))\n\t    return 1;\n\tobuf->flag &= ~RB_TITLE;\n\tobuf->end_tag = 0;\n\ttmp = process_n_title(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_TITLE_ALT:\n\tif (parsedtag_get_value(tag, ATTR_TITLE, &p))\n\t    h_env->title = html_unquote(p);\n\treturn 0;\n    case HTML_FRAMESET:\n\tPUSH_ENV(cmd);\n\tpush_charp(obuf, 9, \""--FRAME--\"", PC_ASCII);\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 0;\n    case HTML_N_FRAMESET:\n\tif (h_env->envc > 0) {\n\t    POP_ENV;\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t}\n\treturn 0;\n    case HTML_NOFRAMES:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag |= (RB_NOFRAMES | RB_IGNORE_P);\n\t/* istr = str; */\n\treturn 1;\n    case HTML_N_NOFRAMES:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag &= ~RB_NOFRAMES;\n\treturn 1;\n    case HTML_FRAME:\n\tq = r = NULL;\n\tparsedtag_get_value(tag, ATTR_SRC, &q);\n\tparsedtag_get_value(tag, ATTR_NAME, &r);\n\tif (q) {\n\t    q = html_quote(q);\n\t    push_tag(obuf, Sprintf(\""<a hseq=\\\""%d\\\"" href=\\\""%s\\\"">\"",\n\t\t\t\t   cur_hseq++, q)->ptr, HTML_A);\n\t    if (r)\n\t\tq = html_quote(r);\n\t    push_charp(obuf, get_strwidth(q), q, PC_ASCII);\n\t    push_tag(obuf, \""</a>\"", HTML_N_A);\n\t}\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\treturn 0;\n    case HTML_HR:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_hr(tag, h_env->limit, envs[h_env->envc].indent);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\tset_space_to_prevchar(obuf->prevchar);\n\treturn 1;\n    case HTML_PRE:\n\tx = parsedtag_exists(tag, ATTR_FOR_TABLE);\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    if (!x)\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t}\n\telse\n\t    fillline(obuf, envs[h_env->envc].indent);\n\tobuf->flag |= (RB_PRE | RB_IGNORE_P);\n\t/* istr = str; */\n\treturn 1;\n    case HTML_N_PRE:\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t    h_env->blank_lines++;\n\t}\n\tobuf->flag &= ~RB_PRE;\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_PRE_INT:\n\ti = obuf->line->length;\n\tappend_tags(obuf);\n\tif (!(obuf->flag & RB_SPECIAL)) {\n\t    set_breakpoint(obuf, obuf->line->length - i);\n\t}\n\tobuf->flag |= RB_PRE_INT;\n\treturn 0;\n    case HTML_N_PRE_INT:\n\tpush_tag(obuf, \""</pre_int>\"", HTML_N_PRE_INT);\n\tobuf->flag &= ~RB_PRE_INT;\n\tif (!(obuf->flag & RB_SPECIAL) && obuf->pos > obuf->bp.pos) {\n\t    set_prevchar(obuf->prevchar, \""\"", 0);\n\t    obuf->prev_ctype = PC_CTRL;\n\t}\n\treturn 1;\n    case HTML_NOBR:\n\tobuf->flag |= RB_NOBR;\n\tobuf->nobr_level++;\n\treturn 0;\n    case HTML_N_NOBR:\n\tif (obuf->nobr_level > 0)\n\t    obuf->nobr_level--;\n\tif (obuf->nobr_level == 0)\n\t    obuf->flag &= ~RB_NOBR;\n\treturn 0;\n    case HTML_PRE_PLAIN:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= (RB_PRE | RB_IGNORE_P);\n\treturn 1;\n    case HTML_N_PRE_PLAIN:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t}\n\tobuf->flag &= ~RB_PRE;\n\treturn 1;\n    case HTML_LISTING:\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t}\n\tobuf->flag |= (RB_PLAIN | RB_IGNORE_P);\n\tswitch (cmd) {\n\tcase HTML_LISTING:\n\t    obuf->end_tag = HTML_N_LISTING;\n\t    break;\n\tcase HTML_XMP:\n\t    obuf->end_tag = HTML_N_XMP;\n\t    break;\n\tcase HTML_PLAINTEXT:\n\t    obuf->end_tag = MAX_HTMLTAG;\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_LISTING:\n    case HTML_N_XMP:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P)) {\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\t    do_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t h_env->limit);\n\t    obuf->flag |= RB_IGNORE_P;\n\t}\n\tobuf->flag &= ~RB_PLAIN;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_SCRIPT:\n\tobuf->flag |= RB_SCRIPT;\n\tobuf->end_tag = HTML_N_SCRIPT;\n\treturn 1;\n    case HTML_STYLE:\n\tobuf->flag |= RB_STYLE;\n\tobuf->end_tag = HTML_N_STYLE;\n\treturn 1;\n    case HTML_N_SCRIPT:\n\tobuf->flag &= ~RB_SCRIPT;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_N_STYLE:\n\tobuf->flag &= ~RB_STYLE;\n\tobuf->end_tag = 0;\n\treturn 1;\n    case HTML_A:\n\tif (obuf->anchor.url)\n\t    close_anchor(h_env, obuf);\n\n\thseq = 0;\n\n\tif (parsedtag_get_value(tag, ATTR_HREF, &p))\n\t    obuf->anchor.url = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_TARGET, &p))\n\t    obuf->anchor.target = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_REFERER, &p))\n\t    obuf->anchor.referer = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_TITLE, &p))\n\t    obuf->anchor.title = Strnew_charp(p)->ptr;\n\tif (parsedtag_get_value(tag, ATTR_ACCESSKEY, &p))\n\t    obuf->anchor.accesskey = (unsigned char)*p;\n\tif (parsedtag_get_value(tag, ATTR_HSEQ, &hseq))\n\t    obuf->anchor.hseq = hseq;\n\n\tif (hseq == 0 && obuf->anchor.url) {\n\t    obuf->anchor.hseq = cur_hseq;\n\t    tmp = process_anchor(tag, h_env->tagbuf->ptr);\n\t    push_tag(obuf, tmp->ptr, HTML_A);\n\t    if (displayLinkNumber)\n\t\tHTMLlineproc1(getLinkNumberStr(-1)->ptr, h_env);\n\t    return 1;\n\t}\n\treturn 0;\n    case HTML_N_A:\n\tclose_anchor(h_env, obuf);\n\treturn 1;\n    case HTML_IMG:\n\ttmp = process_img(tag, h_env->limit);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_IMG_ALT:\n\tif (parsedtag_get_value(tag, ATTR_SRC, &p))\n\t    obuf->img_alt = Strnew_charp(p);\n#ifdef USE_IMAGE\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_TOP_MARGIN, &i)) {\n\t    if (i > obuf->top_margin)\n\t\tobuf->top_margin = i;\n\t}\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &i)) {\n\t    if (i > obuf->bottom_margin)\n\t\tobuf->bottom_margin = i;\n\t}\n#endif\n\treturn 0;\n    case HTML_N_IMG_ALT:\n\tif (obuf->img_alt) {\n\t    if (!close_effect0(obuf, HTML_IMG_ALT))\n\t\tpush_tag(obuf, \""</img_alt>\"", HTML_N_IMG_ALT);\n\t    obuf->img_alt = NULL;\n\t}\n\treturn 1;\n    case HTML_INPUT_ALT:\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_TOP_MARGIN, &i)) {\n\t    if (i > obuf->top_margin)\n\t\tobuf->top_margin = i;\n\t}\n\ti = 0;\n\tif (parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &i)) {\n\t    if (i > obuf->bottom_margin)\n\t\tobuf->bottom_margin = i;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_HSEQ, &hseq)) {\n\t    obuf->input_alt.hseq = hseq;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_FID, &i)) {\n\t    obuf->input_alt.fid = i;\n\t}\n\tif (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\t    obuf->input_alt.type = Strnew_charp(p);\n\t}\n\tif (parsedtag_get_value(tag, ATTR_VALUE, &p)) {\n\t    obuf->input_alt.value = Strnew_charp(p);\n\t}\n\tif (parsedtag_get_value(tag, ATTR_NAME, &p)) {\n\t    obuf->input_alt.name = Strnew_charp(p);\n\t}\n\tobuf->input_alt.in = 1;\n\treturn 0;\n    case HTML_N_INPUT_ALT:\n\tif (obuf->input_alt.in) {\n\t    if (!close_effect0(obuf, HTML_INPUT_ALT))\n\t\tpush_tag(obuf, \""</input_alt>\"", HTML_N_INPUT_ALT);\n\t    obuf->input_alt.hseq = 0;\n\t    obuf->input_alt.fid = -1;\n\t    obuf->input_alt.in = 0;\n\t    obuf->input_alt.type = NULL;\n\t    obuf->input_alt.name = NULL;\n\t    obuf->input_alt.value = NULL;\n\t}\n\treturn 1;\n    case HTML_TABLE:\n\tclose_anchor(h_env, obuf);\n\tobuf->table_level++;\n\tif (obuf->table_level >= MAX_TABLE)\n\t    break;\n\tw = BORDER_NONE;\n\t/* x: cellspacing, y: cellpadding */\n\tx = 2;\n\ty = 1;\n\tz = 0;\n\twidth = 0;\n\tif (parsedtag_exists(tag, ATTR_BORDER)) {\n\t    if (parsedtag_get_value(tag, ATTR_BORDER, &w)) {\n\t\tif (w > 2)\n\t\t    w = BORDER_THICK;\n\t\telse if (w < 0) {\t/* weird */\n\t\t    w = BORDER_THIN;\n\t\t}\n\t    }\n\t    else\n\t\tw = BORDER_THIN;\n\t}\n\tif (DisplayBorders && w == BORDER_NONE)\n\t    w = BORDER_THIN;\n\tif (parsedtag_get_value(tag, ATTR_WIDTH, &i)) {\n\t    if (obuf->table_level == 0)\n\t\twidth = REAL_WIDTH(i, h_env->limit - envs[h_env->envc].indent);\n\t    else\n\t\twidth = RELATIVE_WIDTH(i);\n\t}\n\tif (parsedtag_exists(tag, ATTR_HBORDER))\n\t    w = BORDER_NOWIN;\n#define MAX_CELLSPACING 1000\n#define MAX_CELLPADDING 1000\n#define MAX_VSPACE 1000\n\tparsedtag_get_value(tag, ATTR_CELLSPACING, &x);\n\tparsedtag_get_value(tag, ATTR_CELLPADDING, &y);\n\tparsedtag_get_value(tag, ATTR_VSPACE, &z);\n\tif (x > MAX_CELLSPACING)\n\t    x = MAX_CELLSPACING;\n\tif (y > MAX_CELLPADDING)\n\t    y = MAX_CELLPADDING;\n\tif (z > MAX_VSPACE)\n\t    z = MAX_VSPACE;\n#ifdef ID_EXT\n\tparsedtag_get_value(tag, ATTR_ID, &id);\n#endif\t\t\t\t/* ID_EXT */\n\ttables[obuf->table_level] = begin_table(w, x, y, z);\n#ifdef ID_EXT\n\tif (id != NULL)\n\t    tables[obuf->table_level]->id = Strnew_charp(id);\n#endif\t\t\t\t/* ID_EXT */\n\ttable_mode[obuf->table_level].pre_mode = 0;\n\ttable_mode[obuf->table_level].indent_level = 0;\n\ttable_mode[obuf->table_level].nobr_level = 0;\n\ttable_mode[obuf->table_level].caption = 0;\n\ttable_mode[obuf->table_level].end_tag = 0;\t/* HTML_UNKNOWN */\n#ifndef TABLE_EXPAND\n\ttables[obuf->table_level]->total_width = width;\n#else\n\ttables[obuf->table_level]->real_width = width;\n\ttables[obuf->table_level]->total_width = 0;\n#endif\n\treturn 1;\n    case HTML_N_TABLE:\n\t/* should be processed in HTMLlineproc() */\n\treturn 1;\n    case HTML_CENTER:\n\tCLOSE_A;\n\tif (!(obuf->flag & (RB_PREMODE | RB_IGNORE_P)))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_SAVE_FLAG(obuf);\n\tRB_SET_ALIGN(obuf, RB_CENTER);\n\treturn 1;\n    case HTML_N_CENTER:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_PREMODE))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_DIV:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_DIV:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_DIV_INT:\n\tCLOSE_P;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tset_alignment(obuf, tag);\n\treturn 1;\n    case HTML_N_DIV_INT:\n\tCLOSE_P;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tRB_RESTORE_FLAG(obuf);\n\treturn 1;\n    case HTML_FORM:\n\tCLOSE_A;\n\tif (!(obuf->flag & RB_IGNORE_P))\n\t    flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\ttmp = process_form(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_N_FORM:\n\tCLOSE_A;\n\tflushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);\n\tobuf->flag |= RB_IGNORE_P;\n\tprocess_n_form();\n\treturn 1;\n    case HTML_INPUT:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_input(tag);\n       if (tmp)\n           HTMLlineproc1(tmp->ptr, h_env);\n       return 1;\n    case HTML_BUTTON:\n       tmp = process_button(tag);\n       if (tmp)\n           HTMLlineproc1(tmp->ptr, h_env);\n       return 1;\n    case HTML_N_BUTTON:\n       tmp = process_n_button();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_SELECT:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_select(tag);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\tobuf->flag |= RB_INSELECT;\n\tobuf->end_tag = HTML_N_SELECT;\n\treturn 1;\n    case HTML_N_SELECT:\n\tobuf->flag &= ~RB_INSELECT;\n\tobuf->end_tag = 0;\n\ttmp = process_n_select();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_OPTION:\n\t/* nothing */\n\treturn 1;\n    case HTML_TEXTAREA:\n\tclose_anchor(h_env, obuf);\n\ttmp = process_textarea(tag, h_env->limit);\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\tobuf->flag |= RB_INTXTA;\n\tobuf->end_tag = HTML_N_TEXTAREA;\n\treturn 1;\n    case HTML_N_TEXTAREA:\n\tobuf->flag &= ~RB_INTXTA;\n\tobuf->end_tag = 0;\n\ttmp = process_n_textarea();\n\tif (tmp)\n\t    HTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_ISINDEX:\n\tp = \""\"";\n\tq = \""!CURRENT_URL!\"";\n\tparsedtag_get_value(tag, ATTR_PROMPT, &p);\n\tparsedtag_get_value(tag, ATTR_ACTION, &q);\n\ttmp = Strnew_m_charp(\""<form method=get action=\\\""\"",\n\t\t\t     html_quote(q),\n\t\t\t     \""\\\"">\"",\n\t\t\t     html_quote(p),\n\t\t\t     \""<input type=text name=\\\""\\\"" accept></form>\"",\n\t\t\t     NULL);\n\tHTMLlineproc1(tmp->ptr, h_env);\n\treturn 1;\n    case HTML_META:\n\tp = q = r = NULL;\n\tparsedtag_get_value(tag, ATTR_HTTP_EQUIV, &p);\n\tparsedtag_get_value(tag, ATTR_CONTENT, &q);\n#ifdef USE_M17N\n\tparsedtag_get_value(tag, ATTR_CHARSET, &r);\n\tif (r) {\n\t    /* <meta charset=\""\""> */\n\t    SKIP_BLANKS(r);\n\t    meta_charset = wc_guess_charset(r, 0);\n\t}\n\telse\n\tif (p && q && !strcasecmp(p, \""Content-Type\"") &&\n\t    (q = strcasestr(q, \""charset\"")) != NULL) {\n\t    q += 7;\n\t    SKIP_BLANKS(q);\n\t    if (*q == '=') {\n\t\tq++;\n\t\tSKIP_BLANKS(q);\n\t\tmeta_charset = wc_guess_charset(q, 0);\n\t    }\n\t}\n\telse\n#endif\n\tif (p && q && !strcasecmp(p, \""refresh\"")) {\n\t    int refresh_interval;\n\t    tmp = NULL;\n\t    refresh_interval = getMetaRefreshParam(q, &tmp);\n\t    if (tmp) {\n\t\tq = html_quote(tmp->ptr);\n\t\ttmp = Sprintf(\""Refresh (%d sec) <a href=\\\""%s\\\"">%s</a>\"",\n\t\t\t      refresh_interval, q, q);\n\t    }\n\t    else if (refresh_interval > 0)\n\t\ttmp = Sprintf(\""Refresh (%d sec)\"", refresh_interval);\n\t    if (tmp) {\n\t\tHTMLlineproc1(tmp->ptr, h_env);\n\t\tdo_blankline(h_env, obuf, envs[h_env->envc].indent, 0,\n\t\t\t     h_env->limit);\n\t\tif (!is_redisplay &&\n\t\t    !((obuf->flag & RB_NOFRAMES) && RenderFrame)) {\n\t\t    tag->need_reconstruct = TRUE;\n\t\t    return 0;\n\t\t}\n\t    }\n\t}\n\treturn 1;\n    case HTML_BASE:\n#if defined(USE_M17N) || defined(USE_IMAGE)\n\tp = NULL;\n\tif (parsedtag_get_value(tag, ATTR_HREF, &p)) {\n\t    cur_baseURL = New(ParsedURL);\n\t    parseURL(p, cur_baseURL, NULL);\n\t}\n#endif\n    case HTML_MAP:\n    case HTML_N_MAP:\n    case HTML_AREA:\n\treturn 0;\n    case HTML_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag |= RB_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>[DEL:</U>\"", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_strike++;\n\t    if (obuf->in_strike == 1) {\n\t\tpush_tag(obuf, \""<s>\"", HTML_S);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_DEL:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag &= ~RB_DEL;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>:DEL]</U>\"", h_env);\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_strike == 0)\n\t\treturn 1;\n\t    if (obuf->in_strike == 1 && close_effect0(obuf, HTML_S))\n\t\tobuf->in_strike = 0;\n\t    if (obuf->in_strike > 0) {\n\t\tobuf->in_strike--;\n\t\tif (obuf->in_strike == 0) {\n\t\t    push_tag(obuf, \""</s>\"", HTML_N_S);\n\t\t}\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag |= RB_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>[S:</U>\"", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_strike++;\n\t    if (obuf->in_strike == 1) {\n\t\tpush_tag(obuf, \""<s>\"", HTML_S);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_S:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    obuf->flag &= ~RB_S;\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>:S]</U>\"", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_strike == 0)\n\t\treturn 1;\n\t    if (obuf->in_strike == 1 && close_effect0(obuf, HTML_S))\n\t\tobuf->in_strike = 0;\n\t    if (obuf->in_strike > 0) {\n\t\tobuf->in_strike--;\n\t\tif (obuf->in_strike == 0) {\n\t\t    push_tag(obuf, \""</s>\"", HTML_N_S);\n\t\t}\n\t    }\n\t}\n\treturn 1;\n    case HTML_INS:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>[INS:</U>\"", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    obuf->in_ins++;\n\t    if (obuf->in_ins == 1) {\n\t\tpush_tag(obuf, \""<ins>\"", HTML_INS);\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_N_INS:\n\tswitch (displayInsDel) {\n\tcase DISPLAY_INS_DEL_SIMPLE:\n\t    break;\n\tcase DISPLAY_INS_DEL_NORMAL:\n\t    HTMLlineproc1(\""<U>:INS]</U>\"", h_env);\n\t    break;\n\tcase DISPLAY_INS_DEL_FONTIFY:\n\t    if (obuf->in_ins == 0)\n\t\treturn 1;\n\t    if (obuf->in_ins == 1 && close_effect0(obuf, HTML_INS))\n\t\tobuf->in_ins = 0;\n\t    if (obuf->in_ins > 0) {\n\t\tobuf->in_ins--;\n\t\tif (obuf->in_ins == 0) {\n\t\t    push_tag(obuf, \""</ins>\"", HTML_N_INS);\n\t\t}\n\t    }\n\t    break;\n\t}\n\treturn 1;\n    case HTML_SUP:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\""^\"", h_env);\n\treturn 1;\n    case HTML_N_SUP:\n\treturn 1;\n    case HTML_SUB:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\""[\"", h_env);\n\treturn 1;\n    case HTML_N_SUB:\n\tif (!(obuf->flag & (RB_DEL | RB_S)))\n\t    HTMLlineproc1(\""]\"", h_env);\n\treturn 1;\n    case HTML_FONT:\n    case HTML_N_FONT:\n    case HTML_NOP:\n\treturn 1;\n    case HTML_BGSOUND:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_SRC, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\""<A HREF=\\\""%s\\\"">bgsound(%s)</A>\"", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_EMBED:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_SRC, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\""<A HREF=\\\""%s\\\"">embed(%s)</A>\"", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_APPLET:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_ARCHIVE, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\""<A HREF=\\\""%s\\\"">applet archive(%s)</A>\"", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n\treturn 1;\n    case HTML_BODY:\n\tif (view_unseenobject) {\n\t    if (parsedtag_get_value(tag, ATTR_BACKGROUND, &p)) {\n\t\tStr s;\n\t\tq = html_quote(p);\n\t\ts = Sprintf(\""<IMG SRC=\\\""%s\\\"" ALT=\\\""bg image(%s)\\\""><BR>\"", q, q);\n\t\tHTMLlineproc1(s->ptr, h_env);\n\t    }\n\t}\n    case HTML_N_HEAD:\n\tif (obuf->flag & RB_TITLE)\n\t    HTMLlineproc1(\""</title>\"", h_env);\n    case HTML_HEAD:\n    case HTML_N_BODY:\n\treturn 1;\n    default:\n\t/* obuf->prevchar = '\\0'; */\n\treturn 0;\n    }\n    /* not reached */\n    return 0;\n}\n"", ""start_line"": 4399, ""end_line"": 5396, ""full_name"": ""HTMLtagproc1"", ""file_path"": ""file.c""}]}, {""source"": ""query_info(query:cpg.call.code(\""obuf->input_alt.name\"").l)"", ""result"": [{""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.name"", ""typeFullName"": ""ANY"", ""lineNumber"": 3028, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 8, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.name"", ""typeFullName"": ""ANY"", ""lineNumber"": 4964, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.name"", ""typeFullName"": ""ANY"", ""lineNumber"": 4976, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.name"", ""typeFullName"": ""ANY"", ""lineNumber"": 6926, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.name"", ""typeFullName"": ""ANY"", ""lineNumber"": 6969, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": 1}]}, {""source"": ""query_info(query:cpg.call.code(\""obuf->input_alt.type\"").l)"", ""result"": [{""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.type"", ""typeFullName"": ""ANY"", ""lineNumber"": 3029, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 8, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.type"", ""typeFullName"": ""ANY"", ""lineNumber"": 4958, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.type"", ""typeFullName"": ""ANY"", ""lineNumber"": 4975, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.type"", ""typeFullName"": ""ANY"", ""lineNumber"": 6925, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.type"", ""typeFullName"": ""ANY"", ""lineNumber"": 6968, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": 1}]}, {""source"": ""query_info(query:cpg.call.code(\""obuf->input_alt.value\"").l)"", ""result"": [{""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.value"", ""typeFullName"": ""ANY"", ""lineNumber"": 3030, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 8, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.value"", ""typeFullName"": ""ANY"", ""lineNumber"": 4961, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.value"", ""typeFullName"": ""ANY"", ""lineNumber"": 4977, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.value"", ""typeFullName"": ""ANY"", ""lineNumber"": 6927, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 5, ""argumentIndex"": 1}, {""name"": ""<operator>.fieldAccess"", ""signature"": """", ""code"": ""obuf->input_alt.value"", ""typeFullName"": ""ANY"", ""lineNumber"": 6970, ""methodFullName"": ""<operator>.fieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": 1}]}]","file.c:3026-3032: Dereference of obuf->input_alt.name->ptr, obuf->input_alt.type->ptr, and obuf->input_alt.value->ptr without null checks. obuf->input_alt is sourced from obuf->bp.input_alt (file.c:2476), which is set via obuf->input_alt in set_breakpoint() (file.c:2458). HTMLtagproc1() (file.c:4952-4977) populates input_alt.name, input_alt.type, and input_alt.value during parsing of <input_alt> tags using parsedtag_get_value(). If attributes are missing, these fields remain NULL, leading to a segfault in flushline().",0.95,./github/other_context/CVE-2016-9438
28,CVE-2017-14532,CWE-476,c_cpp,ImageMagick 7.0.7-0 has a NULL Pointer Dereference in TIFFIgnoreTags in coders/tiff.c.,https://github.com/ImageMagick/ImageMagick/commit/c55fb18c3f78445d100a378ab8b3c0acd53c6590,https://github.com/ImageMagick/ImageMagick/issues/719,1,"[{""func_name"": ""TIFFIgnoreTags"", ""file_path"": ""coders/tiff.c"", ""func_code"": ""static void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\""tiff:ignore-tags\"");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  /* This also sets field_bit to 0 (FIELD_IGNORE) */\n  ResetMagickMemory(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}"", ""target"": 0}]","[{""func_name"": ""TIFFIgnoreTags"", ""file_path"": ""coders/tiff.c"", ""func_code"": ""static void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n\n  const char\n    *p,\n    *tags;\n\n  Image\n   *image;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  TIFFFieldInfo\n    *ignore;\n\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\""tiff:ignore-tags\"");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n\n    p=q;\n    count++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  if (ignore == (TIFFFieldInfo *) NULL)\n    return;\n  /* This also sets field_bit to 0 (FIELD_IGNORE) */\n  ResetMagickMemory(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n\n    p=q;\n    i++;\n\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}""}]","{""function"": 2}","[{""source"": ""func_info(func:AcquireQuantumMemory)"", ""result"": [{""code"": ""void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n\n  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}"", ""start_line"": 530, ""end_line"": 539, ""full_name"": ""AcquireQuantumMemory"", ""file_path"": ""magick/memory.c""}]}, {""source"": ""func_info(file:memory.c, func:AcquireMagickMemory)"", ""result"": [{""code"": ""MagickExport void *AcquireMagickMemory(const size_t size)\n{\n  register void\n    *memory;\n\n#if !defined(MAGICKCORE_ANONYMOUS_MEMORY_SUPPORT)\n  memory=memory_methods.acquire_memory_handler(size == 0 ? 1UL : size);\n#else\n  if (memory_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&memory_semaphore);\n  if (free_segments == (DataSegmentInfo *) NULL)\n    {\n      LockSemaphoreInfo(memory_semaphore);\n      if (free_segments == (DataSegmentInfo *) NULL)\n        {\n          register ssize_t\n            i;\n\n          assert(2*sizeof(size_t) > (size_t) (~SizeMask));\n          (void) ResetMagickMemory(&memory_pool,0,sizeof(memory_pool));\n          memory_pool.allocation=SegmentSize;\n          memory_pool.blocks[MaxBlocks]=(void *) (-1);\n          for (i=0; i < MaxSegments; i++)\n          {\n            if (i != 0)\n              memory_pool.segment_pool[i].previous=\n                (&memory_pool.segment_pool[i-1]);\n            if (i != (MaxSegments-1))\n              memory_pool.segment_pool[i].next=(&memory_pool.segment_pool[i+1]);\n          }\n          free_segments=(&memory_pool.segment_pool[0]);\n        }\n      UnlockSemaphoreInfo(memory_semaphore);\n    }\n  LockSemaphoreInfo(memory_semaphore);\n  memory=AcquireBlock(size == 0 ? 1UL : size);\n  if (memory == (void *) NULL)\n    {\n      if (ExpandHeap(size == 0 ? 1UL : size) != MagickFalse)\n        memory=AcquireBlock(size == 0 ? 1UL : size);\n    }\n  UnlockSemaphoreInfo(memory_semaphore);\n#endif\n  return(memory);\n}\n"", ""start_line"": 459, ""end_line"": 503, ""full_name"": ""AcquireMagickMemory"", ""file_path"": ""magick/memory.c""}]}]","coders/tiff.c:2221-2223: 'ignore' pointer allocated via AcquireQuantumMemory() without NULL check. If AcquireQuantumMemory (magick/memory.c:530-539) returns NULL (due to HeapOverflowSanityCheck failure or AcquireMagickMemory failure), ResetMagickMemory() is called on a NULL pointer. AcquireMagickMemory (magick/memory.c:459-503) returns NULL when memory allocation (via acquire_memory_handler or AcquireBlock) fails, confirming the failure condition.",0.95,./github/other_context/CVE-2017-14532
29,CVE-2019-12108,CWE-476,c_cpp,A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in GetOutboundPinholeTimeout in upnpsoap.c for int_port.,https://github.com/miniupnp/miniupnp/commit/13585f15c7f7dc28bbbba1661efb280d530d114c,GetOutboundPinholeTimeout: check args,2,"[{""func_name"": ""GetOutboundPinholeTimeout"", ""file_path"": ""miniupnpd/upnpsoap.c"", ""func_code"": ""static void\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \""FirewallDisabled\"");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \""InternalClient\"");\n\tint_port = GetValueFromNameValueList(&data, \""InternalPort\"");\n\trem_host = GetValueFromNameValueList(&data, \""RemoteHost\"");\n\trem_port = GetValueFromNameValueList(&data, \""RemotePort\"");\n\tprotocol = GetValueFromNameValueList(&data, \""Protocol\"");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \""Invalid Args\"");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\"", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\""*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \""ProtocolNotSupported\"");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \""ActionFailed\"");\n\t}\n\tClearNameValueList(&data);\n}"", ""target"": 1}, {""func_name"": ""GetOutboundPinholeTimeout"", ""file_path"": ""miniupnpd/upnpsoap.c"", ""func_code"": ""static void\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \""FirewallDisabled\"");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \""InternalClient\"");\n\tint_port = GetValueFromNameValueList(&data, \""InternalPort\"");\n\trem_host = GetValueFromNameValueList(&data, \""RemoteHost\"");\n\trem_port = GetValueFromNameValueList(&data, \""RemotePort\"");\n\tprotocol = GetValueFromNameValueList(&data, \""Protocol\"");\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\"", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\""*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \""ProtocolNotSupported\"");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \""ActionFailed\"");\n\t}\n\tClearNameValueList(&data);\n}"", ""target"": 0}]","[{""func_name"": ""GetOutboundPinholeTimeout"", ""file_path"": ""miniupnpd/upnpsoap.c"", ""func_code"": ""static void\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \""FirewallDisabled\"");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \""InternalClient\"");\n\tint_port = GetValueFromNameValueList(&data, \""InternalPort\"");\n\trem_host = GetValueFromNameValueList(&data, \""RemoteHost\"");\n\trem_port = GetValueFromNameValueList(&data, \""RemotePort\"");\n\tprotocol = GetValueFromNameValueList(&data, \""Protocol\"");\n\n\tif (!int_port || !rem_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \""Invalid Args\"");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\"", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\""*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \""ProtocolNotSupported\"");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \""ActionFailed\"");\n\t}\n\tClearNameValueList(&data);\n}""}, {""func_name"": ""GetOutboundPinholeTimeout"", ""file_path"": ""miniupnpd/upnpsoap.c"", ""func_code"": ""static void\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \""FirewallDisabled\"");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \""InternalClient\"");\n\tint_port = GetValueFromNameValueList(&data, \""InternalPort\"");\n\trem_host = GetValueFromNameValueList(&data, \""RemoteHost\"");\n\trem_port = GetValueFromNameValueList(&data, \""RemotePort\"");\n\tprotocol = GetValueFromNameValueList(&data, \""Protocol\"");\n\n\tif (!int_port || !ext_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \""Invalid Args\"");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\"", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\""urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\""*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \""ProtocolNotSupported\"");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \""ActionFailed\"");\n\t}\n\tClearNameValueList(&data);\n}""}]","{""function"": 4, ""value"": 2, ""code"": 4, ""caller"": 3}","[{""source"": ""func_info(func:GetValueFromNameValueList)"", ""result"": [{""code"": ""char *\nGetValueFromNameValueList(struct NameValueParserData * pdata,\n                          const char * Name)\n{\n    struct NameValue * nv;\n    char * p = NULL;\n    for(nv = pdata->l_head;\n        (nv != NULL) && (p == NULL);\n        nv = nv->l_next)\n    {\n        if(strcmp(nv->name, Name) == 0)\n            p = nv->value;\n    }\n    return p;\n}"", ""start_line"": 138, ""end_line"": 152, ""full_name"": ""GetValueFromNameValueList"", ""file_path"": ""miniupnpc-async/upnpreplyparse.c""}, {""code"": ""char *\nGetValueFromNameValueList(struct NameValueParserData * pdata,\n                          const char * Name)\n{\n    struct NameValue * nv;\n    char * p = NULL;\n    for(nv = pdata->l_head;\n        (nv != NULL) && (p == NULL);\n        nv = nv->l_next)\n    {\n        if(strcmp(nv->name, Name) == 0)\n            p = nv->value;\n    }\n    return p;\n}"", ""start_line"": 138, ""end_line"": 152, ""full_name"": ""GetValueFromNameValueList<duplicate>0"", ""file_path"": ""miniupnpc-libevent/upnpreplyparse.c""}, {""code"": ""char *\nGetValueFromNameValueList(struct NameValueParserData * pdata,\n                          const char * Name)\n{\n    struct NameValue * nv;\n    char * p = NULL;\n    for(nv = pdata->l_head;\n        (nv != NULL) && (p == NULL);\n        nv = nv->l_next)\n    {\n        if(strcmp(nv->name, Name) == 0)\n            p = nv->value;\n    }\n    return p;\n}"", ""start_line"": 137, ""end_line"": 151, ""full_name"": ""GetValueFromNameValueList<duplicate>1"", ""file_path"": ""miniupnpc/upnpreplyparse.c""}]}, {""source"": ""value_info(file:upnpsoap.c, value:data)"", ""result"": {""value_trace"": [{""full_code"": ""data = ++p->xml"", ""line"": 155, ""func_name"": ""parseelt""}, {""full_code"": ""data = p->xml"", ""line"": 168, ""func_name"": ""parseelt""}, {""full_code"": ""* data = (struct NameValueParserData *)d"", ""line"": 18, ""func_name"": ""NameValueParserStartElt""}, {""full_code"": ""* data = (struct NameValueParserData *)d"", ""line"": 31, ""func_name"": ""NameValueParserEndElt""}, {""full_code"": ""* data = (struct NameValueParserData *)d"", ""line"": 76, ""func_name"": ""NameValueParserGetData""}], ""struct_var"": ""data"", ""struct_type"": ""ifdata"", ""struct_definition"": ""struct ifdata {\n\tunsigned long opackets;\n\tunsigned long ipackets;\n\tunsigned long obytes;\n\tunsigned long ibytes;\n\tunsigned long baudrate;\n}""}}, {""source"": ""func_info(func:NameValueParserStartElt)"", ""result"": [{""code"": ""static void\nNameValueParserStartElt(void * d, const char * name, int l)\n{\n\tstruct NameValueParserData * data = (struct NameValueParserData *)d;\n\tdata->topelt = 1;\n    if(l>63)\n        l = 63;\n    memcpy(data->curelt, name, l);\n    data->curelt[l] = '\\0';\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n}"", ""start_line"": 15, ""end_line"": 26, ""full_name"": ""NameValueParserStartElt"", ""file_path"": ""miniupnpc-async/upnpreplyparse.c""}, {""code"": ""static void\nNameValueParserStartElt(void * d, const char * name, int l)\n{\n\tstruct NameValueParserData * data = (struct NameValueParserData *)d;\n\tdata->topelt = 1;\n    if(l>63)\n        l = 63;\n    memcpy(data->curelt, name, l);\n    data->curelt[l] = '\\0';\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n}"", ""start_line"": 15, ""end_line"": 26, ""full_name"": ""NameValueParserStartElt<duplicate>0"", ""file_path"": ""miniupnpc-libevent/upnpreplyparse.c""}, {""code"": ""static void\nNameValueParserStartElt(void * d, const char * name, int l)\n{\n\tstruct NameValueParserData * data = (struct NameValueParserData *)d;\n\tdata->topelt = 1;\n    if(l>63)\n        l = 63;\n    memcpy(data->curelt, name, l);\n    data->curelt[l] = '\\0';\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n}"", ""start_line"": 16, ""end_line"": 27, ""full_name"": ""NameValueParserStartElt<duplicate>1"", ""file_path"": ""miniupnpc/upnpreplyparse.c""}]}, {""source"": ""func_info(func:NameValueParserEndElt)"", ""result"": [{""code"": ""static void\nNameValueParserEndElt(void * d, const char * name, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n    struct NameValue * nv;\n\t(void)name;\n\t(void)l;\n\tif(!data->topelt)\n\t\treturn;\n\tif(strcmp(data->curelt, \""NewPortListing\"") != 0)\n\t{\n\t\tint l;\n\t\t/* standard case. Limited to n chars strings */\n\t\tl = data->cdatalen;\n\t    nv = malloc(sizeof(struct NameValue));\n\t\tif(nv == NULL)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: error allocating memory\"",\n\t\t\t        \""NameValueParserEndElt\"");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t    if(l>=(int)sizeof(nv->value))\n\t        l = sizeof(nv->value) - 1;\n\t    strncpy(nv->name, data->curelt, 64);\n\t\tnv->name[63] = '\\0';\n\t\tif(data->cdata != NULL)\n\t\t{\n\t\t\tmemcpy(nv->value, data->cdata, l);\n\t\t\tnv->value[l] = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnv->value[0] = '\\0';\n\t\t}\n\t\tnv->l_next = data->l_head;\t/* insert in list */\n\t\tdata->l_head = nv;\n\t}\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n\tdata->topelt = 0;\n}"", ""start_line"": 28, ""end_line"": 71, ""full_name"": ""NameValueParserEndElt"", ""file_path"": ""miniupnpc-async/upnpreplyparse.c""}, {""code"": ""static void\nNameValueParserEndElt(void * d, const char * name, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n    struct NameValue * nv;\n\t(void)name;\n\t(void)l;\n\tif(!data->topelt)\n\t\treturn;\n\tif(strcmp(data->curelt, \""NewPortListing\"") != 0)\n\t{\n\t\tint l;\n\t\t/* standard case. Limited to n chars strings */\n\t\tl = data->cdatalen;\n\t    nv = malloc(sizeof(struct NameValue));\n\t\tif(nv == NULL)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: error allocating memory\"",\n\t\t\t        \""NameValueParserEndElt\"");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t    if(l>=(int)sizeof(nv->value))\n\t        l = sizeof(nv->value) - 1;\n\t    strncpy(nv->name, data->curelt, 64);\n\t\tnv->name[63] = '\\0';\n\t\tif(data->cdata != NULL)\n\t\t{\n\t\t\tmemcpy(nv->value, data->cdata, l);\n\t\t\tnv->value[l] = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnv->value[0] = '\\0';\n\t\t}\n\t\tnv->l_next = data->l_head;\t/* insert in list */\n\t\tdata->l_head = nv;\n\t}\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n\tdata->topelt = 0;\n}"", ""start_line"": 28, ""end_line"": 71, ""full_name"": ""NameValueParserEndElt<duplicate>0"", ""file_path"": ""miniupnpc-libevent/upnpreplyparse.c""}, {""code"": ""static void\nNameValueParserEndElt(void * d, const char * name, int namelen)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n    struct NameValue * nv;\n\t(void)name;\n\t(void)namelen;\n\tif(!data->topelt)\n\t\treturn;\n\tif(strcmp(data->curelt, \""NewPortListing\"") != 0)\n\t{\n\t\tint l;\n\t\t/* standard case. Limited to n chars strings */\n\t\tl = data->cdatalen;\n\t    nv = malloc(sizeof(struct NameValue));\n\t\tif(nv == NULL)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \""%s: error allocating memory\"",\n\t\t\t        \""NameValueParserEndElt\"");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t    if(l>=(int)sizeof(nv->value))\n\t        l = sizeof(nv->value) - 1;\n\t    strncpy(nv->name, data->curelt, 64);\n\t\tnv->name[63] = '\\0';\n\t\tif(data->cdata != NULL)\n\t\t{\n\t\t\tmemcpy(nv->value, data->cdata, l);\n\t\t\tnv->value[l] = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnv->value[0] = '\\0';\n\t\t}\n\t\tnv->l_next = data->l_head;\t/* insert in list */\n\t\tdata->l_head = nv;\n\t}\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n\tdata->topelt = 0;\n}"", ""start_line"": 29, ""end_line"": 72, ""full_name"": ""NameValueParserEndElt<duplicate>1"", ""file_path"": ""miniupnpc/upnpreplyparse.c""}]}, {""source"": ""value_info(file:upnpsoap.c, value:NameValueParserData)"", ""result"": {""value_trace"": [{""full_code"": ""struct NameValueParserData"", ""line"": 108, ""func_name"": null}], ""struct_var"": ""NameValueParserData"", ""struct_type"": ""NameValueParserData"", ""struct_definition"": ""struct NameValueParserData\n\nstruct NameValueParserData {\n\tstruct NameValue * l_head;\n\tchar curelt[64];\n\tchar * portListing;\n\tint portListingLength;\n\tint topelt;\n\tconst char * cdata;\n\tint cdatalen;\n}\n\nstruct NameValueParserData\n\nstruct NameValueParserData {\n\tstruct NameValue * l_head;\n\tchar curelt[64];\n\tchar * portListing;\n\tint portListingLength;\n\tint topelt;\n\tconst char * cdata;\n\tint cdatalen;\n}\n\nstruct NameValueParserData {\n\tstruct NameValue * l_head;\n\tchar curelt[64];\n\tchar * portListing;\n\tint portListingLength;\n\tint topelt;\n\tconst char * cdata;\n\tint cdatalen;\n}\n\nstruct NameValueParserData {\n\tstruct NameValue * l_head;\n\tchar curelt[64];\n\tchar * portListing;\n\tint portListingLength;\n\tint topelt;\n\tconst char * cdata;\n\tint cdatalen;\n}""}}, {""source"": ""func_info(func:parseelt)"", ""result"": [{""code"": ""static void parseelt(struct xmlparser * p)\n{\n\tint i;\n\tconst char * elementname;\n\twhile(p->xml < (p->xmlend - 1))\n\t{\n\t\tif((p->xml + 4) <= p->xmlend && (0 == memcmp(p->xml, \""<!--\"", 4)))\n\t\t{\n\t\t\tp->xml += 3;\n\t\t\t/* ignore comments */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tp->xml++;\n\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile(memcmp(p->xml, \""-->\"", 3) != 0);\n\t\t\tp->xml += 3;\n\t\t}\n\t\telse if((p->xml)[0]=='<' && (p->xml)[1]!='?')\n\t\t{\n\t\t\ti = 0; elementname = ++p->xml;\n\t\t\twhile( !IS_WHITE_SPACE(*p->xml)\n\t\t\t\t  && (*p->xml!='>') && (*p->xml!='/')\n\t\t\t\t )\n\t\t\t{\n\t\t\t\ti++; p->xml++;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\t/* to ignore namespace : */\n\t\t\t\tif(*p->xml==':')\n\t\t\t\t{\n\t\t\t\t\ti = 0;\n\t\t\t\t\telementname = ++p->xml;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i>0)\n\t\t\t{\n\t\t\t\tif(p->starteltfunc)\n\t\t\t\t\tp->starteltfunc(p->data, elementname, i);\n\t\t\t\tif(parseatt(p))\n\t\t\t\t\treturn;\n\t\t\t\tif(*p->xml!='/')\n\t\t\t\t{\n\t\t\t\t\tconst char * data;\n\t\t\t\t\ti = 0; data = ++p->xml;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t\twhile( IS_WHITE_SPACE(*p->xml) )\n\t\t\t\t\t{\n\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(memcmp(p->xml, \""<![CDATA[\"", 9) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* CDATA handling */\n\t\t\t\t\t\tp->xml += 9;\n\t\t\t\t\t\tdata = p->xml;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile(memcmp(p->xml, \""]]>\"", 3) != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc)\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp->xml++;\n\t\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 1) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc && *(p->xml + 1) == '/')\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(*p->xml == '/')\n\t\t\t{\n\t\t\t\ti = 0; elementname = ++p->xml;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\twhile((*p->xml != '>'))\n\t\t\t\t{\n\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(p->endeltfunc)\n\t\t\t\t\tp->endeltfunc(p->data, elementname, i);\n\t\t\t\tp->xml++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp->xml++;\n\t\t}\n\t}\n}\n"", ""start_line"": 110, ""end_line"": 219, ""full_name"": ""parseelt"", ""file_path"": ""miniupnpc-async/minixml.c""}, {""code"": ""static void parseelt(struct xmlparser * p)\n{\n\tint i;\n\tconst char * elementname;\n\twhile(p->xml < (p->xmlend - 1))\n\t{\n\t\tif((p->xml + 4) <= p->xmlend && (0 == memcmp(p->xml, \""<!--\"", 4)))\n\t\t{\n\t\t\tp->xml += 3;\n\t\t\t/* ignore comments */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tp->xml++;\n\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile(memcmp(p->xml, \""-->\"", 3) != 0);\n\t\t\tp->xml += 3;\n\t\t}\n\t\telse if((p->xml)[0]=='<' && (p->xml)[1]!='?')\n\t\t{\n\t\t\ti = 0; elementname = ++p->xml;\n\t\t\twhile( !IS_WHITE_SPACE(*p->xml)\n\t\t\t\t  && (*p->xml!='>') && (*p->xml!='/')\n\t\t\t\t )\n\t\t\t{\n\t\t\t\ti++; p->xml++;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\t/* to ignore namespace : */\n\t\t\t\tif(*p->xml==':')\n\t\t\t\t{\n\t\t\t\t\ti = 0;\n\t\t\t\t\telementname = ++p->xml;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i>0)\n\t\t\t{\n\t\t\t\tif(p->starteltfunc)\n\t\t\t\t\tp->starteltfunc(p->data, elementname, i);\n\t\t\t\tif(parseatt(p))\n\t\t\t\t\treturn;\n\t\t\t\tif(*p->xml!='/')\n\t\t\t\t{\n\t\t\t\t\tconst char * data;\n\t\t\t\t\ti = 0; data = ++p->xml;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t\twhile( IS_WHITE_SPACE(*p->xml) )\n\t\t\t\t\t{\n\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(memcmp(p->xml, \""<![CDATA[\"", 9) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* CDATA handling */\n\t\t\t\t\t\tp->xml += 9;\n\t\t\t\t\t\tdata = p->xml;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile(memcmp(p->xml, \""]]>\"", 3) != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc)\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp->xml++;\n\t\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 1) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc && *(p->xml + 1) == '/')\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(*p->xml == '/')\n\t\t\t{\n\t\t\t\ti = 0; elementname = ++p->xml;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\twhile((*p->xml != '>'))\n\t\t\t\t{\n\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(p->endeltfunc)\n\t\t\t\t\tp->endeltfunc(p->data, elementname, i);\n\t\t\t\tp->xml++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp->xml++;\n\t\t}\n\t}\n}\n"", ""start_line"": 110, ""end_line"": 219, ""full_name"": ""parseelt<duplicate>0"", ""file_path"": ""miniupnpc-libevent/minixml.c""}, {""code"": ""static void parseelt(struct xmlparser * p)\n{\n\tint i;\n\tconst char * elementname;\n\twhile(p->xml < (p->xmlend - 1))\n\t{\n\t\tif((p->xml + 4) <= p->xmlend && (0 == memcmp(p->xml, \""<!--\"", 4)))\n\t\t{\n\t\t\tp->xml += 3;\n\t\t\t/* ignore comments */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tp->xml++;\n\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile(memcmp(p->xml, \""-->\"", 3) != 0);\n\t\t\tp->xml += 3;\n\t\t}\n\t\telse if((p->xml)[0]=='<' && (p->xml)[1]!='?')\n\t\t{\n\t\t\ti = 0; elementname = ++p->xml;\n\t\t\twhile( !IS_WHITE_SPACE(*p->xml)\n\t\t\t\t  && (*p->xml!='>') && (*p->xml!='/')\n\t\t\t\t )\n\t\t\t{\n\t\t\t\ti++; p->xml++;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\t/* to ignore namespace : */\n\t\t\t\tif(*p->xml==':')\n\t\t\t\t{\n\t\t\t\t\ti = 0;\n\t\t\t\t\telementname = ++p->xml;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i>0)\n\t\t\t{\n\t\t\t\tif(p->starteltfunc)\n\t\t\t\t\tp->starteltfunc(p->data, elementname, i);\n\t\t\t\tif(parseatt(p))\n\t\t\t\t\treturn;\n\t\t\t\tif(*p->xml!='/')\n\t\t\t\t{\n\t\t\t\t\tconst char * data;\n\t\t\t\t\ti = 0; data = ++p->xml;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t\twhile( IS_WHITE_SPACE(*p->xml) )\n\t\t\t\t\t{\n\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t/* CDATA are at least 9 + 3 characters long : <![CDATA[ ]]> */\n\t\t\t\t\tif((p->xmlend >= (p->xml + (9 + 3))) && (memcmp(p->xml, \""<![CDATA[\"", 9) == 0))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* CDATA handling */\n\t\t\t\t\t\tp->xml += 9;\n\t\t\t\t\t\tdata = p->xml;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile(memcmp(p->xml, \""]]>\"", 3) != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 3) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc)\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp->xml++;\n\t\t\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(*p->xml!='<')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\t\t\tif ((p->xml + 1) >= p->xmlend)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i>0 && p->datafunc && *(p->xml + 1) == '/')\n\t\t\t\t\t\t\tp->datafunc(p->data, data, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(*p->xml == '/')\n\t\t\t{\n\t\t\t\ti = 0; elementname = ++p->xml;\n\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\treturn;\n\t\t\t\twhile((*p->xml != '>'))\n\t\t\t\t{\n\t\t\t\t\ti++; p->xml++;\n\t\t\t\t\tif (p->xml >= p->xmlend)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(p->endeltfunc)\n\t\t\t\t\tp->endeltfunc(p->data, elementname, i);\n\t\t\t\tp->xml++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp->xml++;\n\t\t}\n\t}\n}\n"", ""start_line"": 111, ""end_line"": 221, ""full_name"": ""parseelt<duplicate>1"", ""file_path"": ""miniupnpc/minixml.c""}]}, {""source"": ""code_info(file:upnpsoap.c, lines:150-170)"", ""result"": ""\t/* TotalBytesReceived\n\t * This variable represents the cumulative counter for total number of\n\t * bytes received downstream across all connection service instances on\n\t * WANDevice. The count rolls over to 0 after it reaching the maximum\n\t * value (2^32)-1. */\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, /* was \""urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\"" */\n#ifdef UPNP_STRICT\n\t         r<0?0:(data.ibytes & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n\t         r<0?0:data.ibytes, action);\n#endif /* UPNP_STRICT */\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\nstatic void\nGetTotalPacketsSent(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n""}, {""source"": ""code_info(file:upnpsoap.c, lines:140-160)"", ""result"": ""\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<NewTotalBytesReceived>%lu</NewTotalBytesReceived>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n\n\tr = getifstats(ext_if_name, &data);\n\t/* TotalBytesReceived\n\t * This variable represents the cumulative counter for total number of\n\t * bytes received downstream across all connection service instances on\n\t * WANDevice. The count rolls over to 0 after it reaching the maximum\n\t * value (2^32)-1. */\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, /* was \""urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\"" */\n#ifdef UPNP_STRICT\n\t         r<0?0:(data.ibytes & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n\t         r<0?0:data.ibytes, action);\n#endif /* UPNP_STRICT */\n""}, {""source"": ""caller_info(file:upnpsoap.c, func:parseelt)"", ""result"": [{""call_line"": 226, ""call_code"": ""parseelt(parser)"", ""caller_code"": ""void parsexml(struct xmlparser * parser)\n{\n\tparser->xml = parser->xmlstart;\n\tparser->xmlend = parser->xmlstart + parser->xmlsize;\n\tparseelt(parser);\n}"", ""caller_start"": 222, ""file_path"": ""miniupnpc-async/minixml.c""}]}, {""source"": ""caller_info(file:upnpsoap.c, func:parsexml)"", ""result"": [{""call_line"": 618, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""static int upnpc_get_response(upnpc_device_t * p)\n{\n\tssize_t n;\n\tssize_t count;\n\tchar buffer[2048];\n\tif(p->http_response_content_length > 0) {\n\t\tcount = p->http_response_content_length\n\t\t      + p->http_response_end_of_headers\n\t\t      - p->http_response_received;\n\t\tif(count > (ssize_t)sizeof(buffer)) count = sizeof(buffer);\n\t} else {\n\t\tcount = sizeof(buffer);\n\t}\n\tdebug_printf(\""recv(..., %d)\\n\"", (int)count);\n\tn = recv(p->http_socket, buffer, count, 0/* flags */);\n\tif(n < 0) {\n\t\tif(errno == EINTR || WOULDBLOCK(errno))\n\t\t\treturn 0;\t/* try again later */\n\t\tPRINT_SOCKET_ERROR(\""read\"");\n\t\tp->state = EDevError;\n\t\treturn -1;\n\t} else if(n == 0) {\n\t\t/* receiving finished */\n\t\tdebug_printf(\""%.*s\\n\"", p->http_response_received, p->http_response);\n\t\tclose(p->http_socket);\n\t\tp->http_socket = -1;\n\t\t/* parse */\n\t\tif(p->http_response_end_of_headers == 0) {\n\t\t\tupnpc_parse_headers(p);\n\t\t}\n\t\t/* TODO : decode chunked transfer-encoding */\n\t\t/* parse xml */\n\t\tif(p->state == EDevGetDescResponse) {\n\t\t\tstruct IGDdatas igd;\n\t\t\tstruct xmlparser parser;\n\t\t\tmemset(&igd, 0, sizeof(struct IGDdatas));\n\t\t\tmemset(&parser, 0, sizeof(struct xmlparser));\n\t\t\tparser.xmlstart = p->http_response + p->http_response_end_of_headers;\n\t\t\tparser.xmlsize = p->http_response_received - p->http_response_end_of_headers;\n\t\t\tparser.data = &igd;\n\t\t\tparser.starteltfunc = IGDstartelt;\n\t\t\tparser.endeltfunc = IGDendelt;\n\t\t\tparser.datafunc = IGDdata;\n\t\t\tparsexml(&parser);\n#ifdef DEBUG\n\t\t\tprintIGD(&igd);\n#endif /* DEBUG */\n\t\t\tp->control_conn_url = build_url_string(igd.urlbase, p->root_desc_location, igd.first.controlurl);\n\t\t\tp->control_cif_url = build_url_string(igd.urlbase, p->root_desc_location, igd.CIF.controlurl);\n\t\t\tdebug_printf(\""control_conn_url='%s'\\n\"", p->control_conn_url);\n\t\t\tdebug_printf(\""control_cif_url='%s'\\n\"", p->control_cif_url);\n\t\t} else {\n\t\t\tClearNameValueList(&p->soap_response_data);\n\t\t\tParseNameValue(p->http_response + p->http_response_end_of_headers,\n\t\t\t               p->http_response_received - p->http_response_end_of_headers,\n\t\t\t               &p->soap_response_data);\n\t\t}\n\t\tfree(p->http_response);\n\t\tp->http_response = NULL;\n\t\tp->http_response_received = 0;\n\t\tp->http_response_end_of_headers = 0;\n\t\tp->state = EDevReady;\n\t} else {\n\t\t/* receiving in progress */\n\t\tdebug_printf(\""received %d bytes:\\n%.*s\\n\"", (int)n, (int)n, buffer);\n\t\tif(p->http_response == NULL) {\n\t\t\tp->http_response = malloc(n);\n\t\t\tif(p->http_response == NULL) {\n\t\t\t\tdebug_printf(\""failed to malloc %d bytes\\n\"", (int)n);\n\t\t\t\tp->state = EDevError;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tp->http_response_received = n;\n\t\t\tmemcpy(p->http_response, buffer, n);\n\t\t} else {\n\t\t\tchar * tmp = realloc(p->http_response, p->http_response_received + n);\n\t\t\tif(tmp == NULL) {\n\t\t\t\tdebug_printf(\""failed to realloc %d bytes\\n\"", (int)(p->http_response_received + n));\n\t\t\t\tp->state = EDevError;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tp->http_response = tmp;\n\t\t\tmemcpy(p->http_response + p->http_response_received, buffer, n);\n\t\t\tp->http_response_received += n;\n\t\t}\n\t\tif(p->http_response_end_of_headers == 0) {\n\t\t\tupnpc_parse_headers(p);\n\t\t}\n\t}\n\treturn 0;\n}\n"", ""caller_start"": 575, ""file_path"": ""miniupnpc-async/miniupnpc-async.c""}, {""call_line"": 118, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""void\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}"", ""caller_start"": 102, ""file_path"": ""miniupnpc-async/upnpreplyparse.c""}, {""call_line"": 398, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""static void upnpc_desc_received(struct evhttp_request * req, void * pvoid)\n{\n\tsize_t len;\n\tunsigned char * data;\n\tstruct evbuffer * input_buffer;\n\tstruct IGDdatas igd;\n\tstruct xmlparser parser;\n\tupnpc_device_t * d = (upnpc_device_t *)pvoid;\n\n\tif(req == NULL) {\n\t\tdebug_printf(\""%s(%p, %p) NULL argument !\\n\"", __func__, req, pvoid);\n\t\treturn;\n\t}\n\tinput_buffer = evhttp_request_get_input_buffer(req);\n\tlen = evbuffer_get_length(input_buffer);\n\tdata = evbuffer_pullup(input_buffer, len);\n\tdebug_printf(\""%s %d (%d bytes)\\n\"", __func__, evhttp_request_get_response_code(req), (int)len);\n\tif(evhttp_request_get_response_code(req) != HTTP_OK) {\n\t\td->parent->ready_cb(evhttp_request_get_response_code(req), d->parent, d, d->parent->cb_data);\n\t\treturn;\n\t}\n\tif(data == NULL) {\n\t\td->parent->ready_cb(UPNPC_ERR_ROOT_DESC_ERROR, d->parent, d, d->parent->cb_data);\n\t\treturn;\n\t}\n\tdebug_printf(\""%.*s\\n\"", (int)len, (char *)data);\n\n\tmemset(&igd, 0, sizeof(struct IGDdatas));\n\tmemset(&parser, 0, sizeof(struct xmlparser));\n\tparser.xmlstart = (char *)data;\n\tparser.xmlsize = len;\n\tparser.data = &igd;\n\tparser.starteltfunc = IGDstartelt;\n\tparser.endeltfunc = IGDendelt;\n\tparser.datafunc = IGDdata;\n\tparsexml(&parser);\n#ifdef DEBUG\n\tprintIGD(&igd);\n#endif /* DEBUG */\n\td->control_conn_url = build_url_string(igd.urlbase, d->root_desc_location, igd.first.controlurl);\n\td->event_conn_url = build_url_string(igd.urlbase, d->root_desc_location, igd.first.eventsuburl);\n\td->conn_service_type = strdup(igd.first.servicetype);\n\td->control_cif_url = build_url_string(igd.urlbase, d->root_desc_location, igd.CIF.controlurl);\n\td->event_cif_url = build_url_string(igd.urlbase, d->root_desc_location, igd.CIF.eventsuburl);\n\td->cif_service_type = strdup(igd.CIF.servicetype);\n\tdebug_printf(\""control_conn_url='%s'\\n  (service_type='%s')\\n\"",\n\t             d->control_conn_url, d->conn_service_type);\n\tdebug_printf(\""event_conn_url='%s'\\n\"", d->event_conn_url);\n\tdebug_printf(\""control_cif_url='%s'\\n  (service_type='%s')\\n\"",\n\t             d->control_cif_url, d->cif_service_type);\n\n\tif((d->cif_service_type == NULL)\n\t  || (d->cif_service_type[0] == '\\0')\n\t  || (!COMPARE(d->cif_service_type, \""urn:schemas-upnp-org:service:WANCommonInterfaceConfig:\""))) {\n\t\td->parent->ready_cb(UPNPC_ERR_NOT_IGD, d->parent, d, d->parent->cb_data);\n\t} else {\n\t\td->state |= UPNPC_DEVICE_GETSTATUS;\n\t\tupnpc_get_status_info(d);\n\t}\n}\n"", ""caller_start"": 363, ""file_path"": ""miniupnpc-libevent/miniupnpc-libevent.c""}, {""call_line"": 118, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""void\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}"", ""caller_start"": 102, ""file_path"": ""miniupnpc-libevent/upnpreplyparse.c""}]}, {""source"": ""code_info(file:upnpsoap.c, lines:100-120)"", ""result"": ""\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\n/* maximum value for a UPNP ui4 type variable */\n#define UPNP_UI4_MAX (4294967295ul)\n\nstatic void\nGetTotalBytesSent(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<NewTotalBytesSent>%lu</NewTotalBytesSent>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n""}, {""source"": ""caller_info(file:upnpsoap.c, func:parsexml)"", ""result"": [{""call_line"": 618, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""static int upnpc_get_response(upnpc_device_t * p)\n{\n\tssize_t n;\n\tssize_t count;\n\tchar buffer[2048];\n\tif(p->http_response_content_length > 0) {\n\t\tcount = p->http_response_content_length\n\t\t      + p->http_response_end_of_headers\n\t\t      - p->http_response_received;\n\t\tif(count > (ssize_t)sizeof(buffer)) count = sizeof(buffer);\n\t} else {\n\t\tcount = sizeof(buffer);\n\t}\n\tdebug_printf(\""recv(..., %d)\\n\"", (int)count);\n\tn = recv(p->http_socket, buffer, count, 0/* flags */);\n\tif(n < 0) {\n\t\tif(errno == EINTR || WOULDBLOCK(errno))\n\t\t\treturn 0;\t/* try again later */\n\t\tPRINT_SOCKET_ERROR(\""read\"");\n\t\tp->state = EDevError;\n\t\treturn -1;\n\t} else if(n == 0) {\n\t\t/* receiving finished */\n\t\tdebug_printf(\""%.*s\\n\"", p->http_response_received, p->http_response);\n\t\tclose(p->http_socket);\n\t\tp->http_socket = -1;\n\t\t/* parse */\n\t\tif(p->http_response_end_of_headers == 0) {\n\t\t\tupnpc_parse_headers(p);\n\t\t}\n\t\t/* TODO : decode chunked transfer-encoding */\n\t\t/* parse xml */\n\t\tif(p->state == EDevGetDescResponse) {\n\t\t\tstruct IGDdatas igd;\n\t\t\tstruct xmlparser parser;\n\t\t\tmemset(&igd, 0, sizeof(struct IGDdatas));\n\t\t\tmemset(&parser, 0, sizeof(struct xmlparser));\n\t\t\tparser.xmlstart = p->http_response + p->http_response_end_of_headers;\n\t\t\tparser.xmlsize = p->http_response_received - p->http_response_end_of_headers;\n\t\t\tparser.data = &igd;\n\t\t\tparser.starteltfunc = IGDstartelt;\n\t\t\tparser.endeltfunc = IGDendelt;\n\t\t\tparser.datafunc = IGDdata;\n\t\t\tparsexml(&parser);\n#ifdef DEBUG\n\t\t\tprintIGD(&igd);\n#endif /* DEBUG */\n\t\t\tp->control_conn_url = build_url_string(igd.urlbase, p->root_desc_location, igd.first.controlurl);\n\t\t\tp->control_cif_url = build_url_string(igd.urlbase, p->root_desc_location, igd.CIF.controlurl);\n\t\t\tdebug_printf(\""control_conn_url='%s'\\n\"", p->control_conn_url);\n\t\t\tdebug_printf(\""control_cif_url='%s'\\n\"", p->control_cif_url);\n\t\t} else {\n\t\t\tClearNameValueList(&p->soap_response_data);\n\t\t\tParseNameValue(p->http_response + p->http_response_end_of_headers,\n\t\t\t               p->http_response_received - p->http_response_end_of_headers,\n\t\t\t               &p->soap_response_data);\n\t\t}\n\t\tfree(p->http_response);\n\t\tp->http_response = NULL;\n\t\tp->http_response_received = 0;\n\t\tp->http_response_end_of_headers = 0;\n\t\tp->state = EDevReady;\n\t} else {\n\t\t/* receiving in progress */\n\t\tdebug_printf(\""received %d bytes:\\n%.*s\\n\"", (int)n, (int)n, buffer);\n\t\tif(p->http_response == NULL) {\n\t\t\tp->http_response = malloc(n);\n\t\t\tif(p->http_response == NULL) {\n\t\t\t\tdebug_printf(\""failed to malloc %d bytes\\n\"", (int)n);\n\t\t\t\tp->state = EDevError;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tp->http_response_received = n;\n\t\t\tmemcpy(p->http_response, buffer, n);\n\t\t} else {\n\t\t\tchar * tmp = realloc(p->http_response, p->http_response_received + n);\n\t\t\tif(tmp == NULL) {\n\t\t\t\tdebug_printf(\""failed to realloc %d bytes\\n\"", (int)(p->http_response_received + n));\n\t\t\t\tp->state = EDevError;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tp->http_response = tmp;\n\t\t\tmemcpy(p->http_response + p->http_response_received, buffer, n);\n\t\t\tp->http_response_received += n;\n\t\t}\n\t\tif(p->http_response_end_of_headers == 0) {\n\t\t\tupnpc_parse_headers(p);\n\t\t}\n\t}\n\treturn 0;\n}\n"", ""caller_start"": 575, ""file_path"": ""miniupnpc-async/miniupnpc-async.c""}, {""call_line"": 118, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""void\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}"", ""caller_start"": 102, ""file_path"": ""miniupnpc-async/upnpreplyparse.c""}, {""call_line"": 398, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""static void upnpc_desc_received(struct evhttp_request * req, void * pvoid)\n{\n\tsize_t len;\n\tunsigned char * data;\n\tstruct evbuffer * input_buffer;\n\tstruct IGDdatas igd;\n\tstruct xmlparser parser;\n\tupnpc_device_t * d = (upnpc_device_t *)pvoid;\n\n\tif(req == NULL) {\n\t\tdebug_printf(\""%s(%p, %p) NULL argument !\\n\"", __func__, req, pvoid);\n\t\treturn;\n\t}\n\tinput_buffer = evhttp_request_get_input_buffer(req);\n\tlen = evbuffer_get_length(input_buffer);\n\tdata = evbuffer_pullup(input_buffer, len);\n\tdebug_printf(\""%s %d (%d bytes)\\n\"", __func__, evhttp_request_get_response_code(req), (int)len);\n\tif(evhttp_request_get_response_code(req) != HTTP_OK) {\n\t\td->parent->ready_cb(evhttp_request_get_response_code(req), d->parent, d, d->parent->cb_data);\n\t\treturn;\n\t}\n\tif(data == NULL) {\n\t\td->parent->ready_cb(UPNPC_ERR_ROOT_DESC_ERROR, d->parent, d, d->parent->cb_data);\n\t\treturn;\n\t}\n\tdebug_printf(\""%.*s\\n\"", (int)len, (char *)data);\n\n\tmemset(&igd, 0, sizeof(struct IGDdatas));\n\tmemset(&parser, 0, sizeof(struct xmlparser));\n\tparser.xmlstart = (char *)data;\n\tparser.xmlsize = len;\n\tparser.data = &igd;\n\tparser.starteltfunc = IGDstartelt;\n\tparser.endeltfunc = IGDendelt;\n\tparser.datafunc = IGDdata;\n\tparsexml(&parser);\n#ifdef DEBUG\n\tprintIGD(&igd);\n#endif /* DEBUG */\n\td->control_conn_url = build_url_string(igd.urlbase, d->root_desc_location, igd.first.controlurl);\n\td->event_conn_url = build_url_string(igd.urlbase, d->root_desc_location, igd.first.eventsuburl);\n\td->conn_service_type = strdup(igd.first.servicetype);\n\td->control_cif_url = build_url_string(igd.urlbase, d->root_desc_location, igd.CIF.controlurl);\n\td->event_cif_url = build_url_string(igd.urlbase, d->root_desc_location, igd.CIF.eventsuburl);\n\td->cif_service_type = strdup(igd.CIF.servicetype);\n\tdebug_printf(\""control_conn_url='%s'\\n  (service_type='%s')\\n\"",\n\t             d->control_conn_url, d->conn_service_type);\n\tdebug_printf(\""event_conn_url='%s'\\n\"", d->event_conn_url);\n\tdebug_printf(\""control_cif_url='%s'\\n  (service_type='%s')\\n\"",\n\t             d->control_cif_url, d->cif_service_type);\n\n\tif((d->cif_service_type == NULL)\n\t  || (d->cif_service_type[0] == '\\0')\n\t  || (!COMPARE(d->cif_service_type, \""urn:schemas-upnp-org:service:WANCommonInterfaceConfig:\""))) {\n\t\td->parent->ready_cb(UPNPC_ERR_NOT_IGD, d->parent, d, d->parent->cb_data);\n\t} else {\n\t\td->state |= UPNPC_DEVICE_GETSTATUS;\n\t\tupnpc_get_status_info(d);\n\t}\n}\n"", ""caller_start"": 363, ""file_path"": ""miniupnpc-libevent/miniupnpc-libevent.c""}, {""call_line"": 118, ""call_code"": ""parsexml(&parser)"", ""caller_code"": ""void\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}"", ""caller_start"": 102, ""file_path"": ""miniupnpc-libevent/upnpreplyparse.c""}]}, {""source"": ""code_info(file:upnpsoap.c, lines:100-120)"", ""result"": ""\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n\n/* maximum value for a UPNP ui4 type variable */\n#define UPNP_UI4_MAX (4294967295ul)\n\nstatic void\nGetTotalBytesSent(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\""<u:%sResponse \""\n\t\t\""xmlns:u=\\\""%s\\\"">\""\n\t\t\""<NewTotalBytesSent>%lu</NewTotalBytesSent>\""\n\t\t\""</u:%sResponse>\"";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n""}]","The vulnerability arises from the absence of NULL checks for int_port, ext_port, and protocol in GetOutboundPinholeTimeout (miniupnpd/upnpsoap.c:1853). These variables are assigned via GetValueFromNameValueList(&data, ""InternalPort""), GetValueFromNameValueList(&data, ""RemotePort""), and GetValueFromNameValueList(&data, ""Protocol"") (miniupnpd/upnpsoap.c:1851). GetValueFromNameValueList (miniupnpc/upnpreplyparse.c:138-152) returns NULL if the requested key is missing from the NameValueParserData structure. The 'data' structure (miniupnpd/upnpsoap.c:108) is populated during XML parsing of SOAP requests by NameValueParserStartElt (miniupnpc/upnpreplyparse.c:15-26) and NameValueParserEndElt (miniupnpc/upnpreplyparse.c:28-71), which extract parameters into a linked list of NameValue entries. If required parameters are absent, GetValueFromNameValueList returns NULL, leading to a dereference in atoi(). The patch (miniupnpd/upnpsoap.c:1851-1857) adds explicit NULL checks to prevent this.",0.95,./github/other_context/CVE-2019-12108
30,CVE-2019-18798,"CWE-476, CWE-125",c_cpp,LibSass before 3.6.3 allows a heap-based buffer over-read in Sass::weaveParents in ast_sel_weave.cpp.,https://github.com/sass/libsass/commit/0b721e0f37fc69ab197ec956a923e036e3b05ca6,Fix out of boundary vector access\n\nFixes https://github.com/sass/libsass/issues/2999,3,"[{""func_name"": ""weaveParents"", ""file_path"": ""src/ast_sel_weave.cpp"", ""func_code"": ""std::vector<std::vector<SelectorComponentObj>> weaveParents(\n    std::vector<SelectorComponentObj> queue1,\n    std::vector<SelectorComponentObj> queue2)\n  {\n\n    std::vector<SelectorComponentObj> leads;\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> trails;\n    if (!mergeInitialCombinators(queue1, queue2, leads)) return {};\n    if (!mergeFinalCombinators(queue1, queue2, trails)) return {};\n    // list comes out in reverse order for performance\n    std::reverse(trails.begin(), trails.end());\n\n    // Make sure there's at most one `:root` in the output.\n    // Note: does not yet do anything in libsass (no root selector)\n    CompoundSelectorObj root1 = getFirstIfRoot(queue1);\n    CompoundSelectorObj root2 = getFirstIfRoot(queue2);\n\n    if (!root1.isNull() && !root2.isNull()) {\n      CompoundSelectorObj root = root1->unifyWith(root2);\n      if (root.isNull()) return {}; // null\n      queue1.insert(queue1.begin(), root);\n      queue2.insert(queue2.begin(), root);\n    }\n    else if (!root1.isNull()) {\n      queue2.insert(queue2.begin(), root1);\n    }\n    else if (!root2.isNull()) {\n      queue1.insert(queue1.begin(), root2);\n    }\n\n    // group into sub-lists so no sub-list contains two adjacent ComplexSelectors.\n    std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);\n    std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);\n\n    // The main array to store our choices that will be permutated\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;\n\n    // append initial combinators\n    choices.push_back({ leads });\n\n    std::vector<std::vector<SelectorComponentObj>> LCS =\n      lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);\n\n    for (auto group : LCS) {\n\n      // Create junks from groups1 and groups2\n      std::vector<std::vector<std::vector<SelectorComponentObj>>>\n        chunks = getChunks<std::vector<SelectorComponentObj>>(\n          groups1, groups2, group, cmpChunkForParentSuperselector);\n\n      // Create expanded array by flattening chunks2 inner\n      std::vector<std::vector<SelectorComponentObj>>\n        expanded = flattenInner(chunks);\n\n      // Prepare data structures\n      choices.push_back(expanded);\n      choices.push_back({ group });\n      groups1.erase(groups1.begin());\n      groups2.erase(groups2.begin());\n\n    }\n\n    // Create junks from groups1 and groups2\n    std::vector<std::vector<std::vector<SelectorComponentObj>>>\n      chunks = getChunks<std::vector<SelectorComponentObj>>(\n        groups1, groups2, {}, cmpChunkForEmptySequence);\n\n    // Append chunks with inner arrays flattened\n    choices.emplace_back(flattenInner(chunks));\n\n    // append all trailing selectors to choices\n    std::move(std::begin(trails), std::end(trails),\n      std::inserter(choices, std::end(choices)));\n\n    // move all non empty items to the front, then erase the trailing ones\n    choices.erase(std::remove_if(choices.begin(), choices.end(), checkForEmptyChild\n      <std::vector<std::vector<SelectorComponentObj>>>), choices.end());\n\n    // permutate all possible paths through selectors\n    std::vector<std::vector<SelectorComponentObj>>\n      results = flattenInner(permutate(choices));\n\n    return results;\n\n  }"", ""target"": 0}, {""func_name"": ""Parser::parseCompoundSelector"", ""file_path"": ""src/parser_selectors.cpp"", ""func_code"": ""CompoundSelectorObj Parser::parseCompoundSelector()\n  {\n    // init an empty compound selector wrapper\n    CompoundSelectorObj seq = SASS_MEMORY_NEW(CompoundSelector, pstate);\n\n    // skip initial white-space\n    lex < block_comment >();\n    advanceToNextToken();\n\n    if (lex< exactly<'&'> >(false))\n    {\n      // ToDo: check the conditions and try to simplify flag passing\n      if (!allow_parent) error(\""Parent selectors aren't allowed here.\"");\n      // Create and append a new parent selector object\n      seq->hasRealParent(true);\n    }\n\n    // parse list\n    while (true)\n    {\n      // remove all block comments\n      // leaves trailing white-space\n      lex < block_comment >();\n      // parse parent selector\n      if (lex< exactly<'&'> >(false))\n      {\n        // parent selector only allowed at start\n        // upcoming Sass may allow also trailing\n        ParserState state(pstate);\n        SimpleSelectorObj prev = (*seq)[seq->length()-1];\n        std::string sel(prev->to_string({ NESTED, 5 }));\n        std::string found(\""&\"");\n        if (lex < identifier >()) { found += std::string(lexed); }\n        // ToDo: parser should throw parser exceptions\n        error(\""Invalid CSS after \\\""\"" + sel + \""\\\"": expected \\\""{\\\"", was \\\""\"" + found + \""\\\""\\n\\n\""\n          \""\\\""\"" + found + \""\\\"" may only be used at the beginning of a compound selector.\"", state);\n      }\n      // parse functional\n      else if (match < re_functional >())\n        {\n          seq->append(parse_simple_selector());\n        }\n\n      // parse type selector\n      else if (lex< re_type_selector >(false))\n      {\n        seq->append(SASS_MEMORY_NEW(Type_Selector, pstate, lexed));\n      }\n      // peek for abort conditions\n      else if (peek< spaces >()) break;\n      else if (peek< end_of_file >()) { break; }\n      else if (peek_css < class_char < selector_combinator_ops > >()) break;\n      else if (peek_css < class_char < complex_selector_delims > >()) break;\n      // otherwise parse another simple selector\n      else {\n        SimpleSelectorObj sel = parse_simple_selector();\n        if (!sel) return {};\n        seq->append(sel);\n      }\n    }\n    // EO while true\n\n    if (seq && !peek_css<alternatives<end_of_file,exactly<'{'>>>()) {\n      seq->hasPostLineBreak(peek_newline());\n    }\n\n    // We may have set hasRealParent\n    if (seq && seq->empty() && !seq->hasRealParent()) return {};\n\n    return seq;\n  }"", ""target"": 0}, {""func_name"": ""Eval::operator()"", ""file_path"": ""src/eval.cpp"", ""func_code"": ""Expression* Eval::operator()(Binary_Expression* b_in)\n  {\n\n    Expression_Obj lhs = b_in->left();\n    Expression_Obj rhs = b_in->right();\n    enum Sass_OP op_type = b_in->optype();\n\n    if (op_type == Sass_OP::AND) {\n      // LOCAL_FLAG(force, true);\n      lhs = lhs->perform(this);\n      if (!*lhs) return lhs.detach();\n      return rhs->perform(this);\n    }\n    else if (op_type == Sass_OP::OR) {\n      // LOCAL_FLAG(force, true);\n      lhs = lhs->perform(this);\n      if (*lhs) return lhs.detach();\n      return rhs->perform(this);\n    }\n\n    // Evaluate variables as early o\n    while (Variable* l_v = Cast<Variable>(lhs)) {\n      lhs = operator()(l_v);\n    }\n    while (Variable* r_v = Cast<Variable>(rhs)) {\n      rhs = operator()(r_v);\n    }\n\n    Binary_Expression_Obj b = b_in;\n\n    // Evaluate sub-expressions early on\n    while (Binary_Expression* l_b = Cast<Binary_Expression>(lhs)) {\n      if (!force && l_b->is_delayed()) break;\n      lhs = operator()(l_b);\n    }\n    while (Binary_Expression* r_b = Cast<Binary_Expression>(rhs)) {\n      if (!force && r_b->is_delayed()) break;\n      rhs = operator()(r_b);\n    }\n\n    // don't eval delayed expressions (the '/' when used as a separator)\n    if (!force && op_type == Sass_OP::DIV && b->is_delayed()) {\n      b->right(b->right()->perform(this));\n      b->left(b->left()->perform(this));\n      return b.detach();\n    }\n\n    // specific types we know are final\n    // handle them early to avoid overhead\n    if (Number* l_n = Cast<Number>(lhs)) {\n      // lhs is number and rhs is number\n      if (Number* r_n = Cast<Number>(rhs)) {\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_n == *r_n ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_n == *r_n ? bool_false : bool_true;\n            case Sass_OP::LT: return *l_n < *r_n ? bool_true : bool_false;\n            case Sass_OP::GTE: return *l_n < *r_n ? bool_false : bool_true;\n            case Sass_OP::LTE: return *l_n < *r_n || *l_n == *r_n ? bool_true : bool_false;\n            case Sass_OP::GT: return *l_n < *r_n || *l_n == *r_n ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_numbers(op_type, *l_n, *r_n, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n      // lhs is number and rhs is color\n      // Todo: allow to work with HSLA colors\n      else if (Color* r_col = Cast<Color>(rhs)) {\n        Color_RGBA_Obj r_c = r_col->toRGBA();\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_n == *r_c ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_n == *r_c ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_number_color(op_type, *l_n, *r_c, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n    }\n    else if (Color* l_col = Cast<Color>(lhs)) {\n      Color_RGBA_Obj l_c = l_col->toRGBA();\n      // lhs is color and rhs is color\n      if (Color* r_col = Cast<Color>(rhs)) {\n        Color_RGBA_Obj r_c = r_col->toRGBA();\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_c == *r_c ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_c == *r_c ? bool_false : bool_true;\n            case Sass_OP::LT: return *l_c < *r_c ? bool_true : bool_false;\n            case Sass_OP::GTE: return *l_c < *r_c ? bool_false : bool_true;\n            case Sass_OP::LTE: return *l_c < *r_c || *l_c == *r_c ? bool_true : bool_false;\n            case Sass_OP::GT: return *l_c < *r_c || *l_c == *r_c ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_colors(op_type, *l_c, *r_c, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n      // lhs is color and rhs is number\n      else if (Number* r_n = Cast<Number>(rhs)) {\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_c == *r_n ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_c == *r_n ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_color_number(op_type, *l_c, *r_n, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n    }\n\n    String_Schema_Obj ret_schema;\n\n    // only the last item will be used to eval the binary expression\n    if (String_Schema* s_l = Cast<String_Schema>(b->left())) {\n      if (!s_l->has_interpolant() && (!s_l->is_right_interpolant())) {\n        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());\n        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),\n                                                    b->op(), s_l->last(), b->right());\n        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // unverified\n        for (size_t i = 0; i < s_l->length() - 1; ++i) {\n          ret_schema->append(Cast<PreValue>(s_l->at(i)->perform(this)));\n        }\n        ret_schema->append(Cast<PreValue>(bin_ex->perform(this)));\n        return ret_schema->perform(this);\n      }\n    }\n    if (String_Schema* s_r = Cast<String_Schema>(b->right())) {\n\n      if (!s_r->has_interpolant() && (!s_r->is_left_interpolant() || op_type == Sass_OP::DIV)) {\n        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());\n        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),\n                                                    b->op(), b->left(), s_r->first());\n        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // verified\n        ret_schema->append(Cast<PreValue>(bin_ex->perform(this)));\n        for (size_t i = 1; i < s_r->length(); ++i) {\n          ret_schema->append(Cast<PreValue>(s_r->at(i)->perform(this)));\n        }\n        return ret_schema->perform(this);\n      }\n    }\n\n    // fully evaluate their values\n    if (op_type == Sass_OP::EQ ||\n        op_type == Sass_OP::NEQ ||\n        op_type == Sass_OP::GT ||\n        op_type == Sass_OP::GTE ||\n        op_type == Sass_OP::LT ||\n        op_type == Sass_OP::LTE)\n    {\n      LOCAL_FLAG(force, true);\n      lhs->is_expanded(false);\n      lhs->set_delayed(false);\n      lhs = lhs->perform(this);\n      rhs->is_expanded(false);\n      rhs->set_delayed(false);\n      rhs = rhs->perform(this);\n    }\n    else {\n      lhs = lhs->perform(this);\n    }\n\n    // not a logical connective, so go ahead and eval the rhs\n    rhs = rhs->perform(this);\n    AST_Node_Obj lu = lhs;\n    AST_Node_Obj ru = rhs;\n\n    Expression::Type l_type;\n    Expression::Type r_type;\n\n    // Is one of the operands an interpolant?\n    String_Schema_Obj s1 = Cast<String_Schema>(b->left());\n    String_Schema_Obj s2 = Cast<String_Schema>(b->right());\n    Binary_Expression_Obj b1 = Cast<Binary_Expression>(b->left());\n    Binary_Expression_Obj b2 = Cast<Binary_Expression>(b->right());\n\n    bool schema_op = false;\n\n    bool force_delay = (s2 && s2->is_left_interpolant()) ||\n                       (s1 && s1->is_right_interpolant()) ||\n                       (b1 && b1->is_right_interpolant()) ||\n                       (b2 && b2->is_left_interpolant());\n\n    if ((s1 && s1->has_interpolants()) || (s2 && s2->has_interpolants()) || force_delay)\n    {\n      if (op_type == Sass_OP::DIV || op_type == Sass_OP::MUL || op_type == Sass_OP::MOD || op_type == Sass_OP::ADD || op_type == Sass_OP::SUB ||\n          op_type == Sass_OP::EQ) {\n        // If possible upgrade LHS to a number (for number to string compare)\n        if (String_Constant* str = Cast<String_Constant>(lhs)) {\n          std::string value(str->value());\n          const char* start = value.c_str();\n          if (Prelexer::sequence < Prelexer::dimension, Prelexer::end_of_file >(start) != 0) {\n            lhs = Parser::lexed_dimension(b->pstate(), str->value());\n          }\n        }\n        // If possible upgrade RHS to a number (for string to number compare)\n        if (String_Constant* str = Cast<String_Constant>(rhs)) {\n          std::string value(str->value());\n          const char* start = value.c_str();\n          if (Prelexer::sequence < Prelexer::dimension, Prelexer::number >(start) != 0) {\n            rhs = Parser::lexed_dimension(b->pstate(), str->value());\n          }\n        }\n      }\n\n      To_Value to_value(ctx);\n      Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));\n      Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));\n\n      if (force_delay) {\n        std::string str(\""\"");\n        str += v_l->to_string(options());\n        if (b->op().ws_before) str += \"" \"";\n        str += b->separator();\n        if (b->op().ws_after) str += \"" \"";\n        str += v_r->to_string(options());\n        String_Constant* val = SASS_MEMORY_NEW(String_Constant, b->pstate(), str);\n        val->is_interpolant(b->left()->has_interpolant());\n        return val;\n      }\n    }\n\n    // see if it's a relational expression\n    try {\n      switch(op_type) {\n        case Sass_OP::EQ:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::eq(lhs, rhs));\n        case Sass_OP::NEQ: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::neq(lhs, rhs));\n        case Sass_OP::GT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gt(lhs, rhs));\n        case Sass_OP::GTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gte(lhs, rhs));\n        case Sass_OP::LT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lt(lhs, rhs));\n        case Sass_OP::LTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lte(lhs, rhs));\n        default: break;\n      }\n    }\n    catch (Exception::OperationError& err)\n    {\n      traces.push_back(Backtrace(b->pstate()));\n      throw Exception::SassValueError(traces, b->pstate(), err);\n    }\n\n    l_type = lhs->concrete_type();\n    r_type = rhs->concrete_type();\n\n    // ToDo: throw error in op functions\n    // ToDo: then catch and re-throw them\n    Expression_Obj rv;\n    try {\n      ParserState pstate(b->pstate());\n      if (l_type == Expression::NUMBER && r_type == Expression::NUMBER) {\n        Number* l_n = Cast<Number>(lhs);\n        Number* r_n = Cast<Number>(rhs);\n        l_n->reduce(); r_n->reduce();\n        rv = Operators::op_numbers(op_type, *l_n, *r_n, options(), pstate);\n      }\n      else if (l_type == Expression::NUMBER && r_type == Expression::COLOR) {\n        Number* l_n = Cast<Number>(lhs);\n        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();\n        rv = Operators::op_number_color(op_type, *l_n, *r_c, options(), pstate);\n      }\n      else if (l_type == Expression::COLOR && r_type == Expression::NUMBER) {\n        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();\n        Number* r_n = Cast<Number>(rhs);\n        rv = Operators::op_color_number(op_type, *l_c, *r_n, options(), pstate);\n      }\n      else if (l_type == Expression::COLOR && r_type == Expression::COLOR) {\n        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();\n        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();\n        rv = Operators::op_colors(op_type, *l_c, *r_c, options(), pstate);\n      }\n      else {\n        To_Value to_value(ctx);\n        // this will leak if perform does not return a value!\n        Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));\n        Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));\n        bool interpolant = b->is_right_interpolant() ||\n                           b->is_left_interpolant() ||\n                           b->is_interpolant();\n        if (op_type == Sass_OP::SUB) interpolant = false;\n        // if (op_type == Sass_OP::DIV) interpolant = true;\n        // check for type violations\n        if (l_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {\n          traces.push_back(Backtrace(v_l->pstate()));\n          throw Exception::InvalidValue(traces, *v_l);\n        }\n        if (r_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {\n          traces.push_back(Backtrace(v_r->pstate()));\n          throw Exception::InvalidValue(traces, *v_r);\n        }\n        Value* ex = Operators::op_strings(b->op(), *v_l, *v_r, options(), pstate, !interpolant); // pass true to compress\n        if (String_Constant* str = Cast<String_Constant>(ex))\n        {\n          if (str->concrete_type() == Expression::STRING)\n          {\n            String_Constant* lstr = Cast<String_Constant>(lhs);\n            String_Constant* rstr = Cast<String_Constant>(rhs);\n            if (op_type != Sass_OP::SUB) {\n              if (String_Constant* org = lstr ? lstr : rstr)\n              { str->quote_mark(org->quote_mark()); }\n            }\n          }\n        }\n        ex->is_interpolant(b->is_interpolant());\n        rv = ex;\n      }\n    }\n    catch (Exception::OperationError& err)\n    {\n      traces.push_back(Backtrace(b->pstate()));\n      // throw Exception::Base(b->pstate(), err.what());\n      throw Exception::SassValueError(traces, b->pstate(), err);\n    }\n\n    if (rv) {\n      if (schema_op) {\n        // XXX: this is never hit via spec tests\n        (*s2)[0] = rv;\n        rv = s2->perform(this);\n      }\n    }\n\n    return rv.detach();\n\n  }"", ""target"": 0}]","[{""func_name"": ""weaveParents"", ""file_path"": ""src/ast_sel_weave.cpp"", ""func_code"": ""std::vector<std::vector<SelectorComponentObj>> weaveParents(\n    std::vector<SelectorComponentObj> queue1,\n    std::vector<SelectorComponentObj> queue2)\n  {\n\n    std::vector<SelectorComponentObj> leads;\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> trails;\n    if (!mergeInitialCombinators(queue1, queue2, leads)) return {};\n    if (!mergeFinalCombinators(queue1, queue2, trails)) return {};\n    // list comes out in reverse order for performance\n    std::reverse(trails.begin(), trails.end());\n\n    // Make sure there's at most one `:root` in the output.\n    // Note: does not yet do anything in libsass (no root selector)\n    CompoundSelectorObj root1 = getFirstIfRoot(queue1);\n    CompoundSelectorObj root2 = getFirstIfRoot(queue2);\n\n    if (!root1.isNull() && !root2.isNull()) {\n      CompoundSelectorObj root = root1->unifyWith(root2);\n      if (root.isNull()) return {}; // null\n      queue1.insert(queue1.begin(), root);\n      queue2.insert(queue2.begin(), root);\n    }\n    else if (!root1.isNull()) {\n      queue2.insert(queue2.begin(), root1);\n    }\n    else if (!root2.isNull()) {\n      queue1.insert(queue1.begin(), root2);\n    }\n\n    // group into sub-lists so no sub-list contains two adjacent ComplexSelectors.\n    std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);\n    std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);\n\n    // The main array to store our choices that will be permutated\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;\n\n    // append initial combinators\n    choices.push_back({ leads });\n\n    std::vector<std::vector<SelectorComponentObj>> LCS =\n      lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);\n\n    for (auto group : LCS) {\n\n      // Create junks from groups1 and groups2\n      std::vector<std::vector<std::vector<SelectorComponentObj>>>\n        chunks = getChunks<std::vector<SelectorComponentObj>>(\n          groups1, groups2, group, cmpChunkForParentSuperselector);\n\n      // Create expanded array by flattening chunks2 inner\n      std::vector<std::vector<SelectorComponentObj>>\n        expanded = flattenInner(chunks);\n\n      // Prepare data structures\n      choices.push_back(expanded);\n      choices.push_back({ group });\n      if (!groups1.empty()) {\n        groups1.erase(groups1.begin());\n      }\n      if (!groups2.empty()) {\n        groups2.erase(groups2.begin());\n      }\n\n    }\n\n    // Create junks from groups1 and groups2\n    std::vector<std::vector<std::vector<SelectorComponentObj>>>\n      chunks = getChunks<std::vector<SelectorComponentObj>>(\n        groups1, groups2, {}, cmpChunkForEmptySequence);\n\n    // Append chunks with inner arrays flattened\n    choices.emplace_back(flattenInner(chunks));\n\n    // append all trailing selectors to choices\n    std::move(std::begin(trails), std::end(trails),\n      std::inserter(choices, std::end(choices)));\n\n    // move all non empty items to the front, then erase the trailing ones\n    choices.erase(std::remove_if(choices.begin(), choices.end(), checkForEmptyChild\n      <std::vector<std::vector<SelectorComponentObj>>>), choices.end());\n\n    // permutate all possible paths through selectors\n    std::vector<std::vector<SelectorComponentObj>>\n      results = flattenInner(permutate(choices));\n\n    return results;\n\n  }""}, {""func_name"": ""Parser::parseCompoundSelector"", ""file_path"": ""src/parser_selectors.cpp"", ""func_code"": ""CompoundSelectorObj Parser::parseCompoundSelector()\n  {\n    // init an empty compound selector wrapper\n    CompoundSelectorObj seq = SASS_MEMORY_NEW(CompoundSelector, pstate);\n\n    // skip initial white-space\n    lex < block_comment >();\n    advanceToNextToken();\n\n    if (lex< exactly<'&'> >(false))\n    {\n      // ToDo: check the conditions and try to simplify flag passing\n      if (!allow_parent) error(\""Parent selectors aren't allowed here.\"");\n      // Create and append a new parent selector object\n      seq->hasRealParent(true);\n    }\n\n    // parse list\n    while (true)\n    {\n      // remove all block comments\n      // leaves trailing white-space\n      lex < block_comment >();\n      // parse parent selector\n      if (lex< exactly<'&'> >(false))\n      {\n        // parent selector only allowed at start\n        // upcoming Sass may allow also trailing\n        ParserState state(pstate);\n        std::string found(\""&\"");\n        if (lex < identifier >()) {\n          found += std::string(lexed);\n        }\n        std::string sel(seq->hasRealParent() ? \""&\"" : \""\"");\n        if (!seq->empty()) { sel = seq->last()->to_string({ NESTED, 5 }); }\n        // ToDo: parser should throw parser exceptions\n        error(\""Invalid CSS after \\\""\"" + sel + \""\\\"": expected \\\""{\\\"", was \\\""\"" + found + \""\\\""\\n\\n\""\n          \""\\\""\"" + found + \""\\\"" may only be used at the beginning of a compound selector.\"", state);\n      }\n      // parse functional\n      else if (match < re_functional >())\n        {\n          seq->append(parse_simple_selector());\n        }\n\n      // parse type selector\n      else if (lex< re_type_selector >(false))\n      {\n        seq->append(SASS_MEMORY_NEW(Type_Selector, pstate, lexed));\n      }\n      // peek for abort conditions\n      else if (peek< spaces >()) break;\n      else if (peek< end_of_file >()) { break; }\n      else if (peek_css < class_char < selector_combinator_ops > >()) break;\n      else if (peek_css < class_char < complex_selector_delims > >()) break;\n      // otherwise parse another simple selector\n      else {\n        SimpleSelectorObj sel = parse_simple_selector();\n        if (!sel) return {};\n        seq->append(sel);\n      }\n    }\n    // EO while true\n\n    if (seq && !peek_css<alternatives<end_of_file,exactly<'{'>>>()) {\n      seq->hasPostLineBreak(peek_newline());\n    }\n\n    // We may have set hasRealParent\n    if (seq && seq->empty() && !seq->hasRealParent()) return {};\n\n    return seq;\n  }""}, {""func_name"": ""Eval::operator()"", ""file_path"": ""src/eval.cpp"", ""func_code"": ""Expression* Eval::operator()(Binary_Expression* b_in)\n  {\n\n    Expression_Obj lhs = b_in->left();\n    Expression_Obj rhs = b_in->right();\n    enum Sass_OP op_type = b_in->optype();\n\n    if (op_type == Sass_OP::AND) {\n      // LOCAL_FLAG(force, true);\n      lhs = lhs->perform(this);\n      if (!*lhs) return lhs.detach();\n      return rhs->perform(this);\n    }\n    else if (op_type == Sass_OP::OR) {\n      // LOCAL_FLAG(force, true);\n      lhs = lhs->perform(this);\n      if (*lhs) return lhs.detach();\n      return rhs->perform(this);\n    }\n\n    // Evaluate variables as early o\n    while (Variable* l_v = Cast<Variable>(lhs)) {\n      lhs = operator()(l_v);\n    }\n    while (Variable* r_v = Cast<Variable>(rhs)) {\n      rhs = operator()(r_v);\n    }\n\n    Binary_Expression_Obj b = b_in;\n\n    // Evaluate sub-expressions early on\n    while (Binary_Expression* l_b = Cast<Binary_Expression>(lhs)) {\n      if (!force && l_b->is_delayed()) break;\n      lhs = operator()(l_b);\n    }\n    while (Binary_Expression* r_b = Cast<Binary_Expression>(rhs)) {\n      if (!force && r_b->is_delayed()) break;\n      rhs = operator()(r_b);\n    }\n\n    // don't eval delayed expressions (the '/' when used as a separator)\n    if (!force && op_type == Sass_OP::DIV && b->is_delayed()) {\n      b->right(b->right()->perform(this));\n      b->left(b->left()->perform(this));\n      return b.detach();\n    }\n\n    // specific types we know are final\n    // handle them early to avoid overhead\n    if (Number* l_n = Cast<Number>(lhs)) {\n      // lhs is number and rhs is number\n      if (Number* r_n = Cast<Number>(rhs)) {\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_n == *r_n ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_n == *r_n ? bool_false : bool_true;\n            case Sass_OP::LT: return *l_n < *r_n ? bool_true : bool_false;\n            case Sass_OP::GTE: return *l_n < *r_n ? bool_false : bool_true;\n            case Sass_OP::LTE: return *l_n < *r_n || *l_n == *r_n ? bool_true : bool_false;\n            case Sass_OP::GT: return *l_n < *r_n || *l_n == *r_n ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_numbers(op_type, *l_n, *r_n, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n      // lhs is number and rhs is color\n      // Todo: allow to work with HSLA colors\n      else if (Color* r_col = Cast<Color>(rhs)) {\n        Color_RGBA_Obj r_c = r_col->toRGBA();\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_n == *r_c ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_n == *r_c ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_number_color(op_type, *l_n, *r_c, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n    }\n    else if (Color* l_col = Cast<Color>(lhs)) {\n      Color_RGBA_Obj l_c = l_col->toRGBA();\n      // lhs is color and rhs is color\n      if (Color* r_col = Cast<Color>(rhs)) {\n        Color_RGBA_Obj r_c = r_col->toRGBA();\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_c == *r_c ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_c == *r_c ? bool_false : bool_true;\n            case Sass_OP::LT: return *l_c < *r_c ? bool_true : bool_false;\n            case Sass_OP::GTE: return *l_c < *r_c ? bool_false : bool_true;\n            case Sass_OP::LTE: return *l_c < *r_c || *l_c == *r_c ? bool_true : bool_false;\n            case Sass_OP::GT: return *l_c < *r_c || *l_c == *r_c ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_colors(op_type, *l_c, *r_c, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n      // lhs is color and rhs is number\n      else if (Number* r_n = Cast<Number>(rhs)) {\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_c == *r_n ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_c == *r_n ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_color_number(op_type, *l_c, *r_n, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n    }\n\n    String_Schema_Obj ret_schema;\n\n    // only the last item will be used to eval the binary expression\n    if (String_Schema* s_l = Cast<String_Schema>(b->left())) {\n      if (!s_l->has_interpolant() && (!s_l->is_right_interpolant())) {\n        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());\n        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),\n                                                    b->op(), s_l->last(), b->right());\n        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // unverified\n        for (size_t i = 0; i < s_l->length() - 1; ++i) {\n          ret_schema->append(s_l->at(i)->perform(this));\n        }\n        ret_schema->append(bin_ex->perform(this));\n        return ret_schema->perform(this);\n      }\n    }\n    if (String_Schema* s_r = Cast<String_Schema>(b->right())) {\n\n      if (!s_r->has_interpolant() && (!s_r->is_left_interpolant() || op_type == Sass_OP::DIV)) {\n        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());\n        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),\n                                                    b->op(), b->left(), s_r->first());\n        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // verified\n        ret_schema->append(bin_ex->perform(this));\n        for (size_t i = 1; i < s_r->length(); ++i) {\n          ret_schema->append(s_r->at(i)->perform(this));\n        }\n        return ret_schema->perform(this);\n      }\n    }\n\n    // fully evaluate their values\n    if (op_type == Sass_OP::EQ ||\n        op_type == Sass_OP::NEQ ||\n        op_type == Sass_OP::GT ||\n        op_type == Sass_OP::GTE ||\n        op_type == Sass_OP::LT ||\n        op_type == Sass_OP::LTE)\n    {\n      LOCAL_FLAG(force, true);\n      lhs->is_expanded(false);\n      lhs->set_delayed(false);\n      lhs = lhs->perform(this);\n      rhs->is_expanded(false);\n      rhs->set_delayed(false);\n      rhs = rhs->perform(this);\n    }\n    else {\n      lhs = lhs->perform(this);\n    }\n\n    // not a logical connective, so go ahead and eval the rhs\n    rhs = rhs->perform(this);\n    AST_Node_Obj lu = lhs;\n    AST_Node_Obj ru = rhs;\n\n    Expression::Type l_type;\n    Expression::Type r_type;\n\n    // Is one of the operands an interpolant?\n    String_Schema_Obj s1 = Cast<String_Schema>(b->left());\n    String_Schema_Obj s2 = Cast<String_Schema>(b->right());\n    Binary_Expression_Obj b1 = Cast<Binary_Expression>(b->left());\n    Binary_Expression_Obj b2 = Cast<Binary_Expression>(b->right());\n\n    bool schema_op = false;\n\n    bool force_delay = (s2 && s2->is_left_interpolant()) ||\n                       (s1 && s1->is_right_interpolant()) ||\n                       (b1 && b1->is_right_interpolant()) ||\n                       (b2 && b2->is_left_interpolant());\n\n    if ((s1 && s1->has_interpolants()) || (s2 && s2->has_interpolants()) || force_delay)\n    {\n      if (op_type == Sass_OP::DIV || op_type == Sass_OP::MUL || op_type == Sass_OP::MOD || op_type == Sass_OP::ADD || op_type == Sass_OP::SUB ||\n          op_type == Sass_OP::EQ) {\n        // If possible upgrade LHS to a number (for number to string compare)\n        if (String_Constant* str = Cast<String_Constant>(lhs)) {\n          std::string value(str->value());\n          const char* start = value.c_str();\n          if (Prelexer::sequence < Prelexer::dimension, Prelexer::end_of_file >(start) != 0) {\n            lhs = Parser::lexed_dimension(b->pstate(), str->value());\n          }\n        }\n        // If possible upgrade RHS to a number (for string to number compare)\n        if (String_Constant* str = Cast<String_Constant>(rhs)) {\n          std::string value(str->value());\n          const char* start = value.c_str();\n          if (Prelexer::sequence < Prelexer::dimension, Prelexer::number >(start) != 0) {\n            rhs = Parser::lexed_dimension(b->pstate(), str->value());\n          }\n        }\n      }\n\n      To_Value to_value(ctx);\n      Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));\n      Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));\n\n      if (force_delay) {\n        std::string str(\""\"");\n        str += v_l->to_string(options());\n        if (b->op().ws_before) str += \"" \"";\n        str += b->separator();\n        if (b->op().ws_after) str += \"" \"";\n        str += v_r->to_string(options());\n        String_Constant* val = SASS_MEMORY_NEW(String_Constant, b->pstate(), str);\n        val->is_interpolant(b->left()->has_interpolant());\n        return val;\n      }\n    }\n\n    // see if it's a relational expression\n    try {\n      switch(op_type) {\n        case Sass_OP::EQ:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::eq(lhs, rhs));\n        case Sass_OP::NEQ: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::neq(lhs, rhs));\n        case Sass_OP::GT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gt(lhs, rhs));\n        case Sass_OP::GTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gte(lhs, rhs));\n        case Sass_OP::LT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lt(lhs, rhs));\n        case Sass_OP::LTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lte(lhs, rhs));\n        default: break;\n      }\n    }\n    catch (Exception::OperationError& err)\n    {\n      traces.push_back(Backtrace(b->pstate()));\n      throw Exception::SassValueError(traces, b->pstate(), err);\n    }\n\n    l_type = lhs->concrete_type();\n    r_type = rhs->concrete_type();\n\n    // ToDo: throw error in op functions\n    // ToDo: then catch and re-throw them\n    Expression_Obj rv;\n    try {\n      ParserState pstate(b->pstate());\n      if (l_type == Expression::NUMBER && r_type == Expression::NUMBER) {\n        Number* l_n = Cast<Number>(lhs);\n        Number* r_n = Cast<Number>(rhs);\n        l_n->reduce(); r_n->reduce();\n        rv = Operators::op_numbers(op_type, *l_n, *r_n, options(), pstate);\n      }\n      else if (l_type == Expression::NUMBER && r_type == Expression::COLOR) {\n        Number* l_n = Cast<Number>(lhs);\n        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();\n        rv = Operators::op_number_color(op_type, *l_n, *r_c, options(), pstate);\n      }\n      else if (l_type == Expression::COLOR && r_type == Expression::NUMBER) {\n        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();\n        Number* r_n = Cast<Number>(rhs);\n        rv = Operators::op_color_number(op_type, *l_c, *r_n, options(), pstate);\n      }\n      else if (l_type == Expression::COLOR && r_type == Expression::COLOR) {\n        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();\n        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();\n        rv = Operators::op_colors(op_type, *l_c, *r_c, options(), pstate);\n      }\n      else {\n        To_Value to_value(ctx);\n        // this will leak if perform does not return a value!\n        Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));\n        Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));\n        bool interpolant = b->is_right_interpolant() ||\n                           b->is_left_interpolant() ||\n                           b->is_interpolant();\n        if (op_type == Sass_OP::SUB) interpolant = false;\n        // if (op_type == Sass_OP::DIV) interpolant = true;\n        // check for type violations\n        if (l_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {\n          traces.push_back(Backtrace(v_l->pstate()));\n          throw Exception::InvalidValue(traces, *v_l);\n        }\n        if (r_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {\n          traces.push_back(Backtrace(v_r->pstate()));\n          throw Exception::InvalidValue(traces, *v_r);\n        }\n        Value* ex = Operators::op_strings(b->op(), *v_l, *v_r, options(), pstate, !interpolant); // pass true to compress\n        if (String_Constant* str = Cast<String_Constant>(ex))\n        {\n          if (str->concrete_type() == Expression::STRING)\n          {\n            String_Constant* lstr = Cast<String_Constant>(lhs);\n            String_Constant* rstr = Cast<String_Constant>(rhs);\n            if (op_type != Sass_OP::SUB) {\n              if (String_Constant* org = lstr ? lstr : rstr)\n              { str->quote_mark(org->quote_mark()); }\n            }\n          }\n        }\n        ex->is_interpolant(b->is_interpolant());\n        rv = ex;\n      }\n    }\n    catch (Exception::OperationError& err)\n    {\n      traces.push_back(Backtrace(b->pstate()));\n      // throw Exception::Base(b->pstate(), err.what());\n      throw Exception::SassValueError(traces, b->pstate(), err);\n    }\n\n    if (rv) {\n      if (schema_op) {\n        // XXX: this is never hit via spec tests\n        (*s2)[0] = rv;\n        rv = s2->perform(this);\n      }\n    }\n\n    return rv.detach();\n\n  }""}]","{""function"": 4, ""code"": 1, ""value"": 2, ""caller"": 1}","[{""source"": ""func_info(file:ast_sel_weave.cpp, func:weaveParents)"", ""result"": [{""code"": ""  std::vector<std::vector<SelectorComponentObj>> weaveParents(\n    std::vector<SelectorComponentObj> queue1,\n    std::vector<SelectorComponentObj> queue2)\n  {\n\n    std::vector<SelectorComponentObj> leads;\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> trails;\n    if (!mergeInitialCombinators(queue1, queue2, leads)) return {};\n    if (!mergeFinalCombinators(queue1, queue2, trails)) return {};\n    // list comes out in reverse order for performance\n    std::reverse(trails.begin(), trails.end());\n\n    // Make sure there's at most one `:root` in the output.\n    // Note: does not yet do anything in libsass (no root selector)\n    CompoundSelectorObj root1 = getFirstIfRoot(queue1);\n    CompoundSelectorObj root2 = getFirstIfRoot(queue2);\n\n    if (!root1.isNull() && !root2.isNull()) {\n      CompoundSelectorObj root = root1->unifyWith(root2);\n      if (root.isNull()) return {}; // null\n      queue1.insert(queue1.begin(), root);\n      queue2.insert(queue2.begin(), root);\n    }\n    else if (!root1.isNull()) {\n      queue2.insert(queue2.begin(), root1);\n    }\n    else if (!root2.isNull()) {\n      queue1.insert(queue1.begin(), root2);\n    }\n\n    // group into sub-lists so no sub-list contains two adjacent ComplexSelectors.\n    std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);\n    std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);\n\n    // The main array to store our choices that will be permutated\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;\n\n    // append initial combinators\n    choices.push_back({ leads });\n\n    std::vector<std::vector<SelectorComponentObj>> LCS =\n      lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);\n\n    for (auto group : LCS) {\n\n      // Create junks from groups1 and groups2\n      std::vector<std::vector<std::vector<SelectorComponentObj>>>\n        chunks = getChunks<std::vector<SelectorComponentObj>>(\n          groups1, groups2, group, cmpChunkForParentSuperselector);\n\n      // Create expanded array by flattening chunks2 inner\n      std::vector<std::vector<SelectorComponentObj>>\n        expanded = flattenInner(chunks);\n\n      // Prepare data structures\n      choices.push_back(expanded);\n      choices.push_back({ group });\n      groups1.erase(groups1.begin());\n      groups2.erase(groups2.begin());\n\n    }\n\n    // Create junks from groups1 and groups2\n    std::vector<std::vector<std::vector<SelectorComponentObj>>>\n      chunks = getChunks<std::vector<SelectorComponentObj>>(\n        groups1, groups2, {}, cmpChunkForEmptySequence);\n\n    // Append chunks with inner arrays flattened\n    choices.emplace_back(flattenInner(chunks));\n\n    // append all trailing selectors to choices\n    std::move(std::begin(trails), std::end(trails),\n      std::inserter(choices, std::end(choices)));\n\n    // move all non empty items to the front, then erase the trailing ones\n    choices.erase(std::remove_if(choices.begin(), choices.end(), checkForEmptyChild\n      <std::vector<std::vector<SelectorComponentObj>>>), choices.end());\n\n    // permutate all possible paths through selectors\n    std::vector<std::vector<SelectorComponentObj>>\n      results = flattenInner(permutate(choices));\n\n    return results;\n\n  }\n"", ""start_line"": 522, ""end_line"": 606, ""full_name"": ""Sass.weaveParents:vector(std.vector,std.vector)"", ""file_path"": ""src/ast_sel_weave.cpp""}]}, {""source"": ""code_info(file:ast_sel_weave.cpp, lines:550-576)"", ""result"": ""    }\n\n    // group into sub-lists so no sub-list contains two adjacent ComplexSelectors.\n    std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);\n    std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);\n\n    // The main array to store our choices that will be permutated\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;\n\n    // append initial combinators\n    choices.push_back({ leads });\n\n    std::vector<std::vector<SelectorComponentObj>> LCS =\n      lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);\n\n    for (auto group : LCS) {\n\n      // Create junks from groups1 and groups2\n      std::vector<std::vector<std::vector<SelectorComponentObj>>>\n        chunks = getChunks<std::vector<SelectorComponentObj>>(\n          groups1, groups2, group, cmpChunkForParentSuperselector);\n\n      // Create expanded array by flattening chunks2 inner\n      std::vector<std::vector<SelectorComponentObj>>\n        expanded = flattenInner(chunks);\n\n      // Prepare data structures\n      choices.push_back(expanded);\n""}, {""source"": ""value_info(file:ast_sel_weave.cpp, value:groups1)"", ""result"": {""value_trace"": [{""full_code"": ""std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1)"", ""line"": 553, ""func_name"": ""Sass.weaveParents:vector(std.vector,std.vector)""}], ""struct_var"": ""groups1"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""value_info(file:ast_sel_weave.cpp, value:groups2)"", ""result"": {""value_trace"": [{""full_code"": ""std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2)"", ""line"": 554, ""func_name"": ""Sass.weaveParents:vector(std.vector,std.vector)""}], ""struct_var"": ""groups2"", ""struct_type"": ""ANY"", ""struct_definition"": ""ANY""}}, {""source"": ""func_info(func:last)"", ""result"": [{""code"": ""T& last()               { return elements_.back(); }"", ""start_line"": 229, ""end_line"": 229, ""full_name"": ""Sass.Vectorized.last:ANY()"", ""file_path"": ""src/ast.hpp""}, {""code"": ""const T& last() const   { return elements_.back(); }"", ""start_line"": 231, ""end_line"": 231, ""full_name"": ""Sass.Vectorized.last:ANY()<const>"", ""file_path"": ""src/ast.hpp""}]}, {""source"": ""func_info(file:ast_sel_weave.cpp, func:groupSelectors)"", ""result"": [{""code"": ""std::vector<std::vector<SelectorComponentObj>> groupSelectors(\n    const std::vector<SelectorComponentObj>& components)\n  {\n    bool lastWasCompound = false;\n    std::vector<SelectorComponentObj> group;\n    std::vector<std::vector<SelectorComponentObj>> groups;\n    for (size_t i = 0; i < components.size(); i += 1) {\n      if (CompoundSelector* compound = components[i]->getCompound()) {\n        if (lastWasCompound) {\n          groups.push_back(group);\n          group.clear();\n        }\n        group.push_back(compound);\n        lastWasCompound = true;\n      }\n      else if (SelectorCombinator* combinator = components[i]->getCombinator()) {\n        group.push_back(combinator);\n        lastWasCompound = false;\n      }\n    }\n    if (!group.empty()) {\n      groups.push_back(group);\n    }\n    return groups;\n  }"", ""start_line"": 213, ""end_line"": 237, ""full_name"": ""Sass.groupSelectors:vector(std.vector&)"", ""file_path"": ""src/ast_sel_weave.cpp""}]}, {""source"": ""func_info(file:ast_sel_weave.cpp, func:weaveParents)"", ""result"": [{""code"": ""  std::vector<std::vector<SelectorComponentObj>> weaveParents(\n    std::vector<SelectorComponentObj> queue1,\n    std::vector<SelectorComponentObj> queue2)\n  {\n\n    std::vector<SelectorComponentObj> leads;\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> trails;\n    if (!mergeInitialCombinators(queue1, queue2, leads)) return {};\n    if (!mergeFinalCombinators(queue1, queue2, trails)) return {};\n    // list comes out in reverse order for performance\n    std::reverse(trails.begin(), trails.end());\n\n    // Make sure there's at most one `:root` in the output.\n    // Note: does not yet do anything in libsass (no root selector)\n    CompoundSelectorObj root1 = getFirstIfRoot(queue1);\n    CompoundSelectorObj root2 = getFirstIfRoot(queue2);\n\n    if (!root1.isNull() && !root2.isNull()) {\n      CompoundSelectorObj root = root1->unifyWith(root2);\n      if (root.isNull()) return {}; // null\n      queue1.insert(queue1.begin(), root);\n      queue2.insert(queue2.begin(), root);\n    }\n    else if (!root1.isNull()) {\n      queue2.insert(queue2.begin(), root1);\n    }\n    else if (!root2.isNull()) {\n      queue1.insert(queue1.begin(), root2);\n    }\n\n    // group into sub-lists so no sub-list contains two adjacent ComplexSelectors.\n    std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1);\n    std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2);\n\n    // The main array to store our choices that will be permutated\n    std::vector<std::vector<std::vector<SelectorComponentObj>>> choices;\n\n    // append initial combinators\n    choices.push_back({ leads });\n\n    std::vector<std::vector<SelectorComponentObj>> LCS =\n      lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups);\n\n    for (auto group : LCS) {\n\n      // Create junks from groups1 and groups2\n      std::vector<std::vector<std::vector<SelectorComponentObj>>>\n        chunks = getChunks<std::vector<SelectorComponentObj>>(\n          groups1, groups2, group, cmpChunkForParentSuperselector);\n\n      // Create expanded array by flattening chunks2 inner\n      std::vector<std::vector<SelectorComponentObj>>\n        expanded = flattenInner(chunks);\n\n      // Prepare data structures\n      choices.push_back(expanded);\n      choices.push_back({ group });\n      groups1.erase(groups1.begin());\n      groups2.erase(groups2.begin());\n\n    }\n\n    // Create junks from groups1 and groups2\n    std::vector<std::vector<std::vector<SelectorComponentObj>>>\n      chunks = getChunks<std::vector<SelectorComponentObj>>(\n        groups1, groups2, {}, cmpChunkForEmptySequence);\n\n    // Append chunks with inner arrays flattened\n    choices.emplace_back(flattenInner(chunks));\n\n    // append all trailing selectors to choices\n    std::move(std::begin(trails), std::end(trails),\n      std::inserter(choices, std::end(choices)));\n\n    // move all non empty items to the front, then erase the trailing ones\n    choices.erase(std::remove_if(choices.begin(), choices.end(), checkForEmptyChild\n      <std::vector<std::vector<SelectorComponentObj>>>), choices.end());\n\n    // permutate all possible paths through selectors\n    std::vector<std::vector<SelectorComponentObj>>\n      results = flattenInner(permutate(choices));\n\n    return results;\n\n  }\n"", ""start_line"": 522, ""end_line"": 606, ""full_name"": ""Sass.weaveParents:vector(std.vector,std.vector)"", ""file_path"": ""src/ast_sel_weave.cpp""}]}, {""source"": ""caller_info(file:ast_sel_weave.cpp, func:weaveParents)"", ""result"": [{""call_line"": 494, ""call_code"": ""weaveParents(prefix, parents)"", ""caller_code"": ""  std::vector<std::vector<SelectorComponentObj>> weave(\n    const std::vector<std::vector<SelectorComponentObj>>& complexes) {\n\n    std::vector<std::vector<SelectorComponentObj>> prefixes;\n\n    prefixes.push_back(complexes.at(0));\n\n    for (size_t i = 1; i < complexes.size(); i += 1) {\n\n      if (complexes[i].empty()) {\n        continue;\n      }\n      const std::vector<SelectorComponentObj>& complex = complexes[i];\n      SelectorComponent* target = complex.back();\n      if (complex.size() == 1) {\n        for (auto& prefix : prefixes) {\n          prefix.push_back(target);\n        }\n        continue;\n      }\n\n      std::vector<SelectorComponentObj> parents(complex);\n\n      parents.pop_back();\n\n      std::vector<std::vector<SelectorComponentObj>> newPrefixes;\n      for (std::vector<SelectorComponentObj> prefix : prefixes) {\n        std::vector<std::vector<SelectorComponentObj>>\n          parentPrefixes = weaveParents(prefix, parents);\n        if (parentPrefixes.empty()) continue;\n        for (auto& parentPrefix : parentPrefixes) {\n          parentPrefix.push_back(target);\n          newPrefixes.push_back(parentPrefix);\n        }\n      }\n      prefixes = newPrefixes;\n\n    }\n    return prefixes;\n\n  }\n"", ""caller_start"": 466, ""file_path"": ""src/ast_sel_weave.cpp""}]}]",src/ast_sel_weave.cpp:577-578 (groups1/groups2 erase without empty check) → src/ast_sel_weave.cpp:553-554 (groups1/groups2 initialized via groupSelectors(queue1/queue2)) → src/ast_sel_weave.cpp:213-237 (groupSelectors returns empty if input components are empty) → src/ast_sel_weave.cpp:494 (weaveParents called with potentially empty queues from weave function).,0.95,./github/other_context/CVE-2019-18798
31,CVE-2019-20163,"CWE-416, CWE-476",c_cpp,An issue was discovered in GPAC version 0.8.0 and 0.9.0-development-20191109. There is a NULL pointer dereference in the function gf_odf_avc_cfg_write_bs() in odf/descriptors.c.,https://github.com/gpac/gpac/commit/5250afecbc770c8f26829e9566d5b226a3c5fa80,"fix some memory issues:\n\nfixes #1330, #1331, #1332, #1333, #1335, #1338",4,"[{""func_name"": ""ilst_item_Read"", ""file_path"": ""src/isomedia/box_code_apple.c"", ""func_code"": ""GF_Err ilst_item_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a = NULL;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\t/*iTunes way: there's a data atom containing the data*/\n\tsub_type = gf_bs_peek_bits(bs, 32, 4);\n\tif (sub_type == GF_ISOM_BOX_TYPE_DATA ) {\n\t\te = gf_isom_box_parse(&a, bs);\n\n\t\tif (!e && ptr->size < a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\"", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\n\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\n\t\tif (a && ptr->data) gf_isom_box_del((GF_Box *) ptr->data);\n\n\t\t/* otherwise a->data will always overflow */\n\t\tif (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID)\n\t\t\tptr->data = (GF_DataBox *)a;\n\t\telse {\n\t\t\tptr->data = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t}\n\t/*QT way*/\n\telse {\n\t\tptr->data->type = 0;\n\t\tptr->data->dataSize = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\t\tptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));\n\t\tgf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->data->data[ptr->data->dataSize] = 0;\n\t\tISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);\n\t}\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""tenc_Read"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err tenc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\n\tgf_bs_read_u8(bs); //reserved\n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); //reserved\n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\tptr->Per_Sample_IV_Size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, (char *) ptr->KID, 16);\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\n\tif ((ptr->isProtected == 1) && !ptr->Per_Sample_IV_Size) {\n\t\tptr->constant_IV_size = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tISOM_DECREASE_SIZE(ptr, (1 + ptr->constant_IV_size) );\n\n\t}\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""senc_Parse"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tu32 i, j, count, sample_number;\n\tu64 pos = gf_bs_get_position(bs);\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tsample_number = 1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (trak) sample_number += trak->sample_count_at_seg_start;\n#endif\n\tcount = gf_bs_read_u32(bs);\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tu32 is_encrypted;\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));\n\t\tmemset(sai, 0, sizeof(GF_CENCSampleAuxInfo));\n\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_ex(trak, traf, senc, sample_number, &is_encrypted, &sai->IV_size, NULL, NULL, NULL, NULL, NULL);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isobmf] could not get cenc info for sample %d: %s\\n\"", sample_number, gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size 16\\n\"" ));\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tsai->IV_size = 16;\n\t\t}\n\t\tsample_number++;\n\n\t\t//subsample info is only signaled for encrypted samples\n\t\tif (is_encrypted) {\n\t\t\tif (sai->IV_size)\n\t\t\t\tgf_bs_read_data(bs, (char *)sai->IV, sai->IV_size);\n\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tsai->subsample_count = gf_bs_read_u16(bs);\n\t\t\t\tsai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));\n\t\t\t\tfor (j = 0; j < sai->subsample_count; j++) {\n\t\t\t\t\tif (gf_bs_get_size(bs) - gf_bs_get_position(bs) < 6) {\n\t\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\t\tif (trak->moov->mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] Failed to parse SENC box, invalid SAI size\\n\"" ));\n\t\t\t\t\t\t\treturn GF_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tsai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);\n\t\t\t\t\tsai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""gf_odf_avc_cfg_write_bs"", ""file_path"": ""src/odf/descriptors.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_odf_avc_cfg_write_bs(GF_AVCConfig *cfg, GF_BitStream *bs)\n{\n\tu32 i, count;\n\n\tcount = gf_list_count(cfg->sequenceParameterSets);\n\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, cfg->configurationVersion, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCProfileIndication , 8);\n\t\tgf_bs_write_int(bs, cfg->profile_compatibility, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCLevelIndication, 8);\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t\tgf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);\n\t\tgf_bs_write_int(bs, 0x7, 3);\n\t\tgf_bs_write_int(bs, count, 5);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_list_get(cfg->sequenceParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tcount = gf_list_count(cfg->pictureParameterSets);\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, count, 8);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_list_get(cfg->pictureParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tif (gf_avc_is_rext_profile(cfg->AVCProfileIndication)) {\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_bit_depth - 8, 3);\n\t\t}\n\t\tcount = cfg->sequenceParameterSetExtensions ? gf_list_count(cfg->sequenceParameterSetExtensions) : 0;\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(cfg->sequenceParameterSetExtensions, i);\n\t\t\tif (!cfg->write_annex_b) {\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t}\n\t}\n\treturn GF_OK;\n}"", ""target"": 0}]","[{""func_name"": ""ilst_item_Read"", ""file_path"": ""src/isomedia/box_code_apple.c"", ""func_code"": ""GF_Err ilst_item_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a = NULL;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\t/*iTunes way: there's a data atom containing the data*/\n\tsub_type = gf_bs_peek_bits(bs, 32, 4);\n\tif (sub_type == GF_ISOM_BOX_TYPE_DATA ) {\n\t\te = gf_isom_box_parse(&a, bs);\n\n\t\tif (!e && a && ptr->size < a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\"", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (!a) e = GF_ISOM_INVALID_FILE;\n\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\n\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\n\t\tif (a && ptr->data) gf_isom_box_del((GF_Box *) ptr->data);\n\n\t\t/* otherwise a->data will always overflow */\n\t\tif (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID)\n\t\t\tptr->data = (GF_DataBox *)a;\n\t\telse {\n\t\t\tptr->data = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t}\n\t/*QT way*/\n\telse {\n\t\tptr->data->type = 0;\n\t\tptr->data->dataSize = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\t\tptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));\n\t\tgf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->data->data[ptr->data->dataSize] = 0;\n\t\tISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);\n\t}\n\treturn GF_OK;\n}""}, {""func_name"": ""tenc_Read"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err tenc_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\n\tgf_bs_read_u8(bs); //reserved\n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); //reserved\n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\tptr->Per_Sample_IV_Size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, (char *) ptr->KID, 16);\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\n\tif ((ptr->isProtected == 1) && !ptr->Per_Sample_IV_Size) {\n\t\tptr->constant_IV_size = gf_bs_read_u8(bs);\n\t\tif (ptr->constant_IV_size > sizeof(ptr->constant_IV))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tgf_bs_read_data(bs, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tISOM_DECREASE_SIZE(ptr, (1 + ptr->constant_IV_size) );\n\n\t}\n\treturn GF_OK;\n}""}, {""func_name"": ""senc_Parse"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tu32 i, j, count, sample_number;\n\tu64 pos = gf_bs_get_position(bs);\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tsample_number = 1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (trak) sample_number += trak->sample_count_at_seg_start;\n#endif\n\tcount = gf_bs_read_u32(bs);\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tu32 is_encrypted;\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));\n\t\tmemset(sai, 0, sizeof(GF_CENCSampleAuxInfo));\n\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_ex(trak, traf, senc, sample_number, &is_encrypted, &sai->IV_size, NULL, NULL, NULL, NULL, NULL);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isobmf] could not get cenc info for sample %d: %s\\n\"", sample_number, gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size 16\\n\"" ));\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tsai->IV_size = 16;\n\t\t}\n\t\tsample_number++;\n\n\t\t//subsample info is only signaled for encrypted samples\n\t\tif (is_encrypted) {\n\t\t\tif (sai->IV_size)\n\t\t\t\tgf_bs_read_data(bs, (char *)sai->IV, sai->IV_size);\n\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tsai->subsample_count = gf_bs_read_u16(bs);\n\t\t\t\tsai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));\n\t\t\t\tfor (j = 0; j < sai->subsample_count; j++) {\n\t\t\t\t\tif (gf_bs_get_size(bs) - gf_bs_get_position(bs) < 6) {\n\t\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\t\tif (trak && trak->moov && trak->moov->mov && trak->moov->mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] Failed to parse SENC box, invalid SAI size\\n\"" ));\n\t\t\t\t\t\t\treturn GF_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tsai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);\n\t\t\t\t\tsai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n}""}, {""func_name"": ""gf_odf_avc_cfg_write_bs"", ""file_path"": ""src/odf/descriptors.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_odf_avc_cfg_write_bs(GF_AVCConfig *cfg, GF_BitStream *bs)\n{\n\tu32 i, count;\n\n\tif (!cfg) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(cfg->sequenceParameterSets);\n\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, cfg->configurationVersion, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCProfileIndication , 8);\n\t\tgf_bs_write_int(bs, cfg->profile_compatibility, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCLevelIndication, 8);\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t\tgf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);\n\t\tgf_bs_write_int(bs, 0x7, 3);\n\t\tgf_bs_write_int(bs, count, 5);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_list_get(cfg->sequenceParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tcount = gf_list_count(cfg->pictureParameterSets);\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, count, 8);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_list_get(cfg->pictureParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tif (gf_avc_is_rext_profile(cfg->AVCProfileIndication)) {\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_bit_depth - 8, 3);\n\t\t}\n\t\tcount = cfg->sequenceParameterSetExtensions ? gf_list_count(cfg->sequenceParameterSetExtensions) : 0;\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *) gf_list_get(cfg->sequenceParameterSetExtensions, i);\n\t\t\tif (!cfg->write_annex_b) {\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t}\n\t}\n\treturn GF_OK;\n}""}]","{""caller"": 2, ""value"": 1}","[{""source"": ""caller_info(file:descriptors.c, func:gf_odf_avc_cfg_write_bs)"", ""result"": [{""call_line"": 631, ""call_code"": ""gf_odf_avc_cfg_write_bs(cfg, bs)"", ""caller_code"": ""GF_Err gf_odf_avc_cfg_write(GF_AVCConfig *cfg, char **outData, u32 *outSize)\n{\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_odf_avc_cfg_write_bs(cfg, bs);\n\t*outSize = 0;\n\t*outData = NULL;\n\tgf_bs_get_content(bs, outData, outSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}"", ""caller_start"": 628, ""file_path"": ""src/odf/descriptors.c""}, {""call_line"": 351, ""call_code"": ""gf_odf_avc_cfg_write_bs(avcc->config, item_bs)"", ""caller_code"": ""GF_Err gf_isom_extract_meta_item_extended(GF_ISOFile *file, Bool root_meta, u32 track_num, u32 item_id, const char *dump_file_name, char **out_data, u32 *out_size, const char **out_mime, Bool use_annex_b)\n{\n\tGF_BitStream *item_bs;\n\tchar szPath[1024];\n\tGF_ItemExtentEntry *extent_entry;\n\tFILE *resource = NULL;\n\tu32 i, count;\n\tGF_ItemLocationEntry *location_entry;\n\tu32 item_num;\n\tu32 item_type = 0;\n\tu32 nalu_size_length = 0;\n\tu64 idat_offset = 0;\n\tchar *item_name = NULL;\n\n\tGF_MetaBox *meta = gf_isom_get_meta(file, root_meta, track_num);\n\tif (!meta || !meta->item_infos || !meta->item_locations) return GF_BAD_PARAM;\n\n\tif (out_mime) *out_mime = NULL;\n\n\titem_num = gf_isom_get_meta_item_by_id(file, root_meta, track_num, item_id);\n\tif (item_num) {\n\t\tGF_ItemInfoEntryBox *item_entry = (GF_ItemInfoEntryBox *)gf_list_get(meta->item_infos->item_infos, item_num-1);\n\t\titem_name = item_entry->item_name;\n\t\tif (out_mime) *out_mime = item_entry->content_type;\n\n\t\titem_type = item_entry->item_type;\n\t}\n\n\tlocation_entry = NULL;\n\tcount = gf_list_count(meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tlocation_entry = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, i);\n\t\tif (location_entry->item_ID == item_id) break;\n\t\tlocation_entry = NULL;\n\t}\n\n\t// switch (item_type) {\n\t// case GF_ISOM_SUBTYPE_HVC1:\n\t// case GF_ISOM_SUBTYPE_AVC_H264:\n\t// case GF_ISOM_SUBTYPE_JPEG:\n\t// \tbreak;\n\t// default:\n\t// \tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\""[IsoMedia] Extracting item type %s not supported\\n\"", gf_4cc_to_str(item_type) ));\n\t// \treturn GF_NOT_SUPPORTED;\n\t// }\n\n\tif (!location_entry) return GF_BAD_PARAM;\n\n\t/* offsets are expressed from the start of the idat box instead of the start of the file */\n\tif (location_entry->construction_method == 1) {\n\t\tint found = 0;\n\n\t\tcount = gf_list_count(meta->other_boxes);\n\t\tfor (i = 0; i <count; i++) {\n\t\t\tGF_Box *a = (GF_Box *)gf_list_get(meta->other_boxes, i);\n\n\t\t\tif (a->type == GF_ISOM_BOX_TYPE_IDAT) {\n\n\t\t\t\tGF_MediaDataBox *p = (GF_MediaDataBox *)a;\n\t\t\t\tidat_offset = p->bsOffset;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[IsoMedia] Item %d references an inexistant idat box\\n\"", item_num));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\t}\n\t/* when construction_method==1, data_reference_index is ignored */\n\t/*FIXME*/\n\telse if (location_entry->data_reference_index) {\n\t\tchar *item_url = NULL, *item_urn = NULL;\n\t\tGF_Box *a = (GF_Box *)gf_list_get(meta->file_locations->dref->other_boxes, location_entry->data_reference_index-1);\n\t\tif (a->type==GF_ISOM_BOX_TYPE_URL) {\n\t\t\titem_url = ((GF_DataEntryURLBox*)a)->location;\n\t\t} else if (a->type==GF_ISOM_BOX_TYPE_URN) {\n\t\t\titem_url = ((GF_DataEntryURNBox*)a)->location;\n\t\t\titem_urn = ((GF_DataEntryURNBox*)a)->nameURN;\n\t\t}\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\""[IsoMedia] Item already outside the ISO file at URL: %s, URN: %s\\n\"", (item_url?item_url:\""N/A\""), (item_urn?item_urn:\""N/A\"") ));\n\t\treturn GF_OK;\n\t}\n\n\t/*don't extract self-reference item*/\n\tcount = gf_list_count(location_entry->extent_entries);\n\tif (!location_entry->base_offset && (count==1)) {\n\t\textent_entry = (GF_ItemExtentEntry *)gf_list_get(location_entry->extent_entries, 0);\n\t\tif (!extent_entry->extent_length\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t        && !extent_entry->original_extent_offset\n#endif\n\t\t   ) return GF_BAD_PARAM;\n\t}\n\n\titem_bs = NULL;\n\n\n\tif (out_data) {\n\t\titem_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t} else if (dump_file_name) {\n\t\tstrcpy(szPath, dump_file_name);\n\t\tresource = gf_fopen(szPath, \""wb\"");\n\t\titem_bs = gf_bs_from_file(resource, GF_BITSTREAM_WRITE);\n\t} else {\n\t\tif (item_name && strlen(item_name) > 0) strcpy(szPath, item_name);\n\t\telse sprintf(szPath, \""item_id%02d\"", item_id);\n\t\tresource = gf_fopen(szPath, \""wb\"");\n\t\titem_bs = gf_bs_from_file(resource, GF_BITSTREAM_WRITE);\n\t}\n\n\tif ((item_type == GF_ISOM_SUBTYPE_HVC1) || (item_type == GF_ISOM_SUBTYPE_AVC_H264) ) {\n\t\tu32 i, count, j, c2;\n\t\tGF_HEVCConfigurationBox *hvcc = NULL;\n\t\tGF_AVCConfigurationBox *avcc = NULL;\n\t\tif (! meta->item_props) return GF_NON_COMPLIANT_BITSTREAM;\n\t\tif (! meta->item_props->property_container) return GF_NON_COMPLIANT_BITSTREAM;\n\t\tif (! meta->item_props->property_association) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tcount = gf_list_count(meta->item_props->property_association->entries);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ItemPropertyAssociationEntry *e = gf_list_get(meta->item_props->property_association->entries, i);\n\t\t\tif (e->item_id!=item_id) continue;\n\t\t\tc2 = gf_list_count(e->property_index);\n\t\t\tfor (j=0; j<c2; j++) {\n\t\t\t\tu32 *idx = gf_list_get(e->property_index, j);\n\t\t\t\tif (! (*idx) ) continue;\n\t\t\t\thvcc = gf_list_get(meta->item_props->property_container->other_boxes, (*idx) - 1);\n\t\t\t\tif (!hvcc) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tif (hvcc->type == GF_ISOM_BOX_TYPE_HVCC) break;\n\t\t\t\tif (hvcc->type == GF_ISOM_BOX_TYPE_AVCC) {\n\t\t\t\t\tavcc = (GF_AVCConfigurationBox *) hvcc;\n\t\t\t\t\thvcc = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (avcc || hvcc) break;\n\t\t}\n\t\tif (hvcc) {\n\t\t\tif (! hvcc->config) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Missing HEVC config in hvcC\\n\""));\n\t\t\t} else {\n\t\t\t\tif (use_annex_b) {\n\t\t\t\t\thvcc->config->write_annex_b = GF_TRUE;\n\t\t\t\t\tgf_odf_hevc_cfg_write_bs(hvcc->config, item_bs);\n\t\t\t\t\thvcc->config->write_annex_b = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tnalu_size_length = hvcc->config->nal_unit_size;\n\t\t\t}\n\t\t} else if (avcc) {\n\t\t\tif (! avcc->config) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Missing AVC config in avcC\\n\""));\n\t\t\t} else {\n\t\t\t\tif (use_annex_b) {\n\t\t\t\t\tavcc->config->write_annex_b = GF_TRUE;\n\t\t\t\t\tgf_odf_avc_cfg_write_bs(avcc->config, item_bs);\n\t\t\t\t\tavcc->config->write_annex_b = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tnalu_size_length = avcc->config->nal_unit_size;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tchar buf_cache[4096];\n\t\tu64 remain;\n\t\tGF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_list_get(location_entry->extent_entries, i);\n\t\tgf_bs_seek(file->movieFileMap->bs, idat_offset + location_entry->base_offset + extent_entry->extent_offset);\n\n\t\tremain = extent_entry->extent_length;\n\t\twhile (remain) {\n\t\t\tif (nalu_size_length) {\n\t\t\t\tu32 nal_size = gf_bs_read_int(file->movieFileMap->bs, 8*nalu_size_length);\n\t\t\t\tassert(remain>nalu_size_length);\n\n\t\t\t\tif (use_annex_b)\n\t\t\t\t\tgf_bs_write_u32(item_bs, 1);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_int(item_bs, nal_size, 8*nalu_size_length);\n\n\t\t\t\tremain -= nalu_size_length + nal_size;\n\t\t\t\twhile (nal_size) {\n\t\t\t\t\tu32 cache_size = (nal_size>4096) ? 4096 : (u32) nal_size;\n\n\t\t\t\t\tgf_bs_read_data(file->movieFileMap->bs, buf_cache, cache_size);\n\t\t\t\t\tgf_bs_write_data(item_bs, buf_cache, cache_size);\n\t\t\t\t\tnal_size -= cache_size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 cache_size = (remain>4096) ? 4096 : (u32) remain;\n\t\t\t\tgf_bs_read_data(file->movieFileMap->bs, buf_cache, cache_size);\n\t\t\t\tgf_bs_write_data(item_bs, buf_cache, cache_size);\n\t\t\t\tremain -= cache_size;\n\t\t\t}\n\t\t}\n\t}\n\tif (out_data) {\n\t\tgf_bs_get_content(item_bs, out_data, out_size);\n\t}\n\tif (resource) {\n\t\tgf_fclose(resource);\n\t}\n\tgf_bs_del(item_bs);\n\treturn GF_OK;\n}\n"", ""caller_start"": 195, ""file_path"": ""src/isomedia/meta.c""}]}, {""source"": ""caller_info(file:descriptors.c, func:gf_odf_avc_cfg_write)"", ""result"": [{""call_line"": 260, ""call_code"": ""gf_odf_avc_cfg_write(cfg, &dsi_data, &dsi_data_size)"", ""caller_code"": ""static GF_Err VTBDec_InitDecoder(VTBDec *ctx)\n{\n\tCFMutableDictionaryRef dec_dsi, dec_type;\n\tCFMutableDictionaryRef dsi;\n\tVTDecompressionOutputCallbackRecord cbacks;\n    CFDictionaryRef buffer_attribs;\n    OSStatus status;\n\tOSType kColorSpace;\n\t\n\tCFDataRef data = NULL;\n\tchar *dsi_data=NULL;\n\tu32 dsi_data_size=0;\n\t\n    dec_dsi = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n\t\n//\tkColorSpace = kCVPixelFormatType_420YpCbCr8Planar;\n//\tctx->pix_fmt = GF_PIXEL_YV12;\n\n\tkColorSpace = kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange;\n\tctx->pix_fmt = GF_PIXEL_NV12;\n\t\n\tswitch (ctx->esd->decoderConfig->objectTypeIndication) {\n    case GPAC_OTI_VIDEO_AVC :\n\t\tif (gf_list_count(ctx->SPSs) && gf_list_count(ctx->PPSs)) {\n\t\t\ts32 idx;\n\t\t\tu32 i;\n\t\t\tGF_AVCConfig *cfg;\n\t\t\tGF_AVCConfigSlot *sps = NULL;\n\t\t\tGF_AVCConfigSlot *pps = NULL;\n\n\t\t\tfor (i=0; i<gf_list_count(ctx->SPSs); i++) {\n\t\t\t\tsps = gf_list_get(ctx->SPSs, i);\n\t\t\t\tif (ctx->active_sps<0) ctx->active_sps = sps->id;\n\n\t\t\t\tif (sps->id==ctx->active_sps) break;\n\t\t\t\tsps = NULL;\n\t\t\t}\n\t\t\tif (!sps) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tfor (i=0; i<gf_list_count(ctx->PPSs); i++) {\n\t\t\t\tpps = gf_list_get(ctx->PPSs, i);\n\t\t\t\tif (ctx->active_pps<0) ctx->active_pps = pps->id;\n\n\t\t\t\tif (pps->id==ctx->active_pps) break;\n\t\t\t\tpps = NULL;\n\t\t\t}\n\t\t\tif (!pps) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tctx->reconfig_needed = GF_FALSE;\n\t\t\t\n\t\t\tctx->vtb_type = kCMVideoCodecType_H264;\n\n\t\t\tidx = ctx->active_sps;\n\t\t\tctx->width = ctx->avc.sps[idx].width;\n\t\t\tctx->height = ctx->avc.sps[idx].height;\n\t\t\tif (ctx->avc.sps[idx].vui.par_num && ctx->avc.sps[idx].vui.par_den) {\n\t\t\t\tctx->pixel_ar = ctx->avc.sps[idx].vui.par_num;\n\t\t\t\tctx->pixel_ar <<= 16;\n\t\t\t\tctx->pixel_ar |= ctx->avc.sps[idx].vui.par_den;\n\t\t\t}\n\t\t\tctx->chroma_format = ctx->avc.sps[idx].chroma_format;\n\t\t\tctx->luma_bit_depth = 8 + ctx->avc.sps[idx].luma_bit_depth_m8;\n\t\t\tctx->chroma_bit_depth = 8 + ctx->avc.sps[idx].chroma_bit_depth_m8;\n\t\t\n\t\t\tswitch (ctx->chroma_format) {\n\t\t\tcase 2:\n\t\t\t\t//422 decoding doesn't seem supported ...\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_422YpCbCr10;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV422_10;\n\t\t\t\t} else {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_422YpCbCr8;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV422;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_444YpCbCr10;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV444_10;\n\t\t\t\t} else {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_444YpCbCr8;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV444;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YV12_10;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//always rewrite with cirrent sps and pps\n\t\t\tcfg = gf_odf_avc_cfg_new();\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->profile_compatibility = ctx->avc.sps[idx].prof_compat;\n\t\t\tcfg->AVCProfileIndication = ctx->avc.sps[idx].profile_idc;\n\t\t\tcfg->AVCLevelIndication = ctx->avc.sps[idx].level_idc;\n\t\t\tcfg->chroma_format = ctx->avc.sps[idx].chroma_format;\n\t\t\tcfg->luma_bit_depth = 8 + ctx->avc.sps[idx].luma_bit_depth_m8;\n\t\t\tcfg->chroma_bit_depth = 8 + ctx->avc.sps[idx].chroma_bit_depth_m8;\n\t\t\tcfg->nal_unit_size = 4;\n\t\t\t\t\n\t\t\tgf_list_add(cfg->sequenceParameterSets, sps);\n\t\t\t//we send all PPS\n\t\t\tgf_list_del(cfg->pictureParameterSets);\n\t\t\tcfg->pictureParameterSets = ctx->PPSs;\n\n\t\t\tgf_odf_avc_cfg_write(cfg, &dsi_data, &dsi_data_size);\n\t\t\tgf_list_reset(cfg->sequenceParameterSets);\n\t\t\tcfg->pictureParameterSets = NULL;\n\t\t\tgf_odf_avc_cfg_del((cfg));\n\t\t\t\n\t\t\tdsi = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n\t\t\tdata = CFDataCreate(kCFAllocatorDefault, (const UInt8*)dsi_data, dsi_data_size);\n\t\t\tif (data) {\n\t\t\t\tCFDictionarySetValue(dsi, CFSTR(\""avcC\""), data);\n\t\t\t\tCFDictionarySetValue(dec_dsi, kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms, dsi);\n\t\t\t\tCFRelease(data);\n\t\t\t}\n\t\t\tCFRelease(dsi);\n\t\t\n\t\t\tgf_free(dsi_data);\n\t\t}\n        break;\n\n    case GPAC_OTI_VIDEO_HEVC:\n\t\tif (gf_list_count(ctx->SPSs) && gf_list_count(ctx->PPSs) && gf_list_count(ctx->VPSs)) {\n\t\t\ts32 idx;\n\t\t\tu32 i;\n\t\t\tGF_HEVCConfig *cfg;\n\t\t\tGF_HEVCParamArray *vpsa = NULL;\n\t\t\tGF_HEVCParamArray *spsa = NULL;\n\t\t\tGF_HEVCParamArray *ppsa = NULL;\n\t\t\tGF_AVCConfigSlot *vps = NULL;\n\t\t\tGF_AVCConfigSlot *sps = NULL;\n\t\t\tGF_AVCConfigSlot *pps = NULL;\n\n\t\t\tfor (i=0; i<gf_list_count(ctx->VPSs); i++) {\n\t\t\t\tvps = gf_list_get(ctx->VPSs, i);\n\t\t\t\tif (ctx->active_vps<0) ctx->active_vps = vps->id;\n\n\t\t\t\tif (vps->id==ctx->active_vps) break;\n\t\t\t\tvps = NULL;\n\t\t\t}\n\t\t\tif (!vps) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\t\tfor (i=0; i<gf_list_count(ctx->SPSs); i++) {\n\t\t\t\tsps = gf_list_get(ctx->SPSs, i);\n\t\t\t\tif (ctx->active_sps<0) ctx->active_sps = sps->id;\n\n\t\t\t\tif (sps->id==ctx->active_sps) break;\n\t\t\t\tsps = NULL;\n\t\t\t}\n\t\t\tif (!sps) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tfor (i=0; i<gf_list_count(ctx->PPSs); i++) {\n\t\t\t\tpps = gf_list_get(ctx->PPSs, i);\n\t\t\t\tif (ctx->active_pps<0) ctx->active_pps = pps->id;\n\n\t\t\t\tif (pps->id==ctx->active_pps) break;\n\t\t\t\tpps = NULL;\n\t\t\t}\n\t\t\tif (!pps) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tctx->reconfig_needed = GF_FALSE;\n\n\t\t\tctx->vtb_type = kCMVideoCodecType_HEVC;\n\n\t\t\tidx = ctx->active_sps;\n\t\t\tctx->width = ctx->hevc.sps[idx].width;\n\t\t\tctx->height = ctx->hevc.sps[idx].height;\n\t\t\tif (ctx->hevc.sps[idx].aspect_ratio_info_present_flag && ctx->hevc.sps[idx].sar_width && ctx->hevc.sps[idx].sar_height) {\n\t\t\t\tctx->pixel_ar = ctx->hevc.sps[idx].sar_width;\n\t\t\t\tctx->pixel_ar <<= 16;\n\t\t\t\tctx->pixel_ar |= ctx->hevc.sps[idx].sar_height;\n\t\t\t}\n\t\t\tctx->chroma_format = ctx->hevc.sps[idx].chroma_format_idc;\n\t\t\tctx->luma_bit_depth = ctx->hevc.sps[idx].bit_depth_luma;\n\t\t\tctx->chroma_bit_depth = ctx->hevc.sps[idx].bit_depth_chroma;\n\n\t\t\tswitch (ctx->chroma_format) {\n\t\t\tcase 2:\n#ifndef GPAC_IPHONE\n\t\t\t\t//422 decoding doesn't seem supported ...\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_422YpCbCr10;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV422_10;\n\t\t\t\t} else\n#endif\n\t\t\t\t{\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_422YpCbCr8;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV422;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n#ifndef GPAC_IPHONE\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_444YpCbCr10;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV444_10;\n\t\t\t\t} else\n#endif\n\t\t\t\t{\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_444YpCbCr8;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_YUV444;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t//we disable support for 10bit output on ios and old OSX, defaulting back to 8 bits\n#if !defined(GPAC_IPHONE) && defined(AVAILABLE_MAC_OS_X_VERSION_10_13_AND_LATER)\n\t\t\t\tif (ctx->luma_bit_depth>8) {\n\t\t\t\t\tkColorSpace = kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange;\n\t\t\t\t\tctx->pix_fmt = GF_PIXEL_NV12_10;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//always rewrite with cirrent sps and pps\n\t\t\tcfg = gf_odf_hevc_cfg_new();\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->profile_space = ctx->hevc.sps[idx].ptl.profile_space;\n\t\t\tcfg->tier_flag = ctx->hevc.sps[idx].ptl.tier_flag;\n\t\t\tcfg->profile_idc = ctx->hevc.sps[idx].ptl.profile_idc;\n\t\t\tcfg->general_profile_compatibility_flags = ctx->hevc.sps[idx].ptl.profile_compatibility_flag;\n\t\t\tcfg->progressive_source_flag = ctx->hevc.sps[idx].ptl.general_progressive_source_flag;\n\t\t\tcfg->interlaced_source_flag = ctx->hevc.sps[idx].ptl.general_interlaced_source_flag;\n\t\t\tcfg->non_packed_constraint_flag = ctx->hevc.sps[idx].ptl.general_non_packed_constraint_flag;\n\t\t\tcfg->frame_only_constraint_flag = ctx->hevc.sps[idx].ptl.general_frame_only_constraint_flag;\n\n\t\t\tcfg->constraint_indicator_flags = ctx->hevc.sps[idx].ptl.general_reserved_44bits;\n\t\t\tcfg->level_idc = ctx->hevc.sps[idx].ptl.level_idc;\n\n\t\t\tcfg->luma_bit_depth = ctx->hevc.sps[idx].bit_depth_luma;\n\t\t\tcfg->chroma_bit_depth = ctx->hevc.sps[idx].bit_depth_chroma;\n\t\t\tcfg->chromaFormat = ctx->hevc.sps[idx].chroma_format_idc;\n\t\t\tcfg->complete_representation = GF_TRUE;\n\n\t\t\tcfg->nal_unit_size = 4;\n\n\t\t\tGF_SAFEALLOC(vpsa, GF_HEVCParamArray);\n\t\t\tvpsa->array_completeness = 1;\n\t\t\tvpsa->type = GF_HEVC_NALU_VID_PARAM;\n\t\t\tvpsa->nalus = gf_list_new();\n\t\t\tgf_list_add(vpsa->nalus, vps);\n\t\t\tgf_list_add(cfg->param_array, vpsa);\n\n\t\t\tGF_SAFEALLOC(spsa, GF_HEVCParamArray);\n\t\t\tspsa->array_completeness = 1;\n\t\t\tspsa->type = GF_HEVC_NALU_SEQ_PARAM;\n\t\t\tspsa->nalus = gf_list_new();\n\t\t\tgf_list_add(spsa->nalus, sps);\n\t\t\tgf_list_add(cfg->param_array, spsa);\n\n\t\t\tGF_SAFEALLOC(ppsa, GF_HEVCParamArray);\n\t\t\tppsa->array_completeness = 1;\n\t\t\tppsa->type = GF_HEVC_NALU_PIC_PARAM;\n\t\t\t//we send all PPS\n\t\t\tppsa->nalus = ctx->PPSs;\n\n\t\t\tgf_list_add(cfg->param_array, ppsa);\n\n\t\t\tgf_odf_hevc_cfg_write(cfg, &dsi_data, &dsi_data_size);\n\t\t\tgf_list_reset(vpsa->nalus);\n\t\t\tgf_list_reset(spsa->nalus);\n\t\t\tppsa->nalus = NULL;\n\t\t\tgf_odf_hevc_cfg_del(cfg);\n\n\t\t\tdsi = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n\t\t\tdata = CFDataCreate(kCFAllocatorDefault, (const UInt8*)dsi_data, dsi_data_size);\n\t\t\tif (data) {\n\t\t\t\tCFDictionarySetValue(dsi, CFSTR(\""hvcC\""), data);\n\t\t\t\tCFDictionarySetValue(dec_dsi, kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms, dsi);\n\t\t\t\tCFRelease(data);\n\t\t\t}\n\t\t\tCFRelease(dsi);\n\n\t\t\tgf_free(dsi_data);\n\t\t}\n        break;\n\n\tcase GPAC_OTI_VIDEO_MPEG2_SIMPLE:\n\tcase GPAC_OTI_VIDEO_MPEG2_MAIN:\n\tcase GPAC_OTI_VIDEO_MPEG2_SNR:\n\tcase GPAC_OTI_VIDEO_MPEG2_SPATIAL:\n\tcase GPAC_OTI_VIDEO_MPEG2_HIGH:\n\tcase GPAC_OTI_VIDEO_MPEG2_422:\n        ctx->vtb_type = kCMVideoCodecType_MPEG2Video;\n\t\tif (!ctx->width || !ctx->height) {\n\t\t\tctx->init_mpeg12 = GF_TRUE;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tctx->init_mpeg12 = GF_FALSE;\n        break;\n\t\t\n\tcase GPAC_OTI_VIDEO_MPEG1:\n\t\tctx->vtb_type = kCMVideoCodecType_MPEG1Video;\n\t\tif (!ctx->width || !ctx->height) {\n\t\t\tctx->init_mpeg12 = GF_TRUE;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tctx->init_mpeg12 = GF_FALSE;\n\t\tbreak;\n    case GPAC_OTI_VIDEO_MPEG4_PART2 :\n\t{\n\t\tBool reset_dsi = GF_FALSE;\n\t\tctx->vtb_type = kCMVideoCodecType_MPEG4Video;\n\t\tif (!ctx->esd->decoderConfig->decoderSpecificInfo) {\n\t\t\tctx->esd->decoderConfig->decoderSpecificInfo = (GF_DefaultDescriptor *) gf_odf_desc_new(GF_ODF_DSI_TAG);\n\t\t}\n\n\t\tif (!ctx->esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\treset_dsi = GF_TRUE;\n\t\t\tctx->esd->decoderConfig->decoderSpecificInfo->data = ctx->vosh;\n\t\t\tctx->esd->decoderConfig->decoderSpecificInfo->dataLength = ctx->vosh_size;\n\t\t}\n\t\t\n\t\tif (ctx->esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tGF_M4VDecSpecInfo vcfg;\n\t\t\tGF_BitStream *bs;\n\t\t\t\n\t\t\tgf_m4v_get_config(ctx->esd->decoderConfig->decoderSpecificInfo->data, ctx->esd->decoderConfig->decoderSpecificInfo->dataLength, &vcfg);\n\t\t\tctx->width = vcfg.width;\n\t\t\tctx->height = vcfg.height;\n\t\t\tif (ctx->esd->slConfig) {\n\t\t\t\tctx->esd->slConfig->predefined  = 2;\n\t\t\t}\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\tgf_odf_desc_write_bs((GF_Descriptor *) ctx->esd, bs);\n\t\t\tgf_bs_get_content(bs, &dsi_data, &dsi_data_size);\n\t\t\tgf_bs_del(bs);\n\t\t\t\n\t\t\tdsi = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n\t\t\tdata = CFDataCreate(kCFAllocatorDefault, (const UInt8*) dsi_data, dsi_data_size);\n\t\t\tgf_free(dsi_data);\n\t\t\t\n\t\t\tif (data) {\n\t\t\t\tCFDictionarySetValue(dsi, CFSTR(\""esds\""), data);\n\t\t\t\tCFDictionarySetValue(dec_dsi, kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms, dsi);\n\t\t\t\tCFRelease(data);\n\t\t\t}\n\t\t\tCFRelease(dsi);\n\t\t\t\n\t\t\tif (reset_dsi) {\n\t\t\t\tctx->esd->decoderConfig->decoderSpecificInfo->data = NULL;\n\t\t\t\tctx->esd->decoderConfig->decoderSpecificInfo->dataLength = 0;\n\t\t\t}\n\t\t\tctx->skip_mpeg4_vosh = GF_FALSE;\n\t\t} else {\n\t\t\tctx->skip_mpeg4_vosh = GF_TRUE;\n\t\t\treturn GF_OK;\n\t\t}\n        break;\n    }\n\tcase GPAC_OTI_MEDIA_GENERIC:\n\t\tif (ctx->esd->decoderConfig->decoderSpecificInfo && ctx->esd->decoderConfig->decoderSpecificInfo->dataLength) {\n\t\t\tchar *dsi = ctx->esd->decoderConfig->decoderSpecificInfo->data;\n\t\t\tif (ctx->esd->decoderConfig->decoderSpecificInfo->dataLength<8) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tif (strnicmp(dsi, \""s263\"", 4)) return GF_NOT_SUPPORTED;\n\t\t\t\n\t\t\tctx->width = ((u8) dsi[4]); ctx->width<<=8; ctx->width |= ((u8) dsi[5]);\n\t\t\tctx->height = ((u8) dsi[6]); ctx->height<<=8; ctx->height |= ((u8) dsi[7]);\n\t\t\tctx->vtb_type = kCMVideoCodecType_H263;\n\t\t}\n\t\tbreak;\n\t\t\n\tdefault :\n\t\treturn GF_NOT_SUPPORTED;\n    }\n\n\tif (! ctx->width || !ctx->height) return GF_NOT_SUPPORTED;\n\n    status = CMVideoFormatDescriptionCreate(kCFAllocatorDefault, ctx->vtb_type, ctx->width, ctx->height, dec_dsi, &ctx->fmt_desc);\n\n    if (!ctx->fmt_desc) {\n\t\tif (dec_dsi) CFRelease(dec_dsi);\n        return GF_NON_COMPLIANT_BITSTREAM;\n    }\n\tbuffer_attribs = VTBDec_CreateBufferAttributes(ctx, kColorSpace);\n\t\n\tcbacks.decompressionOutputCallback = VTBDec_on_frame;\n    cbacks.decompressionOutputRefCon   = ctx;\n\n    dec_type = CFDictionaryCreateMutable(kCFAllocatorDefault, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);\n    CFDictionarySetValue(dec_type, kVTVideoDecoderSpecification_RequireHardwareAcceleratedVideoDecoder, kCFBooleanTrue);\n\tctx->is_hardware = GF_TRUE;\n\n    status = VTDecompressionSessionCreate(NULL, ctx->fmt_desc, dec_type, buffer_attribs, &cbacks, &ctx->vtb_session);\n\t//if HW decoder not available, try soft one\n\tif (status) {\n\t\tstatus = VTDecompressionSessionCreate(NULL, ctx->fmt_desc, NULL, buffer_attribs, &cbacks, &ctx->vtb_session);\n\t\tctx->is_hardware = GF_FALSE;\n\t}\n\t\n\tif (dec_dsi)\n\t\tCFRelease(dec_dsi);\n\tif (dec_type)\n\t\tCFRelease(dec_type);\n    if (buffer_attribs)\n        CFRelease(buffer_attribs);\n\n    switch (status) {\n    case kVTVideoDecoderNotAvailableNowErr:\n    case kVTVideoDecoderUnsupportedDataFormatErr:\n        return GF_NOT_SUPPORTED;\n    case kVTVideoDecoderMalfunctionErr:\n        return GF_IO_ERR;\n    case kVTVideoDecoderBadDataErr :\n        return GF_BAD_PARAM;\n\n\tcase kVTPixelTransferNotSupportedErr:\n\tcase kVTCouldNotFindVideoDecoderErr:\n\t\treturn GF_NOT_SUPPORTED;\n    case 0:\n        break;\n    default:\n        return GF_SERVICE_ERROR;\n    }\n\t\n\t//good to go !\n\tif (ctx->pix_fmt == GF_PIXEL_YUV422) {\n\t\tctx->out_size = ctx->width*ctx->height*2;\n\t} else if (ctx->pix_fmt == GF_PIXEL_YUV444) {\n\t\tctx->out_size = ctx->width*ctx->height*3;\n\t} else {\n\t\t// (ctx->pix_fmt == GF_PIXEL_YV12)\n\t\tctx->out_size = ctx->width*ctx->height*3/2;\n\t}\n\tif (ctx->luma_bit_depth>8) {\n\t\tctx->out_size *= 2;\n\t}\n\tctx->frame_size_changed = GF_TRUE;\n\treturn GF_OK;\n}\n"", ""caller_start"": 155, ""file_path"": ""modules/vtb_decode/vtb_decode.c""}, {""call_line"": 1564, ""call_code"": ""gf_odf_avc_cfg_write(avcc, &rtp->sl_map.config, &rtp->sl_map.configSize)"", ""caller_code"": ""static GF_Err gf_rtp_payt_setup(GF_RTPDepacketizer *rtp, GF_RTPMap *map, GF_SDPMedia *media)\n{\n\tu32 i, j;\n\tGF_SDP_FMTP *fmtp;\n\n\t/*reset sl map*/\n\tmemset(&rtp->sl_map, 0, sizeof(GP_RTPSLMap));\n\n\tif (!stricmp(map->payload_name, \""enc-mpeg4-generic\"")) rtp->flags |= GF_RTP_HAS_ISMACRYP;\n\n\n\t/*then process all FMTPs*/\n\ti=0;\n\twhile ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {\n\t\tGF_X_Attribute *att;\n\t\t//we work with only one PayloadType for now\n\t\tif (fmtp->PayloadType != map->PayloadType) continue;\n\t\tj=0;\n\t\twhile ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {\n\t\t\tpayt_set_param(rtp, att->Name, att->Value);\n\t\t}\n\t}\n\n\tswitch (rtp->payt) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tcase GF_RTP_PAYT_LATM:\n\t{\n\t\tu32 AudioMuxVersion, AllStreamsSameTime, numSubFrames, numPrograms, numLayers, ch_cfg;\n\t\tGF_M4ADecSpecInfo cfg;\n\t\tchar *latm_dsi = rtp->sl_map.config;\n\t\tGF_BitStream *bs = gf_bs_new(latm_dsi, rtp->sl_map.configSize, GF_BITSTREAM_READ);\n\t\tAudioMuxVersion = gf_bs_read_int(bs, 1);\n\t\tAllStreamsSameTime = gf_bs_read_int(bs, 1);\n\t\tnumSubFrames = gf_bs_read_int(bs, 6);\n\t\tnumPrograms = gf_bs_read_int(bs, 4);\n\t\tnumLayers = gf_bs_read_int(bs, 3);\n\n\t\tif (AudioMuxVersion || !AllStreamsSameTime || numSubFrames || numPrograms || numLayers) {\n\t\t\tgf_bs_del(bs);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tmemset(&cfg, 0, sizeof(cfg));\n\t\tcfg.base_object_type = gf_bs_read_int(bs, 5);\n\t\tcfg.base_sr_index = gf_bs_read_int(bs, 4);\n\t\tif (cfg.base_sr_index == 0x0F) {\n\t\t\tcfg.base_sr = gf_bs_read_int(bs, 24);\n\t\t} else {\n\t\t\tcfg.base_sr = GF_M4ASampleRates[cfg.base_sr_index];\n\t\t}\n\t\tch_cfg = gf_bs_read_int(bs, 4);\n\t\tif (cfg.base_object_type==5 || cfg.base_object_type==29) {\n\t\t\tif (cfg.base_object_type==29) {\n\t\t\t\tcfg.has_ps = 1;\n\t\t\t\tcfg.nb_chan = 1;\n\t\t\t}\n\t\t\tcfg.has_sbr = 1;\n\t\t\tcfg.sbr_sr_index = gf_bs_read_int(bs, 4);\n\t\t\tif (cfg.sbr_sr_index == 0x0F) {\n\t\t\t\tcfg.sbr_sr = gf_bs_read_int(bs, 24);\n\t\t\t} else {\n\t\t\t\tcfg.sbr_sr = GF_M4ASampleRates[cfg.sbr_sr_index];\n\t\t\t}\n\t\t\tcfg.sbr_object_type = gf_bs_read_int(bs, 5);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_free(rtp->sl_map.config);\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t/*write as regular AAC*/\n\t\tgf_bs_write_int(bs, cfg.base_object_type, 5);\n\t\tgf_bs_write_int(bs, cfg.base_sr_index, 4);\n\n\t\tgf_bs_write_int(bs, ch_cfg, 4);\n\t\tgf_bs_align(bs);\n\t\tgf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\tgf_bs_del(bs);\n\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;\n\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_latm;\n\t}\n\tbreak;\n#endif\n\tcase GF_RTP_PAYT_MPEG4:\n\t\t/*mark if AU header is present*/\n\t\trtp->sl_map.auh_first_min_len = 0;\n\t\tif (rtp->flags & GF_RTP_HAS_ISMACRYP) {\n\t\t\tif (!rtp->isma_scheme) rtp->isma_scheme = GF_ISOM_ISMACRYP_SCHEME;\n\t\t\tif (!rtp->sl_map.IV_length) rtp->sl_map.IV_length = 4;\n\n\t\t\tif (rtp->flags & GF_RTP_ISMA_SEL_ENC) rtp->sl_map.auh_first_min_len += 8;\n\t\t\telse rtp->sl_map.auh_first_min_len += 8*(rtp->sl_map.IV_length + rtp->sl_map.KI_length);\n\t\t}\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.CTSDeltaLength;\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.DTSDeltaLength;\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.SizeLength;\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.RandomAccessIndication;\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.StreamStateIndication;\n\t\trtp->sl_map.auh_min_len = rtp->sl_map.auh_first_min_len;\n\t\trtp->sl_map.auh_first_min_len += rtp->sl_map.IndexLength;\n\t\trtp->sl_map.auh_min_len += rtp->sl_map.IndexDeltaLength;\n\t\t/*RFC3016 flags*/\n\t\tif (!stricmp(map->payload_name, \""MP4V-ES\"")) {\n\t\t\trtp->sl_map.StreamType = GF_STREAM_VISUAL;\n\t\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_MPEG4_PART2;\n\t\t}\n\t\telse if (!strnicmp(map->payload_name, \""AAC\"", 3)) {\n\t\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;\n\t\t}\n\t\telse if (!stricmp(map->payload_name, \""MP4A-LATM\"")) {\n\t\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;\n\t\t}\n\t\t/*MPEG-4 video, check RAPs if not indicated*/\n\t\tif ((rtp->sl_map.StreamType == GF_STREAM_VISUAL) && (rtp->sl_map.ObjectTypeIndication == GPAC_OTI_VIDEO_MPEG4_PART2) && !rtp->sl_map.RandomAccessIndication) {\n\t\t\trtp->flags |= GF_RTP_M4V_CHECK_RAP;\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif ((rtp->sl_map.ObjectTypeIndication == GPAC_OTI_AUDIO_AAC_MPEG4) && !rtp->sl_map.config) {\n\t\t\tGF_M4ADecSpecInfo cfg;\n\t\t\tGF_RTPMap*map = (GF_RTPMap*)gf_list_get(media->RTPMaps, 0);\n\n\t\t\tmemset(&cfg, 0, sizeof(GF_M4ADecSpecInfo));\n\t\t\tcfg.audioPL = rtp->sl_map.PL_ID;\n\t\t\tcfg.nb_chan = map->AudioChannels;\n\t\t\tcfg.nb_chan = 1;\n\t\t\tcfg.base_sr = map->ClockRate/2;\n\t\t\tcfg.sbr_sr = map->ClockRate;\n\t\t\tcfg.base_object_type = GF_M4A_AAC_LC;\n\t\t\tcfg.base_object_type = 5;\n\t\t\tcfg.sbr_object_type = GF_M4A_AAC_MAIN;\n\t\t\tgf_m4a_write_config(&cfg, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\t}\n#endif\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_mpeg4;\n\t\tbreak;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tcase GF_RTP_PAYT_MPEG12_AUDIO:\n\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_MPEG2_PART3;\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_mpeg12_audio;\n\t\tbreak;\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n\tcase GF_RTP_PAYT_MPEG12_VIDEO:\n\t\t/*we signal RAPs*/\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\trtp->sl_map.StreamType = GF_STREAM_VISUAL;\n\t\t/*FIXME: how to differentiate MPEG1 from MPEG2 video before any frame is received??*/\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_MPEG1;\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_mpeg12_video;\n\t\tbreak;\n\tcase GF_RTP_PAYT_AMR:\n\tcase GF_RTP_PAYT_AMR_WB:\n\t{\n\t\tGF_BitStream *bs;\n\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_MEDIA_GENERIC;\n\t\t/*create DSI*/\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tif (rtp->payt == GF_RTP_PAYT_AMR) {\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_SUBTYPE_3GP_AMR);\n\t\t\tgf_bs_write_u32(bs, 8000);\n\t\t\tgf_bs_write_u16(bs, 1);\n\t\t\tgf_bs_write_u16(bs, 160);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_SUBTYPE_3GP_AMR_WB);\n\t\t\tgf_bs_write_u32(bs, 16000);\n\t\t\tgf_bs_write_u16(bs, 1);\n\t\t\tgf_bs_write_u16(bs, 320);\n\t\t}\n\t\tgf_bs_write_u8(bs, 16);\n\t\tgf_bs_write_u8(bs, 1);\n\t\tgf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\tgf_bs_del(bs);\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_amr;\n\t}\n\tbreak;\n\tcase GF_RTP_PAYT_H263:\n\t{\n\t\tu32 x, y, w, h;\n\t\tGF_X_Attribute *att;\n\t\tGF_BitStream *bs;\n\t\tx = y = w = h = 0;\n\t\tj=0;\n\t\twhile ((att = (GF_X_Attribute *)gf_list_enum(media->Attributes, &j))) {\n\t\t\tif (stricmp(att->Name, \""cliprect\"")) continue;\n\t\t\t/*only get the display area*/\n\t\t\tsscanf(att->Value, \""%u,%u,%u,%u\"", &y, &x, &h, &w);\n\t\t}\n\n\t\trtp->sl_map.StreamType = GF_STREAM_VISUAL;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_MEDIA_GENERIC;\n\t\t/*create DSI*/\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u32(bs, GF_ISOM_SUBTYPE_H263);\n\t\tgf_bs_write_u16(bs, w);\n\t\tgf_bs_write_u16(bs, h);\n\t\tgf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\tgf_bs_del(bs);\n\t\t/*we signal RAPs*/\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_h263;\n\t}\n\tbreak;\n\tcase GF_RTP_PAYT_3GPP_TEXT:\n\t{\n\t\tchar *tx3g, *a_tx3g;\n\t\tGF_BitStream *bs;\n\t\tu32 nb_desc;\n\t\tGF_SDP_FMTP *fmtp;\n\t\tGF_TextConfig tcfg;\n\t\tmemset(&tcfg, 0, sizeof(GF_TextConfig));\n\t\ttcfg.tag = GF_ODF_TEXT_CFG_TAG;\n\t\ttcfg.Base3GPPFormat = 0x10;\n\t\ttcfg.MPEGExtendedFormat = 0x10;\n\t\ttcfg.profileLevel = 0x10;\n\t\ttcfg.timescale = map->ClockRate;\n\t\ttcfg.sampleDescriptionFlags = 1;\n\t\ttx3g = NULL;\n\n\t\ti=0;\n\t\twhile ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {\n\t\t\tGF_X_Attribute *att;\n\t\t\tif (fmtp->PayloadType != map->PayloadType) continue;\n\t\t\tj=0;\n\t\t\twhile ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {\n\n\t\t\t\tif (!stricmp(att->Name, \""width\"")) tcfg.text_width = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""height\"")) tcfg.text_height = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""tx\"")) tcfg.horiz_offset = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""ty\"")) tcfg.vert_offset = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""layer\"")) tcfg.layer = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""max-w\"")) tcfg.video_width = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""max-h\"")) tcfg.video_height = atoi(att->Value);\n\t\t\t\telse if (!stricmp(att->Name, \""tx3g\"")) tx3g = att->Value;\n\t\t\t}\n\t\t}\n\t\tif (!tx3g) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u8(bs, tcfg.Base3GPPFormat);\n\t\tgf_bs_write_u8(bs, tcfg.MPEGExtendedFormat); /*MPEGExtendedFormat*/\n\t\tgf_bs_write_u8(bs, tcfg.profileLevel); /*profileLevel*/\n\t\tgf_bs_write_u24(bs, tcfg.timescale);\n\t\tgf_bs_write_int(bs, 0, 1);\t/*no alt formats*/\n\t\tgf_bs_write_int(bs, tcfg.sampleDescriptionFlags, 2);\n\t\tgf_bs_write_int(bs, 1, 1);\t/*we will write sample desc*/\n\t\tgf_bs_write_int(bs, 1, 1);\t/*video info*/\n\t\tgf_bs_write_int(bs, 0, 3);\t/*reserved, spec doesn't say the values*/\n\t\tgf_bs_write_u8(bs, tcfg.layer);\n\t\tgf_bs_write_u16(bs, tcfg.text_width);\n\t\tgf_bs_write_u16(bs, tcfg.text_height);\n\t\t/*get all tx3g (comma separated)*/\n\t\tnb_desc = 1;\n\t\ta_tx3g = tx3g;\n\t\twhile ((a_tx3g = strchr(a_tx3g, ',')) ) {\n\t\t\ta_tx3g ++;\n\t\t\tnb_desc ++;\n\t\t}\n\t\ta_tx3g = tx3g;\n\t\tgf_bs_write_u8(bs, nb_desc);\n\t\tnb_desc = 1;\n\t\twhile (1) {\n\t\t\tchar *next_tx3g, szOut[1000];\n\t\t\tu32 len, s_len;\n\t\t\tnext_tx3g = strchr(a_tx3g, ',');\n\t\t\tif (next_tx3g) s_len = (u32) (next_tx3g - a_tx3g - 1);\n\t\t\telse s_len = (u32) strlen(a_tx3g);\n\n\t\t\tlen = gf_base64_decode(a_tx3g, s_len, szOut, 1000);\n\t\t\tnb_desc++;\n\t\t\tgf_bs_write_data(bs, szOut, len);\n\t\t\tif (!next_tx3g) break;\n\t\t\ta_tx3g = strchr(a_tx3g, ',');\n\t\t\tif (!a_tx3g) break;\n\t\t\ta_tx3g += 1;\n\t\t\twhile (a_tx3g[0] == ' ') a_tx3g += 1;\n\t\t}\n\n\t\t/*write video cfg*/\n\t\tgf_bs_write_u16(bs, tcfg.video_width);\n\t\tgf_bs_write_u16(bs, tcfg.video_height);\n\t\tgf_bs_write_u16(bs, tcfg.horiz_offset);\n\t\tgf_bs_write_u16(bs, tcfg.vert_offset);\n\t\tgf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\trtp->sl_map.StreamType = GF_STREAM_TEXT;\n\t\trtp->sl_map.ObjectTypeIndication = 0x08;\n\t\tgf_bs_del(bs);\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_ttxt;\n\t}\n\tbreak;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tcase GF_RTP_PAYT_H264_AVC:\n\tcase GF_RTP_PAYT_H264_SVC:\n\t{\n\t\tGF_SDP_FMTP *fmtp;\n\t\tGF_AVCConfig *avcc = gf_odf_avc_cfg_new();\n\t\tavcc->AVCProfileIndication = (rtp->sl_map.PL_ID>>16) & 0xFF;\n\t\tavcc->profile_compatibility = (rtp->sl_map.PL_ID>>8) & 0xFF;\n\t\tavcc->AVCLevelIndication = rtp->sl_map.PL_ID & 0xFF;\n\t\tavcc->configurationVersion = 1;\n\t\tavcc->nal_unit_size = 4;\n\t\trtp->sl_map.StreamType = 4;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_AVC;\n\t\t/*we will signal RAPs*/\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\t/*rewrite sps and pps*/\n\t\ti=0;\n\t\twhile ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {\n\t\t\tGF_X_Attribute *att;\n\t\t\tif (fmtp->PayloadType != map->PayloadType) continue;\n\t\t\tj=0;\n\t\t\twhile ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {\n\t\t\t\tchar *nal_ptr, *sep;\n\t\t\t\tif (stricmp(att->Name, \""sprop-parameter-sets\"")) continue;\n\n\t\t\t\tnal_ptr = att->Value;\n\t\t\t\twhile (nal_ptr) {\n\t\t\t\t\tu32 nalt, b64size, ret;\n\t\t\t\t\tchar *b64_d;\n\n\t\t\t\t\tsep = strchr(nal_ptr, ',');\n\t\t\t\t\tif (sep) sep[0] = 0;\n\n\t\t\t\t\tb64size = (u32) strlen(nal_ptr);\n\t\t\t\t\tb64_d = (char*)gf_malloc(sizeof(char)*b64size);\n\t\t\t\t\tret = gf_base64_decode(nal_ptr, b64size, b64_d, b64size);\n\t\t\t\t\tb64_d[ret] = 0;\n\n\t\t\t\t\tnalt = b64_d[0] & 0x1F;\n\t\t\t\t\tif (/*SPS*/(nalt==0x07) || /*PPS*/(nalt==0x08) || /*SSPS*/(nalt==0x0F)) {\n\t\t\t\t\t\tGF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\t\t\t\t\tsl->size = ret;\n\t\t\t\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\t\t\t\tmemcpy(sl->data, b64_d, sizeof(char)*sl->size);\n\t\t\t\t\t\tif (nalt==0x07 || nalt==0x0F) {\n\t\t\t\t\t\t\tgf_list_add(avcc->sequenceParameterSets, sl);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_list_add(avcc->pictureParameterSets, sl);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_free(b64_d);\n\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tsep[0] = ',';\n\t\t\t\t\t\tnal_ptr = sep+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gf_list_count(avcc->sequenceParameterSets) && gf_list_count(avcc->pictureParameterSets)) {\n\t\t\tgf_odf_avc_cfg_write(avcc, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\t} else {\n\t\t\trtp->flags |= GF_RTP_AVC_USE_ANNEX_B;\n\t\t}\n\t\tgf_odf_avc_cfg_del(avcc);\n\t}\n\t\t/*assign depacketizer*/\n\trtp->depacketize = gf_rtp_parse_h264;\n\tbreak;\n\tcase GF_RTP_PAYT_HEVC:\n\tcase GF_RTP_PAYT_LHVC:\n#ifndef GPAC_DISABLE_HEVC\n\t{\n\t\tGF_SDP_FMTP *fmtp;\n\t\tGF_HEVCConfig *hevcc = gf_odf_hevc_cfg_new();\n\t\thevcc->configurationVersion = 1;\n\t\thevcc->nal_unit_size = 4;\n\t\trtp->sl_map.StreamType = 4;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_HEVC;\n\t\t/*we will signal RAPs*/\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\ti=0;\n\t\twhile ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {\n\t\t\tGF_X_Attribute *att;\n\t\t\tif (fmtp->PayloadType != map->PayloadType) continue;\n\t\t\tj=0;\n\t\t\twhile ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {\n\t\t\t\tchar *nal_ptr, *sep;\n\t\t\t\tGF_HEVCParamArray *ar;\n\t\t\t\tif (!stricmp(att->Name, \""sprop-vps\"")) {\n\t\t\t\t\tGF_SAFEALLOC(ar, GF_HEVCParamArray);\n\t\t\t\t\tif (!ar) return GF_OUT_OF_MEM;\n\t\t\t\t\tar->nalus = gf_list_new();\n\t\t\t\t\tar->type = GF_HEVC_NALU_VID_PARAM;\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(att->Name, \""sprop-sps\"")) {\n\t\t\t\t\tGF_SAFEALLOC(ar, GF_HEVCParamArray);\n\t\t\t\t\tif (!ar) return GF_OUT_OF_MEM;\n\t\t\t\t\tar->nalus = gf_list_new();\n\t\t\t\t\tar->type = GF_HEVC_NALU_SEQ_PARAM;\n\t\t\t\t}\n\t\t\t\telse if (!stricmp(att->Name, \""sprop-pps\"")) {\n\t\t\t\t\tGF_SAFEALLOC(ar, GF_HEVCParamArray);\n\t\t\t\t\tif (!ar) return GF_OUT_OF_MEM;\n\t\t\t\t\tar->nalus = gf_list_new();\n\t\t\t\t\tar->type = GF_HEVC_NALU_PIC_PARAM;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t\tnal_ptr = att->Value;\n\t\t\t\twhile (nal_ptr) {\n\t\t\t\t\tu32 b64size, ret;\n\t\t\t\t\tchar *b64_d;\n\t\t\t\t\tGF_AVCConfigSlot *sl;\n\n\t\t\t\t\tsep = strchr(nal_ptr, ',');\n\t\t\t\t\tif (sep) sep[0] = 0;\n\n\t\t\t\t\tb64size = (u32) strlen(nal_ptr);\n\t\t\t\t\tb64_d = (char*)gf_malloc(sizeof(char)*b64size);\n\t\t\t\t\tret = gf_base64_decode(nal_ptr, b64size, b64_d, b64size);\n\t\t\t\t\tb64_d[ret] = 0;\n\n\t\t\t\t\tsl = (GF_AVCConfigSlot *)gf_malloc(sizeof(GF_AVCConfigSlot));\n\t\t\t\t\tsl->size = ret;\n\t\t\t\t\tsl->data = (char*)gf_malloc(sizeof(char)*sl->size);\n\t\t\t\t\tmemcpy(sl->data, b64_d, sizeof(char)*sl->size);\n\t\t\t\t\tgf_list_add(ar->nalus, sl);\n\n\t\t\t\t\tgf_free(b64_d);\n\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tsep[0] = ',';\n\t\t\t\t\t\tnal_ptr = sep+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!hevcc->param_array) hevcc->param_array = gf_list_new();\n\t\t\t\tgf_list_add(hevcc->param_array, ar);\n\t\t\t}\n\t\t}\n\t\tgf_odf_hevc_cfg_write(hevcc, &rtp->sl_map.config, &rtp->sl_map.configSize);\n\t\tgf_odf_hevc_cfg_del(hevcc);\n\t}\n\trtp->depacketize = gf_rtp_parse_hevc;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n\tbreak;\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\n\t/*todo - rewrite DIMS config*/\n\tcase GF_RTP_PAYT_3GPP_DIMS:\n\t\trtp->sl_map.StreamType = GF_STREAM_SCENE;\n\t\trtp->sl_map.ObjectTypeIndication = GPAC_OTI_SCENE_DIMS;\n\t\t/*we will signal RAPs*/\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\t/*we map DIMS CTR to AU seq num, hence 3 bits*/\n\t\trtp->sl_map.StreamStateIndication = 3;\n\t\trtp->sl_map.IndexLength = 3;\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_3gpp_dims;\n\t\tbreak;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tcase GF_RTP_PAYT_AC3:\n\t\trtp->sl_map.StreamType = GF_STREAM_AUDIO;\n\t\trtp->sl_map.ObjectTypeIndication = 0xA5;\n\t\trtp->sl_map.RandomAccessIndication = GF_TRUE;\n\t\t/*assign depacketizer*/\n\t\trtp->depacketize = gf_rtp_parse_ac3;\n\t\tbreak;\n#endif /*GPAC_DISABLE_AV_PARSERS*/\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\treturn GF_OK;\n}\n"", ""caller_start"": 1203, ""file_path"": ""src/ietf/rtp_depacketizer.c""}, {""call_line"": 1047, ""call_code"": ""gf_odf_avc_cfg_write(avcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength)"", ""caller_code"": ""void AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia)\n{\n\tGF_AVCConfig *avcc, *svcc, *mvcc;\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_FALSE);\n\n\tif (avc->emul_esd) gf_odf_desc_del((GF_Descriptor *)avc->emul_esd);\n\tavc->emul_esd = gf_odf_desc_esd_new(2);\n\tavc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t/*AVC OTI is 0x21, AVC parameter set stream OTI (not supported in gpac) is 0x22, SVC OTI is 0x24*/\n\t/*if we have only SVC stream, set objectTypeIndication to AVC OTI; else set it to AVC OTI*/\n\tif (avc->svc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_SVC;\n\telse if (avc->mvc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_MVC;\n\telse\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_AVC;\n\n\tif (btrt) {\n\t\tavc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tavc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tavc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (avc->descr) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(avc->descr->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)avc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\tif (avc->avc_config) {\n\t\tavcc = avc->avc_config->config ? AVC_DuplicateConfig(avc->avc_config->config) : NULL;\n\t\t/*merge SVC config*/\n\t\tif (avc->svc_config) {\n\t\t\tmerge_avc_config(avcc, avc->svc_config->config);\n\t\t}\n\t\t/*merge MVC config*/\n\t\tif (avc->mvc_config) {\n\t\t\tmerge_avc_config(avcc, avc->mvc_config->config);\n\t\t}\n\t\tif (avcc) {\n\t\t\tif (mdia) merge_all_config(avcc, NULL, mdia);\n\n\t\t\tgf_odf_avc_cfg_write(avcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t}\n\t} else if (avc->svc_config) {\n\t\tsvcc = AVC_DuplicateConfig(avc->svc_config->config);\n\n\t\tif (mdia) merge_all_config(svcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(svcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\telse if (avc->mvc_config) {\n\t\tmvcc = AVC_DuplicateConfig(avc->mvc_config->config);\n\n\t\tif (mdia) merge_all_config(mvcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(mvcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(mvcc);\n\t}\n}\n"", ""caller_start"": 1001, ""file_path"": ""src/isomedia/avc_ext.c""}, {""call_line"": 1055, ""call_code"": ""gf_odf_avc_cfg_write(svcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength)"", ""caller_code"": ""void AVC_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *avc, GF_MediaBox *mdia)\n{\n\tGF_AVCConfig *avcc, *svcc, *mvcc;\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)avc, GF_FALSE);\n\n\tif (avc->emul_esd) gf_odf_desc_del((GF_Descriptor *)avc->emul_esd);\n\tavc->emul_esd = gf_odf_desc_esd_new(2);\n\tavc->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t/*AVC OTI is 0x21, AVC parameter set stream OTI (not supported in gpac) is 0x22, SVC OTI is 0x24*/\n\t/*if we have only SVC stream, set objectTypeIndication to AVC OTI; else set it to AVC OTI*/\n\tif (avc->svc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_SVC;\n\telse if (avc->mvc_config && !avc->avc_config)\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_MVC;\n\telse\n\t\tavc->emul_esd->decoderConfig->objectTypeIndication = GPAC_OTI_VIDEO_AVC;\n\n\tif (btrt) {\n\t\tavc->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tavc->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tavc->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (avc->descr) {\n\t\tu32 i=0;\n\t\tGF_Descriptor *desc,*clone;\n\t\ti=0;\n\t\twhile ((desc = (GF_Descriptor *)gf_list_enum(avc->descr->descriptors, &i))) {\n\t\t\tclone = NULL;\n\t\t\tgf_odf_desc_copy(desc, &clone);\n\t\t\tif (gf_odf_desc_add_desc((GF_Descriptor *)avc->emul_esd, clone) != GF_OK)\n\t\t\t\tgf_odf_desc_del(clone);\n\t\t}\n\t}\n\tif (avc->avc_config) {\n\t\tavcc = avc->avc_config->config ? AVC_DuplicateConfig(avc->avc_config->config) : NULL;\n\t\t/*merge SVC config*/\n\t\tif (avc->svc_config) {\n\t\t\tmerge_avc_config(avcc, avc->svc_config->config);\n\t\t}\n\t\t/*merge MVC config*/\n\t\tif (avc->mvc_config) {\n\t\t\tmerge_avc_config(avcc, avc->mvc_config->config);\n\t\t}\n\t\tif (avcc) {\n\t\t\tif (mdia) merge_all_config(avcc, NULL, mdia);\n\n\t\t\tgf_odf_avc_cfg_write(avcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t}\n\t} else if (avc->svc_config) {\n\t\tsvcc = AVC_DuplicateConfig(avc->svc_config->config);\n\n\t\tif (mdia) merge_all_config(svcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(svcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\telse if (avc->mvc_config) {\n\t\tmvcc = AVC_DuplicateConfig(avc->mvc_config->config);\n\n\t\tif (mdia) merge_all_config(mvcc, NULL, mdia);\n\n\t\tgf_odf_avc_cfg_write(mvcc, &avc->emul_esd->decoderConfig->decoderSpecificInfo->data, &avc->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_odf_avc_cfg_del(mvcc);\n\t}\n}\n"", ""caller_start"": 1001, ""file_path"": ""src/isomedia/avc_ext.c""}]}, {""source"": ""value_info(file:meta.c, value:avcc)"", ""result"": {""value_trace"": [{""full_code"": ""*avcc = NULL"", ""line"": 310, ""func_name"": ""gf_isom_extract_meta_item_extended""}, {""full_code"": ""avcc = (GF_AVCConfigurationBox *) hvcc"", ""line"": 327, ""func_name"": ""gf_isom_extract_meta_item_extended""}], ""struct_var"": ""avcc"", ""struct_type"": ""GF_AVCConfigurationBox*"", ""struct_definition"": ""typedef struct\n{\n\tGF_ISOM_BOX\n\tGF_AVCConfig *config;\n}""}}]","src/odf/descriptors.c:567: Dereference of 'cfg' without a NULL check. Patch added a check at src/odf/descriptors.c:565. Trigger occurs when 'cfg' is NULL, which can be caused by: \n1. Direct calls to gf_odf_avc_cfg_write() with unvalidated 'cfg' (e.g., src/isomedia/meta.c:351, where avcc is cast from hvcc without NULL check: src/isomedia/meta.c:327). \n2. Callers like src/ietf/rtp_depacketizer.c:1564 and src/isomedia/avc_ext.c:1055, where avcc->config is used without ensuring avcc is non-NULL. \nOriginal vulnerability arises when 'hvcc' is NULL in meta.c:327, leading to avcc->config being NULL and passed to gf_odf_avc_cfg_write_bs().",0.95,./github/other_context/CVE-2019-20163
32,CVE-2019-7153,CWE-476,c_cpp,"A NULL pointer dereference was discovered in wasm::WasmBinaryBuilder::processFunctions() in wasm/wasm-binary.cpp (when calling wasm::WasmBinaryBuilder::getFunctionIndexName) in Binaryen 1.38.22. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by wasm-opt.",https://github.com/WebAssembly/binaryen/commit/e63c4a7d04c145dafaf4b09de5f9f5de69cee8ef,More misc ASAN fixes (#1882)\n\n* fix buffer overflow in simple_ast.h printing.\r\n* check wasm binary format reading of function export indexes for errors.\r\n* check if s-expr format imports have a non-empty module and base.\r\n\r\nFixes #1876\r\nFixes #1877\r\nFixes #1879,5,"[{""func_name"": ""printAst"", ""file_path"": ""src/emscripten-optimizer/simple_ast.h"", ""func_code"": ""void printAst() {\n    print(ast);\n    buffer[used] = 0;\n  }"", ""target"": 0}, {""func_name"": ""WasmBinaryBuilder::processFunctions"", ""file_path"": ""src/wasm/wasm-binary.cpp"", ""func_code"": ""void WasmBinaryBuilder::processFunctions() {\n  for (auto* func : functions) {\n    wasm.addFunction(func);\n  }\n\n  // now that we have names for each function, apply things\n\n  if (startIndex != static_cast<Index>(-1)) {\n    wasm.start = getFunctionIndexName(startIndex);\n  }\n\n  for (auto* curr : exportOrder) {\n    auto index = exportIndexes[curr];\n    switch (curr->kind) {\n      case ExternalKind::Function: {\n        curr->value = getFunctionIndexName(index);\n        break;\n      }\n      case ExternalKind::Table: curr->value = Name::fromInt(0); break;\n      case ExternalKind::Memory: curr->value = Name::fromInt(0); break;\n      case ExternalKind::Global: curr->value = getGlobalName(index); break;\n      default: throwError(\""bad export kind\"");\n    }\n    wasm.addExport(curr);\n  }\n\n  for (auto& iter : functionCalls) {\n    size_t index = iter.first;\n    auto& calls = iter.second;\n    for (auto* call : calls) {\n      call->target = getFunctionIndexName(index);\n    }\n  }\n\n  for (auto& pair : functionTable) {\n    auto i = pair.first;\n    auto& indexes = pair.second;\n    for (auto j : indexes) {\n      wasm.table.segments[i].data.push_back(getFunctionIndexName(j));\n    }\n  }\n\n  // Everything now has its proper name.\n\n  wasm.updateMaps();\n}"", ""target"": 0}, {""func_name"": ""SExpressionWasmBuilder::parseGlobal"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseGlobal(Element& s, bool preParseImport) {\n  std::unique_ptr<Global> global = make_unique<Global>();\n  size_t i = 1;\n  if (s[i]->dollared() && !(s[i]->isStr() && isType(s[i]->str()))) {\n    global->name = s[i++]->str();\n  } else {\n    global->name = Name::fromInt(globalCounter);\n  }\n  globalCounter++;\n  globalNames.push_back(global->name);\n  bool mutable_ = false;\n  Type type = none;\n  bool exported = false;\n  Name importModule, importBase;\n  while (i < s.size() && s[i]->isList()) {\n    auto& inner = *s[i];\n    if (inner[0]->str() == EXPORT) {\n      auto ex = make_unique<Export>();\n      ex->name = inner[1]->str();\n      ex->value = global->name;\n      ex->kind = ExternalKind::Global;\n      if (wasm.getExportOrNull(ex->name)) throw ParseException(\""duplicate export\"", s.line, s.col);\n      wasm.addExport(ex.release());\n      exported = true;\n      i++;\n    } else if (inner[0]->str() == IMPORT) {\n      importModule = inner[1]->str();\n      importBase = inner[2]->str();\n      i++;\n    } else if (inner[0]->str() == MUT) {\n      mutable_ = true;\n      type = stringToType(inner[1]->str());\n      i++;\n    } else {\n      break;\n    }\n  }\n  if (exported && mutable_) throw ParseException(\""cannot export a mutable global\"", s.line, s.col);\n  if (type == none) {\n    type = stringToType(s[i++]->str());\n  }\n  if (importModule.is()) {\n    // this is an import, actually\n    if (!preParseImport) throw ParseException(\""!preParseImport in global\"");\n    auto im = make_unique<Global>();\n    im->name = global->name;\n    im->module = importModule;\n    im->base = importBase;\n    im->type = type;\n    im->mutable_ = mutable_;\n    if (wasm.getGlobalOrNull(im->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n    wasm.addGlobal(im.release());\n    return;\n  }\n  if (preParseImport) throw ParseException(\""preParseImport in global\"");\n  global->type = type;\n  if (i < s.size()) {\n    global->init = parseExpression(s[i++]);\n  } else {\n    throw ParseException(\""global without init\"", s.line, s.col);\n  }\n  global->mutable_ = mutable_;\n  if (i != s.size()) throw ParseException(\""extra import elements\"");\n  if (wasm.getGlobalOrNull(global->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n  wasm.addGlobal(global.release());\n}"", ""target"": 0}, {""func_name"": ""SExpressionWasmBuilder::parseImport"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseImport(Element& s) {\n  size_t i = 1;\n  bool newStyle = s.size() == 4 && s[3]->isList(); // (import \""env\"" \""STACKTOP\"" (global $stackTop i32))\n  auto kind = ExternalKind::Invalid;\n  if (newStyle) {\n    if ((*s[3])[0]->str() == FUNC) {\n      kind = ExternalKind::Function;\n    } else if ((*s[3])[0]->str() == MEMORY) {\n      kind = ExternalKind::Memory;\n      if (wasm.memory.exists) throw ParseException(\""more than one memory\"");\n      wasm.memory.exists = true;\n    } else if ((*s[3])[0]->str() == TABLE) {\n      kind = ExternalKind::Table;\n      if (wasm.table.exists) throw ParseException(\""more than one table\"");\n      wasm.table.exists = true;\n    } else if ((*s[3])[0]->str() == GLOBAL) {\n      kind = ExternalKind::Global;\n    } else {\n      newStyle = false; // either (param..) or (result..)\n    }\n  }\n  Index newStyleInner = 1;\n  Name name;\n  if (s.size() > 3 && s[3]->isStr()) {\n    name = s[i++]->str();\n  } else if (newStyle && newStyleInner < s[3]->size() && (*s[3])[newStyleInner]->dollared()) {\n    name = (*s[3])[newStyleInner++]->str();\n  }\n  if (!name.is()) {\n    if (kind == ExternalKind::Function) {\n      name = Name(\""import$function$\"" + std::to_string(functionCounter++));\n      functionNames.push_back(name);\n    } else if (kind == ExternalKind::Global) {\n      name = Name(\""import$global\"" + std::to_string(globalCounter++));\n      globalNames.push_back(name);\n    } else if (kind == ExternalKind::Memory) {\n      name = Name(\""import$memory$\"" + std::to_string(0));\n    } else if (kind == ExternalKind::Table) {\n      name = Name(\""import$table$\"" + std::to_string(0));\n    } else {\n      throw ParseException(\""invalid import\"");\n    }\n  }\n  if (!s[i]->quoted()) {\n    if (s[i]->str() == MEMORY) {\n      kind = ExternalKind::Memory;\n    } else if (s[i]->str() == TABLE) {\n      kind = ExternalKind::Table;\n    } else if (s[i]->str() == GLOBAL) {\n      kind = ExternalKind::Global;\n    } else {\n      throw ParseException(\""invalid ext import\"");\n    }\n    i++;\n  } else if (!newStyle) {\n    kind = ExternalKind::Function;\n  }\n  auto module = s[i++]->str();\n  if (!s[i]->isStr()) throw ParseException(\""no name for import\"");\n  auto base = s[i++]->str();\n  // parse internals\n  Element& inner = newStyle ? *s[3] : s;\n  Index j = newStyle ? newStyleInner : i;\n  if (kind == ExternalKind::Function) {\n    std::unique_ptr<FunctionType> type = make_unique<FunctionType>();\n    if (inner.size() > j) {\n      Element& params = *inner[j];\n      IString id = params[0]->str();\n      if (id == PARAM) {\n        for (size_t k = 1; k < params.size(); k++) {\n          type->params.push_back(stringToType(params[k]->str()));\n        }\n      } else if (id == RESULT) {\n        type->result = stringToType(params[1]->str());\n      } else if (id == TYPE) {\n        IString name = params[1]->str();\n        if (!wasm.getFunctionTypeOrNull(name)) throw ParseException(\""bad function type for import\"");\n        *type = *wasm.getFunctionType(name);\n      } else {\n        throw ParseException(\""bad import element\"");\n      }\n      if (inner.size() > j+1) {\n        Element& result = *inner[j+1];\n        if (result[0]->str() != RESULT) throw ParseException(\""expected result\"");\n        type->result = stringToType(result[1]->str());\n      }\n    }\n    auto func = make_unique<Function>();\n    func->name = name;\n    func->module = module;\n    func->base = base;\n    auto* functionType = ensureFunctionType(getSig(type.get()), &wasm);\n    func->type = functionType->name;\n    FunctionTypeUtils::fillFunction(func.get(), functionType);\n    functionTypes[name] = func->result;\n    wasm.addFunction(func.release());\n  } else if (kind == ExternalKind::Global) {\n    Type type;\n    bool mutable_ = false;\n    if (inner[j]->isStr()) {\n      type = stringToType(inner[j]->str());\n    } else {\n      auto& inner2 = *inner[j];\n      if (inner2[0]->str() != MUT) throw ParseException(\""expected mut\"");\n      type = stringToType(inner2[1]->str());\n      mutable_ = true;\n    }\n    auto global = make_unique<Global>();\n    global->name = name;\n    global->module = module;\n    global->base = base;\n    global->type = type;\n    global->mutable_ = mutable_;\n    wasm.addGlobal(global.release());\n  } else if (kind == ExternalKind::Table) {\n    wasm.table.module = module;\n    wasm.table.base = base;\n    if (j < inner.size() - 1) {\n      wasm.table.initial = getCheckedAddress(inner[j++], \""excessive table init size\"");\n    }\n    if (j < inner.size() - 1) {\n      wasm.table.max = getCheckedAddress(inner[j++], \""excessive table max size\"");\n    } else {\n      wasm.table.max = Table::kUnlimitedSize;\n    }\n    // ends with the table element type\n  } else if (kind == ExternalKind::Memory) {\n    wasm.memory.module = module;\n    wasm.memory.base = base;\n    if (inner[j]->isList()) {\n      auto& limits = *inner[j];\n      if (!(limits[0]->isStr() && limits[0]->str() == \""shared\"")) throw ParseException(\""bad memory limit declaration\"");\n      wasm.memory.shared = true;\n      parseMemoryLimits(limits, 1);\n    } else {\n      parseMemoryLimits(inner, j);\n    }\n  }\n}"", ""target"": 0}, {""func_name"": ""SExpressionWasmBuilder::parseFunction"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseFunction(Element& s, bool preParseImport) {\n  size_t i = 1;\n  Name name, exportName;\n  i = parseFunctionNames(s, name, exportName);\n  if (!preParseImport) {\n    if (!name.is()) {\n      // unnamed, use an index\n      name = Name::fromInt(functionCounter);\n    }\n    functionCounter++;\n  } else {\n    // just preparsing, functionCounter was incremented by preParseFunctionType\n    if (!name.is()) {\n      // unnamed, use an index\n      name = functionNames[functionCounter - 1];\n    }\n  }\n  if (exportName.is()) {\n    auto ex = make_unique<Export>();\n    ex->name = exportName;\n    ex->value = name;\n    ex->kind = ExternalKind::Function;\n    if (wasm.getExportOrNull(ex->name)) throw ParseException(\""duplicate export\"", s.line, s.col);\n    wasm.addExport(ex.release());\n  }\n  Expression* body = nullptr;\n  localIndex = 0;\n  otherIndex = 0;\n  brokeToAutoBlock = false;\n  std::vector<NameType> typeParams; // we may have both params and a type. store the type info here\n  std::vector<NameType> params;\n  std::vector<NameType> vars;\n  Type result = none;\n  Name type;\n  Block* autoBlock = nullptr; // we may need to add a block for the very top level\n  Name importModule, importBase;\n  auto makeFunction = [&]() {\n    currFunction = std::unique_ptr<Function>(Builder(wasm).makeFunction(\n        name,\n        std::move(params),\n        result,\n        std::move(vars)\n    ));\n  };\n  auto ensureAutoBlock = [&]() {\n    if (!autoBlock) {\n      autoBlock = allocator.alloc<Block>();\n      autoBlock->list.push_back(body);\n      body = autoBlock;\n    }\n  };\n  for (;i < s.size(); i++) {\n    Element& curr = *s[i];\n    IString id = curr[0]->str();\n    if (id == PARAM || id == LOCAL) {\n      size_t j = 1;\n      while (j < curr.size()) {\n        IString name;\n        Type type = none;\n        if (!curr[j]->dollared()) { // dollared input symbols cannot be types\n          type = stringToType(curr[j]->str(), true);\n        }\n        if (type != none) {\n          // a type, so an unnamed parameter\n          name = Name::fromInt(localIndex);\n        } else {\n          name = curr[j]->str();\n          type = stringToType(curr[j+1]->str());\n          j++;\n        }\n        j++;\n        if (id == PARAM) {\n          params.emplace_back(name, type);\n        } else {\n          vars.emplace_back(name, type);\n        }\n        localIndex++;\n        currLocalTypes[name] = type;\n      }\n    } else if (id == RESULT) {\n      if (curr.size() > 2) throw ParseException(\""invalid result arity\"", curr.line, curr.col);\n      result = stringToType(curr[1]->str());\n    } else if (id == TYPE) {\n      Name name = getFunctionTypeName(*curr[1]);\n      type = name;\n      if (!wasm.getFunctionTypeOrNull(name)) throw ParseException(\""unknown function type\"");\n      FunctionType* type = wasm.getFunctionType(name);\n      result = type->result;\n      for (size_t j = 0; j < type->params.size(); j++) {\n        IString name = Name::fromInt(j);\n        Type currType = type->params[j];\n        typeParams.emplace_back(name, currType);\n        currLocalTypes[name] = currType;\n      }\n    } else if (id == IMPORT) {\n      importModule = curr[1]->str();\n      importBase = curr[2]->str();\n    } else {\n      // body\n      if (typeParams.size() > 0 && params.size() == 0) {\n        params = typeParams;\n      }\n      if (!currFunction) makeFunction();\n      Expression* ex = parseExpression(curr);\n      if (!body) {\n        body = ex;\n      } else {\n        ensureAutoBlock();\n        autoBlock->list.push_back(ex);\n      }\n    }\n  }\n  // see https://github.com/WebAssembly/spec/pull/301\n  if (type.isNull()) {\n    // if no function type name provided, then we generated one\n    auto functionType = make_unique<FunctionType>(sigToFunctionType(getSigFromStructs(result, params)));\n    for (auto& existing : wasm.functionTypes) {\n      if (existing->structuralComparison(*functionType)) {\n        type = existing->name;\n        break;\n      }\n    }\n    if (!type.is()) throw ParseException(\""no function type [internal error?]\"", s.line, s.col);\n  }\n  if (importModule.is()) {\n    // this is an import, actually\n    if (!preParseImport) throw ParseException(\""!preParseImport in func\"");\n    auto im = make_unique<Function>();\n    im->name = name;\n    im->module = importModule;\n    im->base = importBase;\n    im->type = type;\n    FunctionTypeUtils::fillFunction(im.get(), wasm.getFunctionType(type));\n    functionTypes[name] = im->result;\n    if (wasm.getFunctionOrNull(im->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n    wasm.addFunction(im.release());\n    if (currFunction) throw ParseException(\""import module inside function dec\"");\n    currLocalTypes.clear();\n    nameMapper.clear();\n    return;\n  }\n  if (preParseImport) throw ParseException(\""preParseImport in func\"");\n  if (brokeToAutoBlock) {\n    ensureAutoBlock();\n    autoBlock->name = FAKE_RETURN;\n  }\n  if (autoBlock) {\n    autoBlock->finalize(result);\n  }\n  if (!currFunction) {\n    makeFunction();\n    body = allocator.alloc<Nop>();\n  }\n  if (currFunction->result != result) throw ParseException(\""bad func declaration\"", s.line, s.col);\n  currFunction->body = body;\n  currFunction->type = type;\n  if (s.startLoc) {\n    currFunction->prologLocation.insert(getDebugLocation(*s.startLoc));\n  }\n  if (s.endLoc) {\n    currFunction->epilogLocation.insert(getDebugLocation(*s.endLoc));\n  }\n  if (wasm.getFunctionOrNull(currFunction->name)) throw ParseException(\""duplicate function\"", s.line, s.col);\n  wasm.addFunction(currFunction.release());\n  currLocalTypes.clear();\n  nameMapper.clear();\n}"", ""target"": 0}]","[{""func_name"": ""printAst"", ""file_path"": ""src/emscripten-optimizer/simple_ast.h"", ""func_code"": ""void printAst() {\n    print(ast);\n    ensure(1);\n    buffer[used] = 0;\n  }""}, {""func_name"": ""WasmBinaryBuilder::processFunctions"", ""file_path"": ""src/wasm/wasm-binary.cpp"", ""func_code"": ""void WasmBinaryBuilder::processFunctions() {\n  for (auto* func : functions) {\n    wasm.addFunction(func);\n  }\n\n  // now that we have names for each function, apply things\n\n  if (startIndex != static_cast<Index>(-1)) {\n    wasm.start = getFunctionIndexName(startIndex);\n  }\n\n  for (auto* curr : exportOrder) {\n    auto index = exportIndexes[curr];\n    switch (curr->kind) {\n      case ExternalKind::Function: {\n        if (index >= wasm.functions.size()) {\n          throwError(\""bad function export index\"");\n        }\n        curr->value = getFunctionIndexName(index);\n        break;\n      }\n      case ExternalKind::Table: curr->value = Name::fromInt(0); break;\n      case ExternalKind::Memory: curr->value = Name::fromInt(0); break;\n      case ExternalKind::Global: curr->value = getGlobalName(index); break;\n      default: throwError(\""bad export kind\"");\n    }\n    wasm.addExport(curr);\n  }\n\n  for (auto& iter : functionCalls) {\n    size_t index = iter.first;\n    auto& calls = iter.second;\n    for (auto* call : calls) {\n      call->target = getFunctionIndexName(index);\n    }\n  }\n\n  for (auto& pair : functionTable) {\n    auto i = pair.first;\n    auto& indexes = pair.second;\n    for (auto j : indexes) {\n      wasm.table.segments[i].data.push_back(getFunctionIndexName(j));\n    }\n  }\n\n  // Everything now has its proper name.\n\n  wasm.updateMaps();\n}""}, {""func_name"": ""SExpressionWasmBuilder::parseGlobal"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseGlobal(Element& s, bool preParseImport) {\n  std::unique_ptr<Global> global = make_unique<Global>();\n  size_t i = 1;\n  if (s[i]->dollared() && !(s[i]->isStr() && isType(s[i]->str()))) {\n    global->name = s[i++]->str();\n  } else {\n    global->name = Name::fromInt(globalCounter);\n  }\n  globalCounter++;\n  globalNames.push_back(global->name);\n  bool mutable_ = false;\n  Type type = none;\n  bool exported = false;\n  Name importModule, importBase;\n  while (i < s.size() && s[i]->isList()) {\n    auto& inner = *s[i];\n    if (inner[0]->str() == EXPORT) {\n      auto ex = make_unique<Export>();\n      ex->name = inner[1]->str();\n      ex->value = global->name;\n      ex->kind = ExternalKind::Global;\n      if (wasm.getExportOrNull(ex->name)) throw ParseException(\""duplicate export\"", s.line, s.col);\n      wasm.addExport(ex.release());\n      exported = true;\n      i++;\n    } else if (inner[0]->str() == IMPORT) {\n      importModule = inner[1]->str();\n      importBase = inner[2]->str();\n      i++;\n    } else if (inner[0]->str() == MUT) {\n      mutable_ = true;\n      type = stringToType(inner[1]->str());\n      i++;\n    } else {\n      break;\n    }\n  }\n  if (exported && mutable_) throw ParseException(\""cannot export a mutable global\"", s.line, s.col);\n  if (type == none) {\n    type = stringToType(s[i++]->str());\n  }\n  if (importModule.is()) {\n    // this is an import, actually\n    if (!importBase.size()) throw ParseException(\""module but no base for import\"");\n    if (!preParseImport) throw ParseException(\""!preParseImport in global\"");\n    auto im = make_unique<Global>();\n    im->name = global->name;\n    im->module = importModule;\n    im->base = importBase;\n    im->type = type;\n    im->mutable_ = mutable_;\n    if (wasm.getGlobalOrNull(im->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n    wasm.addGlobal(im.release());\n    return;\n  }\n  if (preParseImport) throw ParseException(\""preParseImport in global\"");\n  global->type = type;\n  if (i < s.size()) {\n    global->init = parseExpression(s[i++]);\n  } else {\n    throw ParseException(\""global without init\"", s.line, s.col);\n  }\n  global->mutable_ = mutable_;\n  if (i != s.size()) throw ParseException(\""extra import elements\"");\n  if (wasm.getGlobalOrNull(global->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n  wasm.addGlobal(global.release());\n}""}, {""func_name"": ""SExpressionWasmBuilder::parseImport"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseImport(Element& s) {\n  size_t i = 1;\n  bool newStyle = s.size() == 4 && s[3]->isList(); // (import \""env\"" \""STACKTOP\"" (global $stackTop i32))\n  auto kind = ExternalKind::Invalid;\n  if (newStyle) {\n    if ((*s[3])[0]->str() == FUNC) {\n      kind = ExternalKind::Function;\n    } else if ((*s[3])[0]->str() == MEMORY) {\n      kind = ExternalKind::Memory;\n      if (wasm.memory.exists) throw ParseException(\""more than one memory\"");\n      wasm.memory.exists = true;\n    } else if ((*s[3])[0]->str() == TABLE) {\n      kind = ExternalKind::Table;\n      if (wasm.table.exists) throw ParseException(\""more than one table\"");\n      wasm.table.exists = true;\n    } else if ((*s[3])[0]->str() == GLOBAL) {\n      kind = ExternalKind::Global;\n    } else {\n      newStyle = false; // either (param..) or (result..)\n    }\n  }\n  Index newStyleInner = 1;\n  Name name;\n  if (s.size() > 3 && s[3]->isStr()) {\n    name = s[i++]->str();\n  } else if (newStyle && newStyleInner < s[3]->size() && (*s[3])[newStyleInner]->dollared()) {\n    name = (*s[3])[newStyleInner++]->str();\n  }\n  if (!name.is()) {\n    if (kind == ExternalKind::Function) {\n      name = Name(\""import$function$\"" + std::to_string(functionCounter++));\n      functionNames.push_back(name);\n    } else if (kind == ExternalKind::Global) {\n      name = Name(\""import$global\"" + std::to_string(globalCounter++));\n      globalNames.push_back(name);\n    } else if (kind == ExternalKind::Memory) {\n      name = Name(\""import$memory$\"" + std::to_string(0));\n    } else if (kind == ExternalKind::Table) {\n      name = Name(\""import$table$\"" + std::to_string(0));\n    } else {\n      throw ParseException(\""invalid import\"");\n    }\n  }\n  if (!s[i]->quoted()) {\n    if (s[i]->str() == MEMORY) {\n      kind = ExternalKind::Memory;\n    } else if (s[i]->str() == TABLE) {\n      kind = ExternalKind::Table;\n    } else if (s[i]->str() == GLOBAL) {\n      kind = ExternalKind::Global;\n    } else {\n      throw ParseException(\""invalid ext import\"");\n    }\n    i++;\n  } else if (!newStyle) {\n    kind = ExternalKind::Function;\n  }\n  auto module = s[i++]->str();\n  if (!s[i]->isStr()) throw ParseException(\""no name for import\"");\n  auto base = s[i++]->str();\n  if (!module.size() || !base.size()) throw ParseException(\""imports must have module and base\"");\n  // parse internals\n  Element& inner = newStyle ? *s[3] : s;\n  Index j = newStyle ? newStyleInner : i;\n  if (kind == ExternalKind::Function) {\n    std::unique_ptr<FunctionType> type = make_unique<FunctionType>();\n    if (inner.size() > j) {\n      Element& params = *inner[j];\n      IString id = params[0]->str();\n      if (id == PARAM) {\n        for (size_t k = 1; k < params.size(); k++) {\n          type->params.push_back(stringToType(params[k]->str()));\n        }\n      } else if (id == RESULT) {\n        type->result = stringToType(params[1]->str());\n      } else if (id == TYPE) {\n        IString name = params[1]->str();\n        if (!wasm.getFunctionTypeOrNull(name)) throw ParseException(\""bad function type for import\"");\n        *type = *wasm.getFunctionType(name);\n      } else {\n        throw ParseException(\""bad import element\"");\n      }\n      if (inner.size() > j+1) {\n        Element& result = *inner[j+1];\n        if (result[0]->str() != RESULT) throw ParseException(\""expected result\"");\n        type->result = stringToType(result[1]->str());\n      }\n    }\n    auto func = make_unique<Function>();\n    func->name = name;\n    func->module = module;\n    func->base = base;\n    auto* functionType = ensureFunctionType(getSig(type.get()), &wasm);\n    func->type = functionType->name;\n    FunctionTypeUtils::fillFunction(func.get(), functionType);\n    functionTypes[name] = func->result;\n    wasm.addFunction(func.release());\n  } else if (kind == ExternalKind::Global) {\n    Type type;\n    bool mutable_ = false;\n    if (inner[j]->isStr()) {\n      type = stringToType(inner[j]->str());\n    } else {\n      auto& inner2 = *inner[j];\n      if (inner2[0]->str() != MUT) throw ParseException(\""expected mut\"");\n      type = stringToType(inner2[1]->str());\n      mutable_ = true;\n    }\n    auto global = make_unique<Global>();\n    global->name = name;\n    global->module = module;\n    global->base = base;\n    global->type = type;\n    global->mutable_ = mutable_;\n    wasm.addGlobal(global.release());\n  } else if (kind == ExternalKind::Table) {\n    wasm.table.module = module;\n    wasm.table.base = base;\n    if (j < inner.size() - 1) {\n      wasm.table.initial = getCheckedAddress(inner[j++], \""excessive table init size\"");\n    }\n    if (j < inner.size() - 1) {\n      wasm.table.max = getCheckedAddress(inner[j++], \""excessive table max size\"");\n    } else {\n      wasm.table.max = Table::kUnlimitedSize;\n    }\n    // ends with the table element type\n  } else if (kind == ExternalKind::Memory) {\n    wasm.memory.module = module;\n    wasm.memory.base = base;\n    if (inner[j]->isList()) {\n      auto& limits = *inner[j];\n      if (!(limits[0]->isStr() && limits[0]->str() == \""shared\"")) throw ParseException(\""bad memory limit declaration\"");\n      wasm.memory.shared = true;\n      parseMemoryLimits(limits, 1);\n    } else {\n      parseMemoryLimits(inner, j);\n    }\n  }\n}""}, {""func_name"": ""SExpressionWasmBuilder::parseFunction"", ""file_path"": ""src/wasm/wasm-s-parser.cpp"", ""func_code"": ""void SExpressionWasmBuilder::parseFunction(Element& s, bool preParseImport) {\n  size_t i = 1;\n  Name name, exportName;\n  i = parseFunctionNames(s, name, exportName);\n  if (!preParseImport) {\n    if (!name.is()) {\n      // unnamed, use an index\n      name = Name::fromInt(functionCounter);\n    }\n    functionCounter++;\n  } else {\n    // just preparsing, functionCounter was incremented by preParseFunctionType\n    if (!name.is()) {\n      // unnamed, use an index\n      name = functionNames[functionCounter - 1];\n    }\n  }\n  if (exportName.is()) {\n    auto ex = make_unique<Export>();\n    ex->name = exportName;\n    ex->value = name;\n    ex->kind = ExternalKind::Function;\n    if (wasm.getExportOrNull(ex->name)) throw ParseException(\""duplicate export\"", s.line, s.col);\n    wasm.addExport(ex.release());\n  }\n  Expression* body = nullptr;\n  localIndex = 0;\n  otherIndex = 0;\n  brokeToAutoBlock = false;\n  std::vector<NameType> typeParams; // we may have both params and a type. store the type info here\n  std::vector<NameType> params;\n  std::vector<NameType> vars;\n  Type result = none;\n  Name type;\n  Block* autoBlock = nullptr; // we may need to add a block for the very top level\n  Name importModule, importBase;\n  auto makeFunction = [&]() {\n    currFunction = std::unique_ptr<Function>(Builder(wasm).makeFunction(\n        name,\n        std::move(params),\n        result,\n        std::move(vars)\n    ));\n  };\n  auto ensureAutoBlock = [&]() {\n    if (!autoBlock) {\n      autoBlock = allocator.alloc<Block>();\n      autoBlock->list.push_back(body);\n      body = autoBlock;\n    }\n  };\n  for (;i < s.size(); i++) {\n    Element& curr = *s[i];\n    IString id = curr[0]->str();\n    if (id == PARAM || id == LOCAL) {\n      size_t j = 1;\n      while (j < curr.size()) {\n        IString name;\n        Type type = none;\n        if (!curr[j]->dollared()) { // dollared input symbols cannot be types\n          type = stringToType(curr[j]->str(), true);\n        }\n        if (type != none) {\n          // a type, so an unnamed parameter\n          name = Name::fromInt(localIndex);\n        } else {\n          name = curr[j]->str();\n          type = stringToType(curr[j+1]->str());\n          j++;\n        }\n        j++;\n        if (id == PARAM) {\n          params.emplace_back(name, type);\n        } else {\n          vars.emplace_back(name, type);\n        }\n        localIndex++;\n        currLocalTypes[name] = type;\n      }\n    } else if (id == RESULT) {\n      if (curr.size() > 2) throw ParseException(\""invalid result arity\"", curr.line, curr.col);\n      result = stringToType(curr[1]->str());\n    } else if (id == TYPE) {\n      Name name = getFunctionTypeName(*curr[1]);\n      type = name;\n      if (!wasm.getFunctionTypeOrNull(name)) throw ParseException(\""unknown function type\"");\n      FunctionType* type = wasm.getFunctionType(name);\n      result = type->result;\n      for (size_t j = 0; j < type->params.size(); j++) {\n        IString name = Name::fromInt(j);\n        Type currType = type->params[j];\n        typeParams.emplace_back(name, currType);\n        currLocalTypes[name] = currType;\n      }\n    } else if (id == IMPORT) {\n      importModule = curr[1]->str();\n      importBase = curr[2]->str();\n    } else {\n      // body\n      if (typeParams.size() > 0 && params.size() == 0) {\n        params = typeParams;\n      }\n      if (!currFunction) makeFunction();\n      Expression* ex = parseExpression(curr);\n      if (!body) {\n        body = ex;\n      } else {\n        ensureAutoBlock();\n        autoBlock->list.push_back(ex);\n      }\n    }\n  }\n  // see https://github.com/WebAssembly/spec/pull/301\n  if (type.isNull()) {\n    // if no function type name provided, then we generated one\n    auto functionType = make_unique<FunctionType>(sigToFunctionType(getSigFromStructs(result, params)));\n    for (auto& existing : wasm.functionTypes) {\n      if (existing->structuralComparison(*functionType)) {\n        type = existing->name;\n        break;\n      }\n    }\n    if (!type.is()) throw ParseException(\""no function type [internal error?]\"", s.line, s.col);\n  }\n  if (importModule.is()) {\n    // this is an import, actually\n    if (!importBase.size()) throw ParseException(\""module but no base for import\"");\n    if (!preParseImport) throw ParseException(\""!preParseImport in func\"");\n    auto im = make_unique<Function>();\n    im->name = name;\n    im->module = importModule;\n    im->base = importBase;\n    im->type = type;\n    FunctionTypeUtils::fillFunction(im.get(), wasm.getFunctionType(type));\n    functionTypes[name] = im->result;\n    if (wasm.getFunctionOrNull(im->name)) throw ParseException(\""duplicate import\"", s.line, s.col);\n    wasm.addFunction(im.release());\n    if (currFunction) throw ParseException(\""import module inside function dec\"");\n    currLocalTypes.clear();\n    nameMapper.clear();\n    return;\n  }\n  if (preParseImport) throw ParseException(\""preParseImport in func\"");\n  if (brokeToAutoBlock) {\n    ensureAutoBlock();\n    autoBlock->name = FAKE_RETURN;\n  }\n  if (autoBlock) {\n    autoBlock->finalize(result);\n  }\n  if (!currFunction) {\n    makeFunction();\n    body = allocator.alloc<Nop>();\n  }\n  if (currFunction->result != result) throw ParseException(\""bad func declaration\"", s.line, s.col);\n  currFunction->body = body;\n  currFunction->type = type;\n  if (s.startLoc) {\n    currFunction->prologLocation.insert(getDebugLocation(*s.startLoc));\n  }\n  if (s.endLoc) {\n    currFunction->epilogLocation.insert(getDebugLocation(*s.endLoc));\n  }\n  if (wasm.getFunctionOrNull(currFunction->name)) throw ParseException(\""duplicate function\"", s.line, s.col);\n  wasm.addFunction(currFunction.release());\n  currLocalTypes.clear();\n  nameMapper.clear();\n}""}]","{""code"": 2, ""value"": 1, ""function"": 1}","[{""source"": ""code_info(file:wasm-binary.cpp, lines:1490-1510)"", ""result"": ""  return mappedGlobals[index];\n}\n\nvoid WasmBinaryBuilder::processFunctions() {\n  for (auto* func : functions) {\n    wasm.addFunction(func);\n  }\n\n  // now that we have names for each function, apply things\n\n  if (startIndex != static_cast<Index>(-1)) {\n    wasm.start = getFunctionIndexName(startIndex);\n  }\n\n  for (auto* curr : exportOrder) {\n    auto index = exportIndexes[curr];\n    switch (curr->kind) {\n      case ExternalKind::Function: {\n        curr->value = getFunctionIndexName(index);\n        break;\n      }\n      case ExternalKind::Table: curr->value = Name::fromInt(0); break;\n""}, {""source"": ""value_info(file:wasm-binary.cpp, value:exportIndexes)"", ""result"": {""value_trace"": [{""full_code"": ""exportIndexes[curr] = index"", ""line"": 1160, ""func_name"": ""wasm.WasmBinaryBuilder.readExports:void()""}], ""struct_var"": ""exportIndexes"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:wasm-binary.cpp, lines:1150-1170)"", ""result"": ""  for (size_t i = 0; i < num; i++) {\n    if (debug) std::cerr << \""read one\"" << std::endl;\n    auto curr = new Export;\n    curr->name = getInlineString();\n    if (names.count(curr->name) > 0) {\n      throwError(\""duplicate export name\"");\n    }\n    names.insert(curr->name);\n    curr->kind = (ExternalKind)getU32LEB();\n    auto index = getU32LEB();\n    exportIndexes[curr] = index;\n    exportOrder.push_back(curr);\n  }\n}\n\nstatic int32_t readBase64VLQ(std::istream& in) {\n  uint32_t value = 0;\n  uint32_t shift = 0;\n  while (1) {\n    auto ch = in.get();\n    if (ch == EOF)\n      throw MapParseException(\""unexpected EOF in the middle of VLQ\"");\n""}, {""source"": ""func_info(file:wasm-binary.cpp, func:getU32LEB)"", ""result"": [{""code"": ""uint32_t WasmBinaryBuilder::getU32LEB() {\n  if (debug) std::cerr << \""<==\"" << std::endl;\n  U32LEB ret;\n  ret.read([&]() {\n      return getInt8();\n    });\n  if (debug) std::cerr << \""getU32LEB: \"" << ret.value << \"" ==>\"" << std::endl;\n  return ret.value;\n}"", ""start_line"": 800, ""end_line"": 808, ""full_name"": ""wasm.WasmBinaryBuilder.getU32LEB:uint32_t()"", ""file_path"": ""src/wasm/wasm-binary.cpp""}]}]","The vulnerability arises from unvalidated index values read during WebAssembly export parsing. Specifically:\n1. Export indexes are read via `getU32LEB()` (wasm-binary.cpp:1160) without bounds checking against `wasm.functions.size()`.\n2. These indexes are stored in `exportIndexes` and later used in `processFunctions()` (wasm-binary.cpp:1506) to call `getFunctionIndexName()`, causing a NULL dereference if out-of-bounds.\n3. The patch added a bounds check in `processFunctions()` but did not address input validation during parsing.",0.95,./github/other_context/CVE-2019-7153
33,CVE-2020-14396,CWE-476,c_cpp,An issue was discovered in LibVNCServer before 0.9.13. libvncclient/tls_openssl.c has a NULL pointer dereference.,https://github.com/LibVNC/libvncserver/commit/33441d90a506d5f3ae9388f2752901227e430553,libvncclient/tls_openssl: do not deref a NULL pointer\n\nHappens in anonTLS mode where cred is NULL.\n\nre #347,1,"[{""func_name"": ""open_ssl_connection"", ""file_path"": ""libvncclient/tls_openssl.c"", ""func_code"": ""static SSL *\nopen_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls = cred->x509Credential.x509CrlVerifyMode;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\""Could not create new SSL context.\\n\"");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\""Failed to load CA certificate from %s.\\n\"",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\""Using default paths for certificate verification.\\n\"");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\""CRLs could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\""Client certificate could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\""Client private key could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\""Client certificate and private key do not match.\\n\"");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\""Could not set server name for verification.\\n\"");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\""Could not create a new SSL session.\\n\"");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \""ALL\"");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}"", ""target"": 0}]","[{""func_name"": ""open_ssl_connection"", ""file_path"": ""libvncclient/tls_openssl.c"", ""func_code"": ""static SSL *\nopen_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\""Could not create new SSL context.\\n\"");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    verify_crls = cred->x509Credential.x509CrlVerifyMode;\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\""Failed to load CA certificate from %s.\\n\"",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\""Using default paths for certificate verification.\\n\"");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\""CRLs could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\""Client certificate could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\""Client private key could not be loaded.\\n\"");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\""Client certificate and private key do not match.\\n\"");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\""Could not set server name for verification.\\n\"");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\""Could not create a new SSL session.\\n\"");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \""ALL\"");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}""}]","{""value"": 2, ""code"": 1}","[{""source"": ""value_info(file:tls_openssl.c, value:anonTLS)"", ""result"": {""value_trace"": [{""full_code"": ""anonTLS = TRUE"", ""line"": 577, ""func_name"": ""HandleVeNCryptAuth<duplicate>1""}, {""full_code"": ""anonTLS = FALSE"", ""line"": 580, ""func_name"": ""HandleVeNCryptAuth<duplicate>1""}], ""struct_var"": ""anonTLS"", ""struct_type"": ""rfbBool"", ""struct_definition"": ""static rfbBool\n\nstatic rfbBool\n\nstatic rfbBool\n\nstatic rfbBool\n\nstatic rfbBool\n\ntypedef int8_t rfbBool;\n\ntypedef int8_t rfbBool;""}}, {""source"": ""value_info(file:tls_openssl.c, value:cred)"", ""result"": {""value_trace"": [{""full_code"": ""*cred = NULL"", ""line"": 528, ""func_name"": ""HandleVeNCryptAuth<duplicate>1""}, {""full_code"": ""cred = client->GetCredential(client, rfbCredentialTypeX509)"", ""line"": 593, ""func_name"": ""HandleVeNCryptAuth<duplicate>1""}], ""struct_var"": ""cred"", ""struct_type"": ""rfbCredential*"", ""struct_definition"": ""typedef union _rfbCredential\n{\n  /** X509 (VeNCrypt) */\n  struct\n  {\n    char *x509CACertFile;\n    char *x509CACrlFile;\n    char *x509ClientCertFile;\n    char *x509ClientKeyFile;\n    uint8_t x509CrlVerifyMode; /* Only required for OpenSSL - see meanings below */\n  } x509Credential;\n  /** Plain (VeNCrypt), MSLogon (UltraVNC) */\n  struct\n  {\n    char *username;\n    char *password;\n  } userCredential;\n} rfbCredential;""}}, {""source"": ""code_info(file:tls_openssl.c, lines:577-593)"", ""result"": ""      anonTLS = TRUE;\n      break;\n    default:\n      anonTLS = FALSE;\n      break;\n  }\n\n  /* Get X509 Credentials if it's not anonymous */\n  if (!anonTLS)\n  {\n\n    if (!client->GetCredential)\n    {\n      rfbClientLog(\""GetCredential callback is not set.\\n\"");\n      return FALSE;\n    }\n    cred = client->GetCredential(client, rfbCredentialTypeX509);\n    if (!cred)\n""}]","libvncclient/tls_openssl.c:269-282: Original code dereferences 'cred->x509Credential.x509CrlVerifyMode' outside the 'if (!anonTLS)' block. When 'anonTLS' is TRUE (set in HandleVeNCryptAuth:577/580), 'cred' remains NULL (initialized to NULL in tls_openssl.c:528) and is not reassigned (confirmed in HandleVeNCryptAuth:577-593, where 'cred = client->GetCredential(...)' is skipped in 'anonTLS' mode). This leads to a NULL pointer dereference. The patch moves the dereference inside the 'if (!anonTLS)' block (line 282), preventing the issue.",0.95,./github/other_context/CVE-2020-14396
34,CVE-2020-16295,CWE-476,c_cpp,A null pointer dereference vulnerability in clj_media_size() in devices/gdevclj.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.,https://github.com/ArtifexSoftware/ghostpdl/commit/2c2dc335c212750e0fb8ae157063bc06cafa8d3e,"Color Laserjet device - properly check params\n\nBug #701796 ""Segmentation fault at devices/gdevclj.c:269 in clj_media_size""\n\nThe test in clj_media_size() as incorrect, it didn't signal an error if\nthere was no HWResolution in the param list. This left the parameter\n'fres' undefined leading to a potential invalid memory read, or a\ndivide-by-zero error.\n\nThis commit returns an error if we get a param list with no HWResolution\nI'm not absolutely certain if this is correct, but at least signalling\nan error is better than a seg fault.",1,"[{""func_name"": ""clj_media_size"", ""file_path"": ""devices/gdevclj.c"", ""func_code"": ""static int\nclj_media_size(float mediasize[2], gs_param_list *plist)\n{\n    gs_param_float_array fres;\n    gs_param_float_array fsize;\n    gs_param_int_array hwsize;\n    int have_pagesize = 0;\n\n    if ( (param_read_float_array(plist, \""HWResolution\"", &fres) == 0) &&\n          !is_supported_resolution(fres.data) )\n        return_error(gs_error_rangecheck);\n\n    if ( (param_read_float_array(plist, \""PageSize\"", &fsize) == 0) ||\n         (param_read_float_array(plist, \"".MediaSize\"", &fsize) == 0) ) {\n        mediasize[0] = fsize.data[0];\n        mediasize[1] = fsize.data[1];\n        have_pagesize = 1;\n    }\n\n    if (param_read_int_array(plist, \""HWSize\"", &hwsize) == 0) {\n        mediasize[0] = ((float)hwsize.data[0]) * 72 / fres.data[0];\n        mediasize[1] = ((float)hwsize.data[1]) * 72 / fres.data[1];\n        have_pagesize = 1;\n    }\n\n    return have_pagesize;\n}"", ""target"": 0}]","[{""func_name"": ""clj_media_size"", ""file_path"": ""devices/gdevclj.c"", ""func_code"": ""static int\nclj_media_size(float mediasize[2], gs_param_list *plist)\n{\n    gs_param_float_array fres;\n    gs_param_float_array fsize;\n    gs_param_int_array hwsize;\n    int have_pagesize = 0;\n\n    if ( param_read_float_array(plist, \""HWResolution\"", &fres) != 0 ||\n          !is_supported_resolution(fres.data) )\n        return_error(gs_error_rangecheck);\n\n    if ( (param_read_float_array(plist, \""PageSize\"", &fsize) == 0) ||\n         (param_read_float_array(plist, \"".MediaSize\"", &fsize) == 0) ) {\n        mediasize[0] = fsize.data[0];\n        mediasize[1] = fsize.data[1];\n        have_pagesize = 1;\n    }\n\n    if (param_read_int_array(plist, \""HWSize\"", &hwsize) == 0) {\n        mediasize[0] = ((float)hwsize.data[0]) * 72 / fres.data[0];\n        mediasize[1] = ((float)hwsize.data[1]) * 72 / fres.data[1];\n        have_pagesize = 1;\n    }\n\n    return have_pagesize;\n}""}]","{""function"": 1, ""code"": 1, ""value"": 1}","[{""source"": ""func_info(func:param_read_float_array)"", ""result"": [{""code"": ""int\nparam_read_float_array(gs_param_list * plist, gs_param_name pkey,\n                       gs_param_float_array * pvalue)\n{\n    RETURN_READ_TYPED(fa, gs_param_type_float_array);\n}"", ""start_line"": 346, ""end_line"": 351, ""full_name"": ""param_read_float_array"", ""file_path"": ""base/gsparam.c""}]}, {""source"": ""code_info(file:gdevclj.c, lines:255-269)"", ""result"": ""    int have_pagesize = 0;\n\n    if ( (param_read_float_array(plist, \""HWResolution\"", &fres) == 0) &&\n          !is_supported_resolution(fres.data) )\n        return_error(gs_error_rangecheck);\n\n    if ( (param_read_float_array(plist, \""PageSize\"", &fsize) == 0) ||\n         (param_read_float_array(plist, \"".MediaSize\"", &fsize) == 0) ) {\n        mediasize[0] = fsize.data[0];\n        mediasize[1] = fsize.data[1];\n        have_pagesize = 1;\n    }\n\n    if (param_read_int_array(plist, \""HWSize\"", &hwsize) == 0) {\n        mediasize[0] = ((float)hwsize.data[0]) * 72 / fres.data[0];\n        mediasize[1] = ((float)hwsize.data[1]) * 72 / fres.data[1];\n""}, {""source"": ""value_info(file:gdevclj.c, value:fres)"", ""result"": {""value_trace"": [{""full_code"": ""pfres->FontType = ftype"", ""line"": 410, ""func_name"": ""font_resource_alloc""}, {""full_code"": ""pfres->count = chars_count"", ""line"": 411, ""func_name"": ""font_resource_alloc""}, {""full_code"": ""pfres->Widths = widths"", ""line"": 412, ""func_name"": ""font_resource_alloc""}, {""full_code"": ""pfres->used = used"", ""line"": 413, ""func_name"": ""font_resource_alloc""}, {""full_code"": ""pfres->write_contents = write_contents"", ""line"": 414, ""func_name"": ""font_resource_alloc""}], ""struct_var"": ""fres"", ""struct_type"": ""gs_param_float_array"", ""struct_definition"": ""typedef _param_array_struct(gs_param_float_array_s, float) gs_param_float_array;""}}]","The 'clj_media_size' function in 'devices/gdevclj.c' (lines 255-269) fails to handle the case where 'HWResolution' is missing from the parameter list. The 'param_read_float_array' function (base/gsparam.c:346-351) returns a non-zero error code when 'HWResolution' is absent, leaving 'fres' (a 'gs_param_float_array') uninitialized. Subsequent code uses 'fres.data' in calculations (e.g., '72 / fres.data[0]'), leading to an invalid memory read or divide-by-zero. The patch corrects this by returning an error when 'HWResolution' is missing.",0.95,./github/other_context/CVE-2020-16295
35,CVE-2020-16306,CWE-476,c_cpp,A null pointer dereference vulnerability in devices/gdevtsep.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted postscript file. This is fixed in v9.51.,https://github.com/ArtifexSoftware/ghostpdl/commit/aadb53eb834b3def3ef68d78865ff87a68901804,"Tiffsep and Tiffsep1 - abort on multi-page input wtithout %d OutputFile\n\nBug #701821 ""Segmentation fault at tiff//libtiff/tif_dirinfo.c:513 in TIFFFindField""\n\nThe tiffsep and tiffsep1 only set 'code' to an error when an attempt is\nmade to write a second output file without using %d in the OutputFile\nspecification.\n\nThis causes problems later when attempting to process the files. The\ndevices should exit without trying to further process the pages under\nthese conditions and this commit returns immediately on error.\n\nThe other devices like this already return immediately on error, it\nlooks like the code here was copied between  devices without realising\nthat the tiffsep and tiffsep1 devices didn't exit when the error\ncondition was set.",2,"[{""func_name"": ""tiffsep1_print_page"", ""file_path"": ""devices/gdevtsep.c"", ""func_code"": ""static int\ntiffsep1_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    tiffsep1_device * const tfdev = (tiffsep1_device *)pdev;\n    int num_std_colorants = tfdev->devn_params.num_std_colorant_names;\n    int num_order = tfdev->devn_params.num_separation_order_names;\n    int num_spot = tfdev->devn_params.separations.num_separations;\n    int num_comp, comp_num, code = 0, code1 = 0;\n    short map_comp_to_sep[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    char *name = NULL;\n    int save_depth = pdev->color_info.depth;\n    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int non_encodable_count = 0;\n\n    if (tfdev->thresholds[0].dstart == NULL)\n        return_error(gs_error_rangecheck);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    build_comp_to_sep_map((tiffsep_device *)tfdev, map_comp_to_sep);\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep1.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n    }\n    /* If the output file is on disk and the name contains a page #, */\n    /* then delete the previous file. */\n    if (pdev->file != NULL && parsed.iodev == iodev_default(pdev->memory) && fmt) {\n        long count1 = pdev->PageCount;\n        char *compname = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(compname)\"");\n        if (!compname) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        gx_device_close_output_file((gx_device *)pdev, pdev->fname, pdev->file);\n        pdev->file = NULL;\n\n        while (*fmt != 'l' && *fmt != '%')\n            --fmt;\n        if (*fmt == 'l')\n            gs_sprintf(compname, parsed.fname, count1);\n        else\n            gs_sprintf(compname, parsed.fname, (int)count1);\n        parsed.iodev->procs.delete_file(parsed.iodev, compname);\n        /* we always need an open printer (it will get deleted in tiffsep1_prn_close */\n        code = gdev_prn_open_printer((gx_device *)pdev, 1);\n\n        gs_free_object(pdev->memory, compname, \""tiffsep_print_page(compname)\"");\n        if (code < 0) {\n            goto done;\n        }\n    }\n\n    /* Set up the separation output files */\n    num_comp = number_output_separations( tfdev->color_info.num_components,\n                                        num_std_colorants, num_order, num_spot);\n    for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n        int sep_num = map_comp_to_sep[comp_num];\n\n        code = create_separation_file_name((tiffsep_device *)tfdev, name,\n                                        gp_file_name_sizeof, sep_num, true);\n        if (code < 0) {\n            goto done;\n        }\n\n        /* Open the separation file, if not already open */\n        if (tfdev->sep_file[comp_num] == NULL) {\n            code = gs_add_outputfile_control_path(tfdev->memory, name);\n            if (code < 0) {\n                goto done;\n            }\n            code = gx_device_open_output_file((gx_device *)pdev, name,\n                    true, true, &(tfdev->sep_file[comp_num]));\n            if (code < 0) {\n                goto done;\n            }\n            tfdev->tiff[comp_num] = tiff_from_filep(pdev, name,\n                                                    tfdev->sep_file[comp_num],\n                                                    tfdev->BigEndian, tfdev->UseBigTIFF);\n            if (!tfdev->tiff[comp_num]) {\n                code = gs_note_error(gs_error_ioerror);\n                goto done;\n            }\n        }\n\n        pdev->color_info.depth = 8;     /* Create files for 8 bit gray */\n        pdev->color_info.num_components = 1;\n        code = tiff_set_fields_for_printer(pdev, tfdev->tiff[comp_num], 1, 0, tfdev->write_datetime);\n        tiff_set_gray_fields(pdev, tfdev->tiff[comp_num], 1, tfdev->Compression, tfdev->MaxStripSize);\n        pdev->color_info.depth = save_depth;\n        pdev->color_info.num_components = save_numcomps;\n        if (code < 0) {\n            goto done;\n        }\n\n    }   /* end initialization of separation files */\n\n\n    {   /* Get the expanded contone line, halftone and write out the dithered separations */\n        byte *planes[GS_CLIENT_COLOR_MAX_COMPONENTS];\n        int width = tfdev->width;\n        int raster_plane = bitmap_raster(width * 8);\n        int dithered_raster = ((7 + width) / 8) + ARCH_SIZEOF_LONG;\n        int pixel, y;\n        gs_get_bits_params_t params;\n        gs_int_rect rect;\n        /* the dithered_line is assumed to be 32-bit aligned by the alloc */\n        uint32_t *dithered_line = (uint32_t *)gs_alloc_bytes(pdev->memory, dithered_raster,\n                                \""tiffsep1_print_page\"");\n\n        memset(planes, 0, sizeof(*planes) * GS_CLIENT_COLOR_MAX_COMPONENTS);\n\n        /* Return planar data */\n        params.options = (GB_RETURN_POINTER | GB_RETURN_COPY |\n             GB_ALIGN_STANDARD | GB_OFFSET_0 | GB_RASTER_STANDARD |\n             GB_PACKING_PLANAR | GB_COLORS_NATIVE | GB_ALPHA_NONE);\n        params.x_offset = 0;\n        params.raster = bitmap_raster(width * pdev->color_info.depth);\n\n        code = 0;\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                            \""tiffsep1_print_page\"");\n            if (planes[comp_num] == NULL) {\n                code = gs_error_VMerror;\n                break;\n            }\n        }\n\n        if (code < 0 || dithered_line == NULL) {\n            code = gs_note_error(gs_error_VMerror);\n            goto cleanup;\n        }\n\n        for (comp_num = 0; comp_num < num_comp; comp_num++ )\n            TIFFCheckpointDirectory(tfdev->tiff[comp_num]);\n\n        rect.p.x = 0;\n        rect.q.x = pdev->width;\n        /* Loop for the lines */\n        for (y = 0; y < pdev->height; ++y) {\n            rect.p.y = y;\n            rect.q.y = y + 1;\n            /* We have to reset the pointers since get_bits_rect will have moved them */\n            for (comp_num = 0; comp_num < num_comp; comp_num++)\n                params.data[comp_num] = planes[comp_num];\n            code = (*dev_proc(pdev, get_bits_rectangle))((gx_device *)pdev, &rect, &params, NULL);\n            if (code < 0)\n                break;\n\n            /* Dither the separation and write it out */\n            for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n\n/***** #define SKIP_HALFTONING_FOR_TIMING *****/ /* uncomment for timing test */\n#ifndef SKIP_HALFTONING_FOR_TIMING\n\n                /*\n                 * Define 32-bit writes by default. Testing shows that while this is more\n                 * complex code, it runs measurably and consistently faster than the more\n                 * obvious 8-bit code. The 8-bit code is kept to help future optimization\n                 * efforts determine what affects tight loop optimization. Subtracting the\n                 * time when halftoning is skipped shows that the 32-bit halftoning is\n                 * 27% faster.\n                 */\n#define USE_32_BIT_WRITES\n                byte *thresh_line_base = tfdev->thresholds[comp_num].dstart +\n                                    ((y % tfdev->thresholds[comp_num].dheight) *\n                                        tfdev->thresholds[comp_num].dwidth) ;\n                byte *thresh_ptr = thresh_line_base;\n                byte *thresh_limit = thresh_ptr + tfdev->thresholds[comp_num].dwidth;\n                byte *src = params.data[comp_num];\n#ifdef USE_32_BIT_WRITES\n                uint32_t *dest = dithered_line;\n                uint32_t val = 0;\n                const uint32_t *mask = &bit_order[0];\n#else   /* example 8-bit code */\n                byte *dest = dithered_line;\n                byte val = 0;\n                byte mask = 0x80;\n#endif /* USE_32_BIT_WRITES */\n\n                for (pixel = 0; pixel < width; pixel++, src++) {\n#ifdef USE_32_BIT_WRITES\n                    if (*src < *thresh_ptr++)\n                        val |= *mask;\n                    if (++mask == &(bit_order[32])) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = &bit_order[0];\n                    }\n#else   /* example 8-bit code */\n                    if (*src < *thresh_ptr++)\n                        val |= mask;\n                    mask >>= 1;\n                    if (mask == 0) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = 0x80;\n                    }\n#endif /* USE_32_BIT_WRITES */\n                    if (thresh_ptr >= thresh_limit)\n                        thresh_ptr = thresh_line_base;\n                } /* end src pixel loop - collect last bits if any */\n                /* the following relies on their being enough 'pad' in dithered_line */\n#ifdef USE_32_BIT_WRITES\n                if (mask != &bit_order[0]) {\n                    *dest = val;\n                }\n#else   /* example 8-bit code */\n                if (mask != 0x80) {\n                    *dest = val;\n                }\n#endif /* USE_32_BIT_WRITES */\n#endif /* SKIP_HALFTONING_FOR_TIMING */\n                TIFFWriteScanline(tfdev->tiff[comp_num], (tdata_t)dithered_line, y, 0);\n            } /* end component loop */\n        }\n        /* Update the strip data */\n        for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n            TIFFWriteDirectory(tfdev->tiff[comp_num]);\n            if (fmt) {\n                int sep_num = map_comp_to_sep[comp_num];\n\n                code = create_separation_file_name((tiffsep_device *)tfdev, name, gp_file_name_sizeof, sep_num, false);\n                if (code < 0) {\n                    code1 = code;\n                    continue;\n                }\n                code = tiffsep_close_sep_file((tiffsep_device *)tfdev, name, comp_num);\n                if (code >= 0)\n                    code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                if (code < 0) {\n                    code1 = code;\n                }\n            }\n        }\n        code = code1;\n\n        /* free any allocations and exit with code */\ncleanup:\n        gs_free_object(pdev->memory, dithered_line, \""tiffsep1_print_page\"");\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            gs_free_object(pdev->memory, planes[comp_num], \""tiffsep1_print_page\"");\n        }\n    }\n    /*\n     * If we have any non encodable pixels then signal an error.\n     */\n    if (non_encodable_count) {\n        dmlprintf1(pdev->memory, \""WARNING:  Non encodable pixels = %d\\n\"", non_encodable_count);\n        code = gs_note_error(gs_error_rangecheck);\n    }\n\ndone:\n    if (name)\n        gs_free_object(pdev->memory, name, \""tiffsep1_print_page(name)\"");\n    return code;\n}"", ""target"": 0}, {""func_name"": ""tiffsep_print_page"", ""file_path"": ""devices/gdevtsep.c"", ""func_code"": ""static int\ntiffsep_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    tiffsep_device * const tfdev = (tiffsep_device *)pdev;\n    int num_std_colorants = tfdev->devn_params.num_std_colorant_names;\n    int num_order = tfdev->devn_params.num_separation_order_names;\n    int num_spot = tfdev->devn_params.separations.num_separations;\n    int num_comp, comp_num, sep_num, code = 0, code1 = 0;\n    cmyk_composite_map cmyk_map[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    char *name = NULL;\n    bool double_f = false;\n    int base_filename_length = length_base_file_name(tfdev, &double_f);\n    int save_depth = pdev->color_info.depth;\n    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int plane_count = 0;  /* quiet compiler */\n    int factor = tfdev->downscale.downscale_factor;\n    int mfs = tfdev->downscale.min_feature_size;\n    int dst_bpc = tfdev->BitsPerComponent;\n    gx_downscaler_t ds;\n    int width = gx_downscaler_scale(tfdev->width, factor);\n    int height = gx_downscaler_scale(tfdev->height, factor);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    /* Print the names of the spot colors */\n    if (num_order == 0) {\n        for (sep_num = 0; sep_num < num_spot; sep_num++) {\n            copy_separation_name(tfdev, name,\n                gp_file_name_sizeof - base_filename_length - SUFFIX_SIZE, sep_num, 0);\n            dmlprintf1(pdev->memory, \""%%%%SeparationName: %s\\n\"", name);\n        }\n    }\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n    }\n    /* Write the page directory for the CMYK equivalent file. */\n    if (!tfdev->comp_file) {\n        pdev->color_info.depth = dst_bpc*4;        /* Create directory for 32 bit cmyk */\n        if (!tfdev->UseBigTIFF && tfdev->Compression==COMPRESSION_NONE &&\n            height > ((unsigned long) 0xFFFFFFFF - (file ? gp_ftell(file) : 0))/(width*4)) { /* note width is never 0 in print_page */\n            dmprintf(pdev->memory, \""CMYK composite file would be too large! Reduce resolution or enable compression.\\n\"");\n            return_error(gs_error_rangecheck);  /* this will overflow 32 bits */\n        }\n\n        code = gx_device_open_output_file((gx_device *)pdev, pdev->fname, true, true, &(tfdev->comp_file));\n        if (code < 0) {\n            goto done;\n        }\n\n        tfdev->tiff_comp = tiff_from_filep(pdev, pdev->dname, tfdev->comp_file, tfdev->BigEndian, tfdev->UseBigTIFF);\n        if (!tfdev->tiff_comp) {\n            code = gs_note_error(gs_error_invalidfileaccess);\n            goto done;\n        }\n\n    }\n    code = tiff_set_fields_for_printer(pdev, tfdev->tiff_comp, factor, 0, tfdev->write_datetime);\n\n    if (dst_bpc == 1 || dst_bpc == 8) {\n        tiff_set_cmyk_fields(pdev, tfdev->tiff_comp, dst_bpc, tfdev->Compression, tfdev->MaxStripSize);\n    }\n    else {\n        /* Catch-all just for safety's sake */\n        tiff_set_cmyk_fields(pdev, tfdev->tiff_comp, dst_bpc, COMPRESSION_NONE, tfdev->MaxStripSize);\n    }\n\n    pdev->color_info.depth = save_depth;\n    if (code < 0) {\n        goto done;\n    }\n\n    /* Set up the separation output files */\n    num_comp = number_output_separations( tfdev->color_info.num_components,\n                                        num_std_colorants, num_order, num_spot);\n\n    if (!tfdev->NoSeparationFiles && !num_order && num_comp < num_std_colorants + num_spot) {\n        dmlprintf(pdev->memory, \""Warning: skipping one or more colour separations, see: Devices.htm#TIFF\\n\"");\n    }\n\n    if (!tfdev->NoSeparationFiles) {\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            int sep_num = tfdev->devn_params.separation_order_map[comp_num];\n\n            code = create_separation_file_name(tfdev, name, gp_file_name_sizeof,\n                sep_num, true);\n            if (code < 0) {\n                goto done;\n            }\n\n            /*\n             * Close the old separation file if we are creating individual files\n             * for each page.\n             */\n            if (tfdev->sep_file[comp_num] != NULL && fmt != NULL) {\n                code = tiffsep_close_sep_file(tfdev, name, comp_num);\n                if (code >= 0)\n                    code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                if (code < 0)\n                    return code;\n            }\n            /* Open the separation file, if not already open */\n            if (tfdev->sep_file[comp_num] == NULL) {\n                code = gs_add_outputfile_control_path(tfdev->memory, name);\n                if (code < 0) {\n                    goto done;\n                }\n                code = gx_device_open_output_file((gx_device *)pdev, name,\n                    true, true, &(tfdev->sep_file[comp_num]));\n                if (code < 0) {\n                    goto done;\n                }\n                tfdev->tiff[comp_num] = tiff_from_filep(pdev, name,\n                    tfdev->sep_file[comp_num],\n                    tfdev->BigEndian, tfdev->UseBigTIFF);\n                if (!tfdev->tiff[comp_num]) {\n                    code = gs_note_error(gs_error_ioerror);\n                    goto done;\n                }\n            }\n\n            pdev->color_info.depth = dst_bpc;     /* Create files for 8 bit gray */\n            pdev->color_info.num_components = 1;\n            if (!tfdev->UseBigTIFF && tfdev->Compression == COMPRESSION_NONE &&\n                height * 8 / dst_bpc > ((unsigned long)0xFFFFFFFF - (file ? gp_ftell(file) : 0)) / width) /* note width is never 0 in print_page */\n            {\n                code = gs_note_error(gs_error_rangecheck);  /* this will overflow 32 bits */\n                goto done;\n            }\n\n\n            code = tiff_set_fields_for_printer(pdev, tfdev->tiff[comp_num], factor, 0, tfdev->write_datetime);\n            tiff_set_gray_fields(pdev, tfdev->tiff[comp_num], dst_bpc, tfdev->Compression, tfdev->MaxStripSize);\n            pdev->color_info.depth = save_depth;\n            pdev->color_info.num_components = save_numcomps;\n            if (code < 0) {\n                goto done;\n            }\n        }\n    }\n\n    build_cmyk_map((gx_device*) tfdev, num_comp, &tfdev->equiv_cmyk_colors, cmyk_map);\n    if (tfdev->PrintSpotCMYK) {\n        code = print_cmyk_equivalent_colors(tfdev, num_comp, cmyk_map);\n        if (code < 0) {\n            goto done;\n        }\n    }\n\n    {\n        int raster_plane = bitmap_raster(width * 8);\n        byte *planes[GS_CLIENT_COLOR_MAX_COMPONENTS] = { 0 };\n        int cmyk_raster = width * NUM_CMYK_COMPONENTS;\n        int pixel, y;\n        byte * sep_line;\n        int plane_index;\n        int offset_plane = 0;\n\n        sep_line =\n            gs_alloc_bytes(pdev->memory, cmyk_raster, \""tiffsep_print_page\"");\n        if (!sep_line) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        if (!tfdev->NoSeparationFiles)\n            for (comp_num = 0; comp_num < num_comp; comp_num++ )\n                TIFFCheckpointDirectory(tfdev->tiff[comp_num]);\n        TIFFCheckpointDirectory(tfdev->tiff_comp);\n\n        /* Write the page data. */\n        {\n            gs_get_bits_params_t params;\n            int byte_width;\n\n            /* Return planar data */\n            params.options = (GB_RETURN_POINTER | GB_RETURN_COPY |\n                 GB_ALIGN_STANDARD | GB_OFFSET_0 | GB_RASTER_STANDARD |\n                 GB_PACKING_PLANAR | GB_COLORS_NATIVE | GB_ALPHA_NONE);\n            params.x_offset = 0;\n            params.raster = bitmap_raster(width * pdev->color_info.depth);\n\n            if (num_order > 0) {\n                /* In this case, there was a specification for a separation\n                   color order, which indicates what colorants we will\n                   actually creat individual separation files for.  We need\n                   to allocate for the standard colorants.  This is due to the\n                   fact that even when we specify a single spot colorant, we\n                   still create the composite CMYK output file. */\n                for (comp_num = 0; comp_num < num_std_colorants; comp_num++) {\n                    planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                      \""tiffsep_print_page\"");\n                    params.data[comp_num] = planes[comp_num];\n                    if (params.data[comp_num] == NULL) {\n                        code = gs_note_error(gs_error_VMerror);\n                        goto cleanup;\n                    }\n                }\n                offset_plane = num_std_colorants;\n                /* Now we need to make sure that we do not allocate extra\n                   planes if any of the colorants in the order list are\n                   one of the standard colorant names */\n                plane_index = plane_count = num_std_colorants;\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    int temp_pos;\n\n                    temp_pos = tfdev->devn_params.separation_order_map[comp_num];\n                    if (temp_pos >= num_std_colorants) {\n                        /* We have one that is not a standard colorant name\n                           so allocate a new plane */\n                        planes[plane_count] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                        \""tiffsep_print_page\"");\n                        /* Assign the new plane to the appropriate position */\n                        params.data[plane_index] = planes[plane_count];\n                        if (params.data[plane_index] == NULL) {\n                            code = gs_note_error(gs_error_VMerror);\n                            goto cleanup;\n                        }\n                        plane_count += 1;\n                    } else {\n                        /* Assign params.data with the appropriate std.\n                           colorant plane position */\n                        params.data[plane_index] = planes[temp_pos];\n                    }\n                    plane_index += 1;\n                }\n            } else {\n                /* Sep color order number was not specified so just render all\n                   the  planes that we can */\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                    \""tiffsep_print_page\"");\n                    params.data[comp_num] = planes[comp_num];\n                    if (params.data[comp_num] == NULL) {\n                        code = gs_note_error(gs_error_VMerror);\n                        goto cleanup;\n                    }\n                }\n            }\n            code = gx_downscaler_init_planar_trapped(&ds, (gx_device *)pdev, &params,\n                                                     num_comp, factor, mfs, 8, dst_bpc,\n                                                     tfdev->downscale.trap_w, tfdev->downscale.trap_h,\n                                                     tfdev->downscale.trap_order);\n            if (code < 0)\n                goto cleanup;\n            byte_width = (width * dst_bpc + 7)>>3;\n            for (y = 0; y < height; ++y) {\n                code = gx_downscaler_get_bits_rectangle(&ds, &params, y);\n                if (code < 0)\n                    goto cleanup;\n                /* Write separation data (tiffgray format) */\n                if (!tfdev->NoSeparationFiles) {\n                    for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                        byte *src;\n                        byte *dest = sep_line;\n\n                        if (num_order > 0) {\n                            src = params.data[tfdev->devn_params.separation_order_map[comp_num]];\n                        }\n                        else\n                            src = params.data[comp_num];\n                        for (pixel = 0; pixel < byte_width; pixel++, dest++, src++)\n                            *dest = MAX_COLOR_VALUE - *src;    /* Gray is additive */\n                        TIFFWriteScanline(tfdev->tiff[comp_num], (tdata_t)sep_line, y, 0);\n                    }\n                }\n                /* Write CMYK equivalent data */\n                switch(dst_bpc)\n                {\n                default:\n                case 8:\n                    build_cmyk_raster_line_fromplanar(&params, sep_line, width,\n                                                      num_comp, cmyk_map, num_order,\n                                                      tfdev);\n                    break;\n                case 4:\n                    build_cmyk_raster_line_fromplanar_4bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                case 2:\n                    build_cmyk_raster_line_fromplanar_2bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                case 1:\n                    build_cmyk_raster_line_fromplanar_1bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                }\n                TIFFWriteScanline(tfdev->tiff_comp, (tdata_t)sep_line, y, 0);\n            }\ncleanup:\n            if (num_order > 0) {\n                /* Free up the standard colorants if num_order was set.\n                   In this process, we need to make sure that none of them\n                   were the standard colorants.  plane_count should have\n                   the sum of the std. colorants plus any non-standard\n                   ones listed in separation color order */\n                for (comp_num = 0; comp_num < plane_count; comp_num++) {\n                    gs_free_object(pdev->memory, planes[comp_num],\n                                                    \""tiffsep_print_page\"");\n                }\n            } else {\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    gs_free_object(pdev->memory, planes[comp_num + offset_plane],\n                                                    \""tiffsep_print_page\"");\n                }\n            }\n            gx_downscaler_fin(&ds);\n            gs_free_object(pdev->memory, sep_line, \""tiffsep_print_page\"");\n        }\n        code1 = code;\n        if (!tfdev->NoSeparationFiles) {\n            for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                TIFFWriteDirectory(tfdev->tiff[comp_num]);\n                if (fmt) {\n                    int sep_num = tfdev->devn_params.separation_order_map[comp_num];\n\n                    code = create_separation_file_name(tfdev, name, gp_file_name_sizeof, sep_num, false);\n                    if (code < 0) {\n                        code1 = code;\n                        continue;\n                    }\n                    code = tiffsep_close_sep_file(tfdev, name, comp_num);\n                    if (code >= 0)\n                        code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                    if (code < 0) {\n                        code1 = code;\n                    }\n                }\n            }\n        }\n        TIFFWriteDirectory(tfdev->tiff_comp);\n        if (fmt) {\n            code = tiffsep_close_comp_file(tfdev, pdev->fname);\n        }\n        if (code1 < 0) {\n            code = code1;\n        }\n    }\n\ndone:\n    if (name)\n        gs_free_object(pdev->memory, name, \""tiffsep_print_page(name)\"");\n    return code;\n}"", ""target"": 1}]","[{""func_name"": ""tiffsep1_print_page"", ""file_path"": ""devices/gdevtsep.c"", ""func_code"": ""static int\ntiffsep1_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    tiffsep1_device * const tfdev = (tiffsep1_device *)pdev;\n    int num_std_colorants = tfdev->devn_params.num_std_colorant_names;\n    int num_order = tfdev->devn_params.num_separation_order_names;\n    int num_spot = tfdev->devn_params.separations.num_separations;\n    int num_comp, comp_num, code = 0, code1 = 0;\n    short map_comp_to_sep[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    char *name = NULL;\n    int save_depth = pdev->color_info.depth;\n    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int non_encodable_count = 0;\n\n    if (tfdev->thresholds[0].dstart == NULL)\n        return_error(gs_error_rangecheck);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    build_comp_to_sep_map((tiffsep_device *)tfdev, map_comp_to_sep);\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep1.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n       goto done;\n    }\n    /* If the output file is on disk and the name contains a page #, */\n    /* then delete the previous file. */\n    if (pdev->file != NULL && parsed.iodev == iodev_default(pdev->memory) && fmt) {\n        long count1 = pdev->PageCount;\n        char *compname = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(compname)\"");\n        if (!compname) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        gx_device_close_output_file((gx_device *)pdev, pdev->fname, pdev->file);\n        pdev->file = NULL;\n\n        while (*fmt != 'l' && *fmt != '%')\n            --fmt;\n        if (*fmt == 'l')\n            gs_sprintf(compname, parsed.fname, count1);\n        else\n            gs_sprintf(compname, parsed.fname, (int)count1);\n        parsed.iodev->procs.delete_file(parsed.iodev, compname);\n        /* we always need an open printer (it will get deleted in tiffsep1_prn_close */\n        code = gdev_prn_open_printer((gx_device *)pdev, 1);\n\n        gs_free_object(pdev->memory, compname, \""tiffsep_print_page(compname)\"");\n        if (code < 0) {\n            goto done;\n        }\n    }\n\n    /* Set up the separation output files */\n    num_comp = number_output_separations( tfdev->color_info.num_components,\n                                        num_std_colorants, num_order, num_spot);\n    for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n        int sep_num = map_comp_to_sep[comp_num];\n\n        code = create_separation_file_name((tiffsep_device *)tfdev, name,\n                                        gp_file_name_sizeof, sep_num, true);\n        if (code < 0) {\n            goto done;\n        }\n\n        /* Open the separation file, if not already open */\n        if (tfdev->sep_file[comp_num] == NULL) {\n            code = gs_add_outputfile_control_path(tfdev->memory, name);\n            if (code < 0) {\n                goto done;\n            }\n            code = gx_device_open_output_file((gx_device *)pdev, name,\n                    true, true, &(tfdev->sep_file[comp_num]));\n            if (code < 0) {\n                goto done;\n            }\n            tfdev->tiff[comp_num] = tiff_from_filep(pdev, name,\n                                                    tfdev->sep_file[comp_num],\n                                                    tfdev->BigEndian, tfdev->UseBigTIFF);\n            if (!tfdev->tiff[comp_num]) {\n                code = gs_note_error(gs_error_ioerror);\n                goto done;\n            }\n        }\n\n        pdev->color_info.depth = 8;     /* Create files for 8 bit gray */\n        pdev->color_info.num_components = 1;\n        code = tiff_set_fields_for_printer(pdev, tfdev->tiff[comp_num], 1, 0, tfdev->write_datetime);\n        tiff_set_gray_fields(pdev, tfdev->tiff[comp_num], 1, tfdev->Compression, tfdev->MaxStripSize);\n        pdev->color_info.depth = save_depth;\n        pdev->color_info.num_components = save_numcomps;\n        if (code < 0) {\n            goto done;\n        }\n\n    }   /* end initialization of separation files */\n\n\n    {   /* Get the expanded contone line, halftone and write out the dithered separations */\n        byte *planes[GS_CLIENT_COLOR_MAX_COMPONENTS];\n        int width = tfdev->width;\n        int raster_plane = bitmap_raster(width * 8);\n        int dithered_raster = ((7 + width) / 8) + ARCH_SIZEOF_LONG;\n        int pixel, y;\n        gs_get_bits_params_t params;\n        gs_int_rect rect;\n        /* the dithered_line is assumed to be 32-bit aligned by the alloc */\n        uint32_t *dithered_line = (uint32_t *)gs_alloc_bytes(pdev->memory, dithered_raster,\n                                \""tiffsep1_print_page\"");\n\n        memset(planes, 0, sizeof(*planes) * GS_CLIENT_COLOR_MAX_COMPONENTS);\n\n        /* Return planar data */\n        params.options = (GB_RETURN_POINTER | GB_RETURN_COPY |\n             GB_ALIGN_STANDARD | GB_OFFSET_0 | GB_RASTER_STANDARD |\n             GB_PACKING_PLANAR | GB_COLORS_NATIVE | GB_ALPHA_NONE);\n        params.x_offset = 0;\n        params.raster = bitmap_raster(width * pdev->color_info.depth);\n\n        code = 0;\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                            \""tiffsep1_print_page\"");\n            if (planes[comp_num] == NULL) {\n                code = gs_error_VMerror;\n                break;\n            }\n        }\n\n        if (code < 0 || dithered_line == NULL) {\n            code = gs_note_error(gs_error_VMerror);\n            goto cleanup;\n        }\n\n        for (comp_num = 0; comp_num < num_comp; comp_num++ )\n            TIFFCheckpointDirectory(tfdev->tiff[comp_num]);\n\n        rect.p.x = 0;\n        rect.q.x = pdev->width;\n        /* Loop for the lines */\n        for (y = 0; y < pdev->height; ++y) {\n            rect.p.y = y;\n            rect.q.y = y + 1;\n            /* We have to reset the pointers since get_bits_rect will have moved them */\n            for (comp_num = 0; comp_num < num_comp; comp_num++)\n                params.data[comp_num] = planes[comp_num];\n            code = (*dev_proc(pdev, get_bits_rectangle))((gx_device *)pdev, &rect, &params, NULL);\n            if (code < 0)\n                break;\n\n            /* Dither the separation and write it out */\n            for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n\n/***** #define SKIP_HALFTONING_FOR_TIMING *****/ /* uncomment for timing test */\n#ifndef SKIP_HALFTONING_FOR_TIMING\n\n                /*\n                 * Define 32-bit writes by default. Testing shows that while this is more\n                 * complex code, it runs measurably and consistently faster than the more\n                 * obvious 8-bit code. The 8-bit code is kept to help future optimization\n                 * efforts determine what affects tight loop optimization. Subtracting the\n                 * time when halftoning is skipped shows that the 32-bit halftoning is\n                 * 27% faster.\n                 */\n#define USE_32_BIT_WRITES\n                byte *thresh_line_base = tfdev->thresholds[comp_num].dstart +\n                                    ((y % tfdev->thresholds[comp_num].dheight) *\n                                        tfdev->thresholds[comp_num].dwidth) ;\n                byte *thresh_ptr = thresh_line_base;\n                byte *thresh_limit = thresh_ptr + tfdev->thresholds[comp_num].dwidth;\n                byte *src = params.data[comp_num];\n#ifdef USE_32_BIT_WRITES\n                uint32_t *dest = dithered_line;\n                uint32_t val = 0;\n                const uint32_t *mask = &bit_order[0];\n#else   /* example 8-bit code */\n                byte *dest = dithered_line;\n                byte val = 0;\n                byte mask = 0x80;\n#endif /* USE_32_BIT_WRITES */\n\n                for (pixel = 0; pixel < width; pixel++, src++) {\n#ifdef USE_32_BIT_WRITES\n                    if (*src < *thresh_ptr++)\n                        val |= *mask;\n                    if (++mask == &(bit_order[32])) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = &bit_order[0];\n                    }\n#else   /* example 8-bit code */\n                    if (*src < *thresh_ptr++)\n                        val |= mask;\n                    mask >>= 1;\n                    if (mask == 0) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = 0x80;\n                    }\n#endif /* USE_32_BIT_WRITES */\n                    if (thresh_ptr >= thresh_limit)\n                        thresh_ptr = thresh_line_base;\n                } /* end src pixel loop - collect last bits if any */\n                /* the following relies on their being enough 'pad' in dithered_line */\n#ifdef USE_32_BIT_WRITES\n                if (mask != &bit_order[0]) {\n                    *dest = val;\n                }\n#else   /* example 8-bit code */\n                if (mask != 0x80) {\n                    *dest = val;\n                }\n#endif /* USE_32_BIT_WRITES */\n#endif /* SKIP_HALFTONING_FOR_TIMING */\n                TIFFWriteScanline(tfdev->tiff[comp_num], (tdata_t)dithered_line, y, 0);\n            } /* end component loop */\n        }\n        /* Update the strip data */\n        for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n            TIFFWriteDirectory(tfdev->tiff[comp_num]);\n            if (fmt) {\n                int sep_num = map_comp_to_sep[comp_num];\n\n                code = create_separation_file_name((tiffsep_device *)tfdev, name, gp_file_name_sizeof, sep_num, false);\n                if (code < 0) {\n                    code1 = code;\n                    continue;\n                }\n                code = tiffsep_close_sep_file((tiffsep_device *)tfdev, name, comp_num);\n                if (code >= 0)\n                    code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                if (code < 0) {\n                    code1 = code;\n                }\n            }\n        }\n        code = code1;\n\n        /* free any allocations and exit with code */\ncleanup:\n        gs_free_object(pdev->memory, dithered_line, \""tiffsep1_print_page\"");\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            gs_free_object(pdev->memory, planes[comp_num], \""tiffsep1_print_page\"");\n        }\n    }\n    /*\n     * If we have any non encodable pixels then signal an error.\n     */\n    if (non_encodable_count) {\n        dmlprintf1(pdev->memory, \""WARNING:  Non encodable pixels = %d\\n\"", non_encodable_count);\n        code = gs_note_error(gs_error_rangecheck);\n    }\n\ndone:\n    if (name)\n        gs_free_object(pdev->memory, name, \""tiffsep1_print_page(name)\"");\n    return code;\n}""}, {""func_name"": ""tiffsep_print_page"", ""file_path"": ""devices/gdevtsep.c"", ""func_code"": ""static int\ntiffsep_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    tiffsep_device * const tfdev = (tiffsep_device *)pdev;\n    int num_std_colorants = tfdev->devn_params.num_std_colorant_names;\n    int num_order = tfdev->devn_params.num_separation_order_names;\n    int num_spot = tfdev->devn_params.separations.num_separations;\n    int num_comp, comp_num, sep_num, code = 0, code1 = 0;\n    cmyk_composite_map cmyk_map[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    char *name = NULL;\n    bool double_f = false;\n    int base_filename_length = length_base_file_name(tfdev, &double_f);\n    int save_depth = pdev->color_info.depth;\n    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int plane_count = 0;  /* quiet compiler */\n    int factor = tfdev->downscale.downscale_factor;\n    int mfs = tfdev->downscale.min_feature_size;\n    int dst_bpc = tfdev->BitsPerComponent;\n    gx_downscaler_t ds;\n    int width = gx_downscaler_scale(tfdev->width, factor);\n    int height = gx_downscaler_scale(tfdev->height, factor);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    /* Print the names of the spot colors */\n    if (num_order == 0) {\n        for (sep_num = 0; sep_num < num_spot; sep_num++) {\n            copy_separation_name(tfdev, name,\n                gp_file_name_sizeof - base_filename_length - SUFFIX_SIZE, sep_num, 0);\n            dmlprintf1(pdev->memory, \""%%%%SeparationName: %s\\n\"", name);\n        }\n    }\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n       goto done;\n    }\n    /* Write the page directory for the CMYK equivalent file. */\n    if (!tfdev->comp_file) {\n        pdev->color_info.depth = dst_bpc*4;        /* Create directory for 32 bit cmyk */\n        if (!tfdev->UseBigTIFF && tfdev->Compression==COMPRESSION_NONE &&\n            height > ((unsigned long) 0xFFFFFFFF - (file ? gp_ftell(file) : 0))/(width*4)) { /* note width is never 0 in print_page */\n            dmprintf(pdev->memory, \""CMYK composite file would be too large! Reduce resolution or enable compression.\\n\"");\n            return_error(gs_error_rangecheck);  /* this will overflow 32 bits */\n        }\n\n        code = gx_device_open_output_file((gx_device *)pdev, pdev->fname, true, true, &(tfdev->comp_file));\n        if (code < 0) {\n            goto done;\n        }\n\n        tfdev->tiff_comp = tiff_from_filep(pdev, pdev->dname, tfdev->comp_file, tfdev->BigEndian, tfdev->UseBigTIFF);\n        if (!tfdev->tiff_comp) {\n            code = gs_note_error(gs_error_invalidfileaccess);\n            goto done;\n        }\n\n    }\n    code = tiff_set_fields_for_printer(pdev, tfdev->tiff_comp, factor, 0, tfdev->write_datetime);\n\n    if (dst_bpc == 1 || dst_bpc == 8) {\n        tiff_set_cmyk_fields(pdev, tfdev->tiff_comp, dst_bpc, tfdev->Compression, tfdev->MaxStripSize);\n    }\n    else {\n        /* Catch-all just for safety's sake */\n        tiff_set_cmyk_fields(pdev, tfdev->tiff_comp, dst_bpc, COMPRESSION_NONE, tfdev->MaxStripSize);\n    }\n\n    pdev->color_info.depth = save_depth;\n    if (code < 0) {\n        goto done;\n    }\n\n    /* Set up the separation output files */\n    num_comp = number_output_separations( tfdev->color_info.num_components,\n                                        num_std_colorants, num_order, num_spot);\n\n    if (!tfdev->NoSeparationFiles && !num_order && num_comp < num_std_colorants + num_spot) {\n        dmlprintf(pdev->memory, \""Warning: skipping one or more colour separations, see: Devices.htm#TIFF\\n\"");\n    }\n\n    if (!tfdev->NoSeparationFiles) {\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            int sep_num = tfdev->devn_params.separation_order_map[comp_num];\n\n            code = create_separation_file_name(tfdev, name, gp_file_name_sizeof,\n                sep_num, true);\n            if (code < 0) {\n                goto done;\n            }\n\n            /*\n             * Close the old separation file if we are creating individual files\n             * for each page.\n             */\n            if (tfdev->sep_file[comp_num] != NULL && fmt != NULL) {\n                code = tiffsep_close_sep_file(tfdev, name, comp_num);\n                if (code >= 0)\n                    code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                if (code < 0)\n                    return code;\n            }\n            /* Open the separation file, if not already open */\n            if (tfdev->sep_file[comp_num] == NULL) {\n                code = gs_add_outputfile_control_path(tfdev->memory, name);\n                if (code < 0) {\n                    goto done;\n                }\n                code = gx_device_open_output_file((gx_device *)pdev, name,\n                    true, true, &(tfdev->sep_file[comp_num]));\n                if (code < 0) {\n                    goto done;\n                }\n                tfdev->tiff[comp_num] = tiff_from_filep(pdev, name,\n                    tfdev->sep_file[comp_num],\n                    tfdev->BigEndian, tfdev->UseBigTIFF);\n                if (!tfdev->tiff[comp_num]) {\n                    code = gs_note_error(gs_error_ioerror);\n                    goto done;\n                }\n            }\n\n            pdev->color_info.depth = dst_bpc;     /* Create files for 8 bit gray */\n            pdev->color_info.num_components = 1;\n            if (!tfdev->UseBigTIFF && tfdev->Compression == COMPRESSION_NONE &&\n                height * 8 / dst_bpc > ((unsigned long)0xFFFFFFFF - (file ? gp_ftell(file) : 0)) / width) /* note width is never 0 in print_page */\n            {\n                code = gs_note_error(gs_error_rangecheck);  /* this will overflow 32 bits */\n                goto done;\n            }\n\n\n            code = tiff_set_fields_for_printer(pdev, tfdev->tiff[comp_num], factor, 0, tfdev->write_datetime);\n            tiff_set_gray_fields(pdev, tfdev->tiff[comp_num], dst_bpc, tfdev->Compression, tfdev->MaxStripSize);\n            pdev->color_info.depth = save_depth;\n            pdev->color_info.num_components = save_numcomps;\n            if (code < 0) {\n                goto done;\n            }\n        }\n    }\n\n    build_cmyk_map((gx_device*) tfdev, num_comp, &tfdev->equiv_cmyk_colors, cmyk_map);\n    if (tfdev->PrintSpotCMYK) {\n        code = print_cmyk_equivalent_colors(tfdev, num_comp, cmyk_map);\n        if (code < 0) {\n            goto done;\n        }\n    }\n\n    {\n        int raster_plane = bitmap_raster(width * 8);\n        byte *planes[GS_CLIENT_COLOR_MAX_COMPONENTS] = { 0 };\n        int cmyk_raster = width * NUM_CMYK_COMPONENTS;\n        int pixel, y;\n        byte * sep_line;\n        int plane_index;\n        int offset_plane = 0;\n\n        sep_line =\n            gs_alloc_bytes(pdev->memory, cmyk_raster, \""tiffsep_print_page\"");\n        if (!sep_line) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        if (!tfdev->NoSeparationFiles)\n            for (comp_num = 0; comp_num < num_comp; comp_num++ )\n                TIFFCheckpointDirectory(tfdev->tiff[comp_num]);\n        TIFFCheckpointDirectory(tfdev->tiff_comp);\n\n        /* Write the page data. */\n        {\n            gs_get_bits_params_t params;\n            int byte_width;\n\n            /* Return planar data */\n            params.options = (GB_RETURN_POINTER | GB_RETURN_COPY |\n                 GB_ALIGN_STANDARD | GB_OFFSET_0 | GB_RASTER_STANDARD |\n                 GB_PACKING_PLANAR | GB_COLORS_NATIVE | GB_ALPHA_NONE);\n            params.x_offset = 0;\n            params.raster = bitmap_raster(width * pdev->color_info.depth);\n\n            if (num_order > 0) {\n                /* In this case, there was a specification for a separation\n                   color order, which indicates what colorants we will\n                   actually creat individual separation files for.  We need\n                   to allocate for the standard colorants.  This is due to the\n                   fact that even when we specify a single spot colorant, we\n                   still create the composite CMYK output file. */\n                for (comp_num = 0; comp_num < num_std_colorants; comp_num++) {\n                    planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                      \""tiffsep_print_page\"");\n                    params.data[comp_num] = planes[comp_num];\n                    if (params.data[comp_num] == NULL) {\n                        code = gs_note_error(gs_error_VMerror);\n                        goto cleanup;\n                    }\n                }\n                offset_plane = num_std_colorants;\n                /* Now we need to make sure that we do not allocate extra\n                   planes if any of the colorants in the order list are\n                   one of the standard colorant names */\n                plane_index = plane_count = num_std_colorants;\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    int temp_pos;\n\n                    temp_pos = tfdev->devn_params.separation_order_map[comp_num];\n                    if (temp_pos >= num_std_colorants) {\n                        /* We have one that is not a standard colorant name\n                           so allocate a new plane */\n                        planes[plane_count] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                        \""tiffsep_print_page\"");\n                        /* Assign the new plane to the appropriate position */\n                        params.data[plane_index] = planes[plane_count];\n                        if (params.data[plane_index] == NULL) {\n                            code = gs_note_error(gs_error_VMerror);\n                            goto cleanup;\n                        }\n                        plane_count += 1;\n                    } else {\n                        /* Assign params.data with the appropriate std.\n                           colorant plane position */\n                        params.data[plane_index] = planes[temp_pos];\n                    }\n                    plane_index += 1;\n                }\n            } else {\n                /* Sep color order number was not specified so just render all\n                   the  planes that we can */\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                                    \""tiffsep_print_page\"");\n                    params.data[comp_num] = planes[comp_num];\n                    if (params.data[comp_num] == NULL) {\n                        code = gs_note_error(gs_error_VMerror);\n                        goto cleanup;\n                    }\n                }\n            }\n            code = gx_downscaler_init_planar_trapped(&ds, (gx_device *)pdev, &params,\n                                                     num_comp, factor, mfs, 8, dst_bpc,\n                                                     tfdev->downscale.trap_w, tfdev->downscale.trap_h,\n                                                     tfdev->downscale.trap_order);\n            if (code < 0)\n                goto cleanup;\n            byte_width = (width * dst_bpc + 7)>>3;\n            for (y = 0; y < height; ++y) {\n                code = gx_downscaler_get_bits_rectangle(&ds, &params, y);\n                if (code < 0)\n                    goto cleanup;\n                /* Write separation data (tiffgray format) */\n                if (!tfdev->NoSeparationFiles) {\n                    for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                        byte *src;\n                        byte *dest = sep_line;\n\n                        if (num_order > 0) {\n                            src = params.data[tfdev->devn_params.separation_order_map[comp_num]];\n                        }\n                        else\n                            src = params.data[comp_num];\n                        for (pixel = 0; pixel < byte_width; pixel++, dest++, src++)\n                            *dest = MAX_COLOR_VALUE - *src;    /* Gray is additive */\n                        TIFFWriteScanline(tfdev->tiff[comp_num], (tdata_t)sep_line, y, 0);\n                    }\n                }\n                /* Write CMYK equivalent data */\n                switch(dst_bpc)\n                {\n                default:\n                case 8:\n                    build_cmyk_raster_line_fromplanar(&params, sep_line, width,\n                                                      num_comp, cmyk_map, num_order,\n                                                      tfdev);\n                    break;\n                case 4:\n                    build_cmyk_raster_line_fromplanar_4bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                case 2:\n                    build_cmyk_raster_line_fromplanar_2bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                case 1:\n                    build_cmyk_raster_line_fromplanar_1bpc(&params, sep_line, width,\n                                                           num_comp, cmyk_map, num_order,\n                                                           tfdev);\n                    break;\n                }\n                TIFFWriteScanline(tfdev->tiff_comp, (tdata_t)sep_line, y, 0);\n            }\ncleanup:\n            if (num_order > 0) {\n                /* Free up the standard colorants if num_order was set.\n                   In this process, we need to make sure that none of them\n                   were the standard colorants.  plane_count should have\n                   the sum of the std. colorants plus any non-standard\n                   ones listed in separation color order */\n                for (comp_num = 0; comp_num < plane_count; comp_num++) {\n                    gs_free_object(pdev->memory, planes[comp_num],\n                                                    \""tiffsep_print_page\"");\n                }\n            } else {\n                for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                    gs_free_object(pdev->memory, planes[comp_num + offset_plane],\n                                                    \""tiffsep_print_page\"");\n                }\n            }\n            gx_downscaler_fin(&ds);\n            gs_free_object(pdev->memory, sep_line, \""tiffsep_print_page\"");\n        }\n        code1 = code;\n        if (!tfdev->NoSeparationFiles) {\n            for (comp_num = 0; comp_num < num_comp; comp_num++) {\n                TIFFWriteDirectory(tfdev->tiff[comp_num]);\n                if (fmt) {\n                    int sep_num = tfdev->devn_params.separation_order_map[comp_num];\n\n                    code = create_separation_file_name(tfdev, name, gp_file_name_sizeof, sep_num, false);\n                    if (code < 0) {\n                        code1 = code;\n                        continue;\n                    }\n                    code = tiffsep_close_sep_file(tfdev, name, comp_num);\n                    if (code >= 0)\n                        code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                    if (code < 0) {\n                        code1 = code;\n                    }\n                }\n            }\n        }\n        TIFFWriteDirectory(tfdev->tiff_comp);\n        if (fmt) {\n            code = tiffsep_close_comp_file(tfdev, pdev->fname);\n        }\n        if (code1 < 0) {\n            code = code1;\n        }\n    }\n\ndone:\n    if (name)\n        gs_free_object(pdev->memory, name, \""tiffsep_print_page(name)\"");\n    return code;\n}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(file:gdevtsep.c, func:tiffsep1_print_page)"", ""result"": [{""code"": ""static int\ntiffsep1_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    tiffsep1_device * const tfdev = (tiffsep1_device *)pdev;\n    int num_std_colorants = tfdev->devn_params.num_std_colorant_names;\n    int num_order = tfdev->devn_params.num_separation_order_names;\n    int num_spot = tfdev->devn_params.separations.num_separations;\n    int num_comp, comp_num, code = 0, code1 = 0;\n    short map_comp_to_sep[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    char *name = NULL;\n    int save_depth = pdev->color_info.depth;\n    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int non_encodable_count = 0;\n\n    if (tfdev->thresholds[0].dstart == NULL)\n        return_error(gs_error_rangecheck);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    build_comp_to_sep_map((tiffsep_device *)tfdev, map_comp_to_sep);\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep1.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n    }\n    /* If the output file is on disk and the name contains a page #, */\n    /* then delete the previous file. */\n    if (pdev->file != NULL && parsed.iodev == iodev_default(pdev->memory) && fmt) {\n        long count1 = pdev->PageCount;\n        char *compname = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(compname)\"");\n        if (!compname) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        gx_device_close_output_file((gx_device *)pdev, pdev->fname, pdev->file);\n        pdev->file = NULL;\n\n        while (*fmt != 'l' && *fmt != '%')\n            --fmt;\n        if (*fmt == 'l')\n            gs_sprintf(compname, parsed.fname, count1);\n        else\n            gs_sprintf(compname, parsed.fname, (int)count1);\n        parsed.iodev->procs.delete_file(parsed.iodev, compname);\n        /* we always need an open printer (it will get deleted in tiffsep1_prn_close */\n        code = gdev_prn_open_printer((gx_device *)pdev, 1);\n\n        gs_free_object(pdev->memory, compname, \""tiffsep_print_page(compname)\"");\n        if (code < 0) {\n            goto done;\n        }\n    }\n\n    /* Set up the separation output files */\n    num_comp = number_output_separations( tfdev->color_info.num_components,\n                                        num_std_colorants, num_order, num_spot);\n    for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n        int sep_num = map_comp_to_sep[comp_num];\n\n        code = create_separation_file_name((tiffsep_device *)tfdev, name,\n                                        gp_file_name_sizeof, sep_num, true);\n        if (code < 0) {\n            goto done;\n        }\n\n        /* Open the separation file, if not already open */\n        if (tfdev->sep_file[comp_num] == NULL) {\n            code = gs_add_outputfile_control_path(tfdev->memory, name);\n            if (code < 0) {\n                goto done;\n            }\n            code = gx_device_open_output_file((gx_device *)pdev, name,\n                    true, true, &(tfdev->sep_file[comp_num]));\n            if (code < 0) {\n                goto done;\n            }\n            tfdev->tiff[comp_num] = tiff_from_filep(pdev, name,\n                                                    tfdev->sep_file[comp_num],\n                                                    tfdev->BigEndian, tfdev->UseBigTIFF);\n            if (!tfdev->tiff[comp_num]) {\n                code = gs_note_error(gs_error_ioerror);\n                goto done;\n            }\n        }\n\n        pdev->color_info.depth = 8;     /* Create files for 8 bit gray */\n        pdev->color_info.num_components = 1;\n        code = tiff_set_fields_for_printer(pdev, tfdev->tiff[comp_num], 1, 0, tfdev->write_datetime);\n        tiff_set_gray_fields(pdev, tfdev->tiff[comp_num], 1, tfdev->Compression, tfdev->MaxStripSize);\n        pdev->color_info.depth = save_depth;\n        pdev->color_info.num_components = save_numcomps;\n        if (code < 0) {\n            goto done;\n        }\n\n    }   /* end initialization of separation files */\n\n\n    {   /* Get the expanded contone line, halftone and write out the dithered separations */\n        byte *planes[GS_CLIENT_COLOR_MAX_COMPONENTS];\n        int width = tfdev->width;\n        int raster_plane = bitmap_raster(width * 8);\n        int dithered_raster = ((7 + width) / 8) + ARCH_SIZEOF_LONG;\n        int pixel, y;\n        gs_get_bits_params_t params;\n        gs_int_rect rect;\n        /* the dithered_line is assumed to be 32-bit aligned by the alloc */\n        uint32_t *dithered_line = (uint32_t *)gs_alloc_bytes(pdev->memory, dithered_raster,\n                                \""tiffsep1_print_page\"");\n\n        memset(planes, 0, sizeof(*planes) * GS_CLIENT_COLOR_MAX_COMPONENTS);\n\n        /* Return planar data */\n        params.options = (GB_RETURN_POINTER | GB_RETURN_COPY |\n             GB_ALIGN_STANDARD | GB_OFFSET_0 | GB_RASTER_STANDARD |\n             GB_PACKING_PLANAR | GB_COLORS_NATIVE | GB_ALPHA_NONE);\n        params.x_offset = 0;\n        params.raster = bitmap_raster(width * pdev->color_info.depth);\n\n        code = 0;\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            planes[comp_num] = gs_alloc_bytes(pdev->memory, raster_plane,\n                                            \""tiffsep1_print_page\"");\n            if (planes[comp_num] == NULL) {\n                code = gs_error_VMerror;\n                break;\n            }\n        }\n\n        if (code < 0 || dithered_line == NULL) {\n            code = gs_note_error(gs_error_VMerror);\n            goto cleanup;\n        }\n\n        for (comp_num = 0; comp_num < num_comp; comp_num++ )\n            TIFFCheckpointDirectory(tfdev->tiff[comp_num]);\n\n        rect.p.x = 0;\n        rect.q.x = pdev->width;\n        /* Loop for the lines */\n        for (y = 0; y < pdev->height; ++y) {\n            rect.p.y = y;\n            rect.q.y = y + 1;\n            /* We have to reset the pointers since get_bits_rect will have moved them */\n            for (comp_num = 0; comp_num < num_comp; comp_num++)\n                params.data[comp_num] = planes[comp_num];\n            code = (*dev_proc(pdev, get_bits_rectangle))((gx_device *)pdev, &rect, &params, NULL);\n            if (code < 0)\n                break;\n\n            /* Dither the separation and write it out */\n            for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n\n/***** #define SKIP_HALFTONING_FOR_TIMING *****/ /* uncomment for timing test */\n#ifndef SKIP_HALFTONING_FOR_TIMING\n\n                /*\n                 * Define 32-bit writes by default. Testing shows that while this is more\n                 * complex code, it runs measurably and consistently faster than the more\n                 * obvious 8-bit code. The 8-bit code is kept to help future optimization\n                 * efforts determine what affects tight loop optimization. Subtracting the\n                 * time when halftoning is skipped shows that the 32-bit halftoning is\n                 * 27% faster.\n                 */\n#define USE_32_BIT_WRITES\n                byte *thresh_line_base = tfdev->thresholds[comp_num].dstart +\n                                    ((y % tfdev->thresholds[comp_num].dheight) *\n                                        tfdev->thresholds[comp_num].dwidth) ;\n                byte *thresh_ptr = thresh_line_base;\n                byte *thresh_limit = thresh_ptr + tfdev->thresholds[comp_num].dwidth;\n                byte *src = params.data[comp_num];\n#ifdef USE_32_BIT_WRITES\n                uint32_t *dest = dithered_line;\n                uint32_t val = 0;\n                const uint32_t *mask = &bit_order[0];\n#else   /* example 8-bit code */\n                byte *dest = dithered_line;\n                byte val = 0;\n                byte mask = 0x80;\n#endif /* USE_32_BIT_WRITES */\n\n                for (pixel = 0; pixel < width; pixel++, src++) {\n#ifdef USE_32_BIT_WRITES\n                    if (*src < *thresh_ptr++)\n                        val |= *mask;\n                    if (++mask == &(bit_order[32])) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = &bit_order[0];\n                    }\n#else   /* example 8-bit code */\n                    if (*src < *thresh_ptr++)\n                        val |= mask;\n                    mask >>= 1;\n                    if (mask == 0) {\n                        *dest++ = val;\n                        val = 0;\n                        mask = 0x80;\n                    }\n#endif /* USE_32_BIT_WRITES */\n                    if (thresh_ptr >= thresh_limit)\n                        thresh_ptr = thresh_line_base;\n                } /* end src pixel loop - collect last bits if any */\n                /* the following relies on their being enough 'pad' in dithered_line */\n#ifdef USE_32_BIT_WRITES\n                if (mask != &bit_order[0]) {\n                    *dest = val;\n                }\n#else   /* example 8-bit code */\n                if (mask != 0x80) {\n                    *dest = val;\n                }\n#endif /* USE_32_BIT_WRITES */\n#endif /* SKIP_HALFTONING_FOR_TIMING */\n                TIFFWriteScanline(tfdev->tiff[comp_num], (tdata_t)dithered_line, y, 0);\n            } /* end component loop */\n        }\n        /* Update the strip data */\n        for (comp_num = 0; comp_num < num_comp; comp_num++ ) {\n            TIFFWriteDirectory(tfdev->tiff[comp_num]);\n            if (fmt) {\n                int sep_num = map_comp_to_sep[comp_num];\n\n                code = create_separation_file_name((tiffsep_device *)tfdev, name, gp_file_name_sizeof, sep_num, false);\n                if (code < 0) {\n                    code1 = code;\n                    continue;\n                }\n                code = tiffsep_close_sep_file((tiffsep_device *)tfdev, name, comp_num);\n                if (code >= 0)\n                    code = gs_remove_outputfile_control_path(tfdev->memory, name);\n                if (code < 0) {\n                    code1 = code;\n                }\n            }\n        }\n        code = code1;\n\n        /* free any allocations and exit with code */\ncleanup:\n        gs_free_object(pdev->memory, dithered_line, \""tiffsep1_print_page\"");\n        for (comp_num = 0; comp_num < num_comp; comp_num++) {\n            gs_free_object(pdev->memory, planes[comp_num], \""tiffsep1_print_page\"");\n        }\n    }\n    /*\n     * If we have any non encodable pixels then signal an error.\n     */\n    if (non_encodable_count) {\n        dmlprintf1(pdev->memory, \""WARNING:  Non encodable pixels = %d\\n\"", non_encodable_count);\n        code = gs_note_error(gs_error_rangecheck);\n    }\n\ndone:\n    if (name)\n        gs_free_object(pdev->memory, name, \""tiffsep1_print_page(name)\"");\n    return code;\n}\n"", ""start_line"": 2689, ""end_line"": 2963, ""full_name"": ""tiffsep1_print_page"", ""file_path"": ""devices/gdevtsep.c""}]}, {""source"": ""code_info(file:gdevtsep.c, lines:2700-2750)"", ""result"": ""    int save_numcomps = pdev->color_info.num_components;\n    const char *fmt;\n    gs_parsed_file_name_t parsed;\n    int non_encodable_count = 0;\n\n    if (tfdev->thresholds[0].dstart == NULL)\n        return_error(gs_error_rangecheck);\n\n    name = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(name)\"");\n    if (!name)\n        return_error(gs_error_VMerror);\n\n    build_comp_to_sep_map((tiffsep_device *)tfdev, map_comp_to_sep);\n\n    /*\n     * Since different pages may have different spot colors, if this is for a\n     * page after Page 1, we require that each output file is unique with a \""fmt\""\n     * (i.e. %d) as part of the filename. We create individual separation files\n     * for each page of the input.\n     * Since the TIFF lib requires seeakable files, /dev/null or nul: are\n     * not allowed (as they are with the psdcmyk devices).\n    */\n    code = gx_parse_output_file_name(&parsed, &fmt, tfdev->fname,\n                                     strlen(tfdev->fname), pdev->memory);\n    if (code < 0 || (fmt == NULL && tfdev->PageCount > 0)) {\n       emprintf(tfdev->memory,\n                \""\\nUse of the %%d format is required to output more than one page to tiffsep1.\\n\""\n                \""See doc/Devices.htm#TIFF for details.\\n\\n\"");\n       code = gs_note_error(gs_error_ioerror);\n    }\n    /* If the output file is on disk and the name contains a page #, */\n    /* then delete the previous file. */\n    if (pdev->file != NULL && parsed.iodev == iodev_default(pdev->memory) && fmt) {\n        long count1 = pdev->PageCount;\n        char *compname = (char *)gs_alloc_bytes(pdev->memory, gp_file_name_sizeof, \""tiffsep1_print_page(compname)\"");\n        if (!compname) {\n            code = gs_note_error(gs_error_VMerror);\n            goto done;\n        }\n\n        gx_device_close_output_file((gx_device *)pdev, pdev->fname, pdev->file);\n        pdev->file = NULL;\n\n        while (*fmt != 'l' && *fmt != '%')\n            --fmt;\n        if (*fmt == 'l')\n            gs_sprintf(compname, parsed.fname, count1);\n        else\n            gs_sprintf(compname, parsed.fname, (int)count1);\n        parsed.iodev->procs.delete_file(parsed.iodev, compname);\n        /* we always need an open printer (it will get deleted in tiffsep1_prn_close */\n        code = gdev_prn_open_printer((gx_device *)pdev, 1);\n""}]","The original code in `tiffsep1_print_page` (devices/gdevtsep.c:2727) set an error code (`gs_error_ioerror`) when multi-page output lacked a `%d` format specifier but continued execution. This led to uninitialized or invalid TIFF structures being accessed (e.g., `tfdev->tiff[comp_num]`) during subsequent operations like `TIFFWriteScanline`, causing a null pointer dereference. The patch adds `goto done;` to jump to the cleanup/return section (`devices/gdevtsep.c:2950`), ensuring termination before unsafe operations.",0.95,./github/other_context/CVE-2020-16306
36,CVE-2020-36434,CWE-415,c_cpp,An issue was discovered in the sys-info crate before 0.8.0 for Rust. sys_info::disk_info calls can trigger a double free.,https://github.com/FillZpp/sys-info-rs/commit/4fda8b6a5ffbea03d05fcfc0a89594e6ca495fc7,Make Disk Info Thread-Safe on Linux,4,"[{""func_name"": ""get_disk_info"", ""file_path"": ""c/linux.c"", ""func_code"": ""DiskInfo get_disk_info(void) {\n\tFILE *mounts;\n\tchar procline[1024];\n\tchar *mount, *device, *type, *mode, *other;\n\tfloat thispct, max=0.0;\n\tdouble dtotal=0.0, dfree=0.0;\n\tDiskInfo di;\n\t\n\tdi.total = 0;\n\tdi.free = 0;\n\n\tmounts = fopen(MOUNTS,\""r\"");\n\tif (!mounts) {\n\t\treturn di;\n\t}\n\twhile ( fgets(procline, sizeof(procline), mounts) ) {\n\t\tdevice = procline;\n\t\tmount = index(procline, ' ');\n\t\tif (mount == NULL) continue;\n\t\t*mount++ = '\\0';\n\t\ttype = index(mount, ' ');\n\t\tif (type == NULL) continue;\n\t\t*type++ = '\\0';\n\t\tmode = index(type, ' ');\n\t\tif (mode == NULL) continue;\n\t\t*mode++ = '\\0';\n\t\tother = index(mode, ' ');\n\t\tif (other != NULL) *other = '\\0';\n\t\tif (!strncmp(mode, \""ro\"", 2)) continue;\n\t\tif (remote_mount(device, type)) continue;\n\t\tif (strncmp(device, \""/dev/\"", 5) != 0 &&\n\t\t    strncmp(device, \""/dev2/\"", 6) != 0) continue;\n\t\tthispct = device_space(mount, device, &dtotal, &dfree);\n\t\tif (!max || max<thispct)\n\t\t\tmax = thispct;\n\t}\n\tfclose(mounts);\n\n\tDFcleanup();\n\tdi.total = dtotal / 1000;\n\tdi.free = dfree / 1000;\n\t\n\treturn di;\n}"", ""target"": 0}, {""func_name"": ""device_space"", ""file_path"": ""c/linux.c"", ""func_code"": ""float device_space(char *mount, char *device, double *total_size, double *total_free)\n{\n\tstruct statvfs svfs;\n\tdouble blocksize;\n\tdouble free;\n\tdouble size;\n\t/* The percent used: used/total * 100 */\n\tfloat pct=0.0;\n\n\t/* Avoid multiply-mounted disks - not done in df. */\n\tif (seen_before(device)) return pct;\n\n\tif (statvfs(mount, &svfs)) {\n\t\t/* Ignore funky devices... */\n\t\treturn pct;\n\t}\n\n\tfree = svfs.f_bavail;\n\tsize  = svfs.f_blocks;\n\tblocksize = svfs.f_bsize;\n\t/* Keep running sum of total used, free local disk space. */\n\t*total_size += size * blocksize;\n\t*total_free += free * blocksize;\n\t/* The percentage of space used on this partition. */\n\tpct = size ? ((size - free) / (float) size) * 100 : 0.0;\n\treturn pct;\n}"", ""target"": 1}, {""func_name"": ""seen_before"", ""file_path"": ""c/linux.c"", ""func_code"": ""struct nlist * seen_before(const char *name)\n{\n\tstruct nlist *found=0, *np;\n\tunsigned int hashval;\n\n\t/* lookup */\n\thashval=DFhash(name);\n\tfor (np=DFhashvector[hashval]; np; np=np->next) {\n\t\tif (!strcmp(name,np->name)) {\n\t\t\tfound=np;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {    /* not found */\n\t\tnp = (struct nlist *) malloc(sizeof(*np));\n\t\tif (!np || !(np->name = (char *) strdup(name)))\n\t\t\treturn NULL;\n\t\tnp->next = DFhashvector[hashval];\n\t\tDFhashvector[hashval] = np;\n\t\treturn NULL;\n\t}\n\telse /* found name */\n\t\treturn found;\n}"", ""target"": 1}, {""func_name"": ""DFcleanup"", ""file_path"": ""c/linux.c"", ""func_code"": ""void DFcleanup()\n{\n\tstruct nlist *np, *next;\n\tint i;\n\tfor (i=0; i<DFHASHSIZE; i++) {\n\t\t/* Non-standard for loop. Note the last clause happens at the end of the loop. */\n\t\tfor (np = DFhashvector[i]; np; np=next) {\n\t\t\tnext=np->next;\n\t\t\tfree(np->name);\n\t\t\tfree(np);\n\t\t}\n\t\tDFhashvector[i] = 0;\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""get_disk_info"", ""file_path"": ""c/linux.c"", ""func_code"": ""DiskInfo get_disk_info(void) {\n\tFILE *mounts;\n\tchar procline[1024];\n\tstruct nlist *DFhashvector[DFHASHSIZE] = {0};\n\tchar *mount, *device, *type, *mode, *other;\n\tfloat thispct, max=0.0;\n\tdouble dtotal=0.0, dfree=0.0;\n\tDiskInfo di;\n\t\n\tdi.total = 0;\n\tdi.free = 0;\n\n\tmounts = fopen(MOUNTS,\""r\"");\n\tif (!mounts) {\n\t\treturn di;\n\t}\n\twhile ( fgets(procline, sizeof(procline), mounts) ) {\n\t\tdevice = procline;\n\t\tmount = index(procline, ' ');\n\t\tif (mount == NULL) continue;\n\t\t*mount++ = '\\0';\n\t\ttype = index(mount, ' ');\n\t\tif (type == NULL) continue;\n\t\t*type++ = '\\0';\n\t\tmode = index(type, ' ');\n\t\tif (mode == NULL) continue;\n\t\t*mode++ = '\\0';\n\t\tother = index(mode, ' ');\n\t\tif (other != NULL) *other = '\\0';\n\t\tif (!strncmp(mode, \""ro\"", 2)) continue;\n\t\tif (remote_mount(device, type)) continue;\n\t\tif (strncmp(device, \""/dev/\"", 5) != 0 &&\n\t\t    strncmp(device, \""/dev2/\"", 6) != 0) continue;\n\t\tthispct = device_space(DFhashvector, mount, device, &dtotal, &dfree);\n\t\tif (!max || max<thispct)\n\t\t\tmax = thispct;\n\t}\n\tfclose(mounts);\n\n\tDFcleanup(DFhashvector);\n\tdi.total = dtotal / 1000;\n\tdi.free = dfree / 1000;\n\t\n\treturn di;\n}""}, {""func_name"": ""device_space"", ""file_path"": ""c/linux.c"", ""func_code"": ""float device_space(struct nlist **DFhashvector, char *mount, char *device, double *total_size, double *total_free)\n{\n\tstruct statvfs svfs;\n\tdouble blocksize;\n\tdouble free;\n\tdouble size;\n\t/* The percent used: used/total * 100 */\n\tfloat pct=0.0;\n\n\t/* Avoid multiply-mounted disks - not done in df. */\n\tif (seen_before(DFhashvector, device)) return pct;\n\n\tif (statvfs(mount, &svfs)) {\n\t\t/* Ignore funky devices... */\n\t\treturn pct;\n\t}\n\n\tfree = svfs.f_bavail;\n\tsize  = svfs.f_blocks;\n\tblocksize = svfs.f_bsize;\n\t/* Keep running sum of total used, free local disk space. */\n\t*total_size += size * blocksize;\n\t*total_free += free * blocksize;\n\t/* The percentage of space used on this partition. */\n\tpct = size ? ((size - free) / (float) size) * 100 : 0.0;\n\treturn pct;\n}""}, {""func_name"": ""seen_before"", ""file_path"": ""c/linux.c"", ""func_code"": ""struct nlist * seen_before(struct nlist **DFhashvector, const char *name)\n{\n\tstruct nlist *found=0, *np;\n\tunsigned int hashval;\n\n\t/* lookup */\n\thashval=DFhash(name);\n\tfor (np=DFhashvector[hashval]; np; np=np->next) {\n\t\tif (!strcmp(name,np->name)) {\n\t\t\tfound=np;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {    /* not found */\n\t\tnp = (struct nlist *) malloc(sizeof(*np));\n\t\tif (!np || !(np->name = (char *) strdup(name)))\n\t\t\treturn NULL;\n\t\tnp->next = DFhashvector[hashval];\n\t\tDFhashvector[hashval] = np;\n\t\treturn NULL;\n\t}\n\telse /* found name */\n\t\treturn found;\n}""}, {""func_name"": ""DFcleanup"", ""file_path"": ""c/linux.c"", ""func_code"": ""void DFcleanup(struct nlist **DFhashvector)\n{\n\tstruct nlist *np, *next;\n\tint i;\n\tfor (i=0; i<DFHASHSIZE; i++) {\n\t\t/* Non-standard for loop. Note the last clause happens at the end of the loop. */\n\t\tfor (np = DFhashvector[i]; np; np=next) {\n\t\t\tnext=np->next;\n\t\t\tfree(np->name);\n\t\t\tfree(np);\n\t\t}\n\t\tDFhashvector[i] = 0;\n\t}\n}""}]","{""function"": 3, ""code"": 2, ""value"": 1}","[{""source"": ""func_info(file:linux.c, func:DFcleanup)"", ""result"": [{""code"": ""void DFcleanup()\n{\n\tstruct nlist *np, *next;\n\tint i;\n\tfor (i=0; i<DFHASHSIZE; i++) {\n\t\t/* Non-standard for loop. Note the last clause happens at the end of the loop. */\n\t\tfor (np = DFhashvector[i]; np; np=next) {\n\t\t\tnext=np->next;\n\t\t\tfree(np->name);\n\t\t\tfree(np);\n\t\t}\n\t\tDFhashvector[i] = 0;\n\t}\n}"", ""start_line"": 159, ""end_line"": 172, ""full_name"": ""DFcleanup"", ""file_path"": ""c/linux.c""}]}, {""source"": ""func_info(file:linux.c, func:device_space)"", ""result"": [{""code"": ""float device_space(char *mount, char *device, double *total_size, double *total_free)\n{\n\tstruct statvfs svfs;\n\tdouble blocksize;\n\tdouble free;\n\tdouble size;\n\t/* The percent used: used/total * 100 */\n\tfloat pct=0.0;\n\n\t/* Avoid multiply-mounted disks - not done in df. */\n\tif (seen_before(device)) return pct;\n\n\tif (statvfs(mount, &svfs)) {\n\t\t/* Ignore funky devices... */\n\t\treturn pct;\n\t}\n\n\tfree = svfs.f_bavail;\n\tsize  = svfs.f_blocks;\n\tblocksize = svfs.f_bsize;\n\t/* Keep running sum of total used, free local disk space. */\n\t*total_size += size * blocksize;\n\t*total_free += free * blocksize;\n\t/* The percentage of space used on this partition. */\n\tpct = size ? ((size - free) / (float) size) * 100 : 0.0;\n\treturn pct;\n}\n"", ""start_line"": 185, ""end_line"": 211, ""full_name"": ""device_space"", ""file_path"": ""c/linux.c""}]}, {""source"": ""code_info(file:linux.c, lines:160-170)"", ""result"": ""{\n\tstruct nlist *np, *next;\n\tint i;\n\tfor (i=0; i<DFHASHSIZE; i++) {\n\t\t/* Non-standard for loop. Note the last clause happens at the end of the loop. */\n\t\tfor (np = DFhashvector[i]; np; np=next) {\n\t\t\tnext=np->next;\n\t\t\tfree(np->name);\n\t\t\tfree(np);\n\t\t}\n\t\tDFhashvector[i] = 0;\n\t}\n""}, {""source"": ""func_info(file:linux.c, func:seen_before)"", ""result"": [{""code"": ""struct nlist * seen_before(const char *name)\n{\n\tstruct nlist *found=0, *np;\n\tunsigned int hashval;\n\n\t/* lookup */\n\thashval=DFhash(name);\n\tfor (np=DFhashvector[hashval]; np; np=np->next) {\n\t\tif (!strcmp(name,np->name)) {\n\t\t\tfound=np;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {    /* not found */\n\t\tnp = (struct nlist *) malloc(sizeof(*np));\n\t\tif (!np || !(np->name = (char *) strdup(name)))\n\t\t\treturn NULL;\n\t\tnp->next = DFhashvector[hashval];\n\t\tDFhashvector[hashval] = np;\n\t\treturn NULL;\n\t}\n\telse /* found name */\n\t\treturn found;\n}"", ""start_line"": 134, ""end_line"": 157, ""full_name"": ""seen_before"", ""file_path"": ""c/linux.c""}]}, {""source"": ""code_info(file:linux.c, lines:140-180)"", ""result"": ""\thashval=DFhash(name);\n\tfor (np=DFhashvector[hashval]; np; np=np->next) {\n\t\tif (!strcmp(name,np->name)) {\n\t\t\tfound=np;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {    /* not found */\n\t\tnp = (struct nlist *) malloc(sizeof(*np));\n\t\tif (!np || !(np->name = (char *) strdup(name)))\n\t\t\treturn NULL;\n\t\tnp->next = DFhashvector[hashval];\n\t\tDFhashvector[hashval] = np;\n\t\treturn NULL;\n\t}\n\telse /* found name */\n\t\treturn found;\n}\n\nvoid DFcleanup()\n{\n\tstruct nlist *np, *next;\n\tint i;\n\tfor (i=0; i<DFHASHSIZE; i++) {\n\t\t/* Non-standard for loop. Note the last clause happens at the end of the loop. */\n\t\tfor (np = DFhashvector[i]; np; np=next) {\n\t\t\tnext=np->next;\n\t\t\tfree(np->name);\n\t\t\tfree(np);\n\t\t}\n\t\tDFhashvector[i] = 0;\n\t}\n}\n\nint remote_mount(const char *device, const char *type)\n{\n\t/* From ME_REMOTE macro in mountlist.h:\n\t      A file system is `remote' if its Fs_name contains a `:'\n\t      or if (it is of type smbfs and its Fs_name starts with `//'). */\n\treturn ((strchr(device,':') != 0)\n\t\t|| (!strcmp(type, \""smbfs\"") && device[0]=='/' && device[1]=='/')\n\t\t|| (!strncmp(type, \""nfs\"", 3)) || (!strcmp(type, \""autofs\""))\n""}, {""source"": ""value_info(file:linux.c, value:DFhashvector)"", ""result"": {""value_trace"": [{""full_code"": ""DFhashvector[hashval] = np"", ""line"": 152, ""func_name"": ""seen_before""}, {""full_code"": ""DFhashvector[i] = 0"", ""line"": 170, ""func_name"": ""DFcleanup""}], ""struct_var"": ""DFhashvector"", ""struct_type"": ""nlist*[101]"", ""struct_definition"": null}}]","Original `DFhashvector` (c/linux.c) was a global/static structure used by `seen_before` (c/linux.c:134-157) to allocate `struct nlist` entries for device tracking. Concurrent calls to `get_disk_info` (c/linux.c:80) from multiple threads caused overlapping modifications to `DFhashvector`. `DFcleanup` (c/linux.c:159-172) freed entries in this global vector, leading to double-free if called by multiple threads. The patch replaces the global `DFhashvector` with a local instance in `get_disk_info`, passed explicitly to `DFcleanup`, ensuring thread-local resource management.",0.95,./github/other_context/CVE-2020-36434
37,CVE-2021-32437,CWE-476,c_cpp,The gf_hinter_finalize function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.,https://github.com/gpac/gpac/commit/1653f31cf874eb6df964bea88d58d8e9b98b485e,fixed #1770 (fuzz),1,"[{""func_name"": ""gf_hinter_finalize"", ""file_path"": ""src/media_tools/isom_hinter.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \""b=AS:%d\"", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \""a=x-copyright: %s\"", \""MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\"");\n    } else {\n        sprintf(buf64, \""a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\"", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \""data:application/mpeg4-od-au;base64,%s\"", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\""[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\""));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \""data:application/mpeg4-bifs-au;base64,%s\"", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\""[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\""));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \""a=isma-compliance:1,1.0,1\"");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \""a=mpeg4-iod:\\\""data:application/mpeg4-iod;base64,%s\\\""\"", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}"", ""target"": 0}]","[{""func_name"": ""gf_hinter_finalize"", ""file_path"": ""src/media_tools/isom_hinter.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \""b=AS:%d\"", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \""a=x-copyright: %s\"", \""MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\"");\n    } else {\n        sprintf(buf64, \""a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\"", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \""data:application/mpeg4-od-au;base64,%s\"", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\""[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\""));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \""data:application/mpeg4-bifs-au;base64,%s\"", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\""[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\""));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \""a=isma-compliance:1,1.0,1\"");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \""a=mpeg4-iod:\\\""data:application/mpeg4-iod;base64,%s\\\""\"", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}""}]","{""function"": 2, ""value"": 1, ""code"": 1}","[{""source"": ""func_info(func:gf_isom_get_sample)"", ""result"": [{""code"": ""GF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}"", ""start_line"": 1880, ""end_line"": 1883, ""full_name"": ""gf_isom_get_sample"", ""file_path"": ""src/isomedia/isom_read.c""}]}, {""source"": ""value_info(file:isom_hinter.c, value:samp)"", ""result"": {""value_trace"": [{""full_code"": ""samp = gf_isom_get_sample_info(file, Track, i+1, NULL, NULL)"", ""line"": 54, ""func_name"": ""gf_media_get_sample_average_infos""}, {""full_code"": ""*samp = NULL"", ""line"": 337, ""func_name"": ""gf_hinter_track_new""}, {""full_code"": ""samp = gf_isom_get_sample(file, TrackNum, 1, NULL)"", ""line"": 339, ""func_name"": ""gf_hinter_track_new""}, {""full_code"": ""*samp = gf_isom_get_sample(file, TrackNum, 1, NULL)"", ""line"": 515, ""func_name"": ""gf_hinter_track_new""}, {""full_code"": ""samp = gf_isom_get_sample(tkHint->file, tkHint->TrackNum, i+1, &descIndex)"", ""line"": 724, ""func_name"": ""gf_hinter_track_process""}], ""struct_var"": ""samp"", ""struct_type"": ""GF_ISOSample*"", ""struct_definition"": ""typedef struct\n{\n\t/*! data size*/\n\tu32 dataLength;\n\t/*! data with padding if requested*/\n\tu8 *data;\n\t/*! decoding time*/\n\tu64 DTS;\n\t/*! relative offset for composition if needed*/\n\ts32 CTS_Offset;\n\t/*! SAP type*/\n\tGF_ISOSAPType IsRAP;\n\t/*! allocated data size - used only when using static sample in \\ref gf_isom_get_sample_ex*/\n\tu32 alloc_size;\n\t\n\t/*! number of packed samples in this sample. If 0 or 1, only 1 sample is present\n\tonly used for constant size and constant duration samples*/\n\tu32 nb_pack;\n}""}}, {""source"": ""code_info(file:isom_read.c, lines:145-155)"", ""result"": ""\tcase GF_QT_BOX_TYPE_WIDE:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file_range(const char *fileName, u64 start_range, u64 end_range)\n{\n\tu32 type = 0;\n\n""}, {""source"": ""func_info(file:isom_read.c, func:gf_isom_get_sample_ex)"", ""result"": [{""code"": ""GF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n"", ""start_line"": 1837, ""end_line"": 1877, ""full_name"": ""gf_isom_get_sample_ex"", ""file_path"": ""src/isomedia/isom_read.c""}]}]","src/media_tools/isom_hinter.c:1235: 'samp = gf_isom_get_sample(...)' does not validate 'samp' before dereferencing 'samp->data'.\nsrc/isomedia/isom_read.c:1837-1877: 'gf_isom_get_sample_ex' returns NULL if 'trak' is invalid, 'sampleNumber' is 0, or 'Media_GetSample' fails. This allows invalid/crafted inputs to propagate a NULL 'samp' to 'gf_hinter_finalize'.",0.95,./github/other_context/CVE-2021-32437
38,CVE-2021-36222,CWE-476,c_cpp,ec_verify in kdc/kdc_preauth_ec.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.4 and 1.19.x before 1.19.2 allows remote attackers to cause a NULL pointer dereference and daemon crash. This occurs because a return value is not properly managed in a certain situation.,https://github.com/krb5/krb5/commit/fc98f520caefff2e5ee9a0026fdf5109944b3562,"Fix KDC null deref on bad encrypted challenge\n\nThe function ec_verify() in src/kdc/kdc_preauth_ec.c contains a check\nto avoid further processing if the armor key is NULL.  However, this\ncheck is bypassed by a call to k5memdup0() which overwrites retval\nwith 0 if the allocation succeeds.  If the armor key is NULL, a call\nto krb5_c_fx_cf2_simple() will then dereference it, resulting in a\ncrash.  Add a check before the k5memdup0() call to avoid overwriting\nretval.\n\nCVE-2021-36222:\n\nIn MIT krb5 releases 1.16 and later, an unauthenticated attacker can\ncause a null dereference in the KDC by sending a request containing a\nPA-ENCRYPTED-CHALLENGE padata element without using FAST.\n\n[ghudson@mit.edu: trimmed patch; added test case; edited commit\nmessage]\n\nticket: 9007 (new)\ntags: pullup\ntarget_version: 1.19-next\ntarget_version: 1.18-next",1,"[{""func_name"": ""ec_verify"", ""file_path"": ""src/kdc/kdc_preauth_ec.c"", ""func_code"": ""static void\nec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\""Encrypted Challenge used outside of FAST tunnel\""));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \""clientchallengearmor\"",\n                                          &client_keys[i], \""challengelongterm\"",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\""Incorrect password in encrypted challenge\""));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \""kdcchallengearmor\"",\n                                 &client_keys[i], \""challengelongterm\"",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}"", ""target"": 0}]","[{""func_name"": ""ec_verify"", ""file_path"": ""src/kdc/kdc_preauth_ec.c"", ""func_code"": ""static void\nec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\""Encrypted Challenge used outside of FAST tunnel\""));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    if (retval == 0)\n        realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \""clientchallengearmor\"",\n                                          &client_keys[i], \""challengelongterm\"",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\""Incorrect password in encrypted challenge\""));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \""kdcchallengearmor\"",\n                                 &client_keys[i], \""challengelongterm\"",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}""}]","{""function"": 2, ""code"": 2, ""value"": 2}","[{""source"": ""func_info(file:kdc_preauth_ec.c, func:ec_verify)"", ""result"": [{""code"": ""static void\nec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\""Encrypted Challenge used outside of FAST tunnel\""));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \""clientchallengearmor\"",\n                                          &client_keys[i], \""challengelongterm\"",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\""Incorrect password in encrypted challenge\""));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \""kdcchallengearmor\"",\n                                 &client_keys[i], \""challengelongterm\"",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}\n"", ""start_line"": 51, ""end_line"": 153, ""full_name"": ""ec_verify"", ""file_path"": ""src/kdc/kdc_preauth_ec.c""}]}, {""source"": ""code_info(file:kdc_preauth_ec.c, lines:80-100)"", ""result"": ""    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n""}, {""source"": ""value_info(file:kdc_preauth_ec.c, value:retval)"", ""result"": {""value_trace"": [{""full_code"": ""retval = 0"", ""line"": 58, ""func_name"": ""ec_verify""}, {""full_code"": ""retval = ENOENT"", ""line"": 74, ""func_name"": ""ec_verify""}, {""full_code"": ""retval = decode_krb5_enc_data(&scratch, &enc)"", ""line"": 81, ""func_name"": ""ec_verify""}, {""full_code"": ""retval = ENOMEM"", ""line"": 86, ""func_name"": ""ec_verify""}, {""full_code"": ""retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai)"", ""line"": 92, ""func_name"": ""ec_verify""}], ""struct_var"": ""retval"", ""struct_type"": ""krb5_error_code"", ""struct_definition"": ""krb5_error_code""}}, {""source"": ""func_info(func:fast_armor)"", ""result"": [{""code"": ""static krb5_keyblock *\nfast_armor(krb5_context context, krb5_kdcpreauth_rock rock)\n{\n    return rock->rstate->armor_key;\n}"", ""start_line"": 403, ""end_line"": 407, ""full_name"": ""fast_armor"", ""file_path"": ""src/kdc/kdc_preauth.c""}, {""code"": ""static krb5_keyblock *\nfast_armor(krb5_context context, krb5_clpreauth_rock rock)\n{\n    return ((krb5_init_creds_context)rock)->fast_state->armor_key;\n}"", ""start_line"": 428, ""end_line"": 432, ""full_name"": ""fast_armor<duplicate>0"", ""file_path"": ""src/lib/krb5/krb/preauth2.c""}]}, {""source"": ""code_info(file:kdc_preauth_ec.c, lines:100-120)"", ""result"": ""        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \""clientchallengearmor\"",\n                                          &client_keys[i], \""challengelongterm\"",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\""Incorrect password in encrypted challenge\""));\n        }\n""}, {""source"": ""value_info(file:kdc_preauth_ec.c, value:armor_key)"", ""result"": {""value_trace"": [{""full_code"": ""*armor_key = cb->fast_armor(context, rock)"", ""line"": 42, ""func_name"": ""ec_edata""}, {""full_code"": ""*armor_key = cb->fast_armor(context, rock)"", ""line"": 61, ""func_name"": ""ec_verify""}], ""struct_var"": ""armor_key"", ""struct_type"": ""krb5_keyblock*"", ""struct_definition"": ""krb5_keyblock""}}]","src/kdc/kdc_preauth_ec.c:74: 'armor_key' is NULL, setting 'retval' to ENOENT. src/kdc/kdc_preauth_ec.c:88: 'k5memdup0()' overwrites 'retval' with 0 on success, bypassing the error. src/kdc/kdc_preauth_ec.c:100-120: 'krb5_c_fx_cf2_simple(context, armor_key, ...)' dereferences the NULL 'armor_key', causing a crash. The patch adds 'if (retval == 0)' before 'k5memdup0()' to prevent error code overwrite.",0.95,./github/other_context/CVE-2021-36222
39,CVE-2021-39521,CWE-476,c_cpp,An issue was discovered in libredwg through v0.10.1.3751. A NULL pointer dereference exists in the function bit_read_BB() located in bits.c. It allows an attacker to cause Denial of Service.,https://github.com/LibreDWG/libredwg/commit/092725ed1332ea634081ddefe73ff36c635b4035,"decode: fix obj_string_stream overflow handling\n\nto avoid heap overflows, such as in fuzzing GH #262",2,"[{""func_name"": ""obj_string_stream"", ""file_path"": ""src/decode_r2007.c"", ""func_code"": ""int\nobj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                   Bit_Chain *restrict str)\n{\n  BITCODE_RL start = obj->bitsize - 1; // in bits\n  BITCODE_RL data_size = 0;            // in byte\n  BITCODE_RL old_size;                 // in byte\n  BITCODE_RL old_byte;\n  assert (dat != str);\n  old_size = str->size;\n  old_byte = str->byte;\n\n  str->chain += str->byte;\n  // obj->strpos = str->byte * 8 + str->bit;\n\n  str->byte = 0;\n  str->bit = 0;\n  str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0);\n  bit_advance_position (str, start - 8);\n\n  if (str->byte >= old_size - old_byte)\n    {\n      LOG_WARN (\""obj_string_stream overflow\"");\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  LOG_HANDLE (\"" obj string stream +%u: @%lu.%u (%lu)\"", start, str->byte,\n              str->bit & 7, bit_position (str));\n  obj->has_strings = bit_read_B (str);\n  LOG_TRACE (\"" has_strings: %d\\n\"", (int)obj->has_strings);\n  if (!obj->has_strings)\n    {\n      // FIXME wrong bit\n      if (obj->fixedtype == DWG_TYPE_SCALE)\n        obj->has_strings = 1;\n      // str->size = 0;\n      // bit_reset_chain (str);\n      return 0;\n    }\n\n  bit_advance_position (str, -1); //-17\n  str->byte -= 2;\n  LOG_HANDLE (\"" @%lu.%u\"", str->byte, str->bit & 7);\n  data_size = (BITCODE_RL)bit_read_RS (str);\n  LOG_HANDLE (\"" data_size: %u/0x%x\"", data_size, data_size);\n\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      bit_advance_position (str, -1); //-33\n      str->byte -= 4;\n      data_size &= 0x7FFF;\n      hi_size = bit_read_RS (str);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\"" data_size: %u/0x%x\\n\"", data_size, data_size);\n      // LOG_TRACE(\""  -33: @%lu\\n\"", str->byte);\n    }\n  else\n    LOG_HANDLE (\""\\n\"");\n  str->byte -= 2;\n  if (data_size > obj->bitsize)\n    {\n      LOG_WARN (\""Invalid string stream data_size: @%lu.%u\\n\"", str->byte,\n                str->bit & 7);\n      obj->has_strings = 0;\n      bit_reset_chain (str);\n      return DWG_ERR_NOTYETSUPPORTED; // a very low severity error\n    }\n  obj->stringstream_size = data_size;\n  bit_advance_position (str, -(int)data_size);\n  // bit_reset_chain (str);\n  // LOG_TRACE(\"" %d: @%lu.%u (%lu)\\n\"", -(int)data_size - 16, str->byte,\n  // str->bit & 7,\n  //          bit_position(str));\n  // obj->strpos = obj->bitsize_pos + obj->bitsize - obj->stringstream_size;\n  return 0;\n}"", ""target"": 0}, {""func_name"": ""obj_string_stream"", ""file_path"": ""src/decode_r2007.c"", ""func_code"": ""int\nobj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                   Bit_Chain *restrict str)\n{\n  BITCODE_RL start = obj->bitsize - 1; // in bits\n  BITCODE_RL data_size = 0;            // in byte\n  BITCODE_RL old_size;                 // in byte\n  BITCODE_RL old_byte;\n  assert (dat != str);\n  old_size = str->size;\n  old_byte = str->byte;\n\n  str->chain += str->byte;\n  // obj->strpos = str->byte * 8 + str->bit;\n\n  str->byte = 0;\n  str->bit = 0;\n  str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0);\n  bit_advance_position (str, start - 8);\n\n  if (str->byte >= old_size - old_byte)\n    {\n      LOG_WARN (\""obj_string_stream overflow\"");\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  LOG_HANDLE (\"" obj string stream +%u: @%lu.%u (%lu)\"", start, str->byte,\n              str->bit & 7, bit_position (str));\n  obj->has_strings = bit_read_B (str);\n  LOG_TRACE (\"" has_strings: %d\\n\"", (int)obj->has_strings);\n  if (!obj->has_strings)\n    {\n      // FIXME wrong bit\n      if (obj->fixedtype == DWG_TYPE_SCALE)\n        obj->has_strings = 1;\n      // str->size = 0;\n      // bit_reset_chain (str);\n      return 0;\n    }\n\n  bit_advance_position (str, -1); //-17\n  str->byte -= 2;\n  LOG_HANDLE (\"" @%lu.%u\"", str->byte, str->bit & 7);\n  data_size = (BITCODE_RL)bit_read_RS (str);\n  LOG_HANDLE (\"" data_size: %u/0x%x\"", data_size, data_size);\n\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      bit_advance_position (str, -1); //-33\n      str->byte -= 4;\n      data_size &= 0x7FFF;\n      hi_size = bit_read_RS (str);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\"" data_size: %u/0x%x\\n\"", data_size, data_size);\n      // LOG_TRACE(\""  -33: @%lu\\n\"", str->byte);\n    }\n  else\n    LOG_HANDLE (\""\\n\"");\n  str->byte -= 2;\n  if (data_size > obj->bitsize)\n    {\n      LOG_WARN (\""Invalid string stream data_size: @%lu.%u\\n\"", str->byte,\n                str->bit & 7);\n      obj->has_strings = 0;\n      bit_reset_chain (str);\n      return DWG_ERR_NOTYETSUPPORTED; // a very low severity error\n    }\n  obj->stringstream_size = data_size;\n  bit_advance_position (str, -(int)data_size);\n  // bit_reset_chain (str);\n  // LOG_TRACE(\"" %d: @%lu.%u (%lu)\\n\"", -(int)data_size - 16, str->byte,\n  // str->bit & 7,\n  //          bit_position(str));\n  // obj->strpos = obj->bitsize_pos + obj->bitsize - obj->stringstream_size;\n  return 0;\n}"", ""target"": 0}]","[{""func_name"": ""obj_string_stream"", ""file_path"": ""src/decode_r2007.c"", ""func_code"": ""int\nobj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                   Bit_Chain *restrict str)\n{\n  BITCODE_RL start = obj->bitsize - 1; // in bits\n  BITCODE_RL data_size = 0;            // in byte\n  BITCODE_RL old_size;                 // in byte\n  BITCODE_RL old_byte;\n  assert (dat != str);\n  old_size = str->size;\n  old_byte = str->byte;\n\n  str->chain += str->byte;\n  // obj->strpos = str->byte * 8 + str->bit;\n\n  str->byte = 0;\n  str->bit = 0;\n  str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0);\n  bit_advance_position (str, start - 8);\n\n  if (str->byte >= old_size - old_byte)\n    {\n      LOG_WARN (\""obj_string_stream overflow\"");\n      str->byte = old_byte;\n      str->size = old_size;\n      obj->has_strings = 0;\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  LOG_HANDLE (\"" obj string stream +%u: @%lu.%u (%lu)\"", start, str->byte,\n              str->bit & 7, bit_position (str));\n  obj->has_strings = bit_read_B (str);\n  LOG_TRACE (\"" has_strings: %d\\n\"", (int)obj->has_strings);\n  if (!obj->has_strings)\n    {\n      // FIXME wrong bit\n      if (obj->fixedtype == DWG_TYPE_SCALE)\n        obj->has_strings = 1;\n      // str->size = 0;\n      // bit_reset_chain (str);\n      return 0;\n    }\n\n  bit_advance_position (str, -1); //-17\n  str->byte -= 2;\n  LOG_HANDLE (\"" @%lu.%u\"", str->byte, str->bit & 7);\n  data_size = (BITCODE_RL)bit_read_RS (str);\n  LOG_HANDLE (\"" data_size: %u/0x%x\"", data_size, data_size);\n\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      bit_advance_position (str, -1); //-33\n      str->byte -= 4;\n      data_size &= 0x7FFF;\n      hi_size = bit_read_RS (str);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\"" data_size: %u/0x%x\\n\"", data_size, data_size);\n      // LOG_TRACE(\""  -33: @%lu\\n\"", str->byte);\n    }\n  else\n    LOG_HANDLE (\""\\n\"");\n  str->byte -= 2;\n  if (data_size > obj->bitsize)\n    {\n      LOG_WARN (\""Invalid string stream data_size: @%lu.%u\\n\"", str->byte,\n                str->bit & 7);\n      obj->has_strings = 0;\n      bit_reset_chain (str);\n      return DWG_ERR_NOTYETSUPPORTED; // a very low severity error\n    }\n  obj->stringstream_size = data_size;\n  bit_advance_position (str, -(int)data_size);\n  // bit_reset_chain (str);\n  // LOG_TRACE(\"" %d: @%lu.%u (%lu)\\n\"", -(int)data_size - 16, str->byte,\n  // str->bit & 7,\n  //          bit_position(str));\n  // obj->strpos = obj->bitsize_pos + obj->bitsize - obj->stringstream_size;\n  return 0;\n}""}, {""func_name"": ""obj_string_stream"", ""file_path"": ""src/decode_r2007.c"", ""func_code"": ""int\nobj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                   Bit_Chain *restrict str)\n{\n  BITCODE_RL start = obj->bitsize - 1; // in bits\n  BITCODE_RL data_size = 0;            // in byte\n  BITCODE_RL old_size;                 // in byte\n  BITCODE_RL old_byte;\n  assert (dat != str);\n  old_size = str->size;\n  old_byte = str->byte;\n\n  str->chain += str->byte;\n  // obj->strpos = str->byte * 8 + str->bit;\n\n  str->byte = 0;\n  str->bit = 0;\n  str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0);\n  bit_advance_position (str, start - 8);\n\n  if (str->byte >= old_size - old_byte)\n    {\n      LOG_ERROR (\""obj_string_stream overflow, bitsize \"" FORMAT_RL \"" => \"" FORMAT_RL,\n                 obj->bitsize, obj->size * 8);\n      str->byte = old_byte;\n      str->size = old_size;\n      obj->has_strings = 0;\n      obj->bitsize = obj->size * 8;\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  LOG_HANDLE (\"" obj string stream +%u: @%lu.%u (%lu)\"", start, str->byte,\n              str->bit & 7, bit_position (str));\n  obj->has_strings = bit_read_B (str);\n  LOG_TRACE (\"" has_strings: %d\\n\"", (int)obj->has_strings);\n  if (!obj->has_strings)\n    {\n      // FIXME wrong bit\n      if (obj->fixedtype == DWG_TYPE_SCALE)\n        obj->has_strings = 1;\n      // str->size = 0;\n      // bit_reset_chain (str);\n      return 0;\n    }\n\n  bit_advance_position (str, -1); //-17\n  str->byte -= 2;\n  LOG_HANDLE (\"" @%lu.%u\"", str->byte, str->bit & 7);\n  data_size = (BITCODE_RL)bit_read_RS (str);\n  LOG_HANDLE (\"" data_size: %u/0x%x\"", data_size, data_size);\n\n  if (data_size & 0x8000)\n    {\n      BITCODE_RS hi_size;\n      bit_advance_position (str, -1); //-33\n      str->byte -= 4;\n      data_size &= 0x7FFF;\n      hi_size = bit_read_RS (str);\n      data_size |= (hi_size << 15);\n      LOG_HANDLE (\"" data_size: %u/0x%x\\n\"", data_size, data_size);\n      // LOG_TRACE(\""  -33: @%lu\\n\"", str->byte);\n    }\n  else\n    LOG_HANDLE (\""\\n\"");\n  str->byte -= 2;\n  if (data_size > obj->bitsize)\n    {\n      LOG_WARN (\""Invalid string stream data_size: @%lu.%u\\n\"", str->byte,\n                str->bit & 7);\n      obj->has_strings = 0;\n      bit_reset_chain (str);\n      return DWG_ERR_NOTYETSUPPORTED; // a very low severity error\n    }\n  obj->stringstream_size = data_size;\n  bit_advance_position (str, -(int)data_size);\n  // bit_reset_chain (str);\n  // LOG_TRACE(\"" %d: @%lu.%u (%lu)\\n\"", -(int)data_size - 16, str->byte,\n  // str->bit & 7,\n  //          bit_position(str));\n  // obj->strpos = obj->bitsize_pos + obj->bitsize - obj->stringstream_size;\n  return 0;\n}""}]","{""value"": 7, ""function"": 3, ""caller"": 2, ""code"": 2}","[{""source"": ""value_info(file:decode_r2007.c, value:str->byte)"", ""result"": {""value_trace"": [{""full_code"": ""str->byte = 0"", ""line"": 1303, ""func_name"": ""obj_string_stream""}, {""full_code"": ""str->byte -= 2"", ""line"": 1328, ""func_name"": ""obj_string_stream""}, {""full_code"": ""str->byte -= 4"", ""line"": 1337, ""func_name"": ""obj_string_stream""}, {""full_code"": ""str->byte -= 2"", ""line"": 1346, ""func_name"": ""obj_string_stream""}], ""struct_var"": ""str"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:decode_r2007.c, value:str->size)"", ""result"": {""value_trace"": [{""full_code"": ""str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0)"", ""line"": 1305, ""func_name"": ""obj_string_stream""}], ""struct_var"": ""str"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:decode_r2007.c, value:obj->has_strings)"", ""result"": {""value_trace"": [{""full_code"": ""obj->has_strings = bit_read_B (str)"", ""line"": 1315, ""func_name"": ""obj_string_stream""}, {""full_code"": ""obj->has_strings = 1"", ""line"": 1321, ""func_name"": ""obj_string_stream""}, {""full_code"": ""obj->has_strings = 0"", ""line"": 1351, ""func_name"": ""obj_string_stream""}], ""struct_var"": ""obj"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:bits.c, func:bit_read_BB)"", ""result"": [{""code"": ""BITCODE_BB\nbit_read_BB (Bit_Chain *dat)\n{\n  unsigned char result;\n  unsigned char byte;\n\n  CHK_OVERFLOW(__FUNCTION__,0)\n  byte = dat->chain[dat->byte];\n  if (dat->bit < 7)\n    result = (byte & (0xc0 >> dat->bit)) >> (6 - dat->bit);\n  else\n    {\n      result = (byte & 0x01) << 1;\n      if (dat->byte < dat->size - 1)\n        {\n          byte = dat->chain[dat->byte + 1];\n          result |= (byte & 0x80) >> 7;\n        }\n    }\n\n  bit_advance_position (dat, 2);\n  return result;\n}"", ""start_line"": 178, ""end_line"": 200, ""full_name"": ""bit_read_BB"", ""file_path"": ""src/bits.c""}]}, {""source"": ""caller_info(file:decode_r2007.c, func:obj_string_stream)"", ""result"": [{""call_line"": 4363, ""call_code"": ""obj_string_stream (dat, obj, str_dat)"", ""caller_code"": ""static int\ndwg_decode_entity (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Entity *restrict ent)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = ent->dwg;\n  Dwg_Object *obj = &dwg->object[ent->objid];\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Class *klass = NULL;\n  unsigned long objectpos = bit_position (dat);\n  int has_wrong_bitsize = 0;\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  PRE (R_13)\n  {\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat); // until the handles\n    LOG_TRACE (\""bitsize: \"" FORMAT_RL \"" [RL] @%lu.%u\\n\"", obj->bitsize,\n               dat->byte-2, dat->bit);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\"" bitsize: \"" FORMAT_RL \"",\"", obj->bitsize);\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n    // and set the string stream (restricted to size)\n    // skip for all types without strings\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &(obj->handle));\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n      || obj->handle.code)\n    {\n      LOG_ERROR (\""Invalid object handle \"" FORMAT_H \"" at pos @%lu.%u\"",\n                 ARGS_H (obj->handle), dat->byte, dat->bit);\n      // TODO reconstruct the handle and search in the bitsoup?\n      if (has_wrong_bitsize)\n        obj->bitsize = 0;\n      ent->num_eed = 0;\n      ent->preview_exists = 0;\n      return error | DWG_ERR_INVALIDHANDLE;\n    }\n  LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\"", ARGS_H (obj->handle))\n  LOG_INSANE (\"" @%lu.%u\"", dat->byte, dat->bit)\n  LOG_TRACE (\""\\n\"")\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  if (has_wrong_bitsize)\n    LOG_WARN (\""Skip eed\"")\n  else\n    error |= dwg_decode_eed (dat, (Dwg_Object_Object *)ent);\n  LOG_INSANE (\"" @%lu.%u\\n\"", dat->byte, dat->bit)\n  //LOG_TRACE (\""\\n\"")\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  // clang-format off\n  #include \""common_entity_data.spec\""\n  // clang-format on\n\n  dwg_decode_common_entity_handle_data (dat, hdl_dat, obj);\n\n  // elsewhere: object data, handles, padding bits, crc\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\""--common_size: %lu\\n\"", obj->common_size); // needed for unknown\n\n  return error;\n}\n"", ""caller_start"": 4305, ""file_path"": ""src/decode.c""}, {""call_line"": 4464, ""call_code"": ""obj_string_stream (dat, obj, str_dat)"", ""caller_code"": ""static int\ndwg_decode_object (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Object *restrict _obj)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = _obj->dwg;\n  Dwg_Object *obj = &dwg->object[_obj->objid];\n  unsigned long objectpos = bit_position (dat);\n  int has_wrong_bitsize = 0; // first possibly fatal problem\n  BITCODE_BL vcount;\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\""bitsize: \"" FORMAT_RL \"" [RL] @%lu.%u\\n\"", obj->bitsize,\n               dat->byte - 2, dat->bit)\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\"" bitsize: \"" FORMAT_RL \"",\"", obj->bitsize);\n    if (obj->bitsize > obj->size * 8)\n      {\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n        LOG_HANDLE (\"" (fixed)\"");\n      }\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n    // and set the string stream (restricted to size)\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &obj->handle);\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n      || obj->handle.code)\n    {\n      LOG_ERROR (\""Invalid object handle \"" FORMAT_H \"" at pos @%lu.%u\"",\n                 ARGS_H (obj->handle), dat->byte, dat->bit);\n      // TODO reconstruct the handle and search in the bitsoup?\n      if (has_wrong_bitsize)\n        obj->bitsize = 0;\n      obj->tio.object->num_eed = 0;\n      return error | DWG_ERR_INVALIDHANDLE;\n    }\n  LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\\n\"", ARGS_H (obj->handle))\n\n  if (has_wrong_bitsize)\n    LOG_WARN (\""Skip eed\"")\n  else\n    error |= dwg_decode_eed (dat, _obj);\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  VERSIONS (R_13, R_14)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\""bitsize: %u [RL]\\n\"", obj->bitsize);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n\n  // clang-format off\n  #include \""common_object_handle_data.spec\""\n  // clang-format on\n\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\""--common_size: %lu\\n\"", obj->common_size); // needed for unknown\n\n  return error;\n}\n"", ""caller_start"": 4419, ""file_path"": ""src/decode.c""}, {""call_line"": 4189, ""call_code"": ""obj_string_stream (dat, obj, str_dat)"", ""caller_code"": ""static int\ndwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *dat,\n                   Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat)\n{\n  int error = 0;\n  Dwg_Object_Entity *ent = obj->tio.entity;\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Data *dwg = ent->dwg;\n\n  if (!obj || !dat || !ent)\n    return DWG_ERR_INVALIDDWG;\n\n  hdl_dat->from_version = dat->from_version;\n  hdl_dat->version = dat->version;\n  hdl_dat->opts = dat->opts;\n\n  PRE (R_13)\n  {\n\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  SINCE (R_2007) { *str_dat = *dat; }\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_TRACE (\""bitsize: %u [RL] (@%lu.%lu)\\n\"", obj->bitsize,\n               obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n  }\n  obj->was_bitsize_set = 0;\n  if (obj->bitsize)\n    {\n      obj->hdlpos = (obj->address * 8) + obj->bitsize;\n    }\n  SINCE (R_2007)\n  {\n    // The handle stream offset, i.e. end of the object, right after\n    // the has_strings bit.\n    SINCE (R_2010)\n    {\n      if (obj->bitsize)\n        {\n          obj->hdlpos += 8;\n          // LOG_HANDLE (\""(bitsize: \"" FORMAT_RL \"", \"", obj->bitsize);\n          LOG_HANDLE (\""hdlpos: %lu\\n\"", obj->hdlpos);\n        }\n    }\n    // and set the string stream (restricted to size)\n    error |= obj_string_stream (dat, obj, str_dat);\n  }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\"", ARGS_H (obj->handle))\n  LOG_INSANE (\"" @%lu.%u\"", dat->byte - obj->address, dat->bit)\n  LOG_TRACE (\""\\n\"")\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  error |= dwg_encode_eed (dat, obj);\n  // if (error & (DWG_ERR_INVALIDTYPE|DWG_ERR_VALUEOUTOFBOUNDS))\n  //  return error;\n\n  // clang-format off\n  #include \""common_entity_data.spec\""\n  // clang-format on\n\n  return error;\n}\n"", ""caller_start"": 4127, ""file_path"": ""src/encode.c""}, {""call_line"": 4325, ""call_code"": ""obj_string_stream (dat, obj, str_dat)"", ""caller_code"": ""static int\ndwg_encode_object (Dwg_Object *restrict obj, Bit_Chain *dat,\n                   Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat)\n{\n  int error = 0;\n  BITCODE_BL vcount;\n\n  hdl_dat->from_version = dat->from_version;\n  hdl_dat->version = dat->version;\n  hdl_dat->opts = dat->opts;\n\n  {\n    Dwg_Object *_obj = obj;\n    VERSIONS (R_2000, R_2007)\n    {\n      obj->bitsize_pos = bit_position (dat);\n      FIELD_RL (bitsize, 0);\n    }\n    obj->was_bitsize_set = 0;\n    if (obj->bitsize)\n      // the handle stream offset\n      obj->hdlpos = bit_position (dat) + obj->bitsize;\n    SINCE (R_2007) { obj_string_stream (dat, obj, str_dat); }\n    if (!_obj || !obj->tio.object)\n      return DWG_ERR_INVALIDDWG;\n\n    bit_write_H (dat, &obj->handle);\n    LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\\n\"", ARGS_H (obj->handle));\n    error |= dwg_encode_eed (dat, obj);\n\n    VERSIONS (R_13, R_14)\n    {\n      obj->bitsize_pos = bit_position (dat);\n      FIELD_RL (bitsize, 0);\n    }\n  }\n\n  SINCE (R_13) {\n    Dwg_Object_Object *_obj = obj->tio.object;\n    FIELD_BL (num_reactors, 0);\n    SINCE (R_2004) { FIELD_B (is_xdic_missing, 0); }\n    SINCE (R_2013) { FIELD_B (has_ds_data, 0); } // AcDs DATA\n  }\n  return error;\n}\n"", ""caller_start"": 4303, ""file_path"": ""src/encode.c""}]}, {""source"": ""code_info(file:decode.c, lines:4363-4375)"", ""result"": ""      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &(obj->handle));\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n      || obj->handle.code)\n""}, {""source"": ""code_info(file:decode.c, lines:4464-4475)"", ""result"": ""      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &obj->handle);\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n""}, {""source"": ""value_info(file:bits.c, value:chain)"", ""result"": {""value_trace"": [{""full_code"": ""*chain = (BITCODE_RC *)calloc (length + 1, 1)"", ""line"": 1444, ""func_name"": ""bit_read_TF""}, {""full_code"": ""*restrict chain = (BITCODE_RC *)calloc (bytes + (rest ? 2 : 1), 1)"", ""line"": 1468, ""func_name"": ""bit_read_bits""}, {""full_code"": ""chain = (unsigned char *)malloc (length + 1)"", ""line"": 1523, ""func_name"": ""bit_read_TV""}, {""full_code"": ""chain = (BITCODE_TU)malloc ((length + 1) * 2)"", ""line"": 1893, ""func_name"": ""bit_read_TU""}, {""full_code"": ""chain = (BITCODE_TV)malloc (length + 1)"", ""line"": 1919, ""func_name"": ""bit_read_T16""}], ""struct_var"": ""chain"", ""struct_type"": ""BITCODE_RC*"", ""struct_definition"": ""typedef unsigned char BITCODE_RC;""}}, {""source"": ""value_info(file:bits.c, value:byte)"", ""result"": {""value_trace"": [{""full_code"": ""byte = dat->chain[dat->byte]"", ""line"": 153, ""func_name"": ""bit_read_B""}, {""full_code"": ""byte = dat->chain[dat->byte]"", ""line"": 185, ""func_name"": ""bit_read_BB""}, {""full_code"": ""byte = dat->chain[dat->byte + 1]"", ""line"": 193, ""func_name"": ""bit_read_BB""}, {""full_code"": ""byte = dat->chain[dat->byte]"", ""line"": 212, ""func_name"": ""bit_write_BB""}, {""full_code"": ""byte = dat->chain[dat->byte + 1]"", ""line"": 223, ""func_name"": ""bit_write_BB""}], ""struct_var"": ""byte"", ""struct_type"": ""unsigned char"", ""struct_definition"": ""unsigned char""}}, {""source"": ""value_info(file:bits.c, value:size)"", ""result"": {""value_trace"": [{""full_code"": ""size = handle->code << 4"", ""line"": 1288, ""func_name"": ""bit_write_H""}, {""full_code"": ""size |= i + 1"", ""line"": 1289, ""func_name"": ""bit_write_H""}, {""full_code"": ""size = dat->byte - start_address"", ""line"": 1339, ""func_name"": ""bit_check_CRC""}, {""full_code"": ""size = dat->byte - start_address"", ""line"": 1376, ""func_name"": ""bit_write_CRC""}, {""full_code"": ""size = dat->byte - start_address"", ""line"": 1401, ""func_name"": ""bit_write_CRC_LE""}], ""struct_var"": ""size"", ""struct_type"": ""unsigned char"", ""struct_definition"": ""unsigned char""}}, {""source"": ""caller_info(file:bits.c, func:bit_read_BB)"", ""result"": [{""call_line"": 525, ""call_code"": ""bit_read_BB (dat)"", ""caller_code"": ""BITCODE_BS\nbit_read_BS (Bit_Chain *dat)\n{\n  const unsigned char two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    {\n      CHK_OVERFLOW(__FUNCTION__, 0)\n      return bit_read_RS (dat);\n    }\n  else if (two_bit_code == 1)\n    return (BITCODE_BS)bit_read_RC (dat) & 0xFF;\n  else if (two_bit_code == 2)\n    return 0;\n  else /* if (two_bit_code == 3) */\n    return 256;\n}"", ""caller_start"": 522, ""file_path"": ""src/bits.c""}, {""call_line"": 567, ""call_code"": ""bit_read_BB (dat)"", ""caller_code"": ""BITCODE_BL\nbit_read_BL (Bit_Chain *dat)\n{\n  const unsigned char two_bit_code = bit_read_BB (dat);\n  if (two_bit_code == 0)\n    {\n      CHK_OVERFLOW(__FUNCTION__, 0)\n      return bit_read_RL (dat);\n    }\n  else if (two_bit_code == 1)\n    return (BITCODE_BL)bit_read_RC (dat) & 0xFF;\n  else if (two_bit_code == 2)\n    return 0;\n  else /* if (two_bit_code == 3) */\n    {\n      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n      LOG_ERROR (\""bit_read_BL: unexpected 2-bit code: '11'\"")\n      return 256;\n    }\n}"", ""caller_start"": 564, ""file_path"": ""src/bits.c""}, {""call_line"": 634, ""call_code"": ""bit_read_BB (dat)"", ""caller_code"": ""BITCODE_BS\nbit_read_BOT (Bit_Chain *dat)\n{\n  unsigned char two_bit_code;\n\n  two_bit_code = bit_read_BB (dat);\n\n  if (two_bit_code == 0)\n    {\n      CHK_OVERFLOW(__FUNCTION__, 0)\n      return bit_read_RC (dat);\n    }\n  else if (two_bit_code == 1)\n    return bit_read_RC (dat) + 0x1f0;\n  else\n    return bit_read_RS (dat);\n}"", ""caller_start"": 629, ""file_path"": ""src/bits.c""}, {""call_line"": 680, ""call_code"": ""bit_read_BB (dat)"", ""caller_code"": ""BITCODE_BLL\nbit_read_BLL (Bit_Chain *dat)\n{\n  unsigned int i, len;\n  BITCODE_BLL result = 0ULL;\n  len = bit_read_BB (dat) << 1 | bit_read_B (dat);\n  switch (len)\n    {\n    case 1:\n      return bit_read_RC (dat);\n    case 2:\n      return bit_read_RS (dat);\n    case 4:\n      return bit_read_RL (dat);\n    default:\n      CHK_OVERFLOW(__FUNCTION__, 0)\n      for (i = 0; i < len; i++)\n        {\n          result <<= 8;\n          result |= bit_read_RC (dat);\n        }\n      return result;\n    }\n}"", ""caller_start"": 675, ""file_path"": ""src/bits.c""}]}, {""source"": ""func_info(file:decode.c, func:dwg_decode_entity)"", ""result"": [{""code"": ""static int\ndwg_decode_entity (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Entity *restrict ent)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = ent->dwg;\n  Dwg_Object *obj = &dwg->object[ent->objid];\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Class *klass = NULL;\n  unsigned long objectpos = bit_position (dat);\n  int has_wrong_bitsize = 0;\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  PRE (R_13)\n  {\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat); // until the handles\n    LOG_TRACE (\""bitsize: \"" FORMAT_RL \"" [RL] @%lu.%u\\n\"", obj->bitsize,\n               dat->byte-2, dat->bit);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\"" bitsize: \"" FORMAT_RL \"",\"", obj->bitsize);\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n    // and set the string stream (restricted to size)\n    // skip for all types without strings\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &(obj->handle));\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n      || obj->handle.code)\n    {\n      LOG_ERROR (\""Invalid object handle \"" FORMAT_H \"" at pos @%lu.%u\"",\n                 ARGS_H (obj->handle), dat->byte, dat->bit);\n      // TODO reconstruct the handle and search in the bitsoup?\n      if (has_wrong_bitsize)\n        obj->bitsize = 0;\n      ent->num_eed = 0;\n      ent->preview_exists = 0;\n      return error | DWG_ERR_INVALIDHANDLE;\n    }\n  LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\"", ARGS_H (obj->handle))\n  LOG_INSANE (\"" @%lu.%u\"", dat->byte, dat->bit)\n  LOG_TRACE (\""\\n\"")\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  if (has_wrong_bitsize)\n    LOG_WARN (\""Skip eed\"")\n  else\n    error |= dwg_decode_eed (dat, (Dwg_Object_Object *)ent);\n  LOG_INSANE (\"" @%lu.%u\\n\"", dat->byte, dat->bit)\n  //LOG_TRACE (\""\\n\"")\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  // clang-format off\n  #include \""common_entity_data.spec\""\n  // clang-format on\n\n  dwg_decode_common_entity_handle_data (dat, hdl_dat, obj);\n\n  // elsewhere: object data, handles, padding bits, crc\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\""--common_size: %lu\\n\"", obj->common_size); // needed for unknown\n\n  return error;\n}\n"", ""start_line"": 4305, ""end_line"": 4412, ""full_name"": ""dwg_decode_entity"", ""file_path"": ""src/decode.c""}]}, {""source"": ""func_info(file:decode.c, func:dwg_decode_object)"", ""result"": [{""code"": ""static int\ndwg_decode_object (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Object *restrict _obj)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = _obj->dwg;\n  Dwg_Object *obj = &dwg->object[_obj->objid];\n  unsigned long objectpos = bit_position (dat);\n  int has_wrong_bitsize = 0; // first possibly fatal problem\n  BITCODE_BL vcount;\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\""bitsize: \"" FORMAT_RL \"" [RL] @%lu.%u\\n\"", obj->bitsize,\n               dat->byte - 2, dat->bit)\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\"" bitsize: \"" FORMAT_RL \"",\"", obj->bitsize);\n    if (obj->bitsize > obj->size * 8)\n      {\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n        LOG_HANDLE (\"" (fixed)\"");\n      }\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n    // and set the string stream (restricted to size)\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n        str_dat->size = 0;\n      }\n  }\n\n  error |= bit_read_H (dat, &obj->handle);\n  if (error & DWG_ERR_INVALIDHANDLE || !obj->handle.value || !obj->handle.size\n      || obj->handle.code)\n    {\n      LOG_ERROR (\""Invalid object handle \"" FORMAT_H \"" at pos @%lu.%u\"",\n                 ARGS_H (obj->handle), dat->byte, dat->bit);\n      // TODO reconstruct the handle and search in the bitsoup?\n      if (has_wrong_bitsize)\n        obj->bitsize = 0;\n      obj->tio.object->num_eed = 0;\n      return error | DWG_ERR_INVALIDHANDLE;\n    }\n  LOG_TRACE (\""handle: \"" FORMAT_H \"" [H 5]\\n\"", ARGS_H (obj->handle))\n\n  if (has_wrong_bitsize)\n    LOG_WARN (\""Skip eed\"")\n  else\n    error |= dwg_decode_eed (dat, _obj);\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  VERSIONS (R_13, R_14)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\""bitsize: %u [RL]\\n\"", obj->bitsize);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\""Invalid bitsize \"" FORMAT_RL \"" > \"" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        has_wrong_bitsize = 1;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n    else\n      error |= obj_handle_stream (dat, obj, hdl_dat);\n  }\n\n  // clang-format off\n  #include \""common_object_handle_data.spec\""\n  // clang-format on\n\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\""--common_size: %lu\\n\"", obj->common_size); // needed for unknown\n\n  return error;\n}\n"", ""start_line"": 4419, ""end_line"": 4520, ""full_name"": ""dwg_decode_object"", ""file_path"": ""src/decode.c""}]}, {""source"": ""value_info(file:decode.c, value:error)"", ""result"": {""value_trace"": [{""full_code"": ""error = 0"", ""line"": 302, ""func_name"": ""decode_preR13_section""}, {""full_code"": ""error = dwg_decode_eed (dat, (Dwg_Object_Object *)ent)"", ""line"": 632, ""func_name"": ""decode_entity_preR13""}, {""full_code"": ""error = 0"", ""line"": 651, ""func_name"": ""decode_preR13""}, {""full_code"": ""error |= decode_preR13_entities (entities_start, entities_end, 0, dat, dwg)"", ""line"": 731, ""func_name"": ""decode_preR13""}, {""full_code"": ""error |= decode_preR13_section (SECTION_BLOCK, dat, dwg)"", ""line"": 735, ""func_name"": ""decode_preR13""}], ""struct_var"": ""error"", ""struct_type"": ""int"", ""struct_definition"": ""int""}}]","src/decode_r2007.c:1308-1313 (overflow in `obj_string_stream` leaves `dat->byte` unbounded) → src/bits.c:185-193 (bit_read_BB accesses `dat->chain[dat->byte]` without bounds validation). Triggered when `obj_string_stream` returns an error but `dwg_decode_entity`/`dwg_decode_object` (src/decode.c:4363-4375, 4464-4475) continue processing, passing corrupted `Bit_Chain` to `bit_read_H` (src/bits.c:525, 567, etc.).",0.95,./github/other_context/CVE-2021-39521
40,CVE-2021-44108,"CWE-787, CWE-476",c_cpp,A null pointer dereference in src/amf/namf-handler.c in Open5GS 2.3.6 and earlier allows remote attackers to Denial of Service via a crafted sbi request to amf.,https://github.com/open5gs/open5gs/commit/d919b2744cd05abae043490f0a3dd1946c1ccb8c,[AMF] fix the memory problem (#1247)\n\n1. memory corruption\n- Overflow num_of_part in SBI message\n2. null pointer dereference\n- n2InfoContent->ngap_ie_type,5,"[{""func_name"": ""on_header_value"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            if (data->part[data->num_of_part].content_type)\n                ogs_free(data->part[data->num_of_part].content_type);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            if (data->part[data->num_of_part].content_id)\n                ogs_free(data->part[data->num_of_part].content_id);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\""Unknown header field [%s]\"", data->header_field);\n        END\n    }\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""on_part_data_end"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    data->num_of_part++;\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""parse_multipart"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int parse_multipart(\n        ogs_sbi_message_t *message, ogs_sbi_http_message_t *http)\n{\n    char *boundary = NULL;\n    int i;\n\n    multipart_parser_settings settings;\n    multipart_parser_data_t data;\n\n    multipart_parser *parser = NULL;\n\n    ogs_assert(message);\n    ogs_assert(http);\n\n    memset(&settings, 0, sizeof(settings));\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_part_data = &on_part_data;\n    settings.on_part_data_end = &on_part_data_end;\n\n    for (i = 0; i < http->content_length; i++) {\n        if (http->content[i] == '\\r' && http->content[i+1] == '\\n')\n            break;\n    }\n\n    if (i >= http->content_length) {\n        ogs_error(\""Invalid HTTP content [%d]\"", i);\n        ogs_log_hexdump(OGS_LOG_ERROR,\n                (unsigned char *)http->content, http->content_length);\n        return OGS_ERROR;\n    }\n\n    boundary = ogs_strndup(http->content, i);\n    ogs_assert(boundary);\n\n    parser = multipart_parser_init(boundary, &settings);\n    ogs_assert(parser);\n\n    memset(&data, 0, sizeof(data));\n    multipart_parser_set_data(parser, &data);\n    multipart_parser_execute(parser, http->content, http->content_length);\n\n    multipart_parser_free(parser);\n    ogs_free(boundary);\n\n    for (i = 0; i < data.num_of_part; i++) {\n        SWITCH(data.part[i].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n            parse_json(message,\n                    data.part[i].content_type, data.part[i].content);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n\n            break;\n\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            http->part[http->num_of_part].content_id =\n                data.part[i].content_id;\n            http->part[http->num_of_part].content_type =\n                data.part[i].content_type;\n            http->part[http->num_of_part].pkbuf =\n                ogs_pkbuf_alloc(NULL, data.part[i].content_length);\n            ogs_expect_or_return_val(\n                http->part[http->num_of_part].pkbuf, OGS_ERROR);\n            ogs_pkbuf_put_data(http->part[http->num_of_part].pkbuf,\n                data.part[i].content, data.part[i].content_length);\n\n            message->part[message->num_of_part].content_id =\n                http->part[http->num_of_part].content_id;\n            message->part[message->num_of_part].content_type =\n                http->part[http->num_of_part].content_type;\n            message->part[message->num_of_part].pkbuf =\n                ogs_pkbuf_copy(http->part[http->num_of_part].pkbuf);\n            ogs_expect_or_return_val(\n                message->part[message->num_of_part].pkbuf, OGS_ERROR);\n\n            http->num_of_part++;\n            message->num_of_part++;\n\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n            break;\n\n        DEFAULT\n            ogs_error(\""Unknown content-type[%s]\"", data.part[i].content_type);\n        END\n    }\n\n    if (data.part[i].content_id)\n        ogs_free(data.part[i].content_id);\n    if (data.part[i].content_type)\n        ogs_free(data.part[i].content_type);\n\n    if (data.header_field)\n        ogs_free(data.header_field);\n\n    return OGS_OK;\n}"", ""target"": 0}, {""func_name"": ""on_part_data"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            } else {\n                offset = data->part[data->num_of_part].content_length;\n                if ((data->part[data->num_of_part].content_length + length) >\n                        OGS_HUGE_LEN) {\n                    ogs_error(\""Overflow length [%d:%d]\"",\n                        (int)data->part[data->num_of_part].content_length,\n                        (int)length);\n                    ogs_assert_if_reached();\n                    return 0;\n                }\n                data->part[data->num_of_part].content_length += length;\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_log_hexdump(OGS_LOG_FATAL, (unsigned char *)at, length);\n            ogs_error(\""Unknown content_type [%s]\"",\n                    data->part[data->num_of_part].content_type);\n        END\n    }\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""amf_namf_comm_handle_n1_n2_message_transfer"", ""file_path"": ""src/amf/namf-handler.c"", ""func_code"": ""int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\""No N1N2MessageTransferReqData\"");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\""No PDU Session Identity\"");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\""No SUPI\"");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\""No UE context [%s]\"", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\""[%s] No PDU Session Context [%d]\"",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\""No n1MessageContent\"");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\""[%s] No N1 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\""No smInfo\"");\n            return OGS_ERROR;\n        }\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\""No n2InfoContent\"");\n            return OGS_ERROR;\n        }\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\""No ngapData\"");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (n2InfoContent->ngap_ie_type) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\""[%s:%d] No n1-n2-failure-notification-uri\"",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\""[%s:%d] Invalid URI [%s]\"",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\""[%s] No N1 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n\n        } else {\n            ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\""[%s] No skipInd\"", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n\n        } else {\n            ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\""Not implemented ngap_ie_type[%d]\"",\n                n2InfoContent->ngap_ie_type);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}"", ""target"": 0}]","[{""func_name"": ""on_header_value"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            ogs_assert(data->part[data->num_of_part].content_type == NULL);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            ogs_assert(data->part[data->num_of_part].content_id == NULL);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\""Unknown header field [%s]\"", data->header_field);\n        END\n    }\n\n    return 0;\n}""}, {""func_name"": ""on_part_data_end"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART) {\n        data->num_of_part++;\n    }\n\n    return 0;\n}""}, {""func_name"": ""parse_multipart"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int parse_multipart(\n        ogs_sbi_message_t *message, ogs_sbi_http_message_t *http)\n{\n    char *boundary = NULL;\n    int i;\n\n    multipart_parser_settings settings;\n    multipart_parser_data_t data;\n\n    multipart_parser *parser = NULL;\n\n    ogs_assert(message);\n    ogs_assert(http);\n\n    memset(&settings, 0, sizeof(settings));\n    settings.on_header_field = &on_header_field;\n    settings.on_header_value = &on_header_value;\n    settings.on_part_data = &on_part_data;\n    settings.on_part_data_end = &on_part_data_end;\n\n    for (i = 0; i < http->content_length; i++) {\n        if (http->content[i] == '\\r' && http->content[i+1] == '\\n')\n            break;\n    }\n\n    if (i >= http->content_length) {\n        ogs_error(\""Invalid HTTP content [%d]\"", i);\n        ogs_log_hexdump(OGS_LOG_ERROR,\n                (unsigned char *)http->content, http->content_length);\n        return OGS_ERROR;\n    }\n\n    boundary = ogs_strndup(http->content, i);\n    ogs_assert(boundary);\n\n    parser = multipart_parser_init(boundary, &settings);\n    ogs_assert(parser);\n\n    memset(&data, 0, sizeof(data));\n    multipart_parser_set_data(parser, &data);\n    multipart_parser_execute(parser, http->content, http->content_length);\n\n    multipart_parser_free(parser);\n    ogs_free(boundary);\n\n    if (data.num_of_part > OGS_SBI_MAX_NUM_OF_PART) {\n        /* Overflow Issues #1247 */\n        ogs_fatal(\""Overflow num_of_part[%d]\"", data.num_of_part);\n        ogs_assert_if_reached();\n    }\n    for (i = 0; i < data.num_of_part; i++) {\n        SWITCH(data.part[i].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n            parse_json(message,\n                    data.part[i].content_type, data.part[i].content);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n\n            break;\n\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            http->part[http->num_of_part].content_id =\n                data.part[i].content_id;\n            http->part[http->num_of_part].content_type =\n                data.part[i].content_type;\n            http->part[http->num_of_part].pkbuf =\n                ogs_pkbuf_alloc(NULL, data.part[i].content_length);\n            ogs_expect_or_return_val(\n                http->part[http->num_of_part].pkbuf, OGS_ERROR);\n            ogs_pkbuf_put_data(http->part[http->num_of_part].pkbuf,\n                data.part[i].content, data.part[i].content_length);\n\n            message->part[message->num_of_part].content_id =\n                http->part[http->num_of_part].content_id;\n            message->part[message->num_of_part].content_type =\n                http->part[http->num_of_part].content_type;\n            message->part[message->num_of_part].pkbuf =\n                ogs_pkbuf_copy(http->part[http->num_of_part].pkbuf);\n            ogs_expect_or_return_val(\n                message->part[message->num_of_part].pkbuf, OGS_ERROR);\n\n            http->num_of_part++;\n            message->num_of_part++;\n\n            if (data.part[i].content)\n                ogs_free(data.part[i].content);\n            break;\n\n        DEFAULT\n            ogs_error(\""Unknown content-type[%s]\"", data.part[i].content_type);\n\n            if (data.part[i].content_id)\n                ogs_free(data.part[i].content_id);\n            if (data.part[i].content_type)\n                ogs_free(data.part[i].content_type);\n        END\n    }\n\n    if (data.header_field)\n        ogs_free(data.header_field);\n\n    return OGS_OK;\n}""}, {""func_name"": ""on_part_data"", ""file_path"": ""lib/sbi/message.c"", ""func_code"": ""static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            } else {\n                offset = data->part[data->num_of_part].content_length;\n                if ((data->part[data->num_of_part].content_length + length) >\n                        OGS_HUGE_LEN) {\n                    ogs_error(\""Overflow length [%d:%d]\"",\n                        (int)data->part[data->num_of_part].content_length,\n                        (int)length);\n                    ogs_assert_if_reached();\n                    return 0;\n                }\n                data->part[data->num_of_part].content_length += length;\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_error(\""Unknown content_type [%s]\"",\n                    data->part[data->num_of_part].content_type);\n            ogs_log_hexdump(OGS_LOG_ERROR, (unsigned char *)at, length);\n        END\n    }\n    return 0;\n}""}, {""func_name"": ""amf_namf_comm_handle_n1_n2_message_transfer"", ""file_path"": ""src/amf/namf-handler.c"", ""func_code"": ""int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    OpenAPI_ngap_ie_type_e ngapIeType = OpenAPI_ngap_ie_type_NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\""No N1N2MessageTransferReqData\"");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\""No PDU Session Identity\"");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\""No SUPI\"");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\""No UE context [%s]\"", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\""[%s] No PDU Session Context [%d]\"",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\""No n1MessageContent\"");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\""[%s] No N1 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\""No smInfo\"");\n            return OGS_ERROR;\n        }\n\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\""No n2InfoContent\"");\n            return OGS_ERROR;\n        }\n\n        ngapIeType = n2InfoContent->ngap_ie_type;\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\""No ngapData\"");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (ngapIeType) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\""[%s:%d] No n1-n2-failure-notification-uri\"",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\""[%s:%d] Invalid URI [%s]\"",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\""[%s] No N1 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n\n        } else {\n            ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\""[%s] No N2 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\""[%s] No skipInd\"", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\""nas_5gs_send_to_gnb() failed\"");\n\n        } else {\n            ogs_fatal(\""[%s] Invalid AMF-UE state\"", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\""Not implemented ngapIeType[%d]\"", ngapIeType);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}""}]","{""function"": 2, ""code"": 2, ""caller"": 1}","[{""source"": ""func_info(func:multipart_parser_get_data)"", ""result"": [{""code"": ""void *multipart_parser_get_data(multipart_parser *p) {\n    return p->data;\n}"", ""start_line"": 106, ""end_line"": 108, ""full_name"": ""multipart_parser_get_data"", ""file_path"": ""lib/sbi/contrib/multipart_parser.c""}]}, {""source"": ""code_info(file:message.c, lines:100-200)"", ""result"": ""    if (message->Amf3GppAccessRegistration)\n        OpenAPI_amf3_gpp_access_registration_free(\n                message->Amf3GppAccessRegistration);\n    if (message->AccessAndMobilitySubscriptionData)\n        OpenAPI_access_and_mobility_subscription_data_free(\n                message->AccessAndMobilitySubscriptionData);\n    if (message->SmfSelectionSubscriptionData)\n        OpenAPI_smf_selection_subscription_data_free(\n                message->SmfSelectionSubscriptionData);\n    if (message->UeContextInSmfData)\n        OpenAPI_ue_context_in_smf_data_free(message->UeContextInSmfData);\n    if (message->SmContextCreateData)\n        OpenAPI_sm_context_create_data_free(message->SmContextCreateData);\n    if (message->SmContextCreatedData)\n        OpenAPI_sm_context_created_data_free(message->SmContextCreatedData);\n    if (message->SmContextCreateError)\n        OpenAPI_sm_context_create_error_free(message->SmContextCreateError);\n    if (message->SmContextUpdateData)\n        OpenAPI_sm_context_update_data_free(message->SmContextUpdateData);\n    if (message->SmContextUpdatedData)\n        OpenAPI_sm_context_updated_data_free(message->SmContextUpdatedData);\n    if (message->SmContextUpdateError)\n        OpenAPI_sm_context_update_error_free(message->SmContextUpdateError);\n    if (message->SmContextReleaseData)\n        OpenAPI_sm_context_release_data_free(message->SmContextReleaseData);\n    if (message->SmContextReleasedData)\n        OpenAPI_sm_context_released_data_free(message->SmContextReleasedData);\n    if (message->SessionManagementSubscriptionData)\n        OpenAPI_session_management_subscription_data_free(\n                message->SessionManagementSubscriptionData);\n    if (message->N1N2MessageTransferReqData)\n        OpenAPI_n1_n2_message_transfer_req_data_free(\n                message->N1N2MessageTransferReqData);\n    if (message->N1N2MessageTransferRspData)\n        OpenAPI_n1_n2_message_transfer_rsp_data_free(\n                message->N1N2MessageTransferRspData);\n    if (message->N1N2MsgTxfrFailureNotification)\n        OpenAPI_n1_n2_msg_txfr_failure_notification_free(\n                message->N1N2MsgTxfrFailureNotification);\n    if (message->SmContextStatusNotification)\n        OpenAPI_sm_context_status_notification_free(\n                message->SmContextStatusNotification);\n    if (message->PolicyAssociationRequest)\n        OpenAPI_policy_association_request_free(\n                message->PolicyAssociationRequest);\n    if (message->PolicyAssociation)\n        OpenAPI_policy_association_free(message->PolicyAssociation);\n    if (message->AmPolicyData)\n        OpenAPI_am_policy_data_free(message->AmPolicyData);\n    if (message->SmPolicyContextData)\n        OpenAPI_sm_policy_context_data_free(message->SmPolicyContextData);\n    if (message->SmPolicyDecision)\n        OpenAPI_sm_policy_decision_free(message->SmPolicyDecision);\n    if (message->SmPolicyData)\n        OpenAPI_sm_policy_data_free(message->SmPolicyData);\n    if (message->SmPolicyDeleteData)\n        OpenAPI_sm_policy_delete_data_free(message->SmPolicyDeleteData);\n    if (message->AuthorizedNetworkSliceInfo)\n        OpenAPI_authorized_network_slice_info_free(\n                message->AuthorizedNetworkSliceInfo);\n    if (message->PcfBinding)\n        OpenAPI_pcf_binding_free(message->PcfBinding);\n    if (message->AppSessionContext)\n        OpenAPI_app_session_context_free(message->AppSessionContext);\n    if (message->AppSessionContextUpdateDataPatch)\n        OpenAPI_app_session_context_update_data_patch_free(message->AppSessionContextUpdateDataPatch);\n    if (message->SmPolicyNotification)\n        OpenAPI_sm_policy_notification_free(message->SmPolicyNotification);\n    if (message->TerminationNotification)\n        OpenAPI_termination_notification_free(message->TerminationNotification);\n\n    for (i = 0; i < message->num_of_part; i++) {\n        if (message->part[i].pkbuf)\n            ogs_pkbuf_free(message->part[i].pkbuf);\n    }\n}\n\nogs_sbi_request_t *ogs_sbi_request_new(void)\n{\n    ogs_sbi_request_t *request = NULL;\n\n    ogs_pool_alloc(&request_pool, &request);\n    ogs_expect_or_return_val(request, NULL);\n    memset(request, 0, sizeof(ogs_sbi_request_t));\n\n    request->http.params = ogs_hash_make();\n    ogs_expect_or_return_val(request->http.params, NULL);\n    request->http.headers = ogs_hash_make();\n    ogs_expect_or_return_val(request->http.headers, NULL);\n\n    return request;\n}\n\nogs_sbi_response_t *ogs_sbi_response_new(void)\n{\n    ogs_sbi_response_t *response = NULL;\n\n    ogs_pool_alloc(&response_pool, &response);\n    ogs_expect_or_return_val(response, NULL);\n    memset(response, 0, sizeof(ogs_sbi_response_t));\n\n    response->http.params = ogs_hash_make();\n""}, {""source"": ""caller_info(func:amf_namf_comm_handle_n1_n2_message_transfer)"", ""result"": [{""call_line"": 162, ""call_code"": ""amf_namf_comm_handle_n1_n2_message_transfer(\n                                stream, &sbi_message)"", ""caller_code"": ""void amf_state_operational(ogs_fsm_t *s, amf_event_t *e)\n{\n    int rv;\n    char buf[OGS_ADDRSTRLEN];\n    const char *api_version = NULL;\n\n    ogs_sock_t *sock = NULL;\n    ogs_sockaddr_t *addr = NULL;\n    amf_gnb_t *gnb = NULL;\n    uint16_t max_num_of_ostreams = 0;\n\n    ogs_ngap_message_t ngap_message;\n    ogs_pkbuf_t *pkbuf = NULL;\n    int rc;\n\n    ogs_nas_5gs_message_t nas_message;\n    ran_ue_t *ran_ue = NULL;\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_sbi_object_t *sbi_object = NULL;\n    ogs_sbi_xact_t *sbi_xact = NULL;\n    int state = AMF_CREATE_SM_CONTEXT_NO_STATE;\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *sbi_request = NULL;\n    OpenAPI_nf_type_e target_nf_type = OpenAPI_nf_type_NULL;\n\n    ogs_sbi_nf_instance_t *nf_instance = NULL;\n    ogs_sbi_subscription_t *subscription = NULL;\n    ogs_sbi_response_t *sbi_response = NULL;\n    ogs_sbi_message_t sbi_message;\n\n    amf_sm_debug(e);\n\n    ogs_assert(s);\n\n    switch (e->id) {\n    case OGS_FS..."", ""caller_start"": 46, ""file_path"": ""src/amf/amf-sm.c""}]}, {""source"": ""func_info(file:multipart_parser.c, func:multipart_parser_init)"", ""result"": [{""code"": ""multipart_parser* multipart_parser_init\n    (const char *boundary, const multipart_parser_settings* settings) {\n\n  multipart_parser* p = malloc(sizeof(multipart_parser) +\n                             "", ""start_line"": 79, ""end_line"": 96, ""full_name"": ""multipart_parser_init"", ""file_path"": ""lib/sbi/contrib/multipart_parser.c""}]}, {""source"": ""code_info(file:namf-handler.c, lines:50-120)"", ""result"": ""    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\""No N1N2MessageTransferReqData\"");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\""No PDU Session Identity\"");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\""No SUPI\"");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\""No UE context [%s]\"", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\""[%s] No PDU Session Context [%d]\"",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\""No n1MessageContent\"");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\""[%s] No N1 SM Content\"", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\""No smInfo\"");\n            return OGS_ERROR;\n        }\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n""}]","1. **Multipart Parsing Overflow**: Unchecked increment of `data->num_of_part` (lib/sbi/message.c:1918) during multipart parsing risks overflow beyond `OGS_SBI_MAX_NUM_OF_PART`, causing out-of-bounds access in `data->part[]` (lib/sbi/message.c:1834, 1868). The `multipart_parser_init` (lib/sbi/contrib/multipart_parser.c:79-96) initializes `data->num_of_part` to 0, and the patch adds bounds checks. 2. **Null Dereference**: `n2InfoContent->ngap_ie_type` (src/amf/namf-handler.c:118) is dereferenced without null check; the patch caches this value in `ngapIeType` (src/amf/namf-handler.c:54). `n2InfoContent` is populated from `smInfo->n2_info_content` (src/amf/namf-handler.c:118) in the SBI request. The chain is complete with all evidence.",1.0,./github/other_context/CVE-2021-44108
41,CVE-2021-44758,CWE-476,c_cpp,Heimdal before 7.7.1 allows attackers to cause a NULL pointer dereference in a SPNEGO acceptor via a preferred_mech_type of GSS_C_NO_OID and a nonzero initial_response value to send_accept.,https://github.com/heimdal/heimdal/commit/f9ec7002cdd526ae84fbacbf153162e118f22580,"spnego: CVE-2021-44758 send_reject when no mech selected\n\nThis fixes a DoS where an initial SPNEGO token that has no acceptable\nmechanisms causes a NULL dereference in acceptors.\n\nsend_accept() when called with a non-zero 'initial_response' did\nnot handle the case of gssspnego_ctx.preferred_mech_type equal\nto GSS_C_NO_OID.\n\nThe failure to handle GSS_C_NO_OID has been present since the\ninitial revision of gssapi/spnego,\n2baa7e7d613c26b2b037b368931519a84baec53d but might not have\nbeen exercised until later revisions.\n\nThe introduction of opportunistic token handling in\ngss_accept_sec_context(), 3c9d3266f47f594a29068c9d629908e7000ac663,\nintroduced two bugs:\n\n 1. The optional mechToken field is used unconditionally\n    possibly resulting in a segmentation fault.\n\n 2. If use of the opportunistic token is unsuccessful and the\n    mech type list length is one, send_accept() can be called\n    with 'initial_response' true and preferred mech set to\n    GSS_C_NO_OID.\n\nb53c90da0890a9cce6f95c552f094ff6d69027bf (""Make error reporting\nsomewhat more correct for SPNEGO"") attempted to fix the first\nissue and increased the likelihood of the second.\n\nThis change alters the behavior of acceptor_start() so it calls\nsend_reject() when no mechanism was selected.",1,"[{""func_name"": ""GSSAPI_CALLCONV"", ""file_path"": ""lib/gssapi/spnego/accept_sec_context.c"", ""func_code"": ""static OM_uint32 GSSAPI_CALLCONV\nacceptor_start\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, junk;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenInit *ni;\n    gss_buffer_desc data;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_output_token;\n    gss_buffer_desc mech_buf;\n    gss_OID preferred_mech_type = GSS_C_NO_OID;\n    gssspnego_ctx ctx;\n    int get_mic = 0;\n    int first_ok = 0;\n\n    mech_output_token.value = NULL;\n    mech_output_token.length = 0;\n    mech_buf.value = NULL;\n\n    if (input_token_buffer->length == 0)\n\treturn send_supported_mechs (minor_status, output_token);\n\n    ret = _gss_spnego_alloc_sec_context(minor_status, context_handle);\n    if (ret != GSS_S_COMPLETE)\n\treturn ret;\n\n    ctx = (gssspnego_ctx)*context_handle;\n\n    /*\n     * The GSS-API encapsulation is only present on the initial\n     * context token (negTokenInit).\n     */\n    ret = gss_decapsulate_token (input_token_buffer,\n\t\t\t\t GSS_SPNEGO_MECHANISM,\n\t\t\t\t &data);\n    if (ret)\n\treturn ret;\n\n    ret = decode_NegotiationToken(data.value, data.length, &nt, &nt_len);\n    gss_release_buffer(minor_status, &data);\n    if (ret) {\n\t*minor_status = ret;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    if (nt.element != choice_NegotiationToken_negTokenInit) {\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    ni = &nt.u.negTokenInit;\n\n    if (ni->mechTypes.len < 1) {\n\tfree_NegotiationToken(&nt);\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    HEIMDAL_MUTEX_lock(&ctx->ctx_id_mutex);\n\n    ret = copy_MechTypeList(&ni->mechTypes, &ctx->initiator_mech_types);\n    if (ret) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\tfree_NegotiationToken(&nt);\n\t*minor_status = ret;\n\treturn GSS_S_FAILURE;\n    }\n\n    /*\n     * First we try the opportunistic token if we have support for it,\n     * don't try to verify we have credential for the token,\n     * gss_accept_sec_context() will (hopefully) tell us that.\n     * If that failes,\n     */\n\n    ret = select_mech(minor_status,\n\t\t      &ni->mechTypes.val[0],\n\t\t      0,\n\t\t      &preferred_mech_type);\n\n    if (ret == 0 && ni->mechToken != NULL) {\n\tgss_buffer_desc ibuf;\n\n\tibuf.length = ni->mechToken->length;\n\tibuf.value = ni->mechToken->data;\n\tmech_input_token = &ibuf;\n\n\tif (ctx->mech_src_name != GSS_C_NO_NAME)\n\t    gss_release_name(&junk, &ctx->mech_src_name);\n\n\tret = gss_accept_sec_context(minor_status,\n\t\t\t\t     &ctx->negotiated_ctx_id,\n\t\t\t\t     acceptor_cred_handle,\n\t\t\t\t     mech_input_token,\n\t\t\t\t     input_chan_bindings,\n\t\t\t\t     &ctx->mech_src_name,\n\t\t\t\t     &ctx->negotiated_mech_type,\n\t\t\t\t     &mech_output_token,\n\t\t\t\t     &ctx->mech_flags,\n\t\t\t\t     &ctx->mech_time_rec,\n\t\t\t\t     delegated_cred_handle);\n\n\tif (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\t    ctx->preferred_mech_type = preferred_mech_type;\n\t    if (ret == GSS_S_COMPLETE)\n\t\tctx->open = 1;\n\n\t    ret = acceptor_complete(minor_status,\n\t\t\t\t    ctx,\n\t\t\t\t    &get_mic,\n\t\t\t\t    &mech_buf,\n\t\t\t\t    mech_input_token,\n\t\t\t\t    &mech_output_token,\n\t\t\t\t    ni->mechListMIC,\n\t\t\t\t    output_token);\n\t    if (ret != GSS_S_COMPLETE)\n\t\tgoto out;\n\n\t    first_ok = 1;\n\t} else {\n\t    gss_mg_collect_error(preferred_mech_type, ret, *minor_status);\n\t}\n    }\n\n    /*\n     * If opportunistic token failed, lets try the other mechs.\n     */\n\n    if (!first_ok && ni->mechToken != NULL) {\n\tsize_t j;\n\n\tpreferred_mech_type = GSS_C_NO_OID;\n\n\t/* Call glue layer to find first mech we support */\n\tfor (j = 1; j < ni->mechTypes.len; ++j) {\n\t    ret = select_mech(minor_status,\n\t\t\t      &ni->mechTypes.val[j],\n\t\t\t      1,\n\t\t\t      &preferred_mech_type);\n\t    if (ret == 0)\n\t\tbreak;\n\t}\n\tif (preferred_mech_type == GSS_C_NO_OID) {\n\t    HEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\t    free_NegotiationToken(&nt);\n\t    return ret;\n\t}\n\n\tctx->preferred_mech_type = preferred_mech_type;\n    }\n\n    /*\n     * The initial token always have a response\n     */\n\n    ret = send_accept (minor_status,\n\t\t       ctx,\n\t\t       &mech_output_token,\n\t\t       1,\n\t\t       get_mic ? &mech_buf : NULL,\n\t\t       output_token);\n    if (ret)\n\tgoto out;\n\nout:\n    if (mech_output_token.value != NULL)\n\tgss_release_buffer(&junk, &mech_output_token);\n    if (mech_buf.value != NULL) {\n\tfree(mech_buf.value);\n\tmech_buf.value = NULL;\n    }\n    free_NegotiationToken(&nt);\n\n\n    if (ret == GSS_S_COMPLETE) {\n\tif (src_name != NULL && ctx->mech_src_name != NULL) {\n\t    spnego_name name;\n\n\t    name = calloc(1, sizeof(*name));\n\t    if (name) {\n\t\tname->mech = ctx->mech_src_name;\n\t\tctx->mech_src_name = NULL;\n\t\t*src_name = (gss_name_t)name;\n\t    }\n\t}\n    }\n\n    if (mech_type != NULL)\n\t*mech_type = ctx->negotiated_mech_type;\n    if (ret_flags != NULL)\n\t*ret_flags = ctx->mech_flags;\n    if (time_rec != NULL)\n\t*time_rec = ctx->mech_time_rec;\n\n    if (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n \treturn ret;\n    }\n\n    _gss_spnego_internal_delete_sec_context(&junk, context_handle,\n\t\t\t\t\t    GSS_C_NO_BUFFER);\n\n    return ret;\n}"", ""target"": 0}]","[{""func_name"": ""GSSAPI_CALLCONV"", ""file_path"": ""lib/gssapi/spnego/accept_sec_context.c"", ""func_code"": ""static OM_uint32 GSSAPI_CALLCONV\nacceptor_start\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, junk;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenInit *ni;\n    gss_buffer_desc data;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_output_token;\n    gss_buffer_desc mech_buf;\n    gss_OID preferred_mech_type = GSS_C_NO_OID;\n    gssspnego_ctx ctx;\n    int get_mic = 0;\n    int first_ok = 0;\n\n    mech_output_token.value = NULL;\n    mech_output_token.length = 0;\n    mech_buf.value = NULL;\n\n    if (input_token_buffer->length == 0)\n\treturn send_supported_mechs (minor_status, output_token);\n\n    ret = _gss_spnego_alloc_sec_context(minor_status, context_handle);\n    if (ret != GSS_S_COMPLETE)\n\treturn ret;\n\n    ctx = (gssspnego_ctx)*context_handle;\n\n    /*\n     * The GSS-API encapsulation is only present on the initial\n     * context token (negTokenInit).\n     */\n    ret = gss_decapsulate_token (input_token_buffer,\n\t\t\t\t GSS_SPNEGO_MECHANISM,\n\t\t\t\t &data);\n    if (ret)\n\treturn ret;\n\n    ret = decode_NegotiationToken(data.value, data.length, &nt, &nt_len);\n    gss_release_buffer(minor_status, &data);\n    if (ret) {\n\t*minor_status = ret;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    if (nt.element != choice_NegotiationToken_negTokenInit) {\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n    ni = &nt.u.negTokenInit;\n\n    if (ni->mechTypes.len < 1) {\n\tfree_NegotiationToken(&nt);\n\t*minor_status = 0;\n\treturn GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    HEIMDAL_MUTEX_lock(&ctx->ctx_id_mutex);\n\n    ret = copy_MechTypeList(&ni->mechTypes, &ctx->initiator_mech_types);\n    if (ret) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n\tfree_NegotiationToken(&nt);\n\t*minor_status = ret;\n\treturn GSS_S_FAILURE;\n    }\n\n    /*\n     * First we try the opportunistic token if we have support for it,\n     * don't try to verify we have credential for the token,\n     * gss_accept_sec_context() will (hopefully) tell us that.\n     * If that failes,\n     */\n\n    ret = select_mech(minor_status,\n\t\t      &ni->mechTypes.val[0],\n\t\t      0,\n\t\t      &preferred_mech_type);\n\n    if (ret == 0 && ni->mechToken != NULL) {\n\tgss_buffer_desc ibuf;\n\n\tibuf.length = ni->mechToken->length;\n\tibuf.value = ni->mechToken->data;\n\tmech_input_token = &ibuf;\n\n\tif (ctx->mech_src_name != GSS_C_NO_NAME)\n\t    gss_release_name(&junk, &ctx->mech_src_name);\n\n\tret = gss_accept_sec_context(minor_status,\n\t\t\t\t     &ctx->negotiated_ctx_id,\n\t\t\t\t     acceptor_cred_handle,\n\t\t\t\t     mech_input_token,\n\t\t\t\t     input_chan_bindings,\n\t\t\t\t     &ctx->mech_src_name,\n\t\t\t\t     &ctx->negotiated_mech_type,\n\t\t\t\t     &mech_output_token,\n\t\t\t\t     &ctx->mech_flags,\n\t\t\t\t     &ctx->mech_time_rec,\n\t\t\t\t     delegated_cred_handle);\n\n\tif (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\t    ctx->preferred_mech_type = preferred_mech_type;\n\t    if (ret == GSS_S_COMPLETE)\n\t\tctx->open = 1;\n\n\t    ret = acceptor_complete(minor_status,\n\t\t\t\t    ctx,\n\t\t\t\t    &get_mic,\n\t\t\t\t    &mech_buf,\n\t\t\t\t    mech_input_token,\n\t\t\t\t    &mech_output_token,\n\t\t\t\t    ni->mechListMIC,\n\t\t\t\t    output_token);\n\t    if (ret != GSS_S_COMPLETE)\n\t\tgoto out;\n\n\t    first_ok = 1;\n\t} else {\n\t    gss_mg_collect_error(preferred_mech_type, ret, *minor_status);\n\t}\n    }\n\n    /*\n     * If opportunistic token failed, lets try the other mechs.\n     */\n\n    if (!first_ok && ni->mechToken != NULL) {\n\tsize_t j;\n\n\tpreferred_mech_type = GSS_C_NO_OID;\n\n\t/* Call glue layer to find first mech we support */\n\tfor (j = 1; j < ni->mechTypes.len; ++j) {\n\t    ret = select_mech(minor_status,\n\t\t\t      &ni->mechTypes.val[j],\n\t\t\t      1,\n\t\t\t      &preferred_mech_type);\n\t    if (ret == 0)\n\t\tbreak;\n\t}\n    }\n\n    ctx->preferred_mech_type = preferred_mech_type;\n\n    if (preferred_mech_type == GSS_C_NO_OID) {\n        send_reject(minor_status, output_token);\n        HEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n        free_NegotiationToken(&nt);\n        return ret;\n    }\n\n    /*\n     * The initial token always have a response\n     */\n\n    ret = send_accept (minor_status,\n\t\t       ctx,\n\t\t       &mech_output_token,\n\t\t       1,\n\t\t       get_mic ? &mech_buf : NULL,\n\t\t       output_token);\n    if (ret)\n\tgoto out;\n\nout:\n    if (mech_output_token.value != NULL)\n\tgss_release_buffer(&junk, &mech_output_token);\n    if (mech_buf.value != NULL) {\n\tfree(mech_buf.value);\n\tmech_buf.value = NULL;\n    }\n    free_NegotiationToken(&nt);\n\n\n    if (ret == GSS_S_COMPLETE) {\n\tif (src_name != NULL && ctx->mech_src_name != NULL) {\n\t    spnego_name name;\n\n\t    name = calloc(1, sizeof(*name));\n\t    if (name) {\n\t\tname->mech = ctx->mech_src_name;\n\t\tctx->mech_src_name = NULL;\n\t\t*src_name = (gss_name_t)name;\n\t    }\n\t}\n    }\n\n    if (mech_type != NULL)\n\t*mech_type = ctx->negotiated_mech_type;\n    if (ret_flags != NULL)\n\t*ret_flags = ctx->mech_flags;\n    if (time_rec != NULL)\n\t*time_rec = ctx->mech_time_rec;\n\n    if (ret == GSS_S_COMPLETE || ret == GSS_S_CONTINUE_NEEDED) {\n\tHEIMDAL_MUTEX_unlock(&ctx->ctx_id_mutex);\n \treturn ret;\n    }\n\n    _gss_spnego_internal_delete_sec_context(&junk, context_handle,\n\t\t\t\t\t    GSS_C_NO_BUFFER);\n\n    return ret;\n}""}]","{""code"": 1, ""function"": 1, ""caller"": 1}","[{""source"": ""code_info(file:accept_sec_context.c, lines:145-150)"", ""result"": ""\treturn ret;\n\n    *minor_status = 0;\n\n    return GSS_S_CONTINUE_NEEDED;\n}\n\n""}, {""source"": ""func_info(func:send_accept)"", ""result"": [{""code"": ""static OM_uint32\nsend_accept (OM_uint32 *minor_status,\n\t     gssspnego_ctx context_handle,\n\t     gss_buffer_t mech_token,\n\t     int initial_response,\n\t     gss_buffer_t mech_buf,\n\t     gss_buffer_t ou"", ""start_line"": 152, ""end_line"": 272, ""full_name"": ""send_accept"", ""file_path"": ""lib/gssapi/spnego/accept_sec_context.c""}]}, {""source"": ""caller_info(file:accept_sec_context.c, func:send_accept)"", ""result"": [{""call_line"": 635, ""call_code"": ""send_accept (minor_status,\n\t\t       ctx,\n\t\t       &mech_output_token,\n\t\t       1,\n\t\t       get_mic ? &mech_buf : NULL,\n\t\t       output_token)"", ""caller_code"": ""acceptor_start\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, junk;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenInit *ni;\n    gss_buffer_desc data;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_output_token;\n    gss_buffer_desc mech_buf;\n    gss_OID preferred_mech_type = GSS_C_NO_OID;\n    gssspnego_ctx ctx;\n    int get_mic = 0;\n    int first_ok = 0;\n\n    mech_output_token.value = NULL;\n    mech_output_token.length = 0;\n    mech_buf.value = NULL;\n\n    if (input_token_buffer->length == 0)\n\treturn send_supported_mechs (minor_status, output_token);\n\n    ret = _gss_spnego_all..."", ""caller_start"": 470, ""file_path"": ""lib/gssapi/spnego/accept_sec_context.c""}, {""call_line"": 822, ""call_code"": ""send_accept (minor_status,\n\t\t\t\tctx,\n\t\t\t\tmech_output_token,\n\t\t\t\t0,\n\t\t\t\tget_mic ? &mech_buf : NULL,\n\t\t\t\toutput_token)"", ""caller_code"": ""acceptor_continue\n\t   (OM_uint32 * minor_status,\n\t    gss_ctx_id_t * context_handle,\n\t    gss_const_cred_id_t acceptor_cred_handle,\n\t    const gss_buffer_t input_token_buffer,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    gss_name_t * src_name,\n\t    gss_OID * mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags,\n\t    OM_uint32 * time_rec,\n\t    gss_cred_id_t *delegated_cred_handle\n\t   )\n{\n    OM_uint32 ret, ret2, minor;\n    NegotiationToken nt;\n    size_t nt_len;\n    NegTokenResp *na;\n    unsigned int negResult = accept_incomplete;\n    gss_buffer_t mech_input_token = GSS_C_NO_BUFFER;\n    gss_buffer_t mech_output_token = GSS_C_NO_BUFFER;\n    gss_buffer_desc mech_buf;\n    gssspnego_ctx ctx;\n\n    mech_buf.value = NULL;\n\n    ctx = (gssspnego_ctx)*context_handle;\n\n    /*\n     * The GSS-API encapsulation is only present on the initial\n     * context token (negTokenInit).\n     */\n\n    ret = decode_NegotiationToken(input_token_buffer->value,\n\t\t\t\t  input_token_b..."", ""caller_start"": 687, ""file_path"": ""lib/gssapi/spnego/accept_sec_context.c""}]}]","The vulnerability is triggered by an initial SPNEGO token with no acceptable mechanisms. In `acceptor_start` (lib/gssapi/spnego/accept_sec_context.c:470), `preferred_mech_type` is initialized to `GSS_C_NO_OID` and remains unset if no valid mechanism is found. This value is assigned to `ctx->preferred_mech_type` (lib/gssapi/spnego/accept_sec_context.c:151-163). The `send_accept` call from `acceptor_start` (lib/gssapi/spnego/accept_sec_context.c:635) sets `initial_response=1`. The patch introduces a check after assignment to call `send_reject()` if `preferred_mech_type` is `GSS_C_NO_OID`, preventing the NULL dereference in `send_accept`.",1.0,./github/other_context/CVE-2021-44758
42,CVE-2022-1283,CWE-476,c_cpp,NULL Pointer Dereference in r_bin_ne_get_entrypoints function in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability allows attackers to cause a denial of service (application crash).,https://github.com/radareorg/radare2/commit/18d1d064bf599a255d55f09fca3104776fc34a67,Fix null deref in the ne parser ##crash\n\n* Reported by @hmsec via huntr.dev\n* Reproducer: nepoc00\n* BountyID: bfeb8fb8-644d-4587-80d4-cb704c404013,2,"[{""func_name"": ""r_bin_ne_get_entrypoints"", ""file_path"": ""libr/bin/format/ne/ne.c"", ""func_code"": ""RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tut32 entry_cs = bin->ne_header->csEntryPoint;\n\t\tRBinSection *s = r_list_get_n (segments, entry_cs - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\tsize_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tif (tableat + off >= r_buf_size (bin->buf)) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tif (tableat + off + 4 >= r_buf_size (bin->buf)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { // Skip\n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xff) { // moveable\n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);\n\t\t\t\tif (segnum > 0) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t\t}\n\t\t\t} else { // Fixed\n\t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n\t\t\t\t\t\t* bin->alignment + *(ut16 *)(bin->entry_table + off);\n\t\t\t\t}\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}"", ""target"": 0}, {""func_name"": ""r_bin_ne_get_symbols"", ""file_path"": ""libr/bin/format/ne/ne.c"", ""func_code"": ""RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (true) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\""entry%d\"", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}"", ""target"": 0}]","[{""func_name"": ""r_bin_ne_get_entrypoints"", ""file_path"": ""libr/bin/format/ne/ne.c"", ""func_code"": ""RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tif (!bin->entry_table) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tut32 entry_cs = bin->ne_header->csEntryPoint;\n\t\tRBinSection *s = r_list_get_n (segments, entry_cs - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\tsize_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tif (tableat + off >= r_buf_size (bin->buf)) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tif (tableat + off + 4 >= r_buf_size (bin->buf)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { // Skip\n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xff) { // moveable\n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);\n\t\t\t\tif (segnum > 0) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t\t}\n\t\t\t} else { // Fixed\n\t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n\t\t\t\t\t\t* bin->alignment + *(ut16 *)(bin->entry_table + off);\n\t\t\t\t}\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}""}, {""func_name"": ""r_bin_ne_get_symbols"", ""file_path"": ""libr/bin/format/ne/ne.c"", ""func_code"": ""RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (entries) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\""entry%d\"", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}""}]","{""code"": 1, ""query"": 1, ""value"": 1}","[{""source"": ""code_info(file:ne.c, lines:1-1000)"", ""result"": ""/* radare - LGPL - Copyright 2019-2022 - GustavoLCR */\n\n#include \""ne.h\""\n#define NE_BUG 0\n\nstatic char *__get_target_os(r_bin_ne_obj_t *bin) {\n\tswitch (bin->ne_header->targOS) {\n\tcase 1:\n\t\treturn \""OS/2\"";\n\tcase 2:\n\t\treturn \""Windows\"";\n\tcase 3:\n\t\treturn \""European MS-DOS 4.x\"";\n\tcase 4:\n\t\treturn \""Windows 386\"";\n\tcase 5:\n\t\treturn \""BOSS (Borland Operating System Services)\"";\n\tdefault:\n\t\treturn \""Unknown\"";\n\t}\n}\n\nstatic int __translate_perms(int flags) {\n\tint perms = 0;\n\tif (flags & IS_RX) {\n\t\tif (flags & IS_DATA) {\n\t\t\tperms = R_PERM_R;\n\t\t} else {\n\t\t\tperms = R_PERM_X;\n\t\t}\n\t}\n\tif (!perms) {\n\t\tperms = R_PERM_RWX;\n\t}\n\treturn perms;\n}\n\nstatic char *__read_nonnull_str_at(RBuffer *buf, ut64 offset) {\n\tut8 sz = r_buf_read8_at (buf, offset);\n\tif (!sz) {\n\t\treturn NULL;\n\t}\n\tchar *str = malloc ((ut64)sz + 1);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (buf, offset + 1, (ut8 *)str, sz);\n\tstr[sz] = '\\0';\n\treturn str;\n}\n\nstatic char *__func_name_from_ord(const char *module, ut16 ordinal) {\n\tif (!module) {\n\t\treturn NULL;\n\t}\n\tchar *lower_module = strdup (module);\n\tr_str_case (lower_module, false);\n\tchar *path = r_str_newf (R_JOIN_4_PATHS (\""%s\"", R2_SDB_FORMAT, \""dll\"", \""%s.sdb\""), r_sys_prefix (NULL), lower_module);\n\tfree (lower_module);\n\tchar *ord = r_str_newf (\""%d\"", ordinal);\n\tchar *name;\n\tif (r_file_exists (path)) {\n\t\tSdb *sdb = sdb_new (NULL, path, 0);\n\t\tname = sdb_get (sdb, ord, NULL);\n\t\tif (!name) {\n\t\t\tname = ord;\n\t\t} else {\n\t\t\tfree (ord);\n\t\t}\n\t\tsdb_close (sdb);\n\t\tfree (sdb);\n\t} else {\n\t\tname = ord;\n\t}\n\tfree (path);\n\treturn name;\n}\n\nRList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\""%s.%\"" PFMT64d, se->flags & IS_MOVEABLE ? \""MOVEABLE\"" : \""FIXED\"", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}\n\nstatic int __find_symbol_by_paddr(const void *paddr, const void *sym) {\n\treturn (int)!(*(ut64 *)paddr == ((RBinSymbol *)sym)->paddr);\n}\n\nRList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {\n\tRBinSymbol *sym;\n\tut16 off = bin->ne_header->ResidNamTable + bin->header_offset;\n\tRList *symbols = r_list_newf (free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_bin_ne_get_entrypoints (bin);\n\tbool resident = true, first = true;\n\twhile (true) {\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tfirst = true;\n\t\t\tif (resident) {\n\t\t\t\tresident = false;\n\t\t\t\toff = bin->ne_header->OffStartNonResTab;\n\t\t\t\tsz = r_buf_read8_at (bin->buf, off);\n\t\t\t\tif (!sz) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\toff += sz;\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = name;\n\t\tif (!first) {\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tut16 entry_off = r_buf_read_le16_at (bin->buf, off);\n\t\toff += 2;\n\t\tRBinAddr *entry = r_list_get_n (entries, entry_off);\n\t\tif (entry) {\n\t\t\tsym->paddr = entry->paddr;\n\t\t} else {\n\t\t\tsym->paddr = -1;\n\t\t}\n\t\tsym->ordinal = entry_off;\n\t\tr_list_append (symbols, sym);\n\t\tfirst = false;\n\t}\n\tRListIter *it;\n\tRBinAddr *en;\n\tint i = 1;\n\tr_list_foreach (entries, it, en) {\n\t\tif (!r_list_find (symbols, &en->paddr, __find_symbol_by_paddr)) {\n\t\t\tsym = R_NEW0 (RBinSymbol);\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsym->name = r_str_newf (\""entry%d\"", i - 1);\n\t\t\tsym->paddr = en->paddr;\n\t\t\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t\tsym->ordinal = i;\n\t\t\tr_list_append (symbols, sym);\n\t\t}\n\t\ti++;\n\t}\n\tbin->symbols = symbols;\n\treturn symbols;\n}\n\nstatic char *__resource_type_str(int type) {\n\tchar *typeName;\n\tswitch (type) {\n\tcase 1:\n\t\ttypeName = \""CURSOR\"";\n\t\tbreak;\n\tcase 2:\n\t\ttypeName = \""BITMAP\"";\n\t\tbreak;\n\tcase 3:\n\t\ttypeName = \""ICON\"";\n\t\tbreak;\n\tcase 4:\n\t\ttypeName = \""MENU\"";\n\t\tbreak;\n\tcase 5:\n\t\ttypeName = \""DIALOG\"";\n\t\tbreak;\n\tcase 6:\n\t\ttypeName = \""STRING\"";\n\t\tbreak;\n\tcase 7:\n\t\ttypeName = \""FONTDIR\"";\n\t\tbreak;\n\tcase 8:\n\t\ttypeName = \""FONT\"";\n\t\tbreak;\n\tcase 9:\n\t\ttypeName = \""ACCELERATOR\"";\n\t\tbreak;\n\tcase 10:\n\t\ttypeName = \""RCDATA\"";\n\t\tbreak;\n\tcase 11:\n\t\ttypeName = \""MESSAGETABLE\"";\n\t\tbreak;\n\tcase 12:\n\t\ttypeName = \""GROUP_CURSOR\"";\n\t\tbreak;\n\tcase 14:\n\t\ttypeName = \""GROUP_ICON\"";\n\t\tbreak;\n\tcase 15:\n\t\ttypeName = \""NAMETABLE\"";\n\t\tbreak;\n\tcase 16:\n\t\ttypeName = \""VERSION\"";\n\t\tbreak;\n\tcase 17:\n\t\ttypeName = \""DLGINCLUDE\"";\n\t\tbreak;\n\tcase 19:\n\t\ttypeName = \""PLUGPLAY\"";\n\t\tbreak;\n\tcase 20:\n\t\ttypeName = \""VXD\"";\n\t\tbreak;\n\tcase 21:\n\t\ttypeName = \""ANICURSOR\"";\n\t\tbreak;\n\tcase 22:\n\t\ttypeName = \""ANIICON\"";\n\t\tbreak;\n\tcase 23:\n\t\ttypeName = \""HTML\"";\n\t\tbreak;\n\tcase 24:\n\t\ttypeName = \""MANIFEST\"";\n\t\tbreak;\n\tdefault:\n\t\treturn r_str_newf (\""UNKNOWN (%d)\"", type);\n\t}\n\treturn strdup (typeName);\n}\n\nstatic void __free_resource_entry(void *entry) {\n\tr_ne_resource_entry *en = (r_ne_resource_entry *)entry;\n\tfree (en->name);\n\tfree (en);\n}\n\nstatic void __free_resource(void *resource) {\n\tr_ne_resource *res = (r_ne_resource *)resource;\n\tfree (res->name);\n\tr_list_free (res->entry);\n\tfree (res);\n}\n\nstatic bool __ne_get_resources(r_bin_ne_obj_t *bin) {\n\tif (!bin->resources) {\n\t\tbin->resources = r_list_newf (__free_resource);\n\t}\n\tut16 resoff = bin->ne_header->ResTableOffset + bin->header_offset;\n\tut16 alignment = r_buf_read_le16_at (bin->buf, resoff);\n\tut32 off = resoff + 2;\n\twhile (true) {\n\t\tNE_image_typeinfo_entry ti = {0};\n\t\tr_ne_resource *res = R_NEW0 (r_ne_resource);\n\t\tif (!res) {\n\t\t\tbreak;\n\t\t}\n\t\tres->entry = r_list_newf (__free_resource_entry);\n\t\tif (!res->entry) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)&ti, sizeof (ti));\n\t\tif (!ti.rtTypeID) {\n\t\t\tbreak;\n\t\t} else if (ti.rtTypeID & 0x8000) {\n\t\t\tres->name = __resource_type_str (ti.rtTypeID & ~0x8000);\n\t\t} else {\n\t\t\t// Offset to resident name table\n\t\t\tres->name = __read_nonnull_str_at (bin->buf, (ut64)resoff + ti.rtTypeID);\n\t\t}\n\t\toff += sizeof (NE_image_typeinfo_entry);\n\t\tint i;\n\t\tfor (i = 0; i < ti.rtResourceCount; i++) {\n\t\t\tNE_image_nameinfo_entry ni;\n\t\t\tr_ne_resource_entry *ren = R_NEW0 (r_ne_resource_entry);\n\t\t\tif (!ren) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->buf, off, (ut8 *)&ni, sizeof (NE_image_nameinfo_entry));\n\t\t\tren->offset = ni.rnOffset << alignment;\n\t\t\tren->size = ni.rnLength;\n\t\t\tif (ni.rnID & 0x8000) {\n\t\t\t\tren->name = r_str_newf (\""%d\"", ni.rnID & ~0x8000);\n\t\t\t} else {\n\t\t\t\t// Offset to resident name table\n\t\t\t\tren->name = __read_nonnull_str_at (bin->buf, (ut64)resoff + ni.rnID);\n\t\t\t}\n\t\t\tr_list_append (res->entry, ren);\n\t\t\toff += sizeof (NE_image_nameinfo_entry);\n\t\t}\n\t\tr_list_append (bin->resources, res);\n\t}\n\treturn true;\n}\n\nRList *r_bin_ne_get_imports(r_bin_ne_obj_t *bin) {\n\tRList *imports = r_list_newf ((RListFree)r_bin_import_free);\n\tif (!imports) {\n\t\treturn NULL;\n\t}\n\tut16 off = bin->ne_header->ImportNameTable + bin->header_offset + 1;\n\tint i;\n\tfor (i = 0; i < bin->ne_header->ModRefs; i++) {\n\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\tif (!imp) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 sz = r_buf_read8_at (bin->buf, off);\n\t\tif (!sz) {\n\t\t\tr_bin_import_free (imp);\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tchar *name = malloc ((ut64)sz + 1);\n\t\tif (!name) {\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_read_at (bin->buf, off, (ut8 *)name, sz);\n\t\tname[sz] = '\\0';\n\t\timp->name = name;\n\t\timp->ordinal = i + 1;\n\t\tr_list_append (imports, imp);\n\t\toff += sz;\n\t}\n\tbin->imports = imports;\n\treturn imports;\n}\n\nRList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tut32 entry_cs = bin->ne_header->csEntryPoint;\n\t\tRBinSection *s = r_list_get_n (segments, entry_cs - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\tsize_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tif (tableat + off >= r_buf_size (bin->buf)) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tif (tableat + off + 4 >= r_buf_size (bin->buf)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { // Skip\n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xff) { // moveable\n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);\n\t\t\t\tif (segnum > 0) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t\t}\n\t\t\t} else { // Fixed\n\t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n\t\t\t\t\t\t* bin->alignment + *(ut16 *)(bin->entry_table + off);\n\t\t\t\t}\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}\n\nRList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off = seg->paddr + seg->size;\n\t\tut32 start = off;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\t// size_t buf_size = r_buf_size (bin->buf);\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n\t\t\t// && off + sizeof (NE_image_reloc_item) < buf_size)\n\t\t\tNE_image_reloc_item rel = {0};\n\t\t\tif (r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)) < 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name;\n#if NE_BUG\n\t\t\t\tif (rel.index > 0 && rel.index < bin->ne_header->ModRefs) {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t} else {\n\t\t\t\t\tname = r_str_newf (\""UnknownModule%d_%x\"", rel.index, off); // ????\n\t\t\t\t}\n#else\n\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\""UnknownModule%d_%x\"", rel.index, off); // ????\n\t\t\t\t} else {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n#endif\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\timp->name = r_str_newf (\""%s.%s\"", name, __func_name_from_ord(name, rel.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\""%s.%s\"", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \""FIXED\"")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n#if NE_BUG\n\t\t\t\t\tif (reloc->paddr + 4 < r_buf_size (bin->buf)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}\n\nvoid __init(RBuffer *buf, r_bin_ne_obj_t *bin) {\n\tbin->header_offset = r_buf_read_le16_at (buf, 0x3c);\n\tbin->ne_header = R_NEW0 (NE_image_header);\n\tif (!bin->ne_header) {\n\t\treturn;\n\t}\n\tbin->buf = buf;\n\t// XXX this is endian unsafe\n\tif (r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header)) < 1) {\n\t\tR_FREE (bin->ne_header);\n\t\treturn;\n\t}\n\tif (bin->ne_header->FileAlnSzShftCnt > 15) {\n\t\tbin->ne_header->FileAlnSzShftCnt = 15;\n\t}\n\tut64 from = bin->ne_header->ModRefTable + bin->header_offset;\n\tut64 left = r_buf_size (bin->buf) - from;\n\tif (from + bin->ne_header->ModRefs * sizeof (ut16) >= left) {\n\t\tbin->ne_header->ModRefs = left / sizeof (ut16);\n\t}\n\tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\tif (!bin->alignment) {\n\t\tbin->alignment = 1 << 9;\n\t}\n\tbin->os = __get_target_os (bin);\n\n\tut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;\n\tsize_t size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\tif (offset >= r_buf_size (bin->buf)) {\n\t\treturn;\n\t}\n\tsize_t remaining = r_buf_size (bin->buf) - offset;\n\tsize = R_MIN (remaining, size);\n\tbin->ne_header->SegCount = size / sizeof (NE_image_segment_entry); // * sizeof (NE_image_segment_entry);\n\tbin->segment_entries = calloc (1, size);\n\tif (size >= remaining) {\n\t\tbin->ne_header->SegCount = size / sizeof (NE_image_segment_entry);\n\t}\n\tif (!bin->segment_entries) {\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);\n\tbin->entry_table = calloc (4, bin->ne_header->EntryTableLength);\n\tif (!bin->entry_table) {\n\t\tR_FREE (bin->segment_entries);\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);\n\tbin->imports = r_bin_ne_get_imports (bin);\n\t__ne_get_resources (bin);\n}\n\nvoid r_bin_ne_free(r_bin_ne_obj_t *bin) {\n\t// r_list_free (bin->imports); // double free\n\tr_list_free (bin->resources);\n\tfree (bin->entry_table);\n\tfree (bin->ne_header);\n\tfree (bin->resident_name_table);\n\tfree (bin->segment_entries);\n\tfree (bin);\n}\n\nr_bin_ne_obj_t *r_bin_ne_new_buf(RBuffer *buf, bool verbose) {\n\tr_bin_ne_obj_t *bin = R_NEW0 (r_bin_ne_obj_t);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\t__init(buf, bin);\n\treturn bin;\n}\n""}, {""source"": ""query_info(query:cpg.method.where(_.ast.isCall.code(\""bin->entry_tab...)"", ""result"": [""<global>"", ""r_bin_ne_get_entrypoints"", ""__init"", ""r_bin_ne_free""]}, {""source"": ""value_info(file:ne.c, value:bin->entry_table)"", ""result"": {""value_trace"": [{""full_code"": ""bin->entry_table = calloc (4, bin->ne_header->EntryTableLength)"", ""line"": 633, ""func_name"": ""__init""}], ""struct_var"": ""bin"", ""struct_type"": null, ""struct_definition"": null}}]","1. calloc for bin->entry_table in __init (libr/bin/format/ne/ne.c:633) may return NULL on failure. 2. __init returns without setting bin->entry_table to a valid pointer, leaving it as NULL. 3. The bin object is returned by r_bin_ne_new_buf even with NULL bin->entry_table. 4. r_bin_ne_get_entrypoints (libr/bin/format/ne/ne.c:355) dereferences bin->entry_table without a null check (pre-patch), causing a NULL dereference. 5. The patch adds a null check to return early, preventing the crash.",1.0,./github/other_context/CVE-2022-1283
43,CVE-2022-1620,CWE-476,c_cpp,NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729 in GitHub repository vim/vim prior to 8.2.4901. NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729 allows attackers to cause a denial of service (application crash) via a crafted input.,https://github.com/vim/vim/commit/8e4b76da1d7e987d43ca960dfbc372d1c617466f,patch 8.2.4901: NULL pointer access when using invalid pattern\n\nProblem:    NULL pointer access when using invalid pattern.\nSolution:   Check for failed regexp program.,1,"[{""func_name"": ""fname_match"", ""file_path"": ""src/buffer.c"", ""func_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""target"": 0}]","[{""func_name"": ""fname_match"", ""file_path"": ""src/buffer.c"", ""func_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}""}]","{""function"": 2, ""value"": 2, ""code"": 2, ""caller"": 6}","[{""source"": ""func_info(func:vim_regexec)"", ""result"": [{""code"": ""int\nvim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, FALSE);\n}"", ""start_line"": 2813, ""end_line"": 2817, ""full_name"": ""vim_regexec"", ""file_path"": ""src/regexp.c""}]}, {""source"": ""value_info(value:rmp)"", ""result"": {""value_trace"": [{""full_code"": ""rmp->rm_ic = p_fic || ignore_case"", ""line"": 2957, ""func_name"": ""fname_match""}, {""full_code"": ""rmp->rm_ic = TRUE"", ""line"": 2643, ""func_name"": ""ExpandOther""}, {""full_code"": ""want_settermprop = sense"", ""line"": 669, ""func_name"": ""main<duplicate>10""}, {""full_code"": ""want_settermprop = 1"", ""line"": 710, ""func_name"": ""main<duplicate>10""}, {""full_code"": ""want_settermprop = 0"", ""line"": 334, ""func_name"": ""src/libvterm/t/harness.c:<global>""}], ""struct_var"": ""rmp"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:regexp.c, lines:2724-2734)"", ""result"": ""    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n""}, {""source"": ""func_info(func:vim_regcomp)"", ""result"": [{""code"": ""    regprog_T *\nvim_regcomp(char_u *expr_arg, int re_flags)\n{\n    regprog_T   *prog = NULL;\n    char_u\t*expr = expr_arg;\n    int\t\tcalled_emsg_before;\n\n    regexp_engine = p_re;\n\n    // Check for prefix \""\\%#=\"", that sets the regexp engine\n    if (STRNCMP(expr, \""\\\\%#=\"", 4) == 0)\n    {\n\tint newengine = expr[4] - '0';\n\n\tif (newengine == AUTOMATIC_ENGINE\n\t    || newengine == BACKTRACKING_ENGINE\n\t    || newengine == NFA_ENGINE)\n\t{\n\t    regexp_engine = expr[4] - '0';\n\t    expr += 5;\n#ifdef DEBUG\n\t    smsg(\""New regexp mode selected (%d): %s\"",\n\t\t\t\t\t   regexp_engine, regname[newengine]);\n#endif\n\t}\n\telse\n\t{\n\t    emsg(_(e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used));\n\t    regexp_engine = AUTOMATIC_ENGINE;\n\t}\n    }\n#ifdef DEBUG\n    bt_regengine.expr = expr;\n    nfa_regengine.expr = expr;\n#endif\n    // reg_iswordc() uses rex.reg_buf\n    rex.reg_buf = curbuf;\n\n    /*\n     * First try the NFA engine, unless backtracking was requested.\n     */\n    called_emsg_before = called_emsg;\n    if (regexp_engine != BACKTRACKING_ENGINE)\n\tprog = nfa_regengine.regcomp(expr,\n\t\tre_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n    else\n\tprog = bt_regengine.regcomp(expr, re_flags);\n\n    // Check for error compiling regexp with initial engine.\n    if (prog == NULL)\n    {\n#ifdef BT_REGEXP_DEBUG_LOG\n\tif (regexp_engine == BACKTRACKING_ENGINE)   // debugging log for BT engine\n\t{\n\t    FILE *f;\n\t    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \""a\"");\n\t    if (f)\n\t    {\n\t\tfprintf(f, \""Syntax error in \\\""%s\\\""\\n\"", expr);\n\t\tfclose(f);\n\t    }\n\t    else\n\t\tsemsg(\""(NFA) Could not open \\\""%s\\\"" to write !!!\"",\n\t\t\tBT_REGEXP_DEBUG_LOG_NAME);\n\t}\n#endif\n\t/*\n\t * If the NFA engine failed, try the backtracking engine.\n\t * The NFA engine also fails for patterns that it can't handle well\n\t * but are still valid patterns, thus a retry should work.\n\t * But don't try if an error message was given.\n\t */\n\tif (regexp_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t{\n\t    regexp_engine = BACKTRACKING_ENGINE;\n#ifdef FEAT_EVAL\n\t    report_re_switch(expr);\n#endif\n\t    prog = bt_regengine.regcomp(expr, re_flags);\n\t}\n    }\n\n    if (prog != NULL)\n    {\n\t// Store the info needed to call regcomp() again when the engine turns\n\t// out to be very slow when executing it.\n\tprog->re_engine = regexp_engine;\n\tprog->re_flags  = re_flags;\n    }\n\n    return prog;\n}\n"", ""start_line"": 2572, ""end_line"": 2664, ""full_name"": ""vim_regcomp"", ""file_path"": ""src/regexp.c""}]}, {""source"": ""value_info(value:regmatch_T)"", ""result"": {""value_trace"": [{""full_code"": ""typedef struct { regprog_T *regprog; char_u *startp[NSUBEXP]; char_u *endp[NSUBEXP]; int rm_ic; } regmatch_T"", ""line"": 137, ""func_name"": null}], ""struct_var"": ""regmatch_T"", ""struct_type"": ""struct"", ""struct_definition"": ""struct""}}, {""source"": ""caller_info(func:vim_regexec)"", ""result"": [{""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2964, ""call_code"": ""vim_regexec(rmp, p, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}]}, {""source"": ""caller_info(file:cmdexpand.c, func:vim_regexec)"", ""result"": [{""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}, {""call_line"": 3226, ""call_code"": ""vim_regexec(regmatch, s, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandUserDefined(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches)\n{\n    char_u\t*retstr;\n    char_u\t*s;\n    char_u\t*e;\n    int\t\tkeep;\n    garray_T\tga;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tscore = 0;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    retstr = call_user_expand_func(call_func_retstr, xp);\n    if (retstr == NULL)\n\treturn FAIL;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 3);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 3);\n\n    for (s = retstr; *s != NUL; s = e)\n    {\n\te = vim_strchr(s, '\\n');\n\tif (e == NULL)\n\t    e = s + STRLEN(s);\n\tkeep = *e;\n\t*e = NUL;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, s, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(s, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\t\t// match everything\n\n\t*e = keep;\n\n\tif (match)\n\t{\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    if (!fuzzy)\n\t\t((char_u **)ga.ga_data)[ga.ga_len] = vim_strnsave(s, e - s);\n\t    else\n\t    {\n\t\tfuzmatch_str_T  *fuzmatch =\n\t\t\t\t&((fuzmatch_str_T  *)ga.ga_data)[ga.ga_len];\n\t\tfuzmatch->idx = ga.ga_len;\n\t\tfuzmatch->str = vim_strnsave(s, e - s);\n\t\tfuzmatch->score = score;\n\t    }\n\t    ++ga.ga_len;\n\t}\n\n\tif (*e != NUL)\n\t    ++e;\n    }\n    vim_free(retstr);\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\t\tFALSE) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n    return OK;\n}\n"", ""caller_start"": 3185, ""file_path"": ""src/cmdexpand.c""}, {""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}]}, {""source"": ""caller_info(func:vim_regexec)"", ""result"": [{""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2964, ""call_code"": ""vim_regexec(rmp, p, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}]}, {""source"": ""code_info(file:regexp.c, lines:2724-2734)"", ""result"": ""    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n""}, {""source"": ""caller_info(func:vim_regexec)"", ""result"": [{""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2964, ""call_code"": ""vim_regexec(rmp, p, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}]}, {""source"": ""caller_info(func:vim_regexec)"", ""result"": [{""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2964, ""call_code"": ""vim_regexec(rmp, p, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}]}, {""source"": ""caller_info(func:vim_regexec)"", ""result"": [{""call_line"": 447, ""call_code"": ""vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0)"", ""caller_code"": ""    static int\ndo_arglist(\n    char_u\t*str,\n    int\t\twhat,\n    int\t\tafter UNUSED,\t// 0 means before first one\n    int\t\twill_edit)\t// will edit added argument\n{\n    garray_T\tnew_ga;\n    int\t\texp_count;\n    char_u\t**exp_files;\n    int\t\ti;\n    char_u\t*p;\n    int\t\tmatch;\n    int\t\targ_escaped = TRUE;\n\n    if (check_arglist_locked() == FAIL)\n\treturn FAIL;\n\n    // Set default argument for \"":argadd\"" command.\n    if (what == AL_ADD && *str == NUL)\n    {\n\tif (curbuf->b_ffname == NULL)\n\t    return FAIL;\n\tstr = curbuf->b_fname;\n\targ_escaped = FALSE;\n    }\n\n    // Collect all file name arguments in \""new_ga\"".\n    if (get_arglist(&new_ga, str, arg_escaped) == FAIL)\n\treturn FAIL;\n\n    if (what == AL_DEL)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tdidone;\n\n\t// Delete the items: use each item as a regexp and find a match in the\n\t// argument list.\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n\tfor (i = 0; i < new_ga.ga_len && !got_int; ++i)\n\t{\n\t    p = ((char_u **)new_ga.ga_data)[i];\n\t    p = file_pat_to_reg_pat(p, NULL, NULL, FALSE);\n\t    if (p == NULL)\n\t\tbreak;\n\t    regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tvim_free(p);\n\t\tbreak;\n\t    }\n\n\t    didone = FALSE;\n\t    for (match = 0; match < ARGCOUNT; ++match)\n\t\tif (vim_regexec(&regmatch, alist_name(&ARGLIST[match]),\n\t\t\t\t\t\t\t\t  (colnr_T)0))\n\t\t{\n\t\t    didone = TRUE;\n\t\t    vim_free(ARGLIST[match].ae_fname);\n\t\t    mch_memmove(ARGLIST + match, ARGLIST + match + 1,\n\t\t\t    (ARGCOUNT - match - 1) * sizeof(aentry_T));\n\t\t    --ALIST(curwin)->al_ga.ga_len;\n\t\t    if (curwin->w_arg_idx > match)\n\t\t\t--curwin->w_arg_idx;\n\t\t    --match;\n\t\t}\n\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(p);\n\t    if (!didone)\n\t\tsemsg(_(e_no_match_str_2), ((char_u **)new_ga.ga_data)[i]);\n\t}\n\tga_clear(&new_ga);\n    }\n    else\n    {\n\ti = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,\n\t\t&exp_count, &exp_files, EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);\n\tga_clear(&new_ga);\n\tif (i == FAIL || exp_count == 0)\n\t{\n\t    emsg(_(e_no_match));\n\t    return FAIL;\n\t}\n\n\tif (what == AL_ADD)\n\t{\n\t    alist_add_list(exp_count, exp_files, after, will_edit);\n\t    vim_free(exp_files);\n\t}\n\telse // what == AL_SET\n\t    alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);\n    }\n\n    alist_check_arg_idx();\n\n    return OK;\n}\n"", ""caller_start"": 393, ""file_path"": ""src/arglist.c""}, {""call_line"": 2958, ""call_code"": ""vim_regexec(rmp, name, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2964, ""call_code"": ""vim_regexec(rmp, p, (colnr_T)0)"", ""caller_code"": ""static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}"", ""caller_start"": 2945, ""file_path"": ""src/buffer.c""}, {""call_line"": 2861, ""call_code"": ""vim_regexec(regmatch, str, (colnr_T)0)"", ""caller_code"": ""    static int\nExpandGeneric(\n    char_u\t*pat,\n    expand_T\t*xp,\n    regmatch_T\t*regmatch,\n    char_u\t***matches,\n    int\t\t*numMatches,\n    char_u\t*((*func)(expand_T *, int)),\n\t\t\t\t\t  // returns a string from the list\n    int\t\tescaped)\n{\n    int\t\ti;\n    garray_T\tga;\n    char_u\t*str;\n    fuzmatch_str_T\t*fuzmatch = NULL;\n    int\t\tscore = 0;\n    int\t\tfuzzy;\n    int\t\tmatch;\n    int\t\tsort_matches = FALSE;\n    int\t\tfuncsort = FALSE;\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n    *matches = NULL;\n    *numMatches = 0;\n\n    if (!fuzzy)\n\tga_init2(&ga, sizeof(char *), 30);\n    else\n\tga_init2(&ga, sizeof(fuzmatch_str_T), 30);\n\n    for (i = 0; ; ++i)\n    {\n\tstr = (*func)(xp, i);\n\tif (str == NULL)\t    // end of list\n\t    break;\n\tif (*str == NUL)\t    // skip empty strings\n\t    continue;\n\n\tif (xp->xp_pattern[0] != NUL)\n\t{\n\t    if (!fuzzy)\n\t\tmatch = vim_regexec(regmatch, str, (colnr_T)0);\n\t    else\n\t    {\n\t\tscore = fuzzy_match_str(str, pat);\n\t\tmatch = (score != 0);\n\t    }\n\t}\n\telse\n\t    match = TRUE;\n\n\tif (!match)\n\t    continue;\n\n\tif (escaped)\n\t    str = vim_strsave_escaped(str, (char_u *)\"" \\t\\\\.\"");\n\telse\n\t    str = vim_strsave(str);\n\tif (str == NULL)\n\t{\n\t    if (!fuzzy)\n\t    {\n\t\tga_clear_strings(&ga);\n\t\treturn FAIL;\n\t    }\n\t    fuzmatch_str_free(ga.ga_data, ga.ga_len);\n\t    return FAIL;\n\t}\n\n\tif (ga_grow(&ga, 1) == FAIL)\n\t{\n\t    vim_free(str);\n\t    break;\n\t}\n\n\tif (fuzzy)\n\t{\n\t    fuzmatch = &((fuzmatch_str_T *)ga.ga_data)[ga.ga_len];\n\t    fuzmatch->idx = ga.ga_len;\n\t    fuzmatch->str = str;\n\t    fuzmatch->score = score;\n\t}\n\telse\n\t    ((char_u **)ga.ga_data)[ga.ga_len] = str;\n\n# ifdef FEAT_MENU\n\tif (func == get_menu_names)\n\t{\n\t    // test for separator added by get_menu_names()\n\t    str += STRLEN(str) - 1;\n\t    if (*str == '\\001')\n\t\t*str = '.';\n\t}\n# endif\n\n\t++ga.ga_len;\n    }\n\n    if (ga.ga_len == 0)\n\treturn OK;\n\n    // sort the matches when using regular expression matching and sorting\n    // applies to the completion context. Menus and scriptnames should be kept\n    // in the specified order.\n    if (!fuzzy && xp->xp_context != EXPAND_MENUNAMES\n\t\t\t\t\t&& xp->xp_context != EXPAND_MENUS\n\t\t\t\t\t&& xp->xp_context != EXPAND_SCRIPTNAMES)\n\tsort_matches = TRUE;\n\n    // <SNR> functions should be sorted to the end.\n    if (xp->xp_context == EXPAND_EXPRESSION\n\t    || xp->xp_context == EXPAND_FUNCTIONS\n\t    || xp->xp_context == EXPAND_USER_FUNC\n\t    || xp->xp_context == EXPAND_DISASSEMBLE)\n\tfuncsort = TRUE;\n\n    // Sort the matches.\n    if (sort_matches)\n    {\n\tif (funcsort)\n\t    // <SNR> functions should be sorted to the end.\n\t    qsort((void *)ga.ga_data, (size_t)ga.ga_len, sizeof(char_u *),\n\t\t\t\t\t\t\t   sort_func_compare);\n\telse\n\t    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n    }\n\n    if (!fuzzy)\n    {\n\t*matches = ga.ga_data;\n\t*numMatches = ga.ga_len;\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(ga.ga_data, matches, ga.ga_len,\n\t\t\t\t\t\t\tfuncsort) == FAIL)\n\t    return FAIL;\n\t*numMatches = ga.ga_len;\n    }\n\n#if defined(FEAT_SYN_HL)\n    // Reset the variables used for special highlight names expansion, so that\n    // they don't show up when getting normal highlight names by ID.\n    reset_expand_highlight();\n#endif\n\n    return OK;\n}\n"", ""caller_start"": 2820, ""file_path"": ""src/cmdexpand.c""}]}]","1. Invalid regex pattern passed to 'vim_regcomp' (regexp.c:2572) → returns NULL on failure.\n2. Callers like 'ExpandGeneric' (cmdexpand.c:2861) invoke 'vim_regexec' without checking 'rmp->regprog != NULL'.\n3. 'vim_regexec' (regexp.c:2813) calls 'vim_regexec_string' (regexp.c:2729), which dereferences 'rmp->regprog->re_in_use' without NULL check → NULL pointer dereference.",0.95,./github/other_context/CVE-2022-1620
44,CVE-2022-2476,CWE-476,c_cpp,A null pointer dereference bug was found in wavpack-5.4.0 The results from the ASAN log: AddressSanitizer:DEADLYSIGNAL ===================================================================84257==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x561b47a970c6 bp 0x7fff13952fb0 sp 0x7fff1394fca0 T0) ==84257==The signal is caused by a WRITE memory access. ==84257==Hint: address points to the zero page. #0 0x561b47a970c5 in main cli/wvunpack.c:834 #1 0x7efc4f5c0082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) #2 0x561b47a945ed in _start (/usr/local/bin/wvunpack+0xa5ed) AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV cli/wvunpack.c:834 in main ==84257==ABORTING,https://github.com/dbry/WavPack/commit/25b4a2725d8568212e7cf89ca05ca29d128af7ac,issue #121: NULL pointer dereference in wvunpack.c\n\n* check for NULL pointer before dereferencing in wvunpack.c\n* sanitize custom extensions to be alphanumeric only,2,"[{""func_name"": ""wvunpack_main"", ""file_path"": ""cli/wvunpack.c"", ""func_code"": ""static int wvunpack_main(int argc, char **argv)\n#else\nint main(int argc, char **argv)\n#endif\n{\n#ifdef __EMX__ /* OS/2 */\n    _wildcard (&argc, &argv);\n#endif\n    int verify_only = 0, error_count = 0, add_extension = 0, output_spec = 0, c_count = 0, x_count = 0;\n    char outpath, **matches = NULL, *outfilename = NULL, **argv_fn = NULL, selfname [PATH_MAX];\n    int use_stdin = 0, use_stdout = 0, argc_fn = 0, argi, result;\n\n#if defined(_WIN32)\n    if (!GetModuleFileName (NULL, selfname, sizeof (selfname)))\n#endif\n    strncpy (selfname, *argv, sizeof (selfname));\n\n    if (filespec_name (selfname)) {\n        char *filename = filespec_name (selfname);\n\n        if (strstr (filename, \""ebug\"") || strstr (filename, \""DEBUG\""))\n            debug_logging_mode = TRUE;\n\n        while (strchr (filename, '{')) {\n            char *open_brace = strchr (filename, '{');\n            char *close_brace = strchr (open_brace, '}');\n\n            if (!close_brace)\n                break;\n\n            if (close_brace - open_brace > 1) {\n                int option_len = (int)(close_brace - open_brace) - 1;\n                char *option = malloc (option_len + 1);\n\n                argv_fn = realloc (argv_fn, sizeof (char *) * ++argc_fn);\n                memcpy (option, open_brace + 1, option_len);\n                argv_fn [argc_fn - 1] = option;\n                option [option_len] = 0;\n\n                if (debug_logging_mode)\n                    error_line (\""file arg %d: %s\"", argc_fn, option);\n            }\n\n            filename = close_brace;\n        }\n    }\n\n    if (debug_logging_mode) {\n        char **argv_t = argv;\n        int argc_t = argc;\n\n        while (--argc_t)\n            error_line (\""cli arg %d: %s\"", argc - argc_t, *++argv_t);\n    }\n\n#if defined (_WIN32)\n    set_console_title = 1;      // on Windows, we default to messing with the console title\n#endif                          // on Linux, this is considered uncool to do by default\n\n    // loop through command-line arguments\n\n    for (argi = 0; argi < argc + argc_fn - 1; ++argi) {\n        char *argcp;\n\n        if (argi < argc_fn)\n            argcp = argv_fn [argi];\n        else\n            argcp = argv [argi - argc_fn + 1];\n\n        if (argcp [0] == '-' && argcp [1] == '-' && argcp [2]) {\n            char *long_option = argcp + 2, *long_param = long_option;\n\n            while (*long_param)\n                if (*long_param++ == '=')\n                    break;\n\n            if (!strcmp (long_option, \""help\"")) {                        // --help\n                printf (\""%s\"", help);\n                return 0;\n            }\n            else if (!strcmp (long_option, \""version\"")) {                // --version\n                printf (\""wvunpack %s\\n\"", PACKAGE_VERSION);\n                printf (\""libwavpack %s\\n\"", WavpackGetLibraryVersionString ());\n                return 0;\n            }\n#ifdef _WIN32\n            else if (!strcmp (long_option, \""pause\""))                    // --pause\n                pause_mode = 1;\n            else if (!strcmp (long_option, \""drop\""))                     // --drop\n                drop_mode = 1;\n#endif\n            else if (!strcmp (long_option, \""normalize-floats\""))         // --normalize-floats\n                normalize_floats = 1;\n            else if (!strcmp (long_option, \""no-utf8-convert\""))          // --no-utf8-convert\n                no_utf8_convert = 1;\n            else if (!strncmp (long_option, \""skip\"", 4)) {               // --skip\n                parse_sample_time_index (&skip, long_param);\n\n                if (!skip.value_is_valid) {\n                    error_line (\""invalid --skip parameter!\"");\n                    ++error_count;\n                }\n            }\n            else if (!strncmp (long_option, \""until\"", 5)) {              // --until\n                parse_sample_time_index (&until, long_param);\n\n                if (!until.value_is_valid) {\n                    error_line (\""invalid --until parameter!\"");\n                    ++error_count;\n                }\n            }\n            else if (!strcmp (long_option, \""caf-be\"")) {                 // --caf-be\n                decode_format = WP_FORMAT_CAF;\n                caf_be = format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""caf-le\"")) {                 // --caf-le\n                decode_format = WP_FORMAT_CAF;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""dsf\"")) {                    // --dsf\n                decode_format = WP_FORMAT_DSF;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""dsdiff\"") || !strcmp (long_option, \""dff\"")) {\n                decode_format = WP_FORMAT_DFF;                          // --dsdiff or --dff\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""w64\"")) {                    // --w64\n                decode_format = WP_FORMAT_W64;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""wav\"")) {                    // --wav\n                decode_format = WP_FORMAT_WAV;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""raw-pcm\""))                  // --raw-pcm\n                raw_pcm = raw_decode = 1;\n            else if (!strcmp (long_option, \""raw\""))                      // --raw\n                raw_decode = 1;\n            else {\n                error_line (\""unknown option: %s !\"", long_option);\n                ++error_count;\n            }\n        }\n#if defined (_WIN32)\n        else if ((argcp [0] == '-' || argcp [0] == '/') && argcp [1])\n#else\n        else if (argcp [0] == '-' && argcp [1])\n#endif\n            while (*++argcp)\n                switch (*argcp) {\n                    case 'Y': case 'y':\n                        overwrite_all = 1;\n                        break;\n\n                    case 'C': case 'c':\n                        if (++c_count == 2) {\n                            add_tag_extraction_to_list (\""cuesheet=%a.cue\"");\n                            c_count = 0;\n                        }\n\n                        break;\n\n                    case 'D': case 'd':\n                        delete_source = 1;\n                        break;\n\n#if defined (_WIN32)\n                    case 'L': case 'l':\n                        SetPriorityClass (GetCurrentProcess(), IDLE_PRIORITY_CLASS);\n                        break;\n#elif defined (__OS2__)\n                    case 'L': case 'l':\n                        DosSetPriority (0, PRTYC_IDLETIME, 0, 0);\n                        break;\n#endif\n#if defined (_WIN32)\n                    case 'O': case 'o':  // ignore -o in Windows to be Linux compatible\n                        break;\n#else\n                    case 'O': case 'o':\n                        output_spec = 1;\n                        break;\n#endif\n                    case 'T': case 't':\n                        copy_time = 1;\n                        break;\n\n                    case 'V': case 'v':\n                        ++verify_only;\n                        break;\n\n                    case 'F': case 'f':\n                        file_info = (char) strtol (++argcp, &argcp, 10);\n\n                        if (file_info < 0 || file_info > 10) {\n                            error_line (\""-f option must be 1-10, or omit (or 0) for all!\"");\n                            ++error_count;\n                        }\n                        else {\n                            quiet_mode = no_audio_decode = 1;\n                            file_info++;\n                        }\n\n                        --argcp;\n                        break;\n\n                    case 'S': case 's':\n                        no_audio_decode = 1;\n                        ++summary;\n                        break;\n\n                    case 'K': case 'k':\n                        outbuf_k = strtol (++argcp, &argcp, 10);\n\n                        if (outbuf_k < 1 || outbuf_k > 16384)       // range-check for reasonable values\n                            outbuf_k = 0;\n\n                        --argcp;\n                        break;\n\n                    case 'M': case 'm':\n                        calc_md5 = 1;\n                        break;\n\n                    case 'B': case 'b':\n                        blind_decode = 1;\n                        break;\n\n                    case 'N': case 'n':\n                        no_audio_decode = 1;\n                        break;\n\n                    case 'R': case 'r':\n                        raw_decode = 1;\n                        break;\n\n                    case 'W': case 'w':\n                        decode_format = WP_FORMAT_WAV;\n                        format_specified = 1;\n                        break;\n\n                    case 'Q': case 'q':\n                        quiet_mode = 1;\n                        break;\n\n                    case 'Z': case 'z':\n                        set_console_title = (char) strtol (++argcp, &argcp, 10);\n                        --argcp;\n                        break;\n\n                    case 'X': case 'x':\n                        if (++x_count == 3) {\n                            error_line (\""illegal option: %s !\"", argcp);\n                            ++error_count;\n                            x_count = 0;\n                        }\n\n                        break;\n\n                    case 'I': case 'i':\n                        ignore_wvc = 1;\n                        break;\n\n                    default:\n                        error_line (\""illegal option: %c !\"", *argcp);\n                        ++error_count;\n                }\n        else if (argi < argc_fn) {\n            error_line (\""invalid use of filename-embedded args: %s !\"", argcp);\n            ++error_count;\n        }\n        else {\n            if (x_count) {\n                if (x_count == 1) {\n                    if (tag_extract_stdout) {\n                        error_line (\""can't extract more than 1 tag item to stdout at a time!\"");\n                        ++error_count;\n                    }\n                    else {\n                        tag_extract_stdout = argcp;\n                        no_audio_decode = 1;\n                    }\n                }\n                else if (x_count == 2)\n                    add_tag_extraction_to_list (argcp);\n\n                x_count = 0;\n            }\n#if defined (_WIN32)\n            else if (drop_mode || !num_files) {\n                matches = realloc (matches, (num_files + 1) * sizeof (*matches));\n                matches [num_files] = malloc (strlen (argcp) + 10);\n                strcpy (matches [num_files], argcp);\n                use_stdin |= (*argcp == '-');\n\n                if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&\n                    !filespec_ext (matches [num_files]))\n                        strcat (matches [num_files], \"".wv\"");\n\n                num_files++;\n            }\n            else if (!outfilename) {\n                outfilename = malloc (strlen (argcp) + PATH_MAX);\n                strcpy (outfilename, argcp);\n                use_stdout = (*argcp == '-');\n            }\n            else {\n                error_line (\""extra unknown argument: %s !\"", argcp);\n                ++error_count;\n            }\n#else\n            else if (output_spec) {\n                outfilename = malloc (strlen (argcp) + PATH_MAX);\n                strcpy (outfilename, argcp);\n                use_stdout = (*argcp == '-');\n                output_spec = 0;\n            }\n            else {\n                matches = realloc (matches, (num_files + 1) * sizeof (*matches));\n                matches [num_files] = malloc (strlen (argcp) + 10);\n                strcpy (matches [num_files], argcp);\n                use_stdin |= (*argcp == '-');\n\n                if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&\n                    !filespec_ext (matches [num_files]))\n                        strcat (matches [num_files], \"".wv\"");\n\n                num_files++;\n            }\n#endif\n        }\n\n        if (argi < argc_fn)\n            free (argv_fn [argi]);\n    }\n\n    free (argv_fn);\n\n   // check for various command-line argument problems\n\n    if (output_spec) {\n        error_line (\""no output filename or path specified with -o option!\"");\n        ++error_count;\n    }\n\n    if (use_stdin && num_files > 1) {\n        error_line (\""when stdin is used for input, it must be the only file!\"");\n        ++error_count;\n    }\n\n    if (use_stdin && !outfilename)  // for stdin source, no output specification implies stdout\n        use_stdout = 1;\n\n    if (delete_source && (verify_only || skip.value_is_valid || until.value_is_valid)) {\n        error_line (\""can't delete in verify mode or when --skip or --until are used!\"");\n        delete_source = 0;\n    }\n\n    if (raw_decode && format_specified) {\n        error_line (\""-r (raw decode) and specifying a format (like -w) are incompatible!\"");\n        ++error_count;\n    }\n\n    if (verify_only && (format_specified || outfilename)) {\n        error_line (\""specifying output file or format and verify mode are incompatible!\"");\n        ++error_count;\n    }\n\n    if (verify_only > 1 && calc_md5) {\n        error_line (\""can't calculate MD5s in quick verify mode!\"");\n        ++error_count;\n    }\n\n    if (c_count == 1) {\n        if (tag_extract_stdout) {\n            error_line (\""can't extract more than 1 tag item to stdout at a time!\"");\n            error_count++;\n        }\n        else {\n            tag_extract_stdout = \""cuesheet\"";\n            no_audio_decode = 1;\n        }\n    }\n\n    if ((summary || file_info) && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified)) {\n        error_line (\""can't display file information and do anything else!\"");\n        ++error_count;\n    }\n\n    if (tag_extract_stdout && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified || raw_decode)) {\n        error_line (\""can't extract a tag to stdout and do anything else!\"");\n        ++error_count;\n    }\n\n    if ((tag_extract_stdout || num_tag_extractions) && use_stdout) {\n        error_line (\""can't extract tags when unpacking audio to stdout!\"");\n        ++error_count;\n    }\n\n    if (strcmp (WavpackGetLibraryVersionString (), PACKAGE_VERSION)) {\n        fprintf (stderr, version_warning, WavpackGetLibraryVersionString (), PACKAGE_VERSION);\n        fflush (stderr);\n    }\n    else if (!quiet_mode && !error_count) {\n        fprintf (stderr, sign_on, VERSION_OS, WavpackGetLibraryVersionString ());\n        fflush (stderr);\n    }\n\n    if (error_count) {\n        fprintf (stderr, \""\\ntype 'wvunpack' for short help or 'wvunpack --help' for full help\\n\"");\n        fflush (stderr);\n        return 1;\n    }\n\n    if (!num_files) {\n        printf (\""%s\"", usage);\n        return 1;\n    }\n\n    setup_break ();\n\n    for (file_index = 0; file_index < num_files; ++file_index) {\n        char *infilename = matches [file_index];\n\n        // If the single infile specification begins with a '@', then it\n        // actually points to a file that contains the names of the files\n        // to be converted. This was included for use by Wim Speekenbrink's\n        // frontends, but could be used for other purposes.\n\n        if (*infilename == '@') {\n            FILE *list = fopen (infilename+1, \""rb\"");\n            char *listbuff = NULL, *cp;\n            int listbytes = 0, di, c;\n\n            for (di = file_index; di < num_files - 1; di++)\n                matches [di] = matches [di + 1];\n\n            file_index--;\n            num_files--;\n\n            if (list == NULL) {\n                error_line (\""file %s not found!\"", infilename+1);\n                free (infilename);\n                return 1;\n            }\n\n            while (1) {\n                int bytes_read;\n\n                listbuff = realloc (listbuff, listbytes + 1024);\n                memset (listbuff + listbytes, 0, 1024);\n                listbytes += bytes_read = (int) fread (listbuff + listbytes, 1, 1024, list);\n\n                if (bytes_read < 1024)\n                    break;\n            }\n\n#if defined (_WIN32)\n            listbuff = realloc (listbuff, listbytes *= 2);\n            TextToUTF8 (listbuff, listbytes);\n#endif\n            cp = listbuff;\n\n            while ((c = *cp++)) {\n\n                while (c == '\\n' || c == '\\r')\n                    c = *cp++;\n\n                if (c) {\n                    char *fname = malloc (PATH_MAX);\n                    int ci = 0;\n\n                    do\n                        fname [ci++] = c;\n                    while ((c = *cp++) != '\\n' && c != '\\r' && c && ci < PATH_MAX);\n\n                    fname [ci++] = '\\0';\n                    matches = realloc (matches, ++num_files * sizeof (*matches));\n\n                    for (di = num_files - 1; di > file_index + 1; di--)\n                        matches [di] = matches [di - 1];\n\n                    matches [++file_index] = fname;\n                }\n\n                if (!c)\n                    break;\n            }\n\n            fclose (list);\n            free (listbuff);\n            free (infilename);\n        }\n#if defined (_WIN32)\n        else if (filespec_wild (infilename)) {\n            wchar_t *winfilename = utf8_to_utf16(infilename);\n            struct _wfinddata_t _wfinddata_t;\n            intptr_t file;\n            int di;\n\n            for (di = file_index; di < num_files - 1; di++)\n                matches [di] = matches [di + 1];\n\n            file_index--;\n            num_files--;\n\n            if ((file = _wfindfirst (winfilename, &_wfinddata_t)) != (intptr_t) -1) {\n                do {\n                    char *name_utf8;\n\n                    if (!(_wfinddata_t.attrib & _A_SUBDIR) && (name_utf8 = utf16_to_utf8(_wfinddata_t.name))) {\n                        matches = realloc (matches, ++num_files * sizeof (*matches));\n\n                        for (di = num_files - 1; di > file_index + 1; di--)\n                            matches [di] = matches [di - 1];\n\n                        matches [++file_index] = malloc (strlen (infilename) + strlen (name_utf8) + 10);\n                        strcpy (matches [file_index], infilename);\n                        *filespec_name (matches [file_index]) = '\\0';\n                        strcat (matches [file_index], name_utf8);\n                        free (name_utf8);\n                    }\n                } while (_wfindnext (file, &_wfinddata_t) == 0);\n\n                _findclose (file);\n            }\n\n            free (winfilename);\n            free (infilename);\n        }\n#endif\n    }\n\n    // If the outfile specification begins with a '@', then it actually points\n    // to a file that contains the output specification. This was included for\n    // use by Wim Speekenbrink's frontends because certain filenames could not\n    // be passed on the command-line, but could be used for other purposes.\n\n    if (outfilename && outfilename [0] == '@') {\n        char listbuff [PATH_MAX * 2], *lp = listbuff;\n        FILE *list = fopen (outfilename+1, \""rb\"");\n        int c;\n\n        if (list == NULL) {\n            error_line (\""file %s not found!\"", outfilename+1);\n            free(outfilename);\n            return 1;\n        }\n\n        memset (listbuff, 0, sizeof (listbuff));\n        c = (int) fread (listbuff, 1, sizeof (listbuff) - 1, list);   // assign c only to suppress warning\n\n#if defined (_WIN32)\n        TextToUTF8 (listbuff, PATH_MAX * 2);\n#endif\n\n        while ((c = *lp++) == '\\n' || c == '\\r');\n\n        if (c) {\n            int ci = 0;\n\n            do\n                outfilename [ci++] = c;\n            while ((c = *lp++) != '\\n' && c != '\\r' && c && ci < PATH_MAX);\n\n            outfilename [ci] = '\\0';\n        }\n        else {\n            error_line (\""output spec file is empty!\"");\n            free(outfilename);\n            fclose (list);\n            return 1;\n        }\n\n        fclose (list);\n    }\n\n    // if we found any files to process, this is where we start\n\n    if (num_files) {\n        if (outfilename && *outfilename != '-') {\n            outpath = (filespec_path (outfilename) != NULL);\n\n            if (num_files > 1 && !outpath) {\n                error_line (\""%s is not a valid output path\"", outfilename);\n                free (outfilename);\n                return 1;\n            }\n        }\n        else\n            outpath = 0;\n\n        add_extension = !outfilename || outpath || !filespec_ext (outfilename);\n\n        // loop through and process files in list\n\n        for (file_index = 0; file_index < num_files; ++file_index) {\n            if (check_break ())\n                break;\n\n            // generate output filename\n\n            if (outpath) {\n                strcat (outfilename, filespec_name (matches [file_index]));\n\n                if (filespec_ext (outfilename))\n                    *filespec_ext (outfilename) = '\\0';\n            }\n            else if (!outfilename) {\n                outfilename = malloc (strlen (matches [file_index]) + 10);\n                strcpy (outfilename, matches [file_index]);\n\n                if (filespec_ext (outfilename))\n                    *filespec_ext (outfilename) = '\\0';\n            }\n\n            if (num_files > 1 && !quiet_mode) {\n                fprintf (stderr, \""\\n%s:\\n\"", matches [file_index]);\n                fflush (stderr);\n            }\n\n            if (verify_only > 1) {\n                result = quick_verify_file (matches [file_index], verify_only > 2);\n\n                // quick_verify_file() returns hard error to mean file cannot be quickly verified\n                // because it has no block checksums, so fall back to standard slow verify\n\n                if (result == WAVPACK_HARD_ERROR)\n                    result = unpack_file (matches [file_index], NULL, 0);\n            }\n            else\n                result = unpack_file (matches [file_index], verify_only ? NULL : outfilename, add_extension);\n\n            if (result != WAVPACK_NO_ERROR)\n                ++error_count;\n\n            if (result == WAVPACK_HARD_ERROR)\n                break;\n\n            // clean up in preparation for potentially another file\n\n            if (outpath)\n                *filespec_name (outfilename) = '\\0';\n            else if (*outfilename != '-') {\n                free (outfilename);\n                outfilename = NULL;\n            }\n\n            free (matches [file_index]);\n        }\n\n        if (num_files > 1) {\n            if (error_count) {\n                fprintf (stderr, \""\\n **** warning: errors occurred in %d of %d files! ****\\n\"", error_count, num_files);\n                fflush (stderr);\n            }\n            else if (!quiet_mode) {\n                fprintf (stderr, \""\\n **** %d files successfully processed ****\\n\"", num_files);\n                fflush (stderr);\n            }\n        }\n\n        free (matches);\n    }\n    else {\n        error_line (\""nothing to do!\"");\n        ++error_count;\n    }\n\n    if (outfilename)\n        free (outfilename);\n\n    if (set_console_title)\n        DoSetConsoleTitle (\""WvUnpack Completed\"");\n\n    return error_count ? 1 : 0;\n}"", ""target"": 0}, {""func_name"": ""process_metadata"", ""file_path"": ""src/open_utils.c"", ""func_code"": ""static int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    WavpackStream *wps = wpc->streams [wpc->current_stream];\n\n    switch (wpmd->id) {\n        case ID_DUMMY:\n            return TRUE;\n\n        case ID_DECORR_TERMS:\n            return read_decorr_terms (wps, wpmd);\n\n        case ID_DECORR_WEIGHTS:\n            return read_decorr_weights (wps, wpmd);\n\n        case ID_DECORR_SAMPLES:\n            return read_decorr_samples (wps, wpmd);\n\n        case ID_ENTROPY_VARS:\n            return read_entropy_vars (wps, wpmd);\n\n        case ID_HYBRID_PROFILE:\n            return read_hybrid_profile (wps, wpmd);\n\n        case ID_SHAPING_WEIGHTS:\n            return read_shaping_info (wps, wpmd);\n\n        case ID_FLOAT_INFO:\n            return read_float_info (wps, wpmd);\n\n        case ID_INT32_INFO:\n            return read_int32_info (wps, wpmd);\n\n        case ID_CHANNEL_INFO:\n            return read_channel_info (wpc, wpmd);\n\n        case ID_CHANNEL_IDENTITIES:\n            return read_channel_identities (wpc, wpmd);\n\n        case ID_CONFIG_BLOCK:\n            return read_config_info (wpc, wpmd);\n\n        case ID_NEW_CONFIG_BLOCK:\n            return read_new_config_info (wpc, wpmd);\n\n        case ID_SAMPLE_RATE:\n            return read_sample_rate (wpc, wpmd);\n\n        case ID_WV_BITSTREAM:\n            return init_wv_bitstream (wps, wpmd);\n\n        case ID_WVC_BITSTREAM:\n            return init_wvc_bitstream (wps, wpmd);\n\n        case ID_WVX_BITSTREAM:\n            return init_wvx_bitstream (wps, wpmd);\n\n        case ID_DSD_BLOCK:\n#ifdef ENABLE_DSD\n            return init_dsd_block (wpc, wpmd);\n#else\n            strcpy (wpc->error_message, \""not configured to handle DSD WavPack files!\"");\n            return FALSE;\n#endif\n\n        case ID_ALT_HEADER: case ID_ALT_TRAILER:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_RIFF_HEADER: case ID_RIFF_TRAILER:\n            return read_wrapper_data (wpc, wpmd);\n\n        case ID_ALT_MD5_CHECKSUM:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_MD5_CHECKSUM:\n            if (wpmd->byte_length == 16) {\n                memcpy (wpc->config.md5_checksum, wpmd->data, 16);\n                wpc->config.flags |= CONFIG_MD5_CHECKSUM;\n                wpc->config.md5_read = 1;\n            }\n\n            return TRUE;\n\n        case ID_ALT_EXTENSION:\n            if (wpmd->byte_length && wpmd->byte_length < sizeof (wpc->file_extension)) {\n                memcpy (wpc->file_extension, wpmd->data, wpmd->byte_length);\n                wpc->file_extension [wpmd->byte_length] = 0;\n            }\n\n            return TRUE;\n\n        // we don't actually verify the checksum here (it's done right after the\n        // block is read), but it's a good indicator of version 5 files\n\n        case ID_BLOCK_CHECKSUM:\n            wpc->version_five = 1;\n            return TRUE;\n\n        default:\n            return (wpmd->id & ID_OPTIONAL_DATA) ? TRUE : FALSE;\n    }\n}"", ""target"": 0}]","[{""func_name"": ""wvunpack_main"", ""file_path"": ""cli/wvunpack.c"", ""func_code"": ""static int wvunpack_main(int argc, char **argv)\n#else\nint main(int argc, char **argv)\n#endif\n{\n#ifdef __EMX__ /* OS/2 */\n    _wildcard (&argc, &argv);\n#endif\n    int verify_only = 0, error_count = 0, add_extension = 0, output_spec = 0, c_count = 0, x_count = 0;\n    char outpath, **matches = NULL, *outfilename = NULL, **argv_fn = NULL, selfname [PATH_MAX];\n    int use_stdin = 0, use_stdout = 0, argc_fn = 0, argi, result;\n\n#if defined(_WIN32)\n    if (!GetModuleFileName (NULL, selfname, sizeof (selfname)))\n#endif\n    strncpy (selfname, *argv, sizeof (selfname));\n\n    if (filespec_name (selfname)) {\n        char *filename = filespec_name (selfname);\n\n        if (strstr (filename, \""ebug\"") || strstr (filename, \""DEBUG\""))\n            debug_logging_mode = TRUE;\n\n        while (strchr (filename, '{')) {\n            char *open_brace = strchr (filename, '{');\n            char *close_brace = strchr (open_brace, '}');\n\n            if (!close_brace)\n                break;\n\n            if (close_brace - open_brace > 1) {\n                int option_len = (int)(close_brace - open_brace) - 1;\n                char *option = malloc (option_len + 1);\n\n                argv_fn = realloc (argv_fn, sizeof (char *) * ++argc_fn);\n                memcpy (option, open_brace + 1, option_len);\n                argv_fn [argc_fn - 1] = option;\n                option [option_len] = 0;\n\n                if (debug_logging_mode)\n                    error_line (\""file arg %d: %s\"", argc_fn, option);\n            }\n\n            filename = close_brace;\n        }\n    }\n\n    if (debug_logging_mode) {\n        char **argv_t = argv;\n        int argc_t = argc;\n\n        while (--argc_t)\n            error_line (\""cli arg %d: %s\"", argc - argc_t, *++argv_t);\n    }\n\n#if defined (_WIN32)\n    set_console_title = 1;      // on Windows, we default to messing with the console title\n#endif                          // on Linux, this is considered uncool to do by default\n\n    // loop through command-line arguments\n\n    for (argi = 0; argi < argc + argc_fn - 1; ++argi) {\n        char *argcp;\n\n        if (argi < argc_fn)\n            argcp = argv_fn [argi];\n        else\n            argcp = argv [argi - argc_fn + 1];\n\n        if (argcp [0] == '-' && argcp [1] == '-' && argcp [2]) {\n            char *long_option = argcp + 2, *long_param = long_option;\n\n            while (*long_param)\n                if (*long_param++ == '=')\n                    break;\n\n            if (!strcmp (long_option, \""help\"")) {                        // --help\n                printf (\""%s\"", help);\n                return 0;\n            }\n            else if (!strcmp (long_option, \""version\"")) {                // --version\n                printf (\""wvunpack %s\\n\"", PACKAGE_VERSION);\n                printf (\""libwavpack %s\\n\"", WavpackGetLibraryVersionString ());\n                return 0;\n            }\n#ifdef _WIN32\n            else if (!strcmp (long_option, \""pause\""))                    // --pause\n                pause_mode = 1;\n            else if (!strcmp (long_option, \""drop\""))                     // --drop\n                drop_mode = 1;\n#endif\n            else if (!strcmp (long_option, \""normalize-floats\""))         // --normalize-floats\n                normalize_floats = 1;\n            else if (!strcmp (long_option, \""no-utf8-convert\""))          // --no-utf8-convert\n                no_utf8_convert = 1;\n            else if (!strncmp (long_option, \""skip\"", 4)) {               // --skip\n                parse_sample_time_index (&skip, long_param);\n\n                if (!skip.value_is_valid) {\n                    error_line (\""invalid --skip parameter!\"");\n                    ++error_count;\n                }\n            }\n            else if (!strncmp (long_option, \""until\"", 5)) {              // --until\n                parse_sample_time_index (&until, long_param);\n\n                if (!until.value_is_valid) {\n                    error_line (\""invalid --until parameter!\"");\n                    ++error_count;\n                }\n            }\n            else if (!strcmp (long_option, \""caf-be\"")) {                 // --caf-be\n                decode_format = WP_FORMAT_CAF;\n                caf_be = format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""caf-le\"")) {                 // --caf-le\n                decode_format = WP_FORMAT_CAF;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""dsf\"")) {                    // --dsf\n                decode_format = WP_FORMAT_DSF;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""dsdiff\"") || !strcmp (long_option, \""dff\"")) {\n                decode_format = WP_FORMAT_DFF;                          // --dsdiff or --dff\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""w64\"")) {                    // --w64\n                decode_format = WP_FORMAT_W64;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""wav\"")) {                    // --wav\n                decode_format = WP_FORMAT_WAV;\n                format_specified = 1;\n            }\n            else if (!strcmp (long_option, \""raw-pcm\""))                  // --raw-pcm\n                raw_pcm = raw_decode = 1;\n            else if (!strcmp (long_option, \""raw\""))                      // --raw\n                raw_decode = 1;\n            else {\n                error_line (\""unknown option: %s !\"", long_option);\n                ++error_count;\n            }\n        }\n#if defined (_WIN32)\n        else if ((argcp [0] == '-' || argcp [0] == '/') && argcp [1])\n#else\n        else if (argcp [0] == '-' && argcp [1])\n#endif\n            while (*++argcp)\n                switch (*argcp) {\n                    case 'Y': case 'y':\n                        overwrite_all = 1;\n                        break;\n\n                    case 'C': case 'c':\n                        if (++c_count == 2) {\n                            add_tag_extraction_to_list (\""cuesheet=%a.cue\"");\n                            c_count = 0;\n                        }\n\n                        break;\n\n                    case 'D': case 'd':\n                        delete_source = 1;\n                        break;\n\n#if defined (_WIN32)\n                    case 'L': case 'l':\n                        SetPriorityClass (GetCurrentProcess(), IDLE_PRIORITY_CLASS);\n                        break;\n#elif defined (__OS2__)\n                    case 'L': case 'l':\n                        DosSetPriority (0, PRTYC_IDLETIME, 0, 0);\n                        break;\n#endif\n#if defined (_WIN32)\n                    case 'O': case 'o':  // ignore -o in Windows to be Linux compatible\n                        break;\n#else\n                    case 'O': case 'o':\n                        output_spec = 1;\n                        break;\n#endif\n                    case 'T': case 't':\n                        copy_time = 1;\n                        break;\n\n                    case 'V': case 'v':\n                        ++verify_only;\n                        break;\n\n                    case 'F': case 'f':\n                        file_info = (char) strtol (++argcp, &argcp, 10);\n\n                        if (file_info < 0 || file_info > 10) {\n                            error_line (\""-f option must be 1-10, or omit (or 0) for all!\"");\n                            ++error_count;\n                        }\n                        else {\n                            quiet_mode = no_audio_decode = 1;\n                            file_info++;\n                        }\n\n                        --argcp;\n                        break;\n\n                    case 'S': case 's':\n                        no_audio_decode = 1;\n                        ++summary;\n                        break;\n\n                    case 'K': case 'k':\n                        outbuf_k = strtol (++argcp, &argcp, 10);\n\n                        if (outbuf_k < 1 || outbuf_k > 16384)       // range-check for reasonable values\n                            outbuf_k = 0;\n\n                        --argcp;\n                        break;\n\n                    case 'M': case 'm':\n                        calc_md5 = 1;\n                        break;\n\n                    case 'B': case 'b':\n                        blind_decode = 1;\n                        break;\n\n                    case 'N': case 'n':\n                        no_audio_decode = 1;\n                        break;\n\n                    case 'R': case 'r':\n                        raw_decode = 1;\n                        break;\n\n                    case 'W': case 'w':\n                        decode_format = WP_FORMAT_WAV;\n                        format_specified = 1;\n                        break;\n\n                    case 'Q': case 'q':\n                        quiet_mode = 1;\n                        break;\n\n                    case 'Z': case 'z':\n                        set_console_title = (char) strtol (++argcp, &argcp, 10);\n                        --argcp;\n                        break;\n\n                    case 'X': case 'x':\n                        if (++x_count == 3) {\n                            error_line (\""illegal option: %s !\"", argcp);\n                            ++error_count;\n                            x_count = 0;\n                        }\n\n                        break;\n\n                    case 'I': case 'i':\n                        ignore_wvc = 1;\n                        break;\n\n                    default:\n                        error_line (\""illegal option: %c !\"", *argcp);\n                        ++error_count;\n                }\n        else if (argi < argc_fn) {\n            error_line (\""invalid use of filename-embedded args: %s !\"", argcp);\n            ++error_count;\n        }\n        else {\n            if (x_count) {\n                if (x_count == 1) {\n                    if (tag_extract_stdout) {\n                        error_line (\""can't extract more than 1 tag item to stdout at a time!\"");\n                        ++error_count;\n                    }\n                    else {\n                        tag_extract_stdout = argcp;\n                        no_audio_decode = 1;\n                    }\n                }\n                else if (x_count == 2)\n                    add_tag_extraction_to_list (argcp);\n\n                x_count = 0;\n            }\n#if defined (_WIN32)\n            else if (drop_mode || !num_files) {\n                matches = realloc (matches, (num_files + 1) * sizeof (*matches));\n                matches [num_files] = malloc (strlen (argcp) + 10);\n                strcpy (matches [num_files], argcp);\n                use_stdin |= (*argcp == '-');\n\n                if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&\n                    !filespec_ext (matches [num_files]))\n                        strcat (matches [num_files], \"".wv\"");\n\n                num_files++;\n            }\n            else if (!outfilename) {\n                outfilename = malloc (strlen (argcp) + PATH_MAX);\n                strcpy (outfilename, argcp);\n                use_stdout = (*argcp == '-');\n            }\n            else {\n                error_line (\""extra unknown argument: %s !\"", argcp);\n                ++error_count;\n            }\n#else\n            else if (output_spec) {\n                outfilename = malloc (strlen (argcp) + PATH_MAX);\n                strcpy (outfilename, argcp);\n                use_stdout = (*argcp == '-');\n                output_spec = 0;\n            }\n            else {\n                matches = realloc (matches, (num_files + 1) * sizeof (*matches));\n                matches [num_files] = malloc (strlen (argcp) + 10);\n                strcpy (matches [num_files], argcp);\n                use_stdin |= (*argcp == '-');\n\n                if (*(matches [num_files]) != '-' && *(matches [num_files]) != '@' &&\n                    !filespec_ext (matches [num_files]))\n                        strcat (matches [num_files], \"".wv\"");\n\n                num_files++;\n            }\n#endif\n        }\n\n        if (argi < argc_fn)\n            free (argv_fn [argi]);\n    }\n\n    free (argv_fn);\n\n   // check for various command-line argument problems\n\n    if (output_spec) {\n        error_line (\""no output filename or path specified with -o option!\"");\n        ++error_count;\n    }\n\n    if (use_stdin && num_files > 1) {\n        error_line (\""when stdin is used for input, it must be the only file!\"");\n        ++error_count;\n    }\n\n    if (use_stdin && !outfilename)  // for stdin source, no output specification implies stdout\n        use_stdout = 1;\n\n    if (delete_source && (verify_only || skip.value_is_valid || until.value_is_valid)) {\n        error_line (\""can't delete in verify mode or when --skip or --until are used!\"");\n        delete_source = 0;\n    }\n\n    if (raw_decode && format_specified) {\n        error_line (\""-r (raw decode) and specifying a format (like -w) are incompatible!\"");\n        ++error_count;\n    }\n\n    if (verify_only && (format_specified || outfilename)) {\n        error_line (\""specifying output file or format and verify mode are incompatible!\"");\n        ++error_count;\n    }\n\n    if (verify_only > 1 && calc_md5) {\n        error_line (\""can't calculate MD5s in quick verify mode!\"");\n        ++error_count;\n    }\n\n    if (c_count == 1) {\n        if (tag_extract_stdout) {\n            error_line (\""can't extract more than 1 tag item to stdout at a time!\"");\n            error_count++;\n        }\n        else {\n            tag_extract_stdout = \""cuesheet\"";\n            no_audio_decode = 1;\n        }\n    }\n\n    if ((summary || file_info) && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified)) {\n        error_line (\""can't display file information and do anything else!\"");\n        ++error_count;\n    }\n\n    if (tag_extract_stdout && (num_tag_extractions || outfilename || verify_only || delete_source || format_specified || raw_decode)) {\n        error_line (\""can't extract a tag to stdout and do anything else!\"");\n        ++error_count;\n    }\n\n    if ((tag_extract_stdout || num_tag_extractions) && use_stdout) {\n        error_line (\""can't extract tags when unpacking audio to stdout!\"");\n        ++error_count;\n    }\n\n    if (strcmp (WavpackGetLibraryVersionString (), PACKAGE_VERSION)) {\n        fprintf (stderr, version_warning, WavpackGetLibraryVersionString (), PACKAGE_VERSION);\n        fflush (stderr);\n    }\n    else if (!quiet_mode && !error_count) {\n        fprintf (stderr, sign_on, VERSION_OS, WavpackGetLibraryVersionString ());\n        fflush (stderr);\n    }\n\n    if (error_count) {\n        fprintf (stderr, \""\\ntype 'wvunpack' for short help or 'wvunpack --help' for full help\\n\"");\n        fflush (stderr);\n        return 1;\n    }\n\n    if (!num_files) {\n        printf (\""%s\"", usage);\n        return 1;\n    }\n\n    setup_break ();\n\n    for (file_index = 0; file_index < num_files; ++file_index) {\n        char *infilename = matches [file_index];\n\n        // If the single infile specification begins with a '@', then it\n        // actually points to a file that contains the names of the files\n        // to be converted. This was included for use by Wim Speekenbrink's\n        // frontends, but could be used for other purposes.\n\n        if (*infilename == '@') {\n            FILE *list = fopen (infilename+1, \""rb\"");\n            char *listbuff = NULL, *cp;\n            int listbytes = 0, di, c;\n\n            for (di = file_index; di < num_files - 1; di++)\n                matches [di] = matches [di + 1];\n\n            file_index--;\n            num_files--;\n\n            if (list == NULL) {\n                error_line (\""file %s not found!\"", infilename+1);\n                free (infilename);\n                return 1;\n            }\n\n            while (1) {\n                int bytes_read;\n\n                listbuff = realloc (listbuff, listbytes + 1024);\n                memset (listbuff + listbytes, 0, 1024);\n                listbytes += bytes_read = (int) fread (listbuff + listbytes, 1, 1024, list);\n\n                if (bytes_read < 1024)\n                    break;\n            }\n\n#if defined (_WIN32)\n            listbuff = realloc (listbuff, listbytes *= 2);\n            TextToUTF8 (listbuff, listbytes);\n#endif\n            cp = listbuff;\n\n            while ((c = *cp++)) {\n\n                while (c == '\\n' || c == '\\r')\n                    c = *cp++;\n\n                if (c) {\n                    char *fname = malloc (PATH_MAX);\n                    int ci = 0;\n\n                    do\n                        fname [ci++] = c;\n                    while ((c = *cp++) != '\\n' && c != '\\r' && c && ci < PATH_MAX);\n\n                    fname [ci++] = '\\0';\n                    matches = realloc (matches, ++num_files * sizeof (*matches));\n\n                    for (di = num_files - 1; di > file_index + 1; di--)\n                        matches [di] = matches [di - 1];\n\n                    matches [++file_index] = fname;\n                }\n\n                if (!c)\n                    break;\n            }\n\n            fclose (list);\n            free (listbuff);\n            free (infilename);\n        }\n#if defined (_WIN32)\n        else if (filespec_wild (infilename)) {\n            wchar_t *winfilename = utf8_to_utf16(infilename);\n            struct _wfinddata_t _wfinddata_t;\n            intptr_t file;\n            int di;\n\n            for (di = file_index; di < num_files - 1; di++)\n                matches [di] = matches [di + 1];\n\n            file_index--;\n            num_files--;\n\n            if ((file = _wfindfirst (winfilename, &_wfinddata_t)) != (intptr_t) -1) {\n                do {\n                    char *name_utf8;\n\n                    if (!(_wfinddata_t.attrib & _A_SUBDIR) && (name_utf8 = utf16_to_utf8(_wfinddata_t.name))) {\n                        matches = realloc (matches, ++num_files * sizeof (*matches));\n\n                        for (di = num_files - 1; di > file_index + 1; di--)\n                            matches [di] = matches [di - 1];\n\n                        matches [++file_index] = malloc (strlen (infilename) + strlen (name_utf8) + 10);\n                        strcpy (matches [file_index], infilename);\n                        *filespec_name (matches [file_index]) = '\\0';\n                        strcat (matches [file_index], name_utf8);\n                        free (name_utf8);\n                    }\n                } while (_wfindnext (file, &_wfinddata_t) == 0);\n\n                _findclose (file);\n            }\n\n            free (winfilename);\n            free (infilename);\n        }\n#endif\n    }\n\n    // If the outfile specification begins with a '@', then it actually points\n    // to a file that contains the output specification. This was included for\n    // use by Wim Speekenbrink's frontends because certain filenames could not\n    // be passed on the command-line, but could be used for other purposes.\n\n    if (outfilename && outfilename [0] == '@') {\n        char listbuff [PATH_MAX * 2], *lp = listbuff;\n        FILE *list = fopen (outfilename+1, \""rb\"");\n        int c;\n\n        if (list == NULL) {\n            error_line (\""file %s not found!\"", outfilename+1);\n            free(outfilename);\n            return 1;\n        }\n\n        memset (listbuff, 0, sizeof (listbuff));\n        c = (int) fread (listbuff, 1, sizeof (listbuff) - 1, list);   // assign c only to suppress warning\n\n#if defined (_WIN32)\n        TextToUTF8 (listbuff, PATH_MAX * 2);\n#endif\n\n        while ((c = *lp++) == '\\n' || c == '\\r');\n\n        if (c) {\n            int ci = 0;\n\n            do\n                outfilename [ci++] = c;\n            while ((c = *lp++) != '\\n' && c != '\\r' && c && ci < PATH_MAX);\n\n            outfilename [ci] = '\\0';\n        }\n        else {\n            error_line (\""output spec file is empty!\"");\n            free(outfilename);\n            fclose (list);\n            return 1;\n        }\n\n        fclose (list);\n    }\n\n    // if we found any files to process, this is where we start\n\n    if (num_files) {\n        if (outfilename && *outfilename != '-') {\n            outpath = (filespec_path (outfilename) != NULL);\n\n            if (num_files > 1 && !outpath) {\n                error_line (\""%s is not a valid output path\"", outfilename);\n                free (outfilename);\n                return 1;\n            }\n        }\n        else\n            outpath = 0;\n\n        add_extension = !outfilename || outpath || !filespec_ext (outfilename);\n\n        // loop through and process files in list\n\n        for (file_index = 0; file_index < num_files; ++file_index) {\n            if (check_break ())\n                break;\n\n            // generate output filename\n\n            if (outpath) {\n                strcat (outfilename, filespec_name (matches [file_index]));\n\n                if (filespec_ext (outfilename))\n                    *filespec_ext (outfilename) = '\\0';\n            }\n            else if (!outfilename) {\n                outfilename = malloc (strlen (matches [file_index]) + 10);\n                strcpy (outfilename, matches [file_index]);\n\n                if (filespec_ext (outfilename))\n                    *filespec_ext (outfilename) = '\\0';\n            }\n\n            if (num_files > 1 && !quiet_mode) {\n                fprintf (stderr, \""\\n%s:\\n\"", matches [file_index]);\n                fflush (stderr);\n            }\n\n            if (verify_only > 1) {\n                result = quick_verify_file (matches [file_index], verify_only > 2);\n\n                // quick_verify_file() returns hard error to mean file cannot be quickly verified\n                // because it has no block checksums, so fall back to standard slow verify\n\n                if (result == WAVPACK_HARD_ERROR)\n                    result = unpack_file (matches [file_index], NULL, 0);\n            }\n            else\n                result = unpack_file (matches [file_index], verify_only ? NULL : outfilename, add_extension);\n\n            if (result != WAVPACK_NO_ERROR)\n                ++error_count;\n\n            if (result == WAVPACK_HARD_ERROR)\n                break;\n\n            // clean up in preparation for potentially another file\n\n            if (outpath) {\n                if (filespec_name (outfilename))\n                    *filespec_name (outfilename) = '\\0';\n            }\n            else if (*outfilename != '-') {\n                free (outfilename);\n                outfilename = NULL;\n            }\n\n            free (matches [file_index]);\n        }\n\n        if (num_files > 1) {\n            if (error_count) {\n                fprintf (stderr, \""\\n **** warning: errors occurred in %d of %d files! ****\\n\"", error_count, num_files);\n                fflush (stderr);\n            }\n            else if (!quiet_mode) {\n                fprintf (stderr, \""\\n **** %d files successfully processed ****\\n\"", num_files);\n                fflush (stderr);\n            }\n        }\n\n        free (matches);\n    }\n    else {\n        error_line (\""nothing to do!\"");\n        ++error_count;\n    }\n\n    if (outfilename)\n        free (outfilename);\n\n    if (set_console_title)\n        DoSetConsoleTitle (\""WvUnpack Completed\"");\n\n    return error_count ? 1 : 0;\n}""}, {""func_name"": ""process_metadata"", ""file_path"": ""src/open_utils.c"", ""func_code"": ""static int process_metadata (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    WavpackStream *wps = wpc->streams [wpc->current_stream];\n\n    switch (wpmd->id) {\n        case ID_DUMMY:\n            return TRUE;\n\n        case ID_DECORR_TERMS:\n            return read_decorr_terms (wps, wpmd);\n\n        case ID_DECORR_WEIGHTS:\n            return read_decorr_weights (wps, wpmd);\n\n        case ID_DECORR_SAMPLES:\n            return read_decorr_samples (wps, wpmd);\n\n        case ID_ENTROPY_VARS:\n            return read_entropy_vars (wps, wpmd);\n\n        case ID_HYBRID_PROFILE:\n            return read_hybrid_profile (wps, wpmd);\n\n        case ID_SHAPING_WEIGHTS:\n            return read_shaping_info (wps, wpmd);\n\n        case ID_FLOAT_INFO:\n            return read_float_info (wps, wpmd);\n\n        case ID_INT32_INFO:\n            return read_int32_info (wps, wpmd);\n\n        case ID_CHANNEL_INFO:\n            return read_channel_info (wpc, wpmd);\n\n        case ID_CHANNEL_IDENTITIES:\n            return read_channel_identities (wpc, wpmd);\n\n        case ID_CONFIG_BLOCK:\n            return read_config_info (wpc, wpmd);\n\n        case ID_NEW_CONFIG_BLOCK:\n            return read_new_config_info (wpc, wpmd);\n\n        case ID_SAMPLE_RATE:\n            return read_sample_rate (wpc, wpmd);\n\n        case ID_WV_BITSTREAM:\n            return init_wv_bitstream (wps, wpmd);\n\n        case ID_WVC_BITSTREAM:\n            return init_wvc_bitstream (wps, wpmd);\n\n        case ID_WVX_BITSTREAM:\n            return init_wvx_bitstream (wps, wpmd);\n\n        case ID_DSD_BLOCK:\n#ifdef ENABLE_DSD\n            return init_dsd_block (wpc, wpmd);\n#else\n            strcpy (wpc->error_message, \""not configured to handle DSD WavPack files!\"");\n            return FALSE;\n#endif\n\n        case ID_ALT_HEADER: case ID_ALT_TRAILER:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_RIFF_HEADER: case ID_RIFF_TRAILER:\n            return read_wrapper_data (wpc, wpmd);\n\n        case ID_ALT_MD5_CHECKSUM:\n            if (!(wpc->open_flags & OPEN_ALT_TYPES))\n                return TRUE;\n\n        case ID_MD5_CHECKSUM:\n            if (wpmd->byte_length == 16) {\n                memcpy (wpc->config.md5_checksum, wpmd->data, 16);\n                wpc->config.flags |= CONFIG_MD5_CHECKSUM;\n                wpc->config.md5_read = 1;\n            }\n\n            return TRUE;\n\n        case ID_ALT_EXTENSION:\n            if (wpmd->byte_length && wpmd->byte_length < sizeof (wpc->file_extension)) {\n                int i, j;\n\n                for (i = j = 0; i < wpmd->byte_length; ++i)\n                    if (isalnum (((char *) wpmd->data) [i]))\n                        wpc->file_extension [j++] = ((char *) wpmd->data) [i];\n\n                wpc->file_extension [j] = 0;\n            }\n\n            return TRUE;\n\n        // we don't actually verify the checksum here (it's done right after the\n        // block is read), but it's a good indicator of version 5 files\n\n        case ID_BLOCK_CHECKSUM:\n            wpc->version_five = 1;\n            return TRUE;\n\n        default:\n            return (wpmd->id & ID_OPTIONAL_DATA) ? TRUE : FALSE;\n    }\n}""}]","{""value"": 1, ""function"": 1}","[{""source"": ""value_info(file:wvunpack.c, value:filespec_name)"", ""result"": {""value_trace"": [{""full_code"": ""*filespec_name (outfilename) = '\\0'"", ""line"": 911, ""func_name"": ""main<duplicate>7""}], ""struct_var"": ""filespec_name"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:filespec_name)"", ""result"": [{""code"": ""char *filespec_name (char *filespec)\n{\n    char *cp = filespec + strlen (filespec);\n\n    while (--cp >= filespec) {\n\n        if (*cp == '\\\\' || *cp == ':')\n            break;\n    }\n\n    if (strlen (cp + 1))\n        return cp + 1;\n    else\n        return NULL;\n}"", ""start_line"": 267, ""end_line"": 281, ""full_name"": ""filespec_name"", ""file_path"": ""cli/utils.c""}, {""code"": ""char *filespec_name (char *filespec)\n{\n    char *cp = filespec + strlen (filespec);\n\n    while (--cp >= filespec)\n        if (*cp == '/')\n            break;\n\n    if (strlen (cp + 1))\n        return cp + 1;\n    else\n        return NULL;\n}"", ""start_line"": 285, ""end_line"": 297, ""full_name"": ""filespec_name<duplicate>0"", ""file_path"": ""cli/utils.c""}]}]","1. `filespec_name(outfilename)` is called in cli/wvunpack.c:908 (original code) without a NULL check.\n2. `filespec_name` (cli/utils.c:267-281/285-297) returns NULL if the filename component after the last path separator is empty (e.g., input ends with a path separator like ""dir/"").\n3. The returned NULL pointer is dereferenced at cli/wvunpack.c:908 (`*filespec_name(...)`), causing a SEGV when writing '\0' to address 0x0.",0.95,./github/other_context/CVE-2022-2476
45,CVE-2022-47022,CWE-476,c_cpp,An issue was discovered in open-mpi hwloc 2.1.0 allows attackers to cause a denial of service or other unspecified impacts via glibc-cpuset in topology-linux.c.,https://github.com/open-mpi/hwloc/commit/ac1f8db9a0790d2bf153711ff4cbf6101f89aace,linux: handle glibc cpuset allocation failures\n\nCloses #544\nCVE-2022-47022\n\nSigned-off-by: Brice Goglin <Brice.Goglin@inria.fr>,5,"[{""func_name"": ""hwloc_linux_get_tid_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""int\nhwloc_linux_get_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_bitmap_t hwloc_set __hwloc_attribute_unused)\n{\n  int err __hwloc_attribute_unused;\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  cpu_set_t *plinux_set;\n  unsigned cpu;\n  int last;\n  size_t setsize;\n  int kernel_nr_cpus;\n\n  /* find the kernel nr_cpus so as to use a large enough cpu_set size */\n  kernel_nr_cpus = hwloc_linux_find_kernel_nr_cpus(topology);\n  setsize = CPU_ALLOC_SIZE(kernel_nr_cpus);\n  plinux_set = CPU_ALLOC(kernel_nr_cpus);\n\n  err = sched_getaffinity(tid, setsize, plinux_set);\n\n  if (err < 0) {\n    CPU_FREE(plinux_set);\n    return -1;\n  }\n\n  last = -1;\n  if (topology->levels[0][0]->complete_cpuset)\n    last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);\n  if (last == -1)\n    /* round the maximal support number, the topology isn't ready yet (complete_cpuset is missing or empty)*/\n    last = kernel_nr_cpus-1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<=(unsigned) last; cpu++)\n    if (CPU_ISSET_S(cpu, setsize, plinux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n\n  CPU_FREE(plinux_set);\n#elif defined(HWLOC_HAVE_CPU_SET)\n  cpu_set_t linux_set;\n  unsigned cpu;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<CPU_SETSIZE; cpu++)\n    if (CPU_ISSET(cpu, &linux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n#elif defined(HWLOC_HAVE_SYSCALL)\n  unsigned long mask;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_from_ulong(hwloc_set, mask);\n#else /* !SYSCALL */\n  errno = ENOSYS;\n  return -1;\n#endif /* !SYSCALL */\n\n  return 0;\n}"", ""target"": 0}, {""func_name"": ""hwloc_linux_find_kernel_nr_cpus"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_find_kernel_nr_cpus(hwloc_topology_t topology)\n{\n  static int _nr_cpus = -1;\n  int nr_cpus = _nr_cpus;\n  hwloc_bitmap_t possible_bitmap;\n\n  if (nr_cpus != -1)\n    /* already computed */\n    return nr_cpus;\n\n  if (topology->levels[0][0]->complete_cpuset)\n    /* start with a nr_cpus that may contain the whole topology */\n    nr_cpus = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset) + 1;\n  if (nr_cpus <= 0)\n    /* start from scratch, the topology isn't ready yet (complete_cpuset is missing (-1) or empty (0))*/\n    nr_cpus = 1;\n\n  /* reading /sys/devices/system/cpu/kernel_max would be easier (single value to parse instead of a list),\n   * but its value may be way too large (5119 on CentOS7).\n   * /sys/devices/system/cpu/possible is better because it matches the current hardware.\n   */\n\n  possible_bitmap = hwloc__alloc_read_path_as_cpulist(\""/sys/devices/system/cpu/possible\"", -1); /* binding only supported in real fsroot, no need for data->root_fd */\n  if (possible_bitmap) {\n    int max_possible = hwloc_bitmap_last(possible_bitmap);\n    hwloc_debug_bitmap(\""possible CPUs are %s\\n\"", possible_bitmap);\n    if (nr_cpus < max_possible + 1)\n      nr_cpus = max_possible + 1;\n    hwloc_bitmap_free(possible_bitmap);\n  }\n\n  while (1) {\n    cpu_set_t *set = CPU_ALLOC(nr_cpus);\n    size_t setsize = CPU_ALLOC_SIZE(nr_cpus);\n    int err = sched_getaffinity(0, setsize, set); /* always works, unless setsize is too small */\n    CPU_FREE(set);\n    nr_cpus = setsize * 8; /* that's the value that was actually tested */\n    if (!err)\n      /* Found it. Only update the static value with the final one,\n       * to avoid sharing intermediate values that we modify,\n       * in case there's ever multiple concurrent calls.\n       */\n      return _nr_cpus = nr_cpus;\n    nr_cpus *= 2;\n  }\n}"", ""target"": 0}, {""func_name"": ""hwloc_linux_set_tid_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""int\nhwloc_linux_set_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_const_bitmap_t hwloc_set __hwloc_attribute_unused)\n{\n  /* The resulting binding is always strict */\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  cpu_set_t *plinux_set;\n  unsigned cpu;\n  int last;\n  size_t setsize;\n  int err;\n\n  last = hwloc_bitmap_last(hwloc_set);\n  if (last == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  setsize = CPU_ALLOC_SIZE(last+1);\n  plinux_set = CPU_ALLOC(last+1);\n\n  CPU_ZERO_S(setsize, plinux_set);\n  hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n    CPU_SET_S(cpu, setsize, plinux_set);\n  hwloc_bitmap_foreach_end();\n\n  err = sched_setaffinity(tid, setsize, plinux_set);\n\n  CPU_FREE(plinux_set);\n  return err;\n#elif defined(HWLOC_HAVE_CPU_SET)\n  cpu_set_t linux_set;\n  unsigned cpu;\n\n  CPU_ZERO(&linux_set);\n  hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n    CPU_SET(cpu, &linux_set);\n  hwloc_bitmap_foreach_end();\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  return sched_setaffinity(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  return sched_setaffinity(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n#elif defined(HWLOC_HAVE_SYSCALL)\n  unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  return sched_setaffinity(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  return sched_setaffinity(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n#else /* !SYSCALL */\n  errno = ENOSYS;\n  return -1;\n#endif /* !SYSCALL */\n}"", ""target"": 0}, {""func_name"": ""hwloc_linux_get_thread_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_get_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  int err;\n\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  if (!pthread_self) {\n    /* ?! Application uses set_thread_cpubind, but doesn't link against libpthread ?! */\n    errno = ENOSYS;\n    return -1;\n  }\n  if (tid == pthread_self())\n    return hwloc_linux_get_tid_cpubind(topology, 0, hwloc_set);\n\n  if (!pthread_getaffinity_np) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t *plinux_set;\n     unsigned cpu;\n     int last;\n     size_t setsize;\n\n     last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);\n     assert (last != -1);\n\n     setsize = CPU_ALLOC_SIZE(last+1);\n     plinux_set = CPU_ALLOC(last+1);\n\n     err = pthread_getaffinity_np(tid, setsize, plinux_set);\n     if (err) {\n        CPU_FREE(plinux_set);\n        errno = err;\n        return -1;\n     }\n\n     hwloc_bitmap_zero(hwloc_set);\n     for(cpu=0; cpu<=(unsigned) last; cpu++)\n       if (CPU_ISSET_S(cpu, setsize, plinux_set))\n\t hwloc_bitmap_set(hwloc_set, cpu);\n\n     CPU_FREE(plinux_set);\n  }\n#elif defined(HWLOC_HAVE_CPU_SET)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t linux_set;\n     unsigned cpu;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n     err = pthread_getaffinity_np(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     err = pthread_getaffinity_np(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     if (err) {\n        errno = err;\n        return -1;\n     }\n\n     hwloc_bitmap_zero(hwloc_set);\n     for(cpu=0; cpu<CPU_SETSIZE; cpu++)\n       if (CPU_ISSET(cpu, &linux_set))\n\t hwloc_bitmap_set(hwloc_set, cpu);\n  }\n#else /* CPU_SET */\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n      unsigned long mask;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n      err = pthread_getaffinity_np(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      err = pthread_getaffinity_np(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      if (err) {\n        errno = err;\n        return -1;\n      }\n\n     hwloc_bitmap_from_ulong(hwloc_set, mask);\n  }\n#endif /* CPU_SET */\n\n  return 0;\n}"", ""target"": 0}, {""func_name"": ""hwloc_linux_set_thread_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_set_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_const_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  int err;\n\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  if (!pthread_self) {\n    /* ?! Application uses set_thread_cpubind, but doesn't link against libpthread ?! */\n    errno = ENOSYS;\n    return -1;\n  }\n  if (tid == pthread_self())\n    return hwloc_linux_set_tid_cpubind(topology, 0, hwloc_set);\n\n  if (!pthread_setaffinity_np) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t *plinux_set;\n     unsigned cpu;\n     int last;\n     size_t setsize;\n\n     last = hwloc_bitmap_last(hwloc_set);\n     if (last == -1) {\n       errno = EINVAL;\n       return -1;\n     }\n\n     setsize = CPU_ALLOC_SIZE(last+1);\n     plinux_set = CPU_ALLOC(last+1);\n\n     CPU_ZERO_S(setsize, plinux_set);\n     hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n         CPU_SET_S(cpu, setsize, plinux_set);\n     hwloc_bitmap_foreach_end();\n\n     err = pthread_setaffinity_np(tid, setsize, plinux_set);\n\n     CPU_FREE(plinux_set);\n  }\n#elif defined(HWLOC_HAVE_CPU_SET)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t linux_set;\n     unsigned cpu;\n\n     CPU_ZERO(&linux_set);\n     hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n         CPU_SET(cpu, &linux_set);\n     hwloc_bitmap_foreach_end();\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n     err = pthread_setaffinity_np(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     err = pthread_setaffinity_np(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  }\n#else /* CPU_SET */\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n      unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n      err = pthread_setaffinity_np(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      err = pthread_setaffinity_np(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  }\n#endif /* CPU_SET */\n\n  if (err) {\n    errno = err;\n    return -1;\n  }\n  return 0;\n}"", ""target"": 0}]","[{""func_name"": ""hwloc_linux_get_tid_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""int\nhwloc_linux_get_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_bitmap_t hwloc_set __hwloc_attribute_unused)\n{\n  int err __hwloc_attribute_unused;\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  cpu_set_t *plinux_set;\n  unsigned cpu;\n  int last;\n  size_t setsize;\n  int kernel_nr_cpus;\n\n  /* find the kernel nr_cpus so as to use a large enough cpu_set size */\n  kernel_nr_cpus = hwloc_linux_find_kernel_nr_cpus(topology);\n  if (kernel_nr_cpus < 0)\n    return -1;\n  setsize = CPU_ALLOC_SIZE(kernel_nr_cpus);\n  plinux_set = CPU_ALLOC(kernel_nr_cpus);\n  if (!plinux_set)\n    return -1;\n\n  err = sched_getaffinity(tid, setsize, plinux_set);\n\n  if (err < 0) {\n    CPU_FREE(plinux_set);\n    return -1;\n  }\n\n  last = -1;\n  if (topology->levels[0][0]->complete_cpuset)\n    last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);\n  if (last == -1)\n    /* round the maximal support number, the topology isn't ready yet (complete_cpuset is missing or empty)*/\n    last = kernel_nr_cpus-1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<=(unsigned) last; cpu++)\n    if (CPU_ISSET_S(cpu, setsize, plinux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n\n  CPU_FREE(plinux_set);\n#elif defined(HWLOC_HAVE_CPU_SET)\n  cpu_set_t linux_set;\n  unsigned cpu;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<CPU_SETSIZE; cpu++)\n    if (CPU_ISSET(cpu, &linux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n#elif defined(HWLOC_HAVE_SYSCALL)\n  unsigned long mask;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_from_ulong(hwloc_set, mask);\n#else /* !SYSCALL */\n  errno = ENOSYS;\n  return -1;\n#endif /* !SYSCALL */\n\n  return 0;\n}""}, {""func_name"": ""hwloc_linux_find_kernel_nr_cpus"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_find_kernel_nr_cpus(hwloc_topology_t topology)\n{\n  static int _nr_cpus = -1;\n  int nr_cpus = _nr_cpus;\n  hwloc_bitmap_t possible_bitmap;\n\n  if (nr_cpus != -1)\n    /* already computed */\n    return nr_cpus;\n\n  if (topology->levels[0][0]->complete_cpuset)\n    /* start with a nr_cpus that may contain the whole topology */\n    nr_cpus = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset) + 1;\n  if (nr_cpus <= 0)\n    /* start from scratch, the topology isn't ready yet (complete_cpuset is missing (-1) or empty (0))*/\n    nr_cpus = 1;\n\n  /* reading /sys/devices/system/cpu/kernel_max would be easier (single value to parse instead of a list),\n   * but its value may be way too large (5119 on CentOS7).\n   * /sys/devices/system/cpu/possible is better because it matches the current hardware.\n   */\n\n  possible_bitmap = hwloc__alloc_read_path_as_cpulist(\""/sys/devices/system/cpu/possible\"", -1); /* binding only supported in real fsroot, no need for data->root_fd */\n  if (possible_bitmap) {\n    int max_possible = hwloc_bitmap_last(possible_bitmap);\n    hwloc_debug_bitmap(\""possible CPUs are %s\\n\"", possible_bitmap);\n    if (nr_cpus < max_possible + 1)\n      nr_cpus = max_possible + 1;\n    hwloc_bitmap_free(possible_bitmap);\n  }\n\n  while (1) {\n    cpu_set_t *set = CPU_ALLOC(nr_cpus);\n    size_t setsize = CPU_ALLOC_SIZE(nr_cpus);\n    int err;\n    if (!set)\n      return -1; /* caller will return an error, and we'll try again later */\n    err = sched_getaffinity(0, setsize, set); /* always works, unless setsize is too small */\n    CPU_FREE(set);\n    nr_cpus = setsize * 8; /* that's the value that was actually tested */\n    if (!err)\n      /* Found it. Only update the static value with the final one,\n       * to avoid sharing intermediate values that we modify,\n       * in case there's ever multiple concurrent calls.\n       */\n      return _nr_cpus = nr_cpus;\n    nr_cpus *= 2;\n  }\n}""}, {""func_name"": ""hwloc_linux_set_tid_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""int\nhwloc_linux_set_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_const_bitmap_t hwloc_set __hwloc_attribute_unused)\n{\n  /* The resulting binding is always strict */\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  cpu_set_t *plinux_set;\n  unsigned cpu;\n  int last;\n  size_t setsize;\n  int err;\n\n  last = hwloc_bitmap_last(hwloc_set);\n  if (last == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  setsize = CPU_ALLOC_SIZE(last+1);\n  plinux_set = CPU_ALLOC(last+1);\n  if (!plinux_set)\n    return -1;\n\n  CPU_ZERO_S(setsize, plinux_set);\n  hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n    CPU_SET_S(cpu, setsize, plinux_set);\n  hwloc_bitmap_foreach_end();\n\n  err = sched_setaffinity(tid, setsize, plinux_set);\n\n  CPU_FREE(plinux_set);\n  return err;\n#elif defined(HWLOC_HAVE_CPU_SET)\n  cpu_set_t linux_set;\n  unsigned cpu;\n\n  CPU_ZERO(&linux_set);\n  hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n    CPU_SET(cpu, &linux_set);\n  hwloc_bitmap_foreach_end();\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  return sched_setaffinity(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  return sched_setaffinity(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n#elif defined(HWLOC_HAVE_SYSCALL)\n  unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  return sched_setaffinity(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  return sched_setaffinity(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n#else /* !SYSCALL */\n  errno = ENOSYS;\n  return -1;\n#endif /* !SYSCALL */\n}""}, {""func_name"": ""hwloc_linux_get_thread_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_get_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  int err;\n\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  if (!pthread_self) {\n    /* ?! Application uses set_thread_cpubind, but doesn't link against libpthread ?! */\n    errno = ENOSYS;\n    return -1;\n  }\n  if (tid == pthread_self())\n    return hwloc_linux_get_tid_cpubind(topology, 0, hwloc_set);\n\n  if (!pthread_getaffinity_np) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t *plinux_set;\n     unsigned cpu;\n     int last;\n     size_t setsize;\n\n     last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);\n     assert (last != -1);\n\n     setsize = CPU_ALLOC_SIZE(last+1);\n     plinux_set = CPU_ALLOC(last+1);\n     if (!plinux_set)\n       return -1;\n\n     err = pthread_getaffinity_np(tid, setsize, plinux_set);\n     if (err) {\n        CPU_FREE(plinux_set);\n        errno = err;\n        return -1;\n     }\n\n     hwloc_bitmap_zero(hwloc_set);\n     for(cpu=0; cpu<=(unsigned) last; cpu++)\n       if (CPU_ISSET_S(cpu, setsize, plinux_set))\n\t hwloc_bitmap_set(hwloc_set, cpu);\n\n     CPU_FREE(plinux_set);\n  }\n#elif defined(HWLOC_HAVE_CPU_SET)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t linux_set;\n     unsigned cpu;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n     err = pthread_getaffinity_np(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     err = pthread_getaffinity_np(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     if (err) {\n        errno = err;\n        return -1;\n     }\n\n     hwloc_bitmap_zero(hwloc_set);\n     for(cpu=0; cpu<CPU_SETSIZE; cpu++)\n       if (CPU_ISSET(cpu, &linux_set))\n\t hwloc_bitmap_set(hwloc_set, cpu);\n  }\n#else /* CPU_SET */\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n      unsigned long mask;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n      err = pthread_getaffinity_np(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      err = pthread_getaffinity_np(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      if (err) {\n        errno = err;\n        return -1;\n      }\n\n     hwloc_bitmap_from_ulong(hwloc_set, mask);\n  }\n#endif /* CPU_SET */\n\n  return 0;\n}""}, {""func_name"": ""hwloc_linux_set_thread_cpubind"", ""file_path"": ""hwloc/topology-linux.c"", ""func_code"": ""static int\nhwloc_linux_set_thread_cpubind(hwloc_topology_t topology, pthread_t tid, hwloc_const_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  int err;\n\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  if (!pthread_self) {\n    /* ?! Application uses set_thread_cpubind, but doesn't link against libpthread ?! */\n    errno = ENOSYS;\n    return -1;\n  }\n  if (tid == pthread_self())\n    return hwloc_linux_set_tid_cpubind(topology, 0, hwloc_set);\n\n  if (!pthread_setaffinity_np) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t *plinux_set;\n     unsigned cpu;\n     int last;\n     size_t setsize;\n\n     last = hwloc_bitmap_last(hwloc_set);\n     if (last == -1) {\n       errno = EINVAL;\n       return -1;\n     }\n\n     setsize = CPU_ALLOC_SIZE(last+1);\n     plinux_set = CPU_ALLOC(last+1);\n     if (!plinux_set)\n       return -1;\n\n     CPU_ZERO_S(setsize, plinux_set);\n     hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n         CPU_SET_S(cpu, setsize, plinux_set);\n     hwloc_bitmap_foreach_end();\n\n     err = pthread_setaffinity_np(tid, setsize, plinux_set);\n\n     CPU_FREE(plinux_set);\n  }\n#elif defined(HWLOC_HAVE_CPU_SET)\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n     cpu_set_t linux_set;\n     unsigned cpu;\n\n     CPU_ZERO(&linux_set);\n     hwloc_bitmap_foreach_begin(cpu, hwloc_set)\n         CPU_SET(cpu, &linux_set);\n     hwloc_bitmap_foreach_end();\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n     err = pthread_setaffinity_np(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n     err = pthread_setaffinity_np(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  }\n#else /* CPU_SET */\n  /* Use a separate block so that we can define specific variable\n     types here */\n  {\n      unsigned long mask = hwloc_bitmap_to_ulong(hwloc_set);\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n      err = pthread_setaffinity_np(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n      err = pthread_setaffinity_np(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  }\n#endif /* CPU_SET */\n\n  if (err) {\n    errno = err;\n    return -1;\n  }\n  return 0;\n}""}]","{""caller"": 3}","[{""source"": ""caller_info(file:topology-linux.c, func:hwloc_linux_get_tid_cpubind)"", ""result"": [{""call_line"": 1205, ""call_code"": ""hwloc_linux_get_tid_cpubind(topology, tid, tidset)"", ""caller_code"": ""static int\nhwloc_linux_foreach_proc_tid_get_cpubind_cb(hwloc_topology_t topology, pid_t tid, void *_data, int idx)\n{\n  struct hwloc_linux_foreach_proc_tid_get_cpubind_cb_data_s *data = _data;\n  hwloc_bitmap_t cpuset = data->cpuset;\n  hwloc_bitmap_t tidset = data->tidset;\n  int flags = data->flags;\n\n  if (hwloc_linux_get_tid_cpubind(topology, tid, tidset))\n    return -1;\n\n  /* reset the cpuset on first iteration */\n  if (!idx)\n    hwloc_bitmap_zero(cpuset);\n\n  if (flags & HWLOC_CPUBIND_STRICT) {\n    /* if STRICT, we want all threads to have the same binding */\n    if (!idx) {\n      /* this is the first thread, copy its binding */\n      hwloc_bitmap_copy(cpuset, tidset);\n    } else if (!hwloc_bitmap_isequal(cpuset, tidset)) {\n      /* this is not the first thread, and it's binding is different */\n      errno = EXDEV;\n      return -1;\n    }\n  } else {\n    /* if not STRICT, just OR all thread bindings */\n    hwloc_bitmap_or(cpuset, cpuset, tidset);\n  }\n  return 0;\n}"", ""caller_start"": 1197, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 1263, ""call_code"": ""hwloc_linux_get_tid_cpubind(topology, pid, hwloc_set)"", ""caller_code"": ""static int\nhwloc_linux_get_proc_cpubind(hwloc_topology_t topology, pid_t pid, hwloc_bitmap_t hwloc_set, int flags)\n{\n  if (pid == 0)\n    pid = topology->pid;\n  if (flags & HWLOC_CPUBIND_THREAD)\n    return hwloc_linux_get_tid_cpubind(topology, pid, hwloc_set);\n  else\n    return hwloc_linux_get_pid_cpubind(topology, pid, hwloc_set, flags);\n}"", ""caller_start"": 1257, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 1297, ""call_code"": ""hwloc_linux_get_tid_cpubind(topology, 0, hwloc_set)"", ""caller_code"": ""static int\nhwloc_linux_get_thisthread_cpubind(hwloc_topology_t topology, hwloc_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n  return hwloc_linux_get_tid_cpubind(topology, 0, hwloc_set);\n}"", ""caller_start"": 1290, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 199, ""call_code"": ""hwloc_linux_get_tid_cpubind(topology, tid, cpuset)"", ""caller_code"": ""int hwloc_ps_read_process(hwloc_topology_t topology, hwloc_const_bitmap_t topocpuset,\n\t\t\t  struct hwloc_ps_process *proc,\n\t\t\t  unsigned long flags)\n{\n#ifdef HAVE_DIRENT_H\n  hwloc_pid_t realpid;\n  hwloc_bitmap_t cpuset;\n  unsigned pathlen;\n  char *path;\n  int fd;\n  ssize_t n;\n\n  if (hwloc_pid_from_number(&realpid, proc->pid, 0, 0 /* ignore failures */) < 0)\n    return -1;\n\n  cpuset = hwloc_bitmap_alloc();\n  if (!cpuset)\n    return -1;\n\n  pathlen = 6 + 21 + 1 + 7 + 1; /* enough for /proc/%ld/cmdline /proc/%ld/comm and /proc/%ld/stat */\n  path = malloc(pathlen);\n\n  snprintf(path, pathlen, \""/proc/%ld/cmdline\"", proc->pid);\n  fd = open(path, O_RDONLY);\n  if (fd < 0) {\n    free(path);\n    goto out;\n  }\n  n = read(fd, proc->name, sizeof(proc->name) - 1);\n  close(fd);\n  if (n <= 0) {\n    /* Ignore kernel threads and errors */\n    free(path);\n    goto out;\n  }\n  proc->name[n] = '\\0';\n\n  if (flags & HWLOC_PS_FLAG_SHORTNAME) {\n    /* try to get a small name from comm */\n    char comm[16] = \""\"";\n    snprintf(path, pathlen, \""/proc/%ld/comm\"", proc->pid);\n    fd = open(path, O_RDONLY);\n    if (fd >= 0) {\n      n = read(fd, comm, sizeof(comm) - 1);\n      close(fd);\n      if (n > 0) {\n\tcomm[n] = '\\0';\n\tif (n > 1 && comm[n-1] == '\\n')\n\t  comm[n-1] = '\\0';\n      }\n\n    } else {\n      /* Old kernel, have to look at old file */\n      char stats[32];\n      char *parenl = NULL, *parenr;\n\n      snprintf(path, pathlen, \""/proc/%ld/stat\"", proc->pid);\n      fd = open(path, O_RDONLY);\n      if (fd >= 0) {\n\t/* \""pid (comm) ...\"" */\n\tn = read(fd, stats, sizeof(stats) - 1);\n\tclose(fd);\n\tif (n > 0) {\n\t  stats[n] = '\\0';\n\t  parenl = strchr(stats, '(');\n\t  parenr = strchr(stats, ')');\n\t  if (!parenr)\n\t    parenr = &stats[sizeof(stats)-1];\n\t  *parenr = '\\0';\n\t  if (parenl)\n\t    snprintf(comm, sizeof(comm), \""%s\"", parenl+1);\n\t}\n      }\n    }\n\n    if (*comm)\n      snprintf(proc->name, sizeof(proc->name), \""%s\"", comm);\n  }\n\n  free(path);\n\n  proc->string[0] = '\\0'; /* might be set later if hwloc_ps_pidcmd is called */\n\n  if (flags & HWLOC_PS_FLAG_UID) {\n    proc->uid = HWLOC_PS_ALL_UIDS;\n#ifdef HWLOC_LINUX_SYS\n    pathlen = 6 + 21 + 1 + 6 + 1;\n    path = malloc(pathlen);\n    snprintf(path, pathlen, \""/proc/%ld/status\"", proc->pid);\n    fd = open(path, O_RDONLY);\n    if (fd >= 0) {\n      char status[1024];\n      char *uid;\n      if (read(fd, &status, sizeof(status)) > 0) {\n        status[1023] = '\\0';\n        uid = strstr(status, \""Uid:\"");\n        if (uid)\n          proc->uid = strtoul(uid+4, NULL, 0);\n        close(fd);\n      }\n    }\n    free(path);\n#endif\n    /* On *BSD, parse the end of the single-line in /proc/pid/status\n     * (but the format is different between FreeBSD and NetBSD).\n     * It may be a good time to switch to a portable library for gathering this info.\n     */\n  }\n\n  if (flags & HWLOC_PS_FLAG_THREADS) {\n#ifdef HWLOC_LINUX_SYS\n    /* check if some threads must be displayed */\n    DIR *taskdir;\n\n    pathlen = 6 + 21 + 1 + 4 + 1;\n    path = malloc(pathlen);\n    snprintf(path, pathlen, \""/proc/%ld/task\"", proc->pid);\n    taskdir = opendir(path);\n    if (taskdir) {\n      struct dirent *taskdirent;\n      long tid;\n      char *end;\n      unsigned nbth = 0;\n      /* count threads */\n      while ((taskdirent = readdir(taskdir))) {\n\ttid = strtol(taskdirent->d_name, &end, 10);\n\tif (*end)\n\t  /* Not a number */\n\t  continue;\n\tnbth++;\n      }\n      if (nbth > 1) {\n\t/* if there's more than one thread, see if some are bound */\n\tproc->threads = calloc(nbth, sizeof(*proc->threads));\n\tif (proc->threads) {\n\t  /* reread the directory but gather info now */\n\t  rewinddir(taskdir);\n\t  unsigned i = 0;\n\t  while ((taskdirent = readdir(taskdir))) {\n\t    char *path2;\n\t    unsigned path2len;\n\n\t    tid = strtol(taskdirent->d_name, &end, 10);\n\t    if (*end)\n\t      /* Not a number */\n\t      continue;\n\n\t    proc->threads[i].tid = tid;\n\n\t    path2len = pathlen + 1 + 21 + 1 + 4 + 1;\n\t    path2 = malloc(path2len);\n\t    if (path2) {\n\t      int commfd;\n\t      snprintf(path2, path2len, \""%s/%ld/comm\"", path, tid);\n\t      commfd = open(path2, O_RDWR);\n\t      if (commfd >= 0) {\n\t\tn = read(commfd, proc->threads[i].name, sizeof(proc->threads[i].name));\n\t\tclose(commfd);\n\t\tif (n <= 0)\n\t\t  proc->threads[i].name[0] = '\\0';\n\t\telse if ((size_t)n < sizeof(proc->threads[i].name))\n\t\t  proc->threads[i].name[n] = '\\0';\n\t\tproc->threads[i].name[sizeof(proc->threads[i].name)-1] = '\\0';\n\t\tend = strchr(proc->threads[i].name, '\\n');\n\t\tif (end)\n\t\t  *end = '\\0';\n\t      }\n\t      free(path2);\n\t    }\n\n\t    if (flags & HWLOC_PS_FLAG_LASTCPULOCATION) {\n\t      if (hwloc_linux_get_tid_last_cpu_location(topology, tid, cpuset))\n\t\tgoto next;\n\t    } else {\n\t      if (hwloc_linux_get_tid_cpubind(topology, tid, cpuset))\n\t\tgoto next;\n\t    }\n\t    hwloc_bitmap_and(cpuset, cpuset, topocpuset);\n\t    if (hwloc_bitmap_iszero(cpuset))\n\t      goto next;\n\n\t    proc->threads[i].cpuset = hwloc_bitmap_dup(cpuset);\n\t    if (!hwloc_bitmap_isequal(cpuset, topocpuset)) {\n\t      proc->threads[i].bound = 1;\n\t      proc->nboundthreads++;\n\t    }\n\n\t  next:\n\t    i++;\n\t    proc->nthreads++;\n\t    if (i == nbth)\n\t      /* ignore the lastly created threads, I'm too lazy to reallocate */\n\t      break;\n\t  }\n\t} else {\n\t  /* failed to alloc, behave as if there were no threads */\n\t}\n      }\n      closedir(taskdir);\n    }\n    free(path);\n#endif /* HWLOC_LINUX_SYS */\n  }\n\n  if (flags & HWLOC_PS_FLAG_LASTCPULOCATION) {\n    if (hwloc_get_proc_last_cpu_location(topology, realpid, cpuset, 0))\n      goto out;\n  } else {\n    if (hwloc_get_proc_cpubind(topology, realpid, cpuset, 0))\n      goto out;\n  }\n\n  hwloc_bitmap_and(cpuset, cpuset, topocpuset);\n  if (hwloc_bitmap_iszero(cpuset))\n    goto out;\n\n  proc->bound = !hwloc_bitmap_isequal(cpuset, topocpuset);\n  proc->cpuset = cpuset;\n  return 0;\n\n out:\n  hwloc_bitmap_free(cpuset);\n#endif /* HAVE_DIRENT_H */\n  return -1;\n}\n"", ""caller_start"": 25, ""file_path"": ""utils/hwloc/common-ps.c""}]}, {""source"": ""caller_info(file:topology-linux.c, func:hwloc_linux_find_kernel_nr_cpus)"", ""result"": [{""call_line"": 988, ""call_code"": ""hwloc_linux_find_kernel_nr_cpus(topology)"", ""caller_code"": ""int\nhwloc_linux_get_tid_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, pid_t tid __hwloc_attribute_unused, hwloc_bitmap_t hwloc_set __hwloc_attribute_unused)\n{\n  int err __hwloc_attribute_unused;\n\n#if defined(HWLOC_HAVE_CPU_SET_S) && !defined(HWLOC_HAVE_OLD_SCHED_SETAFFINITY)\n  cpu_set_t *plinux_set;\n  unsigned cpu;\n  int last;\n  size_t setsize;\n  int kernel_nr_cpus;\n\n  /* find the kernel nr_cpus so as to use a large enough cpu_set size */\n  kernel_nr_cpus = hwloc_linux_find_kernel_nr_cpus(topology);\n  setsize = CPU_ALLOC_SIZE(kernel_nr_cpus);\n  plinux_set = CPU_ALLOC(kernel_nr_cpus);\n\n  err = sched_getaffinity(tid, setsize, plinux_set);\n\n  if (err < 0) {\n    CPU_FREE(plinux_set);\n    return -1;\n  }\n\n  last = -1;\n  if (topology->levels[0][0]->complete_cpuset)\n    last = hwloc_bitmap_last(topology->levels[0][0]->complete_cpuset);\n  if (last == -1)\n    /* round the maximal support number, the topology isn't ready yet (complete_cpuset is missing or empty)*/\n    last = kernel_nr_cpus-1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<=(unsigned) last; cpu++)\n    if (CPU_ISSET_S(cpu, setsize, plinux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n\n  CPU_FREE(plinux_set);\n#elif defined(HWLOC_HAVE_CPU_SET)\n  cpu_set_t linux_set;\n  unsigned cpu;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, &linux_set);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(linux_set), &linux_set);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_zero(hwloc_set);\n  for(cpu=0; cpu<CPU_SETSIZE; cpu++)\n    if (CPU_ISSET(cpu, &linux_set))\n      hwloc_bitmap_set(hwloc_set, cpu);\n#elif defined(HWLOC_HAVE_SYSCALL)\n  unsigned long mask;\n\n#ifdef HWLOC_HAVE_OLD_SCHED_SETAFFINITY\n  err = sched_getaffinity(tid, (void*) &mask);\n#else /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  err = sched_getaffinity(tid, sizeof(mask), (void*) &mask);\n#endif /* HWLOC_HAVE_OLD_SCHED_SETAFFINITY */\n  if (err < 0)\n    return -1;\n\n  hwloc_bitmap_from_ulong(hwloc_set, mask);\n#else /* !SYSCALL */\n  errno = ENOSYS;\n  return -1;\n#endif /* !SYSCALL */\n\n  return 0;\n}\n"", ""caller_start"": 975, ""file_path"": ""hwloc/topology-linux.c""}]}, {""source"": ""caller_info(file:topology-linux.c, func:hwloc_linux_set_tid_cpubind)"", ""result"": [{""call_line"": 1179, ""call_code"": ""hwloc_linux_set_tid_cpubind(topology, tid, (hwloc_bitmap_t) data)"", ""caller_code"": ""static int\nhwloc_linux_foreach_proc_tid_set_cpubind_cb(hwloc_topology_t topology, pid_t tid, void *data, int idx __hwloc_attribute_unused)\n{\n  return hwloc_linux_set_tid_cpubind(topology, tid, (hwloc_bitmap_t) data);\n}"", ""caller_start"": 1176, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 1252, ""call_code"": ""hwloc_linux_set_tid_cpubind(topology, pid, hwloc_set)"", ""caller_code"": ""static int\nhwloc_linux_set_proc_cpubind(hwloc_topology_t topology, pid_t pid, hwloc_const_bitmap_t hwloc_set, int flags)\n{\n  if (pid == 0)\n    pid = topology->pid;\n  if (flags & HWLOC_CPUBIND_THREAD)\n    return hwloc_linux_set_tid_cpubind(topology, pid, hwloc_set);\n  else\n    return hwloc_linux_set_pid_cpubind(topology, pid, hwloc_set, flags);\n}"", ""caller_start"": 1246, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 1287, ""call_code"": ""hwloc_linux_set_tid_cpubind(topology, 0, hwloc_set)"", ""caller_code"": ""static int\nhwloc_linux_set_thisthread_cpubind(hwloc_topology_t topology, hwloc_const_bitmap_t hwloc_set, int flags __hwloc_attribute_unused)\n{\n  if (topology->pid) {\n    errno = ENOSYS;\n    return -1;\n  }\n  return hwloc_linux_set_tid_cpubind(topology, 0, hwloc_set);\n}"", ""caller_start"": 1280, ""file_path"": ""hwloc/topology-linux.c""}, {""call_line"": 575, ""call_code"": ""hwloc_linux_set_tid_cpubind(topology, tid_number, cpubind_set)"", ""caller_code"": ""int main(int argc, char *argv[])\n{\n  hwloc_topology_t topology;\n  int depth = -1;\n  hwloc_bitmap_t cpubind_set, membind_set;\n  int got_cpubind = 0, got_membind = 0;\n  int working_on_cpubind = 1; /* membind if 0 */\n  int get_binding = 0;\n  int use_nodeset = 0;\n  int get_last_cpu_location = 0;\n  unsigned long flags = 0;\n  unsigned long restrict_flags = 0;\n  int force = 0;\n  int single = 0;\n  int verbose = 0;\n  int no_smt = -1;\n  int only_hbm = -1;\n  int logical = 1;\n  int taskset = 0;\n  unsigned cpubind_flags = 0;\n  hwloc_membind_policy_t membind_policy = HWLOC_MEMBIND_BIND;\n  int got_mempolicy = 0;\n  unsigned membind_flags = 0;\n  int opt;\n  int ret;\n  int pid_number = -1;\n  int tid_number = -1;\n  hwloc_pid_t pid = 0; /* only valid when pid_number > 0, but gcc-4.8 still reports uninitialized warnings */\n  hwloc_memattr_id_t best_memattr_id = (hwloc_memattr_id_t) -1;\n  const char *best_memattr_str = NULL;\n  char *callname;\n  char *restrictstring = NULL;\n  struct hwloc_calc_location_context_s lcontext;\n  struct hwloc_calc_set_context_s scontext;\n\n  callname = strrchr(argv[0], '/');\n  if (!callname)\n    callname = argv[0];\n  else\n    callname++;\n\n  /* skip argv[0], handle options */\n  argv++;\n  argc--;\n\n  hwloc_utils_check_api_version(callname);\n\n  cpubind_set = hwloc_bitmap_alloc();\n  membind_set = hwloc_bitmap_alloc();\n\n  while (argc >= 1) {\n    opt = 0;\n\n    if (!strcmp (argv[0], \""--disallowed\"") || !strcmp (argv[0], \""--whole-system\"")) {\n      flags |= HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED;\n      goto next_config;\n    }\n    if (!strcmp (argv[0], \""--restrict\"")) {\n      if (argc < 2) {\n        usage (callname, stderr);\n        exit(EXIT_FAILURE);\n      }\n      if(strncmp(argv[1], \""nodeset=\"", 7))\n        restrictstring = strdup(argv[1]);\n      else {\n        restrictstring = strdup(argv[1]+8);\n        restrict_flags |= HWLOC_RESTRICT_FLAG_BYNODESET;\n      }\n      opt = 1;\n      goto next_config;\n    }\n    if (!strcmp (argv[0], \""--restrict-flags\"")) {\n      if (argc < 2) {\n        usage (callname, stderr);\n        exit(EXIT_FAILURE);\n      }\n      restrict_flags = hwloc_utils_parse_restrict_flags(argv[1]);\n      opt = 1;\n      goto next_config;\n    }\n    if (!strcmp(argv[0], \""--no-smt\"")) {\n      no_smt = 0;\n      goto next_config;\n    }\n    if (!strncmp(argv[0], \""--no-smt=\"", 9)) {\n      no_smt = atoi(argv[0] + 9);\n      goto next_config;\n    }\n    if (!strcmp(argv[0], \""--hbm\"")) {\n      only_hbm = 1;\n      goto next_config;\n    }\n    if (!strcmp(argv[0], \""--no-hbm\"")) {\n      only_hbm = 0;\n      goto next_config;\n    }\n    if (!strcmp (argv[0], \""--best-memattr\"")) {\n      if (argc < 2) {\n        usage (callname, stderr);\n        exit(EXIT_FAILURE);\n      }\n      best_memattr_str = argv[1];\n      opt = 1;\n      goto next_config;\n    }\n\n    break;\n\n  next_config:\n    argc -= opt+1;\n    argv += opt+1;\n  }\n\n  hwloc_topology_init(&topology);\n  hwloc_topology_set_all_types_filter(topology, HWLOC_TYPE_FILTER_KEEP_ALL);\n  hwloc_topology_set_flags(topology, flags);\n  ret = hwloc_topology_load(topology);\n  if (ret < 0) {\n    perror(\""Couldn't load the topology\"");\n    return EXIT_FAILURE;\n  }\n  if (restrictstring) {\n    hwloc_bitmap_t restrictset = hwloc_bitmap_alloc();\n    hwloc_bitmap_sscanf(restrictset, restrictstring);\n    if (hwloc_topology_restrict (topology, restrictset, restrict_flags)) {\n      perror(\""Restricting the topology\"");\n      /* FALLTHRU */\n    }\n    hwloc_bitmap_free(restrictset);\n    free(restrictstring);\n  }\n  depth = hwloc_topology_get_depth(topology);\n\n  while (argc >= 1) {\n    char *location;\n    int nodeset_location;\n\n    if (!strcmp(argv[0], \""--\"")) {\n      argc--;\n      argv++;\n      break;\n    }\n\n    opt = 0;\n\n    if (*argv[0] == '-') {\n      if (!strcmp(argv[0], \""-v\"") || !strcmp(argv[0], \""--verbose\"")) {\n\tverbose++;\n\tgoto next;\n      }\n      if (!strcmp(argv[0], \""-q\"") || !strcmp(argv[0], \""--quiet\"")) {\n\tverbose--;\n\tgoto next;\n      }\n      if (!strcmp(argv[0], \""-h\"") || !strcmp(argv[0], \""--help\"")) {\n        usage(callname, stdout);\n\treturn EXIT_SUCCESS;\n      }\n      if (!strcmp(argv[0], \""--single\"")) {\n\tsingle = 1;\n\tgoto next;\n      }\n      if (!strcmp(argv[0], \""-f\"") || !strcmp(argv[0], \""--force\"")) {\n\tforce = 1;\n\tgoto next;\n      }\n      if (!strcmp(argv[0], \""--strict\"")) {\n\tcpubind_flags |= HWLOC_CPUBIND_STRICT;\n\tmembind_flags |= HWLOC_MEMBIND_STRICT;\n\tgoto next;\n      }\n      if (!strcmp(argv[0], \""--pid\"")) {\n        if (argc < 2) {\n          usage (callname, stderr);\n          exit(EXIT_FAILURE);\n        }\n        pid_number = atoi(argv[1]);\n        opt = 1;\n        goto next;\n      }\n#ifdef HWLOC_LINUX_SYS\n      if (!strcmp(argv[0], \""--tid\"")) {\n        if (argc < 2) {\n          usage (callname, stderr);\n          exit(EXIT_FAILURE);\n        }\n        tid_number = atoi(argv[1]);\n        opt = 1;\n        goto next;\n      }\n#endif\n      if (!strcmp (argv[0], \""--version\"")) {\n\tprintf(\""%s %s\\n\"", callname, HWLOC_VERSION);\n\texit(EXIT_SUCCESS);\n      }\n      if (!strcmp(argv[0], \""-l\"") || !strcmp(argv[0], \""--logical\"")) {\n        logical = 1;\n        goto next;\n      }\n      if (!strcmp(argv[0], \""-p\"") || !strcmp(argv[0], \""--physical\"")) {\n        logical = 0;\n        goto next;\n      }\n      if (!strcmp(argv[0], \""--taskset\"")) {\n        taskset = 1;\n        goto next;\n      }\n      if (!strcmp (argv[0], \""-e\"") || !strncmp (argv[0], \""--get-last-cpu-location\"", 10)) {\n\tget_last_cpu_location = 1;\n\tgoto next;\n      }\n      if (!strcmp (argv[0], \""--get\"")) {\n\tget_binding = 1;\n\tgoto next;\n      }\n      if (!strcmp (argv[0], \""--nodeset\"")) {\n\tuse_nodeset = 1;\n\tgoto next;\n      }\n      if (!strcmp (argv[0], \""--cpubind\"")) {\n\tworking_on_cpubind = 1;\n\tgoto next;\n      }\n      if (!strcmp (argv[0], \""--membind\"")) {\n\tworking_on_cpubind = 0;\n\tgoto next;\n      }\n      if (!strcmp (argv[0], \""--mempolicy\"")) {\n\tif (!strncmp(argv[1], \""default\"", 2))\n\t  membind_policy = HWLOC_MEMBIND_DEFAULT;\n\telse if (!strncmp(argv[1], \""firsttouch\"", 2))\n\t  membind_policy = HWLOC_MEMBIND_FIRSTTOUCH;\n\telse if (!strncmp(argv[1], \""bind\"", 2))\n\t  membind_policy = HWLOC_MEMBIND_BIND;\n\telse if (!strncmp(argv[1], \""interleave\"", 2))\n\t  membind_policy = HWLOC_MEMBIND_INTERLEAVE;\n\telse if (!strncmp(argv[1], \""nexttouch\"", 2))\n\t  membind_policy = HWLOC_MEMBIND_NEXTTOUCH;\n\telse {\n\t  fprintf(stderr, \""Unrecognized memory binding policy %s\\n\"", argv[1]);\n          usage (callname, stderr);\n          exit(EXIT_FAILURE);\n\t}\n\tgot_mempolicy = 1;\n\topt = 1;\n\tgoto next;\n      }\n\n      fprintf (stderr, \""Unrecognized option: %s\\n\"", argv[0]);\n      usage(callname, stderr);\n      return EXIT_FAILURE;\n    }\n\n    location = argv[0];\n    nodeset_location = 0;\n    if (!strncmp(location, \""nodeset=\"", 8)) {\n      location += 8;\n      nodeset_location = 1;\n    }\n\n    lcontext.topology = topology;\n    lcontext.topodepth = depth;\n    lcontext.only_hbm = only_hbm;\n    lcontext.logical = logical;\n    lcontext.verbose = verbose;\n    scontext.nodeset_input = use_nodeset || nodeset_location;\n    scontext.nodeset_output = working_on_cpubind ? 0 : 1;\n    scontext.output_set = working_on_cpubind ? cpubind_set : membind_set;\n    ret = hwloc_calc_process_location_as_set(&lcontext, &scontext, location);\n    if (ret < 0) {\n      fprintf(stderr, \""argument `%s' unrecognized, assuming this is the executable.\\n\"", argv[0]);\n      break;\n    }\n    if (working_on_cpubind)\n      got_cpubind = 1;\n    else\n      got_membind = 1;\n\n  next:\n    argc -= opt+1;\n    argv += opt+1;\n  }\n\n  if (pid_number > 0 && tid_number > 0) {\n    fprintf(stderr, \""cannot operate both on tid and pid\\n\"");\n    return EXIT_FAILURE;\n  }\n\n  if (pid_number > 0) {\n    if (hwloc_pid_from_number(&pid, pid_number, !(get_binding || get_last_cpu_location), 1 /* verbose */) < 0) {\n      fprintf(stderr, \""failed to use pid\\n\"");\n      return EXIT_FAILURE;\n    }\n    /* no need to set_pid()\n     * the doc just says we're operating on pid, not that we're retrieving the topo/cpuset as seen from inside pid\n     */\n  }\n\n  if (get_last_cpu_location && !working_on_cpubind) {\n    fprintf(stderr, \""Options --membind and --get-last-cpu-location cannot be combined.\\n\"");\n    return EXIT_FAILURE;\n  }\n  if ((get_binding || get_last_cpu_location) && (got_cpubind || got_membind)) {\n    /* doesn't work because get_binding/get_last_cpu_location overwrites cpubind_set */\n    fprintf(stderr, \""Cannot display and set binding at the same time.\\n\"");\n    return EXIT_FAILURE;\n  }\n\n  if (!got_cpubind && !got_membind && !get_binding && !get_last_cpu_location) {\n    if (verbose >= 0)\n      fprintf(stderr, \""got neither CPU nor memory binding locations.\\n\"");\n  }\n\n  if (get_binding || get_last_cpu_location) {\n    char *s;\n    const char *policystr = NULL;\n    int err;\n    if (working_on_cpubind) {\n      if (get_last_cpu_location) {\n\tif (pid_number > 0)\n\t  err = hwloc_get_proc_last_cpu_location(topology, pid, cpubind_set, 0);\n#ifdef HWLOC_LINUX_SYS\n\telse if (tid_number > 0)\n\t  err = hwloc_linux_get_tid_last_cpu_location(topology, tid_number, cpubind_set);\n#endif\n\telse\n\t  err = hwloc_get_last_cpu_location(topology, cpubind_set, 0);\n      } else {\n\tif (pid_number > 0)\n\t  err = hwloc_get_proc_cpubind(topology, pid, cpubind_set, 0);\n#ifdef HWLOC_LINUX_SYS\n\telse if (tid_number > 0)\n\t  err = hwloc_linux_get_tid_cpubind(topology, tid_number, cpubind_set);\n#endif\n\telse\n\t  err = hwloc_get_cpubind(topology, cpubind_set, 0);\n      }\n      if (err) {\n\tconst char *errmsg = strerror(errno);\n\tif (pid_number > 0)\n\t  fprintf(stderr, \""hwloc_get_proc_%s %d failed (errno %d %s)\\n\"", get_last_cpu_location ? \""last_cpu_location\"" : \""cpubind\"", pid_number, errno, errmsg);\n\telse if (tid_number > 0)\n\t  fprintf(stderr, \""hwloc_get_tid_%s %d failed (errno %d %s)\\n\"", get_last_cpu_location ? \""last_cpu_location\"" : \""cpubind\"", tid_number, errno, errmsg);\n\telse\n\t  fprintf(stderr, \""hwloc_get_%s failed (errno %d %s)\\n\"", get_last_cpu_location ? \""last_cpu_location\"" : \""cpubind\"", errno, errmsg);\n\treturn EXIT_FAILURE;\n      }\n      if (use_nodeset) {\n\thwloc_bitmap_t nset = hwloc_bitmap_alloc();\n\thwloc_cpuset_to_nodeset(topology, cpubind_set, nset);\n\tif (taskset)\n\t  hwloc_bitmap_taskset_asprintf(&s, nset);\n\telse\n\t  hwloc_bitmap_asprintf(&s, nset);\n\thwloc_bitmap_free(nset);\n      } else {\n\tif (taskset)\n\t  hwloc_bitmap_taskset_asprintf(&s, cpubind_set);\n\telse\n\t  hwloc_bitmap_asprintf(&s, cpubind_set);\n      }\n\n      } else {\n      hwloc_membind_policy_t policy;\n      if (pid_number > 0) {\n\terr = hwloc_get_proc_membind(topology, pid, membind_set, &policy, use_nodeset ? HWLOC_MEMBIND_BYNODESET : 0);\n      } else if (tid_number > 0) {\n\terr = -1; errno = ENOSYS;\n      } else {\n\terr = hwloc_get_membind(topology, membind_set, &policy, use_nodeset ? HWLOC_MEMBIND_BYNODESET : 0);\n      }\n      if (err) {\n\tconst char *errmsg = strerror(errno);\n        if (pid_number > 0)\n          fprintf(stderr, \""hwloc_get_proc_membind %d failed (errno %d %s)\\n\"", pid_number, errno, errmsg);\n        else\n\t  fprintf(stderr, \""hwloc_get_membind failed (errno %d %s)\\n\"", errno, errmsg);\n\treturn EXIT_FAILURE;\n      }\n      if (taskset)\n\thwloc_bitmap_taskset_asprintf(&s, membind_set);\n      else\n\thwloc_bitmap_asprintf(&s, membind_set);\n      switch (policy) {\n      case HWLOC_MEMBIND_FIRSTTOUCH: policystr = \""firsttouch\""; break;\n      case HWLOC_MEMBIND_BIND: policystr = \""bind\""; break;\n      case HWLOC_MEMBIND_INTERLEAVE: policystr = \""interleave\""; break;\n      case HWLOC_MEMBIND_NEXTTOUCH: policystr = \""nexttouch\""; break;\n      default: fprintf(stderr, \""unknown memory policy %d\\n\"", policy); assert(0); break;\n      }\n    }\n    if (policystr)\n      printf(\""%s (%s)\\n\"", s, policystr);\n    else\n      printf(\""%s\\n\"", s);\n    free(s);\n  }\n\n  if (got_membind) {\n    if (hwloc_bitmap_iszero(membind_set)) {\n      if (verbose >= 0)\n\tfprintf(stderr, \""cannot membind to empty set\\n\"");\n      if (!force)\n\tgoto failed_binding;\n    }\n\n    if (best_memattr_str) {\n      struct hwloc_location loc;\n      char *s;\n      best_memattr_id = hwloc_utils_parse_memattr_name(topology, best_memattr_str);\n      if (best_memattr_id == (hwloc_memattr_id_t) -1) {\n        fprintf(stderr, \""unrecognized memattr %s\\n\"", best_memattr_str);\n        return EXIT_FAILURE;\n      }\n\n      loc.type = HWLOC_LOCATION_TYPE_CPUSET;\n      loc.location.cpuset = cpubind_set;\n      if (verbose > 0) {\n        hwloc_bitmap_asprintf(&s, membind_set);\n        fprintf(stderr, \""memory binding set was %s before filtering by best memattr\\n\"", s);\n        free(s);\n      }\n      hwloc_utils_get_best_node_in_nodeset_by_memattr(topology, best_memattr_id, membind_set, &loc);\n      if (verbose > 0) {\n        hwloc_bitmap_asprintf(&s, membind_set);\n        /* double-space before %s for alignment with previous verbose message */\n        fprintf(stderr, \""memory binding is now  %s after filtering by best memattr\\n\"", s);\n        free(s);\n      }\n      if (hwloc_bitmap_iszero(membind_set)) {\n        fprintf(stderr, \""failed to find a best memory node for memory attribute `%s' among the given membind set.\\n\"", best_memattr_str);\n        return EXIT_FAILURE;\n      }\n    }\n\n    if (verbose > 0) {\n      char *s;\n      hwloc_bitmap_asprintf(&s, membind_set);\n      fprintf(stderr, \""binding on memory set %s\\n\"", s);\n      free(s);\n    }\n    if (single)\n      hwloc_bitmap_singlify(membind_set);\n    if (pid_number > 0)\n      ret = hwloc_set_proc_membind(topology, pid, membind_set, membind_policy, membind_flags | HWLOC_MEMBIND_BYNODESET);\n    else if (tid_number > 0) {\n      ret = -1; errno = ENOSYS;\n    } else\n      ret = hwloc_set_membind(topology, membind_set, membind_policy, membind_flags | HWLOC_MEMBIND_BYNODESET);\n    if (ret && verbose >= 0) {\n      int bind_errno = errno;\n      const char *errmsg = strerror(bind_errno);\n      char *s;\n      hwloc_bitmap_asprintf(&s, membind_set);\n      if (pid_number > 0)\n        fprintf(stderr, \""hwloc_set_proc_membind %s (policy %d flags 0x%x) PID %d failed (errno %d %s)\\n\"",\n\t\ts, membind_policy, membind_flags, pid_number, bind_errno, errmsg);\n      else\n        fprintf(stderr, \""hwloc_set_membind %s (policy %d flags 0x%x) failed (errno %d %s)\\n\"",\n\t\ts, membind_policy, membind_flags, bind_errno, errmsg);\n      free(s);\n    }\n    if (ret && !force)\n      goto failed_binding;\n  } else {\n    if (got_mempolicy)\n      fprintf(stderr, \""--mempolicy ignored unless memory binding is also requested with --membind.\\n\"");\n  }\n\n  if (!got_cpubind && no_smt != -1) {\n    hwloc_bitmap_copy(cpubind_set, hwloc_topology_get_topology_cpuset(topology));\n    got_cpubind = 1;\n  }\n\n  if (got_cpubind) {\n    if (hwloc_bitmap_iszero(cpubind_set)) {\n      if (verbose >= 0)\n\tfprintf(stderr, \""cannot cpubind to empty set\\n\"");\n      if (!force)\n\tgoto failed_binding;\n    }\n    if (verbose > 0) {\n      char *s;\n      hwloc_bitmap_asprintf(&s, cpubind_set);\n      fprintf(stderr, \""binding on cpu set %s\\n\"", s);\n      free(s);\n    }\n    if (got_membind && !hwloc_bitmap_isequal(membind_set, cpubind_set)) {\n      if (verbose)\n\tfprintf(stderr, \""Conflicting CPU and memory binding requested, adding HWLOC_CPUBIND_NOMEMBIND flag.\\n\"");\n      cpubind_flags |= HWLOC_CPUBIND_NOMEMBIND;\n    }\n    if (no_smt != -1) {\n      if (hwloc_get_type_depth(topology, HWLOC_OBJ_CORE) == HWLOC_TYPE_DEPTH_UNKNOWN) {\n\tfprintf(stderr, \""Topology has no Core object, ignoring --no-smt\\n\"");\n      } else {\n\thwloc_bitmap_singlify_per_core(topology, cpubind_set, no_smt);\n      }\n    }\n    if (single)\n      hwloc_bitmap_singlify(cpubind_set);\n    if (pid_number > 0)\n      ret = hwloc_set_proc_cpubind(topology, pid, cpubind_set, cpubind_flags);\n#ifdef HWLOC_LINUX_SYS\n    else if (tid_number > 0)\n      ret = hwloc_linux_set_tid_cpubind(topology, tid_number, cpubind_set);\n#endif\n    else\n      ret = hwloc_set_cpubind(topology, cpubind_set, cpubind_flags);\n    if (ret && verbose >= 0) {\n      int bind_errno = errno;\n      const char *errmsg = strerror(bind_errno);\n      char *s;\n      hwloc_bitmap_asprintf(&s, cpubind_set);\n      if (pid_number > 0)\n        fprintf(stderr, \""hwloc_set_proc_cpubind %s (flags 0x%x) PID %d failed (errno %d %s)\\n\"",\n\t\ts, cpubind_flags, pid_number, bind_errno, errmsg);\n      else if (tid_number > 0)\n        fprintf(stderr, \""hwloc_set_tid_cpubind %s (flags 0x%x) PID %d failed (errno %d %s)\\n\"",\n\t\ts, cpubind_flags, tid_number, bind_errno, errmsg);\n      else\n        fprintf(stderr, \""hwloc_set_cpubind %s (flags 0x%x) failed (errno %d %s)\\n\"",\n\t\ts, cpubind_flags, bind_errno, errmsg);\n      free(s);\n    }\n    if (ret && !force)\n      goto failed_binding;\n  }\n\n  hwloc_bitmap_free(cpubind_set);\n  hwloc_bitmap_free(membind_set);\n\n  hwloc_topology_destroy(topology);\n\n  if (pid_number > 0 || tid_number > 0)\n    return EXIT_SUCCESS;\n\n  if (0 == argc) {\n    if (get_binding || get_last_cpu_location)\n      return EXIT_SUCCESS;\n    fprintf(stderr, \""%s: nothing to do!\\n\"", callname);\n    return EXIT_FAILURE;\n  }\n\n  /* FIXME: check whether Windows execvp() passes INHERIT_PARENT_AFFINITY to CreateProcess()\n   * because we need to propagate processor group affinity. However process-wide affinity\n   * isn't supported with processor groups so far.\n   */\n  ret = execvp(argv[0], argv);\n  if (ret) {\n      fprintf(stderr, \""%s: Failed to launch executable \\\""%s\\\""\\n\"",\n              callname, argv[0]);\n      perror(\""execvp\"");\n  }\n  return EXIT_FAILURE;\n\n\nfailed_binding:\n  hwloc_bitmap_free(cpubind_set);\n  hwloc_bitmap_free(membind_set);\n  hwloc_topology_destroy(topology);\n  return EXIT_FAILURE;\n}\n"", ""caller_start"": 70, ""file_path"": ""utils/hwloc/hwloc-bind.c""}]}]","The root cause is unhandled NULL returns from CPU_ALLOC() in hwloc/topology-linux.c functions (hwloc_linux_get_tid_cpubind:987, hwloc_linux_find_kernel_nr_cpus:959, hwloc_linux_set_tid_cpubind:879, etc.). These functions allocated memory for cpu_set_t without checking for failure, risking dereference of invalid pointers. The patch adds NULL checks to return -1 on failure. Callers (e.g., hwloc_linux_get_proc_cpubind:1257, hwloc_linux_foreach_proc_tid_get_cpubind_cb:1197, hwloc_linux_set_tid_cpubind:1179) propagate errors via return values, eventually leading to error handling in main() (hwloc-bind.c:70) which exits on failure, preventing invalid memory access.",0.95,./github/other_context/CVE-2022-47022
46,CVE-2023-25136,CWE-415,c_cpp,"OpenSSH server (sshd) 9.1 introduced a double-free vulnerability during options.kex_algorithms handling. This is fixed in OpenSSH 9.2. The double free can be leveraged, by an unauthenticated remote attacker in the default configuration, to jump to any location in the sshd address space. One third-party report states ""remote code execution is theoretically possible.""",https://github.com/openssh/openssh-portable/commit/486c4dc3b83b4b67d663fb0fa62bc24138ec3946,upstream: Always return allocated strings from the kex filtering so\n\nthat we can free them later.  Fix one leak in compat_kex_proposal.  Based on\ngithub PR#324 from ZoltanFridrich with some simplications by me. ok djm@\n\nOpenBSD-Commit-ID: 9171616da3307612d0ede086fd511142f91246e4,3,"[{""func_name"": ""compat_kex_proposal"", ""file_path"": ""compat.c"", ""func_code"": ""char *\ncompat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2_f(\""original KEX proposal: %s\"", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \""curve25519-sha256@libssh.org\"")) == NULL)\n\t\t\tfatal(\""match_filter_denylist failed\"");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \""diffie-hellman-group-exchange-sha256,\""\n\t\t    \""diffie-hellman-group-exchange-sha1\"")) == NULL)\n\t\t\tfatal(\""match_filter_denylist failed\"");\n\t}\n\tdebug2_f(\""compat KEX proposal: %s\"", p);\n\tif (*p == '\\0')\n\t\tfatal(\""No supported key exchange algorithms found\"");\n\treturn p;\n}"", ""target"": 0}, {""func_name"": ""compat_pkalg_proposal"", ""file_path"": ""compat.c"", ""func_code"": ""char *\ncompat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n\t\treturn pkalg_prop;\n\tdebug2_f(\""original public key proposal: %s\"", pkalg_prop);\n\tif ((pkalg_prop = match_filter_denylist(pkalg_prop, \""ssh-rsa\"")) == NULL)\n\t\tfatal(\""match_filter_denylist failed\"");\n\tdebug2_f(\""compat public key proposal: %s\"", pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\""No supported PK algorithms found\"");\n\treturn pkalg_prop;\n}"", ""target"": 0}, {""func_name"": ""compat_cipher_proposal"", ""file_path"": ""compat.c"", ""func_code"": ""char *\ncompat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\""original cipher proposal: %s\"", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \""aes*\"")) == NULL)\n\t\tfatal(\""match_filter_denylist failed\"");\n\tdebug2_f(\""compat cipher proposal: %s\"", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\""No supported ciphers found\"");\n\treturn cipher_prop;\n}"", ""target"": 0}]","[{""func_name"": ""compat_kex_proposal"", ""file_path"": ""compat.c"", ""func_code"": ""char *\ncompat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tchar *cp = NULL;\n\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn xstrdup(p);\n\tdebug2_f(\""original KEX proposal: %s\"", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \""curve25519-sha256@libssh.org\"")) == NULL)\n\t\t\tfatal(\""match_filter_denylist failed\"");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tcp = p;\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \""diffie-hellman-group-exchange-sha256,\""\n\t\t    \""diffie-hellman-group-exchange-sha1\"")) == NULL)\n\t\t\tfatal(\""match_filter_denylist failed\"");\n\t\tfree(cp);\n\t}\n\tdebug2_f(\""compat KEX proposal: %s\"", p);\n\tif (*p == '\\0')\n\t\tfatal(\""No supported key exchange algorithms found\"");\n\treturn p;\n}""}, {""func_name"": ""compat_pkalg_proposal"", ""file_path"": ""compat.c"", ""func_code"": ""char *\ncompat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n\t\treturn xstrdup(pkalg_prop);\n\tdebug2_f(\""original public key proposal: %s\"", pkalg_prop);\n\tif ((pkalg_prop = match_filter_denylist(pkalg_prop, \""ssh-rsa\"")) == NULL)\n\t\tfatal(\""match_filter_denylist failed\"");\n\tdebug2_f(\""compat public key proposal: %s\"", pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\""No supported PK algorithms found\"");\n\treturn pkalg_prop;\n}""}, {""func_name"": ""compat_cipher_proposal"", ""file_path"": ""compat.c"", ""func_code"": ""char *\ncompat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn xstrdup(cipher_prop);\n\tdebug2_f(\""original cipher proposal: %s\"", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \""aes*\"")) == NULL)\n\t\tfatal(\""match_filter_denylist failed\"");\n\tdebug2_f(\""compat cipher proposal: %s\"", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\""No supported ciphers found\"");\n\treturn cipher_prop;\n}""}]","{""caller"": 3}","[{""source"": ""caller_info(file:compat.c, func:compat_kex_proposal)"", ""result"": [{""call_line"": 246, ""call_code"": ""compat_kex_proposal(ssh, s)"", ""caller_code"": ""void\nssh_kex2(struct ssh *ssh, char *host, struct sockaddr *hostaddr, u_short port,\n    const struct ssh_conn_info *cinfo)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *s, *all_key;\n\tint r, use_known_hosts_order = 0;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\txxx_conn_info = cinfo;\n\n\t/*\n\t * If the user has not specified HostkeyAlgorithms, or has only\n\t * appended or removed algorithms from that list then prefer algorithms\n\t * that are in the list that are supported by known_hosts keys.\n\t */\n\tif (options.hostkeyalgorithms == NULL ||\n\t    options.hostkeyalgorithms[0] == '-' ||\n\t    options.hostkeyalgorithms[0] == '+')\n\t\tuse_known_hosts_order = 1;\n\n\t/* Expand or fill in HostkeyAlgorithms */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&options.hostkeyalgorithms,\n\t    kex_default_pk_alg(), all_key)) != 0)\n\t\tfatal_fr(r, \""kex_assemble_namelist\"");\n\tfree(all_key);\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \""ext-info-c\"")) == NULL)\n\t\tfatal_f(\""kex_names_cat\"");\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(ssh, s);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_COMP_ALGS_STOC] =\n\t    (char *)compression_alg_list(options.compression);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\tif (use_known_hosts_order) {\n\t\t/* Query known_hosts and prefer algorithms that appear there */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh,\n\t\t    order_hostkeyalgs(host, hostaddr, port, cinfo));\n\t} else {\n\t\t/* Use specified HostkeyAlgorithms exactly */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh, options.hostkeyalgorithms);\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\t/* start key exchange */\n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_setup\"");\n#ifdef WITH_OPENSSL\n\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tssh->kex->kex[KEX_ECDH_SHA2] = kex_gen_client;\n# endif\n#endif\n\tssh->kex->kex[KEX_C25519_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_client;\n\tssh->kex->verify_host_key=&verify_host_key_callback;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &ssh->kex->done);\n\n\t/* remove ext-info from the KEX proposals for rekeying */\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(ssh, options.kex_algorithms);\n\tif ((r = kex_prop2buf(ssh->kex->my, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_prop2buf\"");\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""markus\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n#endif\n}\n"", ""caller_start"": 215, ""file_path"": ""sshconnect2.c""}, {""call_line"": 294, ""call_code"": ""compat_kex_proposal(ssh, options.kex_algorithms)"", ""caller_code"": ""void\nssh_kex2(struct ssh *ssh, char *host, struct sockaddr *hostaddr, u_short port,\n    const struct ssh_conn_info *cinfo)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *s, *all_key;\n\tint r, use_known_hosts_order = 0;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\txxx_conn_info = cinfo;\n\n\t/*\n\t * If the user has not specified HostkeyAlgorithms, or has only\n\t * appended or removed algorithms from that list then prefer algorithms\n\t * that are in the list that are supported by known_hosts keys.\n\t */\n\tif (options.hostkeyalgorithms == NULL ||\n\t    options.hostkeyalgorithms[0] == '-' ||\n\t    options.hostkeyalgorithms[0] == '+')\n\t\tuse_known_hosts_order = 1;\n\n\t/* Expand or fill in HostkeyAlgorithms */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&options.hostkeyalgorithms,\n\t    kex_default_pk_alg(), all_key)) != 0)\n\t\tfatal_fr(r, \""kex_assemble_namelist\"");\n\tfree(all_key);\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \""ext-info-c\"")) == NULL)\n\t\tfatal_f(\""kex_names_cat\"");\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(ssh, s);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_COMP_ALGS_STOC] =\n\t    (char *)compression_alg_list(options.compression);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\tif (use_known_hosts_order) {\n\t\t/* Query known_hosts and prefer algorithms that appear there */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh,\n\t\t    order_hostkeyalgs(host, hostaddr, port, cinfo));\n\t} else {\n\t\t/* Use specified HostkeyAlgorithms exactly */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh, options.hostkeyalgorithms);\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\t/* start key exchange */\n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_setup\"");\n#ifdef WITH_OPENSSL\n\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tssh->kex->kex[KEX_ECDH_SHA2] = kex_gen_client;\n# endif\n#endif\n\tssh->kex->kex[KEX_C25519_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_client;\n\tssh->kex->verify_host_key=&verify_host_key_callback;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &ssh->kex->done);\n\n\t/* remove ext-info from the KEX proposals for rekeying */\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(ssh, options.kex_algorithms);\n\tif ((r = kex_prop2buf(ssh->kex->my, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_prop2buf\"");\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""markus\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n#endif\n}\n"", ""caller_start"": 215, ""file_path"": ""sshconnect2.c""}, {""call_line"": 2373, ""call_code"": ""compat_kex_proposal(ssh,\n\t    options.kex_algorithms)"", ""caller_code"": ""static void\ndo_ssh2_kex(struct ssh *ssh)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_SERVER };\n\tstruct kex *kex;\n\tint r;\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(ssh,\n\t    options.kex_algorithms);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(ssh,\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(ssh,\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\n\tif (options.compression == COMP_NONE) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \""none\"";\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(\n\t    ssh, list_hostkey_types());\n\n\t/* start key exchange */\n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_setup\"");\n\tkex = ssh->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kex_gen_server;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kex_gen_server;\n\tkex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_server;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &kex->done);\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""markus\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \""send test\"");\n#endif\n\tdebug(\""KEX done\"");\n}\n"", ""caller_start"": 2366, ""file_path"": ""sshd.c""}]}, {""source"": ""caller_info(file:compat.c, func:compat_pkalg_proposal)"", ""result"": [{""call_line"": 259, ""call_code"": ""compat_pkalg_proposal(ssh,\n\t\t    order_hostkeyalgs(host, hostaddr, port, cinfo))"", ""caller_code"": ""void\nssh_kex2(struct ssh *ssh, char *host, struct sockaddr *hostaddr, u_short port,\n    const struct ssh_conn_info *cinfo)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *s, *all_key;\n\tint r, use_known_hosts_order = 0;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\txxx_conn_info = cinfo;\n\n\t/*\n\t * If the user has not specified HostkeyAlgorithms, or has only\n\t * appended or removed algorithms from that list then prefer algorithms\n\t * that are in the list that are supported by known_hosts keys.\n\t */\n\tif (options.hostkeyalgorithms == NULL ||\n\t    options.hostkeyalgorithms[0] == '-' ||\n\t    options.hostkeyalgorithms[0] == '+')\n\t\tuse_known_hosts_order = 1;\n\n\t/* Expand or fill in HostkeyAlgorithms */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&options.hostkeyalgorithms,\n\t    kex_default_pk_alg(), all_key)) != 0)\n\t\tfatal_fr(r, \""kex_assemble_namelist\"");\n\tfree(all_key);\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \""ext-info-c\"")) == NULL)\n\t\tfatal_f(\""kex_names_cat\"");\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(ssh, s);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_COMP_ALGS_STOC] =\n\t    (char *)compression_alg_list(options.compression);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\tif (use_known_hosts_order) {\n\t\t/* Query known_hosts and prefer algorithms that appear there */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh,\n\t\t    order_hostkeyalgs(host, hostaddr, port, cinfo));\n\t} else {\n\t\t/* Use specified HostkeyAlgorithms exactly */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh, options.hostkeyalgorithms);\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\t/* start key exchange */\n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_setup\"");\n#ifdef WITH_OPENSSL\n\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tssh->kex->kex[KEX_ECDH_SHA2] = kex_gen_client;\n# endif\n#endif\n\tssh->kex->kex[KEX_C25519_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_client;\n\tssh->kex->verify_host_key=&verify_host_key_callback;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &ssh->kex->done);\n\n\t/* remove ext-info from the KEX proposals for rekeying */\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(ssh, options.kex_algorithms);\n\tif ((r = kex_prop2buf(ssh->kex->my, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_prop2buf\"");\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""markus\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n#endif\n}\n"", ""caller_start"": 215, ""file_path"": ""sshconnect2.c""}, {""call_line"": 264, ""call_code"": ""compat_pkalg_proposal(ssh, options.hostkeyalgorithms)"", ""caller_code"": ""void\nssh_kex2(struct ssh *ssh, char *host, struct sockaddr *hostaddr, u_short port,\n    const struct ssh_conn_info *cinfo)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *s, *all_key;\n\tint r, use_known_hosts_order = 0;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\txxx_conn_info = cinfo;\n\n\t/*\n\t * If the user has not specified HostkeyAlgorithms, or has only\n\t * appended or removed algorithms from that list then prefer algorithms\n\t * that are in the list that are supported by known_hosts keys.\n\t */\n\tif (options.hostkeyalgorithms == NULL ||\n\t    options.hostkeyalgorithms[0] == '-' ||\n\t    options.hostkeyalgorithms[0] == '+')\n\t\tuse_known_hosts_order = 1;\n\n\t/* Expand or fill in HostkeyAlgorithms */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&options.hostkeyalgorithms,\n\t    kex_default_pk_alg(), all_key)) != 0)\n\t\tfatal_fr(r, \""kex_assemble_namelist\"");\n\tfree(all_key);\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \""ext-info-c\"")) == NULL)\n\t\tfatal_f(\""kex_names_cat\"");\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(ssh, s);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_COMP_ALGS_STOC] =\n\t    (char *)compression_alg_list(options.compression);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\tif (use_known_hosts_order) {\n\t\t/* Query known_hosts and prefer algorithms that appear there */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh,\n\t\t    order_hostkeyalgs(host, hostaddr, port, cinfo));\n\t} else {\n\t\t/* Use specified HostkeyAlgorithms exactly */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh, options.hostkeyalgorithms);\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\t/* start key exchange */\n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_setup\"");\n#ifdef WITH_OPENSSL\n\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tssh->kex->kex[KEX_ECDH_SHA2] = kex_gen_client;\n# endif\n#endif\n\tssh->kex->kex[KEX_C25519_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_client;\n\tssh->kex->verify_host_key=&verify_host_key_callback;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &ssh->kex->done);\n\n\t/* remove ext-info from the KEX proposals for rekeying */\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(ssh, options.kex_algorithms);\n\tif ((r = kex_prop2buf(ssh->kex->my, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_prop2buf\"");\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""markus\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n#endif\n}\n"", ""caller_start"": 215, ""file_path"": ""sshconnect2.c""}, {""call_line"": 2391, ""call_code"": ""compat_pkalg_proposal(\n\t    ssh, list_hostkey_types())"", ""caller_code"": ""static void\ndo_ssh2_kex(struct ssh *ssh)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_SERVER };\n\tstruct kex *kex;\n\tint r;\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(ssh,\n\t    options.kex_algorithms);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(ssh,\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(ssh,\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\n\tif (options.compression == COMP_NONE) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \""none\"";\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(\n\t    ssh, list_hostkey_types());\n\n\t/* start key exchange */\n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_setup\"");\n\tkex = ssh->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kex_gen_server;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kex_gen_server;\n\tkex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_server;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &kex->done);\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""markus\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \""send test\"");\n#endif\n\tdebug(\""KEX done\"");\n}\n"", ""caller_start"": 2366, ""file_path"": ""sshd.c""}]}, {""source"": ""caller_info(file:compat.c, func:compat_cipher_proposal)"", ""result"": [{""call_line"": 248, ""call_code"": ""compat_cipher_proposal(ssh, options.ciphers)"", ""caller_code"": ""void\nssh_kex2(struct ssh *ssh, char *host, struct sockaddr *hostaddr, u_short port,\n    const struct ssh_conn_info *cinfo)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *s, *all_key;\n\tint r, use_known_hosts_order = 0;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\txxx_conn_info = cinfo;\n\n\t/*\n\t * If the user has not specified HostkeyAlgorithms, or has only\n\t * appended or removed algorithms from that list then prefer algorithms\n\t * that are in the list that are supported by known_hosts keys.\n\t */\n\tif (options.hostkeyalgorithms == NULL ||\n\t    options.hostkeyalgorithms[0] == '-' ||\n\t    options.hostkeyalgorithms[0] == '+')\n\t\tuse_known_hosts_order = 1;\n\n\t/* Expand or fill in HostkeyAlgorithms */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&options.hostkeyalgorithms,\n\t    kex_default_pk_alg(), all_key)) != 0)\n\t\tfatal_fr(r, \""kex_assemble_namelist\"");\n\tfree(all_key);\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \""ext-info-c\"")) == NULL)\n\t\tfatal_f(\""kex_names_cat\"");\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(ssh, s);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_COMP_ALGS_STOC] =\n\t    (char *)compression_alg_list(options.compression);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\tif (use_known_hosts_order) {\n\t\t/* Query known_hosts and prefer algorithms that appear there */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh,\n\t\t    order_hostkeyalgs(host, hostaddr, port, cinfo));\n\t} else {\n\t\t/* Use specified HostkeyAlgorithms exactly */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh, options.hostkeyalgorithms);\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\t/* start key exchange */\n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_setup\"");\n#ifdef WITH_OPENSSL\n\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tssh->kex->kex[KEX_ECDH_SHA2] = kex_gen_client;\n# endif\n#endif\n\tssh->kex->kex[KEX_C25519_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_client;\n\tssh->kex->verify_host_key=&verify_host_key_callback;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &ssh->kex->done);\n\n\t/* remove ext-info from the KEX proposals for rekeying */\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(ssh, options.kex_algorithms);\n\tif ((r = kex_prop2buf(ssh->kex->my, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_prop2buf\"");\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""markus\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n#endif\n}\n"", ""caller_start"": 215, ""file_path"": ""sshconnect2.c""}, {""call_line"": 250, ""call_code"": ""compat_cipher_proposal(ssh, options.ciphers)"", ""caller_code"": ""void\nssh_kex2(struct ssh *ssh, char *host, struct sockaddr *hostaddr, u_short port,\n    const struct ssh_conn_info *cinfo)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *s, *all_key;\n\tint r, use_known_hosts_order = 0;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\txxx_conn_info = cinfo;\n\n\t/*\n\t * If the user has not specified HostkeyAlgorithms, or has only\n\t * appended or removed algorithms from that list then prefer algorithms\n\t * that are in the list that are supported by known_hosts keys.\n\t */\n\tif (options.hostkeyalgorithms == NULL ||\n\t    options.hostkeyalgorithms[0] == '-' ||\n\t    options.hostkeyalgorithms[0] == '+')\n\t\tuse_known_hosts_order = 1;\n\n\t/* Expand or fill in HostkeyAlgorithms */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&options.hostkeyalgorithms,\n\t    kex_default_pk_alg(), all_key)) != 0)\n\t\tfatal_fr(r, \""kex_assemble_namelist\"");\n\tfree(all_key);\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \""ext-info-c\"")) == NULL)\n\t\tfatal_f(\""kex_names_cat\"");\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(ssh, s);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] =\n\t    compat_cipher_proposal(ssh, options.ciphers);\n\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_COMP_ALGS_STOC] =\n\t    (char *)compression_alg_list(options.compression);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\tif (use_known_hosts_order) {\n\t\t/* Query known_hosts and prefer algorithms that appear there */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh,\n\t\t    order_hostkeyalgs(host, hostaddr, port, cinfo));\n\t} else {\n\t\t/* Use specified HostkeyAlgorithms exactly */\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] =\n\t\t    compat_pkalg_proposal(ssh, options.hostkeyalgorithms);\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\t/* start key exchange */\n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_setup\"");\n#ifdef WITH_OPENSSL\n\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tssh->kex->kex[KEX_ECDH_SHA2] = kex_gen_client;\n# endif\n#endif\n\tssh->kex->kex[KEX_C25519_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_client;\n\tssh->kex->verify_host_key=&verify_host_key_callback;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &ssh->kex->done);\n\n\t/* remove ext-info from the KEX proposals for rekeying */\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(ssh, options.kex_algorithms);\n\tif ((r = kex_prop2buf(ssh->kex->my, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_prop2buf\"");\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""markus\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \""send packet\"");\n#endif\n}\n"", ""caller_start"": 215, ""file_path"": ""sshconnect2.c""}, {""call_line"": 2375, ""call_code"": ""compat_cipher_proposal(ssh,\n\t    options.ciphers)"", ""caller_code"": ""static void\ndo_ssh2_kex(struct ssh *ssh)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_SERVER };\n\tstruct kex *kex;\n\tint r;\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(ssh,\n\t    options.kex_algorithms);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(ssh,\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(ssh,\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\n\tif (options.compression == COMP_NONE) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \""none\"";\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(\n\t    ssh, list_hostkey_types());\n\n\t/* start key exchange */\n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_setup\"");\n\tkex = ssh->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kex_gen_server;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kex_gen_server;\n\tkex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_server;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &kex->done);\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""markus\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \""send test\"");\n#endif\n\tdebug(\""KEX done\"");\n}\n"", ""caller_start"": 2366, ""file_path"": ""sshd.c""}, {""call_line"": 2377, ""call_code"": ""compat_cipher_proposal(ssh,\n\t    options.ciphers)"", ""caller_code"": ""static void\ndo_ssh2_kex(struct ssh *ssh)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_SERVER };\n\tstruct kex *kex;\n\tint r;\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(ssh,\n\t    options.kex_algorithms);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(ssh,\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(ssh,\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\n\tif (options.compression == COMP_NONE) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \""none\"";\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(\n\t    ssh, list_hostkey_types());\n\n\t/* start key exchange */\n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \""kex_setup\"");\n\tkex = ssh->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kex_gen_server;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kex_gen_server;\n\tkex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_server;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &kex->done);\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \""markus\"")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \""send test\"");\n#endif\n\tdebug(\""KEX done\"");\n}\n"", ""caller_start"": 2366, ""file_path"": ""sshd.c""}]}]","Prior to the patch, compat_kex_proposal (compat.c:188), compat_pkalg_proposal (compat.c:175), and compat_cipher_proposal (compat.c:161) returned input pointers directly when no compatibility filtering was needed. This allowed the same string (e.g., options.kex_algorithms) to be stored in multiple myproposal array entries (sshconnect2.c:246, sshd.c:2373). When these entries were later freed (e.g., via kex_prop_free() called during key exchange teardown), the identical pointer was freed twice, causing a double-free. The patch replaces direct returns with xstrdup(), ensuring unique allocations for each entry. The trigger occurs during key exchange initialization (ssh_kex2, do_ssh2_kex) when the same input string is referenced in multiple proposal entries.",0.95,./github/other_context/CVE-2023-25136
47,CVE-2023-41358,CWE-476,c_cpp,An issue was discovered in FRRouting FRR through 9.0. bgpd/bgp_packet.c processes NLRIs if the attribute length is zero.,https://github.com/FRRouting/frr/commit/28ccc24d38df1d51ed8a563507e5d6f6171fdd38,"bgpd: Do not process NLRIs if the attribute length is zero\n\n```\n3  0x00007f423aa42476 in __GI_raise (sig=sig@entry=11) at ../sysdeps/posix/raise.c:26\n4  0x00007f423aef9740 in core_handler (signo=11, siginfo=0x7fffc414deb0, context=<optimized out>) at lib/sigevent.c:246\n5  <signal handler called>\n6  0x0000564dea2fc71e in route_set_aspath_prepend (rule=0x564debd66d50, prefix=0x7fffc414ea30, object=0x7fffc414e400)\n    at bgpd/bgp_routemap.c:2258\n7  0x00007f423aeec7e0 in route_map_apply_ext (map=<optimized out>, prefix=prefix@entry=0x7fffc414ea30,\n    match_object=match_object@entry=0x7fffc414e400, set_object=set_object@entry=0x7fffc414e400, pref=pref@entry=0x0) at lib/routemap.c:2690\n8  0x0000564dea2d277e in bgp_input_modifier (peer=peer@entry=0x7f4238f59010, p=p@entry=0x7fffc414ea30, attr=attr@entry=0x7fffc414e770,\n    afi=afi@entry=AFI_IP, safi=safi@entry=SAFI_UNICAST, rmap_name=rmap_name@entry=0x0, label=0x0, num_labels=0, dest=0x564debdd5130)\n    at bgpd/bgp_route.c:1772\n9  0x0000564dea2df762 in bgp_update (peer=peer@entry=0x7f4238f59010, p=p@entry=0x7fffc414ea30, addpath_id=addpath_id@entry=0,\n    attr=0x7fffc414eb50, afi=afi@entry=AFI_IP, safi=<optimized out>, safi@entry=SAFI_UNICAST, type=9, sub_type=0, prd=0x0, label=0x0,\n    num_labels=0, soft_reconfig=0, evpn=0x0) at bgpd/bgp_route.c:4374\n10 0x0000564dea2e2047 in bgp_nlri_parse_ip (peer=0x7f4238f59010, attr=attr@entry=0x7fffc414eb50, packet=0x7fffc414eaf0)\n    at bgpd/bgp_route.c:6249\n11 0x0000564dea2c5a58 in bgp_nlri_parse (peer=peer@entry=0x7f4238f59010, attr=attr@entry=0x7fffc414eb50,\n    packet=packet@entry=0x7fffc414eaf0, mp_withdraw=mp_withdraw@entry=false) at bgpd/bgp_packet.c:339\n12 0x0000564dea2c5d66 in bgp_update_receive (peer=peer@entry=0x7f4238f59010, size=size@entry=109) at bgpd/bgp_packet.c:2024\n13 0x0000564dea2c901d in bgp_process_packet (thread=<optimized out>) at bgpd/bgp_packet.c:2933\n14 0x00007f423af0bf71 in event_call (thread=thread@entry=0x7fffc414ee40) at lib/event.c:1995\n15 0x00007f423aebb198 in frr_run (master=0x564deb73c670) at lib/libfrr.c:1213\n16 0x0000564dea261b83 in main (argc=<optimized out>, argv=<optimized out>) at bgpd/bgp_main.c:505\n```\n\nWith the configuration:\n\n```\nfrr version 9.1-dev-MyOwnFRRVersion\nfrr defaults traditional\nhostname ip-172-31-13-140\nlog file /tmp/debug.log\nlog syslog\nservice integrated-vtysh-config\n!\ndebug bgp keepalives\ndebug bgp neighbor-events\ndebug bgp updates in\ndebug bgp updates out\n!\nrouter bgp 100\n bgp router-id 9.9.9.9\n no bgp ebgp-requires-policy\n bgp bestpath aigp\n neighbor 172.31.2.47 remote-as 200\n !\n address-family ipv4 unicast\n  neighbor 172.31.2.47 default-originate\n  neighbor 172.31.2.47 route-map RM_IN in\n exit-address-family\nexit\n!\nroute-map RM_IN permit 10\n set as-path prepend 200\nexit\n!\n```\n\nThe issue is that we try to process NLRIs even if the attribute length is 0.\n\nLater bgp_update() will handle route-maps and a crash occurs because all the\nattributes are NULL, including aspath, where we dereference.\n\nAccording to the RFC 4271:\n\nA value of 0 indicates that neither the Network Layer\n         Reachability Information field nor the Path Attribute field is\n         present in this UPDATE message.\n\nBut with a fuzzed UPDATE message this can be faked. I think it's reasonable\nto skip processing NLRIs if both update_len and attribute_len are 0.\n\nReported-by: Iggy Frankovic <iggyfran@amazon.com>\nSigned-off-by: Donatas Abraitis <donatas@opensourcerouting.org>",1,"[{""func_name"": ""bgp_update_receive"", ""file_path"": ""bgpd/bgp_packet.c"", ""func_code"": ""static int bgp_update_receive(struct peer *peer, bgp_size_t size)\n{\n\tint ret, nlri_ret;\n\tuint8_t *end;\n\tstruct stream *s;\n\tstruct attr attr;\n\tbgp_size_t attribute_len;\n\tbgp_size_t update_len;\n\tbgp_size_t withdraw_len;\n\tbool restart = false;\n\n\tenum NLRI_TYPES {\n\t\tNLRI_UPDATE,\n\t\tNLRI_WITHDRAW,\n\t\tNLRI_MP_UPDATE,\n\t\tNLRI_MP_WITHDRAW,\n\t\tNLRI_TYPE_MAX\n\t};\n\tstruct bgp_nlri nlris[NLRI_TYPE_MAX];\n\n\t/* Status must be Established. */\n\tif (!peer_established(peer)) {\n\t\tflog_err(EC_BGP_INVALID_STATUS,\n\t\t\t \""%s [FSM] Update packet received under status %s\"",\n\t\t\t peer->host,\n\t\t\t lookup_msg(bgp_status_msg, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(peer, BGP_NOTIFY_FSM_ERR,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Set initial values. */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\tmemset(&nlris, 0, sizeof(nlris));\n\tmemset(peer->rcvd_attr_str, 0, BUFSIZ);\n\tpeer->rcvd_attr_printed = 0;\n\n\ts = peer->curr;\n\tend = stream_pnt(s) + size;\n\n\t/* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute\n\t   Length is too large (i.e., if Unfeasible Routes Length + Total\n\t   Attribute Length + 23 exceeds the message Length), then the Error\n\t   Subcode is set to Malformed Attribute List.  */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \""%s [Error] Update packet error (packet length is short for unfeasible length)\"",\n\t\t\t peer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route Length. */\n\twithdraw_len = stream_getw(s);\n\n\t/* Unfeasible Route Length check. */\n\tif (stream_pnt(s) + withdraw_len > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \""%s [Error] Update packet error (packet unfeasible length overflow %d)\"",\n\t\t\t peer->host, withdraw_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route packet format check. */\n\tif (withdraw_len > 0) {\n\t\tnlris[NLRI_WITHDRAW].afi = AFI_IP;\n\t\tnlris[NLRI_WITHDRAW].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_WITHDRAW].nlri = stream_pnt(s);\n\t\tnlris[NLRI_WITHDRAW].length = withdraw_len;\n\t\tstream_forward_getp(s, withdraw_len);\n\t}\n\n\t/* Attribute total length check. */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_SHORT,\n\t\t\t\""%s [Error] Packet Error (update packet is short for attribute length)\"",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Fetch attribute total length. */\n\tattribute_len = stream_getw(s);\n\n\t/* Attribute length check. */\n\tif (stream_pnt(s) + attribute_len > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_LONG,\n\t\t\t\""%s [Error] Packet Error (update packet attribute length overflow %d)\"",\n\t\t\tpeer->host, attribute_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Certain attribute parsing errors should not be considered bad enough\n\t * to reset the session for, most particularly any partial/optional\n\t * attributes that have 'tunneled' over speakers that don't understand\n\t * them. Instead we withdraw only the prefix concerned.\n\t *\n\t * Complicates the flow a little though..\n\t */\n\tenum bgp_attr_parse_ret attr_parse_ret = BGP_ATTR_PARSE_PROCEED;\n/* This define morphs the update case into a withdraw when lower levels\n * have signalled an error condition where this is best.\n */\n#define NLRI_ATTR_ARG (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* Parse attribute when it exists. */\n\tif (attribute_len) {\n\t\tattr_parse_ret = bgp_attr_parse(peer, &attr, attribute_len,\n\t\t\t\t\t\t&nlris[NLRI_MP_UPDATE],\n\t\t\t\t\t\t&nlris[NLRI_MP_WITHDRAW]);\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* Logging the attribute. */\n\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW\n\t    || BGP_DEBUG(update, UPDATE_IN)\n\t    || BGP_DEBUG(update, UPDATE_PREFIX)) {\n\t\tret = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW)\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\""%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\"",\n\t\t\t\tpeer);\n\n\t\tif (ret && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\""%pBP rcvd UPDATE w/ attr: %s\"", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* Network Layer Reachability Information. */\n\tupdate_len = end - stream_pnt(s);\n\n\tif (update_len) {\n\t\t/* Set NLRI portion to structure. */\n\t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n\t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_UPDATE].nlri = stream_pnt(s);\n\t\tnlris[NLRI_UPDATE].length = update_len;\n\t\tstream_forward_getp(s, update_len);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\t\t/*\n\t\t\t * We skipped nexthop attribute validation earlier so\n\t\t\t * validate the nexthop now.\n\t\t\t */\n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(update, UPDATE_IN))\n\t\tzlog_debug(\""%pBP rcvd UPDATE wlen %d attrlen %d alen %d\"", peer,\n\t\t\t   withdraw_len, attribute_len, update_len);\n\n\t/* Parse any given NLRIs */\n\tfor (int i = NLRI_UPDATE; i < NLRI_TYPE_MAX; i++) {\n\t\tif (!nlris[i].nlri)\n\t\t\tcontinue;\n\n\t\t/* NLRI is processed iff the peer if configured for the specific\n\t\t * afi/safi */\n\t\tif (!peer->afc[nlris[i].afi][nlris[i].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\""%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\"",\n\t\t\t\tpeer->host, nlris[i].afi, nlris[i].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* EoR handled later */\n\t\tif (nlris[i].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NLRI_UPDATE:\n\t\tcase NLRI_MP_UPDATE:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 0);\n\t\t\tbreak;\n\t\tcase NLRI_WITHDRAW:\n\t\tcase NLRI_MP_WITHDRAW:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnlri_ret = BGP_NLRI_PARSE_ERROR;\n\t\t}\n\n\t\tif (nlri_ret < BGP_NLRI_PARSE_OK\n\t\t    && nlri_ret != BGP_NLRI_PARSE_ERROR_PREFIX_OVERFLOW) {\n\t\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t\t \""%s [Error] Error parsing NLRI\"", peer->host);\n\t\t\tif (peer_established(peer))\n\t\t\t\tbgp_notify_send(\n\t\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\ti <= NLRI_WITHDRAW\n\t\t\t\t\t\t? BGP_NOTIFY_UPDATE_INVAL_NETWORK\n\t\t\t\t\t\t: BGP_NOTIFY_UPDATE_OPT_ATTR_ERR);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* EoR checks\n\t *\n\t * Non-MP IPv4/Unicast EoR is a completely empty UPDATE\n\t * and MP EoR should have only an empty MP_UNREACH\n\t */\n\tif ((!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0)\n\t    || (attr_parse_ret == BGP_ATTR_PARSE_EOR)) {\n\t\tafi_t afi = 0;\n\t\tsafi_t safi;\n\t\tstruct graceful_restart_info *gr_info;\n\n\t\t/* Restarting router */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\trestart = true;\n\n\t\t/* Non-MP IPv4/Unicast is a completely emtpy UPDATE - already\n\t\t * checked\n\t\t * update and withdraw NLRI lengths are 0.\n\t\t */\n\t\tif (!attribute_len) {\n\t\t\tafi = AFI_IP;\n\t\t\tsafi = SAFI_UNICAST;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)\n\t\t\t   && nlris[NLRI_MP_WITHDRAW].length == 0) {\n\t\t\tafi = nlris[NLRI_MP_WITHDRAW].afi;\n\t\t\tsafi = nlris[NLRI_MP_WITHDRAW].safi;\n\t\t} else if (attr_parse_ret == BGP_ATTR_PARSE_EOR) {\n\t\t\tafi = nlris[NLRI_MP_UPDATE].afi;\n\t\t\tsafi = nlris[NLRI_MP_UPDATE].safi;\n\t\t}\n\n\t\tif (afi && peer->afc[afi][safi]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* End-of-RIB received */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\tPEER_STATUS_EOR_RECEIVED)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\t PEER_STATUS_EOR_RECEIVED);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* Update graceful restart information */\n\t\t\t\tgr_info = &(peer->bgp->gr_info[afi][safi]);\n\t\t\t\tif (restart)\n\t\t\t\t\tgr_info->eor_received++;\n\t\t\t\t/* If EOR received from all peers and selection\n\t\t\t\t * deferral timer is running, cancel the timer\n\t\t\t\t * and invoke the best path calculation\n\t\t\t\t */\n\t\t\t\tif (gr_info->eor_required\n\t\t\t\t    == gr_info->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\""%s %d, %s %d\"",\n\t\t\t\t\t\t\t\""EOR REQ\"",\n\t\t\t\t\t\t\tgr_info->eor_required,\n\t\t\t\t\t\t\t\""EOR RCV\"",\n\t\t\t\t\t\t\tgr_info->eor_received);\n\t\t\t\t\tif (gr_info->t_select_deferral) {\n\t\t\t\t\t\tvoid *info = EVENT_ARG(\n\t\t\t\t\t\t\tgr_info->t_select_deferral);\n\t\t\t\t\t\tXFREE(MTYPE_TMP, info);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(gr_info->t_select_deferral);\n\t\t\t\t\tgr_info->eor_required = 0;\n\t\t\t\t\tgr_info->eor_received = 0;\n\t\t\t\t\t/* Best path selection */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   afi, safi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* NSF delete stale route */\n\t\t\tif (peer->nsf[afi][safi])\n\t\t\t\tbgp_clear_stale_route(peer, afi, safi);\n\n\t\t\tzlog_info(\n\t\t\t\t\""%s: rcvd End-of-RIB for %s from %s in vrf %s\"",\n\t\t\t\t__func__, get_afi_safi_str(afi, safi, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VRF_DEFAULT_NAME);\n\t\t}\n\t}\n\n\t/* Everything is done.  We unintern temporary structures which\n\t   interned in bgp_attr_parse(). */\n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* Notify BGP Conditional advertisement scanner process */\n\tpeer->advmap_table_change = true;\n\n\treturn Receive_UPDATE_message;\n}"", ""target"": 0}]","[{""func_name"": ""bgp_update_receive"", ""file_path"": ""bgpd/bgp_packet.c"", ""func_code"": ""static int bgp_update_receive(struct peer *peer, bgp_size_t size)\n{\n\tint ret, nlri_ret;\n\tuint8_t *end;\n\tstruct stream *s;\n\tstruct attr attr;\n\tbgp_size_t attribute_len;\n\tbgp_size_t update_len;\n\tbgp_size_t withdraw_len;\n\tbool restart = false;\n\n\tenum NLRI_TYPES {\n\t\tNLRI_UPDATE,\n\t\tNLRI_WITHDRAW,\n\t\tNLRI_MP_UPDATE,\n\t\tNLRI_MP_WITHDRAW,\n\t\tNLRI_TYPE_MAX\n\t};\n\tstruct bgp_nlri nlris[NLRI_TYPE_MAX];\n\n\t/* Status must be Established. */\n\tif (!peer_established(peer)) {\n\t\tflog_err(EC_BGP_INVALID_STATUS,\n\t\t\t \""%s [FSM] Update packet received under status %s\"",\n\t\t\t peer->host,\n\t\t\t lookup_msg(bgp_status_msg, peer->connection->status,\n\t\t\t\t    NULL));\n\t\tbgp_notify_send(peer, BGP_NOTIFY_FSM_ERR,\n\t\t\t\tbgp_fsm_error_subcode(peer->connection->status));\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Set initial values. */\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.label_index = BGP_INVALID_LABEL_INDEX;\n\tattr.label = MPLS_INVALID_LABEL;\n\tmemset(&nlris, 0, sizeof(nlris));\n\tmemset(peer->rcvd_attr_str, 0, BUFSIZ);\n\tpeer->rcvd_attr_printed = 0;\n\n\ts = peer->curr;\n\tend = stream_pnt(s) + size;\n\n\t/* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute\n\t   Length is too large (i.e., if Unfeasible Routes Length + Total\n\t   Attribute Length + 23 exceeds the message Length), then the Error\n\t   Subcode is set to Malformed Attribute List.  */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \""%s [Error] Update packet error (packet length is short for unfeasible length)\"",\n\t\t\t peer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route Length. */\n\twithdraw_len = stream_getw(s);\n\n\t/* Unfeasible Route Length check. */\n\tif (stream_pnt(s) + withdraw_len > end) {\n\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t \""%s [Error] Update packet error (packet unfeasible length overflow %d)\"",\n\t\t\t peer->host, withdraw_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Unfeasible Route packet format check. */\n\tif (withdraw_len > 0) {\n\t\tnlris[NLRI_WITHDRAW].afi = AFI_IP;\n\t\tnlris[NLRI_WITHDRAW].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_WITHDRAW].nlri = stream_pnt(s);\n\t\tnlris[NLRI_WITHDRAW].length = withdraw_len;\n\t\tstream_forward_getp(s, withdraw_len);\n\t}\n\n\t/* Attribute total length check. */\n\tif (stream_pnt(s) + 2 > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_SHORT,\n\t\t\t\""%s [Error] Packet Error (update packet is short for attribute length)\"",\n\t\t\tpeer->host);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Fetch attribute total length. */\n\tattribute_len = stream_getw(s);\n\n\t/* Attribute length check. */\n\tif (stream_pnt(s) + attribute_len > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_UPDATE_PACKET_LONG,\n\t\t\t\""%s [Error] Packet Error (update packet attribute length overflow %d)\"",\n\t\t\tpeer->host, attribute_len);\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\treturn BGP_Stop;\n\t}\n\n\t/* Certain attribute parsing errors should not be considered bad enough\n\t * to reset the session for, most particularly any partial/optional\n\t * attributes that have 'tunneled' over speakers that don't understand\n\t * them. Instead we withdraw only the prefix concerned.\n\t *\n\t * Complicates the flow a little though..\n\t */\n\tenum bgp_attr_parse_ret attr_parse_ret = BGP_ATTR_PARSE_PROCEED;\n/* This define morphs the update case into a withdraw when lower levels\n * have signalled an error condition where this is best.\n */\n#define NLRI_ATTR_ARG (attr_parse_ret != BGP_ATTR_PARSE_WITHDRAW ? &attr : NULL)\n\n\t/* Parse attribute when it exists. */\n\tif (attribute_len) {\n\t\tattr_parse_ret = bgp_attr_parse(peer, &attr, attribute_len,\n\t\t\t\t\t\t&nlris[NLRI_MP_UPDATE],\n\t\t\t\t\t\t&nlris[NLRI_MP_WITHDRAW]);\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* Logging the attribute. */\n\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW\n\t    || BGP_DEBUG(update, UPDATE_IN)\n\t    || BGP_DEBUG(update, UPDATE_PREFIX)) {\n\t\tret = bgp_dump_attr(&attr, peer->rcvd_attr_str,\n\t\t\t\t    sizeof(peer->rcvd_attr_str));\n\n\t\tpeer->stat_upd_7606++;\n\n\t\tif (attr_parse_ret == BGP_ATTR_PARSE_WITHDRAW)\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\""%pBP rcvd UPDATE with errors in attr(s)!! Withdrawing route.\"",\n\t\t\t\tpeer);\n\n\t\tif (ret && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\""%pBP rcvd UPDATE w/ attr: %s\"", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* Network Layer Reachability Information. */\n\tupdate_len = end - stream_pnt(s);\n\n\tif (update_len && attribute_len) {\n\t\t/* Set NLRI portion to structure. */\n\t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n\t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_UPDATE].nlri = stream_pnt(s);\n\t\tnlris[NLRI_UPDATE].length = update_len;\n\t\tstream_forward_getp(s, update_len);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\t\t/*\n\t\t\t * We skipped nexthop attribute validation earlier so\n\t\t\t * validate the nexthop now.\n\t\t\t */\n\t\t\tif (bgp_attr_nexthop_valid(peer, &attr) < 0) {\n\t\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (BGP_DEBUG(update, UPDATE_IN))\n\t\tzlog_debug(\""%pBP rcvd UPDATE wlen %d attrlen %d alen %d\"", peer,\n\t\t\t   withdraw_len, attribute_len, update_len);\n\n\t/* Parse any given NLRIs */\n\tfor (int i = NLRI_UPDATE; i < NLRI_TYPE_MAX; i++) {\n\t\tif (!nlris[i].nlri)\n\t\t\tcontinue;\n\n\t\t/* NLRI is processed iff the peer if configured for the specific\n\t\t * afi/safi */\n\t\tif (!peer->afc[nlris[i].afi][nlris[i].safi]) {\n\t\t\tzlog_info(\n\t\t\t\t\""%s [Info] UPDATE for non-enabled AFI/SAFI %u/%u\"",\n\t\t\t\tpeer->host, nlris[i].afi, nlris[i].safi);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* EoR handled later */\n\t\tif (nlris[i].length == 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NLRI_UPDATE:\n\t\tcase NLRI_MP_UPDATE:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 0);\n\t\t\tbreak;\n\t\tcase NLRI_WITHDRAW:\n\t\tcase NLRI_MP_WITHDRAW:\n\t\t\tnlri_ret = bgp_nlri_parse(peer, NLRI_ATTR_ARG,\n\t\t\t\t\t\t  &nlris[i], 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnlri_ret = BGP_NLRI_PARSE_ERROR;\n\t\t}\n\n\t\tif (nlri_ret < BGP_NLRI_PARSE_OK\n\t\t    && nlri_ret != BGP_NLRI_PARSE_ERROR_PREFIX_OVERFLOW) {\n\t\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t\t \""%s [Error] Error parsing NLRI\"", peer->host);\n\t\t\tif (peer_established(peer))\n\t\t\t\tbgp_notify_send(\n\t\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\ti <= NLRI_WITHDRAW\n\t\t\t\t\t\t? BGP_NOTIFY_UPDATE_INVAL_NETWORK\n\t\t\t\t\t\t: BGP_NOTIFY_UPDATE_OPT_ATTR_ERR);\n\t\t\tbgp_attr_unintern_sub(&attr);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t}\n\n\t/* EoR checks\n\t *\n\t * Non-MP IPv4/Unicast EoR is a completely empty UPDATE\n\t * and MP EoR should have only an empty MP_UNREACH\n\t */\n\tif ((!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0)\n\t    || (attr_parse_ret == BGP_ATTR_PARSE_EOR)) {\n\t\tafi_t afi = 0;\n\t\tsafi_t safi;\n\t\tstruct graceful_restart_info *gr_info;\n\n\t\t/* Restarting router */\n\t\tif (BGP_PEER_GRACEFUL_RESTART_CAPABLE(peer)\n\t\t    && BGP_PEER_RESTARTING_MODE(peer))\n\t\t\trestart = true;\n\n\t\t/* Non-MP IPv4/Unicast is a completely emtpy UPDATE - already\n\t\t * checked\n\t\t * update and withdraw NLRI lengths are 0.\n\t\t */\n\t\tif (!attribute_len) {\n\t\t\tafi = AFI_IP;\n\t\t\tsafi = SAFI_UNICAST;\n\t\t} else if (attr.flag & ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)\n\t\t\t   && nlris[NLRI_MP_WITHDRAW].length == 0) {\n\t\t\tafi = nlris[NLRI_MP_WITHDRAW].afi;\n\t\t\tsafi = nlris[NLRI_MP_WITHDRAW].safi;\n\t\t} else if (attr_parse_ret == BGP_ATTR_PARSE_EOR) {\n\t\t\tafi = nlris[NLRI_MP_UPDATE].afi;\n\t\t\tsafi = nlris[NLRI_MP_UPDATE].safi;\n\t\t}\n\n\t\tif (afi && peer->afc[afi][safi]) {\n\t\t\tstruct vrf *vrf = vrf_lookup_by_id(peer->bgp->vrf_id);\n\n\t\t\t/* End-of-RIB received */\n\t\t\tif (!CHECK_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\tPEER_STATUS_EOR_RECEIVED)) {\n\t\t\t\tSET_FLAG(peer->af_sflags[afi][safi],\n\t\t\t\t\t PEER_STATUS_EOR_RECEIVED);\n\t\t\t\tbgp_update_explicit_eors(peer);\n\t\t\t\t/* Update graceful restart information */\n\t\t\t\tgr_info = &(peer->bgp->gr_info[afi][safi]);\n\t\t\t\tif (restart)\n\t\t\t\t\tgr_info->eor_received++;\n\t\t\t\t/* If EOR received from all peers and selection\n\t\t\t\t * deferral timer is running, cancel the timer\n\t\t\t\t * and invoke the best path calculation\n\t\t\t\t */\n\t\t\t\tif (gr_info->eor_required\n\t\t\t\t    == gr_info->eor_received) {\n\t\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\t\""%s %d, %s %d\"",\n\t\t\t\t\t\t\t\""EOR REQ\"",\n\t\t\t\t\t\t\tgr_info->eor_required,\n\t\t\t\t\t\t\t\""EOR RCV\"",\n\t\t\t\t\t\t\tgr_info->eor_received);\n\t\t\t\t\tif (gr_info->t_select_deferral) {\n\t\t\t\t\t\tvoid *info = EVENT_ARG(\n\t\t\t\t\t\t\tgr_info->t_select_deferral);\n\t\t\t\t\t\tXFREE(MTYPE_TMP, info);\n\t\t\t\t\t}\n\t\t\t\t\tEVENT_OFF(gr_info->t_select_deferral);\n\t\t\t\t\tgr_info->eor_required = 0;\n\t\t\t\t\tgr_info->eor_received = 0;\n\t\t\t\t\t/* Best path selection */\n\t\t\t\t\tbgp_best_path_select_defer(peer->bgp,\n\t\t\t\t\t\t\t\t   afi, safi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* NSF delete stale route */\n\t\t\tif (peer->nsf[afi][safi])\n\t\t\t\tbgp_clear_stale_route(peer, afi, safi);\n\n\t\t\tzlog_info(\n\t\t\t\t\""%s: rcvd End-of-RIB for %s from %s in vrf %s\"",\n\t\t\t\t__func__, get_afi_safi_str(afi, safi, false),\n\t\t\t\tpeer->host, vrf ? vrf->name : VRF_DEFAULT_NAME);\n\t\t}\n\t}\n\n\t/* Everything is done.  We unintern temporary structures which\n\t   interned in bgp_attr_parse(). */\n\tbgp_attr_unintern_sub(&attr);\n\n\tpeer->update_time = monotime(NULL);\n\n\t/* Notify BGP Conditional advertisement scanner process */\n\tpeer->advmap_table_change = true;\n\n\treturn Receive_UPDATE_message;\n}""}]","{""code"": 1, ""value"": 1}","[{""source"": ""code_info(file:bgp_packet.c, lines:2040-2060)"", ""result"": ""\t\t\t\tpeer);\n\n\t\tif (ret && bgp_debug_update(peer, NULL, NULL, 1)) {\n\t\t\tzlog_debug(\""%pBP rcvd UPDATE w/ attr: %s\"", peer,\n\t\t\t\t   peer->rcvd_attr_str);\n\t\t\tpeer->rcvd_attr_printed = 1;\n\t\t}\n\t}\n\n\t/* Network Layer Reachability Information. */\n\tupdate_len = end - stream_pnt(s);\n\n\tif (update_len) {\n\t\t/* Set NLRI portion to structure. */\n\t\tnlris[NLRI_UPDATE].afi = AFI_IP;\n\t\tnlris[NLRI_UPDATE].safi = SAFI_UNICAST;\n\t\tnlris[NLRI_UPDATE].nlri = stream_pnt(s);\n\t\tnlris[NLRI_UPDATE].length = update_len;\n\t\tstream_forward_getp(s, update_len);\n\n\t\tif (CHECK_FLAG(attr.flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\t\t/*\n""}, {""source"": ""value_info(file:bgp_packet.c, value:attribute_len)"", ""result"": {""value_trace"": [{""full_code"": ""attribute_len = stream_getw(s)"", ""line"": 1990, ""func_name"": ""bgp_update_receive""}], ""struct_var"": ""attribute_len"", ""struct_type"": ""bgp_size_t"", ""struct_definition"": ""typedef uint16_t bgp_size_t;""}}]","1. A malformed BGP UPDATE message with attribute_len=0 and non-zero update_len is received.\n2. In bgpd/bgp_packet.c:2050, `if (update_len)` is true, but `attribute_len` (derived from stream_getw(s) at bgpd/bgp_packet.c:1990) is zero.\n3. Attributes (e.g., aspath) are not parsed, leaving `attr` uninitialized/NULL.\n4. bgp_nlri_parse (bgpd/bgp_packet.c:339) and bgp_update (bgpd/bgp_route.c:4374) process the NULL `attr`.\n5. Route-map application (bgpd/bgp_route.c:1772) calls route_set_aspath_prepend (bgpd/bgp_routemap.c:2258), which dereferences the NULL aspath, causing a crash.",0.95,./github/other_context/CVE-2023-41358
48,CVE-2023-39975,CWE-415,c_cpp,kdc/do_tgs_req.c in MIT Kerberos 5 (aka krb5) 1.21 before 1.21.2 has a double free that is reachable if an authenticated user can trigger an authorization-data handling failure. Incorrect data is copied from one ticket to another.,https://github.com/krb5/krb5/commit/88a1701b423c13991a8064feeb26952d3641d840,"Fix double-free in KDC TGS processing\n\nWhen issuing a ticket for a TGS renew or validate request, copy only\nthe server field from the outer part of the header ticket to the new\nticket.  Copying the whole structure causes the enc_part pointer to be\naliased to the header ticket until krb5_encrypt_tkt_part() is called,\nresulting in a double-free if handle_authdata() fails.\n\n[ghudson@mit.edu: changed the fix to avoid aliasing enc_part rather\nthan check for aliasing before freeing; rewrote commit message]\n\nCVE-2023-39975:\n\nIn MIT krb5 release 1.21, an authenticated attacker can cause a KDC to\nfree the same pointer twice if it can induce a failure in\nauthorization data handling.\n\nticket: 9101 (new)\ntags: pullup\ntarget_version: 1.21-next",1,"[{""func_name"": ""tgs_issue_ticket"", ""file_path"": ""src/kdc/do_tgs_req.c"", ""func_code"": ""static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \""FINDING_SERVER_KEY\"";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the whole header ticket except for authorization data. */\n        ticket_reply = *t->header_tkt;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\""TGS_REQ : handle_authdata (%d)\""), ret);\n        *status = \""HANDLE_AUTHDATA\"";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \""KDC_RETURN_ENC_PADATA\"";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \""ISSUE\"", 0, NULL);\n    au_state->status = \""ISSUE\"";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}"", ""target"": 0}]","[{""func_name"": ""tgs_issue_ticket"", ""file_path"": ""src/kdc/do_tgs_req.c"", ""func_code"": ""static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \""FINDING_SERVER_KEY\"";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the header ticket server and all enc-part fields except for\n         * authorization data. */\n        ticket_reply.server = t->header_tkt->server;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\""TGS_REQ : handle_authdata (%d)\""), ret);\n        *status = \""HANDLE_AUTHDATA\"";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \""KDC_RETURN_ENC_PADATA\"";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \""ISSUE\"", 0, NULL);\n    au_state->status = \""ISSUE\"";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}""}]","{""code"": 2, ""function"": 7, ""value"": 2, ""caller"": 3}","[{""source"": ""code_info(file:do_tgs_req.c, lines:1011-1030)"", ""result"": ""\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the whole header ticket except for authorization data. */\n        ticket_reply = *t->header_tkt;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n""}, {""source"": ""func_info(func:handle_authdata)"", ""result"": [{""code"": ""krb5_error_code\nhandle_authdata(kdc_realm_t *realm, unsigned int flags, krb5_db_entry *client,\n                krb5_db_entry *server, krb5_db_entry *subject_server,\n                krb5_db_entry *local_tgt, krb5_keyblock *local_tgt_key,\n                krb5_keyblock *client_key, krb5_keyblock *server_key,\n                krb5_keyblock *subject_key, krb5_keyblock *replaced_reply_key,\n                krb5_data *req_pkt, krb5_kdc_req *req,\n                krb5_const_principal altcprinc, krb5_pac subject_pac,\n                krb5_enc_tkt_part *enc_tkt_req, krb5_data ***auth_indicators,\n                krb5_enc_tkt_part *enc_tkt_reply)\n{\n    krb5_context context = realm->realm_context;\n    kdcauthdata_handle *h;\n    krb5_error_code ret = 0;\n    size_t i;\n\n    if (req->msg_type == KRB5_TGS_REQ &&\n        req->authorization_data.ciphertext.data != NULL) {\n        /* Copy TGS request authdata.  This must be done first so that modules\n         * have access to the unencrypted request authdata. */\n        ret = copy_request_authdata(context, client_key, req, enc_tkt_req,\n                                    &enc_tkt_reply->authorization_data);\n        if (ret)\n            return ret;\n    }\n\n    /* Invoke loaded module handlers. */\n    if (!isflagset(enc_tkt_reply->flags, TKT_FLG_ANONYMOUS)) {\n        for (i = 0; i < n_authdata_modules; i++) {\n            h = &authdata_modules[i];\n            ret = h->vt.handle(context, h->data, flags, client, server,\n                               subject_server, client_key, server_key,\n                               subject_key, req_pkt, req, altcprinc,\n                               enc_tkt_req, enc_tkt_reply);\n            if (ret)\n                kdc_err(context, ret, \""from authdata module %s\"", h->vt.name);\n        }\n    }\n\n    if (req->msg_type == KRB5_TGS_REQ) {\n        /* Copy authdata from the TGT to the issued ticket. */\n        ret = copy_tgt_authdata(context, req, enc_tkt_req->authorization_data,\n                                &enc_tkt_reply->authorization_data);\n        if (ret)\n            return ret;\n    }\n\n    return handle_pac(realm, flags, client, server, subject_server, local_tgt,\n                      local_tgt_key, server_key, subject_key,\n                      replaced_reply_key, enc_tkt_req, subject_pac, req,\n                      altcprinc, enc_tkt_reply->times.authtime, enc_tkt_reply,\n                      auth_indicators);\n}\n"", ""start_line"": 576, ""end_line"": 628, ""full_name"": ""handle_authdata"", ""file_path"": ""src/kdc/kdc_authdata.c""}]}, {""source"": ""value_info(file:do_tgs_req.c, value:ticket_reply)"", ""result"": {""value_trace"": [{""full_code"": ""ticket_reply = { 0 }"", ""line"": 969, ""func_name"": ""tgs_issue_ticket""}, {""full_code"": ""ticket_reply = *t->header_tkt"", ""line"": 1014, ""func_name"": ""tgs_issue_ticket""}], ""struct_var"": ""ticket_reply"", ""struct_type"": ""krb5_ticket"", ""struct_definition"": ""krb5_ticket""}}, {""source"": ""func_info(file:do_tgs_req.c, func:tgs_issue_ticket)"", ""result"": [{""code"": ""static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \""FINDING_SERVER_KEY\"";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the whole header ticket except for authorization data. */\n        ticket_reply = *t->header_tkt;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\""TGS_REQ : handle_authdata (%d)\""), ret);\n        *status = \""HANDLE_AUTHDATA\"";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \""KDC_RETURN_ENC_PADATA\"";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \""ISSUE\"", 0, NULL);\n    au_state->status = \""ISSUE\"";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}\n"", ""start_line"": 955, ""end_line"": 1138, ""full_name"": ""tgs_issue_ticket"", ""file_path"": ""src/kdc/do_tgs_req.c""}]}, {""source"": ""caller_info(file:do_tgs_req.c, func:handle_authdata)"", ""result"": [{""call_line"": 1037, ""call_code"": ""handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply)"", ""caller_code"": ""static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \""FINDING_SERVER_KEY\"";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the whole header ticket except for authorization data. */\n        ticket_reply = *t->header_tkt;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\""TGS_REQ : handle_authdata (%d)\""), ret);\n        *status = \""HANDLE_AUTHDATA\"";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \""KDC_RETURN_ENC_PADATA\"";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \""ISSUE\"", 0, NULL);\n    au_state->status = \""ISSUE\"";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}\n"", ""caller_start"": 955, ""file_path"": ""src/kdc/do_tgs_req.c""}, {""call_line"": 270, ""call_code"": ""handle_authdata(realm, state->c_flags, state->client,\n                              state->server, NULL, state->local_tgt,\n                              &state->local_tgt_key, &state->client_keyblock,\n                              &state->server_keyblock, NULL,\n                              replaced_reply_key, state->req_pkt,\n                              state->request, NULL, NULL, NULL,\n                              &state->auth_indicators, &state->enc_tkt_reply)"", ""caller_code"": ""static void\nfinish_process_as_req(struct as_req_state *state, krb5_error_code errcode)\n{\n    kdc_realm_t *realm = state->active_realm;\n    krb5_context context = realm->realm_context;\n    krb5_keyblock *as_encrypting_key = NULL;\n    krb5_data *response = NULL;\n    const char *emsg = 0;\n    int did_log = 0;\n    loop_respond_fn oldrespond;\n    void *oldarg;\n    krb5_audit_state *au_state = state->au_state;\n    krb5_keyblock *replaced_reply_key = NULL;\n\n    assert(state);\n    oldrespond = state->respond;\n    oldarg = state->arg;\n\n    if (errcode)\n        goto egress;\n\n    au_state->stage = ENCR_REP;\n\n    state->ticket_reply.enc_part2 = &state->enc_tkt_reply;\n\n    errcode = check_kdcpolicy_as(context, state->request, state->client,\n                                 state->server, state->auth_indicators,\n                                 state->kdc_time, &state->enc_tkt_reply.times,\n                                 &state->status);\n    if (errcode)\n        goto egress;\n\n    errcode = get_first_current_key(context, state->server,\n                                    &state->server_keyblock);\n    if (errcode) {\n        state->status = \""FINDING_SERVER_KEY\"";\n        goto egress;\n    }\n\n    /* Start assembling the response */\n    state->reply.msg_type = KRB5_AS_REP;\n    state->reply.client = state->enc_tkt_reply.client; /* post canonization */\n    state->reply.ticket = &state->ticket_reply;\n    state->reply_encpart.session = &state->session_key;\n    if ((errcode = fetch_last_req_info(state->client,\n                                       &state->reply_encpart.last_req)))\n        goto egress;\n    state->reply_encpart.nonce = state->request->nonce;\n    state->reply_encpart.key_exp = get_key_exp(state->client);\n    state->reply_encpart.flags = state->enc_tkt_reply.flags;\n    state->reply_encpart.server = state->ticket_reply.server;\n    state->reply_encpart.times = state->enc_tkt_reply.times;\n    state->reply_encpart.caddrs = state->enc_tkt_reply.caddrs;\n    state->reply_encpart.enc_padata = NULL;\n\n    /* Fetch the padata info to be returned (do this before\n     *  authdata to handle possible replacement of reply key\n     */\n    errcode = return_padata(context, &state->rock, state->req_pkt,\n                            state->request, &state->reply,\n                            &state->client_keyblock, &state->pa_context);\n    if (errcode) {\n        state->status = \""KDC_RETURN_PADATA\"";\n        goto egress;\n    }\n\n    /* If we didn't find a client long-term key and no preauth mechanism\n     * replaced the reply key, error out now. */\n    if (state->client_keyblock.enctype == ENCTYPE_NULL) {\n        state->status = \""CANT_FIND_CLIENT_KEY\"";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto egress;\n    }\n\n    if (state->rock.replaced_reply_key)\n        replaced_reply_key = &state->client_keyblock;\n\n    errcode = handle_authdata(realm, state->c_flags, state->client,\n                              state->server, NULL, state->local_tgt,\n                              &state->local_tgt_key, &state->client_keyblock,\n                              &state->server_keyblock, NULL,\n                              replaced_reply_key, state->req_pkt,\n                              state->request, NULL, NULL, NULL,\n                              &state->auth_indicators, &state->enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\""AS_REQ : handle_authdata (%d)\""),\n                         errcode);\n        state->status = \""HANDLE_AUTHDATA\"";\n        goto egress;\n    }\n\n    errcode = check_indicators(context, state->server, state->auth_indicators);\n    if (errcode) {\n        state->status = \""HIGHER_AUTHENTICATION_REQUIRED\"";\n        goto egress;\n    }\n\n    errcode = krb5_encrypt_tkt_part(context, &state->server_keyblock,\n                                    &state->ticket_reply);\n    if (errcode)\n        goto egress;\n\n    errcode = kau_make_tkt_id(context, &state->ticket_reply,\n                              &au_state->tkt_out_id);\n    if (errcode)\n        goto egress;\n\n    state->ticket_reply.enc_part.kvno = current_kvno(state->server);\n    errcode = kdc_fast_response_handle_padata(state->rstate,\n                                              state->request,\n                                              &state->reply,\n                                              state->client_keyblock.enctype);\n    if (errcode)\n        goto egress;\n\n    /* now encode/encrypt the response */\n\n    state->reply.enc_part.enctype = state->client_keyblock.enctype;\n\n    errcode = kdc_fast_handle_reply_key(state->rstate, &state->client_keyblock,\n                                        &as_encrypting_key);\n    if (errcode)\n        goto egress;\n    errcode = return_enc_padata(context, state->req_pkt, state->request,\n                                as_encrypting_key, state->server,\n                                &state->reply_encpart, FALSE);\n    if (errcode) {\n        state->status = \""KDC_RETURN_ENC_PADATA\"";\n        goto egress;\n    }\n\n    if (kdc_fast_hide_client(state->rstate))\n        state->reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(context, KRB5_AS_REP, &state->reply_encpart,\n                                  0, as_encrypting_key, &state->reply,\n                                  &response);\n    if (state->client_key != NULL)\n        state->reply.enc_part.kvno = state->client_key->key_data_kvno;\n    if (errcode)\n        goto egress;\n\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(state->reply.enc_part.ciphertext.data, 0,\n           state->reply.enc_part.ciphertext.length);\n    free(state->reply.enc_part.ciphertext.data);\n\n    log_as_req(context, state->local_addr, state->remote_addr,\n               state->request, &state->reply, state->client, state->cname,\n               state->server, state->sname, state->kdc_time, 0, 0, 0);\n    did_log = 1;\n\negress:\n    if (errcode != 0 && state->status == NULL)\n        state->status = \""UNKNOWN_REASON\"";\n\n    au_state->status = state->status;\n    au_state->reply = &state->reply;\n    kau_as_req(context, (errcode || state->preauth_err) ? FALSE : TRUE,\n               au_state);\n    kau_free_kdc_req(au_state);\n\n    free_padata_context(context, state->pa_context);\n    if (as_encrypting_key)\n        krb5_free_keyblock(context, as_encrypting_key);\n    if (errcode)\n        emsg = krb5_get_error_message(context, errcode);\n\n    if (state->status) {\n        log_as_req(context, state->local_addr, state->remote_addr,\n                   state->request, &state->reply, state->client,\n                   state->cname, state->server, state->sname, state->kdc_time,\n                   state->status, errcode, emsg);\n        did_log = 1;\n    }\n    if (errcode) {\n        if (state->status == 0) {\n            state->status = emsg;\n        }\n        if (errcode != KRB5KDC_ERR_DISCARD) {\n            errcode = prepare_error_as(state->rstate, state->request,\n                                       state->local_tgt, &state->local_tgt_key,\n                                       errcode, state->e_data,\n                                       state->typed_e_data,\n                                       ((state->client != NULL) ?\n                                        state->client->princ : NULL),\n                                       &response, state->status);\n            state->status = 0;\n        }\n    }\n\n    if (emsg)\n        krb5_free_error_message(context, emsg);\n    if (state->enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(context, state->enc_tkt_reply.authorization_data);\n    if (state->local_tgt_key.contents != NULL)\n        krb5_free_keyblock_contents(context, &state->local_tgt_key);\n    if (state->server_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(context, &state->server_keyblock);\n    if (state->client_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(context, &state->client_keyblock);\n    if (state->reply.padata != NULL)\n        krb5_free_pa_data(context, state->reply.padata);\n    if (state->reply_encpart.enc_padata)\n        krb5_free_pa_data(context, state->reply_encpart.enc_padata);\n\n    if (state->cname != NULL)\n        free(state->cname);\n    if (state->sname != NULL)\n        free(state->sname);\n    krb5_db_free_principal(context, state->client);\n    krb5_db_free_principal(context, state->server);\n    krb5_db_free_principal(context, state->local_tgt_storage);\n    if (state->session_key.contents != NULL)\n        krb5_free_keyblock_contents(context, &state->session_key);\n    if (state->ticket_reply.enc_part.ciphertext.data != NULL) {\n        memset(state->ticket_reply.enc_part.ciphertext.data , 0,\n               state->ticket_reply.enc_part.ciphertext.length);\n        free(state->ticket_reply.enc_part.ciphertext.data);\n    }\n\n    krb5_free_pa_data(context, state->e_data);\n    krb5_free_data(context, state->inner_body);\n    kdc_free_rstate(state->rstate);\n    krb5_free_kdc_req(context, state->request);\n    k5_free_data_ptr_list(state->auth_indicators);\n    assert(did_log != 0);\n\n    free(state);\n    (*oldrespond)(oldarg, errcode, response);\n}\n"", ""caller_start"": 193, ""file_path"": ""src/kdc/do_as_req.c""}]}, {""source"": ""code_info(file:do_tgs_req.c, lines:1-200)"", ""result"": ""/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_tgs_req.c - KDC Routines to deal with TGS_REQ's */\n/*\n * Copyright 1990, 1991, 2001, 2007, 2008, 2009, 2013, 2014 by the\n * Massachusetts Institute of Technology.  All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \""as is\"" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \""AS IS\""\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \""k5-int.h\""\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif\n#endif\n\n#include \""kdc_util.h\""\n#include \""kdc_audit.h\""\n#include \""policy.h\""\n#include \""extern.h\""\n#include \""adm_proto.h\""\n#include <ctype.h>\n\nstruct tgs_req_info {\n    /* The decoded request.  Ownership is transferred to this structure.  This\n     * will be replaced with the inner FAST body if present. */\n    krb5_kdc_req *req;\n\n    /*\n     * The decrypted authentication header ticket from the request's\n     * PA-TGS-REQ, the KDB entry for its server, its encryption key, the\n     * PA-TGS-REQ subkey if present, and the decoded and verified header ticket\n     * PAC if present.\n     */\n    krb5_ticket *header_tkt;\n    krb5_db_entry *header_server;\n    krb5_keyblock *header_key;\n    krb5_keyblock *subkey;\n    krb5_pac header_pac;\n\n    /*\n     * If a second ticket is present and this is a U2U or S4U2Proxy request,\n     * the decoded and verified PAC if present, the KDB entry for the second\n     * ticket server server, and the key used to decrypt the second ticket.\n     */\n    krb5_pac stkt_pac;\n    krb5_db_entry *stkt_server;\n    krb5_keyblock *stkt_server_key;\n    /* For cross-realm S4U2Proxy requests, the client principal retrieved from\n     * stkt_pac. */\n    krb5_principal stkt_pac_client;\n\n    /* Storage for the local TGT KDB entry for the service realm if that isn't\n     * the header server. */\n    krb5_db_entry *local_tgt_storage;\n    /* The decrypted first key of the local TGT entry. */\n    krb5_keyblock local_tgt_key;\n\n    /* The server KDB entry.  Normally the requested server, but for referral\n     * and alternate TGS replies this will be a cross-realm TGT entry. */\n    krb5_db_entry *server;\n\n    /*\n     * The subject client KDB entry for an S4U2Self request, or the header\n     * ticket client KDB entry for other requests.  NULL if\n     * NO_AUTH_DATA_REQUIRED is set on the server KDB entry and this isn't an\n     * S4U2Self request, or if the client is in another realm and the KDB\n     * cannot map its principal name.\n     */\n    krb5_db_entry *client;\n\n    /* The decoded S4U2Self padata from the request, if present. */\n    krb5_pa_s4u_x509_user *s4u2self;\n\n    /* Authentication indicators retrieved from the header ticket, for\n     * non-S4U2Self requests. */\n    krb5_data **auth_indicators;\n\n    /* Storage for a transited list with the header TGT realm added, if that\n     * realm is different from the client and server realm. */\n    krb5_data new_transited;\n\n    /* The KDB flags applicable to this request (a subset of {CROSS_REALM,\n     * ISSUING_REFERRAL, PROTOCOL_TRANSITION, CONSTRAINED_DELEGATION}). */\n    unsigned int flags;\n\n    /* Booleans for two of the above flags, for convenience. */\n    krb5_boolean is_referral;\n    krb5_boolean is_crossrealm;\n\n    /* The authtime of subject_tkt.  On early failures this may be 0. */\n    krb5_timestamp authtime;\n\n    /* The following fields are (or contain) alias pointers and should not be\n     * freed. */\n\n    /* The transited list implied by the request, aliasing new_transited or the\n     * header ticket transited field. */\n    krb5_transited transited;\n\n    /* Alias to the decrypted second ticket within req, if one applies to this\n     * request. */\n    const krb5_ticket *stkt;\n\n    /* Alias to stkt for S4U2Proxy requests, header_tkt otherwise. */\n    krb5_enc_tkt_part *subject_tkt;\n\n    /* Alias to local_tgt_storage or header_server. */\n    krb5_db_entry *local_tgt;\n\n    /* For either kind of S4U request, an alias to the requested client\n     * principal name. */\n    krb5_principal s4u_cprinc;\n\n    /* An alias to the client principal name we should issue the ticket for\n     * (either header_tkt->enc_part2->client or s4u_cprinc). */\n    krb5_principal tkt_client;\n\n    /* The client principal of the PA-TGS-REQ header ticket.  On early failures\n     * this may be NULL. */\n    krb5_principal cprinc;\n\n    /* The canonicalized request server principal or referral/alternate TGT.\n     * On early failures this may be the requested server instead. */\n    krb5_principal sprinc;\n\n};\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context, krb5_principal, krb5_flags,\n                 krb5_db_entry **, const char **);\n\nstatic krb5_error_code\nprepare_error_tgs(struct kdc_request_state *state, krb5_kdc_req *request,\n                  krb5_ticket *ticket, krb5_error_code code,\n                  krb5_principal canon_server, krb5_data **response,\n                  const char *status, krb5_pa_data **e_data)\n{\n    krb5_context context = state->realm_data->realm_context;\n    krb5_error errpkt;\n    krb5_error_code retval = 0;\n    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;\n\n    errpkt.magic = KV5M_ERROR;\n    errpkt.ctime = 0;\n    errpkt.cusec = 0;\n\n    retval = krb5_us_timeofday(context, &errpkt.stime, &errpkt.susec);\n    if (retval)\n        return(retval);\n    errpkt.error = errcode_to_protocol(code);\n    errpkt.server = request->server;\n    if (ticket && ticket->enc_part2)\n""}, {""source"": ""func_info(file:do_tgs_req.c, func:tgs_issue_ticket)"", ""result"": [{""code"": ""static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \""FINDING_SERVER_KEY\"";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the whole header ticket except for authorization data. */\n        ticket_reply = *t->header_tkt;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\""TGS_REQ : handle_authdata (%d)\""), ret);\n        *status = \""HANDLE_AUTHDATA\"";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \""KDC_RETURN_ENC_PADATA\"";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \""ISSUE\"", 0, NULL);\n    au_state->status = \""ISSUE\"";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}\n"", ""start_line"": 955, ""end_line"": 1138, ""full_name"": ""tgs_issue_ticket"", ""file_path"": ""src/kdc/do_tgs_req.c""}]}, {""source"": ""caller_info(file:do_tgs_req.c, func:tgs_issue_ticket)"", ""result"": [{""call_line"": 1195, ""call_code"": ""tgs_issue_ticket(realm, &t, tktflags, &times, pkt, from, fast_state,\n                           au_state, &status, response)"", ""caller_code"": ""krb5_error_code\nprocess_tgs_req(krb5_kdc_req *request, krb5_data *pkt,\n                const krb5_fulladdr *from, kdc_realm_t *realm,\n                krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    struct tgs_req_info t = { 0 };\n    struct kdc_request_state *fast_state = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_pa_data **e_data = NULL;\n    krb5_flags tktflags;\n    krb5_ticket_times times = { 0 };\n    const char *emsg = NULL, *status = NULL;\n\n    ret = kdc_make_rstate(realm, &fast_state);\n    if (ret)\n        goto cleanup;\n    ret = kau_init_kdc_req(context, request, from, &au_state);\n    if (ret)\n        goto cleanup;\n    kau_tgs_req(context, TRUE, au_state);\n\n    ret = gather_tgs_req_info(realm, &request, pkt, from, fast_state, au_state,\n                              &t, &status);\n    if (ret)\n        goto cleanup;\n\n    ret = check_tgs_req(realm, &t, au_state, &tktflags, &times, &status,\n                        &e_data);\n    if (ret)\n        goto cleanup;\n\n    ret = tgs_issue_ticket(realm, &t, tktflags, &times, pkt, from, fast_state,\n                           au_state, &status, response);\n    if (ret)\n        goto cleanup;\n\ncleanup:\n    if (status == NULL)\n        status = \""UNKNOWN_REASON\"";\n\n    if (ret) {\n        emsg = krb5_get_error_message(context, ret);\n        log_tgs_req(context, from, t.req, NULL, t.cprinc, t.sprinc,\n                    t.s4u_cprinc, t.authtime, t.flags, status, ret, emsg);\n        krb5_free_error_message(context, emsg);\n\n        if (au_state != NULL) {\n            au_state->status = status;\n            kau_tgs_req(context, FALSE, au_state);\n        }\n    }\n\n    if (ret && fast_state != NULL) {\n        ret = prepare_error_tgs(fast_state, t.req, t.header_tkt, ret,\n                                (t.server != NULL) ? t.server->princ : NULL,\n                                response, status, e_data);\n    }\n\n    krb5_free_kdc_req(context, request);\n    kdc_free_rstate(fast_state);\n    kau_free_kdc_req(au_state);\n    free_req_info(context, &t);\n    krb5_free_pa_data(context, e_data);\n    return ret;\n}\n"", ""caller_start"": 1162, ""file_path"": ""src/kdc/do_tgs_req.c""}]}, {""source"": ""func_info(func:handle_authdata)"", ""result"": [{""code"": ""krb5_error_code\nhandle_authdata(kdc_realm_t *realm, unsigned int flags, krb5_db_entry *client,\n                krb5_db_entry *server, krb5_db_entry *subject_server,\n                krb5_db_entry *local_tgt, krb5_keyblock *local_tgt_key,\n                krb5_keyblock *client_key, krb5_keyblock *server_key,\n                krb5_keyblock *subject_key, krb5_keyblock *replaced_reply_key,\n                krb5_data *req_pkt, krb5_kdc_req *req,\n                krb5_const_principal altcprinc, krb5_pac subject_pac,\n                krb5_enc_tkt_part *enc_tkt_req, krb5_data ***auth_indicators,\n                krb5_enc_tkt_part *enc_tkt_reply)\n{\n    krb5_context context = realm->realm_context;\n    kdcauthdata_handle *h;\n    krb5_error_code ret = 0;\n    size_t i;\n\n    if (req->msg_type == KRB5_TGS_REQ &&\n        req->authorization_data.ciphertext.data != NULL) {\n        /* Copy TGS request authdata.  This must be done first so that modules\n         * have access to the unencrypted request authdata. */\n        ret = copy_request_authdata(context, client_key, req, enc_tkt_req,\n                                    &enc_tkt_reply->authorization_data);\n        if (ret)\n            return ret;\n    }\n\n    /* Invoke loaded module handlers. */\n    if (!isflagset(enc_tkt_reply->flags, TKT_FLG_ANONYMOUS)) {\n        for (i = 0; i < n_authdata_modules; i++) {\n            h = &authdata_modules[i];\n            ret = h->vt.handle(context, h->data, flags, client, server,\n                               subject_server, client_key, server_key,\n                               subject_key, req_pkt, req, altcprinc,\n                               enc_tkt_req, enc_tkt_reply);\n            if (ret)\n                kdc_err(context, ret, \""from authdata module %s\"", h->vt.name);\n        }\n    }\n\n    if (req->msg_type == KRB5_TGS_REQ) {\n        /* Copy authdata from the TGT to the issued ticket. */\n        ret = copy_tgt_authdata(context, req, enc_tkt_req->authorization_data,\n                                &enc_tkt_reply->authorization_data);\n        if (ret)\n            return ret;\n    }\n\n    return handle_pac(realm, flags, client, server, subject_server, local_tgt,\n                      local_tgt_key, server_key, subject_key,\n                      replaced_reply_key, enc_tkt_req, subject_pac, req,\n                      altcprinc, enc_tkt_reply->times.authtime, enc_tkt_reply,\n                      auth_indicators);\n}\n"", ""start_line"": 576, ""end_line"": 628, ""full_name"": ""handle_authdata"", ""file_path"": ""src/kdc/kdc_authdata.c""}]}, {""source"": ""func_info(func:cleanup)"", ""result"": [{""code"": ""int WorkList::cleanup() {\n    CloseHandle(hEvent);\n    hEvent = INVALID_HANDLE_VALUE;\n    return 0;\n    }"", ""start_line"": 111, ""end_line"": 115, ""full_name"": ""WorkList.cleanup:int()"", ""file_path"": ""src/ccapi/server/win/WorkItem.cpp""}, {""code"": ""static void cleanup(void)\n{\n     client_list *c, *c2;\n\n     PRINTF((\""cleanup_and_exit: starting\\n\""));\n\n     c = clients;\n     while (c) {\n\t  c2 = c;\n\t  c = c->next;\n\t  destroy_client(c2->client);\n\t  free(c2);\n     }\n\n     exit(0);\n}"", ""start_line"": 663, ""end_line"": 678, ""full_name"": ""cleanup"", ""file_path"": ""src/lib/rpc/svc_auth_gssapi.c""}, {""code"": ""static void\ncleanup(void *cbdata)\n{\n    struct data *d = cbdata;\n\n    free(d->residual);\n    free(d);\n}"", ""start_line"": 63, ""end_line"": 70, ""full_name"": ""cleanup<duplicate>0"", ""file_path"": ""src/util/profile/testmod/testmod_main.c""}]}, {""source"": ""value_info(file:do_tgs_req.c, value:t->header_tkt)"", ""result"": {""value_trace"": [{""full_code"": ""t->header_tkt"", ""line"": 617, ""func_name"": ""gather_tgs_req_info""}, {""full_code"": ""t->header_tkt"", ""line"": 620, ""func_name"": ""gather_tgs_req_info""}, {""full_code"": ""t->header_tkt"", ""line"": 621, ""func_name"": ""gather_tgs_req_info""}, {""full_code"": ""t->header_tkt"", ""line"": 626, ""func_name"": ""gather_tgs_req_info""}], ""struct_var"": ""t"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:do_tgs_req.c, func:free_req_info)"", ""result"": [{""code"": ""static void\nfree_req_info(krb5_context context, struct tgs_req_info *t)\n{\n    krb5_free_kdc_req(context, t->req);\n    krb5_free_ticket(context, t->header_tkt);\n    krb5_db_free_principal(context, t->header_server);\n    krb5_free_keyblock(context, t->header_key);\n    krb5_free_keyblock(context, t->subkey);\n    krb5_pac_free(context, t->header_pac);\n    krb5_pac_free(context, t->stkt_pac);\n    krb5_db_free_principal(context, t->stkt_server);\n    krb5_free_keyblock(context, t->stkt_server_key);\n    krb5_db_free_principal(context, t->local_tgt_storage);\n    krb5_free_keyblock_contents(context, &t->local_tgt_key);\n    krb5_db_free_principal(context, t->server);\n    krb5_db_free_principal(context, t->client);\n    krb5_free_pa_s4u_x509_user(context, t->s4u2self);\n    krb5_free_principal(context, t->stkt_pac_client);\n    k5_free_data_ptr_list(t->auth_indicators);\n    krb5_free_data_contents(context, &t->new_transited);\n}"", ""start_line"": 1140, ""end_line"": 1160, ""full_name"": ""free_req_info"", ""file_path"": ""src/kdc/do_tgs_req.c""}]}, {""source"": ""func_info(file:do_tgs_req.c, func:tgs_issue_ticket)"", ""result"": [{""code"": ""static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \""FINDING_SERVER_KEY\"";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the whole header ticket except for authorization data. */\n        ticket_reply = *t->header_tkt;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\""TGS_REQ : handle_authdata (%d)\""), ret);\n        *status = \""HANDLE_AUTHDATA\"";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \""KDC_RETURN_ENC_PADATA\"";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \""ISSUE\"", 0, NULL);\n    au_state->status = \""ISSUE\"";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}\n"", ""start_line"": 955, ""end_line"": 1138, ""full_name"": ""tgs_issue_ticket"", ""file_path"": ""src/kdc/do_tgs_req.c""}]}, {""source"": ""caller_info(file:do_tgs_req.c, func:tgs_issue_ticket)"", ""result"": [{""call_line"": 1195, ""call_code"": ""tgs_issue_ticket(realm, &t, tktflags, &times, pkt, from, fast_state,\n                           au_state, &status, response)"", ""caller_code"": ""krb5_error_code\nprocess_tgs_req(krb5_kdc_req *request, krb5_data *pkt,\n                const krb5_fulladdr *from, kdc_realm_t *realm,\n                krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    struct tgs_req_info t = { 0 };\n    struct kdc_request_state *fast_state = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_pa_data **e_data = NULL;\n    krb5_flags tktflags;\n    krb5_ticket_times times = { 0 };\n    const char *emsg = NULL, *status = NULL;\n\n    ret = kdc_make_rstate(realm, &fast_state);\n    if (ret)\n        goto cleanup;\n    ret = kau_init_kdc_req(context, request, from, &au_state);\n    if (ret)\n        goto cleanup;\n    kau_tgs_req(context, TRUE, au_state);\n\n    ret = gather_tgs_req_info(realm, &request, pkt, from, fast_state, au_state,\n                              &t, &status);\n    if (ret)\n        goto cleanup;\n\n    ret = check_tgs_req(realm, &t, au_state, &tktflags, &times, &status,\n                        &e_data);\n    if (ret)\n        goto cleanup;\n\n    ret = tgs_issue_ticket(realm, &t, tktflags, &times, pkt, from, fast_state,\n                           au_state, &status, response);\n    if (ret)\n        goto cleanup;\n\ncleanup:\n    if (status == NULL)\n        status = \""UNKNOWN_REASON\"";\n\n    if (ret) {\n        emsg = krb5_get_error_message(context, ret);\n        log_tgs_req(context, from, t.req, NULL, t.cprinc, t.sprinc,\n                    t.s4u_cprinc, t.authtime, t.flags, status, ret, emsg);\n        krb5_free_error_message(context, emsg);\n\n        if (au_state != NULL) {\n            au_state->status = status;\n            kau_tgs_req(context, FALSE, au_state);\n        }\n    }\n\n    if (ret && fast_state != NULL) {\n        ret = prepare_error_tgs(fast_state, t.req, t.header_tkt, ret,\n                                (t.server != NULL) ? t.server->princ : NULL,\n                                response, status, e_data);\n    }\n\n    krb5_free_kdc_req(context, request);\n    kdc_free_rstate(fast_state);\n    kau_free_kdc_req(au_state);\n    free_req_info(context, &t);\n    krb5_free_pa_data(context, e_data);\n    return ret;\n}\n"", ""caller_start"": 1162, ""file_path"": ""src/kdc/do_tgs_req.c""}]}]","src/kdc/do_tgs_req.c:1014: Copying `*t->header_tkt` into `ticket_reply` aliases `enc_part`. If `handle_authdata` (src/kdc/kdc_authdata.c:576-628) fails, `cleanup` in `tgs_issue_ticket` frees `ticket_reply.enc_part.ciphertext.data`, which aliases `header_tkt.enc_part`. Later, `free_req_info` (src/kdc/do_tgs_req.c:1140-1160) calls `krb5_free_ticket(t->header_tkt)`, which also frees `enc_part`, causing a double-free.",0.95,./github/other_context/CVE-2023-39975
49,CVE-2023-43898,CWE-476,c_cpp,Nothings stb 2.28 was discovered to contain a Null Pointer Dereference via the function stbi__convert_format. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted pic file.,https://github.com/nothings/stb/commit/4e58258d8c434111fe2e8f1146ae0a72b0e8c554,"Fix nullptr dereference when a PIC file causes stbi__pic_load_core to return 0, and the requested number of components to stbi_load_from_memory is not 0 or 4",1,"[{""func_name"": ""stbi__pic_load"", ""file_path"": ""stb_image.h"", ""func_code"": ""static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *result;\n   int i, x,y, internal_comp;\n   STBI_NOTUSED(ri);\n\n   if (!comp) comp = &internal_comp;\n\n   for (i=0; i<92; ++i)\n      stbi__get8(s);\n\n   x = stbi__get16be(s);\n   y = stbi__get16be(s);\n\n   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n\n   if (stbi__at_eof(s))  return stbi__errpuc(\""bad file\"",\""file too short (pic header)\"");\n   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(\""too large\"", \""PIC image too large to decode\"");\n\n   stbi__get32be(s); //skip `ratio'\n   stbi__get16be(s); //skip `fields'\n   stbi__get16be(s); //skip `pad'\n\n   // intermediate buffer is RGBA\n   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);\n   if (!result) return stbi__errpuc(\""outofmem\"", \""Out of memory\"");\n   memset(result, 0xff, x*y*4);\n\n   if (!stbi__pic_load_core(s,x,y,comp, result)) {\n      STBI_FREE(result);\n      result=0;\n   }\n   *px = x;\n   *py = y;\n   if (req_comp == 0) req_comp = *comp;\n   result=stbi__convert_format(result,4,req_comp,x,y);\n\n   return result;\n}"", ""target"": 0}]","[{""func_name"": ""stbi__pic_load"", ""file_path"": ""stb_image.h"", ""func_code"": ""static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *result;\n   int i, x,y, internal_comp;\n   STBI_NOTUSED(ri);\n\n   if (!comp) comp = &internal_comp;\n\n   for (i=0; i<92; ++i)\n      stbi__get8(s);\n\n   x = stbi__get16be(s);\n   y = stbi__get16be(s);\n\n   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\""too large\"",\""Very large image (corrupt?)\"");\n\n   if (stbi__at_eof(s))  return stbi__errpuc(\""bad file\"",\""file too short (pic header)\"");\n   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(\""too large\"", \""PIC image too large to decode\"");\n\n   stbi__get32be(s); //skip `ratio'\n   stbi__get16be(s); //skip `fields'\n   stbi__get16be(s); //skip `pad'\n\n   // intermediate buffer is RGBA\n   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);\n   if (!result) return stbi__errpuc(\""outofmem\"", \""Out of memory\"");\n   memset(result, 0xff, x*y*4);\n\n   if (!stbi__pic_load_core(s,x,y,comp, result)) {\n      STBI_FREE(result);\n      return 0;\n   }\n   *px = x;\n   *py = y;\n   if (req_comp == 0) req_comp = *comp;\n   result=stbi__convert_format(result,4,req_comp,x,y);\n\n   return result;\n}""}]","{""code"": 1}","[{""source"": ""code_info(file:stb_image.h, lines:6531-6550)"", ""result"": ""   }\n   *px = x;\n   *py = y;\n   if (req_comp == 0) req_comp = *comp;\n   result=stbi__convert_format(result,4,req_comp,x,y);\n\n   return result;\n}\n\nstatic int stbi__pic_test(stbi__context *s)\n{\n   int r = stbi__pic_test_core(s);\n   stbi__rewind(s);\n   return r;\n}\n#endif\n\n// *************************************************************************************************\n// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb\n\n#ifndef STBI_NO_GIF\n""}]","The vulnerability arises when `stbi__pic_load_core` (called at `stb_image.h:6528`) returns 0, indicating failure. In the original code, `result` is set to 0 (`result=0;` at `stb_image.h:6530`), but execution continues. The null `result` is then passed to `stbi__convert_format(result, 4, req_comp, x, y)` at `stb_image.h:6534`, causing a null pointer dereference. The patch replaces `result=0;` with `return 0;` to exit the function immediately, preventing the dereference.",1.0,./github/other_context/CVE-2023-43898
50,CVE-2016-9624,CWE-476,c_cpp,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-33. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.,https://github.com/tats/w3m/commit/73397b6b7954971e3015b4f96b919ec90390e671,Prevent dereference near-null pointer in formUpdateBuffer\n\nBug-Debian: https://github.com/tats/w3m/issues/35\nOrigin: https://anonscm.debian.org/cgit/collab-maint/w3m.git/commit/?id=e2c7ecec6f9b730ad3c9bf8c8df9212970f183d7,1,"[{""func_name"": ""formUpdateBuffer"", ""file_path"": ""form.c"", ""func_code"": ""void\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len || spos < 0 || epos < 0)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}"", ""target"": 0}]","[{""func_name"": ""formUpdateBuffer"", ""file_path"": ""form.c"", ""func_code"": ""void\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len || spos < 0 || epos < 0)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}""}]","{""caller"": 4, ""value"": 3, ""code"": 1}","[{""source"": ""caller_info(func:formUpdateBuffer)"", ""result"": [{""call_line"": 219, ""call_code"": ""formUpdateBuffer(a2, buf, f2)"", ""caller_code"": ""void\nformRecheckRadio(Anchor *a, Buffer *buf, FormItemList *fi)\n{\n    int i;\n    Anchor *a2;\n    FormItemList *f2;\n\n    for (i = 0; i < buf->formitem->nanchor; i++) {\n\ta2 = &buf->formitem->anchors[i];\n\tf2 = (FormItemList *)a2->url;\n\tif (f2->parent == fi->parent && f2 != fi &&\n\t    f2->type == FORM_INPUT_RADIO && Strcmp(f2->name, fi->name) == 0) {\n\t    f2->checked = 0;\n\t    formUpdateBuffer(a2, buf, f2);\n\t}\n    }\n    fi->checked = 1;\n    formUpdateBuffer(a, buf, fi);\n}"", ""caller_start"": 206, ""file_path"": ""form.c""}, {""call_line"": 223, ""call_code"": ""formUpdateBuffer(a, buf, fi)"", ""caller_code"": ""void\nformRecheckRadio(Anchor *a, Buffer *buf, FormItemList *fi)\n{\n    int i;\n    Anchor *a2;\n    FormItemList *f2;\n\n    for (i = 0; i < buf->formitem->nanchor; i++) {\n\ta2 = &buf->formitem->anchors[i];\n\tf2 = (FormItemList *)a2->url;\n\tif (f2->parent == fi->parent && f2 != fi &&\n\t    f2->type == FORM_INPUT_RADIO && Strcmp(f2->name, fi->name) == 0) {\n\t    f2->checked = 0;\n\t    formUpdateBuffer(a2, buf, f2);\n\t}\n    }\n    fi->checked = 1;\n    formUpdateBuffer(a, buf, fi);\n}"", ""caller_start"": 206, ""file_path"": ""form.c""}, {""call_line"": 272, ""call_code"": ""formUpdateBuffer(a, buf, f1)"", ""caller_code"": ""void\nformResetBuffer(Buffer *buf, AnchorList *formitem)\n{\n    int i;\n    Anchor *a;\n    FormItemList *f1, *f2;\n\n    if (buf == NULL || buf->formitem == NULL || formitem == NULL)\n\treturn;\n    for (i = 0; i < buf->formitem->nanchor && i < formitem->nanchor; i++) {\n\ta = &buf->formitem->anchors[i];\n\tif (a->y != a->start.line)\n\t    continue;\n\tf1 = (FormItemList *)a->url;\n\tf2 = (FormItemList *)formitem->anchors[i].url;\n\tif (f1->type != f2->type ||\n\t    strcmp(((f1->name == NULL) ? \""\"" : f1->name->ptr),\n\t\t   ((f2->name == NULL) ? \""\"" : f2->name->ptr)))\n\t    break;\t\t/* What's happening */\n\tswitch (f1->type) {\n\tcase FORM_INPUT_TEXT:\n\tcase FORM_INPUT_PASSWORD:\n\tcase FORM_INPUT_FILE:\n\tcase FORM_TEXTAREA:\n\t    f1->value = f2->value;\n\t    f1->init_value = f2->init_value;\n\t    break;\n\tcase FORM_INPUT_CHECKBOX:\n\tcase FORM_INPUT_RADIO:\n\t    f1->checked = f2->checked;\n\t    f1->init_checked = f2->init_checked;\n\t    break;\n\tcase FORM_SELECT:\n#ifdef MENU_SELECT\n\t    f1->select_option = f2->select_option;\n\t    f1->value = f2->value;\n\t    f1->label = f2->label;\n\t    f1->selected = f2->selected;\n\t    f1->init_value = f2->init_value;\n\t    f1->init_label = f2->init_label;\n\t    f1->init_selected = f2->init_selected;\n#endif\t\t\t\t/* MENU_SELECT */\n\t    break;\n\tdefault:\n\t    continue;\n\t}\n\tformUpdateBuffer(a, buf, f1);\n    }\n}\n"", ""caller_start"": 226, ""file_path"": ""form.c""}, {""call_line"": 1031, ""call_code"": ""formUpdateBuffer(a, buf, fi)"", ""caller_code"": ""void\npreFormUpdateBuffer(Buffer *buf)\n{\n    struct pre_form *pf;\n    struct pre_form_item *pi;\n    int i;\n    Anchor *a;\n    FormList *fl;\n    FormItemList *fi;\n#ifdef MENU_SELECT\n    FormSelectOptionItem *opt;\n    int j;\n#endif\n\n    if (!buf || !buf->formitem || !PreForm)\n\treturn;\n\n    for (pf = PreForm; pf; pf = pf->next) {\n\tif (pf->re_url) {\n\t    Str url = parsedURL2Str(&buf->currentURL);\n\t    if (!RegexMatch(pf->re_url, url->ptr, url->length, 1))\n\t\tcontinue;\n\t}\n\telse if (pf->url) {\n\t    if (Strcmp_charp(parsedURL2Str(&buf->currentURL), pf->url))\n\t\tcontinue;\n\t}\n\telse\n\t    continue;\n\tfor (i = 0; i < buf->formitem->nanchor; i++) {\n\t    a = &buf->formitem->anchors[i];\n\t    fi = (FormItemList *)a->url;\n\t    fl = fi->parent;\n\t    if (pf->name && (!fl->name || strcmp(fl->name, pf->name)))\n\t\tcontinue;\n\t    if (pf->action\n\t\t&& (!fl->action || Strcmp_charp(fl->action, pf->action)))\n\t\tcontinue;\n\t    for (pi = pf->item; pi; pi = pi->next) {\n\t\tif (pi->type != fi->type)\n\t\t    continue;\n\t\tif (pi->type == FORM_INPUT_SUBMIT ||\n\t\t    pi->type == FORM_INPUT_IMAGE) {\n\t\t    if ((!pi->name || !*pi->name ||\n\t\t\t (fi->name && !Strcmp_charp(fi->name, pi->name))) &&\n\t\t\t(!pi->value || !*pi->value ||\n\t\t\t (fi->value && !Strcmp_charp(fi->value, pi->value))))\n\t\t\tbuf->submit = a;\n\t\t    continue;\n\t\t}\n\t\tif (!pi->name || !fi->name || Strcmp_charp(fi->name, pi->name))\n\t\t    continue;\n\t\tswitch (pi->type) {\n\t\tcase FORM_INPUT_TEXT:\n\t\tcase FORM_INPUT_FILE:\n\t\tcase FORM_INPUT_PASSWORD:\n\t\tcase FORM_TEXTAREA:\n\t\t    fi->value = Strnew_charp(pi->value);\n\t\t    formUpdateBuffer(a, buf, fi);\n\t\t    break;\n\t\tcase FORM_INPUT_CHECKBOX:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value)) {\n\t\t\tfi->checked = pi->checked;\n\t\t\tformUpdateBuffer(a, buf, fi);\n\t\t    }\n\t\t    break;\n\t\tcase FORM_INPUT_RADIO:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value))\n\t\t\tformRecheckRadio(a, buf, fi);\n\t\t    break;\n#ifdef MENU_SELECT\n\t\tcase FORM_SELECT:\n\t\t    for (j = 0, opt = fi->select_option; opt != NULL;\n\t\t\t j++, opt = opt->next) {\n\t\t\tif (pi->value && opt->value &&\n\t\t\t    !Strcmp_charp(opt->value, pi->value)) {\n\t\t\t    fi->selected = j;\n\t\t\t    fi->value = opt->value;\n\t\t\t    fi->label = opt->label;\n\t\t\t    updateSelectOption(fi, fi->select_option);\n\t\t\t    formUpdateBuffer(a, buf, fi);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    break;\n#endif\n\t\t}\n\t    }\n\t}\n    }\n}\n"", ""caller_start"": 973, ""file_path"": ""form.c""}]}, {""source"": ""value_info(file:form.c, value:buf->currentLine)"", ""result"": {""value_trace"": [{""full_code"": ""buf->currentLine = buf->lastLine = NULL"", ""line"": 72, ""func_name"": ""clearBuffer""}, {""full_code"": ""buf->currentLine = l"", ""line"": 255, ""func_name"": ""gotoLine""}], ""struct_var"": ""buf"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:form.c, lines:430-450)"", ""result"": ""    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n""}, {""source"": ""caller_info(file:form.c, func:formRecheckRadio)"", ""result"": [{""call_line"": 1043, ""call_code"": ""formRecheckRadio(a, buf, fi)"", ""caller_code"": ""void\npreFormUpdateBuffer(Buffer *buf)\n{\n    struct pre_form *pf;\n    struct pre_form_item *pi;\n    int i;\n    Anchor *a;\n    FormList *fl;\n    FormItemList *fi;\n#ifdef MENU_SELECT\n    FormSelectOptionItem *opt;\n    int j;\n#endif\n\n    if (!buf || !buf->formitem || !PreForm)\n\treturn;\n\n    for (pf = PreForm; pf; pf = pf->next) {\n\tif (pf->re_url) {\n\t    Str url = parsedURL2Str(&buf->currentURL);\n\t    if (!RegexMatch(pf->re_url, url->ptr, url->length, 1))\n\t\tcontinue;\n\t}\n\telse if (pf->url) {\n\t    if (Strcmp_charp(parsedURL2Str(&buf->currentURL), pf->url))\n\t\tcontinue;\n\t}\n\telse\n\t    continue;\n\tfor (i = 0; i < buf->formitem->nanchor; i++) {\n\t    a = &buf->formitem->anchors[i];\n\t    fi = (FormItemList *)a->url;\n\t    fl = fi->parent;\n\t    if (pf->name && (!fl->name || strcmp(fl->name, pf->name)))\n\t\tcontinue;\n\t    if (pf->action\n\t\t&& (!fl->action || Strcmp_charp(fl->action, pf->action)))\n\t\tcontinue;\n\t    for (pi = pf->item; pi; pi = pi->next) {\n\t\tif (pi->type != fi->type)\n\t\t    continue;\n\t\tif (pi->type == FORM_INPUT_SUBMIT ||\n\t\t    pi->type == FORM_INPUT_IMAGE) {\n\t\t    if ((!pi->name || !*pi->name ||\n\t\t\t (fi->name && !Strcmp_charp(fi->name, pi->name))) &&\n\t\t\t(!pi->value || !*pi->value ||\n\t\t\t (fi->value && !Strcmp_charp(fi->value, pi->value))))\n\t\t\tbuf->submit = a;\n\t\t    continue;\n\t\t}\n\t\tif (!pi->name || !fi->name || Strcmp_charp(fi->name, pi->name))\n\t\t    continue;\n\t\tswitch (pi->type) {\n\t\tcase FORM_INPUT_TEXT:\n\t\tcase FORM_INPUT_FILE:\n\t\tcase FORM_INPUT_PASSWORD:\n\t\tcase FORM_TEXTAREA:\n\t\t    fi->value = Strnew_charp(pi->value);\n\t\t    formUpdateBuffer(a, buf, fi);\n\t\t    break;\n\t\tcase FORM_INPUT_CHECKBOX:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value)) {\n\t\t\tfi->checked = pi->checked;\n\t\t\tformUpdateBuffer(a, buf, fi);\n\t\t    }\n\t\t    break;\n\t\tcase FORM_INPUT_RADIO:\n\t\t    if (pi->value && fi->value &&\n\t\t\t!Strcmp_charp(fi->value, pi->value))\n\t\t\tformRecheckRadio(a, buf, fi);\n\t\t    break;\n#ifdef MENU_SELECT\n\t\tcase FORM_SELECT:\n\t\t    for (j = 0, opt = fi->select_option; opt != NULL;\n\t\t\t j++, opt = opt->next) {\n\t\t\tif (pi->value && opt->value &&\n\t\t\t    !Strcmp_charp(opt->value, pi->value)) {\n\t\t\t    fi->selected = j;\n\t\t\t    fi->value = opt->value;\n\t\t\t    fi->label = opt->label;\n\t\t\t    updateSelectOption(fi, fi->select_option);\n\t\t\t    formUpdateBuffer(a, buf, fi);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    break;\n#endif\n\t\t}\n\t    }\n\t}\n    }\n}\n"", ""caller_start"": 973, ""file_path"": ""form.c""}, {""call_line"": 3485, ""call_code"": ""formRecheckRadio(a, Currentbuf, fi)"", ""caller_code"": ""static void\n_followForm(int submit)\n{\n    Line *l;\n    Anchor *a, *a2;\n    char *p;\n    FormItemList *fi, *f2;\n    Str tmp, tmp2;\n    int multipart = 0, i;\n\n    if (Currentbuf->firstLine == NULL)\n\treturn;\n    l = Currentbuf->currentLine;\n\n    a = retrieveCurrentForm(Currentbuf);\n    if (a == NULL)\n\treturn;\n    fi = (FormItemList *)a->url;\n    switch (fi->type) {\n    case FORM_INPUT_TEXT:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly)\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\t/* FIXME: gettextize? */\n\tp = inputStrHist(\""TEXT:\"", fi->value ? fi->value->ptr : NULL, TextHist);\n\tif (p == NULL || fi->readonly)\n\t    break;\n\tfi->value = Strnew_charp(p);\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tif (fi->accept || fi->parent->nitems == 1)\n\t    goto do_submit;\n\tbreak;\n    case FORM_INPUT_FILE:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly)\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\t/* FIXME: gettextize? */\n\tp = inputFilenameHist(\""Filename:\"", fi->value ? fi->value->ptr : NULL,\n\t\t\t      NULL);\n\tif (p == NULL || fi->readonly)\n\t    break;\n\tfi->value = Strnew_charp(p);\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tif (fi->accept || fi->parent->nitems == 1)\n\t    goto do_submit;\n\tbreak;\n    case FORM_INPUT_PASSWORD:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly) {\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\t    break;\n\t}\n\t/* FIXME: gettextize? */\n\tp = inputLine(\""Password:\"", fi->value ? fi->value->ptr : NULL,\n\t\t      IN_PASSWORD);\n\tif (p == NULL)\n\t    break;\n\tfi->value = Strnew_charp(p);\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tif (fi->accept)\n\t    goto do_submit;\n\tbreak;\n    case FORM_TEXTAREA:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly)\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\tinput_textarea(fi);\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tbreak;\n    case FORM_INPUT_RADIO:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly) {\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\t    break;\n\t}\n\tformRecheckRadio(a, Currentbuf, fi);\n\tbreak;\n    case FORM_INPUT_CHECKBOX:\n\tif (submit)\n\t    goto do_submit;\n\tif (fi->readonly) {\n\t    /* FIXME: gettextize? */\n\t    disp_message_nsec(\""Read only field!\"", FALSE, 1, TRUE, FALSE);\n\t    break;\n\t}\n\tfi->checked = !fi->checked;\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tbreak;\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (submit)\n\t    goto do_submit;\n\tif (!formChooseOptionByMenu(fi,\n\t\t\t\t    Currentbuf->cursorX - Currentbuf->pos +\n\t\t\t\t    a->start.pos + Currentbuf->rootX,\n\t\t\t\t    Currentbuf->cursorY + Currentbuf->rootY))\n\t    break;\n\tformUpdateBuffer(a, Currentbuf, fi);\n\tif (fi->parent->nitems == 1)\n\t    goto do_submit;\n\tbreak;\n#endif\t\t\t\t/* MENU_SELECT */\n    case FORM_INPUT_IMAGE:\n    case FORM_INPUT_SUBMIT:\n    case FORM_INPUT_BUTTON:\n      do_submit:\n\ttmp = Strnew();\n\ttmp2 = Strnew();\n\tmultipart = (fi->parent->method == FORM_METHOD_POST &&\n\t\t     fi->parent->enctype == FORM_ENCTYPE_MULTIPART);\n\tquery_from_followform(&tmp, fi, multipart);\n\n\ttmp2 = Strdup(fi->parent->action);\n\tif (!Strcmp_charp(tmp2, \""!CURRENT_URL!\"")) {\n\t    /* It means \""current URL\"" */\n\t    tmp2 = parsedURL2Str(&Currentbuf->currentURL);\n\t    if ((p = strchr(tmp2->ptr, '?')) != NULL)\n\t\tStrshrink(tmp2, (tmp2->ptr + tmp2->length) - p);\n\t}\n\n\tif (fi->parent->method == FORM_METHOD_GET) {\n\t    if ((p = strchr(tmp2->ptr, '?')) != NULL)\n\t\tStrshrink(tmp2, (tmp2->ptr + tmp2->length) - p);\n\t    Strcat_charp(tmp2, \""?\"");\n\t    Strcat(tmp2, tmp);\n\t    loadLink(tmp2->ptr, a->target, NULL, NULL);\n\t}\n\telse if (fi->parent->method == FORM_METHOD_POST) {\n\t    Buffer *buf;\n\t    if (multipart) {\n\t\tstruct stat st;\n\t\tstat(fi->parent->body, &st);\n\t\tfi->parent->length = st.st_size;\n\t    }\n\t    else {\n\t\tfi->parent->body = tmp->ptr;\n\t\tfi->parent->length = tmp->length;\n\t    }\n\t    buf = loadLink(tmp2->ptr, a->target, NULL, fi->parent);\n\t    if (multipart) {\n\t\tunlink(fi->parent->body);\n\t    }\n\t    if (buf && !(buf->bufferprop & BP_REDIRECTED)) {\t/* buf must be Currentbuf */\n\t\t/* BP_REDIRECTED means that the buffer is obtained through\n\t\t * Location: header. In this case, buf->form_submit must not be set\n\t\t * because the page is not loaded by POST method but GET method.\n\t\t */\n\t\tbuf->form_submit = save_submit_formlist(fi);\n\t    }\n\t}\n\telse if ((fi->parent->method == FORM_METHOD_INTERNAL && (!Strcmp_charp(fi->parent->action, \""map\"") || !Strcmp_charp(fi->parent->action, \""none\""))) || Currentbuf->bufferprop & BP_INTERNAL) {\t/* internal */\n\t    do_internal(tmp2->ptr, tmp->ptr);\n\t}\n\telse {\n\t    disp_err_message(\""Can't send form because of illegal method.\"",\n\t\t\t     FALSE);\n\t}\n\tbreak;\n    case FORM_INPUT_RESET:\n\tfor (i = 0; i < Currentbuf->formitem->nanchor; i++) {\n\t    a2 = &Currentbuf->formitem->anchors[i];\n\t    f2 = (FormItemList *)a2->url;\n\t    if (f2->parent == fi->parent &&\n\t\tf2->name && f2->value &&\n\t\tf2->type != FORM_INPUT_SUBMIT &&\n\t\tf2->type != FORM_INPUT_HIDDEN &&\n\t\tf2->type != FORM_INPUT_RESET) {\n\t\tf2->value = f2->init_value;\n\t\tf2->checked = f2->init_checked;\n#ifdef MENU_SELECT\n\t\tf2->label = f2->init_label;\n\t\tf2->selected = f2->init_selected;\n#endif\t\t\t\t/* MENU_SELECT */\n\t\tformUpdateBuffer(a2, Currentbuf, f2);\n\t    }\n\t}\n\tbreak;\n    case FORM_INPUT_HIDDEN:\n    default:\n\tbreak;\n    }\n    displayBuffer(Currentbuf, B_FORCE_REDRAW);\n}\n"", ""caller_start"": 3400, ""file_path"": ""main.c""}]}, {""source"": ""caller_info(file:form.c, func:formResetBuffer)"", ""result"": [{""call_line"": 607, ""call_code"": ""formResetBuffer(buf, sbuf.formitem)"", ""caller_code"": ""void\nreshapeBuffer(Buffer *buf)\n{\n    URLFile f;\n    Buffer sbuf;\n#ifdef USE_M17N\n    wc_uint8 old_auto_detect = WcOption.auto_detect;\n#endif\n\n    if (!buf->need_reshape)\n\treturn;\n    buf->need_reshape = FALSE;\n    buf->width = INIT_BUFFER_WIDTH;\n    if (buf->sourcefile == NULL)\n\treturn;\n    init_stream(&f, SCM_LOCAL, NULL);\n    examineFile(buf->mailcap_source ? buf->mailcap_source : buf->sourcefile,\n\t\t&f);\n    if (f.stream == NULL)\n\treturn;\n    copyBuffer(&sbuf, buf);\n    clearBuffer(buf);\n    while (buf->frameset) {\n\tdeleteFrameSet(buf->frameset);\n\tbuf->frameset = popFrameTree(&(buf->frameQ));\n    }\n\n    buf->href = NULL;\n    buf->name = NULL;\n    buf->img = NULL;\n    buf->formitem = NULL;\n    buf->formlist = NULL;\n    buf->linklist = NULL;\n    buf->maplist = NULL;\n    if (buf->hmarklist)\n\tbuf->hmarklist->nmark = 0;\n    if (buf->imarklist)\n\tbuf->imarklist->nmark = 0;\n\n    if (buf->header_source) {\n\tif (buf->currentURL.scheme != SCM_LOCAL ||\n\t    buf->mailcap_source || !strcmp(buf->currentURL.file, \""-\"")) {\n\t    URLFile h;\n\t    init_stream(&h, SCM_LOCAL, NULL);\n\t    examineFile(buf->header_source, &h);\n\t    if (h.stream) {\n\t\treadHeader(&h, buf, TRUE, NULL);\n\t\tUFclose(&h);\n\t    }\n\t}\n\telse if (buf->search_header)\t/* -m option */\n\t    readHeader(&f, buf, TRUE, NULL);\n    }\n\n#ifdef USE_M17N\n    WcOption.auto_detect = WC_OPT_DETECT_OFF;\n    UseContentCharset = FALSE;\n#endif\n    if (is_html_type(buf->type))\n\tloadHTMLBuffer(&f, buf);\n    else\n\tloadBuffer(&f, buf);\n    UFclose(&f);\n#ifdef USE_M17N\n    WcOption.auto_detect = old_auto_detect;\n    UseContentCharset = TRUE;\n#endif\n\n    buf->height = LASTLINE + 1;\n    if (buf->firstLine && sbuf.firstLine) {\n\tLine *cur = sbuf.currentLine;\n\tint n;\n\n\tbuf->pos = sbuf.pos + cur->bpos;\n\twhile (cur->bpos && cur->prev)\n\t    cur = cur->prev;\n\tif (cur->real_linenumber > 0)\n\t    gotoRealLine(buf, cur->real_linenumber);\n\telse\n\t    gotoLine(buf, cur->linenumber);\n\tn = (buf->currentLine->linenumber - buf->topLine->linenumber)\n\t    - (cur->linenumber - sbuf.topLine->linenumber);\n\tif (n) {\n\t    buf->topLine = lineSkip(buf, buf->topLine, n, FALSE);\n\t    if (cur->real_linenumber > 0)\n\t\tgotoRealLine(buf, cur->real_linenumber);\n\t    else\n\t\tgotoLine(buf, cur->linenumber);\n\t}\n\tbuf->pos -= buf->currentLine->bpos;\n\tif (FoldLine && !is_html_type(buf->type))\n\t    buf->currentColumn = 0;\n\telse\n\t    buf->currentColumn = sbuf.currentColumn;\n\tarrangeCursor(buf);\n    }\n    if (buf->check_url & CHK_URL)\n\tchkURLBuffer(buf);\n#ifdef USE_NNTP\n    if (buf->check_url & CHK_NMID)\n\tchkNMIDBuffer(buf);\n    if (buf->real_scheme == SCM_NNTP || buf->real_scheme == SCM_NEWS)\n\treAnchorNewsheader(buf);\n#endif\n    formResetBuffer(buf, sbuf.formitem);\n}\n"", ""caller_start"": 503, ""file_path"": ""buffer.c""}, {""call_line"": 6758, ""call_code"": ""formResetBuffer(newBuf, newBuf->formitem)"", ""caller_code"": ""Buffer *\nloadHTMLBuffer(URLFile *f, Buffer *newBuf)\n{\n    FILE *src = NULL;\n    Str tmp;\n\n    if (newBuf == NULL)\n\tnewBuf = newBuffer(INIT_BUFFER_WIDTH);\n    if (newBuf->sourcefile == NULL &&\n\t(f->scheme != SCM_LOCAL || newBuf->mailcap)) {\n\ttmp = tmpfname(TMPF_SRC, \"".html\"");\n\tsrc = fopen(tmp->ptr, \""w\"");\n\tif (src)\n\t    newBuf->sourcefile = tmp->ptr;\n    }\n\n    loadHTMLstream(f, newBuf, src, newBuf->bufferprop & BP_FRAME);\n\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    if (n_textarea)\n\tformResetBuffer(newBuf, newBuf->formitem);\n    if (src)\n\tfclose(src);\n\n    return newBuf;\n}"", ""caller_start"": 6736, ""file_path"": ""file.c""}, {""call_line"": 7296, ""call_code"": ""formResetBuffer(newBuf, newBuf->formitem)"", ""caller_code"": ""Buffer *\nloadHTMLString(Str page)\n{\n    URLFile f;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    Buffer *newBuf;\n\n    init_stream(&f, SCM_LOCAL, newStrStream(page));\n\n    newBuf = newBuffer(INIT_BUFFER_WIDTH);\n    if (SETJMP(AbortLoading) != 0) {\n\tTRAP_OFF;\n\tdiscardBuffer(newBuf);\n\tUFclose(&f);\n\treturn NULL;\n    }\n    TRAP_ON;\n\n#ifdef USE_M17N\n    newBuf->document_charset = InnerCharset;\n#endif\n    loadHTMLstream(&f, newBuf, NULL, TRUE);\n#ifdef USE_M17N\n    newBuf->document_charset = WC_CES_US_ASCII;\n#endif\n\n    TRAP_OFF;\n    UFclose(&f);\n    newBuf->topLine = newBuf->firstLine;\n    newBuf->lastLine = newBuf->currentLine;\n    newBuf->currentLine = newBuf->firstLine;\n    newBuf->type = \""text/html\"";\n    newBuf->real_type = newBuf->type;\n    if (n_textarea)\n\tformResetBuffer(newBuf, newBuf->formitem);\n    return newBuf;\n}"", ""caller_start"": 7262, ""file_path"": ""file.c""}, {""call_line"": 4119, ""call_code"": ""formResetBuffer(Currentbuf, formitem)"", ""caller_code"": ""DEFUN(backBf, BACK, \""Back to previous buffer\"")\n{\n    Buffer *buf = Currentbuf->linkBuffer[LB_N_FRAME];\n\n    if (!checkBackBuffer(Currentbuf)) {\n\tif (close_tab_back && nTab >= 1) {\n\t    deleteTab(CurrentTab);\n\t    displayBuffer(Currentbuf, B_FORCE_REDRAW);\n\t}\n\telse\n\t    /* FIXME: gettextize? */\n\t    disp_message(\""Can't back...\"", TRUE);\n\treturn;\n    }\n\n    delBuffer(Currentbuf);\n\n    if (buf) {\n\tif (buf->frameQ) {\n\t    struct frameset *fs;\n\t    long linenumber = buf->frameQ->linenumber;\n\t    long top = buf->frameQ->top_linenumber;\n\t    int pos = buf->frameQ->pos;\n\t    int currentColumn = buf->frameQ->currentColumn;\n\t    AnchorList *formitem = buf->frameQ->formitem;\n\n\t    fs = popFrameTree(&(buf->frameQ));\n\t    deleteFrameSet(buf->frameset);\n\t    buf->frameset = fs;\n\n\t    if (buf == Currentbuf) {\n\t\trFrame();\n\t\tCurrentbuf->topLine = lineSkip(Currentbuf,\n\t\t\t\t\t       Currentbuf->firstLine, top - 1,\n\t\t\t\t\t       FALSE);\n\t\tgotoLine(Currentbuf, linenumber);\n\t\tCurrentbuf->pos = pos;\n\t\tCurrentbuf->currentColumn = currentColumn;\n\t\tarrangeCursor(Currentbuf);\n\t\tformResetBuffer(Currentbuf, formitem);\n\t    }\n\t}\n\telse if (RenderFrame && buf == Currentbuf) {\n\t    delBuffer(Currentbuf);\n\t}\n    }\n    displayBuffer(Currentbuf, B_FORCE_REDRAW);\n}\n"", ""caller_start"": 4080, ""file_path"": ""main.c""}]}, {""source"": ""caller_info(file:form.c, func:preFormUpdateBuffer)"", ""result"": [{""call_line"": 2275, ""call_code"": ""preFormUpdateBuffer(b)"", ""caller_code"": ""Buffer *\nloadGeneralFile(char *path, ParsedURL *volatile current, char *referer,\n\t\tint flag, FormList *volatile request)\n{\n    URLFile f, *volatile of = NULL;\n    ParsedURL pu;\n    Buffer *b = NULL;\n    Buffer *(*volatile proc)(URLFile *, Buffer *) = loadBuffer;\n    char *volatile tpath;\n    char *volatile t = \""text/plain\"", *p, *volatile real_type = NULL;\n    Buffer *volatile t_buf = NULL;\n    int volatile searchHeader = SearchHeader;\n    int volatile searchHeader_through = TRUE;\n    MySignalHandler(*volatile prevtrap) (SIGNAL_ARG) = NULL;\n    TextList *extra_header = newTextList();\n    volatile Str uname = NULL;\n    volatile Str pwd = NULL;\n    volatile Str realm = NULL;\n    int volatile add_auth_cookie_flag;\n    unsigned char status = HTST_NORMAL;\n    URLOption url_option;\n    Str tmp;\n    Str volatile page = NULL;\n#ifdef USE_M17N\n    wc_ces charset = WC_CES_US_ASCII;\n#endif\n    HRequest hr;\n    ParsedURL *volatile auth_pu;\n\n    tpath = path;\n    prevtrap = NULL;\n    add_auth_cookie_flag = 0;\n\n    checkRedirection(NULL);\n\n  load_doc:\n    {\n\tconst char *sc_redirect;\n\tparseURL2(tpath, &pu, current);\n\tsc_redirect = query_SCONF_SUBSTITUTE_URL(&pu);\n\tif (sc_redirect && *sc_redirect && checkRedirection(&pu)) {\n\t    tpath = (char *)sc_redirect;\n\t    request = NULL;\n\t    add_auth_cookie_flag = 0;\n\t    current = New(ParsedURL);\n\t    *current = pu;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n    }\n    TRAP_OFF;\n    url_option.referer = referer;\n    url_option.flag = flag;\n    f = openURL(tpath, &pu, current, &url_option, request, extra_header, of,\n\t\t&hr, &status);\n    of = NULL;\n#ifdef USE_M17N\n    content_charset = 0;\n#endif\n    if (f.stream == NULL) {\n\tswitch (f.scheme) {\n\tcase SCM_LOCAL:\n\t    {\n\t\tstruct stat st;\n\t\tif (stat(pu.real_file, &st) < 0)\n\t\t    return NULL;\n\t\tif (S_ISDIR(st.st_mode)) {\n\t\t    if (UseExternalDirBuffer) {\n\t\t\tStr cmd = Sprintf(\""%s?dir=%s#current\"",\n\t\t\t\t\t  DirBufferCommand, pu.file);\n\t\t\tb = loadGeneralFile(cmd->ptr, NULL, NO_REFERER, 0,\n\t\t\t\t\t    NULL);\n\t\t\tif (b != NULL && b != NO_BUFFER) {\n\t\t\t    copyParsedURL(&b->currentURL, &pu);\n\t\t\t    b->filename = b->currentURL.real_file;\n\t\t\t}\n\t\t\treturn b;\n\t\t    }\n\t\t    else {\n\t\t\tpage = loadLocalDir(pu.real_file);\n\t\t\tt = \""local:directory\"";\n#ifdef USE_M17N\n\t\t\tcharset = SystemCharset;\n#endif\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase SCM_FTPDIR:\n\t    page = loadFTPDir(&pu, &charset);\n\t    t = \""ftp:directory\"";\n\t    break;\n#ifdef USE_NNTP\n\tcase SCM_NEWS_GROUP:\n\t    page = loadNewsgroup(&pu, &charset);\n\t    t = \""news:group\"";\n\t    break;\n#endif\n\tcase SCM_UNKNOWN:\n#ifdef USE_EXTERNAL_URI_LOADER\n\t    tmp = searchURIMethods(&pu);\n\t    if (tmp != NULL) {\n\t\tb = loadGeneralFile(tmp->ptr, current, referer, flag, request);\n\t\tif (b != NULL && b != NO_BUFFER)\n\t\t    copyParsedURL(&b->currentURL, &pu);\n\t\treturn b;\n\t    }\n#endif\n\t    /* FIXME: gettextize? */\n\t    disp_err_message(Sprintf(\""Unknown URI: %s\"",\n\t\t\t\t     parsedURL2Str(&pu)->ptr)->ptr, FALSE);\n\t    break;\n\t}\n\tif (page && page->length > 0)\n\t    goto page_loaded;\n\treturn NULL;\n    }\n\n    if (status == HTST_MISSING) {\n\tTRAP_OFF;\n\tUFclose(&f);\n\treturn NULL;\n    }\n\n    /* openURL() succeeded */\n    if (SETJMP(AbortLoading) != 0) {\n\t/* transfer interrupted */\n\tTRAP_OFF;\n\tif (b)\n\t    discardBuffer(b);\n\tUFclose(&f);\n\treturn NULL;\n    }\n\n    b = NULL;\n    if (f.is_cgi) {\n\t/* local CGI */\n\tsearchHeader = TRUE;\n\tsearchHeader_through = FALSE;\n    }\n    if (header_string)\n\theader_string = NULL;\n    TRAP_ON;\n    if (pu.scheme == SCM_HTTP ||\n#ifdef USE_SSL\n\tpu.scheme == SCM_HTTPS ||\n#endif\t\t\t\t/* USE_SSL */\n\t((\n#ifdef USE_GOPHER\n\t     (pu.scheme == SCM_GOPHER && non_null(GOPHER_proxy)) ||\n#endif\t\t\t\t/* USE_GOPHER */\n\t     (pu.scheme == SCM_FTP && non_null(FTP_proxy))\n\t ) && !Do_not_use_proxy && !check_no_proxy(pu.host))) {\n\n\tif (fmInitialized) {\n\t    term_cbreak();\n\t    /* FIXME: gettextize? */\n\t    message(Sprintf(\""%s contacted. Waiting for reply...\"", pu.host)->\n\t\t    ptr, 0, 0);\n\t    refresh();\n\t}\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n#if 0\t\t\t\t/* USE_SSL */\n\tif (IStype(f.stream) == IST_SSL) {\n\t    Str s = ssl_get_certificate(f.stream, pu.host);\n\t    if (s == NULL)\n\t\treturn NULL;\n\t    else\n\t\tt_buf->ssl_certificate = s->ptr;\n\t}\n#endif\n\treadHeader(&f, t_buf, FALSE, &pu);\n\tif (((http_response_code >= 301 && http_response_code <= 303)\n\t     || http_response_code == 307)\n\t    && (p = checkHeader(t_buf, \""Location:\"")) != NULL\n\t    && checkRedirection(&pu)) {\n\t    /* document moved */\n\t    /* 301: Moved Permanently */\n\t    /* 302: Found */\n\t    /* 303: See Other */\n\t    /* 307: Temporary Redirect (HTTP/1.1) */\n\t    tpath = url_encode(p, NULL, 0);\n\t    request = NULL;\n\t    UFclose(&f);\n\t    current = New(ParsedURL);\n\t    copyParsedURL(current, &pu);\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    t_buf->bufferprop |= BP_REDIRECTED;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n\tt = checkContentType(t_buf);\n\tif (t == NULL && pu.file != NULL) {\n\t    if (!((http_response_code >= 400 && http_response_code <= 407) ||\n\t\t  (http_response_code >= 500 && http_response_code <= 505)))\n\t\tt = guessContentType(pu.file);\n\t}\n\tif (t == NULL)\n\t    t = \""text/plain\"";\n\tif (add_auth_cookie_flag && realm && uname && pwd) {\n\t    /* If authorization is required and passed */\n\t    add_auth_user_passwd(&pu, qstr_unquote(realm)->ptr, uname, pwd, \n\t\t\t\t  0);\n\t    add_auth_cookie_flag = 0;\n\t}\n\tif ((p = checkHeader(t_buf, \""WWW-Authenticate:\"")) != NULL &&\n\t    http_response_code == 401) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \""WWW-Authenticate:\"") != NULL\n\t\t&& (realm = get_auth_param(hauth.param, \""realm\"")) != NULL) {\n\t\tauth_pu = &pu;\n\t\tgetAuthCookie(&hauth, \""Authorization:\"", extra_header,\n\t\t\t      auth_pu, &hr, request, &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tgoto load_doc;\n\t    }\n\t}\n\tif ((p = checkHeader(t_buf, \""Proxy-Authenticate:\"")) != NULL &&\n\t    http_response_code == 407) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \""Proxy-Authenticate:\"")\n\t\t!= NULL\n\t\t&& (realm = get_auth_param(hauth.param, \""realm\"")) != NULL) {\n\t\tauth_pu = schemeToProxy(pu.scheme);\n\t\tgetAuthCookie(&hauth, \""Proxy-Authorization:\"",\n\t\t\t      extra_header, auth_pu, &hr, request, \n\t\t\t      &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tadd_auth_user_passwd(auth_pu, qstr_unquote(realm)->ptr, uname, pwd, 1);\n\t\tgoto load_doc;\n\t    }\n\t}\n\t/* XXX: RFC2617 3.2.3 Authentication-Info: ? */\n\n\tif (status == HTST_CONNECT) {\n\t    of = &f;\n\t    goto load_doc;\n\t}\n\n\tf.modtime = mymktime(checkHeader(t_buf, \""Last-Modified:\""));\n    }\n#ifdef USE_NNTP\n    else if (pu.scheme == SCM_NEWS || pu.scheme == SCM_NNTP) {\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\treadHeader(&f, t_buf, TRUE, &pu);\n\tt = checkContentType(t_buf);\n\tif (t == NULL)\n\t    t = \""text/plain\"";\n    }\n#endif\t\t\t\t/* USE_NNTP */\n#ifdef USE_GOPHER\n    else if (pu.scheme == SCM_GOPHER) {\n\tswitch (*pu.file) {\n\tcase '0':\n\t    t = \""text/plain\"";\n\t    break;\n\tcase '1':\n\tcase 'm':\n\t    page = loadGopherDir(&f, &pu, &charset);\n\t    t = \""gopher:directory\"";\n\t    TRAP_OFF;\n\t    goto page_loaded;\n\tcase 's':\n\t    t = \""audio/basic\"";\n\t    break;\n\tcase 'g':\n\t    t = \""image/gif\"";\n\t    break;\n\tcase 'h':\n\t    t = \""text/html\"";\n\t    break;\n\t}\n    }\n#endif\t\t\t\t/* USE_GOPHER */\n    else if (pu.scheme == SCM_FTP) {\n\tcheck_compression(path, &f);\n\tif (f.compression != CMP_NOCOMPRESS) {\n\t    char *t1 = uncompressed_file_type(pu.file, NULL);\n\t    real_type = f.guess_type;\n#if 0\n\t    if (t1 && strncasecmp(t1, \""application/\"", 12) == 0) {\n\t\tf.compression = CMP_NOCOMPRESS;\n\t\tt = real_type;\n\t    }\n\t    else\n#endif\n\t    if (t1)\n\t\tt = t1;\n\t    else\n\t\tt = real_type;\n\t}\n\telse {\n\t    real_type = guessContentType(pu.file);\n\t    if (real_type == NULL)\n\t\treal_type = \""text/plain\"";\n\t    t = real_type;\n\t}\n#if 0\n\tif (!strncasecmp(t, \""application/\"", 12)) {\n\t    char *tmpf = tmpfname(TMPF_DFL, NULL)->ptr;\n\t    current_content_length = 0;\n\t    if (save2tmp(f, tmpf) < 0)\n\t\tUFclose(&f);\n\t    else {\n\t\tUFclose(&f);\n\t\tTRAP_OFF;\n\t\tdoFileMove(tmpf, guess_save_name(t_buf, pu.file));\n\t    }\n\t    return NO_BUFFER;\n\t}\n#endif\n    }\n    else if (pu.scheme == SCM_DATA) {\n\tt = f.guess_type;\n    }\n    else if (searchHeader) {\n\tsearchHeader = SearchHeader = FALSE;\n\tif (t_buf == NULL)\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\treadHeader(&f, t_buf, searchHeader_through, &pu);\n\tif (f.is_cgi && (p = checkHeader(t_buf, \""Location:\"")) != NULL &&\n\t    checkRedirection(&pu)) {\n\t    /* document moved */\n\t    tpath = url_encode(remove_space(p), NULL, 0);\n\t    request = NULL;\n\t    UFclose(&f);\n\t    add_auth_cookie_flag = 0;\n\t    current = New(ParsedURL);\n\t    copyParsedURL(current, &pu);\n\t    t_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    t_buf->bufferprop |= BP_REDIRECTED;\n\t    status = HTST_NORMAL;\n\t    goto load_doc;\n\t}\n#ifdef AUTH_DEBUG\n\tif ((p = checkHeader(t_buf, \""WWW-Authenticate:\"")) != NULL) {\n\t    /* Authentication needed */\n\t    struct http_auth hauth;\n\t    if (findAuthentication(&hauth, t_buf, \""WWW-Authenticate:\"") != NULL\n\t\t&& (realm = get_auth_param(hauth.param, \""realm\"")) != NULL) {\n\t\tauth_pu = &pu;\n\t\tgetAuthCookie(&hauth, \""Authorization:\"", extra_header,\n\t\t\t      auth_pu, &hr, request, &uname, &pwd);\n\t\tif (uname == NULL) {\n\t\t    /* abort */\n\t\t    TRAP_OFF;\n\t\t    goto page_loaded;\n\t\t}\n\t\tUFclose(&f);\n\t\tadd_auth_cookie_flag = 1;\n\t\tstatus = HTST_NORMAL;\n\t\tgoto load_doc;\n\t    }\n\t}\n#endif /* defined(AUTH_DEBUG) */\n\tt = checkContentType(t_buf);\n\tif (t == NULL)\n\t    t = \""text/plain\"";\n    }\n    else if (DefaultType) {\n\tt = DefaultType;\n\tDefaultType = NULL;\n    }\n    else {\n\tt = guessContentType(pu.file);\n\tif (t == NULL)\n\t    t = \""text/plain\"";\n\treal_type = t;\n\tif (f.guess_type)\n\t    t = f.guess_type;\n    }\n\n    /* XXX: can we use guess_type to give the type to loadHTMLstream\n     *      to support default utf8 encoding for XHTML here? */\n    f.guess_type = t;\n    \n  page_loaded:\n    if (page) {\n\tFILE *src;\n#ifdef USE_IMAGE\n\tif (image_source)\n\t    return NULL;\n#endif\n\ttmp = tmpfname(TMPF_SRC, \"".html\"");\n\tsrc = fopen(tmp->ptr, \""w\"");\n\tif (src) {\n\t    Str s;\n\t    s = wc_Str_conv_strict(page, InnerCharset, charset);\n\t    Strfputs(s, src);\n\t    fclose(src);\n\t}\n\tif (do_download) {\n\t    char *file;\n\t    if (!src)\n\t\treturn NULL;\n\t    file = guess_filename(pu.file);\n#ifdef USE_GOPHER\n\t    if (f.scheme == SCM_GOPHER)\n\t\tfile = Sprintf(\""%s.html\"", file)->ptr;\n#endif\n#ifdef USE_NNTP\n\t    if (f.scheme == SCM_NEWS_GROUP)\n\t\tfile = Sprintf(\""%s.html\"", file)->ptr;\n#endif\n\t    doFileMove(tmp->ptr, file);\n\t    return NO_BUFFER;\n\t}\n\tb = loadHTMLString(page);\n\tif (b) {\n\t    copyParsedURL(&b->currentURL, &pu);\n\t    b->real_scheme = pu.scheme;\n\t    b->real_type = t;\n\t    if (src)\n\t\tb->sourcefile = tmp->ptr;\n#ifdef USE_M17N\n\t    b->document_charset = charset;\n#endif\n\t}\n\treturn b;\n    }\n\n    if (real_type == NULL)\n\treal_type = t;\n    proc = loadBuffer;\n\n    current_content_length = 0;\n    if ((p = checkHeader(t_buf, \""Content-Length:\"")) != NULL)\n\tcurrent_content_length = strtoclen(p);\n    if (do_download) {\n\t/* download only */\n\tchar *file;\n\tTRAP_OFF;\n\tif (DecodeCTE && IStype(f.stream) != IST_ENCODED)\n\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\tif (pu.scheme == SCM_LOCAL) {\n\t    struct stat st;\n\t    if (PreserveTimestamp && !stat(pu.real_file, &st))\n\t\tf.modtime = st.st_mtime;\n\t    file = conv_from_system(guess_save_name(NULL, pu.real_file));\n\t}\n\telse\n\t    file = guess_save_name(t_buf, pu.file);\n\tif (doFileSave(f, file) == 0)\n\t    UFhalfclose(&f);\n\telse\n\t    UFclose(&f);\n\treturn NO_BUFFER;\n    }\n\n    if ((f.content_encoding != CMP_NOCOMPRESS) && AutoUncompress\n\t&& !(w3m_dump & DUMP_EXTRA)) {\n\tuncompress_stream(&f, &pu.real_file);\n    }\n    else if (f.compression != CMP_NOCOMPRESS) {\n\tif (!(w3m_dump & DUMP_SOURCE) &&\n\t    (w3m_dump & ~DUMP_FRAME || is_text_type(t)\n\t     || searchExtViewer(t))) {\n\t    if (t_buf == NULL)\n\t\tt_buf = newBuffer(INIT_BUFFER_WIDTH);\n\t    uncompress_stream(&f, &t_buf->sourcefile);\n\t    uncompressed_file_type(pu.file, &f.ext);\n\t}\n\telse {\n\t    t = compress_application_type(f.compression);\n\t    f.compression = CMP_NOCOMPRESS;\n\t}\n    }\n#ifdef USE_IMAGE\n    if (image_source) {\n\tBuffer *b = NULL;\n\tif (IStype(f.stream) != IST_ENCODED)\n\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\tif (save2tmp(f, image_source) == 0) {\n\t    b = newBuffer(INIT_BUFFER_WIDTH);\n\t    b->sourcefile = image_source;\n\t    b->real_type = t;\n\t}\n\tUFclose(&f);\n\tTRAP_OFF;\n\treturn b;\n    }\n#endif\n\n    if (is_html_type(t))\n\tproc = loadHTMLBuffer;\n    else if (is_plain_text_type(t))\n\tproc = loadBuffer;\n#ifdef USE_IMAGE\n    else if (activeImage && displayImage && !useExtImageViewer &&\n\t     !(w3m_dump & ~DUMP_FRAME) && !strncasecmp(t, \""image/\"", 6))\n\tproc = loadImageBuffer;\n#endif\n    else if (w3m_backend) ;\n    else if (!(w3m_dump & ~DUMP_FRAME) || is_dump_text_type(t)) {\n\tif (!do_download && searchExtViewer(t) != NULL) {\n\t    proc = DO_EXTERNAL;\n\t}\n\telse {\n\t    TRAP_OFF;\n\t    if (pu.scheme == SCM_LOCAL) {\n\t\tUFclose(&f);\n\t\t_doFileCopy(pu.real_file,\n\t\t\t    conv_from_system(guess_save_name\n\t\t\t\t\t     (NULL, pu.real_file)), TRUE);\n\t    }\n\t    else {\n\t\tif (DecodeCTE && IStype(f.stream) != IST_ENCODED)\n\t\t    f.stream = newEncodedStream(f.stream, f.encoding);\n\t\tif (doFileSave(f, guess_save_name(t_buf, pu.file)) == 0)\n\t\t    UFhalfclose(&f);\n\t\telse\n\t\t    UFclose(&f);\n\t    }\n\t    return NO_BUFFER;\n\t}\n    }\n    else if (w3m_dump & DUMP_FRAME)\n\treturn NULL;\n\n    if (t_buf == NULL)\n\tt_buf = newBuffer(INIT_BUFFER_WIDTH);\n    copyParsedURL(&t_buf->currentURL, &pu);\n    t_buf->filename = pu.real_file ? pu.real_file :\n\tpu.file ? conv_to_system(pu.file) : NULL;\n    if (flag & RG_FRAME) {\n\tt_buf->bufferprop |= BP_FRAME;\n    }\n#ifdef USE_SSL\n    t_buf->ssl_certificate = f.ssl_certificate;\n#endif\n    frame_source = flag & RG_FRAME_SRC;\n    if (proc == DO_EXTERNAL) {\n\tb = doExternal(f, t, t_buf);\n    } else {\n\tb = loadSomething(&f, proc, t_buf);\n    }\n    UFclose(&f);\n    frame_source = 0;\n    if (b && b != NO_BUFFER) {\n\tb->real_scheme = f.scheme;\n\tb->real_type = real_type;\n\tif (w3m_backend)\n\t    b->type = allocStr(t, -1);\n\tif (pu.label) {\n\t    if (proc == loadHTMLBuffer) {\n\t\tAnchor *a;\n\t\ta = searchURLLabel(b, pu.label);\n\t\tif (a != NULL) {\n\t\t    gotoLine(b, a->start.line);\n\t\t    if (label_topline)\n\t\t\tb->topLine = lineSkip(b, b->topLine,\n\t\t\t\t\t      b->currentLine->linenumber\n\t\t\t\t\t      - b->topLine->linenumber, FALSE);\n\t\t    b->pos = a->start.pos;\n\t\t    arrangeCursor(b);\n\t\t}\n\t    }\n\t    else {\t\t/* plain text */\n\t\tint l = atoi(pu.label);\n\t\tgotoRealLine(b, l);\n\t\tb->pos = 0;\n\t\tarrangeCursor(b);\n\t    }\n\t}\n    }\n    if (header_string)\n\theader_string = NULL;\n#ifdef USE_NNTP\n    if (b && b != NO_BUFFER && (f.scheme == SCM_NNTP || f.scheme == SCM_NEWS))\n\treAnchorNewsheader(b);\n#endif\n    if (b && b != NO_BUFFER)\n\tpreFormUpdateBuffer(b);\n    TRAP_OFF;\n    return b;\n}\n"", ""caller_start"": 1685, ""file_path"": ""file.c""}, {""call_line"": 921, ""call_code"": ""preFormUpdateBuffer(buf)"", ""caller_code"": ""Buffer *\nrenderFrame(Buffer *Cbuf, int force_reload)\n{\n    Str tmp;\n    FILE *f;\n    Buffer *buf;\n    int flag;\n    struct frameset *fset;\n#ifdef USE_M17N\n    wc_ces doc_charset = DocumentCharset;\n#endif\n\n    tmp = tmpfname(TMPF_FRAME, \"".html\"");\n    f = fopen(tmp->ptr, \""w\"");\n    if (f == NULL)\n\treturn NULL;\n    /* \n     * if (Cbuf->frameQ != NULL) fset = Cbuf->frameQ->frameset; else */\n    fset = Cbuf->frameset;\n    if (fset == NULL || createFrameFile(fset, f, Cbuf, 0, force_reload) < 0)\n\treturn NULL;\n    fclose(f);\n    flag = RG_FRAME;\n    if ((Cbuf->currentURL).is_nocache)\n\tflag |= RG_NOCACHE;\n    renderFrameSet = Cbuf->frameset;\n    flushFrameSet(renderFrameSet);\n#ifdef USE_M17N\n    DocumentCharset = InnerCharset;\n#endif\n    buf = loadGeneralFile(tmp->ptr, NULL, NULL, flag, NULL);\n#ifdef USE_M17N\n    DocumentCharset = doc_charset;\n#endif\n    renderFrameSet = NULL;\n    if (buf == NULL || buf == NO_BUFFER)\n\treturn NULL;\n    buf->sourcefile = tmp->ptr;\n#ifdef USE_M17N\n    buf->document_charset = Cbuf->document_charset;\n#endif\n    copyParsedURL(&buf->currentURL, &Cbuf->currentURL);\n    preFormUpdateBuffer(buf);\n    return buf;\n}\n"", ""caller_start"": 879, ""file_path"": ""frame.c""}]}, {""source"": ""value_info(file:form.c, value:Buffer)"", ""result"": {""value_trace"": [{""full_code"": ""b->linkBuffer[REV_LB[i]] = NULL"", ""line"": 94, ""func_name"": ""discardBuffer""}, {""full_code"": ""buf->nextBuffer = b->nextBuffer"", ""line"": 151, ""func_name"": ""deleteBuffer""}, {""full_code"": ""newbuf->nextBuffer = first"", ""line"": 166, ""func_name"": ""replaceBuffer""}, {""full_code"": ""newbuf->nextBuffer = delbuf->nextBuffer"", ""line"": 170, ""func_name"": ""replaceBuffer""}, {""full_code"": ""buf->nextBuffer = newbuf"", ""line"": 175, ""func_name"": ""replaceBuffer""}], ""struct_var"": ""Buffer"", ""struct_type"": ""Buffer"", ""struct_definition"": ""typedef struct _Buffer {\n    char *filename;\n    char *buffername;\n    Line *firstLine;\n    Line *topLine;\n    Line *currentLine;\n    Line *lastLine;\n    struct _Buffer *nextBuffer;\n    struct _Buffer *linkBuffer[MAX_LB];\n    short width;\n    short height;\n    char *type;\n    char *real_type;\n    int allLine;\n    short bufferprop;\n    int currentColumn;\n    short cursorX;\n    short cursorY;\n    int pos;\n    int visualpos;\n    short rootX;\n    short rootY;\n    short COLS;\n    short LINES;\n    InputStream pagerSource;\n    AnchorList *href;\n    AnchorList *name;\n    AnchorList *img;\n    AnchorList *formitem;\n    LinkList *linklist;\n    FormList *formlist;\n    MapList *maplist;\n    HmarkerList *hmarklist;\n    HmarkerList *imarklist;\n    ParsedURL currentURL;\n    ParsedURL *baseURL;\n    char *baseTarget;\n    int real_scheme;\n    char *sourcefile;\n    struct frameset *frameset;\n    struct frameset_queue *frameQ;\n    int *clone;\n    size_t trbyte;\n    char check_url;\n#ifdef USE_M17N\n    wc...""}}, {""source"": ""value_info(value:currentLine)"", ""result"": {""value_trace"": [{""full_code"": ""currentLine = sbuf.currentLine"", ""line"": 1767, ""func_name"": ""dispincsrch""}, {""full_code"": ""currentLine = Currentbuf->currentLine"", ""line"": 1817, ""func_name"": ""dispincsrch""}], ""struct_var"": ""currentLine"", ""struct_type"": ""Line*"", ""struct_definition"": ""typedef struct _Line {\n    char *lineBuf;\n    Lineprop *propBuf;\n#ifdef USE_ANSI_COLOR\n    Linecolor *colorBuf;\n#endif\n    struct _Line *next;\n    struct _Line *prev;\n    int len;\n    int width;\n    long linenumber;\t\t/* on buffer */\n    long real_linenumber;\t/* on file */\n    unsigned short usrflags;\n    int size;\n    int bpos;\n    int bwidth;\n} Line;""}}]","form.c:443-445: Access to `buf->currentLine->len` without a prior NULL check. `buf->currentLine` can be NULL if `clearBuffer` (form.c:72) is called, or if `gotoLine` (form.c:255) fails to initialize it. Callers like `formRecheckRadio` (form.c:219) and `preFormUpdateBuffer` (form.c:1031) may pass a `buf` with `currentLine` uninitialized, leading to a segmentation fault when the check is bypassed. The vulnerability is triggered when a crafted HTML page invokes form handling logic that calls `formUpdateBuffer` with an invalid `buf->currentLine`.",0.95,./github/other_context/CVE-2016-9624
51,CVE-2017-10917,CWE-476,c_cpp,"Xen through 4.8.x does not validate the port numbers of polled event channel ports, which allows guest OS users to cause a denial of service (NULL pointer dereference and host OS crash) or possibly obtain sensitive information, aka XSA-221.",https://github.com/xen-project/xen/commit/e7719a0dfac7a20cb7da5529e09773d8271bb78b,"evtchn: avoid NULL derefs\n\nCommit fbbd5009e6 (""evtchn: refactor low-level event channel port ops"")\nadded a de-reference of the struct evtchn pointer for a port without\nfirst making sure the bucket pointer is non-NULL. This de-reference is\nactually entirely unnecessary, as all relevant callers (beyond the\nproblematic do_poll()) already hold the port number in their hands, and\nthe actual leaf functions need nothing else.\n\nFor FIFO event channels there's a second problem in that the ordering\nof reads and updates to ->num_evtchns and ->event_array[] was so far\nundefined (the read side isn't always holding the domain's event lock).\nAdd respective barriers.\n\nThis is XSA-221.\n\nReported-by: Ankur Arora <ankur.a.arora@oracle.com>\nSigned-off-by: Jan Beulich <jbeulich@suse.com>",12,"[{""func_name"": ""evtchn_fifo_is_masked"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_masked(struct domain *d,\n                                    const struct evtchn *evtchn)\n{\n    event_word_t *word;\n\n    word = evtchn_fifo_word_from_port(d, evtchn->port);\n    if ( unlikely(!word) )\n        return 1;\n\n    return test_bit(EVTCHN_FIFO_MASKED, word);\n}"", ""target"": 0}, {""func_name"": ""evtchn_fifo_word_from_port"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static inline event_word_t *evtchn_fifo_word_from_port(struct domain *d,\n                                                       unsigned int port)\n{\n    unsigned int p, w;\n\n    if ( unlikely(port >= d->evtchn_fifo->num_evtchns) )\n        return NULL;\n\n    p = port / EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n    w = port % EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n\n    return d->evtchn_fifo->event_array[p] + w;\n}"", ""target"": 0}, {""func_name"": ""add_page_to_event_array"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static int add_page_to_event_array(struct domain *d, unsigned long gfn)\n{\n    void *virt;\n    unsigned int slot;\n    unsigned int port = d->evtchn_fifo->num_evtchns;\n    int rc;\n\n    slot = d->evtchn_fifo->num_evtchns / EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n    if ( slot >= EVTCHN_FIFO_MAX_EVENT_ARRAY_PAGES )\n        return -ENOSPC;\n\n    rc = map_guest_page(d, gfn, &virt);\n    if ( rc < 0 )\n        return rc;\n\n    d->evtchn_fifo->event_array[slot] = virt;\n    d->evtchn_fifo->num_evtchns += EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n\n    /*\n     * Re-raise any events that were pending while this array page was\n     * missing.\n     */\n    for ( ; port < d->evtchn_fifo->num_evtchns; port++ )\n    {\n        struct evtchn *evtchn;\n\n        if ( !port_is_valid(d, port) )\n            break;\n\n        evtchn = evtchn_from_port(d, port);\n        if ( evtchn->pending )\n            evtchn_fifo_set_pending(d->vcpu[evtchn->notify_vcpu_id], evtchn);\n    }\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""evtchn_fifo_is_pending"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_pending(struct domain *d,\n                                     const struct evtchn *evtchn)\n{\n    event_word_t *word;\n\n    word = evtchn_fifo_word_from_port(d, evtchn->port);\n    if ( unlikely(!word) )\n        return 0;\n\n    return test_bit(EVTCHN_FIFO_PENDING, word);\n}"", ""target"": 0}, {""func_name"": ""do_poll"", ""file_path"": ""xen/common/schedule.c"", ""func_code"": ""static long do_poll(struct sched_poll *sched_poll)\n{\n    struct vcpu   *v = current;\n    struct domain *d = v->domain;\n    evtchn_port_t  port;\n    long           rc;\n    unsigned int   i;\n\n    /* Fairly arbitrary limit. */\n    if ( sched_poll->nr_ports > 128 )\n        return -EINVAL;\n\n    if ( !guest_handle_okay(sched_poll->ports, sched_poll->nr_ports) )\n        return -EFAULT;\n\n    set_bit(_VPF_blocked, &v->pause_flags);\n    v->poll_evtchn = -1;\n    set_bit(v->vcpu_id, d->poll_mask);\n\n    arch_vcpu_block(v);\n\n#ifndef CONFIG_X86 /* set_bit() implies mb() on x86 */\n    /* Check for events /after/ setting flags: avoids wakeup waiting race. */\n    smp_mb();\n\n    /*\n     * Someone may have seen we are blocked but not that we are polling, or\n     * vice versa. We are certainly being woken, so clean up and bail. Beyond\n     * this point others can be guaranteed to clean up for us if they wake us.\n     */\n    rc = 0;\n    if ( (v->poll_evtchn == 0) ||\n         !test_bit(_VPF_blocked, &v->pause_flags) ||\n         !test_bit(v->vcpu_id, d->poll_mask) )\n        goto out;\n#endif\n\n    rc = 0;\n    if ( local_events_need_delivery() )\n        goto out;\n\n    for ( i = 0; i < sched_poll->nr_ports; i++ )\n    {\n        rc = -EFAULT;\n        if ( __copy_from_guest_offset(&port, sched_poll->ports, i, 1) )\n            goto out;\n\n        rc = -EINVAL;\n        if ( port >= d->max_evtchns )\n            goto out;\n\n        rc = 0;\n        if ( evtchn_port_is_pending(d, evtchn_from_port(d, port)) )\n            goto out;\n    }\n\n    if ( sched_poll->nr_ports == 1 )\n        v->poll_evtchn = port;\n\n    if ( sched_poll->timeout != 0 )\n        set_timer(&v->poll_timer, sched_poll->timeout);\n\n    TRACE_2D(TRC_SCHED_BLOCK, d->domain_id, v->vcpu_id);\n    raise_softirq(SCHEDULE_SOFTIRQ);\n\n    return 0;\n\n out:\n    v->poll_evtchn = 0;\n    clear_bit(v->vcpu_id, d->poll_mask);\n    clear_bit(_VPF_blocked, &v->pause_flags);\n    return rc;\n}"", ""target"": 0}, {""func_name"": ""dump_irqs"", ""file_path"": ""xen/arch/x86/irq.c"", ""func_code"": ""static void dump_irqs(unsigned char key)\n{\n    int i, irq, pirq;\n    struct irq_desc *desc;\n    irq_guest_action_t *action;\n    struct evtchn *evtchn;\n    struct domain *d;\n    const struct pirq *info;\n    unsigned long flags;\n    char *ssid;\n\n    printk(\""IRQ information:\\n\"");\n\n    for ( irq = 0; irq < nr_irqs; irq++ )\n    {\n        if ( !(irq & 0x1f) )\n            process_pending_softirqs();\n\n        desc = irq_to_desc(irq);\n\n        if ( !irq_desc_initialized(desc) || desc->handler == &no_irq_type )\n            continue;\n\n        ssid = in_irq() ? NULL : xsm_show_irq_sid(irq);\n\n        spin_lock_irqsave(&desc->lock, flags);\n\n        cpumask_scnprintf(keyhandler_scratch, sizeof(keyhandler_scratch),\n                          desc->affinity);\n        printk(\""   IRQ:%4d affinity:%s vec:%02x type=%-15s\""\n               \"" status=%08x \"",\n               irq, keyhandler_scratch, desc->arch.vector,\n               desc->handler->typename, desc->status);\n\n        if ( ssid )\n            printk(\""Z=%-25s \"", ssid);\n\n        if ( desc->status & IRQ_GUEST )\n        {\n            action = (irq_guest_action_t *)desc->action;\n\n            printk(\""in-flight=%d domain-list=\"", action->in_flight);\n\n            for ( i = 0; i < action->nr_guests; i++ )\n            {\n                d = action->guest[i];\n                pirq = domain_irq_to_pirq(d, irq);\n                info = pirq_info(d, pirq);\n                evtchn = evtchn_from_port(d, info->evtchn);\n                printk(\""%u:%3d(%c%c%c)\"",\n                       d->domain_id, pirq,\n                       (evtchn_port_is_pending(d, evtchn) ? 'P' : '-'),\n                       (evtchn_port_is_masked(d, evtchn) ? 'M' : '-'),\n                       (info->masked ? 'M' : '-'));\n                if ( i != action->nr_guests )\n                    printk(\"",\"");\n            }\n\n            printk(\""\\n\"");\n        }\n        else if ( desc->action )\n            printk(\""%ps()\\n\"", desc->action->handler);\n        else\n            printk(\""mapped, unbound\\n\"");\n\n        spin_unlock_irqrestore(&desc->lock, flags);\n\n        xfree(ssid);\n    }\n\n    process_pending_softirqs();\n    printk(\""Direct vector information:\\n\"");\n    for ( i = FIRST_DYNAMIC_VECTOR; i < NR_VECTORS; ++i )\n        if ( direct_apic_vector[i] )\n            printk(\""   %#02x -> %ps()\\n\"", i, direct_apic_vector[i]);\n\n    dump_ioapic_irq_info();\n}"", ""target"": 0}, {""func_name"": ""pirq_guest_unmask"", ""file_path"": ""xen/arch/x86/irq.c"", ""func_code"": ""int pirq_guest_unmask(struct domain *d)\n{\n    unsigned int pirq = 0, n, i;\n    struct pirq *pirqs[16];\n\n    do {\n        n = radix_tree_gang_lookup(&d->pirq_tree, (void **)pirqs, pirq,\n                                   ARRAY_SIZE(pirqs));\n        for ( i = 0; i < n; ++i )\n        {\n            pirq = pirqs[i]->pirq;\n            if ( pirqs[i]->masked &&\n                 !evtchn_port_is_masked(d, evtchn_from_port(d, pirqs[i]->evtchn)) )\n                pirq_guest_eoi(pirqs[i]);\n        }\n    } while ( ++pirq < d->nr_pirqs && n == ARRAY_SIZE(pirqs) );\n\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""domain_dump_evtchn_info"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static void domain_dump_evtchn_info(struct domain *d)\n{\n    unsigned int port;\n    int irq;\n\n    bitmap_scnlistprintf(keyhandler_scratch, sizeof(keyhandler_scratch),\n                         d->poll_mask, d->max_vcpus);\n    printk(\""Event channel information for domain %d:\\n\""\n           \""Polling vCPUs: {%s}\\n\""\n           \""    port [p/m/s]\\n\"", d->domain_id, keyhandler_scratch);\n\n    spin_lock(&d->event_lock);\n\n    for ( port = 1; port < d->max_evtchns; ++port )\n    {\n        const struct evtchn *chn;\n        char *ssid;\n\n        if ( !port_is_valid(d, port) )\n            continue;\n        chn = evtchn_from_port(d, port);\n        if ( chn->state == ECS_FREE )\n            continue;\n\n        printk(\""    %4u [%d/%d/\"",\n               port,\n               !!evtchn_port_is_pending(d, chn),\n               !!evtchn_port_is_masked(d, chn));\n        evtchn_port_print_state(d, chn);\n        printk(\""]: s=%d n=%d x=%d\"",\n               chn->state, chn->notify_vcpu_id, chn->xen_consumer);\n\n        switch ( chn->state )\n        {\n        case ECS_UNBOUND:\n            printk(\"" d=%d\"", chn->u.unbound.remote_domid);\n            break;\n        case ECS_INTERDOMAIN:\n            printk(\"" d=%d p=%d\"",\n                   chn->u.interdomain.remote_dom->domain_id,\n                   chn->u.interdomain.remote_port);\n            break;\n        case ECS_PIRQ:\n            irq = domain_pirq_to_irq(d, chn->u.pirq.irq);\n            printk(\"" p=%d i=%d\"", chn->u.pirq.irq, irq);\n            break;\n        case ECS_VIRQ:\n            printk(\"" v=%d\"", chn->u.virq);\n            break;\n        }\n\n        ssid = xsm_show_security_evtchn(d, chn);\n        if (ssid) {\n            printk(\"" Z=%s\\n\"", ssid);\n            xfree(ssid);\n        } else {\n            printk(\""\\n\"");\n        }\n    }\n\n    spin_unlock(&d->event_lock);\n}"", ""target"": 0}, {""func_name"": ""evtchn_port_is_pending"", ""file_path"": ""xen/include/xen/event.h"", ""func_code"": ""static inline bool_t evtchn_port_is_pending(struct domain *d,\n                                            const struct evtchn *evtchn)\n{\n    return d->evtchn_port_ops->is_pending(d, evtchn);\n}"", ""target"": 0}, {""func_name"": ""evtchn_port_is_masked"", ""file_path"": ""xen/include/xen/event.h"", ""func_code"": ""static inline bool_t evtchn_port_is_masked(struct domain *d,\n                                           const struct evtchn *evtchn)\n{\n    return d->evtchn_port_ops->is_masked(d, evtchn);\n}"", ""target"": 0}, {""func_name"": ""evtchn_2l_is_masked"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool_t evtchn_2l_is_masked(struct domain *d,\n                                  const struct evtchn *evtchn)\n{\n    return test_bit(evtchn->port, &shared_info(d, evtchn_mask));\n}"", ""target"": 0}, {""func_name"": ""evtchn_2l_is_pending"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool_t evtchn_2l_is_pending(struct domain *d,\n                                   const struct evtchn *evtchn)\n{\n    return test_bit(evtchn->port, &shared_info(d, evtchn_pending));\n}"", ""target"": 0}]","[{""func_name"": ""evtchn_fifo_is_masked"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_masked(struct domain *d, evtchn_port_t port)\n{\n    event_word_t *word;\n\n    word = evtchn_fifo_word_from_port(d, port);\n    if ( unlikely(!word) )\n        return 1;\n\n    return test_bit(EVTCHN_FIFO_MASKED, word);\n}""}, {""func_name"": ""evtchn_fifo_word_from_port"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static inline event_word_t *evtchn_fifo_word_from_port(struct domain *d,\n                                                       unsigned int port)\n{\n    unsigned int p, w;\n\n    if ( unlikely(port >= d->evtchn_fifo->num_evtchns) )\n        return NULL;\n\n    /*\n     * Callers aren't required to hold d->event_lock, so we need to synchronize\n     * with add_page_to_event_array().\n     */\n    smp_rmb();\n\n    p = port / EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n    w = port % EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n\n    return d->evtchn_fifo->event_array[p] + w;\n}""}, {""func_name"": ""add_page_to_event_array"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static int add_page_to_event_array(struct domain *d, unsigned long gfn)\n{\n    void *virt;\n    unsigned int slot;\n    unsigned int port = d->evtchn_fifo->num_evtchns;\n    int rc;\n\n    slot = d->evtchn_fifo->num_evtchns / EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n    if ( slot >= EVTCHN_FIFO_MAX_EVENT_ARRAY_PAGES )\n        return -ENOSPC;\n\n    rc = map_guest_page(d, gfn, &virt);\n    if ( rc < 0 )\n        return rc;\n\n    d->evtchn_fifo->event_array[slot] = virt;\n\n    /* Synchronize with evtchn_fifo_word_from_port(). */\n    smp_wmb();\n\n    d->evtchn_fifo->num_evtchns += EVTCHN_FIFO_EVENT_WORDS_PER_PAGE;\n\n    /*\n     * Re-raise any events that were pending while this array page was\n     * missing.\n     */\n    for ( ; port < d->evtchn_fifo->num_evtchns; port++ )\n    {\n        struct evtchn *evtchn;\n\n        if ( !port_is_valid(d, port) )\n            break;\n\n        evtchn = evtchn_from_port(d, port);\n        if ( evtchn->pending )\n            evtchn_fifo_set_pending(d->vcpu[evtchn->notify_vcpu_id], evtchn);\n    }\n\n    return 0;\n}""}, {""func_name"": ""evtchn_fifo_is_pending"", ""file_path"": ""xen/common/event_fifo.c"", ""func_code"": ""static bool_t evtchn_fifo_is_pending(struct domain *d, evtchn_port_t port)\n{\n    event_word_t *word;\n\n    word = evtchn_fifo_word_from_port(d, port);\n    if ( unlikely(!word) )\n        return 0;\n\n    return test_bit(EVTCHN_FIFO_PENDING, word);\n}""}, {""func_name"": ""do_poll"", ""file_path"": ""xen/common/schedule.c"", ""func_code"": ""static long do_poll(struct sched_poll *sched_poll)\n{\n    struct vcpu   *v = current;\n    struct domain *d = v->domain;\n    evtchn_port_t  port;\n    long           rc;\n    unsigned int   i;\n\n    /* Fairly arbitrary limit. */\n    if ( sched_poll->nr_ports > 128 )\n        return -EINVAL;\n\n    if ( !guest_handle_okay(sched_poll->ports, sched_poll->nr_ports) )\n        return -EFAULT;\n\n    set_bit(_VPF_blocked, &v->pause_flags);\n    v->poll_evtchn = -1;\n    set_bit(v->vcpu_id, d->poll_mask);\n\n    arch_vcpu_block(v);\n\n#ifndef CONFIG_X86 /* set_bit() implies mb() on x86 */\n    /* Check for events /after/ setting flags: avoids wakeup waiting race. */\n    smp_mb();\n\n    /*\n     * Someone may have seen we are blocked but not that we are polling, or\n     * vice versa. We are certainly being woken, so clean up and bail. Beyond\n     * this point others can be guaranteed to clean up for us if they wake us.\n     */\n    rc = 0;\n    if ( (v->poll_evtchn == 0) ||\n         !test_bit(_VPF_blocked, &v->pause_flags) ||\n         !test_bit(v->vcpu_id, d->poll_mask) )\n        goto out;\n#endif\n\n    rc = 0;\n    if ( local_events_need_delivery() )\n        goto out;\n\n    for ( i = 0; i < sched_poll->nr_ports; i++ )\n    {\n        rc = -EFAULT;\n        if ( __copy_from_guest_offset(&port, sched_poll->ports, i, 1) )\n            goto out;\n\n        rc = -EINVAL;\n        if ( port >= d->max_evtchns )\n            goto out;\n\n        rc = 0;\n        if ( evtchn_port_is_pending(d, port) )\n            goto out;\n    }\n\n    if ( sched_poll->nr_ports == 1 )\n        v->poll_evtchn = port;\n\n    if ( sched_poll->timeout != 0 )\n        set_timer(&v->poll_timer, sched_poll->timeout);\n\n    TRACE_2D(TRC_SCHED_BLOCK, d->domain_id, v->vcpu_id);\n    raise_softirq(SCHEDULE_SOFTIRQ);\n\n    return 0;\n\n out:\n    v->poll_evtchn = 0;\n    clear_bit(v->vcpu_id, d->poll_mask);\n    clear_bit(_VPF_blocked, &v->pause_flags);\n    return rc;\n}""}, {""func_name"": ""dump_irqs"", ""file_path"": ""xen/arch/x86/irq.c"", ""func_code"": ""static void dump_irqs(unsigned char key)\n{\n    int i, irq, pirq;\n    struct irq_desc *desc;\n    irq_guest_action_t *action;\n    struct domain *d;\n    const struct pirq *info;\n    unsigned long flags;\n    char *ssid;\n\n    printk(\""IRQ information:\\n\"");\n\n    for ( irq = 0; irq < nr_irqs; irq++ )\n    {\n        if ( !(irq & 0x1f) )\n            process_pending_softirqs();\n\n        desc = irq_to_desc(irq);\n\n        if ( !irq_desc_initialized(desc) || desc->handler == &no_irq_type )\n            continue;\n\n        ssid = in_irq() ? NULL : xsm_show_irq_sid(irq);\n\n        spin_lock_irqsave(&desc->lock, flags);\n\n        cpumask_scnprintf(keyhandler_scratch, sizeof(keyhandler_scratch),\n                          desc->affinity);\n        printk(\""   IRQ:%4d affinity:%s vec:%02x type=%-15s\""\n               \"" status=%08x \"",\n               irq, keyhandler_scratch, desc->arch.vector,\n               desc->handler->typename, desc->status);\n\n        if ( ssid )\n            printk(\""Z=%-25s \"", ssid);\n\n        if ( desc->status & IRQ_GUEST )\n        {\n            action = (irq_guest_action_t *)desc->action;\n\n            printk(\""in-flight=%d domain-list=\"", action->in_flight);\n\n            for ( i = 0; i < action->nr_guests; i++ )\n            {\n                d = action->guest[i];\n                pirq = domain_irq_to_pirq(d, irq);\n                info = pirq_info(d, pirq);\n                printk(\""%u:%3d(%c%c%c)\"",\n                       d->domain_id, pirq,\n                       evtchn_port_is_pending(d, info->evtchn) ? 'P' : '-',\n                       evtchn_port_is_masked(d, info->evtchn) ? 'M' : '-',\n                       (info->masked ? 'M' : '-'));\n                if ( i != action->nr_guests )\n                    printk(\"",\"");\n            }\n\n            printk(\""\\n\"");\n        }\n        else if ( desc->action )\n            printk(\""%ps()\\n\"", desc->action->handler);\n        else\n            printk(\""mapped, unbound\\n\"");\n\n        spin_unlock_irqrestore(&desc->lock, flags);\n\n        xfree(ssid);\n    }\n\n    process_pending_softirqs();\n    printk(\""Direct vector information:\\n\"");\n    for ( i = FIRST_DYNAMIC_VECTOR; i < NR_VECTORS; ++i )\n        if ( direct_apic_vector[i] )\n            printk(\""   %#02x -> %ps()\\n\"", i, direct_apic_vector[i]);\n\n    dump_ioapic_irq_info();\n}""}, {""func_name"": ""pirq_guest_unmask"", ""file_path"": ""xen/arch/x86/irq.c"", ""func_code"": ""int pirq_guest_unmask(struct domain *d)\n{\n    unsigned int pirq = 0, n, i;\n    struct pirq *pirqs[16];\n\n    do {\n        n = radix_tree_gang_lookup(&d->pirq_tree, (void **)pirqs, pirq,\n                                   ARRAY_SIZE(pirqs));\n        for ( i = 0; i < n; ++i )\n        {\n            pirq = pirqs[i]->pirq;\n            if ( pirqs[i]->masked &&\n                 !evtchn_port_is_masked(d, pirqs[i]->evtchn) )\n                pirq_guest_eoi(pirqs[i]);\n        }\n    } while ( ++pirq < d->nr_pirqs && n == ARRAY_SIZE(pirqs) );\n\n    return 0;\n}""}, {""func_name"": ""domain_dump_evtchn_info"", ""file_path"": ""xen/common/event_channel.c"", ""func_code"": ""static void domain_dump_evtchn_info(struct domain *d)\n{\n    unsigned int port;\n    int irq;\n\n    bitmap_scnlistprintf(keyhandler_scratch, sizeof(keyhandler_scratch),\n                         d->poll_mask, d->max_vcpus);\n    printk(\""Event channel information for domain %d:\\n\""\n           \""Polling vCPUs: {%s}\\n\""\n           \""    port [p/m/s]\\n\"", d->domain_id, keyhandler_scratch);\n\n    spin_lock(&d->event_lock);\n\n    for ( port = 1; port < d->max_evtchns; ++port )\n    {\n        const struct evtchn *chn;\n        char *ssid;\n\n        if ( !port_is_valid(d, port) )\n            continue;\n        chn = evtchn_from_port(d, port);\n        if ( chn->state == ECS_FREE )\n            continue;\n\n        printk(\""    %4u [%d/%d/\"",\n               port,\n               evtchn_port_is_pending(d, port),\n               evtchn_port_is_masked(d, port));\n        evtchn_port_print_state(d, chn);\n        printk(\""]: s=%d n=%d x=%d\"",\n               chn->state, chn->notify_vcpu_id, chn->xen_consumer);\n\n        switch ( chn->state )\n        {\n        case ECS_UNBOUND:\n            printk(\"" d=%d\"", chn->u.unbound.remote_domid);\n            break;\n        case ECS_INTERDOMAIN:\n            printk(\"" d=%d p=%d\"",\n                   chn->u.interdomain.remote_dom->domain_id,\n                   chn->u.interdomain.remote_port);\n            break;\n        case ECS_PIRQ:\n            irq = domain_pirq_to_irq(d, chn->u.pirq.irq);\n            printk(\"" p=%d i=%d\"", chn->u.pirq.irq, irq);\n            break;\n        case ECS_VIRQ:\n            printk(\"" v=%d\"", chn->u.virq);\n            break;\n        }\n\n        ssid = xsm_show_security_evtchn(d, chn);\n        if (ssid) {\n            printk(\"" Z=%s\\n\"", ssid);\n            xfree(ssid);\n        } else {\n            printk(\""\\n\"");\n        }\n    }\n\n    spin_unlock(&d->event_lock);\n}""}, {""func_name"": ""evtchn_port_is_pending"", ""file_path"": ""xen/include/xen/event.h"", ""func_code"": ""static inline bool_t evtchn_port_is_pending(struct domain *d,\n                                            evtchn_port_t port)\n{\n    return d->evtchn_port_ops->is_pending(d, port);\n}""}, {""func_name"": ""evtchn_port_is_masked"", ""file_path"": ""xen/include/xen/event.h"", ""func_code"": ""static inline bool_t evtchn_port_is_masked(struct domain *d,\n                                           evtchn_port_t port)\n{\n    return d->evtchn_port_ops->is_masked(d, port);\n}""}, {""func_name"": ""evtchn_2l_is_masked"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool_t evtchn_2l_is_masked(struct domain *d, evtchn_port_t port)\n{\n    unsigned int max_ports = BITS_PER_EVTCHN_WORD(d) * BITS_PER_EVTCHN_WORD(d);\n\n    ASSERT(port < max_ports);\n    return port >= max_ports || test_bit(port, &shared_info(d, evtchn_mask));\n}""}, {""func_name"": ""evtchn_2l_is_pending"", ""file_path"": ""xen/common/event_2l.c"", ""func_code"": ""static bool_t evtchn_2l_is_pending(struct domain *d, evtchn_port_t port)\n{\n    unsigned int max_ports = BITS_PER_EVTCHN_WORD(d) * BITS_PER_EVTCHN_WORD(d);\n\n    ASSERT(port < max_ports);\n    return port < max_ports && test_bit(port, &shared_info(d, evtchn_pending));\n}""}]","{""function"": 1, ""caller"": 1}","[{""source"": ""func_info(file:event.h, func:evtchn_from_port)"", ""result"": [{""code"": ""static inline struct evtchn *evtchn_from_port(struct domain *d, unsigned int p)\n{\n    if ( p < EVTCHNS_PER_BUCKET )\n        return &d->evtchn[p];\n    return bucket_from_port(d, p) + (p % EVTCHNS_PER_BUCKET);\n}"", ""start_line"": 95, ""end_line"": 100, ""full_name"": ""evtchn_from_port"", ""file_path"": ""xen/include/xen/event.h""}]}, {""source"": ""caller_info(func:evtchn_from_port)"", ""result"": [{""call_line"": 1489, ""call_code"": ""evtchn_from_port(d, pirqs[i]->evtchn)"", ""caller_code"": ""int pirq_guest_unmask(struct domain *d)\n{\n    unsigned int pirq = 0, n, i;\n    struct pirq *pirqs[16];\n\n    do {\n        n = radix_tree_gang_lookup(&d->pirq_tree, (void **)pirqs, pirq,\n                                   ARRAY_SIZE(pirqs));\n        for ( i = 0; i < n; ++i )\n        {\n            pirq = pirqs[i]->pirq;\n            if ( pirqs[i]->masked &&\n                 !evtchn_port_is_masked(d, evtchn_from_port(d, pirqs[i]->evtchn)) )\n                pirq_guest_eoi(pirqs[i]);\n        }\n    } while ( ++pirq < d->nr_pirqs && n == ARRAY_SIZE(pirqs) );\n\n    return 0;\n}"", ""caller_start"": 1477, ""file_path"": ""xen/arch/x86/irq.c""}, {""call_line"": 2290, ""call_code"": ""evtchn_from_port(d, info->evtchn)"", ""caller_code"": ""static void dump_irqs(unsigned char key)\n{\n    int i, irq, pirq;\n    struct irq_desc *desc;\n    irq_guest_action_t *action;\n    struct evtchn *evtchn;\n    struct domain *d;\n    const struct pirq *info;\n    unsigned long flags;\n    char *ssid;\n\n    printk(\""IRQ information:\\n\"");\n\n    for ( irq = 0; irq < nr_irqs; irq++ )\n    {\n        if ( !(irq & 0x1f) )\n            process_pending_softirqs();\n\n        desc = irq_to_desc(irq);\n\n        if ( !irq_desc_initialized(desc) || desc->handler == &no_irq_type )\n            continue;\n\n        ssid = in_irq() ? NULL : xsm_show_irq_sid(irq);\n\n        spin_lock_irqsave(&desc->lock, flags);\n\n        cpumask_scnprintf(keyhandler_scratch, sizeof(keyhandler_scratch),\n                          desc->affinity);\n        printk(\""   IRQ:%4d affinity:%s vec:%02x type=%-15s\""\n               \"" status=%08x \"",\n               irq, keyhandler_scratch, desc->arch.vector,\n               desc->handler->typename, desc->status);\n\n        if ( ssid )\n            printk(\""Z=%-25s \"", ssid);\n\n        if ( desc->status & IRQ_GUEST )\n        {\n            action = (irq_guest_action_t *)desc->action;\n\n            printk(\""in-flight=%d domain-list=\"", action->in_flight);\n\n            for ( i = 0; i < action->nr_guests; i++ )\n            {\n                d = action->guest[i];\n                pirq = domain_irq_to_pirq(d, irq);\n                info = pirq_info(d, pirq);\n                evtchn = evtchn_from_port(d, info->evtchn);\n                printk(\""%u:%3d(%c%c%c)\"",\n                       d->domain_id, pirq,\n                       (evtchn_port_is_pending(d, evtchn) ? 'P' : '-'),\n                       (evtchn_port_is_masked(d, evtchn) ? 'M' : '-'),\n                       (info->masked ? 'M' : '-'));\n                if ( i != action->nr_guests )\n                    printk(\"",\"");\n            }\n\n            printk(\""\\n\"");\n        }\n        else if ( desc->action )\n            printk(\""%ps()\\n\"", desc->action->handler);\n        else\n            printk(\""mapped, unbound\\n\"");\n\n        spin_unlock_irqrestore(&desc->lock, flags);\n\n        xfree(ssid);\n    }\n\n    process_pending_softirqs();\n    printk(\""Direct vector information:\\n\"");\n    for ( i = FIRST_DYNAMIC_VECTOR; i < NR_VECTORS; ++i )\n        if ( direct_apic_vector[i] )\n            printk(\""   %#02x -> %ps()\\n\"", i, direct_apic_vector[i]);\n\n    dump_ioapic_irq_info();\n}\n"", ""caller_start"": 2242, ""file_path"": ""xen/arch/x86/irq.c""}, {""call_line"": 172, ""call_code"": ""evtchn_from_port(d, port)"", ""caller_code"": ""static int get_free_port(struct domain *d)\n{\n    struct evtchn *chn;\n    struct evtchn **grp;\n    int            port;\n\n    if ( d->is_dying )\n        return -EINVAL;\n\n    for ( port = 0; port_is_valid(d, port); port++ )\n    {\n        if ( port > d->max_evtchn_port )\n            return -ENOSPC;\n        if ( evtchn_from_port(d, port)->state == ECS_FREE\n             && !evtchn_port_is_busy(d, port) )\n            return port;\n    }\n\n    if ( port == d->max_evtchns || port > d->max_evtchn_port )\n        return -ENOSPC;\n\n    if ( !group_from_port(d, port) )\n    {\n        grp = xzalloc_array(struct evtchn *, BUCKETS_PER_GROUP);\n        if ( !grp )\n            return -ENOMEM;\n        group_from_port(d, port) = grp;\n    }\n\n    chn = alloc_evtchn_bucket(d, port);\n    if ( !chn )\n        return -ENOMEM;\n    bucket_from_port(d, port) = chn;\n\n    write_atomic(&d->valid_evtchns, d->valid_evtchns + EVTCHNS_PER_BUCKET);\n\n    return port;\n}"", ""caller_start"": 159, ""file_path"": ""xen/common/event_channel.c""}, {""call_line"": 227, ""call_code"": ""evtchn_from_port(d, port)"", ""caller_code"": ""static long evtchn_alloc_unbound(evtchn_alloc_unbound_t *alloc)\n{\n    struct evtchn *chn;\n    struct domain *d;\n    int            port;\n    domid_t        dom = alloc->dom;\n    long           rc;\n\n    d = rcu_lock_domain_by_any_id(dom);\n    if ( d == NULL )\n        return -ESRCH;\n\n    spin_lock(&d->event_lock);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT_DOM(port, d);\n    chn = evtchn_from_port(d, port);\n\n    rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, alloc->remote_dom);\n    if ( rc )\n        goto out;\n\n    spin_lock(&chn->lock);\n\n    chn->state = ECS_UNBOUND;\n    if ( (chn->u.unbound.remote_domid = alloc->remote_dom) == DOMID_SELF )\n        chn->u.unbound.remote_domid = current->domain->domain_id;\n    evtchn_port_init(d, chn);\n\n    spin_unlock(&chn->lock);\n\n    alloc->port = port;\n\n out:\n    spin_unlock(&d->event_lock);\n    rcu_unlock_domain(d);\n\n    return rc;\n}"", ""caller_start"": 211, ""file_path"": ""xen/common/event_channel.c""}]}]","Unvalidated port numbers in Xen's event channel handling allowed NULL dereferences. Specifically:\n1. `evtchn_from_port` (xen/include/xen/event.h:95-100) returns a struct evtchn* based on the port, but does not validate the port's validity beyond basic bounds checks.\n2. Callers like `pirq_guest_unmask` (xen/arch/x86/irq.c:1489) and `dump_irqs` (xen/arch/x86/irq.c:2290) used `evtchn_from_port` without validating the returned pointer.\n3. If the port was invalid (e.g., beyond allocated buckets), `evtchn_from_port` would return NULL. Subsequent dereferences (e.g., in `evtchn_port_is_masked`) would cause a NULL pointer dereference.\n4. The patch replaces struct-based calls with direct port usage (e.g., `evtchn_port_is_masked(d, port)`) and adds barriers in FIFO handling (xen/common/event_fifo.c:28, 594) to ensure proper memory ordering.",0.95,./github/other_context/CVE-2017-10917
52,CVE-2017-11733,CWE-476,c_cpp,"A null pointer dereference vulnerability was found in the function stackswap (called from decompileSTACKSWAP) in util/decompile.c in Ming 0.4.8, which allows attackers to cause a denial of service via a crafted file.",https://github.com/libming/libming/commit/eda5a20206862a11805303cdd125566c9f9f9103,"Fix null-pointer dereference issue in stackswap.\n\nAvoid processing stackswap when stack only contains one element. In this\ncase, print a warning if debug mode is enabled, and return cleanly.\n\nThis commit fixes CVE-2017-11733 (fixes #78).",5,"[{""func_name"": ""readUInt32"", ""file_path"": ""util/read.c"", ""func_code"": ""unsigned long readUInt32(FILE *f)\n{\n  int part1 = readUInt8(f);\n  int part2 = readUInt8(f) << 8;\n  int part3 = readUInt8(f) << 16;\n  unsigned long part4 = ((unsigned long)readUInt8(f)) << 24;\n  return part1 + part2 + part3 + part4;\n}"", ""target"": 1}, {""func_name"": ""readSInt32"", ""file_path"": ""util/read.c"", ""func_code"": ""long readSInt32(FILE *f)\n{\n  return (long)readUInt8(f) + (readUInt8(f)<<8) + (readUInt8(f)<<16) + (readUInt8(f)<<24);\n}"", ""target"": 1}, {""func_name"": ""readUInt16"", ""file_path"": ""util/read.c"", ""func_code"": ""int readUInt16(FILE *f)\n{\n  return readUInt8(f) + (readUInt8(f)<<8);\n}"", ""target"": 1}, {""func_name"": ""readSInt16"", ""file_path"": ""util/read.c"", ""func_code"": ""int readSInt16(FILE *f)\n{\n  return readUInt8(f) + readSInt8(f)*256;\n}"", ""target"": 1}, {""func_name"": ""stackswap"", ""file_path"": ""util/decompile.c"", ""func_code"": ""void\nstackswap()\n{\n#ifdef DEBUG\n\tprintf(\""*stackswap*\\n\"");\n#endif\n\tstruct SWF_ACTIONPUSHPARAM *p = peek();\t\t/* peek() includes error handling */\n\tchar type = Stack->type;\n\tStack->type = Stack->next->type;\n\tStack->val  = Stack->next->val;\n\tStack->next->type = type;\n\tStack->next->val  = p;\n}"", ""target"": 0}]","[{""func_name"": ""readUInt32"", ""file_path"": ""util/read.c"", ""func_code"": ""unsigned long readUInt32(FILE *f)\n{\n  unsigned long result = 0u;\n  result |= readUInt8(f);\n  result |= readUInt8(f) << 8;\n  result |= readUInt8(f) << 16;\n  result |= readUInt8(f) << 24;\n  return result;\n}""}, {""func_name"": ""readSInt32"", ""file_path"": ""util/read.c"", ""func_code"": ""long readSInt32(FILE *f)\n{\n  long result = 0;\n  result |= readUInt8(f);\n  result |= readUInt8(f) << 8;\n  result |= readUInt8(f) << 16;\n  result |= readUInt8(f) << 24;\n  return result;\n}""}, {""func_name"": ""readUInt16"", ""file_path"": ""util/read.c"", ""func_code"": ""unsigned int readUInt16(FILE *f)\n{\n  unsigned int result = 0u;\n  result |= readUInt8(f);\n  result |= readUInt8(f) << 8;\n  return result;\n}""}, {""func_name"": ""readSInt16"", ""file_path"": ""util/read.c"", ""func_code"": ""int readSInt16(FILE *f)\n{\n  int result = 0;\n  result |= readUInt8(f);\n  result |= readSInt8(f) << 8;\n  return result;\n}""}, {""func_name"": ""stackswap"", ""file_path"": ""util/decompile.c"", ""func_code"": ""void\nstackswap()\n{\n#ifdef DEBUG\n\tprintf(\""*stackswap*\\n\"");\n#endif\n\tstruct SWF_ACTIONPUSHPARAM *p = peek();\t\t/* peek() includes error handling */\n\tchar type = Stack->type;\n\n        if (Stack->next == NULL) {\n#if DEBUG\n\t\tSWF_warn(\""stackswap: can't swap (stack contains only one element)\\n\"");\n#endif\n                return;\n        }\n\n\tStack->type = Stack->next->type;\n\tStack->val  = Stack->next->val;\n\tStack->next->type = type;\n\tStack->next->val  = p;\n}""}]","{""caller"": 1, ""function"": 1}","[{""source"": ""caller_info(file:decompile.c, func:decompileSTACKSWAP)"", ""result"": [{""call_line"": 3178, ""call_code"": ""decompileSTACKSWAP(&actions[n])"", ""caller_code"": ""int\ndecompileAction(int n, SWF_ACTION *actions, int maxn)\n{\n\tif( n > maxn ) SWF_error(\""Action overflow!!\"");\n\n#ifdef DEBUG\n\tfprintf(stderr,\""%d:\\tACTION[%3.3d]: %s\\n\"",\n\t        actions[n].SWF_ACTIONRECORD.Offset, n, \n\t        actionName(actions[n].SWF_ACTIONRECORD.ActionCode));\n#endif\n\n\tswitch(actions[n].SWF_ACTIONRECORD.ActionCode)\n\t{\n\tcase SWFACTION_END:\n\t\treturn 0;\n\n\tcase SWFACTION_CONSTANTPOOL:\n\t\tdecompileCONSTANTPOOL(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GOTOLABEL:\n\t\treturn decompileGOTOFRAME(n, actions, maxn,1);\n\n\tcase SWFACTION_GOTOFRAME:\n\t\treturn decompileGOTOFRAME(n, actions, maxn,0);\n\n\tcase SWFACTION_GOTOFRAME2:\n\t\treturn decompileGOTOFRAME2(n, actions, maxn);\n\n\tcase SWFACTION_WAITFORFRAME:\n\t\tdecompileWAITFORFRAME(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GETURL2:\n\t\tdecompileGETURL2(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GETURL:\n\t\tdecompileGETURL(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_PUSH:\n\t\tdecompilePUSH(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_PUSHDUP:\n\t\tde..."", ""caller_start"": 3128, ""file_path"": ""util/decompile.c""}]}, {""source"": ""func_info(file:decompile.c, func:decompileSTACKSWAP)"", ""result"": [{""code"": ""static void\ndecompileSTACKSWAP (SWF_ACTION *act)\n{\n\tSanityCheck(SWF_STACKSWAP,\n\t\tact->SWF_ACTIONRECORD.ActionCode == SWFACTION_STACKSWAP,\n\t\t\""not a STACKSWAP\"")\n\tstackswap();\n}"", ""start_line"": 1352, ""end_line"": 1359, ""full_name"": ""decompileSTACKSWAP"", ""file_path"": ""util/decompile.c""}]}]","The root cause is the absence of stack depth validation in `decompileSTACKSWAP` (called from `util/decompile.c:3178`), which directly invokes `stackswap()` without ensuring the stack has at least two elements. This allows `stackswap` to dereference `Stack->next` when it is NULL (util/decompile.c:633-635). The patch at `util/decompile.c:627+` adds a check for this condition, but the trigger chain relies on `decompileSTACKSWAP` (util/decompile.c:1352-1359) not enforcing stack constraints before calling `stackswap`.",0.95,./github/other_context/CVE-2017-11733
53,CVE-2017-13764,CWE-476,c_cpp,"In Wireshark 2.4.0, the Modbus dissector could crash with a NULL pointer dereference. This was addressed in epan/dissectors/packet-mbtcp.c by adding length validation.",https://github.com/wireshark/wireshark/commit/b87ffbd12bddf64582c0a6e082b462744474de94,"Modbus: do not trigger an exception before saving pkt_info structure\n\nOtherwise on second pass pkt_info is null, leading to a segmentation fault\n\nBug: 13925\nChange-Id: I61cfbee894506fb6c4205c9a2ad19e6973821f23\nReviewed-on: https://code.wireshark.org/review/22833\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>\n(cherry picked from commit b16d487cbc70a441d26a1052b22d1bb0132b1cbc)\nReviewed-on: https://code.wireshark.org/review/22839",1,"[{""func_name"": ""dissect_modbus"", ""file_path"": ""epan/dissectors/packet-mbtcp.c"", ""func_code"": ""static int\ndissect_modbus(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    proto_tree          *modbus_tree;\n    proto_item          *mi;\n    int                 offset = 0;\n    int*                packet_type = (int*)data;\n    gint                payload_start, payload_len, len;\n    guint8              function_code, exception_code;\n    modbus_pkt_info_t   *pkt_info;\n\n    /* Reject the packet if data passed from the mbrtu or mbtcp dissector is NULL */\n    if (packet_type == NULL)\n        return 0;\n\n    len = tvb_captured_length(tvb);\n\n    /* If the packet is zero-length, we should not attempt to dissect any further */\n    if (len == 0)\n        return 0;\n\n    /* Add items to protocol tree specific to Modbus */\n    mi = proto_tree_add_protocol_format(tree, proto_modbus, tvb, offset, len, \""Modbus\"");\n    modbus_tree = proto_item_add_subtree(mi, ett_modbus_hdr);\n\n    function_code = tvb_get_guint8(tvb, offset) & 0x7F;\n    proto_tree_add_item(modbus_tree, hf_modbus_functioncode, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Conversation support */\n    if (!pinfo->fd->flags.visited) {\n        conversation_t       *conversation = NULL;\n        modbus_conversation  *modbus_conv_data = NULL;\n\n        /* Find a conversation, create a new if no one exists */\n        conversation = find_or_create_conversation(pinfo);\n        modbus_conv_data = (modbus_conversation *)conversation_get_proto_data(conversation, proto_modbus);\n        pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t);\n\n        if (modbus_conv_data == NULL){\n           modbus_conv_data = wmem_new(wmem_file_scope(), modbus_conversation);\n           modbus_conv_data->modbus_request_frame_data = wmem_list_new(wmem_file_scope());\n           modbus_conv_data->register_format = global_mbus_register_format;\n           conversation_add_proto_data(conversation, proto_modbus, (void *)modbus_conv_data);\n        }\n\n        pkt_info->register_format = modbus_conv_data->register_format;\n\n        if (*packet_type == QUERY_PACKET) {\n            /*create the modbus_request frame. It holds the request information.*/\n            modbus_request_info_t    *frame_ptr = wmem_new(wmem_file_scope(), modbus_request_info_t);\n\n            /* load information into the modbus request frame */\n            frame_ptr->fnum = pinfo->num;\n            frame_ptr->function_code = function_code;\n            pkt_info->reg_base = frame_ptr->base_address = tvb_get_ntohs(tvb, 1);\n            pkt_info->num_reg = frame_ptr->num_reg = tvb_get_ntohs(tvb, 3);\n\n            wmem_list_prepend(modbus_conv_data->modbus_request_frame_data, frame_ptr);\n        }\n        else if (*packet_type == RESPONSE_PACKET) {\n            guint8                req_function_code;\n            guint32               req_frame_num;\n            modbus_request_info_t *request_data;\n\n            wmem_list_frame_t *frame = wmem_list_head(modbus_conv_data->modbus_request_frame_data);\n            /* Step backward through all logged instances of request frames, looking for a request frame number that\n            occurred immediately prior to current frame number that has a matching function code */\n            while (frame && !pkt_info->request_found) {\n                request_data = (modbus_request_info_t *)wmem_list_frame_data(frame);\n                req_frame_num = request_data->fnum;\n                req_function_code = request_data->function_code;\n                if ((pinfo->num > req_frame_num) && (req_function_code == function_code)) {\n                    pkt_info->reg_base = request_data->base_address;\n                    pkt_info->num_reg = request_data->num_reg;\n                    pkt_info->request_found = TRUE;\n                    pkt_info->req_frame_num = req_frame_num;\n                }\n                frame = wmem_list_frame_next(frame);\n            }\n\n\n        }\n        p_add_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0, pkt_info);\n\n    }\n    else { /* !visited */\n        pkt_info = (modbus_pkt_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0);\n    }\n\n\n    /* Find exception - last bit set in function code */\n    if (tvb_get_guint8(tvb, offset) & 0x80 ) {\n        exception_code = tvb_get_guint8(tvb, offset+1);\n    }\n    else {\n        exception_code = 0;\n    }\n\n    payload_start = offset + 1;\n    payload_len = len - 1;\n\n    if (exception_code != 0) {\n        proto_item_set_text(mi, \""Function %u:  %s.  Exception: %s\"",\n                            function_code,\n                            val_to_str_const(function_code, function_code_vals, \""Unknown Function\""),\n                            val_to_str(exception_code,\n                                       exception_code_vals,\n                                       \""Unknown Exception Code (%u)\""));\n        proto_tree_add_uint(modbus_tree, hf_modbus_exceptioncode, tvb, payload_start, 1,\n                            exception_code);\n    }\n    else {\n\n        /* Follow different dissection path depending on whether packet is query or response */\n        if (*packet_type == QUERY_PACKET) {\n            dissect_modbus_request(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info);\n        }\n        else if (*packet_type == RESPONSE_PACKET) {\n            dissect_modbus_response(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info);\n        }\n\n    }\n\n    return tvb_captured_length(tvb);\n}"", ""target"": 0}]","[{""func_name"": ""dissect_modbus"", ""file_path"": ""epan/dissectors/packet-mbtcp.c"", ""func_code"": ""static int\ndissect_modbus(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    proto_tree          *modbus_tree;\n    proto_item          *mi;\n    int                 offset = 0;\n    int*                packet_type = (int*)data;\n    gint                payload_start, payload_len, len;\n    guint8              function_code, exception_code;\n    modbus_pkt_info_t   *pkt_info;\n\n    /* Reject the packet if data passed from the mbrtu or mbtcp dissector is NULL */\n    if (packet_type == NULL)\n        return 0;\n\n    len = tvb_captured_length(tvb);\n\n    /* If the packet is zero-length, we should not attempt to dissect any further */\n    if (len == 0)\n        return 0;\n\n    /* Add items to protocol tree specific to Modbus */\n    mi = proto_tree_add_protocol_format(tree, proto_modbus, tvb, offset, len, \""Modbus\"");\n    modbus_tree = proto_item_add_subtree(mi, ett_modbus_hdr);\n\n    function_code = tvb_get_guint8(tvb, offset) & 0x7F;\n    proto_tree_add_item(modbus_tree, hf_modbus_functioncode, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Conversation support */\n    if (!pinfo->fd->flags.visited) {\n        conversation_t       *conversation = NULL;\n        modbus_conversation  *modbus_conv_data = NULL;\n\n        /* Find a conversation, create a new if no one exists */\n        conversation = find_or_create_conversation(pinfo);\n        modbus_conv_data = (modbus_conversation *)conversation_get_proto_data(conversation, proto_modbus);\n        pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t);\n\n        if (modbus_conv_data == NULL){\n           modbus_conv_data = wmem_new(wmem_file_scope(), modbus_conversation);\n           modbus_conv_data->modbus_request_frame_data = wmem_list_new(wmem_file_scope());\n           modbus_conv_data->register_format = global_mbus_register_format;\n           conversation_add_proto_data(conversation, proto_modbus, (void *)modbus_conv_data);\n        }\n\n        pkt_info->register_format = modbus_conv_data->register_format;\n\n        if (*packet_type == QUERY_PACKET) {\n            /*create the modbus_request frame. It holds the request information.*/\n            modbus_request_info_t    *frame_ptr = wmem_new0(wmem_file_scope(), modbus_request_info_t);\n            gint captured_length = tvb_captured_length(tvb);\n\n            /* load information into the modbus request frame */\n            frame_ptr->fnum = pinfo->num;\n            frame_ptr->function_code = function_code;\n            if (captured_length >= 3) {\n                pkt_info->reg_base = frame_ptr->base_address = tvb_get_ntohs(tvb, 1);\n                if (captured_length >= 5)\n                    pkt_info->num_reg = frame_ptr->num_reg = tvb_get_ntohs(tvb, 3);\n            }\n\n            wmem_list_prepend(modbus_conv_data->modbus_request_frame_data, frame_ptr);\n        }\n        else if (*packet_type == RESPONSE_PACKET) {\n            guint8                req_function_code;\n            guint32               req_frame_num;\n            modbus_request_info_t *request_data;\n\n            wmem_list_frame_t *frame = wmem_list_head(modbus_conv_data->modbus_request_frame_data);\n            /* Step backward through all logged instances of request frames, looking for a request frame number that\n            occurred immediately prior to current frame number that has a matching function code */\n            while (frame && !pkt_info->request_found) {\n                request_data = (modbus_request_info_t *)wmem_list_frame_data(frame);\n                req_frame_num = request_data->fnum;\n                req_function_code = request_data->function_code;\n                if ((pinfo->num > req_frame_num) && (req_function_code == function_code)) {\n                    pkt_info->reg_base = request_data->base_address;\n                    pkt_info->num_reg = request_data->num_reg;\n                    pkt_info->request_found = TRUE;\n                    pkt_info->req_frame_num = req_frame_num;\n                }\n                frame = wmem_list_frame_next(frame);\n            }\n\n\n        }\n        p_add_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0, pkt_info);\n\n    }\n    else { /* !visited */\n        pkt_info = (modbus_pkt_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0);\n    }\n\n\n    /* Find exception - last bit set in function code */\n    if (tvb_get_guint8(tvb, offset) & 0x80 ) {\n        exception_code = tvb_get_guint8(tvb, offset+1);\n    }\n    else {\n        exception_code = 0;\n    }\n\n    payload_start = offset + 1;\n    payload_len = len - 1;\n\n    if (exception_code != 0) {\n        proto_item_set_text(mi, \""Function %u:  %s.  Exception: %s\"",\n                            function_code,\n                            val_to_str_const(function_code, function_code_vals, \""Unknown Function\""),\n                            val_to_str(exception_code,\n                                       exception_code_vals,\n                                       \""Unknown Exception Code (%u)\""));\n        proto_tree_add_uint(modbus_tree, hf_modbus_exceptioncode, tvb, payload_start, 1,\n                            exception_code);\n    }\n    else {\n\n        /* Follow different dissection path depending on whether packet is query or response */\n        if (*packet_type == QUERY_PACKET) {\n            dissect_modbus_request(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info);\n        }\n        else if (*packet_type == RESPONSE_PACKET) {\n            dissect_modbus_response(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info);\n        }\n\n    }\n\n    return tvb_captured_length(tvb);\n}""}]","{""code"": 3, ""value"": 1, ""function"": 4}","[{""source"": ""code_info(file:packet-mbtcp.c, lines:1550-1580)"", ""result"": ""    /* Conversation support */\n    if (!pinfo->fd->flags.visited) {\n        conversation_t       *conversation = NULL;\n        modbus_conversation  *modbus_conv_data = NULL;\n\n        /* Find a conversation, create a new if no one exists */\n        conversation = find_or_create_conversation(pinfo);\n        modbus_conv_data = (modbus_conversation *)conversation_get_proto_data(conversation, proto_modbus);\n        pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t);\n\n        if (modbus_conv_data == NULL){\n           modbus_conv_data = wmem_new(wmem_file_scope(), modbus_conversation);\n           modbus_conv_data->modbus_request_frame_data = wmem_list_new(wmem_file_scope());\n           modbus_conv_data->register_format = global_mbus_register_format;\n           conversation_add_proto_data(conversation, proto_modbus, (void *)modbus_conv_data);\n        }\n\n        pkt_info->register_format = modbus_conv_data->register_format;\n\n        if (*packet_type == QUERY_PACKET) {\n            /*create the modbus_request frame. It holds the request information.*/\n            modbus_request_info_t    *frame_ptr = wmem_new(wmem_file_scope(), modbus_request_info_t);\n\n            /* load information into the modbus request frame */\n            frame_ptr->fnum = pinfo->num;\n            frame_ptr->function_code = function_code;\n            pkt_info->reg_base = frame_ptr->base_address = tvb_get_ntohs(tvb, 1);\n            pkt_info->num_reg = frame_ptr->num_reg = tvb_get_ntohs(tvb, 3);\n\n            wmem_list_prepend(modbus_conv_data->modbus_request_frame_data, frame_ptr);\n        }\n        else if (*packet_type == RESPONSE_PACKET) {\n""}, {""source"": ""value_info(file:packet-mbtcp.c, value:pkt_info)"", ""result"": {""value_trace"": [{""full_code"": ""pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t)"", ""line"": 1558, ""func_name"": ""dissect_modbus""}, {""full_code"": ""pkt_info = (modbus_pkt_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0)"", ""line"": 1608, ""func_name"": ""dissect_modbus""}], ""struct_var"": ""pkt_info"", ""struct_type"": ""modbus_pkt_info_t*"", ""struct_definition"": ""typedef struct {\n    guint8  function_code;\n    gint    register_format;\n    guint16 reg_base;\n    guint16 num_reg;\n    guint32 req_frame_num;\n    gboolean request_found;\n}""}}, {""source"": ""func_info(func:p_get_proto_data)"", ""result"": [{""code"": ""void *\np_get_proto_data(wmem_allocator_t *scope, struct _packet_info* pinfo, int proto, guint32 key)\n{\n  proto_data_t  temp, *p1;\n  GSList       *item;\n\n  temp.proto = proto;\n  temp.key = key;\n  temp.proto_data = NULL;\n\n  if (scope == pinfo->pool) {\n    item = g_slist_find_custom(pinfo->proto_data, &temp, p_compare);\n  } else if (scope == wmem_file_scope()) {\n    item = g_slist_find_custom(pinfo->fd->pfd, &temp, p_compare);\n  } else {\n    DISSECTOR_ASSERT(!\""invalid wmem scope\"");\n  }\n\n  if (item) {\n    p1 = (proto_data_t *)item->data;\n    return p1->proto_data;\n  }\n\n  return NULL;\n}"", ""start_line"": 97, ""end_line"": 121, ""full_name"": ""p_get_proto_data"", ""file_path"": ""epan/proto_data.c""}]}, {""source"": ""code_info(file:packet-mbtcp.c, lines:1540-1560)"", ""result"": ""    if (len == 0)\n        return 0;\n\n    /* Add items to protocol tree specific to Modbus */\n    mi = proto_tree_add_protocol_format(tree, proto_modbus, tvb, offset, len, \""Modbus\"");\n    modbus_tree = proto_item_add_subtree(mi, ett_modbus_hdr);\n\n    function_code = tvb_get_guint8(tvb, offset) & 0x7F;\n    proto_tree_add_item(modbus_tree, hf_modbus_functioncode, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Conversation support */\n    if (!pinfo->fd->flags.visited) {\n        conversation_t       *conversation = NULL;\n        modbus_conversation  *modbus_conv_data = NULL;\n\n        /* Find a conversation, create a new if no one exists */\n        conversation = find_or_create_conversation(pinfo);\n        modbus_conv_data = (modbus_conversation *)conversation_get_proto_data(conversation, proto_modbus);\n        pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t);\n\n        if (modbus_conv_data == NULL){\n           modbus_conv_data = wmem_new(wmem_file_scope(), modbus_conversation);\n""}, {""source"": ""code_info(file:packet-mbtcp.c, lines:1590-1610)"", ""result"": ""                request_data = (modbus_request_info_t *)wmem_list_frame_data(frame);\n                req_frame_num = request_data->fnum;\n                req_function_code = request_data->function_code;\n                if ((pinfo->num > req_frame_num) && (req_function_code == function_code)) {\n                    pkt_info->reg_base = request_data->base_address;\n                    pkt_info->num_reg = request_data->num_reg;\n                    pkt_info->request_found = TRUE;\n                    pkt_info->req_frame_num = req_frame_num;\n                }\n                frame = wmem_list_frame_next(frame);\n            }\n\n\n        }\n        p_add_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0, pkt_info);\n\n    }\n    else { /* !visited */\n        pkt_info = (modbus_pkt_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0);\n    }\n\n\n""}, {""source"": ""func_info(file:proto_data.c, func:p_add_proto_data)"", ""result"": [{""code"": ""void\np_add_proto_data(wmem_allocator_t *tmp_scope, struct _packet_info* pinfo, int proto, guint32 key, void *proto_data)\n{\n  proto_data_t     *p1;\n  GSList          **proto_list;\n  wmem_allocator_t *scope;\n\n  if (tmp_scope == pinfo->pool) {\n    scope = tmp_scope;\n    proto_list = &pinfo->proto_data;\n  } else if (tmp_scope == wmem_file_scope()) {\n    scope = wmem_file_scope();\n    proto_list = &pinfo->fd->pfd;\n  } else {\n    DISSECTOR_ASSERT(!\""invalid wmem scope\"");\n  }\n\n  p1 = (proto_data_t *)wmem_alloc(scope, sizeof(proto_data_t));\n\n  p1->proto = proto;\n  p1->key = key;\n  p1->proto_data = proto_data;\n\n  /* Add it to the GSLIST */\n  *proto_list = g_slist_prepend(*proto_list, p1);\n}"", ""start_line"": 70, ""end_line"": 95, ""full_name"": ""p_add_proto_data"", ""file_path"": ""epan/proto_data.c""}]}, {""source"": ""func_info(file:proto_data.c, func:p_get_proto_data)"", ""result"": [{""code"": ""void *\np_get_proto_data(wmem_allocator_t *scope, struct _packet_info* pinfo, int proto, guint32 key)\n{\n  proto_data_t  temp, *p1;\n  GSList       *item;\n\n  temp.proto = proto;\n  temp.key = key;\n  temp.proto_data = NULL;\n\n  if (scope == pinfo->pool) {\n    item = g_slist_find_custom(pinfo->proto_data, &temp, p_compare);\n  } else if (scope == wmem_file_scope()) {\n    item = g_slist_find_custom(pinfo->fd->pfd, &temp, p_compare);\n  } else {\n    DISSECTOR_ASSERT(!\""invalid wmem scope\"");\n  }\n\n  if (item) {\n    p1 = (proto_data_t *)item->data;\n    return p1->proto_data;\n  }\n\n  return NULL;\n}"", ""start_line"": 97, ""end_line"": 121, ""full_name"": ""p_get_proto_data"", ""file_path"": ""epan/proto_data.c""}]}, {""source"": ""func_info(file:proto_data.c, func:p_compare)"", ""result"": [{""code"": ""static gint\np_compare(gconstpointer a, gconstpointer b)\n{\n  const proto_data_t *ap = (const proto_data_t *)a;\n  const proto_data_t *bp = (const proto_data_t *)b;\n\n  if (ap -> proto > bp -> proto) {\n    return 1;\n  } else if (ap -> proto == bp -> proto) {\n    if (ap->key > bp->key){\n      return 1;\n    } else if (ap -> key == bp -> key) {\n      return 0;\n    }\n    return -1;\n  } else {\n    return -1;\n  }\n}"", ""start_line"": 50, ""end_line"": 68, ""full_name"": ""p_compare<duplicate>1"", ""file_path"": ""epan/proto_data.c""}]}]","The segmentation fault is triggered by a null `pkt_info` during the second pass of `dissect_modbus` (packet-mbtcp.c:1573-1574). The initial allocation of `pkt_info` occurs via `wmem_new0` (line 1558) during the first pass and is stored using `p_add_proto_data` (line 1608). On the second pass, `pkt_info` is retrieved via `p_get_proto_data` (line 1608), which returns null. The `p_get_proto_data` function (proto_data.c:97-121) searches for the `proto_data` entry in `pinfo->fd->pfd` using `g_slist_find_custom` with `p_compare` (proto_data.c:50-68). The `p_compare` function correctly matches `proto` and `key`, but the entry is not found, leading to a null return. The root cause is that the `proto_data` entry added during the first pass is not present in the `pinfo->fd->pfd` list during the second pass, likely due to incorrect scope or key mismatch. The patch (packet-mbtcp.c:1575-1577) prevents out-of-bounds reads but does not address the null `pkt_info` issue.",0.95,./github/other_context/CVE-2017-13764
54,CVE-2017-15056,CWE-476,c_cpp,"p_lx_elf.cpp in UPX 3.94 mishandles ELF headers, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by an Invalid Pointer Read in PackLinuxElf64::unpack().",https://github.com/upx/upx/commit/ef336dbcc6dc8344482f8cf6c909ae96c3286317,Protect against bad crafted input.\n\nhttps://github.com/upx/upx/issues/128\n	modified:   p_lx_elf.cpp,4,"[{""func_name"": ""PackLinuxElf64::unpack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\""p_info corrupted\"");\n\n#define MAX_ELF_HDR 1024\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *) u.buf;\n    Elf64_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\""b_info corrupted\"");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\""ElfXX_Ehdr corrupted\"");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te64(&phdr->p_offset);\n                unsigned const dyn_len = get_te64(&phdr->p_filesz);\n                Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(upx_uint64_t) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf64::PackLinuxElf64help1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf64::PackLinuxElf64help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    e_phoff = get_te64(&ehdri.e_phoff);\n    e_shoff = get_te64(&ehdri.e_shoff);\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf64_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf64_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr const *)(e_shoff + file_image);  // do not free() !!\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te64(&sec_dynsym->sh_link) + shdri;\n\n        Elf64_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te64(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(get_te64(&phdr->p_offset) + file_image);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te64(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf32::unpack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\""p_info corrupted\"");\n\n#define MAX_ELF_HDR 512\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) == MAX_ELF_HDR)\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\""b_info corrupted\"");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Peek at resulting Ehdr and Phdrs for use in controlling unpacking.\n    // Uncompress an extra time, and don't verify or update checksums.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI))\n        throwCantUnpack(\""ElfXX_Ehdr corrupted\"");\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te32(&phdr->p_offset);\n                unsigned const dyn_len = get_te32(&phdr->p_filesz);\n                Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(unsigned) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}"", ""target"": 0}, {""func_name"": ""PackLinuxElf32::PackLinuxElf32help1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    e_phoff = get_te32(&ehdri.e_phoff);\n    e_shoff = get_te32(&ehdri.e_shoff);\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr const *)(e_shoff + file_image);  // do not free() !!\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(get_te32(&phdr->p_offset) + file_image);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}"", ""target"": 0}]","[{""func_name"": ""PackLinuxElf64::unpack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\""p_info corrupted\"");\n\n#define MAX_ELF_HDR 1024\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *) u.buf;\n    Elf64_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\""b_info corrupted\"");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\""ElfXX_Ehdr corrupted\"");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf64_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te64(&phdr->p_offset);\n                unsigned const dyn_len = get_te64(&phdr->p_filesz);\n                Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(upx_uint64_t) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}""}, {""func_name"": ""PackLinuxElf64::PackLinuxElf64help1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf64::PackLinuxElf64help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\""0==e_phnum\"");\n    e_phoff = get_te64(&ehdri.e_phoff);\n    if ((unsigned long)file_size < (e_phoff + e_phnum * sizeof(Elf64_Phdr))) {\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    e_shoff = get_te64(&ehdri.e_shoff);\n    if ((unsigned long)file_size < (e_shoff + e_shnum * sizeof(Elf64_Shdr))) {\n        throwCantUnpack(\""bad e_shoff\"");\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf64_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf64_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr const *)(e_shoff + file_image);  // do not free() !!\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te64(&sec_dynsym->sh_link) + shdri;\n\n        Elf64_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te64(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(get_te64(&phdr->p_offset) + file_image);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te64(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}""}, {""func_name"": ""PackLinuxElf32::unpack"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if (file_size > (off_t)orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\""p_info corrupted\"");\n\n#define MAX_ELF_HDR 512\n    union {\n        unsigned char buf[MAX_ELF_HDR];\n        struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) == MAX_ELF_HDR)\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *) u.buf;\n    Elf32_Phdr const *phdr = 0;\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > sizeof(u))\n        throwCantUnpack(\""b_info corrupted\"");\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Peek at resulting Ehdr and Phdrs for use in controlling unpacking.\n    // Uncompress an extra time, and don't verify or update checksums.\n    if (ibuf.getSize() < ph.c_len  ||  sizeof(u) < ph.u_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI))\n        throwCantUnpack(\""ElfXX_Ehdr corrupted\"");\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    bool const is_shlib = !!elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        // Read enough to position the input for next unpackExtent.\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, overlay_offset + sizeof(hbuf) + szb_info + ph.c_len);\n        overlay_offset -= sizeof(linfo);\n        if (fo) {\n            fo->write(ibuf + ph.u_len, overlay_offset - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = overlay_offset;\n        total_out = overlay_offset;\n        ph.u_len = 0;\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - overlay_offset;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = d_info[2 + (0==d_info[0])];\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {  // the non-first PT_LOAD\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n        // Restore DT_INIT.d_val\n        phdr = (Elf32_Phdr *) (u.buf + sizeof(*ehdr));\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (phdr->PT_DYNAMIC==get_te32(&phdr->p_type)) {\n                unsigned const dyn_off = get_te32(&phdr->p_offset);\n                unsigned const dyn_len = get_te32(&phdr->p_filesz);\n                Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                    (dyn_off - load_off));\n                for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        if (fo) {\n                            fo->seek(sizeof(unsigned) + j2 + dyn_off, SEEK_SET);\n                            fo->rewrite(&old_dtinit, sizeof(old_dtinit));\n                            fo->seek(0, SEEK_END);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n#undef MAX_ELF_HDR\n}""}, {""func_name"": ""PackLinuxElf32::PackLinuxElf32help1"", ""file_path"": ""src/p_lx_elf.cpp"", ""func_code"": ""void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\""0==e_phnum\"");\n    e_phoff = get_te32(&ehdri.e_phoff);\n    if ((unsigned long)file_size < ((unsigned long)e_phoff + e_phnum * sizeof(Elf32_Phdr))) {\n        throwCantUnpack(\""bad e_phoff\"");\n    }\n    e_shoff = get_te32(&ehdri.e_shoff);\n    if ((unsigned long)file_size < ((unsigned long)e_shoff + e_shnum * sizeof(Elf32_Shdr))) {\n        throwCantUnpack(\""bad e_shoff\"");\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr const *)(e_shoff + file_image);  // do not free() !!\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(get_te32(&phdr->p_offset) + file_image);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}""}]","{""code"": 7, ""value"": 10, ""function"": 2}","[{""source"": ""code_info(file:p_lx_elf.cpp, lines:100-200)"", ""result"": ""static unsigned\nfunpad4(InputFile *fi)\n{\n    unsigned d = 3u & (0 - fi->tell());\n    if (d)\n        fi->seek(d, SEEK_CUR);\n    return d;\n}\n\nstatic void alloc_file_image(MemBuffer &mb, off_t size)\n{\n    assert(mem_size_valid_bytes(size));\n    if (mb.getVoidPtr() == NULL) {\n        mb.alloc(size);\n    } else {\n        assert(size <= (off_t) mb.getSize());\n    }\n}\n\nint\nPackLinuxElf32::checkEhdr(Elf32_Ehdr const *ehdr) const\n{\n    const unsigned char * const buf = ehdr->e_ident;\n\n    if (0!=memcmp(buf, \""\\x7f\\x45\\x4c\\x46\"", 4)  // \""\\177ELF\""\n    ||  buf[Elf32_Ehdr::EI_CLASS]!=ei_class\n    ||  buf[Elf32_Ehdr::EI_DATA] !=ei_data\n    ) {\n        return -1;\n    }\n    if (!memcmp(buf+8, \""FreeBSD\"", 7))                   // branded\n        return 1;\n\n    int const type = get_te16(&ehdr->e_type);\n    if (type != Elf32_Ehdr::ET_EXEC && type != Elf32_Ehdr::ET_DYN)\n        return 2;\n    if (get_te16(&ehdr->e_machine) != (unsigned) e_machine)\n        return 3;\n    if (get_te32(&ehdr->e_version) != Elf32_Ehdr::EV_CURRENT)\n        return 4;\n    if (e_phnum < 1)\n        return 5;\n    if (get_te16(&ehdr->e_phentsize) != sizeof(Elf32_Phdr))\n        return 6;\n\n    if (type == Elf32_Ehdr::ET_EXEC) {\n        // check for Linux kernels\n        unsigned const entry = get_te32(&ehdr->e_entry);\n        if (entry == 0xC0100000)    // uncompressed vmlinux\n            return 1000;\n        if (entry == 0x00001000)    // compressed vmlinux\n            return 1001;\n        if (entry == 0x00100000)    // compressed bvmlinux\n            return 1002;\n    }\n\n    // FIXME: add more checks for kernels\n\n    // FIXME: add special checks for other ELF i386 formats, like\n    //        NetBSD, OpenBSD, Solaris, ....\n\n    // success\n    return 0;\n}\n\nint\nPackLinuxElf64::checkEhdr(Elf64_Ehdr const *ehdr) const\n{\n    const unsigned char * const buf = ehdr->e_ident;\n    unsigned char osabi0 = buf[Elf32_Ehdr::EI_OSABI];\n    if (0==osabi0) {\n        osabi0 = opt->o_unix.osabi0;\n    }\n\n    if (0!=memcmp(buf, \""\\x7f\\x45\\x4c\\x46\"", 4)  // \""\\177ELF\""\n    ||  buf[Elf64_Ehdr::EI_CLASS]!=ei_class\n    ||  buf[Elf64_Ehdr::EI_DATA] !=ei_data\n    ||                     osabi0!=ei_osabi\n    ) {\n        return -1;\n    }\n    if (!memcmp(buf+8, \""FreeBSD\"", 7))                   // branded\n        return 1;\n\n    int const type = get_te16(&ehdr->e_type);\n    if (type != Elf64_Ehdr::ET_EXEC && type != Elf64_Ehdr::ET_DYN)\n        return 2;\n    if (get_te16(&ehdr->e_machine) != (unsigned) e_machine)\n        return 3;\n    if (get_te32(&ehdr->e_version) != Elf64_Ehdr::EV_CURRENT)\n        return 4;\n    if (e_phnum < 1)\n        return 5;\n    if (get_te16(&ehdr->e_phentsize) != sizeof(Elf64_Phdr))\n        return 6;\n\n    if (type == Elf64_Ehdr::ET_EXEC) {\n        // check for Linux kernels\n        upx_uint64_t const entry = get_te64(&ehdr->e_entry);\n        if (entry == 0xC0100000)    // uncompressed vmlinux\n            return 1000;\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:200-300)"", ""result"": ""            return 1000;\n        if (entry == 0x00001000)    // compressed vmlinux\n            return 1001;\n        if (entry == 0x00100000)    // compressed bvmlinux\n            return 1002;\n    }\n\n    // FIXME: add more checks for kernels\n\n    // FIXME: add special checks for other ELF i386 formats, like\n    //        NetBSD, OpenBSD, Solaris, ....\n\n    // success\n    return 0;\n}\n\nPackLinuxElf::PackLinuxElf(InputFile *f)\n    : super(f), e_phnum(0), dynstr(NULL),\n    sz_phdrs(0), sz_elf_hdrs(0), sz_pack2(0), sz_pack2a(0),\n    lg2_page(12), page_size(1u<<lg2_page), is_big(0), is_pie(0),\n    xct_off(0), xct_va(0), jni_onload_va(0),\n    e_machine(0), ei_class(0), ei_data(0), ei_osabi(0), osabi_note(NULL),\n    o_elf_shnum(0)\n{\n}\n\nPackLinuxElf::~PackLinuxElf()\n{\n}\n\nvoid\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    e_phoff = get_te32(&ehdri.e_phoff);\n    e_shoff = get_te32(&ehdri.e_shoff);\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr const *)(e_shoff + file_image);  // do not free() !!\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(get_te32(&phdr->p_offset) + file_image);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        jni_onload_sym = elf_lookup(\""JNI_OnLoad\"");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;\n        }\n    }\n}\n\nvoid PackLinuxElf::pack3(OutputFile *fo, Filter &ft)\n{\n    unsigned disp;\n    unsigned const zero = 0;\n    unsigned len = sz_pack2a;  // after headers and all PT_LOAD\n\n    unsigned const t = (4 & len) ^ ((!!xct_off)<<2);  // 0 or 4\n    fo->write(&zero, t);\n    len += t;\n\n    set_te32(&disp, 2*sizeof(disp) + len - (sz_elf_hdrs + sizeof(p_info) + sizeof(l_info)));\n    fo->write(&disp, sizeof(disp));  // .e_entry - &first_b_info\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri.e_phoff)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_phoff"", ""line"": 248, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phoff"", ""line"": 664, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}], ""struct_var"": ""ehdri"", ""struct_type"": ""Elf32_Ehdr"", ""struct_definition"": ""typedef ElfClass_Host32::Ehdr Elf32_Ehdr;\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}""}}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri.e_phnum)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_phnum"", ""line"": 234, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 371, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 463, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 650, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 2986, ""func_name"": ""PackLinuxElf32.ARM_is_QNX:int(void)""}], ""struct_var"": ""ehdri"", ""struct_type"": ""Elf32_Ehdr"", ""struct_definition"": ""typedef ElfClass_Host32::Ehdr Elf32_Ehdr;\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}""}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:50-100)"", ""result"": ""#define PT_GNU_STACK64  Elf64_Phdr::PT_GNU_STACK\n\n//static unsigned const EF_ARM_HASENTRY = 0x02;\nstatic unsigned const EF_ARM_EABI_VER4 = 0x04000000;\nstatic unsigned const EF_ARM_EABI_VER5 = 0x05000000;\n\nunsigned char PackLinuxElf::o_shstrtab[] = {  \\\n/*start*/       '\\0',\n/*offset  1*/   '.','n','o','t','e','.','g','n','u','.','b','u','i','l','d','-','i','d','\\0',\n/*offset 20*/   '.','s','h','s','t','r','t','a','b','\\0'\n};\n\nstatic unsigned\numin(unsigned a, unsigned b)\n{\n    return (a < b) ? a : b;\n}\n\nstatic upx_uint64_t\numin64(upx_uint64_t a, upx_uint64_t b)\n{\n    return (a < b) ? a : b;\n}\n\nstatic unsigned\nup4(unsigned x)\n{\n    return ~3u & (3+ x);\n}\n\nstatic unsigned\nfpad4(OutputFile *fo)\n{\n    unsigned len = fo->st_size();\n    unsigned d = 3u & (0 - len);\n    unsigned zero = 0;\n    fo->write(&zero, d);\n    return d + len;\n}\n\nstatic unsigned\nfpad8(OutputFile *fo)\n{\n    unsigned len = fo->st_size();\n    unsigned d = 7u & (0 - len);\n    upx_uint64_t zero = 0;\n    fo->write(&zero, d);\n    return d + len;\n}\n\nstatic unsigned\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:0-50)"", ""result"": ""/* p_lx_elf.cpp --\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2017 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2017 Laszlo Molnar\n   Copyright (C) 2000-2017 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \""conf.h\""\n\n#include \""file.h\""\n#include \""filter.h\""\n#include \""linker.h\""\n#include \""packer.h\""\n#include \""p_elf.h\""\n#include \""p_unix.h\""\n#include \""p_lx_exc.h\""\n#include \""p_lx_elf.h\""\n#include \""ui.h\""\n\n#define PT_LOAD32   Elf32_Phdr::PT_LOAD\n#define PT_LOAD64   Elf64_Phdr::PT_LOAD\n#define PT_NOTE32   Elf32_Phdr::PT_NOTE\n#define PT_NOTE64   Elf64_Phdr::PT_NOTE\n#define PT_GNU_STACK32  Elf32_Phdr::PT_GNU_STACK\n#define PT_GNU_STACK64  Elf64_Phdr::PT_GNU_STACK\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri.e_phoff)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_phoff"", ""line"": 248, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phoff"", ""line"": 664, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}], ""struct_var"": ""ehdri"", ""struct_type"": ""Elf32_Ehdr"", ""struct_definition"": ""typedef ElfClass_Host32::Ehdr Elf32_Ehdr;\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}""}}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri.e_phnum)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_phnum"", ""line"": 234, ""func_name"": ""PackLinuxElf32.PackLinuxElf32help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 371, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 463, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 650, ""func_name"": ""PackLinuxElf64.PackLinuxElf64help1:void(InputFile*)""}, {""full_code"": ""ehdri.e_phnum"", ""line"": 2986, ""func_name"": ""PackLinuxElf32.ARM_is_QNX:int(void)""}], ""struct_var"": ""ehdri"", ""struct_type"": ""Elf32_Ehdr"", ""struct_definition"": ""typedef ElfClass_Host32::Ehdr Elf32_Ehdr;\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}\n\ntypedef struct\n{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;\n  Elf32_Off     e_phoff;\n  Elf32_Off     e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n}""}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:0-50)"", ""result"": ""/* p_lx_elf.cpp --\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2017 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2017 Laszlo Molnar\n   Copyright (C) 2000-2017 John F. Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n\n   John F. Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \""conf.h\""\n\n#include \""file.h\""\n#include \""filter.h\""\n#include \""linker.h\""\n#include \""packer.h\""\n#include \""p_elf.h\""\n#include \""p_unix.h\""\n#include \""p_lx_exc.h\""\n#include \""p_lx_elf.h\""\n#include \""ui.h\""\n\n#define PT_LOAD32   Elf32_Phdr::PT_LOAD\n#define PT_LOAD64   Elf64_Phdr::PT_LOAD\n#define PT_NOTE32   Elf32_Phdr::PT_NOTE\n#define PT_NOTE64   Elf64_Phdr::PT_NOTE\n#define PT_GNU_STACK32  Elf32_Phdr::PT_GNU_STACK\n#define PT_GNU_STACK64  Elf64_Phdr::PT_GNU_STACK\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:300-400)"", ""result"": ""    fo->write(&disp, sizeof(disp));  // .e_entry - &first_b_info\n    len += sizeof(disp);\n    set_te32(&disp, len);  // distance back to beginning (detect dynamic reloc)\n    fo->write(&disp, sizeof(disp));\n    len += sizeof(disp);\n\n    if (xct_off) {  // is_shlib\n        upx_uint64_t const firstpc_va = (jni_onload_va\n            ? jni_onload_va\n            : elf_unsigned_dynamic(Elf32_Dyn::DT_INIT) );\n        set_te32(&disp, firstpc_va - load_va);\n        fo->write(&disp, sizeof(disp));\n        len += sizeof(disp);\n\n        set_te32(&disp, hatch_off);\n        fo->write(&disp, sizeof(disp));\n        len += sizeof(disp);\n\n        set_te32(&disp, xct_off);\n        fo->write(&disp, sizeof(disp));\n        len += sizeof(disp);\n    }\n    sz_pack2 = len;  // 0 mod 8\n\n    super::pack3(fo, ft);  // append the decompressor\n    set_te16(&linfo.l_lsize, up4(  // MATCH03: up4\n    get_te16(&linfo.l_lsize) + len - sz_pack2a));\n\n    len = fpad4(fo);  // MATCH03\n    ACC_UNUSED(len);\n}\n\nvoid PackLinuxElf32::pack3(OutputFile *fo, Filter &ft)\n{\n    super::pack3(fo, ft);  // loader follows compressed PT_LOADs\n    // Then compressed gaps (including debuginfo.)\n    unsigned total_in = 0, total_out = 0;\n    for (unsigned k = 0; k < e_phnum; ++k) {\n        Extent x;\n        x.size = find_LOAD_gap(phdri, k, e_phnum);\n        if (x.size) {\n            x.offset = get_te32(&phdri[k].p_offset) +\n                       get_te32(&phdri[k].p_filesz);\n            packExtent(x, total_in, total_out, 0, fo);\n        }\n    }\n    // write block end marker (uncompressed size 0)\n    b_info hdr; memset(&hdr, 0, sizeof(hdr));\n    set_le32(&hdr.sz_cpr, UPX_MAGIC_LE32);\n    fo->write(&hdr, sizeof(hdr));\n    fpad4(fo);\n\n    set_te32(&elfout.phdr[0].p_filesz, sz_pack2 + lsize);\n    set_te32(&elfout.phdr[0].p_memsz,  sz_pack2 + lsize);\n    if (0!=xct_off) {  // shared library\n        Elf32_Phdr *phdr = phdri;\n        unsigned off = fo->st_size();\n        unsigned off_init = 0;  // where in file\n        unsigned va_init = sz_pack2;   // virtual address\n        so_slide = 0;\n        for (int j = e_phnum; --j>=0; ++phdr) {\n            unsigned const len  = get_te32(&phdr->p_filesz);\n            unsigned const ioff = get_te32(&phdr->p_offset);\n            unsigned const type = get_te32(&phdr->p_type);\n            if (phdr->PT_INTERP==type) {\n                // Rotate to highest position, so it can be lopped\n                // by decrementing e_phnum.\n                memcpy((unsigned char *)ibuf, phdr, sizeof(*phdr));\n                memmove(phdr, 1+phdr, j * sizeof(*phdr));  // overlapping\n                memcpy(&phdr[j], (unsigned char *)ibuf, sizeof(*phdr));\n                --phdr;\n                set_te16(&ehdri.e_phnum, --e_phnum);\n                continue;\n            }\n            if (phdr->PT_LOAD32==type) {\n                if (xct_off < ioff) {  // Slide up non-first PT_LOAD.\n                    fi->seek(ioff, SEEK_SET);\n                    fi->readx(ibuf, len);\n                    off += ~page_mask & (ioff - off);\n                    fo->seek(off, SEEK_SET);\n                    fo->write(ibuf, len);\n                    so_slide = off - ioff;\n                    set_te32(&phdr->p_offset, so_slide + ioff);\n                }\n                else {  // Change length of first PT_LOAD.\n                    va_init += get_te32(&phdr->p_vaddr);\n                    set_te32(&phdr->p_filesz, sz_pack2 + lsize);\n                    set_te32(&phdr->p_memsz,  sz_pack2 + lsize);\n                }\n                continue;  // all done with this PT_LOAD\n            }\n            // Compute new offset of &DT_INIT.d_val.\n            if (/*0==jni_onload_sym &&*/ phdr->PT_DYNAMIC==type) {\n                off_init = so_slide + ioff;\n                fi->seek(ioff, SEEK_SET);\n                fi->read(ibuf, len);\n                Elf32_Dyn *dyn = (Elf32_Dyn *)(void *)ibuf;\n                for (int j2 = len; j2 > 0; ++dyn, j2 -= sizeof(*dyn)) {\n                    if (dyn->DT_INIT==get_te32(&dyn->d_tag)) {\n                        unsigned const t = (unsigned char *)&dyn->d_val -\n                                           (unsigned char *)ibuf;\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:p_lx_elf.cpp, lines:100-200)"", ""result"": ""static unsigned\nfunpad4(InputFile *fi)\n{\n    unsigned d = 3u & (0 - fi->tell());\n    if (d)\n        fi->seek(d, SEEK_CUR);\n    return d;\n}\n\nstatic void alloc_file_image(MemBuffer &mb, off_t size)\n{\n    assert(mem_size_valid_bytes(size));\n    if (mb.getVoidPtr() == NULL) {\n        mb.alloc(size);\n    } else {\n        assert(size <= (off_t) mb.getSize());\n    }\n}\n\nint\nPackLinuxElf32::checkEhdr(Elf32_Ehdr const *ehdr) const\n{\n    const unsigned char * const buf = ehdr->e_ident;\n\n    if (0!=memcmp(buf, \""\\x7f\\x45\\x4c\\x46\"", 4)  // \""\\177ELF\""\n    ||  buf[Elf32_Ehdr::EI_CLASS]!=ei_class\n    ||  buf[Elf32_Ehdr::EI_DATA] !=ei_data\n    ) {\n        return -1;\n    }\n    if (!memcmp(buf+8, \""FreeBSD\"", 7))                   // branded\n        return 1;\n\n    int const type = get_te16(&ehdr->e_type);\n    if (type != Elf32_Ehdr::ET_EXEC && type != Elf32_Ehdr::ET_DYN)\n        return 2;\n    if (get_te16(&ehdr->e_machine) != (unsigned) e_machine)\n        return 3;\n    if (get_te32(&ehdr->e_version) != Elf32_Ehdr::EV_CURRENT)\n        return 4;\n    if (e_phnum < 1)\n        return 5;\n    if (get_te16(&ehdr->e_phentsize) != sizeof(Elf32_Phdr))\n        return 6;\n\n    if (type == Elf32_Ehdr::ET_EXEC) {\n        // check for Linux kernels\n        unsigned const entry = get_te32(&ehdr->e_entry);\n        if (entry == 0xC0100000)    // uncompressed vmlinux\n            return 1000;\n        if (entry == 0x00001000)    // compressed vmlinux\n            return 1001;\n        if (entry == 0x00100000)    // compressed bvmlinux\n            return 1002;\n    }\n\n    // FIXME: add more checks for kernels\n\n    // FIXME: add special checks for other ELF i386 formats, like\n    //        NetBSD, OpenBSD, Solaris, ....\n\n    // success\n    return 0;\n}\n\nint\nPackLinuxElf64::checkEhdr(Elf64_Ehdr const *ehdr) const\n{\n    const unsigned char * const buf = ehdr->e_ident;\n    unsigned char osabi0 = buf[Elf32_Ehdr::EI_OSABI];\n    if (0==osabi0) {\n        osabi0 = opt->o_unix.osabi0;\n    }\n\n    if (0!=memcmp(buf, \""\\x7f\\x45\\x4c\\x46\"", 4)  // \""\\177ELF\""\n    ||  buf[Elf64_Ehdr::EI_CLASS]!=ei_class\n    ||  buf[Elf64_Ehdr::EI_DATA] !=ei_data\n    ||                     osabi0!=ei_osabi\n    ) {\n        return -1;\n    }\n    if (!memcmp(buf+8, \""FreeBSD\"", 7))                   // branded\n        return 1;\n\n    int const type = get_te16(&ehdr->e_type);\n    if (type != Elf64_Ehdr::ET_EXEC && type != Elf64_Ehdr::ET_DYN)\n        return 2;\n    if (get_te16(&ehdr->e_machine) != (unsigned) e_machine)\n        return 3;\n    if (get_te32(&ehdr->e_version) != Elf64_Ehdr::EV_CURRENT)\n        return 4;\n    if (e_phnum < 1)\n        return 5;\n    if (get_te16(&ehdr->e_phentsize) != sizeof(Elf64_Phdr))\n        return 6;\n\n    if (type == Elf64_Ehdr::ET_EXEC) {\n        // check for Linux kernels\n        upx_uint64_t const entry = get_te64(&ehdr->e_entry);\n        if (entry == 0xC0100000)    // uncompressed vmlinux\n            return 1000;\n""}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:p_lx_elf.cpp, func:PackLinuxElf32)"", ""result"": [{""code"": ""PackLinuxElf32::PackLinuxElf32(InputFile *f)\n    : super(f), phdri(NULL) , shdri(NULL), gnu_stack(NULL), note_body(NULL),\n    page_mask(~0u<<lg2_page),\n    dynseg(NULL), hashtab(NULL), gashtab(NULL), dynsym(NULL),\n    jni_onload_sym(NULL),\n    shstrtab(NULL),\n    sec_strndx(NULL), sec_dynsym(NULL), sec_dynstr(NULL)\n{\n    memset(&ehdri, 0, sizeof(ehdri));\n    if (f) {\n        f->seek(0, SEEK_SET);\n        f->readx(&ehdri, sizeof(ehdri));\n    }\n}"", ""start_line"": 605, ""end_line"": 618, ""full_name"": ""PackLinuxElf32.PackLinuxElf32:ANY(InputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}]}, {""source"": ""func_info(file:p_lx_elf.cpp, func:PackLinuxElf64)"", ""result"": [{""code"": ""PackLinuxElf64::PackLinuxElf64(InputFile *f)\n    : super(f), phdri(NULL), shdri(NULL), gnu_stack(NULL), note_body(NULL),\n    page_mask(~0ull<<lg2_page),\n    dynseg(NULL), hashtab(NULL), gashtab(NULL), dynsym(NULL),\n    jni_onload_sym(NULL),\n    shstrtab(NULL),\n    sec_strndx(NULL), sec_dynsym(NULL), sec_dynstr(NULL)\n{\n    memset(&ehdri, 0, sizeof(ehdri));\n    if (f) {\n        f->seek(0, SEEK_SET);\n        f->readx(&ehdri, sizeof(ehdri));\n    }\n}"", ""start_line"": 625, ""end_line"": 638, ""full_name"": ""PackLinuxElf64.PackLinuxElf64:ANY(InputFile*)"", ""file_path"": ""src/p_lx_elf.cpp""}]}, {""source"": ""value_info(file:p_lx_elf.cpp, value:ehdri)"", ""result"": {""value_trace"": [{""full_code"": ""ehdri.e_shnum = 0"", ""line"": 417, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 418, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shstrndx = 0"", ""line"": 419, ""func_name"": ""PackLinuxElf32.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shnum = 0"", ""line"": 515, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}, {""full_code"": ""ehdri.e_shoff = 0"", ""line"": 516, ""func_name"": ""PackLinuxElf64.pack3:void(OutputFile*,Filter&)""}], ""struct_var"": ""ehdri"", ""struct_type"": null, ""struct_definition"": null}}]","1. **Trigger**: A crafted ELF file provides invalid `e_phoff` or `e_phnum` in its ELF header (p_lx_elf.cpp:605-618 for 32-bit, p_lx_elf.cpp:625-638 for 64-bit). These values are read into `ehdri` via `f->readx(&ehdri, sizeof(ehdri))`.\n2. **Propagation**: `ehdri.e_phoff` and `ehdri.e_phnum` are accessed in `PackLinuxElf32help1` (p_lx_elf.cpp:234, 248) and `PackLinuxElf64help1` (p_lx_elf.cpp:650, 664) without sufficient bounds checks.\n3. **Validation Gap**: While `checkEhdr` validates `e_phnum >= 1` (p_lx_elf.cpp:100-200), it does not verify `e_phoff` validity or ensure program headers fit within the file size.\n4. **Impact**: Unvalidated `e_phoff`/`e_phnum` leads to out-of-bounds memory access in `PackLinuxElf64::unpack()` (e.g., reading program headers beyond the file's size), causing an invalid pointer read and potential crash.",0.95,./github/other_context/CVE-2017-15056
55,CVE-2017-17479,"CWE-787, CWE-476",c_cpp,"In OpenJPEG 2.3.0, a stack-based buffer overflow was discovered in the pgxtoimage function in jpwl/convert.c. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly remote code execution.",https://github.com/uclouvain/openjpeg/commit/0bc90e4062a5f9258c91eca018c019b179066c62,jp3d/jpwl convert: fix write stack buffer overflow\n\nMissing buffer length formatter in fscanf call might lead to write\nstack buffer overflow.\n\nfixes #1044 (CVE-2017-17480),3,"[{""func_name"": ""pgxtovolume"", ""file_path"": ""src/bin/jpwl/convert.c"", ""func_code"": ""opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters)\n{\n\n    FILE *f = NULL;\n    int w, h, prec;\n    unsigned long offset;\n    int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;\n\n    OPJ_COLOR_SPACE color_space;\n    opj_volume_cmptparm_t cmptparm; /* maximum of 1 component */\n    opj_volume_t * volume = NULL;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n    char temp[32];\n    opj_volume_comp_t *comp = NULL;\n\n    DIR *dirp;\n    struct dirent *direntp;\n\n    char *tmp = NULL, *tmp2 = NULL,\n          *point = NULL, *pgx = NULL;\n    char tmpdirpath[MAX_PATH];\n    char dirpath[MAX_PATH];\n    char pattern[MAX_PATH];\n    char pgxfiles[MAX_SLICES][MAX_PATH];\n    int pgxslicepos[MAX_SLICES];\n    char tmpno[3];\n\n    numcomps = 1;\n    color_space = CLRSPC_GRAY;\n    sliceno = 0;\n    maxvalue = 0;\n    memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));\n    memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* Separaci\u00f3n del caso de un \u00fanico slice frente al de muchos */\n    if ((tmp = strrchr(relpath, '-')) == NULL) {\n        /*fprintf(stdout,\""[INFO] A volume of only one slice....\\n\"");*/\n        sliceno = 1;\n        maxslice = 1;\n        strcpy(pgxfiles[0], relpath);\n\n    } else {\n        /*Fetch only the path */\n        strcpy(tmpdirpath, relpath);\n        if ((tmp = strrchr(tmpdirpath, '/')) != NULL) {\n            tmp++;\n            *tmp = '\\0';\n            strcpy(dirpath, tmpdirpath);\n        } else {\n            strcpy(dirpath, \""./\"");\n        }\n\n        /*Fetch the pattern of the volume slices*/\n        if ((tmp = strrchr(relpath, '/')) != NULL) {\n            tmp++;\n        } else {\n            tmp = relpath;\n        }\n        if ((tmp2 = strrchr(tmp, '-')) != NULL) {\n            *tmp2 = '\\0';\n        } else {\n            fprintf(stdout, \""[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\"", tmp,\n                    relpath);\n            return NULL;\n        }\n        strcpy(pattern, tmp);\n\n        dirp = opendir(dirpath);\n        if (dirp == NULL) {\n            fprintf(stdout,\n                    \""[ERROR] Infile must be a .pgx file or a directory that contain pgx files\"");\n            return NULL;\n        }\n\n        /*Read all .pgx files of directory */\n        while ((direntp = readdir(dirp)) != NULL) {\n            /* Found a directory, but ignore . and .. */\n            if (strcmp(\"".\"", direntp->d_name) == 0 || strcmp(\""..\"", direntp->d_name) == 0) {\n                continue;\n            }\n\n            if (((pgx = strstr(direntp->d_name, pattern)) != NULL) &&\n                    ((tmp2 = strstr(direntp->d_name, \"".pgx\"")) != NULL)) {\n\n                strcpy(tmp, dirpath);\n                tmp = strcat(tmp, direntp->d_name);\n\n                /*Obtenemos el index de la secuencia de slices*/\n                if ((tmp2 = strpbrk(direntp->d_name, \""0123456789\"")) == NULL) {\n                    continue;\n                }\n                i = 0;\n                while (tmp2 != NULL) {\n                    tmpno[i++] = *tmp2;\n                    point = tmp2;\n                    tmp2 = strpbrk(tmp2 + 1, \""0123456789\"");\n                }\n                tmpno[i] = '\\0';\n\n                /*Comprobamos que no estamos leyendo algo raro como pattern.jp3d*/\n                if ((point = strpbrk(point, \"".\"")) == NULL) {\n                    break;\n                }\n                /*Slicepos --> index de slice; Sliceno --> no de slices hasta el momento*/\n                slicepos = atoi(tmpno);\n                pgxslicepos[sliceno] = slicepos - 1;\n                sliceno++;\n                if (slicepos > maxslice) {\n                    maxslice = slicepos;\n                }\n\n                /*Colocamos el slices en su posicion correspondiente*/\n                strcpy(pgxfiles[slicepos - 1], tmp);\n            }\n        }\n\n    }/* else if pattern*.pgx */\n\n    if (!sliceno) {\n        fprintf(stdout,\n                \""[ERROR] No slices with this pattern founded !! Please check input volume name\\n\"");\n        return NULL;\n    }\n    /*if ( maxslice != sliceno) {\n        fprintf(stdout,\""[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\\n\"");\n        return NULL;\n    }*/\n\n    for (s = 0; s < sliceno; s++) {\n        int pos = maxslice == sliceno ? s : pgxslicepos[s];\n        f = fopen(pgxfiles[pos], \""rb\"");\n        if (!f) {\n            fprintf(stdout, \""[ERROR] Failed to open %s for reading !\\n\"", pgxfiles[s]);\n            return NULL;\n        }\n        fprintf(stdout, \""[INFO] Loading %s \\n\"", pgxfiles[pos]);\n\n        fseek(f, 0, SEEK_SET);\n        fscanf(f, \""PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\"", temp, &endian1, &endian2,\n               signtmp, &prec, temp, &w, temp, &h);\n\n        i = 0;\n        sign = '+';\n        while (signtmp[i] != '\\0') {\n            if (signtmp[i] == '-') {\n                sign = '-';\n            }\n            i++;\n        }\n\n        fgetc(f);\n        if (endian1 == 'M' && endian2 == 'L') {\n            cmptparm.bigendian = 1;\n        } else if (endian2 == 'M' && endian1 == 'L') {\n            cmptparm.bigendian = 0;\n        } else {\n            fprintf(stdout, \""[ERROR] Bad pgx header, please check input file\\n\"");\n            fclose(f);\n            return NULL;\n        }\n\n        if (s == 0) {\n            /* initialize volume component */\n\n            cmptparm.x0 = parameters->volume_offset_x0;\n            cmptparm.y0 = parameters->volume_offset_y0;\n            cmptparm.z0 = parameters->volume_offset_z0;\n            cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 :\n                         cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;\n            cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 :\n                         cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;\n            cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 :\n                         cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;\n\n            if (sign == '-') {\n                cmptparm.sgnd = 1;\n            } else {\n                cmptparm.sgnd = 0;\n            }\n            cmptparm.prec = prec;\n            cmptparm.bpp = prec;\n            cmptparm.dcoffset = parameters->dcoffset;\n            cmptparm.dx = parameters->subsampling_dx;\n            cmptparm.dy = parameters->subsampling_dy;\n            cmptparm.dz = parameters->subsampling_dz;\n\n            /* create the volume */\n            volume = opj_volume_create(numcomps, &cmptparm, color_space);\n            if (!volume) {\n                fclose(f);\n                return NULL;\n            }\n            /* set volume offset and reference grid */\n            volume->x0 = cmptparm.x0;\n            volume->y0 = cmptparm.y0;\n            volume->z0 = cmptparm.z0;\n            volume->x1 = cmptparm.w;\n            volume->y1 = cmptparm.h;\n            volume->z1 = cmptparm.l;\n\n            /* set volume data :only one component, that is a volume*/\n            comp = &volume->comps[0];\n\n        }/*if sliceno==1*/\n\n        offset = w * h * s;\n\n        for (i = 0; i < w * h; i++) {\n            int v;\n            if (comp->prec <= 8) {\n                if (!comp->sgnd) {\n                    v = readuchar(f);\n                } else {\n                    v = (char) readuchar(f);\n                }\n            } else if (comp->prec <= 16) {\n                if (!comp->sgnd) {\n                    v = readushort(f, cmptparm.bigendian);\n                } else {\n                    v = (short) readushort(f, cmptparm.bigendian);\n                }\n            } else {\n                if (!comp->sgnd) {\n                    v = readuint(f, cmptparm.bigendian);\n                } else {\n                    v = (int) readuint(f, cmptparm.bigendian);\n                }\n            }\n            if (v > maxvalue) {\n                maxvalue = v;\n            }\n            comp->data[i + offset] = v;\n\n        }\n        fclose(f);\n    } /* for s --> sliceno*/\n    comp->bpp = int_floorlog2(maxvalue) + 1;\n    if (sliceno != 1) {\n        closedir(dirp);\n    }\n    /*dump_volume(stdout, volume);*/\n    return volume;\n}"", ""target"": 0}, {""func_name"": ""pgxtovolume"", ""file_path"": ""src/bin/jp3d/convert.c"", ""func_code"": ""opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters)\n{\n\n    FILE *f = NULL;\n    int w, h, prec;\n    unsigned long offset;\n    int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;\n\n    OPJ_COLOR_SPACE color_space;\n    opj_volume_cmptparm_t cmptparm; /* maximum of 1 component */\n    opj_volume_t * volume = NULL;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n    char temp[32];\n    opj_volume_comp_t *comp = NULL;\n\n    DIR *dirp;\n    struct dirent *direntp;\n\n    char *tmp = NULL, *tmp2 = NULL,\n          *point = NULL, *pgx = NULL;\n    char tmpdirpath[MAX_PATH];\n    char dirpath[MAX_PATH];\n    char pattern[MAX_PATH];\n    char pgxfiles[MAX_SLICES][MAX_PATH];\n    int pgxslicepos[MAX_SLICES];\n    char tmpno[3];\n\n    numcomps = 1;\n    color_space = CLRSPC_GRAY;\n    sliceno = 0;\n    maxvalue = 0;\n    memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));\n    memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* Separaci\u00f3n del caso de un \u00fanico slice frente al de muchos */\n    if ((tmp = strrchr(relpath, '-')) == NULL) {\n        /*fprintf(stdout,\""[INFO] A volume of only one slice....\\n\"");*/\n        sliceno = 1;\n        maxslice = 1;\n        strcpy(pgxfiles[0], relpath);\n\n    } else {\n        /*Fetch only the path */\n        strcpy(tmpdirpath, relpath);\n        if ((tmp = strrchr(tmpdirpath, '/')) != NULL) {\n            tmp++;\n            *tmp = '\\0';\n            strcpy(dirpath, tmpdirpath);\n        } else {\n            strcpy(dirpath, \""./\"");\n        }\n\n        /*Fetch the pattern of the volume slices*/\n        if ((tmp = strrchr(relpath, '/')) != NULL) {\n            tmp++;\n        } else {\n            tmp = relpath;\n        }\n        if ((tmp2 = strrchr(tmp, '-')) != NULL) {\n            *tmp2 = '\\0';\n        } else {\n            fprintf(stdout, \""[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\"", tmp,\n                    relpath);\n            return NULL;\n        }\n        strcpy(pattern, tmp);\n\n        dirp = opendir(dirpath);\n        if (dirp == NULL) {\n            fprintf(stdout,\n                    \""[ERROR] Infile must be a .pgx file or a directory that contain pgx files\"");\n            return NULL;\n        }\n\n        /*Read all .pgx files of directory */\n        while ((direntp = readdir(dirp)) != NULL) {\n            /* Found a directory, but ignore . and .. */\n            if (strcmp(\"".\"", direntp->d_name) == 0 || strcmp(\""..\"", direntp->d_name) == 0) {\n                continue;\n            }\n\n            if (((pgx = strstr(direntp->d_name, pattern)) != NULL) &&\n                    ((tmp2 = strstr(direntp->d_name, \"".pgx\"")) != NULL)) {\n\n                strcpy(tmp, dirpath);\n                tmp = strcat(tmp, direntp->d_name);\n\n                /*Obtenemos el index de la secuencia de slices*/\n                if ((tmp2 = strpbrk(direntp->d_name, \""0123456789\"")) == NULL) {\n                    continue;\n                }\n                i = 0;\n                while (tmp2 != NULL) {\n                    tmpno[i++] = *tmp2;\n                    point = tmp2;\n                    tmp2 = strpbrk(tmp2 + 1, \""0123456789\"");\n                }\n                tmpno[i] = '\\0';\n\n                /*Comprobamos que no estamos leyendo algo raro como pattern.jp3d*/\n                if ((point = strpbrk(point, \"".\"")) == NULL) {\n                    break;\n                }\n                /*Slicepos --> index de slice; Sliceno --> no de slices hasta el momento*/\n                slicepos = atoi(tmpno);\n                pgxslicepos[sliceno] = slicepos - 1;\n                sliceno++;\n                if (slicepos > maxslice) {\n                    maxslice = slicepos;\n                }\n\n                /*Colocamos el slices en su posicion correspondiente*/\n                strcpy(pgxfiles[slicepos - 1], tmp);\n            }\n        }\n\n    }/* else if pattern*.pgx */\n\n    if (!sliceno) {\n        fprintf(stdout,\n                \""[ERROR] No slices with this pattern founded !! Please check input volume name\\n\"");\n        return NULL;\n    }\n    /*if ( maxslice != sliceno) {\n        fprintf(stdout,\""[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\\n\"");\n        return NULL;\n    }*/\n\n    for (s = 0; s < sliceno; s++) {\n        int pos = maxslice == sliceno ? s : pgxslicepos[s];\n        f = fopen(pgxfiles[pos], \""rb\"");\n        if (!f) {\n            fprintf(stdout, \""[ERROR] Failed to open %s for reading !\\n\"", pgxfiles[s]);\n            return NULL;\n        }\n        fprintf(stdout, \""[INFO] Loading %s \\n\"", pgxfiles[pos]);\n\n        fseek(f, 0, SEEK_SET);\n        fscanf(f, \""PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\"", temp, &endian1, &endian2,\n               signtmp, &prec, temp, &w, temp, &h);\n\n        i = 0;\n        sign = '+';\n        while (signtmp[i] != '\\0') {\n            if (signtmp[i] == '-') {\n                sign = '-';\n            }\n            i++;\n        }\n\n        fgetc(f);\n        if (endian1 == 'M' && endian2 == 'L') {\n            cmptparm.bigendian = 1;\n        } else if (endian2 == 'M' && endian1 == 'L') {\n            cmptparm.bigendian = 0;\n        } else {\n            fprintf(stdout, \""[ERROR] Bad pgx header, please check input file\\n\"");\n            fclose(f);\n            return NULL;\n        }\n\n        if (s == 0) {\n            /* initialize volume component */\n\n            cmptparm.x0 = parameters->volume_offset_x0;\n            cmptparm.y0 = parameters->volume_offset_y0;\n            cmptparm.z0 = parameters->volume_offset_z0;\n            cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 :\n                         cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;\n            cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 :\n                         cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;\n            cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 :\n                         cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;\n\n            if (sign == '-') {\n                cmptparm.sgnd = 1;\n            } else {\n                cmptparm.sgnd = 0;\n            }\n            cmptparm.prec = prec;\n            cmptparm.bpp = prec;\n            cmptparm.dcoffset = parameters->dcoffset;\n            cmptparm.dx = parameters->subsampling_dx;\n            cmptparm.dy = parameters->subsampling_dy;\n            cmptparm.dz = parameters->subsampling_dz;\n\n            /* create the volume */\n            volume = opj_volume_create(numcomps, &cmptparm, color_space);\n            if (!volume) {\n                fclose(f);\n                return NULL;\n            }\n            /* set volume offset and reference grid */\n            volume->x0 = cmptparm.x0;\n            volume->y0 = cmptparm.y0;\n            volume->z0 = cmptparm.z0;\n            volume->x1 = cmptparm.w;\n            volume->y1 = cmptparm.h;\n            volume->z1 = cmptparm.l;\n\n            /* set volume data :only one component, that is a volume*/\n            comp = &volume->comps[0];\n\n        }/*if sliceno==1*/\n\n        offset = w * h * s;\n\n        for (i = 0; i < w * h; i++) {\n            int v;\n            if (comp->prec <= 8) {\n                if (!comp->sgnd) {\n                    v = readuchar(f);\n                } else {\n                    v = (char) readuchar(f);\n                }\n            } else if (comp->prec <= 16) {\n                if (!comp->sgnd) {\n                    v = readushort(f, cmptparm.bigendian);\n                } else {\n                    v = (short) readushort(f, cmptparm.bigendian);\n                }\n            } else {\n                if (!comp->sgnd) {\n                    v = readuint(f, cmptparm.bigendian);\n                } else {\n                    v = (int) readuint(f, cmptparm.bigendian);\n                }\n            }\n            if (v > maxvalue) {\n                maxvalue = v;\n            }\n            comp->data[i + offset] = v;\n\n        }\n        fclose(f);\n    } /* for s --> sliceno*/\n    comp->bpp = int_floorlog2(maxvalue) + 1;\n    if (sliceno != 1) {\n        closedir(dirp);\n    }\n    /*dump_volume(stdout, volume);*/\n    return volume;\n}"", ""target"": 0}, {""func_name"": ""imagetopnm"", ""file_path"": ""src/bin/jp2/convert.c"", ""func_code"": ""int imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n{\n    int *red, *green, *blue, *alpha;\n    int wr, hr, max;\n    int i;\n    unsigned int compno, ncomp;\n    int adjustR, adjustG, adjustB, adjustA;\n    int fails, two, want_gray, has_alpha, triple;\n    int prec, v;\n    FILE *fdest = NULL;\n    const char *tmp = outfile;\n    char *destname;\n\n    alpha = NULL;\n\n    if ((prec = (int)image->comps[0].prec) > 16) {\n        fprintf(stderr, \""%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\""\n                \""\\n\\t: refused.\\n\"", __FILE__, __LINE__, prec);\n        return 1;\n    }\n    two = has_alpha = 0;\n    fails = 1;\n    ncomp = image->numcomps;\n\n    while (*tmp) {\n        ++tmp;\n    }\n    tmp -= 2;\n    want_gray = (*tmp == 'g' || *tmp == 'G');\n    ncomp = image->numcomps;\n\n    if (want_gray) {\n        ncomp = 1;\n    }\n\n    if ((force_split == 0) && ncomp >= 2 &&\n            are_comps_similar(image)) {\n        fdest = fopen(outfile, \""wb\"");\n\n        if (!fdest) {\n            fprintf(stderr, \""ERROR -> failed to open %s for writing\\n\"", outfile);\n            return fails;\n        }\n        two = (prec > 8);\n        triple = (ncomp > 2);\n        wr = (int)image->comps[0].w;\n        hr = (int)image->comps[0].h;\n        max = (1 << prec) - 1;\n        has_alpha = (ncomp == 4 || ncomp == 2);\n\n        red = image->comps[0].data;\n\n        if (triple) {\n            green = image->comps[1].data;\n            blue = image->comps[2].data;\n        } else {\n            green = blue = NULL;\n        }\n\n        if (has_alpha) {\n            const char *tt = (triple ? \""RGB_ALPHA\"" : \""GRAYSCALE_ALPHA\"");\n\n            fprintf(fdest, \""P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\""\n                    \""MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\"", opj_version(),\n                    wr, hr, ncomp, max, tt);\n            alpha = image->comps[ncomp - 1].data;\n            adjustA = (image->comps[ncomp - 1].sgnd ?\n                       1 << (image->comps[ncomp - 1].prec - 1) : 0);\n        } else {\n            fprintf(fdest, \""P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\"",\n                    opj_version(), wr, hr, max);\n            adjustA = 0;\n        }\n        adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n\n        if (triple) {\n            adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n        } else {\n            adjustG = adjustB = 0;\n        }\n\n        for (i = 0; i < wr * hr; ++i) {\n            if (two) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (triple) {\n                    v = *green + adjustG;\n                    ++green;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                    v =  *blue + adjustB;\n                    ++blue;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                }/* if(triple) */\n\n                if (has_alpha) {\n                    v = *alpha + adjustA;\n                    ++alpha;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n                continue;\n\n            }   /* if(two) */\n\n            /* prec <= 8: */\n            v = *red++;\n            if (v > 255) {\n                v = 255;\n            } else if (v < 0) {\n                v = 0;\n            }\n\n            fprintf(fdest, \""%c\"", (unsigned char)v);\n            if (triple) {\n                v = *green++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n                v = *blue++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n            if (has_alpha) {\n                v = *alpha++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n        }   /* for(i */\n\n        fclose(fdest);\n        return 0;\n    }\n\n    /* YUV or MONO: */\n\n    if (image->numcomps > ncomp) {\n        fprintf(stderr, \""WARNING -> [PGM file] Only the first component\\n\"");\n        fprintf(stderr, \""           is written to the file\\n\"");\n    }\n    destname = (char*)malloc(strlen(outfile) + 8);\n    if (destname == NULL) {\n        fprintf(stderr, \""imagetopnm: memory out\\n\"");\n        return 1;\n    }\n    for (compno = 0; compno < ncomp; compno++) {\n        if (ncomp > 1) {\n            /*sprintf(destname, \""%d.%s\"", compno, outfile);*/\n            const size_t olen = strlen(outfile);\n            const size_t dotpos = olen - 4;\n\n            strncpy(destname, outfile, dotpos);\n            sprintf(destname + dotpos, \""_%u.pgm\"", compno);\n        } else {\n            sprintf(destname, \""%s\"", outfile);\n        }\n\n        fdest = fopen(destname, \""wb\"");\n        if (!fdest) {\n            fprintf(stderr, \""ERROR -> failed to open %s for writing\\n\"", destname);\n            free(destname);\n            return 1;\n        }\n        wr = (int)image->comps[compno].w;\n        hr = (int)image->comps[compno].h;\n        prec = (int)image->comps[compno].prec;\n        max = (1 << prec) - 1;\n\n        fprintf(fdest, \""P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\"",\n                opj_version(), wr, hr, max);\n\n        red = image->comps[compno].data;\n        adjustR =\n            (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);\n\n        if (prec > 8) {\n            for (i = 0; i < wr * hr; i++) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (has_alpha) {\n                    v = *alpha++;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n            }/* for(i */\n        } else { /* prec <= 8 */\n            for (i = 0; i < wr * hr; ++i) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n        }\n        fclose(fdest);\n    } /* for (compno */\n    free(destname);\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""pgxtovolume"", ""file_path"": ""src/bin/jpwl/convert.c"", ""func_code"": ""opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters)\n{\n\n    FILE *f = NULL;\n    int w, h, prec;\n    unsigned long offset;\n    int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;\n\n    OPJ_COLOR_SPACE color_space;\n    opj_volume_cmptparm_t cmptparm; /* maximum of 1 component */\n    opj_volume_t * volume = NULL;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n    char temp[32];\n    opj_volume_comp_t *comp = NULL;\n\n    DIR *dirp;\n    struct dirent *direntp;\n\n    char *tmp = NULL, *tmp2 = NULL,\n          *point = NULL, *pgx = NULL;\n    char tmpdirpath[MAX_PATH];\n    char dirpath[MAX_PATH];\n    char pattern[MAX_PATH];\n    char pgxfiles[MAX_SLICES][MAX_PATH];\n    int pgxslicepos[MAX_SLICES];\n    char tmpno[3];\n\n    numcomps = 1;\n    color_space = CLRSPC_GRAY;\n    sliceno = 0;\n    maxvalue = 0;\n    memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));\n    memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* Separaci\u00f3n del caso de un \u00fanico slice frente al de muchos */\n    if ((tmp = strrchr(relpath, '-')) == NULL) {\n        /*fprintf(stdout,\""[INFO] A volume of only one slice....\\n\"");*/\n        sliceno = 1;\n        maxslice = 1;\n        strcpy(pgxfiles[0], relpath);\n\n    } else {\n        /*Fetch only the path */\n        strcpy(tmpdirpath, relpath);\n        if ((tmp = strrchr(tmpdirpath, '/')) != NULL) {\n            tmp++;\n            *tmp = '\\0';\n            strcpy(dirpath, tmpdirpath);\n        } else {\n            strcpy(dirpath, \""./\"");\n        }\n\n        /*Fetch the pattern of the volume slices*/\n        if ((tmp = strrchr(relpath, '/')) != NULL) {\n            tmp++;\n        } else {\n            tmp = relpath;\n        }\n        if ((tmp2 = strrchr(tmp, '-')) != NULL) {\n            *tmp2 = '\\0';\n        } else {\n            fprintf(stdout, \""[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\"", tmp,\n                    relpath);\n            return NULL;\n        }\n        strcpy(pattern, tmp);\n\n        dirp = opendir(dirpath);\n        if (dirp == NULL) {\n            fprintf(stdout,\n                    \""[ERROR] Infile must be a .pgx file or a directory that contain pgx files\"");\n            return NULL;\n        }\n\n        /*Read all .pgx files of directory */\n        while ((direntp = readdir(dirp)) != NULL) {\n            /* Found a directory, but ignore . and .. */\n            if (strcmp(\"".\"", direntp->d_name) == 0 || strcmp(\""..\"", direntp->d_name) == 0) {\n                continue;\n            }\n\n            if (((pgx = strstr(direntp->d_name, pattern)) != NULL) &&\n                    ((tmp2 = strstr(direntp->d_name, \"".pgx\"")) != NULL)) {\n\n                strcpy(tmp, dirpath);\n                tmp = strcat(tmp, direntp->d_name);\n\n                /*Obtenemos el index de la secuencia de slices*/\n                if ((tmp2 = strpbrk(direntp->d_name, \""0123456789\"")) == NULL) {\n                    continue;\n                }\n                i = 0;\n                while (tmp2 != NULL) {\n                    tmpno[i++] = *tmp2;\n                    point = tmp2;\n                    tmp2 = strpbrk(tmp2 + 1, \""0123456789\"");\n                }\n                tmpno[i] = '\\0';\n\n                /*Comprobamos que no estamos leyendo algo raro como pattern.jp3d*/\n                if ((point = strpbrk(point, \"".\"")) == NULL) {\n                    break;\n                }\n                /*Slicepos --> index de slice; Sliceno --> no de slices hasta el momento*/\n                slicepos = atoi(tmpno);\n                pgxslicepos[sliceno] = slicepos - 1;\n                sliceno++;\n                if (slicepos > maxslice) {\n                    maxslice = slicepos;\n                }\n\n                /*Colocamos el slices en su posicion correspondiente*/\n                strcpy(pgxfiles[slicepos - 1], tmp);\n            }\n        }\n\n    }/* else if pattern*.pgx */\n\n    if (!sliceno) {\n        fprintf(stdout,\n                \""[ERROR] No slices with this pattern founded !! Please check input volume name\\n\"");\n        return NULL;\n    }\n    /*if ( maxslice != sliceno) {\n        fprintf(stdout,\""[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\\n\"");\n        return NULL;\n    }*/\n\n    for (s = 0; s < sliceno; s++) {\n        int pos = maxslice == sliceno ? s : pgxslicepos[s];\n        f = fopen(pgxfiles[pos], \""rb\"");\n        if (!f) {\n            fprintf(stdout, \""[ERROR] Failed to open %s for reading !\\n\"", pgxfiles[s]);\n            return NULL;\n        }\n        fprintf(stdout, \""[INFO] Loading %s \\n\"", pgxfiles[pos]);\n\n        fseek(f, 0, SEEK_SET);\n        fscanf(f, \""PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\"", temp, &endian1,\n               &endian2, signtmp, &prec, temp, &w, temp, &h);\n\n        i = 0;\n        sign = '+';\n        while (signtmp[i] != '\\0') {\n            if (signtmp[i] == '-') {\n                sign = '-';\n            }\n            i++;\n        }\n\n        fgetc(f);\n        if (endian1 == 'M' && endian2 == 'L') {\n            cmptparm.bigendian = 1;\n        } else if (endian2 == 'M' && endian1 == 'L') {\n            cmptparm.bigendian = 0;\n        } else {\n            fprintf(stdout, \""[ERROR] Bad pgx header, please check input file\\n\"");\n            fclose(f);\n            return NULL;\n        }\n\n        if (s == 0) {\n            /* initialize volume component */\n\n            cmptparm.x0 = parameters->volume_offset_x0;\n            cmptparm.y0 = parameters->volume_offset_y0;\n            cmptparm.z0 = parameters->volume_offset_z0;\n            cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 :\n                         cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;\n            cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 :\n                         cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;\n            cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 :\n                         cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;\n\n            if (sign == '-') {\n                cmptparm.sgnd = 1;\n            } else {\n                cmptparm.sgnd = 0;\n            }\n            cmptparm.prec = prec;\n            cmptparm.bpp = prec;\n            cmptparm.dcoffset = parameters->dcoffset;\n            cmptparm.dx = parameters->subsampling_dx;\n            cmptparm.dy = parameters->subsampling_dy;\n            cmptparm.dz = parameters->subsampling_dz;\n\n            /* create the volume */\n            volume = opj_volume_create(numcomps, &cmptparm, color_space);\n            if (!volume) {\n                fclose(f);\n                return NULL;\n            }\n            /* set volume offset and reference grid */\n            volume->x0 = cmptparm.x0;\n            volume->y0 = cmptparm.y0;\n            volume->z0 = cmptparm.z0;\n            volume->x1 = cmptparm.w;\n            volume->y1 = cmptparm.h;\n            volume->z1 = cmptparm.l;\n\n            /* set volume data :only one component, that is a volume*/\n            comp = &volume->comps[0];\n\n        }/*if sliceno==1*/\n\n        offset = w * h * s;\n\n        for (i = 0; i < w * h; i++) {\n            int v;\n            if (comp->prec <= 8) {\n                if (!comp->sgnd) {\n                    v = readuchar(f);\n                } else {\n                    v = (char) readuchar(f);\n                }\n            } else if (comp->prec <= 16) {\n                if (!comp->sgnd) {\n                    v = readushort(f, cmptparm.bigendian);\n                } else {\n                    v = (short) readushort(f, cmptparm.bigendian);\n                }\n            } else {\n                if (!comp->sgnd) {\n                    v = readuint(f, cmptparm.bigendian);\n                } else {\n                    v = (int) readuint(f, cmptparm.bigendian);\n                }\n            }\n            if (v > maxvalue) {\n                maxvalue = v;\n            }\n            comp->data[i + offset] = v;\n\n        }\n        fclose(f);\n    } /* for s --> sliceno*/\n    comp->bpp = int_floorlog2(maxvalue) + 1;\n    if (sliceno != 1) {\n        closedir(dirp);\n    }\n    /*dump_volume(stdout, volume);*/\n    return volume;\n}""}, {""func_name"": ""pgxtovolume"", ""file_path"": ""src/bin/jp3d/convert.c"", ""func_code"": ""opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters)\n{\n\n    FILE *f = NULL;\n    int w, h, prec;\n    unsigned long offset;\n    int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;\n\n    OPJ_COLOR_SPACE color_space;\n    opj_volume_cmptparm_t cmptparm; /* maximum of 1 component */\n    opj_volume_t * volume = NULL;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n    char temp[32];\n    opj_volume_comp_t *comp = NULL;\n\n    DIR *dirp;\n    struct dirent *direntp;\n\n    char *tmp = NULL, *tmp2 = NULL,\n          *point = NULL, *pgx = NULL;\n    char tmpdirpath[MAX_PATH];\n    char dirpath[MAX_PATH];\n    char pattern[MAX_PATH];\n    char pgxfiles[MAX_SLICES][MAX_PATH];\n    int pgxslicepos[MAX_SLICES];\n    char tmpno[3];\n\n    numcomps = 1;\n    color_space = CLRSPC_GRAY;\n    sliceno = 0;\n    maxvalue = 0;\n    memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));\n    memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* Separaci\u00f3n del caso de un \u00fanico slice frente al de muchos */\n    if ((tmp = strrchr(relpath, '-')) == NULL) {\n        /*fprintf(stdout,\""[INFO] A volume of only one slice....\\n\"");*/\n        sliceno = 1;\n        maxslice = 1;\n        strcpy(pgxfiles[0], relpath);\n\n    } else {\n        /*Fetch only the path */\n        strcpy(tmpdirpath, relpath);\n        if ((tmp = strrchr(tmpdirpath, '/')) != NULL) {\n            tmp++;\n            *tmp = '\\0';\n            strcpy(dirpath, tmpdirpath);\n        } else {\n            strcpy(dirpath, \""./\"");\n        }\n\n        /*Fetch the pattern of the volume slices*/\n        if ((tmp = strrchr(relpath, '/')) != NULL) {\n            tmp++;\n        } else {\n            tmp = relpath;\n        }\n        if ((tmp2 = strrchr(tmp, '-')) != NULL) {\n            *tmp2 = '\\0';\n        } else {\n            fprintf(stdout, \""[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\"", tmp,\n                    relpath);\n            return NULL;\n        }\n        strcpy(pattern, tmp);\n\n        dirp = opendir(dirpath);\n        if (dirp == NULL) {\n            fprintf(stdout,\n                    \""[ERROR] Infile must be a .pgx file or a directory that contain pgx files\"");\n            return NULL;\n        }\n\n        /*Read all .pgx files of directory */\n        while ((direntp = readdir(dirp)) != NULL) {\n            /* Found a directory, but ignore . and .. */\n            if (strcmp(\"".\"", direntp->d_name) == 0 || strcmp(\""..\"", direntp->d_name) == 0) {\n                continue;\n            }\n\n            if (((pgx = strstr(direntp->d_name, pattern)) != NULL) &&\n                    ((tmp2 = strstr(direntp->d_name, \"".pgx\"")) != NULL)) {\n\n                strcpy(tmp, dirpath);\n                tmp = strcat(tmp, direntp->d_name);\n\n                /*Obtenemos el index de la secuencia de slices*/\n                if ((tmp2 = strpbrk(direntp->d_name, \""0123456789\"")) == NULL) {\n                    continue;\n                }\n                i = 0;\n                while (tmp2 != NULL) {\n                    tmpno[i++] = *tmp2;\n                    point = tmp2;\n                    tmp2 = strpbrk(tmp2 + 1, \""0123456789\"");\n                }\n                tmpno[i] = '\\0';\n\n                /*Comprobamos que no estamos leyendo algo raro como pattern.jp3d*/\n                if ((point = strpbrk(point, \"".\"")) == NULL) {\n                    break;\n                }\n                /*Slicepos --> index de slice; Sliceno --> no de slices hasta el momento*/\n                slicepos = atoi(tmpno);\n                pgxslicepos[sliceno] = slicepos - 1;\n                sliceno++;\n                if (slicepos > maxslice) {\n                    maxslice = slicepos;\n                }\n\n                /*Colocamos el slices en su posicion correspondiente*/\n                strcpy(pgxfiles[slicepos - 1], tmp);\n            }\n        }\n\n    }/* else if pattern*.pgx */\n\n    if (!sliceno) {\n        fprintf(stdout,\n                \""[ERROR] No slices with this pattern founded !! Please check input volume name\\n\"");\n        return NULL;\n    }\n    /*if ( maxslice != sliceno) {\n        fprintf(stdout,\""[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\\n\"");\n        return NULL;\n    }*/\n\n    for (s = 0; s < sliceno; s++) {\n        int pos = maxslice == sliceno ? s : pgxslicepos[s];\n        f = fopen(pgxfiles[pos], \""rb\"");\n        if (!f) {\n            fprintf(stdout, \""[ERROR] Failed to open %s for reading !\\n\"", pgxfiles[s]);\n            return NULL;\n        }\n        fprintf(stdout, \""[INFO] Loading %s \\n\"", pgxfiles[pos]);\n\n        fseek(f, 0, SEEK_SET);\n        fscanf(f, \""PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\"", temp, &endian1,\n               &endian2, signtmp, &prec, temp, &w, temp, &h);\n\n        i = 0;\n        sign = '+';\n        while (signtmp[i] != '\\0') {\n            if (signtmp[i] == '-') {\n                sign = '-';\n            }\n            i++;\n        }\n\n        fgetc(f);\n        if (endian1 == 'M' && endian2 == 'L') {\n            cmptparm.bigendian = 1;\n        } else if (endian2 == 'M' && endian1 == 'L') {\n            cmptparm.bigendian = 0;\n        } else {\n            fprintf(stdout, \""[ERROR] Bad pgx header, please check input file\\n\"");\n            fclose(f);\n            return NULL;\n        }\n\n        if (s == 0) {\n            /* initialize volume component */\n\n            cmptparm.x0 = parameters->volume_offset_x0;\n            cmptparm.y0 = parameters->volume_offset_y0;\n            cmptparm.z0 = parameters->volume_offset_z0;\n            cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 :\n                         cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;\n            cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 :\n                         cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;\n            cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 :\n                         cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;\n\n            if (sign == '-') {\n                cmptparm.sgnd = 1;\n            } else {\n                cmptparm.sgnd = 0;\n            }\n            cmptparm.prec = prec;\n            cmptparm.bpp = prec;\n            cmptparm.dcoffset = parameters->dcoffset;\n            cmptparm.dx = parameters->subsampling_dx;\n            cmptparm.dy = parameters->subsampling_dy;\n            cmptparm.dz = parameters->subsampling_dz;\n\n            /* create the volume */\n            volume = opj_volume_create(numcomps, &cmptparm, color_space);\n            if (!volume) {\n                fclose(f);\n                return NULL;\n            }\n            /* set volume offset and reference grid */\n            volume->x0 = cmptparm.x0;\n            volume->y0 = cmptparm.y0;\n            volume->z0 = cmptparm.z0;\n            volume->x1 = cmptparm.w;\n            volume->y1 = cmptparm.h;\n            volume->z1 = cmptparm.l;\n\n            /* set volume data :only one component, that is a volume*/\n            comp = &volume->comps[0];\n\n        }/*if sliceno==1*/\n\n        offset = w * h * s;\n\n        for (i = 0; i < w * h; i++) {\n            int v;\n            if (comp->prec <= 8) {\n                if (!comp->sgnd) {\n                    v = readuchar(f);\n                } else {\n                    v = (char) readuchar(f);\n                }\n            } else if (comp->prec <= 16) {\n                if (!comp->sgnd) {\n                    v = readushort(f, cmptparm.bigendian);\n                } else {\n                    v = (short) readushort(f, cmptparm.bigendian);\n                }\n            } else {\n                if (!comp->sgnd) {\n                    v = readuint(f, cmptparm.bigendian);\n                } else {\n                    v = (int) readuint(f, cmptparm.bigendian);\n                }\n            }\n            if (v > maxvalue) {\n                maxvalue = v;\n            }\n            comp->data[i + offset] = v;\n\n        }\n        fclose(f);\n    } /* for s --> sliceno*/\n    comp->bpp = int_floorlog2(maxvalue) + 1;\n    if (sliceno != 1) {\n        closedir(dirp);\n    }\n    /*dump_volume(stdout, volume);*/\n    return volume;\n}""}, {""func_name"": ""imagetopnm"", ""file_path"": ""src/bin/jp2/convert.c"", ""func_code"": ""int imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n{\n    int *red, *green, *blue, *alpha;\n    int wr, hr, max;\n    int i;\n    unsigned int compno, ncomp;\n    int adjustR, adjustG, adjustB, adjustA;\n    int fails, two, want_gray, has_alpha, triple;\n    int prec, v;\n    FILE *fdest = NULL;\n    const char *tmp = outfile;\n    char *destname;\n\n    alpha = NULL;\n\n    if ((prec = (int)image->comps[0].prec) > 16) {\n        fprintf(stderr, \""%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\""\n                \""\\n\\t: refused.\\n\"", __FILE__, __LINE__, prec);\n        return 1;\n    }\n    two = has_alpha = 0;\n    fails = 1;\n    ncomp = image->numcomps;\n\n    while (*tmp) {\n        ++tmp;\n    }\n    tmp -= 2;\n    want_gray = (*tmp == 'g' || *tmp == 'G');\n    ncomp = image->numcomps;\n\n    if (want_gray) {\n        ncomp = 1;\n    }\n\n    if ((force_split == 0) && ncomp >= 2 &&\n            are_comps_similar(image)) {\n        fdest = fopen(outfile, \""wb\"");\n\n        if (!fdest) {\n            fprintf(stderr, \""ERROR -> failed to open %s for writing\\n\"", outfile);\n            return fails;\n        }\n        two = (prec > 8);\n        triple = (ncomp > 2);\n        wr = (int)image->comps[0].w;\n        hr = (int)image->comps[0].h;\n        max = (1 << prec) - 1;\n        has_alpha = (ncomp == 4 || ncomp == 2);\n\n        red = image->comps[0].data;\n\n        if (triple) {\n            green = image->comps[1].data;\n            blue = image->comps[2].data;\n        } else {\n            green = blue = NULL;\n        }\n\n        if (has_alpha) {\n            const char *tt = (triple ? \""RGB_ALPHA\"" : \""GRAYSCALE_ALPHA\"");\n\n            fprintf(fdest, \""P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\""\n                    \""MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\"", opj_version(),\n                    wr, hr, ncomp, max, tt);\n            alpha = image->comps[ncomp - 1].data;\n            adjustA = (image->comps[ncomp - 1].sgnd ?\n                       1 << (image->comps[ncomp - 1].prec - 1) : 0);\n        } else {\n            fprintf(fdest, \""P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\"",\n                    opj_version(), wr, hr, max);\n            adjustA = 0;\n        }\n        adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n\n        if (triple) {\n            adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n        } else {\n            adjustG = adjustB = 0;\n        }\n\n        for (i = 0; i < wr * hr; ++i) {\n            if (two) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (triple) {\n                    v = *green + adjustG;\n                    ++green;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                    v =  *blue + adjustB;\n                    ++blue;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                }/* if(triple) */\n\n                if (has_alpha) {\n                    v = *alpha + adjustA;\n                    ++alpha;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n                continue;\n\n            }   /* if(two) */\n\n            /* prec <= 8: */\n            v = *red++;\n            if (v > 255) {\n                v = 255;\n            } else if (v < 0) {\n                v = 0;\n            }\n\n            fprintf(fdest, \""%c\"", (unsigned char)v);\n            if (triple) {\n                v = *green++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n                v = *blue++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n            if (has_alpha) {\n                v = *alpha++;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n        }   /* for(i */\n\n        fclose(fdest);\n        return 0;\n    }\n\n    /* YUV or MONO: */\n\n    if (image->numcomps > ncomp) {\n        fprintf(stderr, \""WARNING -> [PGM file] Only the first component\\n\"");\n        fprintf(stderr, \""           is written to the file\\n\"");\n    }\n    destname = (char*)malloc(strlen(outfile) + 8);\n    if (destname == NULL) {\n        fprintf(stderr, \""imagetopnm: memory out\\n\"");\n        return 1;\n    }\n    for (compno = 0; compno < ncomp; compno++) {\n        if (ncomp > 1) {\n            /*sprintf(destname, \""%d.%s\"", compno, outfile);*/\n            const size_t olen = strlen(outfile);\n            const size_t dotpos = olen - 4;\n\n            strncpy(destname, outfile, dotpos);\n            sprintf(destname + dotpos, \""_%u.pgm\"", compno);\n        } else {\n            sprintf(destname, \""%s\"", outfile);\n        }\n\n        fdest = fopen(destname, \""wb\"");\n        if (!fdest) {\n            fprintf(stderr, \""ERROR -> failed to open %s for writing\\n\"", destname);\n            free(destname);\n            return 1;\n        }\n        wr = (int)image->comps[compno].w;\n        hr = (int)image->comps[compno].h;\n        prec = (int)image->comps[compno].prec;\n        max = (1 << prec) - 1;\n\n        fprintf(fdest, \""P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\"",\n                opj_version(), wr, hr, max);\n\n        red = image->comps[compno].data;\n        if (!red) {\n            fclose(fdest);\n            continue;\n        }\n\n        adjustR =\n            (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);\n\n        if (prec > 8) {\n            for (i = 0; i < wr * hr; i++) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 65535) {\n                    v = 65535;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                /* netpbm: */\n                fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n\n                if (has_alpha) {\n                    v = *alpha++;\n                    if (v > 65535) {\n                        v = 65535;\n                    } else if (v < 0) {\n                        v = 0;\n                    }\n\n                    /* netpbm: */\n                    fprintf(fdest, \""%c%c\"", (unsigned char)(v >> 8), (unsigned char)v);\n                }\n            }/* for(i */\n        } else { /* prec <= 8 */\n            for (i = 0; i < wr * hr; ++i) {\n                v = *red + adjustR;\n                ++red;\n                if (v > 255) {\n                    v = 255;\n                } else if (v < 0) {\n                    v = 0;\n                }\n\n                fprintf(fdest, \""%c\"", (unsigned char)v);\n            }\n        }\n        fclose(fdest);\n    } /* for (compno */\n    free(destname);\n\n    return 0;\n}""}]","{""value"": 2}","[{""source"": ""value_info(file:convert.c, value:temp)"", ""result"": {""value_trace"": [{""full_code"": ""temp[32]"", ""line"": 1334, ""func_name"": ""pgxtoimage<duplicate>0""}, {""full_code"": ""temp = (unsigned char)(curr >> 8)"", ""line"": 3118, ""func_name"": ""imagetoraw<duplicate>0""}, {""full_code"": ""temp = (unsigned char) curr"", ""line"": 3124, ""func_name"": ""imagetoraw<duplicate>0""}, {""full_code"": ""temp = (unsigned char)(curr >> 8)"", ""line"": 3141, ""func_name"": ""imagetoraw<duplicate>0""}, {""full_code"": ""temp = (unsigned char) curr"", ""line"": 3147, ""func_name"": ""imagetoraw<duplicate>0""}], ""struct_var"": ""temp"", ""struct_type"": ""char[32]"", ""struct_definition"": null}}, {""source"": ""value_info(file:convert.c, value:temp)"", ""result"": {""value_trace"": [{""full_code"": ""temp[32]"", ""line"": 174, ""func_name"": ""pgxtovolume""}], ""struct_var"": ""temp"", ""struct_type"": ""char[32]"", ""struct_definition"": null}}]","In src/bin/jpwl/convert.c:298 and src/bin/jp3d/convert.c:298, the fscanf format string uses %[\\t] without a length modifier to read into 'temp' (char[32]). This allows input exceeding 32 bytes to overflow the stack buffer. The patch adds %31[\\t] to restrict input length.",0.95,./github/other_context/CVE-2017-17479
56,CVE-2017-18120,CWE-415,c_cpp,"A double-free bug in the read_gif function in gifread.c in gifsicle 1.90 allows a remote attacker to cause a denial-of-service attack or unspecified other impact via a maliciously crafted file, because last_name is mishandled, a different vulnerability than CVE-2017-1000421.",https://github.com/kohler/gifsicle/commit/118a46090c50829dc543179019e6140e1235f909,"gif_read: Set last_name = NULL unconditionally.\n\nWith a non-malicious GIF, last_name is set to NULL when a name\nextension is followed by an image. Reported in #117, via\nDebian, via a KAIST fuzzing program.",1,"[{""func_name"": ""read_gif"", ""file_path"": ""src/gifread.c"", ""func_code"": ""static Gif_Stream *\nread_gif(Gif_Reader *grr, int read_flags,\n\t const char* landmark, Gif_ReadErrorHandler handler)\n{\n  Gif_Stream *gfs;\n  Gif_Image *gfi;\n  Gif_Context gfc;\n  int unknown_block_type = 0;\n\n  if (gifgetc(grr) != 'G' ||\n      gifgetc(grr) != 'I' ||\n      gifgetc(grr) != 'F')\n    return 0;\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n\n  gfs = Gif_NewStream();\n  gfi = Gif_NewImage();\n\n  gfc.stream = gfs;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = handler;\n  gfc.gfi = gfi;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)\n    goto done;\n  gfs->landmark = landmark;\n\n  GIF_DEBUG((\""\\nGIF \""));\n  if (!read_logical_screen_descriptor(gfs, grr))\n    goto done;\n  GIF_DEBUG((\""logscrdesc \""));\n\n  while (!gifeof(grr)) {\n\n    uint8_t block = gifgetbyte(grr);\n\n    switch (block) {\n\n     case ',': /* image block */\n      GIF_DEBUG((\""imageread %d \"", gfs->nimages));\n\n      gfi->identifier = last_name;\n      last_name = 0;\n      if (!Gif_AddImage(gfs, gfi))\n          goto done;\n      else if (!read_image(grr, &gfc, gfi, read_flags)) {\n          Gif_RemoveImage(gfs, gfs->nimages - 1);\n          gfi = 0;\n          goto done;\n      }\n\n      gfc.gfi = gfi = Gif_NewImage();\n      if (!gfi)\n          goto done;\n      break;\n\n     case ';': /* terminator */\n      GIF_DEBUG((\""term\\n\""));\n      goto done;\n\n     case '!': /* extension */\n      block = gifgetbyte(grr);\n      GIF_DEBUG((\""ext(0x%02X) \"", block));\n      switch (block) {\n\n       case 0xF9:\n\tread_graphic_control_extension(&gfc, gfi, grr);\n\tbreak;\n\n       case 0xCE:\n\tlast_name = suck_data(last_name, 0, grr);\n\tbreak;\n\n       case 0xFE:\n\tif (!read_comment_extension(gfi, grr)) goto done;\n\tbreak;\n\n       case 0xFF:\n\tread_application_extension(&gfc, grr);\n\tbreak;\n\n       default:\n        read_unknown_extension(&gfc, grr, block, 0, 0);\n\tbreak;\n\n      }\n      break;\n\n     default:\n       if (!unknown_block_type) {\n\t char buf[256];\n\t sprintf(buf, \""unknown block type %d at file offset %u\"", block, grr->pos - 1);\n\t gif_read_error(&gfc, 1, buf);\n\t unknown_block_type = 1;\n       }\n       break;\n\n    }\n\n  }\n\n done:\n\n  /* Move comments and extensions after last image into stream. */\n  if (gfs && gfi) {\n      Gif_Extension* gfex;\n      gfs->end_comment = gfi->comment;\n      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n  Gif_DeleteArray(gfc.suffix);\n  Gif_DeleteArray(gfc.length);\n  gfc.gfi = 0;\n\n  if (gfs)\n    gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \""trailing garbage after GIF ignored\"");\n  /* finally, export last message */\n  gif_read_error(&gfc, -1, 0);\n\n  return gfs;\n}"", ""target"": 0}]","[{""func_name"": ""read_gif"", ""file_path"": ""src/gifread.c"", ""func_code"": ""static Gif_Stream *\nread_gif(Gif_Reader *grr, int read_flags,\n\t const char* landmark, Gif_ReadErrorHandler handler)\n{\n  Gif_Stream *gfs;\n  Gif_Image *gfi;\n  Gif_Context gfc;\n  int unknown_block_type = 0;\n\n  if (gifgetc(grr) != 'G' ||\n      gifgetc(grr) != 'I' ||\n      gifgetc(grr) != 'F')\n    return 0;\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n\n  gfs = Gif_NewStream();\n  gfi = Gif_NewImage();\n\n  gfc.stream = gfs;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = handler;\n  gfc.gfi = gfi;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)\n    goto done;\n  gfs->landmark = landmark;\n\n  GIF_DEBUG((\""\\nGIF \""));\n  if (!read_logical_screen_descriptor(gfs, grr))\n    goto done;\n  GIF_DEBUG((\""logscrdesc \""));\n\n  while (!gifeof(grr)) {\n\n    uint8_t block = gifgetbyte(grr);\n\n    switch (block) {\n\n     case ',': /* image block */\n      GIF_DEBUG((\""imageread %d \"", gfs->nimages));\n\n      gfi->identifier = last_name;\n      last_name = 0;\n      if (!Gif_AddImage(gfs, gfi))\n          goto done;\n      else if (!read_image(grr, &gfc, gfi, read_flags)) {\n          Gif_RemoveImage(gfs, gfs->nimages - 1);\n          gfi = 0;\n          goto done;\n      }\n\n      gfc.gfi = gfi = Gif_NewImage();\n      if (!gfi)\n          goto done;\n      break;\n\n     case ';': /* terminator */\n      GIF_DEBUG((\""term\\n\""));\n      goto done;\n\n     case '!': /* extension */\n      block = gifgetbyte(grr);\n      GIF_DEBUG((\""ext(0x%02X) \"", block));\n      switch (block) {\n\n       case 0xF9:\n\tread_graphic_control_extension(&gfc, gfi, grr);\n\tbreak;\n\n       case 0xCE:\n\tlast_name = suck_data(last_name, 0, grr);\n\tbreak;\n\n       case 0xFE:\n\tif (!read_comment_extension(gfi, grr)) goto done;\n\tbreak;\n\n       case 0xFF:\n\tread_application_extension(&gfc, grr);\n\tbreak;\n\n       default:\n        read_unknown_extension(&gfc, grr, block, 0, 0);\n\tbreak;\n\n      }\n      break;\n\n     default:\n       if (!unknown_block_type) {\n\t char buf[256];\n\t sprintf(buf, \""unknown block type %d at file offset %u\"", block, grr->pos - 1);\n\t gif_read_error(&gfc, 1, buf);\n\t unknown_block_type = 1;\n       }\n       break;\n\n    }\n\n  }\n\n done:\n\n  /* Move comments and extensions after last image into stream. */\n  if (gfs && gfi) {\n      Gif_Extension* gfex;\n      gfs->end_comment = gfi->comment;\n      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n  Gif_DeleteArray(gfc.suffix);\n  Gif_DeleteArray(gfc.length);\n  gfc.gfi = 0;\n  last_name = 0;\n\n  if (gfs)\n    gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \""trailing garbage after GIF ignored\"");\n  /* finally, export last message */\n  gif_read_error(&gfc, -1, 0);\n\n  return gfs;\n}""}]","{""code"": 1, ""value"": 1, ""function"": 1}","[{""source"": ""code_info(file:gifread.c, lines:890-910)"", ""result"": ""      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n  Gif_DeleteArray(gfc.suffix);\n  Gif_DeleteArray(gfc.length);\n  gfc.gfi = 0;\n\n  if (gfs)\n    gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \""trailing garbage after GIF ignored\"");\n  /* finally, export last message */\n""}, {""source"": ""value_info(file:gifread.c, value:last_name)"", ""result"": {""value_trace"": [{""full_code"": ""last_name = 0"", ""line"": 825, ""func_name"": ""read_gif""}, {""full_code"": ""last_name = suck_data(last_name, 0, grr)"", ""line"": 853, ""func_name"": ""read_gif""}], ""struct_var"": ""last_name"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""func_info(func:read_gif)"", ""result"": [{""code"": ""static Gif_Stream *\nread_gif(Gif_Reader *grr, int read_flags,\n\t const char* landmark, Gif_ReadErrorHandler handler)\n{\n  Gif_Stream *gfs;\n  Gif_Image *gfi;\n  Gif_Context gfc;\n  int unknown_block_type = 0;\n\n  if (gifgetc(grr) != 'G' ||\n      gifgetc(grr) != 'I' ||\n      gifgetc(grr) != 'F')\n    return 0;\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n\n  gfs = Gif_NewStream();\n  gfi = Gif_NewImage();\n\n  gfc.stream = gfs;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = handler;\n  gfc.gfi = gfi;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)\n    goto done;\n  gfs->landmark = landmark;\n\n  GIF_DEBUG((\""\\nGIF \""));\n  if (!read_logical_screen_descriptor(gfs, grr))\n    goto done;\n  GIF_DEBUG((\""logscrdesc \""));\n\n  while (!gifeof(grr)) {\n\n    uint8_t block = gifgetbyte(grr);\n\n    switch (block) {\n\n     case ',': /* image block */\n      GIF_DEBUG((\""imageread %d \"", gfs->nimages));\n\n      gfi->identifier = last_name;\n      last_name = 0;\n      if (!Gif_AddImage(gfs, gfi))\n          goto done;\n      else if (!read_image(grr, &gfc, gfi, read_flags)) {\n          Gif_RemoveImage(gfs, gfs->nimages - 1);\n          gfi = 0;\n          goto done;\n      }\n\n      gfc.gfi = gfi = Gif_NewImage();\n      if (!gfi)\n          goto done;\n      break;\n\n     case ';': /* terminator */\n      GIF_DEBUG((\""term\\n\""));\n      goto done;\n\n     case '!': /* extension */\n      block = gifgetbyte(grr);\n      GIF_DEBUG((\""ext(0x%02X) \"", block));\n      switch (block) {\n\n       case 0xF9:\n\tread_graphic_control_extension(&gfc, gfi, grr);\n\tbreak;\n\n       case 0xCE:\n\tlast_name = suck_data(last_name, 0, grr);\n\tbreak;\n\n       case 0xFE:\n\tif (!read_comment_extension(gfi, grr)) goto done;\n\tbreak;\n\n       case 0xFF:\n\tread_application_extension(&gfc, grr);\n\tbreak;\n\n       default:\n        read_unknown_extension(&gfc, grr, block, 0, 0);\n\tbreak;\n\n      }\n      break;\n\n     default:\n       if (!unknown_block_type) {\n\t char buf[256];\n\t sprintf(buf, \""unknown block type %d at file offset %u\"", block, grr->pos - 1);\n\t gif_read_error(&gfc, 1, buf);\n\t unknown_block_type = 1;\n       }\n       break;\n\n    }\n\n  }\n\n done:\n\n  /* Move comments and extensions after last image into stream. */\n  if (gfs && gfi) {\n      Gif_Extension* gfex;\n      gfs->end_comment = gfi->comment;\n      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n  Gif_DeleteArray(gfc.suffix);\n  Gif_DeleteArray(gfc.length);\n  gfc.gfi = 0;\n\n  if (gfs)\n    gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \""trailing garbage after GIF ignored\"");\n  /* finally, export last message */\n  gif_read_error(&gfc, -1, 0);\n\n  return gfs;\n}\n"", ""start_line"": 778, ""end_line"": 914, ""full_name"": ""read_gif"", ""file_path"": ""src/gifread.c""}]}]","src/gifread.c:891 assigns 'gfi->identifier = last_name;' followed by 'last_name = 0;' when processing an image block. If this nullification is skipped (e.g., in error paths or when subsequent extensions reuse 'last_name'), 'Gif_DeleteArray(last_name)' in src/gifread.c:899 frees the memory again after it was already freed by 'Gif_DeleteImage(gfi)' in src/gifread.c:897. The patch adds 'last_name = 0;' before the 'Gif_DeleteArray' call to ensure 'last_name' is NULL, preventing double-free.",0.95,./github/other_context/CVE-2017-18120
57,CVE-2017-17439,CWE-476,c_cpp,"In Heimdal through 7.4, remote unauthenticated attackers are able to crash the KDC by sending a crafted UDP packet containing empty data fields for client name or realm. The parser would unconditionally dereference NULL pointers in that case, leading to a segmentation fault. This is related to the _kdc_as_rep function in kdc/kerberos5.c and the der_length_visible_string function in lib/asn1/der_length.c.",https://github.com/heimdal/heimdal/commit/1a6a6e462dc2ac6111f9e02c6852ddec4849b887,Security: Avoid NULL structure pointer member dereference\n\nThis can happen in the error path when processing malformed AS\nrequests with a NULL client name.  Bug originally introduced on\nFri Feb 13 09:26:01 2015 +0100 in commit:\n\n    a873e21d7c06f22943a90a41dc733ae76799390d\n\n    kdc: base _kdc_fast_mk_error() on krb5_mk_error_ext()\n\nOriginal patch by Jeffrey Altman <jaltman@secure-endpoints.com>,1,"[{""func_name"": ""_kdc_as_rep"", ""file_path"": ""kdc/kerberos5.c"", ""func_code"": ""krb5_error_code\n_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \""FAST unwrap request from %s failed: %d\"", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No server in request\"");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed server name from %s\"", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No client in request\"");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed client name from %s\"", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \""AS-REQ %s from %s for %s\"",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \""Anonymous ticket w/o anonymous flag\"");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\""Request for a anonymous ticket with non \""\n\t\t\""anonymous client name: %s\"", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""client %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \""WRONG_REALM - %s -> %s\"",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""target %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""Client (%s) from %s has no common enctypes with KDC \""\n\t\t\""to use for the session key\"",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \""Looking for %s pa-data -- %s\"", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\""%s pre-authentication succeeded -- %s\"",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\"");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \""Doesn't have a client key available\"");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \""Bad KDC options\"");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \""Ticket may not be forwardable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \""Ticket may not be proxiable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \""Ticket may not be postdate\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \""Bad address list in requested\"");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    if (ret)\n\tgoto out;\n    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if (ret)\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \""Client have no reply key\"");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \""AS-REQ\"", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \""add_enc_pa_rep failed: %s: %d\"", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \""Reply packet too large\"");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}"", ""target"": 0}]","[{""func_name"": ""_kdc_as_rep"", ""file_path"": ""kdc/kerberos5.c"", ""func_code"": ""krb5_error_code\n_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \""FAST unwrap request from %s failed: %d\"", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No server in request\"");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed server name from %s\"", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No client in request\"");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed client name from %s\"", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \""AS-REQ %s from %s for %s\"",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \""Anonymous ticket w/o anonymous flag\"");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\""Request for a anonymous ticket with non \""\n\t\t\""anonymous client name: %s\"", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""client %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \""WRONG_REALM - %s -> %s\"",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""target %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""Client (%s) from %s has no common enctypes with KDC \""\n\t\t\""to use for the session key\"",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \""Looking for %s pa-data -- %s\"", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\""%s pre-authentication succeeded -- %s\"",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\"");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \""Doesn't have a client key available\"");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \""Bad KDC options\"");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \""Ticket may not be forwardable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \""Ticket may not be proxiable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \""Ticket may not be postdate\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \""Bad address list in requested\"");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n\t\n\tstart = r->et.authtime = kdc_time;\n\n\tif(f.postdated && req->req_body.from){\n\t    ALLOC(r->et.starttime);\n\t    start = *r->et.starttime = *req->req_body.from;\n\t    r->et.flags.invalid = 1;\n\t    r->et.flags.postdated = 1; /* XXX ??? */\n\t}\n\t_kdc_fix_time(&b->till);\n\tt = *b->till;\n\n\t/* be careful not overflowing */\n\n\tif(r->client->entry.max_life)\n\t    t = start + min(t - start, *r->client->entry.max_life);\n\tif(r->server->entry.max_life)\n\t    t = start + min(t - start, *r->server->entry.max_life);\n#if 0\n\tt = min(t, start + realm->max_life);\n#endif\n\tr->et.endtime = t;\n\tif(f.renewable_ok && r->et.endtime < *b->till){\n\t    f.renewable = 1;\n\t    if(b->rtime == NULL){\n\t\tALLOC(b->rtime);\n\t\t*b->rtime = 0;\n\t    }\n\t    if(*b->rtime < *b->till)\n\t\t*b->rtime = *b->till;\n\t}\n\tif(f.renewable && b->rtime){\n\t    t = *b->rtime;\n\t    if(t == 0)\n\t\tt = MAX_TIME;\n\t    if(r->client->entry.max_renew)\n\t\tt = start + min(t - start, *r->client->entry.max_renew);\n\t    if(r->server->entry.max_renew)\n\t\tt = start + min(t - start, *r->server->entry.max_renew);\n#if 0\n\t    t = min(t, start + realm->max_renew);\n#endif\n\t    ALLOC(r->et.renew_till);\n\t    *r->et.renew_till = t;\n\t    r->et.flags.renewable = 1;\n\t}\n    }\n\n    if (_kdc_is_anon_request(b))\n\tr->et.flags.anonymous = 1;\n\n    if(b->addresses){\n\tALLOC(r->et.caddr);\n\tcopy_HostAddresses(b->addresses, r->et.caddr);\n    }\n\n    r->et.transited.tr_type = DOMAIN_X500_COMPRESS;\n    krb5_data_zero(&r->et.transited.contents);\n\n    /* The MIT ASN.1 library (obviously) doesn't tell lengths encoded\n     * as 0 and as 0x80 (meaning indefinite length) apart, and is thus\n     * incapable of correctly decoding SEQUENCE OF's of zero length.\n     *\n     * To fix this, always send at least one no-op last_req\n     *\n     * If there's a pw_end or valid_end we will use that,\n     * otherwise just a dummy lr.\n     */\n    r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));\n    if (r->ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    r->ek.last_req.len = 0;\n    if (r->client->entry.pw_end\n\t&& (config->kdc_warn_pwexpire == 0\n\t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->client->entry.valid_end) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;\n\t++r->ek.last_req.len;\n    }\n    if (r->ek.last_req.len == 0) {\n\tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;\n\tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;\n\t++r->ek.last_req.len;\n    }\n    r->ek.nonce = b->nonce;\n    if (r->client->entry.valid_end || r->client->entry.pw_end) {\n\tALLOC(r->ek.key_expiration);\n\tif (r->client->entry.valid_end) {\n\t    if (r->client->entry.pw_end)\n\t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,\n\t\t\t\t\t *r->client->entry.pw_end);\n\t    else\n\t\t*r->ek.key_expiration = *r->client->entry.valid_end;\n\t} else\n\t    *r->ek.key_expiration = *r->client->entry.pw_end;\n    } else\n\tr->ek.key_expiration = NULL;\n    r->ek.flags = r->et.flags;\n    r->ek.authtime = r->et.authtime;\n    if (r->et.starttime) {\n\tALLOC(r->ek.starttime);\n\t*r->ek.starttime = *r->et.starttime;\n    }\n    r->ek.endtime = r->et.endtime;\n    if (r->et.renew_till) {\n\tALLOC(r->ek.renew_till);\n\t*r->ek.renew_till = *r->et.renew_till;\n    }\n    ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);\n    if (ret)\n\tgoto out;\n    ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);\n    if (ret)\n\tgoto out;\n    if(r->et.caddr){\n\tALLOC(r->ek.caddr);\n\tcopy_HostAddresses(r->et.caddr, r->ek.caddr);\n    }\n\n    /*\n     * Check and session and reply keys\n     */\n\n    if (r->session_key.keytype == ETYPE_NULL) {\n\tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->reply_key.keytype == ETYPE_NULL) {\n\t_kdc_set_e_text(r, \""Client have no reply key\"");\n\tret = KRB5KDC_ERR_CLIENT_NOTYET;\n\tgoto out;\n    }\n\n    ret = copy_EncryptionKey(&r->session_key, &r->et.key);\n    if (ret)\n\tgoto out;\n\n    ret = copy_EncryptionKey(&r->session_key, &r->ek.key);\n    if (ret)\n\tgoto out;\n\n    if (r->outpadata.len) {\n\n\tALLOC(rep.padata);\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(&r->outpadata, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    /* Add the PAC */\n    if (send_pac_p(context, req)) {\n\tgenerate_pac(r, skey);\n    }\n\n    _kdc_log_timestamp(context, config, \""AS-REQ\"", r->et.authtime, r->et.starttime,\n\t\t       r->et.endtime, r->et.renew_till);\n\n    /* do this as the last thing since this signs the EncTicketPart */\n    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t  config,\n\t\t\t\t  r->server,\n\t\t\t\t  setype,\n\t\t\t\t  r->client->entry.principal,\n\t\t\t\t  NULL,\n\t\t\t\t  NULL,\n\t\t\t\t  &r->et);\n    if (ret)\n\tgoto out;\n\n    log_as_req(context, config, r->reply_key.keytype, setype, b);\n\n    /*\n     * We always say we support FAST/enc-pa-rep\n     */\n\n    r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;\n\n    /*\n     * Add REQ_ENC_PA_REP if client supports it\n     */\n\n    i = 0;\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);\n    if (pa) {\n\n\tret = add_enc_pa_rep(r);\n\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \""add_enc_pa_rep failed: %s: %d\"", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \""Reply packet too large\"");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->name : NULL,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->realm : NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n    }\n    if (r->client_name) {\n\tfree(r->client_name);\n\tr->client_name = NULL;\n    }\n    if (r->server_princ){\n\tkrb5_free_principal(context, r->server_princ);\n\tr->server_princ = NULL;\n    }\n    if (r->server_name) {\n\tfree(r->server_name);\n\tr->server_name = NULL;\n    }\n    if (r->client)\n\t_kdc_free_ent(context, r->client);\n    if (r->server)\n\t_kdc_free_ent(context, r->server);\n    if (r->armor_crypto) {\n\tkrb5_crypto_destroy(r->context, r->armor_crypto);\n\tr->armor_crypto = NULL;\n    }\n    krb5_free_keyblock_contents(r->context, &r->reply_key);\n    krb5_free_keyblock_contents(r->context, &r->session_key);\n    return ret;\n}""}]","{""code"": 8, ""value"": 8, ""function"": 1}","[{""source"": ""code_info(file:kerberos5.c, lines:145-155)"", ""result"": ""    if (use_strongest_session_key) {\n\n\t/*\n\t * Pick the strongest key that the KDC, target service, and\n\t * client all support, using the local cryptosystem enctype\n\t * list in strongest-to-weakest order to drive the search.\n\t *\n\t * This is not what RFC4120 says to do, but it encourages\n\t * adoption of stronger enctypes.  This doesn't play well with\n\t * clients that have multiple Kerberos client implementations\n\t * available with different supported enctype lists.\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:2200-2260)"", ""result"": ""\tif (ret) {\n\t    const char *msg = krb5_get_error_message(r->context, ret);\n\t    _kdc_r_log(r, 0, \""add_enc_pa_rep failed: %s: %d\"", msg, ret);\n\t    krb5_free_error_message(r->context, msg);\n\t    goto out;\n\t}\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_encode_reply(context, config,\n\t\t\t    r->armor_crypto, req->req_body.nonce,\n\t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,\n\t\t\t    &skey->key, r->client->entry.kvno,\n\t\t\t    &r->reply_key, 0, &r->e_text, reply);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Check if message too large\n     */\n    if (datagram_reply && reply->length > config->max_datagram_reply_length) {\n\tkrb5_data_free(reply);\n\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \""Reply packet too large\"");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n\n    if (error_method.len)\n\tfree_METHOD_DATA(&error_method);\n    if (r->outpadata.len)\n\tfree_METHOD_DATA(&r->outpadata);\n    if (r->client_princ) {\n\tkrb5_free_principal(context, r->client_princ);\n\tr->client_princ = NULL;\n""}, {""source"": ""func_info(file:der_length.c, func:der_length_visible_string)"", ""result"": [{""code"": ""size_t\nder_length_visible_string (const heim_visible_string *data)\n{\n    return strlen(*data);\n}"", ""start_line"": 242, ""end_line"": 246, ""full_name"": ""der_length_visible_string"", ""file_path"": ""lib/asn1/der_length.c""}]}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:100-220)"", ""result"": ""}\n\n\n/*\n * Detect if `key' is the using the the precomputed `default_salt'.\n */\n\nstatic krb5_boolean\nis_default_salt_p(const krb5_salt *default_salt, const Key *key)\n{\n    if (key->salt == NULL)\n\treturn TRUE;\n    if (default_salt->salttype != key->salt->type)\n\treturn FALSE;\n    if (krb5_data_cmp(&default_salt->saltvalue, &key->salt->salt))\n\treturn FALSE;\n    return TRUE;\n}\n\n/*\n * return the first appropriate key of `princ' in `ret_key'.  Look for\n * all the etypes in (`etypes', `len'), stopping as soon as we find\n * one, but preferring one that has default salt.\n */\n\nkrb5_error_code\n_kdc_find_etype(krb5_context context, krb5_boolean use_strongest_session_key,\n\t\tkrb5_boolean is_preauth, hdb_entry_ex *princ,\n\t\tkrb5_enctype *etypes, unsigned len,\n\t\tkrb5_enctype *ret_enctype, Key **ret_key)\n{\n    krb5_error_code ret;\n    krb5_salt def_salt;\n    krb5_enctype enctype = (krb5_enctype)ETYPE_NULL;\n    const krb5_enctype *p;\n    Key *key = NULL;\n    int i, k;\n\n    /* We'll want to avoid keys with v4 salted keys in the pre-auth case... */\n    ret = krb5_get_pw_salt(context, princ->entry.principal, &def_salt);\n    if (ret)\n\treturn ret;\n\n    ret = KRB5KDC_ERR_ETYPE_NOSUPP;\n\n    if (use_strongest_session_key) {\n\n\t/*\n\t * Pick the strongest key that the KDC, target service, and\n\t * client all support, using the local cryptosystem enctype\n\t * list in strongest-to-weakest order to drive the search.\n\t *\n\t * This is not what RFC4120 says to do, but it encourages\n\t * adoption of stronger enctypes.  This doesn't play well with\n\t * clients that have multiple Kerberos client implementations\n\t * available with different supported enctype lists.\n\t */\n\n\t/* drive the search with local supported enctypes list */\n\tp = krb5_kerberos_enctypes(context);\n\tfor (i = 0;\n\t    p[i] != (krb5_enctype)ETYPE_NULL && enctype == (krb5_enctype)ETYPE_NULL;\n\t    i++) {\n\t    if (krb5_enctype_valid(context, p[i]) != 0 &&\n                !_kdc_is_weak_exception(princ->entry.principal, p[i]))\n\t\tcontinue;\n\n\t    /* check that the client supports it too */\n\t    for (k = 0; k < len && enctype == (krb5_enctype)ETYPE_NULL; k++) {\n\n\t\tif (p[i] != etypes[k])\n\t\t    continue;\n\n                /* check target princ support */\n\t\tkey = NULL;\n\t\twhile (hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\t     p[i], &key) == 0) {\n\t\t    if (key->key.keyvalue.length == 0) {\n\t\t\tret = KRB5KDC_ERR_NULL_KEY;\n\t\t\tcontinue;\n\t\t    }\n\t\t    enctype = p[i];\n\t\t    ret = 0;\n\t\t    if (is_preauth && ret_key != NULL &&\n\t\t\t!is_default_salt_p(&def_salt, key))\n\t\t\tcontinue;\n\t\t}\n\t    }\n\t}\n    } else {\n\t/*\n\t * Pick the first key from the client's enctype list that is\n\t * supported by the cryptosystem and by the given principal.\n\t *\n\t * RFC4120 says we SHOULD pick the first _strong_ key from the\n\t * client's list... not the first key...  If the admin disallows\n\t * weak enctypes in krb5.conf and selects this key selection\n\t * algorithm, then we get exactly what RFC4120 says.\n\t */\n\tfor(i = 0; ret != 0 && i < len; i++) {\n\n\t    if (krb5_enctype_valid(context, etypes[i]) != 0 &&\n\t\t!_kdc_is_weak_exception(princ->entry.principal, etypes[i]))\n\t\tcontinue;\n\n\t    key = NULL;\n\t    while (ret != 0 &&\n                   hdb_next_enctype2key(context, &princ->entry, NULL,\n\t\t\t\t\tetypes[i], &key) == 0) {\n\t\tif (key->key.keyvalue.length == 0) {\n\t\t    ret = KRB5KDC_ERR_NULL_KEY;\n\t\t    continue;\n\t\t}\n                enctype = etypes[i];\n\t\tret = 0;\n\t\tif (is_preauth && ret_key != NULL &&\n\t\t    !is_default_salt_p(&def_salt, key))\n\t\t    continue;\n\t    }\n\t}\n    }\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:1000-1200)"", ""result"": ""    case ETYPE_DES_CBC_MD5:\n    case ETYPE_DES3_CBC_SHA1:\n    case ETYPE_ARCFOUR_HMAC_MD5:\n    case ETYPE_ARCFOUR_HMAC_MD5_56:\n    /*\n     * The following three is \""old\"" windows enctypes and is needed for\n     * windows 2000 hosts.\n     */\n    case ETYPE_ARCFOUR_MD4:\n    case ETYPE_ARCFOUR_HMAC_OLD:\n    case ETYPE_ARCFOUR_HMAC_OLD_EXP:\n\treturn 1;\n    default:\n\treturn 0;\n    }\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\nmake_etype_info_entry(krb5_context context, ETYPE_INFO_ENTRY *ent, Key *key)\n{\n    ent->etype = key->key.keytype;\n    if(key->salt){\n#if 0\n\tALLOC(ent->salttype);\n\n\tif(key->salt->type == hdb_pw_salt)\n\t    *ent->salttype = 0; /* or 1? or NULL? */\n\telse if(key->salt->type == hdb_afs3_salt)\n\t    *ent->salttype = 2;\n\telse {\n\t    kdc_log(context, config, 0, \""unknown salt-type: %d\"",\n\t\t    key->salt->type);\n\t    return KRB5KRB_ERR_GENERIC;\n\t}\n\t/* according to `the specs', we can't send a salt if\n\t   we have AFS3 salted key, but that requires that you\n\t   *know* what cell you are using (e.g by assuming\n\t   that the cell is the same as the realm in lower\n\t   case) */\n#elif 0\n\tALLOC(ent->salttype);\n\t*ent->salttype = key->salt->type;\n#else\n\t/*\n\t * We shouldn't sent salttype since it is incompatible with the\n\t * specification and it breaks windows clients.  The afs\n\t * salting problem is solved by using KRB5-PADATA-AFS3-SALT\n\t * implemented in Heimdal 0.7 and later.\n\t */\n\tent->salttype = NULL;\n#endif\n\tkrb5_copy_data(context, &key->salt->salt,\n\t\t       &ent->salt);\n    } else {\n\t/* we return no salt type at all, as that should indicate\n\t * the default salt type and make everybody happy.  some\n\t * systems (like w2k) dislike being told the salt type\n\t * here. */\n\n\tent->salttype = NULL;\n\tent->salt = NULL;\n    }\n    return 0;\n}\n\nstatic krb5_error_code\nget_pa_etype_info(krb5_context context,\n\t\t  krb5_kdc_configuration *config,\n\t\t  METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO pa;\n    unsigned char *buf;\n    size_t len;\n\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info_entry(context, &pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}\n\n/*\n *\n */\n\nextern int _krb5_AES_SHA1_string_to_default_iterator;\nextern int _krb5_AES_SHA2_string_to_default_iterator;\n\nstatic krb5_error_code\nmake_s2kparams(int value, size_t len, krb5_data **ps2kparams)\n{\n    krb5_data *s2kparams;\n    krb5_error_code ret;\n\n    ALLOC(s2kparams);\n    if (s2kparams == NULL)\n\treturn ENOMEM;\n    ret = krb5_data_alloc(s2kparams, len);\n    if (ret) {\n\tfree(s2kparams);\n\treturn ret;\n    }\n    _krb5_put_int(s2kparams->data, value, len);\n    *ps2kparams = s2kparams;\n    return 0;\n}\n\nstatic krb5_error_code\nmake_etype_info2_entry(ETYPE_INFO2_ENTRY *ent, Key *key)\n{\n    krb5_error_code ret;\n\n    ent->etype = key->key.keytype;\n    if(key->salt) {\n\tALLOC(ent->salt);\n\tif (ent->salt == NULL)\n\t    return ENOMEM;\n\t*ent->salt = malloc(key->salt->salt.length + 1);\n\tif (*ent->salt == NULL) {\n\t    free(ent->salt);\n\t    ent->salt = NULL;\n\t    return ENOMEM;\n\t}\n\tmemcpy(*ent->salt, key->salt->salt.data, key->salt->salt.length);\n\t(*ent->salt)[key->salt->salt.length] = '\\0';\n    } else\n\tent->salt = NULL;\n\n    ent->s2kparams = NULL;\n\n    switch (key->key.keytype) {\n    case ETYPE_AES128_CTS_HMAC_SHA1_96:\n    case ETYPE_AES256_CTS_HMAC_SHA1_96:\n\tret = make_s2kparams(_krb5_AES_SHA1_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case KRB5_ENCTYPE_AES128_CTS_HMAC_SHA256_128:\n    case KRB5_ENCTYPE_AES256_CTS_HMAC_SHA384_192:\n\tret = make_s2kparams(_krb5_AES_SHA2_string_to_default_iterator,\n\t\t\t     4, &ent->s2kparams);\n\tbreak;\n    case ETYPE_DES_CBC_CRC:\n    case ETYPE_DES_CBC_MD4:\n    case ETYPE_DES_CBC_MD5:\n\t/* Check if this was a AFS3 salted key */\n\tif(key->salt && key->salt->type == hdb_afs3_salt)\n\t    ret = make_s2kparams(1, 1, &ent->s2kparams);\n\telse\n\t    ret = 0;\n\tbreak;\n    default:\n\tret = 0;\n\tbreak;\n    }\n    return ret;\n}\n\n/*\n * Return an ETYPE-INFO2. Enctypes are storted the same way as in the\n * database (client supported enctypes first, then the unsupported\n * enctypes).\n */\n\nstatic krb5_error_code\nget_pa_etype_info2(krb5_context context,\n\t\t   krb5_kdc_configuration *config,\n\t\t   METHOD_DATA *md, Key *ckey)\n{\n    krb5_error_code ret = 0;\n    ETYPE_INFO2 pa;\n    unsigned char *buf;\n    size_t len;\n\n    pa.len = 1;\n    pa.val = calloc(1, sizeof(pa.val[0]));\n    if(pa.val == NULL)\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:1200-1400)"", ""result"": ""    if(pa.val == NULL)\n\treturn ENOMEM;\n\n    ret = make_etype_info2_entry(&pa.val[0], ckey);\n    if (ret) {\n\tfree_ETYPE_INFO2(&pa);\n\treturn ret;\n    }\n\n    ASN1_MALLOC_ENCODE(ETYPE_INFO2, buf, len, &pa, &len, ret);\n    free_ETYPE_INFO2(&pa);\n    if(ret)\n\treturn ret;\n    ret = realloc_method_data(md);\n    if(ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    md->val[md->len - 1].padata_type = KRB5_PADATA_ETYPE_INFO2;\n    md->val[md->len - 1].padata_value.length = len;\n    md->val[md->len - 1].padata_value.data = buf;\n    return 0;\n}\n\n/*\n *\n */\n\nstatic void\nlog_as_req(krb5_context context,\n\t   krb5_kdc_configuration *config,\n\t   krb5_enctype cetype,\n\t   krb5_enctype setype,\n\t   const KDC_REQ_BODY *b)\n{\n    krb5_error_code ret;\n    struct rk_strpool *p;\n    char *str;\n    size_t i;\n\n    p = rk_strpoolprintf(NULL, \""%s\"", \""Client supported enctypes: \"");\n\n    for (i = 0; i < b->etype.len; i++) {\n\tret = krb5_enctype_to_string(context, b->etype.val[i], &str);\n\tif (ret == 0) {\n\t    p = rk_strpoolprintf(p, \""%s\"", str);\n\t    free(str);\n\t} else\n\t    p = rk_strpoolprintf(p, \""%d\"", b->etype.val[i]);\n\tif (p && i + 1 < b->etype.len)\n\t    p = rk_strpoolprintf(p, \"", \"");\n\tif (p == NULL) {\n\t    kdc_log(context, config, 0, \""out of memory\"");\n\t    return;\n\t}\n    }\n    if (p == NULL)\n\tp = rk_strpoolprintf(p, \""no encryption types\"");\n\n    {\n\tchar *cet;\n\tchar *set;\n\n\tret = krb5_enctype_to_string(context, cetype, &cet);\n\tif(ret == 0) {\n\t    ret = krb5_enctype_to_string(context, setype, &set);\n\t    if (ret == 0) {\n\t\tp = rk_strpoolprintf(p, \"", using %s/%s\"", cet, set);\n\t\tfree(set);\n\t    }\n\t    free(cet);\n\t}\n\tif (ret != 0)\n\t    p = rk_strpoolprintf(p, \"", using enctypes %d/%d\"",\n\t\t\t\t cetype, setype);\n    }\n\n    str = rk_strpoolcollect(p);\n    kdc_log(context, config, 0, \""%s\"", str);\n    free(str);\n\n    {\n\tchar fixedstr[128];\n\tunparse_flags(KDCOptions2int(b->kdc_options), asn1_KDCOptions_units(),\n\t\t      fixedstr, sizeof(fixedstr));\n\tif(*fixedstr)\n\t    kdc_log(context, config, 0, \""Requested flags: %s\"", fixedstr);\n    }\n}\n\n/*\n * verify the flags on `client' and `server', returning 0\n * if they are OK and generating an error messages and returning\n * and error code otherwise.\n */\n\nkrb5_error_code\nkdc_check_flags(krb5_context context,\n\t\tkrb5_kdc_configuration *config,\n\t\thdb_entry_ex *client_ex, const char *client_name,\n\t\thdb_entry_ex *server_ex, const char *server_name,\n\t\tkrb5_boolean is_as_req)\n{\n    if(client_ex != NULL) {\n\thdb_entry *client = &client_ex->entry;\n\n\t/* check client */\n\tif (client->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \""Client (%s) is locked out\"", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \""Client (%s) has invalid bit set\"", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!client->flags.client){\n\t    kdc_log(context, config, 0,\n\t\t    \""Principal may not act as client -- %s\"", client_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (client->valid_start && *client->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *client->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Client not yet valid until %s -- %s\"",\n\t\t    starttime_str, client_name);\n\t    return KRB5KDC_ERR_CLIENT_NOTYET;\n\t}\n\n\tif (client->valid_end && *client->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *client->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Client expired at %s -- %s\"",\n\t\t    endtime_str, client_name);\n\t    return KRB5KDC_ERR_NAME_EXP;\n\t}\n\n\tif (client->flags.require_pwchange &&\n\t    (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    kdc_log(context, config, 0,\n\t\t    \""Client's key must be changed -- %s\"", client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n\n\tif (client->pw_end && *client->pw_end < kdc_time\n\t    && (server_ex == NULL || !server_ex->entry.flags.change_pw)) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *client->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Client's key has expired at %s -- %s\"",\n\t\t    pwend_str, client_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n\n    /* check server */\n\n    if (server_ex != NULL) {\n\thdb_entry *server = &server_ex->entry;\n\n\tif (server->flags.locked_out) {\n\t    kdc_log(context, config, 0,\n\t\t    \""Client server locked out -- %s\"", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\tif (server->flags.invalid) {\n\t    kdc_log(context, config, 0,\n\t\t    \""Server has invalid flag set -- %s\"", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!server->flags.server){\n\t    kdc_log(context, config, 0,\n\t\t    \""Principal may not act as server -- %s\"", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif(!is_as_req && server->flags.initial) {\n\t    kdc_log(context, config, 0,\n\t\t    \""AS-REQ is required for server -- %s\"", server_name);\n\t    return KRB5KDC_ERR_POLICY;\n\t}\n\n\tif (server->valid_start && *server->valid_start > kdc_time) {\n\t    char starttime_str[100];\n\t    krb5_format_time(context, *server->valid_start,\n\t\t\t     starttime_str, sizeof(starttime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Server not yet valid until %s -- %s\"",\n\t\t    starttime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_NOTYET;\n\t}\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:1400-1600)"", ""result"": ""\t}\n\n\tif (server->valid_end && *server->valid_end < kdc_time) {\n\t    char endtime_str[100];\n\t    krb5_format_time(context, *server->valid_end,\n\t\t\t     endtime_str, sizeof(endtime_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Server expired at %s -- %s\"",\n\t\t    endtime_str, server_name);\n\t    return KRB5KDC_ERR_SERVICE_EXP;\n\t}\n\n\tif (server->pw_end && *server->pw_end < kdc_time) {\n\t    char pwend_str[100];\n\t    krb5_format_time(context, *server->pw_end,\n\t\t\t     pwend_str, sizeof(pwend_str), TRUE);\n\t    kdc_log(context, config, 0,\n\t\t    \""Server's key has expired at -- %s\"",\n\t\t    pwend_str, server_name);\n\t    return KRB5KDC_ERR_KEY_EXPIRED;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Return TRUE if `from' is part of `addresses' taking into consideration\n * the configuration variables that tells us how strict we should be about\n * these checks\n */\n\nkrb5_boolean\n_kdc_check_addresses(krb5_context context,\n\t\t     krb5_kdc_configuration *config,\n\t\t     HostAddresses *addresses, const struct sockaddr *from)\n{\n    krb5_error_code ret;\n    krb5_address addr;\n    krb5_boolean result;\n    krb5_boolean only_netbios = TRUE;\n    size_t i;\n\n    if(config->check_ticket_addresses == 0)\n\treturn TRUE;\n\n    if(addresses == NULL)\n\treturn config->allow_null_ticket_addresses;\n\n    for (i = 0; i < addresses->len; ++i) {\n\tif (addresses->val[i].addr_type != KRB5_ADDRESS_NETBIOS) {\n\t    only_netbios = FALSE;\n\t}\n    }\n\n    /* Windows sends it's netbios name, which I can only assume is\n     * used for the 'allowed workstations' check.  This is painful,\n     * but we still want to check IP addresses if they happen to be\n     * present.\n     */\n\n    if(only_netbios)\n\treturn config->allow_null_ticket_addresses;\n\n    ret = krb5_sockaddr2address (context, from, &addr);\n    if(ret)\n\treturn FALSE;\n\n    result = krb5_address_search(context, &addr, addresses);\n    krb5_free_address (context, &addr);\n    return result;\n}\n\n/*\n *\n */\n\nstatic krb5_boolean\nsend_pac_p(krb5_context context, KDC_REQ *req)\n{\n    krb5_error_code ret;\n    PA_PAC_REQUEST pacreq;\n    const PA_DATA *pa;\n    int i = 0;\n\n    pa = _kdc_find_padata(req, &i, KRB5_PADATA_PA_PAC_REQUEST);\n    if (pa == NULL)\n\treturn TRUE;\n\n    ret = decode_PA_PAC_REQUEST(pa->padata_value.data,\n\t\t\t\tpa->padata_value.length,\n\t\t\t\t&pacreq,\n\t\t\t\tNULL);\n    if (ret)\n\treturn TRUE;\n    i = pacreq.include_pac;\n    free_PA_PAC_REQUEST(&pacreq);\n    if (i == 0)\n\treturn FALSE;\n    return TRUE;\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ngenerate_pac(kdc_request_t r, Key *skey)\n{\n    krb5_error_code ret;\n    krb5_pac p = NULL;\n    krb5_data data;\n\n    ret = _kdc_pac_generate(r->context, r->client, &p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \""PAC generation failed for -- %s\"",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    if (p == NULL)\n\treturn 0;\n\n    ret = _krb5_pac_sign(r->context, p, r->et.authtime,\n\t\t\t r->client->entry.principal,\n\t\t\t &skey->key, /* Server key */\n\t\t\t &skey->key, /* FIXME: should be krbtgt key */\n\t\t\t &data);\n    krb5_pac_free(r->context, p);\n    if (ret) {\n\t_kdc_r_log(r, 0, \""PAC signing failed for -- %s\"",\n\t\t   r->client_name);\n\treturn ret;\n    }\n    \n    ret = _kdc_tkt_add_if_relevant_ad(r->context, &r->et,\n\t\t\t\t      KRB5_AUTHDATA_WIN2K_PAC,\n\t\t\t\t      &data);\n    krb5_data_free(&data);\n\n    return ret;\n}\n\n/*\n *\n */\n\nkrb5_boolean\n_kdc_is_anonymous(krb5_context context, krb5_principal principal)\n{\n    if ((principal->name.name_type != KRB5_NT_WELLKNOWN &&\n\t principal->name.name_type != KRB5_NT_UNKNOWN) ||\n\tprincipal->name.name_string.len != 2 ||\n\tstrcmp(principal->name.name_string.val[0], KRB5_WELLKNOWN_NAME) != 0 ||\n\tstrcmp(principal->name.name_string.val[1], KRB5_ANON_NAME) != 0)\n\treturn 0;\n    return 1;\n}\n\nstatic int\nrequire_preauth_p(kdc_request_t r)\n{\n    return r->config->require_preauth\n\t|| r->client->entry.flags.require_preauth\n\t|| r->server->entry.flags.require_preauth;\n}\n\n\n/*\n *\n */\n\nstatic krb5_error_code\nadd_enc_pa_rep(kdc_request_t r)\n{\n    krb5_error_code ret;\n    krb5_crypto crypto;\n    Checksum checksum;\n    krb5_data cdata;\n    size_t len;\n\n    ret = krb5_crypto_init(r->context, &r->reply_key, 0, &crypto);\n    if (ret)\n\treturn ret;\n\n    ret = krb5_create_checksum(r->context, crypto,\n\t\t\t       KRB5_KU_AS_REQ, 0,\n\t\t\t       r->request.data, r->request.length,\n\t\t\t       &checksum);\n    krb5_crypto_destroy(r->context, crypto);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(Checksum, cdata.data, cdata.length,\n\t\t       &checksum, &len, ret);\n    free_Checksum(&checksum);\n    if (ret)\n\treturn ret;\n    heim_assert(cdata.length == len, \""ASN.1 internal error\"");\n\n    if (r->ek.encrypted_pa_data == NULL) {\n\tALLOC(r->ek.encrypted_pa_data);\n\tif (r->ek.encrypted_pa_data == NULL)\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:1600-1800)"", ""result"": ""\tif (r->ek.encrypted_pa_data == NULL)\n\t    return ENOMEM;\n    }\n    ret = krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t  KRB5_PADATA_REQ_ENC_PA_REP, cdata.data, cdata.length);\n    if (ret)\n\treturn ret;\n    \n    return krb5_padata_add(r->context, r->ek.encrypted_pa_data,\n\t\t\t   KRB5_PADATA_FX_FAST, NULL, 0);\n}\n\n/*\n *\n */\n\nkrb5_error_code\n_kdc_as_rep(kdc_request_t r,\n\t    krb5_data *reply,\n\t    const char *from,\n\t    struct sockaddr *from_addr,\n\t    int datagram_reply)\n{\n    krb5_context context = r->context;\n    krb5_kdc_configuration *config = r->config;\n    KDC_REQ *req = &r->req;\n    KDC_REQ_BODY *b = NULL;\n    AS_REP rep;\n    KDCOptions f;\n    krb5_enctype setype;\n    krb5_error_code ret = 0;\n    Key *skey;\n    int found_pa = 0;\n    int i, flags = HDB_F_FOR_AS_REQ;\n    METHOD_DATA error_method;\n    const PA_DATA *pa;\n\n    memset(&rep, 0, sizeof(rep));\n    error_method.len = 0;\n    error_method.val = NULL;\n\n    /*\n     * Look for FAST armor and unwrap\n     */\n    ret = _kdc_fast_unwrap_request(r);\n    if (ret) {\n\t_kdc_r_log(r, 0, \""FAST unwrap request from %s failed: %d\"", from, ret);\n\tgoto out;\n    }\n\n    b = &req->req_body;\n    f = b->kdc_options;\n\n    if (f.canonicalize)\n\tflags |= HDB_F_CANON;\n\n    if(b->sname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No server in request\"");\n    } else{\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->server_princ,\n\t\t\t\t\t\t  *(b->sname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret == 0)\n\t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed server name from %s\"", from);\n\tgoto out;\n    }\n    if(b->cname == NULL){\n\tret = KRB5KRB_ERR_GENERIC;\n\t_kdc_set_e_text(r, \""No client in request\"");\n    } else {\n\tret = _krb5_principalname2krb5_principal (context,\n\t\t\t\t\t\t  &r->client_princ,\n\t\t\t\t\t\t  *(b->cname),\n\t\t\t\t\t\t  b->realm);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_unparse_name(context, r->client_princ, &r->client_name);\n    }\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""AS-REQ malformed client name from %s\"", from);\n\tgoto out;\n    }\n\n    kdc_log(context, config, 0, \""AS-REQ %s from %s for %s\"",\n\t    r->client_name, from, r->server_name);\n\n    /*\n     *\n     */\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tif (!_kdc_is_anon_request(b)) {\n\t    kdc_log(context, config, 0, \""Anonymous ticket w/o anonymous flag\"");\n\t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\t    goto out;\n\t}\n    } else if (_kdc_is_anon_request(b)) {\n\tkdc_log(context, config, 0,\n\t\t\""Request for a anonymous ticket with non \""\n\t\t\""anonymous client name: %s\"", r->client_name);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     *\n     */\n\n    ret = _kdc_db_fetch(context, config, r->client_princ,\n\t\t\tHDB_F_GET_CLIENT | flags, NULL,\n\t\t\t&r->clientdb, &r->client);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""client %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->client_name);\n\tgoto out;\n    } else if (ret == HDB_ERR_WRONG_REALM) {\n\tchar *fixed_client_name = NULL;\n\n\tret = krb5_unparse_name(context, r->client->entry.principal,\n\t\t\t\t&fixed_client_name);\n\tif (ret) {\n\t    goto out;\n\t}\n\n\tkdc_log(context, config, 0, \""WRONG_REALM - %s -> %s\"",\n\t\tr->client_name, fixed_client_name);\n\tfree(fixed_client_name);\n\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t KRB5_KDC_ERR_WRONG_REALM,\n\t\t\t\t NULL,\n\t\t\t\t r->server_princ,\n\t\t\t\t NULL,\n\t\t\t\t &r->client->entry.principal->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->client_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n    ret = _kdc_db_fetch(context, config, r->server_princ,\n\t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,\n\t\t\tNULL, NULL, &r->server);\n    if(ret == HDB_ERR_NOT_FOUND_HERE) {\n\tkdc_log(context, config, 5, \""target %s does not have secrets at this KDC, need to proxy\"",\n\t\tr->server_name);\n\tgoto out;\n    } else if(ret){\n\tconst char *msg = krb5_get_error_message(context, ret);\n\tkdc_log(context, config, 0, \""UNKNOWN -- %s: %s\"", r->server_name, msg);\n\tkrb5_free_error_message(context, msg);\n\tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n\tgoto out;\n    }\n\n    /*\n     * Select a session enctype from the list of the crypto system\n     * supported enctypes that is supported by the client and is one of\n     * the enctype of the enctype of the service (likely krbtgt).\n     *\n     * The latter is used as a hint of what enctypes all KDC support,\n     * to make sure a newer version of KDC won't generate a session\n     * enctype that an older version of a KDC in the same realm can't\n     * decrypt.\n     */\n\n    ret = _kdc_find_etype(context,\n\t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?\n\t\t\t  config->tgt_use_strongest_session_key :\n\t\t\t  config->svc_use_strongest_session_key, FALSE,\n\t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,\n\t\t\t  NULL);\n    if (ret) {\n\tkdc_log(context, config, 0,\n\t\t\""Client (%s) from %s has no common enctypes with KDC \""\n\t\t\""to use for the session key\"",\n\t\tr->client_name, from);\n\tgoto out;\n    }\n\n    /*\n     * Pre-auth processing\n     */\n\n    if(req->padata){\n\tunsigned int n;\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:kerberos5.c, lines:1800-2000)"", ""result"": ""\tunsigned int n;\n\n\tlog_patypes(context, config, req->padata);\n\n\t/* Check if preauth matching */\n\n\tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if (pat[n].validate == NULL)\n\t\tcontinue;\n\t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))\n\t\tcontinue;\n\n\t    kdc_log(context, config, 5,\n\t\t    \""Looking for %s pa-data -- %s\"", pat[n].name, r->client_name);\n\t    i = 0;\n\t    pa = _kdc_find_padata(req, &i, pat[n].type);\n\t    if (pa) {\n\t\tret = pat[n].validate(r, pa);\n\t\tif (ret != 0) {\n\t\t    goto out;\n\t\t}\n\t\tkdc_log(context, config, 0,\n\t\t\t\""%s pre-authentication succeeded -- %s\"",\n\t\t\tpat[n].name, r->client_name);\n\t\tfound_pa = 1;\n\t\tr->et.flags.pre_authent = 1;\n\t    }\n\t}\n    }\n\n    if (found_pa == 0) {\n\tKey *ckey = NULL;\n\tsize_t n;\n\n\tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {\n\t    if ((pat[n].flags & PA_ANNOUNCE) == 0)\n\t\tcontinue;\n\t    ret = krb5_padata_add(context, &error_method,\n\t\t\t\t  pat[n].type, NULL, 0);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is a client key, send ETYPE_INFO{,2}\n\t */\n\tret = _kdc_find_etype(context,\n\t\t\t      config->preauth_use_strongest_session_key, TRUE,\n\t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);\n\tif (ret == 0) {\n\n\t    /*\n\t     * RFC4120 requires:\n\t     * - If the client only knows about old enctypes, then send\n\t     *   both info replies (we send 'info' first in the list).\n\t     * - If the client is 'modern', because it knows about 'new'\n\t     *   enctype types, then only send the 'info2' reply.\n\t     *\n\t     * Before we send the full list of etype-info data, we pick\n\t     * the client key we would have used anyway below, just pick\n\t     * that instead.\n\t     */\n\n\t    if (older_enctype(ckey->key.keytype)) {\n\t\tret = get_pa_etype_info(context, config,\n\t\t\t\t\t&error_method, ckey);\n\t\tif (ret)\n\t\t    goto out;\n\t    }\n\t    ret = get_pa_etype_info2(context, config,\n\t\t\t\t     &error_method, ckey);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\t/* \n\t * send requre preauth is its required or anon is requested,\n\t * anon is today only allowed via preauth mechanisms.\n\t */\n\tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {\n\t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\t    _kdc_set_e_text(r, \""Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\"");\n\t    goto out;\n\t}\n\n\tif (ckey == NULL) {\n\t    ret = KRB5KDC_ERR_CLIENT_NOTYET;\n\t    _kdc_set_e_text(r, \""Doesn't have a client key available\"");\n\t    goto out;\n\t}\n\tkrb5_free_keyblock_contents(r->context,  &r->reply_key);\n\tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (r->clientdb->hdb_auth_status) {\n\tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, \n\t\t\t\t     HDB_AUTH_SUCCESS);\n    }\n\n    /*\n     * Verify flags after the user been required to prove its identity\n     * with in a preauth mech.\n     */\n\n    ret = _kdc_check_access(context, config, r->client, r->client_name,\n\t\t\t    r->server, r->server_name,\n\t\t\t    req, &error_method);\n    if(ret)\n\tgoto out;\n\n    /*\n     * Select the best encryption type for the KDC with out regard to\n     * the client since the client never needs to read that data.\n     */\n\n    ret = _kdc_get_preferred_key(context, config,\n\t\t\t\t r->server, r->server_name,\n\t\t\t\t &setype, &skey);\n    if(ret)\n\tgoto out;\n\n    if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey\n       || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {\n\tret = KRB5KDC_ERR_BADOPTION;\n\t_kdc_set_e_text(r, \""Bad KDC options\"");\n\tgoto out;\n    }\n\n    /*\n     * Build reply\n     */\n\n    rep.pvno = 5;\n    rep.msg_type = krb_as_rep;\n\n    if (_kdc_is_anonymous(context, r->client_princ)) {\n\tRealm anon_realm=KRB5_ANON_REALM;\n\tret = copy_Realm(&anon_realm, &rep.crealm);\n    } else\n\tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);\n    if (ret)\n\tgoto out;\n    ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);\n    if (ret)\n\tgoto out;\n\n    rep.ticket.tkt_vno = 5;\n    ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);\n    if (ret)\n\tgoto out;\n    _krb5_principal2principalname(&rep.ticket.sname,\n\t\t\t\t  r->server->entry.principal);\n    /* java 1.6 expects the name to be the same type, lets allow that\n     * uncomplicated name-types. */\n#define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)\n    if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))\n\trep.ticket.sname.name_type = b->sname->name_type;\n#undef CNT\n\n    r->et.flags.initial = 1;\n    if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)\n\tr->et.flags.forwardable = f.forwardable;\n    else if (f.forwardable) {\n\t_kdc_set_e_text(r, \""Ticket may not be forwardable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)\n\tr->et.flags.proxiable = f.proxiable;\n    else if (f.proxiable) {\n\t_kdc_set_e_text(r, \""Ticket may not be proxiable\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n    if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)\n\tr->et.flags.may_postdate = f.allow_postdate;\n    else if (f.allow_postdate){\n\t_kdc_set_e_text(r, \""Ticket may not be postdate\"");\n\tret = KRB5KDC_ERR_POLICY;\n\tgoto out;\n    }\n\n    /* check for valid set of addresses */\n    if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {\n\t_kdc_set_e_text(r, \""Bad address list in requested\"");\n\tret = KRB5KRB_AP_ERR_BADADDR;\n\tgoto out;\n    }\n\n    ret = copy_PrincipalName(&rep.cname, &r->et.cname);\n    if (ret)\n\tgoto out;\n    ret = copy_Realm(&rep.crealm, &r->et.crealm);\n    if (ret)\n\tgoto out;\n\n    {\n\ttime_t start;\n\ttime_t t;\n""}, {""source"": ""value_info(file:kerberos5.c, value:r->client_princ)"", ""result"": {""value_trace"": [{""full_code"": ""r->client_princ = NULL"", ""line"": 2260, ""func_name"": ""_kdc_as_rep""}], ""struct_var"": ""r"", ""struct_type"": null, ""struct_definition"": null}}]","kdc/kerberos5.c:2233-2239: Dereference of `r->client_princ->name` and `r->client_princ->realm` in `_kdc_fast_mk_error()` without NULL check. kdc/kerberos5.c:2260: `r->client_princ` is explicitly set to NULL during error handling. Malformed AS requests with empty client name/realm fields are parsed by `_krb5_principalname2krb5_principal` (unavailable code), which fails and triggers the error path. `der_length_visible_string` (lib/asn1/der_length.c:242-246) returns 0 for empty strings, leading to parsing failure and `r->client_princ` being NULL.",0.95,./github/other_context/CVE-2017-17439
58,CVE-2017-6850,CWE-476,c_cpp,The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.,https://github.com/jasper-software/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,"Fixed bugs due to uninitialized data in the JP2 decoder.\nAlso, added some comments marking I/O stream interfaces that probably\nneed to be changed (in the long term) to fix integer overflow problems.",8,"[{""func_name"": ""jp2_cdef_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""jp2_bpcc_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"", ""target"": 1}, {""func_name"": ""jp2_pclr_putdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n/* Eliminate warning about unused variable. */\nbox = 0;\nout = 0;\n\treturn -1;\n}"", ""target"": 1}, {""func_name"": ""jp2_pclr_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}"", ""target"": 0}, {""func_name"": ""jp2_box_put"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}"", ""target"": 0}, {""func_name"": ""jp2_box_get"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\"",\n\t  '\""', boxinfo->name, '\""', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\""warning: cannot handle large 64-bit box length\\n\"");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\""cannot parse box data\\n\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}"", ""target"": 1}, {""func_name"": ""jp2_cmap_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"", ""target"": 1}, {""func_name"": ""jp2_box_create"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}"", ""target"": 0}]","[{""func_name"": ""jp2_cdef_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}""}, {""func_name"": ""jp2_bpcc_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->bpcs = 0;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}""}, {""func_name"": ""jp2_pclr_putdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n\t/* Eliminate warning about unused variable. */\n\tbox = 0;\n\tout = 0;\n\treturn -1;\n}""}, {""func_name"": ""jp2_pclr_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\tpclr->bpc = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}""}, {""func_name"": ""jp2_box_put"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len -\n\t\t  JP2_BOX_HDRLEN(false))) {\n\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}""}, {""func_name"": ""jp2_box_get"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jp2_box_create0())) {\n\t\tgoto error;\n\t}\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \""preliminary processing of JP2 box: \""\n\t  \""type=%c%s%c (0x%08x); length=%\""PRIuFAST32\""\\n\"",\n\t  '\""', boxinfo->name, '\""', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tJAS_DBGLOG(10, (\""big length\\n\""));\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\""warning: cannot handle large 64-bit box length\\n\"");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\""cannot copy box data\\n\"");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\""cannot parse box data\\n\"");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}""}, {""func_name"": ""jp2_cmap_getdata"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\tcmap->ents = 0;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}""}, {""func_name"": ""jp2_box_create"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c"", ""func_code"": ""jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jp2_box_create0())) {\n\t\treturn 0;\n\t}\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}""}]","{""function"": 1, ""code"": 1}","[{""source"": ""func_info(file:jp2_cod.c, func:jp2_cdef_destroy)"", ""result"": [{""code"": ""static void jp2_cdef_destroy(jp2_box_t *box)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tif (cdef->ents) {\n\t\tjas_free(cdef->ents);\n\t\tcdef->ents = 0;\n\t}\n}"", ""start_line"": 226, ""end_line"": 233, ""full_name"": ""jp2_cdef_destroy"", ""file_path"": ""src/libjasper/jp2/jp2_cod.c""}]}, {""source"": ""code_info(file:jp2_cod.c, lines:145-155)"", ""result"": ""\t{JP2_BOX_BPCC, \""BPCC\"", 0,\n\t  {0, jp2_bpcc_destroy, jp2_bpcc_getdata, jp2_bpcc_putdata, 0}},\n\t{JP2_BOX_COLR, \""COLR\"", 0,\n\t  {0, jp2_colr_destroy, jp2_colr_getdata, jp2_colr_putdata, jp2_colr_dumpdata}},\n\t{JP2_BOX_PCLR, \""PCLR\"", 0,\n\t  {0, jp2_pclr_destroy, jp2_pclr_getdata, jp2_pclr_putdata, jp2_pclr_dumpdata}},\n\t{JP2_BOX_CMAP, \""CMAP\"", 0,\n\t  {0, jp2_cmap_destroy, jp2_cmap_getdata, jp2_cmap_putdata, jp2_cmap_dumpdata}},\n\t{JP2_BOX_CDEF, \""CDEF\"", 0,\n\t  {0, jp2_cdef_destroy, jp2_cdef_getdata, jp2_cdef_putdata, jp2_cdef_dumpdata}},\n\t{JP2_BOX_RES, \""RES\"", JP2_BOX_SUPER,\n""}]","In 'jp2_cdef_getdata' (src/libjasper/jp2/jp2_cod.c:463), 'cdef->ents' was not initialized before the patch. If an error occurred during 'jp2_getuint16', 'cdef->ents' remained uninitialized. In 'jp2_cdef_destroy' (src/libjasper/jp2/jp2_cod.c:226-233), an uninitialized 'cdef->ents' could be non-zero, leading to 'jas_free(cdef->ents)' on invalid memory. The patch initializes 'cdef->ents = 0;' to ensure it is zeroed on error, preventing the invalid free.",0.95,./github/other_context/CVE-2017-6850
59,CVE-2017-7452,CWE-476,c_cpp,The iwbmp_read_info_header function in imagew-bmp.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted file.,https://github.com/jsummers/imageworsener/commit/45000700386baa6fbde03d98dd60cc4049230b82,Fixed a BMP decoding bug (buffer underrun)\n\nFixes issue #8,1,"[{""func_name"": ""iwbmp_read_info_header"", ""file_path"": ""src/imagew-bmp.c"", ""func_code"": ""static int iwbmp_read_info_header(struct iwbmprcontext *rctx)\n{\n\tiw_byte buf[124];\n\tint retval = 0;\n\tsize_t n;\n\n\t// First, read just the \""size\"" field. It tells the size of the header\n\t// structure, and identifies the BMP version.\n\tif(!iwbmp_read(rctx,buf,4)) goto done;\n\trctx->infoheader_size = iw_get_ui32le(&buf[0]);\n\n\t// Read the rest of the header.\n\tn = rctx->infoheader_size;\n\tif(n>sizeof(buf)) n=sizeof(buf);\n\tif(!iwbmp_read(rctx,&buf[4],n-4)) goto done;\n\n\tif(rctx->infoheader_size==12) {\n\t\t// This is a \""Windows BMP v2\"" or \""OS/2 BMP v1\"" bitmap.\n\t\trctx->bmpversion=2;\n\t\tif(!decode_v2_header(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {\n\t\t// A Windows v3 or OS/2 v2 BMP.\n\t\t// OS/2 v2 BMPs can technically have other header sizes between 16 and 64,\n\t\t// but it's not clear if such files actually exist.\n\t\trctx->bmpversion=3;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==108 || rctx->infoheader_size==52 || rctx->infoheader_size==56) {\n\t\t// We assume a a 52- or 56-byte header is for BITMAPV2INFOHEADER/BITMAPV3INFOHEADER,\n\t\t// and not OS/2v2 format. But if it OS/2v2, it will probably either work (because\n\t\t// the formats are similar enough), or fail due to an unsupported combination of\n\t\t// compression and bits/pixel.\n\t\trctx->bmpversion=4;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==124) {\n\t\trctx->bmpversion=5;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v5_header_fields(rctx,buf)) goto done;\n\t}\n\telse {\n\t\tiw_set_error(rctx->ctx,\""Unsupported BMP version\"");\n\t\tgoto done;\n\t}\n\n\tif(!iw_check_image_dimensions(rctx->ctx,rctx->width,rctx->height)) {\n\t\tgoto done;\n\t}\n\n\tretval = 1;\n\ndone:\n\treturn retval;\n}"", ""target"": 0}]","[{""func_name"": ""iwbmp_read_info_header"", ""file_path"": ""src/imagew-bmp.c"", ""func_code"": ""static int iwbmp_read_info_header(struct iwbmprcontext *rctx)\n{\n\tiw_byte buf[124];\n\tint retval = 0;\n\tsize_t n;\n\n\t// First, read just the \""size\"" field. It tells the size of the header\n\t// structure, and identifies the BMP version.\n\tif(!iwbmp_read(rctx,buf,4)) goto done;\n\trctx->infoheader_size = iw_get_ui32le(&buf[0]);\n\tif(rctx->infoheader_size<12) goto done;\n\n\t// Read the rest of the header.\n\tn = rctx->infoheader_size;\n\tif(n>sizeof(buf)) n=sizeof(buf);\n\tif(!iwbmp_read(rctx,&buf[4],n-4)) goto done;\n\n\tif(rctx->infoheader_size==12) {\n\t\t// This is a \""Windows BMP v2\"" or \""OS/2 BMP v1\"" bitmap.\n\t\trctx->bmpversion=2;\n\t\tif(!decode_v2_header(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {\n\t\t// A Windows v3 or OS/2 v2 BMP.\n\t\t// OS/2 v2 BMPs can technically have other header sizes between 16 and 64,\n\t\t// but it's not clear if such files actually exist.\n\t\trctx->bmpversion=3;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==108 || rctx->infoheader_size==52 || rctx->infoheader_size==56) {\n\t\t// We assume a a 52- or 56-byte header is for BITMAPV2INFOHEADER/BITMAPV3INFOHEADER,\n\t\t// and not OS/2v2 format. But if it OS/2v2, it will probably either work (because\n\t\t// the formats are similar enough), or fail due to an unsupported combination of\n\t\t// compression and bits/pixel.\n\t\trctx->bmpversion=4;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==124) {\n\t\trctx->bmpversion=5;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v5_header_fields(rctx,buf)) goto done;\n\t}\n\telse {\n\t\tiw_set_error(rctx->ctx,\""Unsupported BMP version\"");\n\t\tgoto done;\n\t}\n\n\tif(!iw_check_image_dimensions(rctx->ctx,rctx->width,rctx->height)) {\n\t\tgoto done;\n\t}\n\n\tretval = 1;\n\ndone:\n\treturn retval;\n}""}]","{""code"": 2, ""function"": 5, ""value"": 2}","[{""source"": ""code_info(file:imagew-bmp.c, lines:375-385)"", ""result"": ""\t// Read the rest of the header.\n\tn = rctx->infoheader_size;\n\tif(n>sizeof(buf)) n=sizeof(buf);\n\tif(!iwbmp_read(rctx,&buf[4],n-4)) goto done;\n\n\tif(rctx->infoheader_size==12) {\n\t\t// This is a \""Windows BMP v2\"" or \""OS/2 BMP v1\"" bitmap.\n\t\trctx->bmpversion=2;\n\t\tif(!decode_v2_header(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {\n""}, {""source"": ""func_info(file:imagew-bmp.c, func:iwbmp_read)"", ""result"": [{""code"": ""static int iwbmp_read(struct iwbmprcontext *rctx,\n\t\tiw_byte *buf, size_t buflen)\n{\n\tint ret;\n\tsize_t bytesread = 0;\n\n\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\tbuf,buflen,&bytesread);\n\tif(!ret || bytesread!=buflen) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"", ""start_line"": 65, ""end_line"": 77, ""full_name"": ""iwbmp_read"", ""file_path"": ""src/imagew-bmp.c""}]}, {""source"": ""value_info(file:imagew-bmp.c, value:rctx->infoheader_size)"", ""result"": {""value_trace"": [{""full_code"": ""rctx->infoheader_size = iw_get_ui32le(&buf[0])"", ""line"": 373, ""func_name"": ""iwbmp_read_info_header""}], ""struct_var"": ""rctx"", ""struct_type"": ""iwbmprcontext*"", ""struct_definition"": ""struct iwbmprcontext {\n\tstruct iw_iodescr *iodescr;\n\tstruct iw_context *ctx;\n\tstruct iw_image *img;\n\tint bmpversion;\n\tint width, height;\n\tint topdown;\n\tint has_fileheader;\n\tunsigned int bitcount; // bits per pixel\n\tunsigned int compression; // IWBMP_BI_*\n\tint uses_bitfields; // 'compression' is BI_BITFIELDS\n\tint has_alpha_channel;\n\tint bitfields_set;\n\tint need_16bit;\n\tunsigned int palette_entries;\n\tsize_t fileheader_size;\n\tsize_t infoheader_size;\n\tsize_t bitfields_nbytes; // Bytes consumed by BITFIELDs, if not part of the header.\n\tsize_t palette_nbytes;\n\tsize_t bfOffBits;\n\tstruct iw_palette palette;\n\n\t// For 16- & 32-bit images:\n\tunsigned int bf_mask[4];\n\tint bf_high_bit[4];\n\tint bf_low_bit[4];\n\tint bf_bits_count[4]; // number of bits in each channel\n\n\tstruct iw_csdescr csdescr;\n}""}}, {""source"": ""code_info(file:imagew-bmp.c, lines:385-405)"", ""result"": ""\telse if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {\n\t\t// A Windows v3 or OS/2 v2 BMP.\n\t\t// OS/2 v2 BMPs can technically have other header sizes between 16 and 64,\n\t\t// but it's not clear if such files actually exist.\n\t\trctx->bmpversion=3;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==108 || rctx->infoheader_size==52 || rctx->infoheader_size==56) {\n\t\t// We assume a a 52- or 56-byte header is for BITMAPV2INFOHEADER/BITMAPV3INFOHEADER,\n\t\t// and not OS/2v2 format. But if it OS/2v2, it will probably either work (because\n\t\t// the formats are similar enough), or fail due to an unsupported combination of\n\t\t// compression and bits/pixel.\n\t\trctx->bmpversion=4;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==124) {\n\t\trctx->bmpversion=5;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v5_header_fields(rctx,buf)) goto done;\n""}, {""source"": ""func_info(file:imagew-bmp.c, func:decode_v2_header)"", ""result"": [{""code"": ""static int decode_v2_header(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int nplanes;\n\n\trctx->width = iw_get_ui16le(&buf[4]);\n\trctx->height = iw_get_ui16le(&buf[6]);\n\tnplanes = iw_get_ui16le(&buf[8]);\n\tif(nplanes!=1) return 0;\n\trctx->bitcount = iw_get_ui16le(&buf[10]);\n\tif(rctx->bitcount!=1 && rctx->bitcount!=4 &&\n\t\trctx->bitcount!=8 && rctx->bitcount!=24)\n\t{\n\t\treturn 0;\n\t}\n\tif(rctx->bitcount<=8) {\n\t\tsize_t palette_start, palette_end;\n\n\t\trctx->palette_entries = 1<<rctx->bitcount;\n\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\n\t\t// Since v2 BMPs have no direct way to indicate that the palette is not\n\t\t// full-sized, assume the palette ends no later than the start of the\n\t\t// bitmap bits.\n\t\tpalette_start = rctx->fileheader_size + rctx->infoheader_size;\n\t\tpalette_end = palette_start + rctx->palette_nbytes;\n\t\tif(rctx->bfOffBits >= palette_start+3 && rctx->bfOffBits < palette_end) {\n\t\t\trctx->palette_entries = (unsigned int)((rctx->bfOffBits - palette_start)/3);\n\t\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\t\t}\n\t}\n\treturn 1;\n}\n"", ""start_line"": 132, ""end_line"": 163, ""full_name"": ""decode_v2_header"", ""file_path"": ""src/imagew-bmp.c""}]}, {""source"": ""value_info(file:imagew-bmp.c, value:buf)"", ""result"": {""value_trace"": [{""full_code"": ""buf[1024]"", ""line"": 81, ""func_name"": ""iwbmp_skip_bytes""}, {""full_code"": ""buf[14]"", ""line"": 99, ""func_name"": ""iwbmp_read_file_header""}, {""full_code"": ""buf[124]"", ""line"": 366, ""func_name"": ""iwbmp_read_info_header""}], ""struct_var"": ""buf"", ""struct_type"": ""uint8_t[1024]"", ""struct_definition"": null}}, {""source"": ""func_info(file:imagew-bmp.c, func:decode_v3_header_fields)"", ""result"": [{""code"": ""static int decode_v3_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int nplanes;\n\tint biXPelsPerMeter, biYPelsPerMeter;\n\tunsigned int biClrUsed = 0;\n\t//unsigned int biSizeImage;\n\n\trctx->width = iw_get_i32le(&buf[4]);\n\trctx->height = iw_get_i32le(&buf[8]);\n\tif(rctx->height<0) {\n\t\trctx->height = -rctx->height;\n\t\trctx->topdown = 1;\n\t}\n\n\tnplanes = iw_get_ui16le(&buf[12]);\n\tif(nplanes!=1) return 0;\n\n\trctx->bitcount = iw_get_ui16le(&buf[14]);\n\t// We allow bitcount=2 because it's legal in Windows CE BMPs.\n\tif(rctx->bitcount!=1 && rctx->bitcount!=2 && rctx->bitcount!=4 &&\n\t\trctx->bitcount!=8 && rctx->bitcount!=16 && rctx->bitcount!=24 &&\n\t\trctx->bitcount!=32)\n\t{\n\t\tiw_set_errorf(rctx->ctx,\""Bad or unsupported bit count (%d)\"",(int)rctx->bitcount);\n\t\treturn 0;\n\t}\n\n\tif(rctx->infoheader_size<=16) {\n\t\tgoto infoheaderdone;\n\t}\n\n\trctx->compression = iw_get_ui32le(&buf[16]);\n\tif(rctx->compression==IWBMP_BI_BITFIELDS) {\n\t\tif(rctx->bitcount==1) {\n\t\t\tiw_set_error(rctx->ctx,\""Huffman 1D compression not supported\"");\n\t\t\treturn 0;\n\t\t}\n\t\telse if(rctx->bitcount!=16 && rctx->bitcount!=32) {\n\t\t\tiw_set_error(rctx->ctx,\""Bad or unsupported image type\"");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// The compression field is overloaded: BITFIELDS is not a type of\n\t\t// compression. Un-overload it.\n\t\trctx->uses_bitfields = 1;\n\n\t\t// The v4/v5 documentation for the \""BitCount\"" field says that the\n\t\t// BITFIELDS data comes after the header, the same as with v3.\n\t\t// The v4/v5 documentation for the \""Compression\"" field says that the\n\t\t// BITFIELDS data is stored in the \""Mask\"" fields of the header.\n\t\t// Am I supposed to conclude that it is redundantly stored in both\n\t\t// places?\n\t\t// Evidence and common sense suggests the \""BitCount\"" documentation is\n\t\t// incorrect, and v4/v5 BMPs never have a separate \""bitfields\"" segment.\n\t\tif(rctx->bmpversion==3) {\n\t\t\trctx->bitfields_nbytes = 12;\n\t\t}\n\n\t\trctx->compression=IWBMP_BI_RGB;\n\t}\n\n\t//biSizeImage = iw_get_ui32le(&buf[20]);\n\tbiXPelsPerMeter = iw_get_i32le(&buf[24]);\n\tbiYPelsPerMeter = iw_get_i32le(&buf[28]);\n\n\trctx->img->density_code = IW_DENSITY_UNITS_PER_METER;\n\trctx->img->density_x = (double)biXPelsPerMeter;\n\trctx->img->density_y = (double)biYPelsPerMeter;\n\tif(!iw_is_valid_density(rctx->img->density_x,rctx->img->density_y,rctx->img->density_code)) {\n\t\trctx->img->density_code=IW_DENSITY_UNKNOWN;\n\t}\n\n\tbiClrUsed = iw_get_ui32le(&buf[32]);\n\tif(biClrUsed>100000) return 0;\n\ninfoheaderdone:\n\t// The documentation of the biClrUsed field is not very clear.\n\t// I'm going to assume that if biClrUsed is 0 and bitcount<=8, then\n\t// the number of palette colors is the maximum that would be useful\n\t// for that bitcount. In all other cases, the number of palette colors\n\t// equals biClrUsed.\n\tif(biClrUsed==0 && rctx->bitcount<=8) {\n\t\trctx->palette_entries = 1<<rctx->bitcount;\n\t}\n\telse {\n\t\trctx->palette_entries = biClrUsed;\n\t}\n\trctx->palette_nbytes = 4*rctx->palette_entries;\n\treturn 1;\n}\n"", ""start_line"": 166, ""end_line"": 255, ""full_name"": ""decode_v3_header_fields"", ""file_path"": ""src/imagew-bmp.c""}]}, {""source"": ""func_info(file:imagew-bmp.c, func:decode_v4_header_fields)"", ""result"": [{""code"": ""static int decode_v4_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tint k;\n\tunsigned int cstype;\n\n\tif(rctx->uses_bitfields) {\n\t\t// Set the bitfields masks here, instead of in iwbmp_read_bitfields().\n\t\tfor(k=0;k<4;k++) {\n\t\t\trctx->bf_mask[k] = 0;\n\t\t}\n\t\tfor(k=0;k<4;k++) {\n\t\t\tif(rctx->infoheader_size < (size_t)(40+k*4+4)) break;\n\t\t\trctx->bf_mask[k] = iw_get_ui32le(&buf[40+k*4]);\n\t\t\tif(!process_bf_mask(rctx,k)) return 0;\n\t\t}\n\t\trctx->bitfields_set=1; // Remember not to overwrite the bf_* fields.\n\n\t\tif(rctx->bf_mask[3]!=0) {\n\t\t\t// The documentation says this is the mask that \""specifies the\n\t\t\t// alpha component of each pixel.\""\n\t\t\t// It doesn't say whther it's associated, or unassociated alpha.\n\t\t\t// It doesn't say whether 0=transparent, or 0=opaque.\n\t\t\t// It doesn't say how to tell whether an image has an alpha\n\t\t\t// channel.\n\t\t\t// These are the answers I'm going with:\n\t\t\t// - Unassociated alpha\n\t\t\t// - 0=transparent\n\t\t\t// - 16- and 32-bit images have an alpha channel if 'compression'\n\t\t\t// is set to BI_BITFIELDS, and this alpha mask is nonzero.\n\t\t\trctx->has_alpha_channel = 1;\n\t\t}\n\t}\n\n\tif(rctx->infoheader_size < 108) return 1;\n\n\tcstype = iw_get_ui32le(&buf[56]);\n\tswitch(cstype) {\n\tcase IWBMPCS_CALIBRATED_RGB:\n\t\t//  \""indicates that endpoints and gamma values are given in the\n\t\t//    appropriate fields.\""  (TODO)\n\t\tbreak;\n\n\tcase IWBMPCS_DEVICE_RGB:\n\tcase IWBMPCS_SRGB:\n\tcase IWBMPCS_WINDOWS:\n\t\tbreak;\n\n\tcase IWBMPCS_PROFILE_LINKED:\n\tcase IWBMPCS_PROFILE_EMBEDDED:\n\t\tif(rctx->bmpversion<5) {\n\t\t\tiw_warning(rctx->ctx,\""Invalid colorspace type for BMPv4\"");\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tiw_warningf(rctx->ctx,\""Unrecognized or unsupported colorspace type (0x%x)\"",cstype);\n\t}\n\n\t// Read Gamma fields\n\tif(cstype==IWBMPCS_CALIBRATED_RGB) {\n\t\tunsigned int bmpgamma;\n\t\tdouble gamma[3];\n\t\tdouble avggamma;\n\n\t\tfor(k=0;k<3;k++) {\n\t\t\tbmpgamma = iw_get_ui32le(&buf[96+k*4]);\n\t\t\tgamma[k] = ((double)bmpgamma)/65536.0;\n\t\t}\n\t\tavggamma = (gamma[0] + gamma[1] + gamma[2])/3.0;\n\n\t\tif(avggamma>=0.1 && avggamma<=10.0) {\n\t\t\tiw_make_gamma_csdescr(&rctx->csdescr,1.0/avggamma);\n\t\t}\n\t}\n\n\treturn 1;\n}\n"", ""start_line"": 260, ""end_line"": 336, ""full_name"": ""decode_v4_header_fields"", ""file_path"": ""src/imagew-bmp.c""}]}, {""source"": ""func_info(file:imagew-bmp.c, func:decode_v5_header_fields)"", ""result"": [{""code"": ""static int decode_v5_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int intent_bmp_style;\n\tint intent_iw_style;\n\n\tintent_bmp_style = iw_get_ui32le(&buf[108]);\n\tintent_iw_style = IW_INTENT_UNKNOWN;\n\tswitch(intent_bmp_style) {\n\t\tcase 1: intent_iw_style = IW_INTENT_SATURATION; break; // LCS_GM_BUSINESS\n\t\tcase 2: intent_iw_style = IW_INTENT_RELATIVE; break; // LCS_GM_GRAPHICS\n\t\tcase 4: intent_iw_style = IW_INTENT_PERCEPTUAL; break; // LCS_GM_IMAGES\n\t\tcase 8: intent_iw_style = IW_INTENT_ABSOLUTE; break; // LCS_GM_ABS_COLORIMETRIC\n\t}\n\trctx->img->rendering_intent = intent_iw_style;\n\n\t// The profile may either be after the color table, or after the bitmap bits.\n\t// I'm assuming that we will never need to use the profile size in order to\n\t// find the bitmap bits; i.e. that if the bfOffBits field in the file header\n\t// is not available, the profile must be after the bits.\n\t//profile_offset = iw_get_ui32le(&buf[112]); // bV5ProfileData;\n\t//profile_size = iw_get_ui32le(&buf[116]); // bV5ProfileSize;\n\n\treturn 1;\n}\n"", ""start_line"": 339, ""end_line"": 362, ""full_name"": ""decode_v5_header_fields"", ""file_path"": ""src/imagew-bmp.c""}]}]","src/imagew-bmp.c:373: infoheader_size is read without validation. If <12, subsequent code (lines 375-385) calls decode_v2_header (line 132) which accesses buf[10] (out-of-bounds if buffer is undersized). The patch (line 372) adds infoheader_size < 12 check to prevent this. Trigger chain: [1] Crafted BMP with infoheader_size < 12 → [2] iwbmp_read_info_header reads into undersized buffer → [3] decode_v2_header accesses buf[10] (invalid memory) → [4] NULL pointer dereference.",0.95,./github/other_context/CVE-2017-7452
60,CVE-2017-7458,CWE-476,c_cpp,The NetworkInterface::getHost function in NetworkInterface.cpp in ntopng before 3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an empty field that should have contained a hostname or IP address.,https://github.com/ntop/ntopng/commit/01f47e04fd7c8d54399c9e465f823f0017069f8f,Security fix: prevents empty host from being used,2,"[{""func_name"": ""NetworkInterface::getHost"", ""file_path"": ""src/NetworkInterface.cpp"", ""func_code"": ""Host* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {\n  struct in_addr  a4;\n  struct in6_addr a6;\n  Host *h = NULL;\n\n  /* Check if address is invalid */\n  if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)\n     && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {\n    /* Looks like a symbolic name */\n    struct host_find_info info;\n\n    memset(&info, 0, sizeof(info));\n    info.host_to_find = host_ip, info.vlan_id = vlan_id;\n    walker(walker_hosts, find_host_by_name, (void*)&info);\n\n    h = info.h;\n  } else {\n    IpAddress *ip = new IpAddress();\n\n    if(ip) {\n      ip->set(host_ip);\n\n      if(!isView())\n\th = hosts_hash->get(vlan_id, ip);\n      else {\n\tfor(u_int8_t s = 0; s<numSubInterfaces; s++) {\n\t  h = subInterfaces[s]->get_hosts_hash()->get(vlan_id, ip);\n\t  if(h) break;\n\t}\n      }\n\n      delete ip;\n    }\n  }\n\n  return(h);\n}"", ""target"": 0}, {""func_name"": ""Lua::setParamsTable"", ""file_path"": ""src/Lua.cpp"", ""func_code"": ""void Lua::setParamsTable(lua_State* vm, const char* table_name,\n\t\t\t const char* query) const {\n  char outbuf[FILENAME_MAX];\n  char *where;\n  char *tok;\n\n  char *query_string = query ? strdup(query) : NULL;\n\n  lua_newtable(L);\n\n  if (query_string) {\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \""[HTTP] %s\"", query_string);\n\n    tok = strtok_r(query_string, \""&\"", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \""csrf\"", strlen(\""csrf\"")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        // ntop->getTrace()->traceEvent(TRACE_WARNING, \""%s = %s\"", tok, _equal);\n\n        if((decoded_buf = (char*)malloc(len+1)) != NULL) {\n\n          Utils::urlDecode(_equal, decoded_buf, len+1);\n\n\t  Utils::purifyHTTPparam(tok, true, false);\n\t  Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t  /* Now make sure that decoded_buf is not a file path */\n\t  FILE *fd;\n\t  if((decoded_buf[0] == '.')\n\t     && ((fd = fopen(decoded_buf, \""r\""))\n\t\t || (fd = fopen(realpath(decoded_buf, outbuf), \""r\"")))) {\n\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \""Discarded '%s'='%s' as argument is a valid file path\"",\n\t\t\t\t\t tok, decoded_buf);\n\t    decoded_buf[0] = '\\0';\n\t    fclose(fd);\n\t  }\n\n\t  /* ntop->getTrace()->traceEvent(TRACE_WARNING, \""'%s'='%s'\"", tok, decoded_buf); */\n\n\t  /* put tok and the decoded buffer in to the table */\n\t  lua_push_str_table_entry(vm, tok, decoded_buf);\n\n          free(decoded_buf);\n        } else\n          ntop->getTrace()->traceEvent(TRACE_WARNING, \""Not enough memory\"");\n      }\n\n      tok = strtok_r(NULL, \""&\"", &where);\n    } /* while */\n  }\n\n  if(query_string) free(query_string);\n\n  if(table_name)\n    lua_setglobal(L, table_name);\n  else\n    lua_setglobal(L, (char*)\""_GET\""); /* Default */\n}"", ""target"": 0}]","[{""func_name"": ""NetworkInterface::getHost"", ""file_path"": ""src/NetworkInterface.cpp"", ""func_code"": ""Host* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {\n  struct in_addr  a4;\n  struct in6_addr a6;\n  Host *h = NULL;\n\n  if(!host_ip) return(NULL);\n\n  /* Check if address is invalid */\n  if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)\n     && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {\n    /* Looks like a symbolic name */\n    struct host_find_info info;\n\n    memset(&info, 0, sizeof(info));\n    info.host_to_find = host_ip, info.vlan_id = vlan_id;\n    walker(walker_hosts, find_host_by_name, (void*)&info);\n\n    h = info.h;\n  } else {\n    IpAddress *ip = new IpAddress();\n\n    if(ip) {\n      ip->set(host_ip);\n\n      if(!isView())\n\th = hosts_hash->get(vlan_id, ip);\n      else {\n\tfor(u_int8_t s = 0; s<numSubInterfaces; s++) {\n\t  h = subInterfaces[s]->get_hosts_hash()->get(vlan_id, ip);\n\t  if(h) break;\n\t}\n      }\n\n      delete ip;\n    }\n  }\n\n  return(h);\n}""}, {""func_name"": ""Lua::setParamsTable"", ""file_path"": ""src/Lua.cpp"", ""func_code"": ""void Lua::setParamsTable(lua_State* vm, const char* table_name,\n\t\t\t const char* query) const {\n  char outbuf[FILENAME_MAX];\n  char *where;\n  char *tok;\n\n  char *query_string = query ? strdup(query) : NULL;\n\n  lua_newtable(L);\n\n  if (query_string) {\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \""[HTTP] %s\"", query_string);\n\n    tok = strtok_r(query_string, \""&\"", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \""csrf\"", strlen(\""csrf\"")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))\n\t && (strlen(_equal) > 1)) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        // ntop->getTrace()->traceEvent(TRACE_WARNING, \""%s = %s\"", tok, _equal);\n\n        if((decoded_buf = (char*)malloc(len+1)) != NULL) {\n\n          Utils::urlDecode(_equal, decoded_buf, len+1);\n\n\t  Utils::purifyHTTPparam(tok, true, false);\n\t  Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t  /* Now make sure that decoded_buf is not a file path */\n\t  FILE *fd;\n\t  if((decoded_buf[0] == '.')\n\t     && ((fd = fopen(decoded_buf, \""r\""))\n\t\t || (fd = fopen(realpath(decoded_buf, outbuf), \""r\"")))) {\n\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \""Discarded '%s'='%s' as argument is a valid file path\"",\n\t\t\t\t\t tok, decoded_buf);\n\t    decoded_buf[0] = '\\0';\n\t    fclose(fd);\n\t  }\n\n\t  /* ntop->getTrace()->traceEvent(TRACE_WARNING, \""'%s'='%s'\"", tok, decoded_buf); */\n\n\t  /* put tok and the decoded buffer in to the table */\n\t  lua_push_str_table_entry(vm, tok, decoded_buf);\n\n          free(decoded_buf);\n        } else\n          ntop->getTrace()->traceEvent(TRACE_WARNING, \""Not enough memory\"");\n      }\n\n      tok = strtok_r(NULL, \""&\"", &where);\n    } /* while */\n  }\n\n  if(query_string) free(query_string);\n\n  if(table_name)\n    lua_setglobal(L, table_name);\n  else\n    lua_setglobal(L, (char*)\""_GET\""); /* Default */\n}""}]","{""caller"": 3, ""value"": 1, ""function"": 1, ""code"": 1}","[{""source"": ""caller_info(file:NetworkInterface.cpp, func:getHost)"", ""result"": [{""call_line"": 2305, ""call_code"": ""getHost(host_ip, vlan_id)"", ""caller_code"": ""Host* NetworkInterface::findHostsByIP(AddressTree *allowed_hosts,\n\t\t\t\t      char *host_ip, u_int16_t vlan_id) {\n  if(host_ip != NULL) {\n    Host *h = getHost(host_ip, vlan_id);\n\n    if(h && h->match(allowed_hosts))\n      return(h);\n  }\n\n  return(NULL);\n}"", ""caller_start"": 2302, ""file_path"": ""src/NetworkInterface.cpp""}, {""call_line"": 3827, ""call_code"": ""getHost(host_ip, vlan_id)"", ""caller_code"": ""bool NetworkInterface::correlateHostActivity(lua_State* vm,\n\t\t\t\t\t     AddressTree *allowed_hosts,\n\t\t\t\t\t     char *host_ip, u_int16_t vlan_id) {\n  Host *h = getHost(host_ip, vlan_id);\n\n  if(h) {\n    struct correlator_host_info info;\n\n    memset(&info, 0, sizeof(info));\n\n    info.vm = vm, info.h = h;\n    h->getActivityStats()->extractPoints(&info.x);\n    walker(walker_hosts, correlator_walker, &info);\n\n    return(true);\n  } else\n    return(false);\n}"", ""caller_start"": 3824, ""file_path"": ""src/NetworkInterface.cpp""}, {""call_line"": 3848, ""call_code"": ""getHost(host_ip, vlan_id)"", ""caller_code"": ""bool NetworkInterface::similarHostActivity(lua_State* vm,\n\t\t\t\t\t   AddressTree *allowed_hosts,\n\t\t\t\t\t   char *host_ip, u_int16_t vlan_id) {\n  Host *h = getHost(host_ip, vlan_id);\n\n  if(h) {\n    struct correlator_host_info info;\n\n    memset(&info, 0, sizeof(info));\n\n    info.vm = vm, info.h = h;\n    h->getActivityStats()->extractPoints(&info.x);\n    walker(walker_hosts, similarity_walker, &info);\n\n    return(true);\n  } else\n    return(false);\n}"", ""caller_start"": 3845, ""file_path"": ""src/NetworkInterface.cpp""}, {""call_line"": 1512, ""call_code"": ""ntop_interface->getHost(host_ip, vlan_id)"", ""caller_code"": ""static int ntop_get_interface_flows(lua_State* vm, LocationPolicy location) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char buf[64];\n  char *host_ip = NULL;\n  u_int16_t vlan_id = 0;\n  Host *host = NULL;\n  Paginator *p = NULL;\n  int numFlows = -1;\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  if((p = new(std::nothrow) Paginator()) == NULL)\n    return(CONST_LUA_ERROR);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \""%s() called\"", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n    get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n    host = ntop_interface->getHost(host_ip, vlan_id);\n  }\n\n  if(lua_type(vm, 2) == LUA_TTABLE)\n    p->readOptions(vm, 2);\n\n  if(ntop_interface)\n    numFlows = ntop_interface->getFlows(vm, get_allowed_nets(vm), location, host, p);\n\n  if(p) delete p;\n  return numFlows < 0 ? CONST_LUA_ERROR : CONST_LUA_OK;\n}"", ""caller_start"": 1493, ""file_path"": ""src/Lua.cpp""}]}, {""source"": ""value_info(file:NetworkInterface.cpp, value:host_ip)"", ""result"": {""value_trace"": [{""full_code"": ""*host_ip = NULL"", ""line"": 304, ""func_name"": ""ntop_get_ndpi_interface_stats:int(lua_State*)""}, {""full_code"": ""*host_ip = NULL"", ""line"": 1496, ""func_name"": ""ntop_get_interface_flows:int(lua_State*,LocationPolicy)""}], ""struct_var"": ""host_ip"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""func_info(func:get_host_vlan_info)"", ""result"": [{""code"": ""static void get_host_vlan_info(char* lua_ip, char** host_ip,\n\t\t\t       u_int16_t* vlan_id,\n\t\t\t       char *buf, u_int buf_len) {\n  char *where, *vlan = NULL;\n\n  snprintf(buf, buf_len, \""%s\"", lua_ip);\n\n  if(((*host_ip) = strtok_r(buf, \""@\"", &where)) != NULL)\n    vlan = strtok_r(NULL, \""@\"", &where);\n\n  if(vlan)\n    (*vlan_id) = (u_int16_t)atoi(vlan);\n}"", ""start_line"": 90, ""end_line"": 102, ""full_name"": ""get_host_vlan_info:void(char*,char**,u_int16_t*,char*,u_int)"", ""file_path"": ""src/Lua.cpp""}]}, {""source"": ""code_info(file:Lua.cpp, lines:1490-1510)"", ""result"": ""\n/* ****************************************** */\n\nstatic int ntop_get_interface_flows(lua_State* vm, LocationPolicy location) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char buf[64];\n  char *host_ip = NULL;\n  u_int16_t vlan_id = 0;\n  Host *host = NULL;\n  Paginator *p = NULL;\n  int numFlows = -1;\n\n  if(!ntop_interface)\n    return(CONST_LUA_ERROR);\n\n  if((p = new(std::nothrow) Paginator()) == NULL)\n    return(CONST_LUA_ERROR);\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \""%s() called\"", __FUNCTION__);\n\n  if(lua_type(vm, 1) == LUA_TSTRING) {\n""}, {""source"": ""caller_info(file:NetworkInterface.cpp, func:correlateHostActivity)"", ""result"": [{""call_line"": 1802, ""call_code"": ""ntop_interface->correlateHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id)"", ""caller_code"": ""static int ntop_correalate_host_activity(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \""%s() called\"", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n   /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->correlateHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}"", ""caller_start"": 1788, ""file_path"": ""src/Lua.cpp""}]}, {""source"": ""caller_info(file:NetworkInterface.cpp, func:similarHostActivity)"", ""result"": [{""call_line"": 1824, ""call_code"": ""ntop_interface->similarHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id)"", ""caller_code"": ""static int ntop_similar_host_activity(lua_State* vm) {\n  NetworkInterface *ntop_interface = getCurrentInterface(vm);\n  char *host_ip;\n  u_int16_t vlan_id = 0;\n  char buf[64];\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \""%s() called\"", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  get_host_vlan_info((char*)lua_tostring(vm, 1), &host_ip, &vlan_id, buf, sizeof(buf));\n\n  /* Optional VLAN id */\n  if(lua_type(vm, 2) == LUA_TNUMBER) vlan_id = (u_int16_t)lua_tonumber(vm, 2);\n\n  if((!ntop_interface) || !ntop_interface->similarHostActivity(vm, get_allowed_nets(vm), host_ip, vlan_id))\n    return(CONST_LUA_ERROR);\n  else\n    return(CONST_LUA_OK);\n}"", ""caller_start"": 1810, ""file_path"": ""src/Lua.cpp""}]}]","src/Lua.cpp:90-102: get_host_vlan_info splits input like '@vlan' into host_ip (empty string) and vlan. src/Lua.cpp:1503,1788,1810: host_ip is passed as empty string to NetworkInterface::getHost. src/NetworkInterface.cpp:2200: getHost checks !host_ip (NULL) but not empty strings → inet_pton crash.",0.95,./github/other_context/CVE-2017-7458
61,CVE-2018-1000879,CWE-476,c_cpp,"libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted archive file.",https://github.com/libarchive/libarchive/commit/15bf44fd2c1ad0e3fd87048b3fcc90c4dcff1175,"Skip 0-length ACL fields\n\nCurrently, it is possible to create an archive that crashes bsdtar\nwith a malformed ACL:\n\nProgram received signal SIGSEGV, Segmentation fault.\narchive_acl_from_text_l (acl=<optimised out>, text=0x7e2e92 """", want_type=<optimised out>, sc=<optimised out>) at libarchive/archive_acl.c:1726\n1726				switch (*s) {\n(gdb) p n\n$1 = 1\n(gdb) p field[n]\n$2 = {start = 0x0, end = 0x0}\n\nStop this by checking that the length is not zero before beginning\nthe switch statement.\n\nI am pretty sure this is the bug mentioned in the qsym paper [1],\nand I was able to replicate it with a qsym + AFL + afl-rb setup.\n\n[1] https://www.usenix.org/conference/usenixsecurity18/presentation/yun",1,"[{""func_name"": ""archive_acl_from_text_l"", ""file_path"": ""libarchive/archive_acl.c"", ""func_code"": ""int\narchive_acl_from_text_l(struct archive_acl *acl, const char *text,\n    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = 0;\n\t\tsol = 0;\n\t\tid = -1;\n\t\tpermset = 0;\n\t\tname.start = name.end = NULL;\n\n\t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \""default:user::rwx\""\n\t\t\t * if found, we have one more field\n\t\t\t *\n\t\t\t * We also support old Solaris extension:\n\t\t\t * \""defaultuser::rwx\"" is the default ACL corresponding\n\t\t\t * to \""user::rwx\"", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \""efault\"", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ser\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""roup\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""ther\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ask\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (tag) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\t\tif (fields == (n + 2)\n\t\t\t\t    && field[n + 1].start < field[n + 1].end\n\t\t\t\t    && ismode(field[n + 1].start,\n\t\t\t\t    field[n + 1].end, &permset)) {\n\t\t\t\t\t/* This is Solaris-style \""other:rwx\"" */\n\t\t\t\t\tsol = 1;\n\t\t\t\t} else if (fields == (n + 3) &&\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field */\n\t\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\t\tif (id != -1 ||\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\tname = field[n + 1];\n\t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\t\telse\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \""default:\"" we expect mode in field 3\n\t\t\t * Exception: Solaris other and mask fields\n\t\t\t */\n\t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,\n\t\t\t    field[n + 2 - sol].end, &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\ttag = 0;\n\n\t\t\tswitch (len) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(s, \""user\"", 4) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(s, \""group\"", 5) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(s, \""owner@\"", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\telse if (memcmp(s, \""group@\"", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(s, \""everyone@\"", 9) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||\n\t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {\n\t\t\t\tn = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.start, name.end, &id);\n\t\t\t} else\n\t\t\t\tn = 0;\n\n\t\t\tif (!is_nfs4_perms(field[1 + n].start,\n\t\t\t    field[1 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(field[2 + n].start,\n\t\t\t    field[2 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = field[3 + n].start;\n\t\t\tlen = field[3 + n].end - field[3 + n].start;\n\t\t\ttype = 0;\n\t\t\tif (len == 4) {\n\t\t\t\tif (memcmp(s, \""deny\"", 4) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t} else if (len == 5) {\n\t\t\t\tif (memcmp(s, \""allow\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\telse if (memcmp(s, \""audit\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\telse if (memcmp(s, \""alarm\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t}\n\t\t\tif (type == 0) {\n\t\t\t\t/* Invalid entry type, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(field[4 + n].start, field[4 + n].end,\n\t\t\t    &id);\n\t\t}\n\n\t\t/* Add entry to the internal list. */\n\t\tr = archive_acl_add_entry_len_l(acl, type, permset,\n\t\t    tag, id, name.start, name.end - name.start, sc);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tret = ARCHIVE_WARN;\n\t\ttypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl_reset(acl, types);\n\n\treturn (ret);\n}"", ""target"": 0}]","[{""func_name"": ""archive_acl_from_text_l"", ""file_path"": ""libarchive/archive_acl.c"", ""func_code"": ""int\narchive_acl_from_text_l(struct archive_acl *acl, const char *text,\n    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == '#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = 0;\n\t\tsol = 0;\n\t\tid = -1;\n\t\tpermset = 0;\n\t\tname.start = name.end = NULL;\n\n\t\tif (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/* POSIX.1e ACLs */\n\t\t\t/*\n\t\t\t * Default keyword \""default:user::rwx\""\n\t\t\t * if found, we have one more field\n\t\t\t *\n\t\t\t * We also support old Solaris extension:\n\t\t\t * \""defaultuser::rwx\"" is the default ACL corresponding\n\t\t\t * to \""user::rwx\"", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \""efault\"", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tif (len == 0) {\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ser\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""roup\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""ther\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ask\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (tag) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\t\tif (fields == (n + 2)\n\t\t\t\t    && field[n + 1].start < field[n + 1].end\n\t\t\t\t    && ismode(field[n + 1].start,\n\t\t\t\t    field[n + 1].end, &permset)) {\n\t\t\t\t\t/* This is Solaris-style \""other:rwx\"" */\n\t\t\t\t\tsol = 1;\n\t\t\t\t} else if (fields == (n + 3) &&\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\t/* Invalid mask or other field */\n\t\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\t\tif (id != -1 ||\n\t\t\t\t    field[n + 1].start < field[n + 1].end) {\n\t\t\t\t\tname = field[n + 1];\n\t\t\t\t\tif (tag == ARCHIVE_ENTRY_ACL_USER_OBJ)\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\t\telse\n\t\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Without \""default:\"" we expect mode in field 3\n\t\t\t * Exception: Solaris other and mask fields\n\t\t\t */\n\t\t\tif (permset == 0 && !ismode(field[n + 2 - sol].start,\n\t\t\t    field[n + 2 - sol].end, &permset)) {\n\t\t\t\t/* Invalid mode, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* NFS4 ACLs */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\ttag = 0;\n\n\t\t\tswitch (len) {\n\t\t\tcase 4:\n\t\t\t\tif (memcmp(s, \""user\"", 4) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (memcmp(s, \""group\"", 5) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (memcmp(s, \""owner@\"", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\telse if (memcmp(s, \""group@\"", 6) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (memcmp(s, \""everyone@\"", 9) == 0)\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_EVERYONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tag == 0) {\n\t\t\t\t/* Invalid tag, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t} else if (tag == ARCHIVE_ENTRY_ACL_USER ||\n\t\t\t    tag == ARCHIVE_ENTRY_ACL_GROUP) {\n\t\t\t\tn = 1;\n\t\t\t\tname = field[1];\n\t\t\t\tisint(name.start, name.end, &id);\n\t\t\t} else\n\t\t\t\tn = 0;\n\n\t\t\tif (!is_nfs4_perms(field[1 + n].start,\n\t\t\t    field[1 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 perms, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!is_nfs4_flags(field[2 + n].start,\n\t\t\t    field[2 + n].end, &permset)) {\n\t\t\t\t/* Invalid NFSv4 flags, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts = field[3 + n].start;\n\t\t\tlen = field[3 + n].end - field[3 + n].start;\n\t\t\ttype = 0;\n\t\t\tif (len == 4) {\n\t\t\t\tif (memcmp(s, \""deny\"", 4) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DENY;\n\t\t\t} else if (len == 5) {\n\t\t\t\tif (memcmp(s, \""allow\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;\n\t\t\t\telse if (memcmp(s, \""audit\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;\n\t\t\t\telse if (memcmp(s, \""alarm\"", 5) == 0)\n\t\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_ALARM;\n\t\t\t}\n\t\t\tif (type == 0) {\n\t\t\t\t/* Invalid entry type, skip entry */\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisint(field[4 + n].start, field[4 + n].end,\n\t\t\t    &id);\n\t\t}\n\n\t\t/* Add entry to the internal list. */\n\t\tr = archive_acl_add_entry_len_l(acl, type, permset,\n\t\t    tag, id, name.start, name.end - name.start, sc);\n\t\tif (r < ARCHIVE_WARN)\n\t\t\treturn (r);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tret = ARCHIVE_WARN;\n\t\ttypes |= type;\n\t}\n\n\t/* Reset ACL */\n\tarchive_acl_reset(acl, types);\n\n\treturn (ret);\n}""}]","{""code"": 4, ""value"": 3, ""function"": 2}","[{""source"": ""code_info(file:archive_acl.c, lines:1720-1730)"", ""result"": ""\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ser\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n""}, {""source"": ""value_info(file:archive_acl.c, value:s)"", ""result"": {""value_trace"": [{""full_code"": ""s = (char *)malloc(length * sizeof(char))"", ""line"": 938, ""func_name"": ""archive_acl_to_text_l""}, {""full_code"": ""s = field[0].start"", ""line"": 1219, ""func_name"": ""archive_acl_from_text_w""}, {""full_code"": ""s = field[n].start"", ""line"": 1239, ""func_name"": ""archive_acl_from_text_w""}, {""full_code"": ""s = field[0].start"", ""line"": 1313, ""func_name"": ""archive_acl_from_text_w""}], ""struct_var"": ""s"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""code_info(file:archive_acl.c, lines:1700-1750)"", ""result"": ""\t\t\t * to \""user::rwx\"", etc. valid only for first field\n\t\t\t */\n\t\t\ts = field[0].start;\n\t\t\tlen = field[0].end - field[0].start;\n\t\t\tif (*s == 'd' && (len == 1 || (len >= 7\n\t\t\t    && memcmp((s + 1), \""efault\"", 6) == 0))) {\n\t\t\t\ttype = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;\n\t\t\t\tif (len > 7)\n\t\t\t\t\tfield[0].start += 7;\n\t\t\t\telse\n\t\t\t\t\tn = 1;\n\t\t\t} else\n\t\t\t\ttype = want_type;\n\n\t\t\t/* Check for a numeric ID in field n+1 or n+3. */\n\t\t\tisint(field[n + 1].start, field[n + 1].end, &id);\n\t\t\t/* Field n+3 is optional. */\n\t\t\tif (id == -1 && fields > (n + 3))\n\t\t\t\tisint(field[n + 3].start, field[n + 3].end,\n\t\t\t\t    &id);\n\n\t\t\ttag = 0;\n\t\t\ts = field[n].start;\n\t\t\tst = field[n].start + 1;\n\t\t\tlen = field[n].end - field[n].start;\n\n\t\t\tswitch (*s) {\n\t\t\tcase 'u':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ser\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_USER_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""roup\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (len == 1 || (len == 5\n\t\t\t\t    && memcmp(st, \""ther\"", 4) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_OTHER;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (len == 1 || (len == 4\n\t\t\t\t    && memcmp(st, \""ask\"", 3) == 0))\n\t\t\t\t\ttag = ARCHIVE_ENTRY_ACL_MASK;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n""}, {""source"": ""value_info(file:archive_acl.c, value:field)"", ""result"": {""value_trace"": [{""full_code"": ""field[6]"", ""line"": 1151, ""func_name"": ""archive_acl_from_text_w""}, {""full_code"": ""field[6]"", ""line"": 1635, ""func_name"": ""archive_acl_from_text_l""}], ""struct_var"": ""field"", ""struct_type"": ""std.array"", ""struct_definition"": null}}, {""source"": ""code_info(file:archive_acl.c, lines:1150-1200)"", ""result"": ""\t\tconst wchar_t *end;\n\t} field[6], name;\n\n\tconst wchar_t *s, *st;\n\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\twchar_t sep;\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\twhile (text != NULL && *text != L'\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst wchar_t *start, *end;\n\t\t\tnext_field_w(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == L':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n\t\tif (field[0].start != NULL && *(field[0].start) == L'#') {\n\t\t\t/* Comment, skip entry */\n\t\t\tcontinue;\n""}, {""source"": ""code_info(file:archive_acl.c, lines:1630-1680)"", ""result"": ""    int want_type, struct archive_string_conv *sc)\n{\n\tstruct {\n\t\tconst char *start;\n\t\tconst char *end;\n\t} field[6], name;\n\n\tconst char *s, *st;\n\tint numfields, fields, n, r, sol, ret;\n\tint type, types, tag, permset, id;\n\tsize_t len;\n\tchar sep;\n\n\tswitch (want_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\twant_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;\n\t\t__LA_FALLTHROUGH;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tnumfields = 5;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tnumfields = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tret = ARCHIVE_OK;\n\ttypes = 0;\n\n\twhile (text != NULL &&  *text != '\\0') {\n\t\t/*\n\t\t * Parse the fields out of the next entry,\n\t\t * advance 'text' to start of next entry.\n\t\t */\n\t\tfields = 0;\n\t\tdo {\n\t\t\tconst char *start, *end;\n\t\t\tnext_field(&text, &start, &end, &sep);\n\t\t\tif (fields < numfields) {\n\t\t\t\tfield[fields].start = start;\n\t\t\t\tfield[fields].end = end;\n\t\t\t}\n\t\t\t++fields;\n\t\t} while (sep == ':');\n\n\t\t/* Set remaining fields to blank. */\n\t\tfor (n = fields; n < numfields; ++n)\n\t\t\tfield[n].start = field[n].end = NULL;\n\n""}, {""source"": ""value_info(file:archive_acl.c, value:field)"", ""result"": {""value_trace"": [{""full_code"": ""field[6]"", ""line"": 1151, ""func_name"": ""archive_acl_from_text_w""}, {""full_code"": ""field[6]"", ""line"": 1635, ""func_name"": ""archive_acl_from_text_l""}], ""struct_var"": ""field"", ""struct_type"": ""std.array"", ""struct_definition"": null}}, {""source"": ""func_info(file:archive_acl.c, func:next_field)"", ""result"": [{""code"": ""static void\nnext_field(const char **p, const char **start,\n    const char **end, char *sep)\n{\n\t/* Skip leading whitespace to find start of field. */\n\twhile (**p == ' ' || **p == '\\t' || **p == '\\n') {\n\t\t(*p)++;\n\t}\n\t*start = *p;\n\n\t/* Scan for the separator. */\n\twhile (**p != '\\0' && **p != ',' && **p != ':' && **p != '\\n' &&\n\t    **p != '#') {\n\t\t(*p)++;\n\t}\n\t*sep = **p;\n\n\t/* Locate end of field, trim trailing whitespace if necessary */\n\tif (*p == *start) {\n\t\t*end = *p;\n\t} else {\n\t\t*end = *p - 1;\n\t\twhile (**end == ' ' || **end == '\\t' || **end == '\\n') {\n\t\t\t(*end)--;\n\t\t}\n\t\t(*end)++;\n\t}\n\n\t/* Handle in-field comments */\n\tif (*sep == '#') {\n\t\twhile (**p != '\\0' && **p != ',' && **p != '\\n') {\n\t\t\t(*p)++;\n\t\t}\n\t\t*sep = **p;\n\t}\n\n\t/* Adjust scanner location. */\n\tif (**p != '\\0')\n\t\t(*p)++;\n}"", ""start_line"": 2061, ""end_line"": 2100, ""full_name"": ""next_field"", ""file_path"": ""libarchive/archive_acl.c""}]}, {""source"": ""func_info(file:archive_acl.c, func:next_field_w)"", ""result"": [{""code"": ""static void\nnext_field_w(const wchar_t **wp, const wchar_t **start,\n    const wchar_t **end, wchar_t *sep)\n{\n\t/* Skip leading whitespace to find start of field. */\n\twhile (**wp == L' ' || **wp == L'\\t' || **wp == L'\\n') {\n\t\t(*wp)++;\n\t}\n\t*start = *wp;\n\n\t/* Scan for the separator. */\n\twhile (**wp != L'\\0' && **wp != L',' && **wp != L':' &&\n\t    **wp != L'\\n' && **wp != L'#') {\n\t\t(*wp)++;\n\t}\n\t*sep = **wp;\n\n\t/* Locate end of field, trim trailing whitespace if necessary */\n\tif (*wp == *start) {\n\t\t*end = *wp;\n\t} else {\n\t\t*end = *wp - 1;\n\t\twhile (**end == L' ' || **end == L'\\t' || **end == L'\\n') {\n\t\t\t(*end)--;\n\t\t}\n\t\t(*end)++;\n\t}\n\n\t/* Handle in-field comments */\n\tif (*sep == L'#') {\n\t\twhile (**wp != L'\\0' && **wp != L',' && **wp != L'\\n') {\n\t\t\t(*wp)++;\n\t\t}\n\t\t*sep = **wp;\n\t}\n\n\t/* Adjust scanner location. */\n\tif (**wp != L'\\0')\n\t\t(*wp)++;\n}"", ""start_line"": 1576, ""end_line"": 1615, ""full_name"": ""next_field_w"", ""file_path"": ""libarchive/archive_acl.c""}]}]","libarchive/archive_acl.c:1726: Dereference of *s (s = field[n].start, which is 0x0) when len == 0. The 'field' array is initialized with up to numfields (5 or 6) entries. If parsed fields are insufficient, remaining entries (e.g., field[n]) have start/end = NULL (libarchive/archive_acl.c:1660-1665). For a malformed ACL with <numfields entries, len = 0 (due to field[n].end - field[n].start = 0), leading to *s dereference of NULL. The patch adds len == 0 check to skip invalid fields.",0.95,./github/other_context/CVE-2018-1000879
62,CVE-2018-14524,CWE-415,c_cpp,dwg_decode_eed in decode.c in GNU LibreDWG before 0.6 leads to a double free (in dwg_free_eed in free.c) because it does not properly manage the obj->eed value after a free occurs.,https://github.com/LibreDWG/libredwg/commit/9a8b9fb49108bab5d12f3353292f8fd8ea12898f,"free: improve eed double-free\n\nFixes [GH #33], detected by jinyu00",2,"[{""func_name"": ""dwg_decode_eed"", ""file_path"": ""src/decode.c"", ""func_code"": ""static int\ndwg_decode_eed(Bit_Chain * dat, Dwg_Object_Object * obj)\n{\n  BITCODE_BS size;\n  unsigned int idx = 0;\n  int error = 0;\n  Dwg_Data *dwg = obj->dwg;\n\n  obj->num_eed = 0;\n  while ((size = bit_read_BS(dat)))\n    {\n      int i;\n      BITCODE_BS j;\n      BITCODE_RC code = 0;\n      long unsigned int end, offset;\n      long unsigned int sav_byte;\n      Dwg_Object *_obj = &dwg->object[obj->objid];\n\n      LOG_TRACE(\""EED[%u] size: \"" FORMAT_BS \""\\n\"", idx, size);\n      if (size > _obj->size)\n        {\n          LOG_ERROR(\""Invalid EED size \"" FORMAT_BS \"" > %u\"", size, _obj->size)\n          obj->num_eed = 0;\n          return DWG_ERR_INVALIDEED; /* may continue */\n        }\n\n      if (idx) {\n        obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n        memset(&obj->eed[idx], 0, sizeof(Dwg_Eed));\n      } else {\n        obj->eed = (Dwg_Eed*)calloc(1, sizeof(Dwg_Eed));\n      }\n      obj->eed[idx].size = size;\n      error = bit_read_H(dat, &obj->eed[idx].handle);\n      if (error) {\n        LOG_ERROR(\""No EED[%d].handle\"", idx);\n        obj->num_eed = 0;\n        free(obj->eed);\n        return error;\n      } else {\n        end = dat->byte + size;\n        LOG_TRACE(\""EED[%u] handle: %d.%d.%lX\\n\"", idx,\n                  obj->eed[idx].handle.code, obj->eed[idx].handle.size,\n                  obj->eed[idx].handle.value);\n        if (_obj->supertype == DWG_SUPERTYPE_OBJECT &&\n            _obj->dxfname &&\n            !strcmp(_obj->dxfname, \""MLEADERSTYLE\""))\n          { // check for is_new_format: has extended data for APPID \u201cACAD_MLEADERVER\u201d\n            Dwg_Object_Ref ref;\n            ref.obj = NULL;\n            ref.handleref = obj->eed[idx].handle;\n            ref.absolute_ref = 0L;\n            if (dwg_resolve_handleref(&ref, _obj))\n              {\n                Dwg_Object_APPID_CONTROL *appid = &dwg->appid_control;\n                // search absref in APPID_CONTROL apps[]\n                for (j=0; j < appid->num_entries; j++)\n                  {\n                    if ( appid->apps[j]->absolute_ref == ref.absolute_ref )\n                      {\n                        Dwg_Object_MLEADERSTYLE *this = obj->tio.MLEADERSTYLE;\n                        this->is_new_format = 1;\n                        LOG_TRACE(\""EED found ACAD_MLEADERVER %lu: new format\\n\"",\n                                  ref.absolute_ref);\n                      }\n                  }\n              }\n          }\n      }\n\n      sav_byte = dat->byte;\n      obj->eed[idx].raw = bit_read_TF(dat, size);\n      LOG_INSANE_TF(obj->eed[idx].raw, size);\n      dat->byte = sav_byte;\n\n      while (dat->byte < end)\n        {\n          int lenc;\n          BITCODE_RS lens;\n\n          obj->eed[idx].data = (Dwg_Eed_Data*)calloc(size + 8, 1);\n          obj->eed[idx].data->code = code = bit_read_RC(dat);\n          LOG_TRACE(\""EED[%u] code: %d\\n\"", idx, (int)code);\n          switch (code)\n            {\n            case 0:\n              PRE(R_2007) {\n                obj->eed[idx].data->u.eed_0.length = lenc = bit_read_RC(dat);\n                obj->eed[idx].data->u.eed_0.codepage = bit_read_RS_LE(dat);\n                if (lenc > size-4)\n                  {\n                    LOG_ERROR(\""Invalid EED string len %d, max %d\"", lenc, size-4);\n                    dat->byte = end;\n                    break;\n#if 0\n\n                    obj->num_eed = 0;\n                    if (obj->eed[idx].size)\n                      free(obj->eed[idx].raw);\n                    free(obj->eed[idx].data);\n                    free(obj->eed);\n                    dat->byte = end;\n                    return DWG_ERR_VALUEOUTOFBOUNDS; /* may not continue */\n#endif\n                  }\n                /* code:1 + len:1 + cp:2 */\n                bit_read_fixed(dat, obj->eed[idx].data->u.eed_0.string, lenc);\n                obj->eed[idx].data->u.eed_0.string[lenc] = '\\0';\n                LOG_TRACE(\""EED[%u] string: \\\""%s\\\"" len=%d cp=%d\\n\"", idx,\n                          obj->eed[idx].data->u.eed_0.string, (int)lenc,\n                          (int)obj->eed[idx].data->u.eed_0.codepage);\n              } LATER_VERSIONS {\n                obj->eed[idx].data->u.eed_0_r2007.length = lens = bit_read_RS(dat);\n                /* code:1 + len:2 NUL? */\n                for (j=0; j < MIN(lens,(size-3)/2); j++)\n                  obj->eed[idx].data->u.eed_0_r2007.string[j] = bit_read_RS_LE(dat);\n                //obj->eed[idx].data->u.eed_0_r2007.string[j] = 0; //already calloc'ed\n#ifdef _WIN32\n                LOG_TRACE(\""EED[%u] string: \\\""\"" FORMAT_TU \""\\\"" len=%d\\n\"", idx,\n                          obj->eed[idx].data->u.eed_0_r2007.string, (int)lens);\n#endif\n              }\n              break;\n            case 2:\n              obj->eed[idx].data->u.eed_2.byte = bit_read_RC(dat);\n              LOG_TRACE(\""EED[%u] byte: \"" FORMAT_RC \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_2.byte);\n              break;\n            case 3:\n            case 5:\n              obj->eed[idx].data->u.eed_3.layer = bit_read_RL(dat);\n              LOG_TRACE(\""EED[%u] layer/...: \"" FORMAT_RL \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_3.layer);\n              break;\n            case 4:\n              obj->eed[idx].data->u.eed_4.length = lenc = bit_read_RC(dat);\n              /* code:1 + len:1 */\n              for (j=0; j < MIN(lenc,size-2); j++)\n                obj->eed[idx].data->u.eed_4.data[j] = bit_read_RC(dat);\n              LOG_TRACE(\""EED[%u] raw: %s\\n\"", idx, obj->eed[idx].data->u.eed_4.data);\n              break;\n            case 10: case 11: case 12: case 13: /*case 14: case 15:*/\n              obj->eed[idx].data->u.eed_10.point.x = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.y = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.z = bit_read_RD(dat);\n              LOG_TRACE(\""EED[%u] 3dpoint: %f, %f, %f\\n\"", idx,\n                        obj->eed[idx].data->u.eed_10.point.x,\n                        obj->eed[idx].data->u.eed_10.point.y,\n                        obj->eed[idx].data->u.eed_10.point.z);\n              break;\n            case 40: case 41: case 42: /*case 43: case 44: case 45: case 46:\n            case 51: case 54:*/\n              obj->eed[idx].data->u.eed_40.real = bit_read_RD(dat);\n              LOG_TRACE(\""EED[%u] real: %f\\n\"", idx,\n                        obj->eed[idx].data->u.eed_40.real);\n              break;\n            case 70:\n              obj->eed[idx].data->u.eed_70.rs = bit_read_RS(dat);\n              LOG_TRACE(\""EED[%u] short: \"" FORMAT_RS \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_70.rs);\n              break;\n            case 71:\n              obj->eed[idx].data->u.eed_71.rl = bit_read_RL(dat);\n              LOG_TRACE(\""EED[%u] long: \"" FORMAT_RL \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_71.rl);\n              break;\n            default:\n              LOG_ERROR(\""Unknown EED code %d\"", code);\n              dat->byte = end;\n              return DWG_ERR_INVALIDTYPE; /* may continue */\n            }\n#ifdef DEBUG\n          // sanity checks\n          if (code == 0 || code == 4)\n            assert(obj->eed[idx].data->u.eed_0.length <= size-1);\n          if (code == 10) // 3 double\n            assert(size >= 1 + 3*8);\n#endif\n\n          idx++;\n          obj->num_eed++;\n          if (dat->byte < end-1)\n            {\n              size = (long)(end - dat->byte + 1);\n              LOG_INSANE(\""EED[%u] size remaining: %ld\\n\"", idx, (long)size);\n\n              obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n              obj->eed[idx].handle = obj->eed[idx-1].handle;\n              obj->eed[idx].size = 0;\n              obj->eed[idx].raw = NULL;\n            }\n        }\n      dat->byte = end;\n    }\n  return error;\n}"", ""target"": 0}, {""func_name"": ""dwg_free_eed"", ""file_path"": ""src/free.c"", ""func_code"": ""static void\ndwg_free_eed(Dwg_Object* obj)\n{\n  unsigned int i;\n  if (obj->supertype == DWG_SUPERTYPE_OBJECT) {\n    Dwg_Object_Object* _obj = obj->tio.object;\n    for (i=0; i < _obj->num_eed; i++) {\n      if (_obj->eed[i].size)\n        FREE_IF(_obj->eed[i].raw);\n      if (_obj->eed[i].data)\n        FREE_IF(_obj->eed[i].data);\n    }\n    FREE_IF(_obj->eed);\n  }\n  else if (obj->supertype == DWG_SUPERTYPE_ENTITY) {\n    Dwg_Object_Entity* _obj = obj->tio.entity;\n    for (i=0; i < _obj->num_eed; i++) {\n      if (_obj->eed[i].size)\n        FREE_IF(_obj->eed[i].raw);\n      if (_obj->eed[i].data)\n        FREE_IF(_obj->eed[i].data);\n    }\n    FREE_IF(_obj->eed);\n  }\n}"", ""target"": 0}]","[{""func_name"": ""dwg_decode_eed"", ""file_path"": ""src/decode.c"", ""func_code"": ""static int\ndwg_decode_eed(Bit_Chain * dat, Dwg_Object_Object * obj)\n{\n  BITCODE_BS size;\n  unsigned int idx = 0;\n  int error = 0;\n  Dwg_Data *dwg = obj->dwg;\n\n  obj->num_eed = 0;\n  while ((size = bit_read_BS(dat)))\n    {\n      int i;\n      BITCODE_BS j;\n      BITCODE_RC code = 0;\n      long unsigned int end, offset;\n      long unsigned int sav_byte;\n      Dwg_Object *_obj = &dwg->object[obj->objid];\n\n      LOG_TRACE(\""EED[%u] size: \"" FORMAT_BS \""\\n\"", idx, size);\n      if (size > _obj->size)\n        {\n          LOG_ERROR(\""Invalid EED size \"" FORMAT_BS \"" > %u\"", size, _obj->size)\n          obj->num_eed = 0;\n          return DWG_ERR_INVALIDEED; /* may continue */\n        }\n\n      if (idx) {\n        obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n        memset(&obj->eed[idx], 0, sizeof(Dwg_Eed));\n      } else {\n        obj->eed = (Dwg_Eed*)calloc(1, sizeof(Dwg_Eed));\n      }\n      obj->eed[idx].size = size;\n      error = bit_read_H(dat, &obj->eed[idx].handle);\n      if (error) {\n        LOG_ERROR(\""No EED[%d].handle\"", idx);\n        obj->num_eed = 0;\n        free(obj->eed);\n        obj->eed = NULL;\n        return error;\n      } else {\n        end = dat->byte + size;\n        LOG_TRACE(\""EED[%u] handle: %d.%d.%lX\\n\"", idx,\n                  obj->eed[idx].handle.code, obj->eed[idx].handle.size,\n                  obj->eed[idx].handle.value);\n        if (_obj->supertype == DWG_SUPERTYPE_OBJECT &&\n            _obj->dxfname &&\n            !strcmp(_obj->dxfname, \""MLEADERSTYLE\""))\n          { // check for is_new_format: has extended data for APPID \u201cACAD_MLEADERVER\u201d\n            Dwg_Object_Ref ref;\n            ref.obj = NULL;\n            ref.handleref = obj->eed[idx].handle;\n            ref.absolute_ref = 0L;\n            if (dwg_resolve_handleref(&ref, _obj))\n              {\n                Dwg_Object_APPID_CONTROL *appid = &dwg->appid_control;\n                // search absref in APPID_CONTROL apps[]\n                for (j=0; j < appid->num_entries; j++)\n                  {\n                    if ( appid->apps[j]->absolute_ref == ref.absolute_ref )\n                      {\n                        Dwg_Object_MLEADERSTYLE *this = obj->tio.MLEADERSTYLE;\n                        this->is_new_format = 1;\n                        LOG_TRACE(\""EED found ACAD_MLEADERVER %lu: new format\\n\"",\n                                  ref.absolute_ref);\n                      }\n                  }\n              }\n          }\n      }\n\n      sav_byte = dat->byte;\n      obj->eed[idx].raw = bit_read_TF(dat, size);\n      LOG_INSANE_TF(obj->eed[idx].raw, size);\n      dat->byte = sav_byte;\n\n      while (dat->byte < end)\n        {\n          int lenc;\n          BITCODE_RS lens;\n\n          obj->eed[idx].data = (Dwg_Eed_Data*)calloc(size + 8, 1);\n          obj->eed[idx].data->code = code = bit_read_RC(dat);\n          LOG_TRACE(\""EED[%u] code: %d\\n\"", idx, (int)code);\n          switch (code)\n            {\n            case 0:\n              PRE(R_2007) {\n                obj->eed[idx].data->u.eed_0.length = lenc = bit_read_RC(dat);\n                obj->eed[idx].data->u.eed_0.codepage = bit_read_RS_LE(dat);\n                if (lenc > size-4)\n                  {\n                    LOG_ERROR(\""Invalid EED string len %d, max %d\"", lenc, size-4);\n                    dat->byte = end;\n                    break;\n#if 0\n\n                    obj->num_eed = 0;\n                    if (obj->eed[idx].size)\n                      free(obj->eed[idx].raw);\n                    free(obj->eed[idx].data);\n                    free(obj->eed);\n                    obj->eed = NULL;\n                    dat->byte = end;\n                    return DWG_ERR_VALUEOUTOFBOUNDS; /* may not continue */\n#endif\n                  }\n                /* code:1 + len:1 + cp:2 */\n                bit_read_fixed(dat, obj->eed[idx].data->u.eed_0.string, lenc);\n                obj->eed[idx].data->u.eed_0.string[lenc] = '\\0';\n                LOG_TRACE(\""EED[%u] string: \\\""%s\\\"" len=%d cp=%d\\n\"", idx,\n                          obj->eed[idx].data->u.eed_0.string, (int)lenc,\n                          (int)obj->eed[idx].data->u.eed_0.codepage);\n              } LATER_VERSIONS {\n                obj->eed[idx].data->u.eed_0_r2007.length = lens = bit_read_RS(dat);\n                /* code:1 + len:2 NUL? */\n                for (j=0; j < MIN(lens,(size-3)/2); j++)\n                  obj->eed[idx].data->u.eed_0_r2007.string[j] = bit_read_RS_LE(dat);\n                //obj->eed[idx].data->u.eed_0_r2007.string[j] = 0; //already calloc'ed\n#ifdef _WIN32\n                LOG_TRACE(\""EED[%u] string: \\\""\"" FORMAT_TU \""\\\"" len=%d\\n\"", idx,\n                          obj->eed[idx].data->u.eed_0_r2007.string, (int)lens);\n#endif\n              }\n              break;\n            case 2:\n              obj->eed[idx].data->u.eed_2.byte = bit_read_RC(dat);\n              LOG_TRACE(\""EED[%u] byte: \"" FORMAT_RC \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_2.byte);\n              break;\n            case 3:\n            case 5:\n              obj->eed[idx].data->u.eed_3.layer = bit_read_RL(dat);\n              LOG_TRACE(\""EED[%u] layer/...: \"" FORMAT_RL \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_3.layer);\n              break;\n            case 4:\n              obj->eed[idx].data->u.eed_4.length = lenc = bit_read_RC(dat);\n              /* code:1 + len:1 */\n              for (j=0; j < MIN(lenc,size-2); j++)\n                obj->eed[idx].data->u.eed_4.data[j] = bit_read_RC(dat);\n              LOG_TRACE(\""EED[%u] raw: %s\\n\"", idx, obj->eed[idx].data->u.eed_4.data);\n              break;\n            case 10: case 11: case 12: case 13: /*case 14: case 15:*/\n              obj->eed[idx].data->u.eed_10.point.x = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.y = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.z = bit_read_RD(dat);\n              LOG_TRACE(\""EED[%u] 3dpoint: %f, %f, %f\\n\"", idx,\n                        obj->eed[idx].data->u.eed_10.point.x,\n                        obj->eed[idx].data->u.eed_10.point.y,\n                        obj->eed[idx].data->u.eed_10.point.z);\n              break;\n            case 40: case 41: case 42: /*case 43: case 44: case 45: case 46:\n            case 51: case 54:*/\n              obj->eed[idx].data->u.eed_40.real = bit_read_RD(dat);\n              LOG_TRACE(\""EED[%u] real: %f\\n\"", idx,\n                        obj->eed[idx].data->u.eed_40.real);\n              break;\n            case 70:\n              obj->eed[idx].data->u.eed_70.rs = bit_read_RS(dat);\n              LOG_TRACE(\""EED[%u] short: \"" FORMAT_RS \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_70.rs);\n              break;\n            case 71:\n              obj->eed[idx].data->u.eed_71.rl = bit_read_RL(dat);\n              LOG_TRACE(\""EED[%u] long: \"" FORMAT_RL \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_71.rl);\n              break;\n            default:\n              LOG_ERROR(\""Unknown EED code %d\"", code);\n              dat->byte = end;\n              return DWG_ERR_INVALIDTYPE; /* may continue */\n            }\n#ifdef DEBUG\n          // sanity checks\n          if (code == 0 || code == 4)\n            assert(obj->eed[idx].data->u.eed_0.length <= size-1);\n          if (code == 10) // 3 double\n            assert(size >= 1 + 3*8);\n#endif\n\n          idx++;\n          obj->num_eed++;\n          if (dat->byte < end-1)\n            {\n              size = (long)(end - dat->byte + 1);\n              LOG_INSANE(\""EED[%u] size remaining: %ld\\n\"", idx, (long)size);\n\n              obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n              obj->eed[idx].handle = obj->eed[idx-1].handle;\n              obj->eed[idx].size = 0;\n              obj->eed[idx].raw = NULL;\n            }\n        }\n      dat->byte = end;\n    }\n  return error;\n}""}, {""func_name"": ""dwg_free_eed"", ""file_path"": ""src/free.c"", ""func_code"": ""static void\ndwg_free_eed(Dwg_Object* obj)\n{\n  unsigned int i;\n  if (obj->supertype == DWG_SUPERTYPE_OBJECT) {\n    Dwg_Object_Object* _obj = obj->tio.object;\n    for (i=0; i < _obj->num_eed; i++) {\n      if (_obj->eed[i].size)\n        FREE_IF(_obj->eed[i].raw);\n      FREE_IF(_obj->eed[i].data);\n    }\n    FREE_IF(_obj->eed);\n  }\n  else if (obj->supertype == DWG_SUPERTYPE_ENTITY) {\n    Dwg_Object_Entity* _obj = obj->tio.entity;\n    for (i=0; i < _obj->num_eed; i++) {\n      if (_obj->eed[i].size)\n        FREE_IF(_obj->eed[i].raw);\n      FREE_IF(_obj->eed[i].data);\n    }\n    FREE_IF(_obj->eed);\n  }\n}""}]","{""function"": 2, ""code"": 2, ""value"": 1}","[{""source"": ""func_info(file:decode.c, func:dwg_decode_eed)"", ""result"": [{""code"": ""static int\ndwg_decode_eed(Bit_Chain * dat, Dwg_Object_Object * obj)\n{\n  BITCODE_BS size;\n  unsigned int idx = 0;\n  int error = 0;\n  Dwg_Data *dwg = obj->dwg;\n\n  obj->num_eed = 0;\n  while ((size = bit_read_BS(dat)))\n    {\n      int i;\n      BITCODE_BS j;\n      BITCODE_RC code = 0;\n      long unsigned int end, offset;\n      long unsigned int sav_byte;\n      Dwg_Object *_obj = &dwg->object[obj->objid];\n\n      LOG_TRACE(\""EED[%u] size: \"" FORMAT_BS \""\\n\"", idx, size);\n      if (size > _obj->size)\n        {\n          LOG_ERROR(\""Invalid EED size \"" FORMAT_BS \"" > %u\"", size, _obj->size)\n          obj->num_eed = 0;\n          return DWG_ERR_INVALIDEED; /* may continue */\n        }\n\n      if (idx) {\n        obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n        memset(&obj->eed[idx], 0, sizeof(Dwg_Eed));\n      } else {\n        obj->eed = (Dwg_Eed*)calloc(1, sizeof(Dwg_Eed));\n      }\n      obj->eed[idx].size = size;\n      error = bit_read_H(dat, &obj->eed[idx].handle);\n      if (error) {\n        LOG_ERROR(\""No EED[%d].handle\"", idx);\n        obj->num_eed = 0;\n        free(obj->eed);\n        return error;\n      } else {\n        end = dat->byte + size;\n        LOG_TRACE(\""EED[%u] handle: %d.%d.%lX\\n\"", idx,\n                  obj->eed[idx].handle.code, obj->eed[idx].handle.size,\n                  obj->eed[idx].handle.value);\n        if (_obj->supertype == DWG_SUPERTYPE_OBJECT &&\n            _obj->dxfname &&\n            !strcmp(_obj->dxfname, \""MLEADERSTYLE\""))\n          { // check for is_new_format: has extended data for APPID \u201cACAD_MLEADERVER\u201d\n            Dwg_Object_Ref ref;\n            ref.obj = NULL;\n            ref.handleref = obj->eed[idx].handle;\n            ref.absolute_ref = 0L;\n            if (dwg_resolve_handleref(&ref, _obj))\n              {\n                Dwg_Object_APPID_CONTROL *appid = &dwg->appid_control;\n                // search absref in APPID_CONTROL apps[]\n                for (j=0; j < appid->num_entries; j++)\n                  {\n                    if ( appid->apps[j]->absolute_ref == ref.absolute_ref )\n                      {\n                        Dwg_Object_MLEADERSTYLE *this = obj->tio.MLEADERSTYLE;\n                        this->is_new_format = 1;\n                        LOG_TRACE(\""EED found ACAD_MLEADERVER %lu: new format\\n\"",\n                                  ref.absolute_ref);\n                      }\n                  }\n              }\n          }\n      }\n\n      sav_byte = dat->byte;\n      obj->eed[idx].raw = bit_read_TF(dat, size);\n      LOG_INSANE_TF(obj->eed[idx].raw, size);\n      dat->byte = sav_byte;\n\n      while (dat->byte < end)\n        {\n          int lenc;\n          BITCODE_RS lens;\n\n          obj->eed[idx].data = (Dwg_Eed_Data*)calloc(size + 8, 1);\n          obj->eed[idx].data->code = code = bit_read_RC(dat);\n          LOG_TRACE(\""EED[%u] code: %d\\n\"", idx, (int)code);\n          switch (code)\n            {\n            case 0:\n              PRE(R_2007) {\n                obj->eed[idx].data->u.eed_0.length = lenc = bit_read_RC(dat);\n                obj->eed[idx].data->u.eed_0.codepage = bit_read_RS_LE(dat);\n                if (lenc > size-4)\n                  {\n                    LOG_ERROR(\""Invalid EED string len %d, max %d\"", lenc, size-4);\n                    dat->byte = end;\n                    break;\n#if 0\n\n                    obj->num_eed = 0;\n                    if (obj->eed[idx].size)\n                      free(obj->eed[idx].raw);\n                    free(obj->eed[idx].data);\n                    free(obj->eed);\n                    dat->byte = end;\n                    return DWG_ERR_VALUEOUTOFBOUNDS; /* may not continue */\n#endif\n                  }\n                /* code:1 + len:1 + cp:2 */\n                bit_read_fixed(dat, obj->eed[idx].data->u.eed_0.string, lenc);\n                obj->eed[idx].data->u.eed_0.string[lenc] = '\\0';\n                LOG_TRACE(\""EED[%u] string: \\\""%s\\\"" len=%d cp=%d\\n\"", idx,\n                          obj->eed[idx].data->u.eed_0.string, (int)lenc,\n                          (int)obj->eed[idx].data->u.eed_0.codepage);\n              } LATER_VERSIONS {\n                obj->eed[idx].data->u.eed_0_r2007.length = lens = bit_read_RS(dat);\n                /* code:1 + len:2 NUL? */\n                for (j=0; j < MIN(lens,(size-3)/2); j++)\n                  obj->eed[idx].data->u.eed_0_r2007.string[j] = bit_read_RS_LE(dat);\n                //obj->eed[idx].data->u.eed_0_r2007.string[j] = 0; //already calloc'ed\n#ifdef _WIN32\n                LOG_TRACE(\""EED[%u] string: \\\""\"" FORMAT_TU \""\\\"" len=%d\\n\"", idx,\n                          obj->eed[idx].data->u.eed_0_r2007.string, (int)lens);\n#endif\n              }\n              break;\n            case 2:\n              obj->eed[idx].data->u.eed_2.byte = bit_read_RC(dat);\n              LOG_TRACE(\""EED[%u] byte: \"" FORMAT_RC \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_2.byte);\n              break;\n            case 3:\n            case 5:\n              obj->eed[idx].data->u.eed_3.layer = bit_read_RL(dat);\n              LOG_TRACE(\""EED[%u] layer/...: \"" FORMAT_RL \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_3.layer);\n              break;\n            case 4:\n              obj->eed[idx].data->u.eed_4.length = lenc = bit_read_RC(dat);\n              /* code:1 + len:1 */\n              for (j=0; j < MIN(lenc,size-2); j++)\n                obj->eed[idx].data->u.eed_4.data[j] = bit_read_RC(dat);\n              LOG_TRACE(\""EED[%u] raw: %s\\n\"", idx, obj->eed[idx].data->u.eed_4.data);\n              break;\n            case 10: case 11: case 12: case 13: /*case 14: case 15:*/\n              obj->eed[idx].data->u.eed_10.point.x = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.y = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.z = bit_read_RD(dat);\n              LOG_TRACE(\""EED[%u] 3dpoint: %f, %f, %f\\n\"", idx,\n                        obj->eed[idx].data->u.eed_10.point.x,\n                        obj->eed[idx].data->u.eed_10.point.y,\n                        obj->eed[idx].data->u.eed_10.point.z);\n              break;\n            case 40: case 41: case 42: /*case 43: case 44: case 45: case 46:\n            case 51: case 54:*/\n              obj->eed[idx].data->u.eed_40.real = bit_read_RD(dat);\n              LOG_TRACE(\""EED[%u] real: %f\\n\"", idx,\n                        obj->eed[idx].data->u.eed_40.real);\n              break;\n            case 70:\n              obj->eed[idx].data->u.eed_70.rs = bit_read_RS(dat);\n              LOG_TRACE(\""EED[%u] short: \"" FORMAT_RS \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_70.rs);\n              break;\n            case 71:\n              obj->eed[idx].data->u.eed_71.rl = bit_read_RL(dat);\n              LOG_TRACE(\""EED[%u] long: \"" FORMAT_RL \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_71.rl);\n              break;\n            default:\n              LOG_ERROR(\""Unknown EED code %d\"", code);\n              dat->byte = end;\n              return DWG_ERR_INVALIDTYPE; /* may continue */\n            }\n#ifdef DEBUG\n          // sanity checks\n          if (code == 0 || code == 4)\n            assert(obj->eed[idx].data->u.eed_0.length <= size-1);\n          if (code == 10) // 3 double\n            assert(size >= 1 + 3*8);\n#endif\n\n          idx++;\n          obj->num_eed++;\n          if (dat->byte < end-1)\n            {\n              size = (long)(end - dat->byte + 1);\n              LOG_INSANE(\""EED[%u] size remaining: %ld\\n\"", idx, (long)size);\n\n              obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n              obj->eed[idx].handle = obj->eed[idx-1].handle;\n              obj->eed[idx].size = 0;\n              obj->eed[idx].raw = NULL;\n            }\n        }\n      dat->byte = end;\n    }\n  return error;\n}\n"", ""start_line"": 2274, ""end_line"": 2469, ""full_name"": ""dwg_decode_eed"", ""file_path"": ""src/decode.c""}]}, {""source"": ""code_info(file:decode.c, lines:2300-2400)"", ""result"": ""      if (idx) {\n        obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n        memset(&obj->eed[idx], 0, sizeof(Dwg_Eed));\n      } else {\n        obj->eed = (Dwg_Eed*)calloc(1, sizeof(Dwg_Eed));\n      }\n      obj->eed[idx].size = size;\n      error = bit_read_H(dat, &obj->eed[idx].handle);\n      if (error) {\n        LOG_ERROR(\""No EED[%d].handle\"", idx);\n        obj->num_eed = 0;\n        free(obj->eed);\n        return error;\n      } else {\n        end = dat->byte + size;\n        LOG_TRACE(\""EED[%u] handle: %d.%d.%lX\\n\"", idx,\n                  obj->eed[idx].handle.code, obj->eed[idx].handle.size,\n                  obj->eed[idx].handle.value);\n        if (_obj->supertype == DWG_SUPERTYPE_OBJECT &&\n            _obj->dxfname &&\n            !strcmp(_obj->dxfname, \""MLEADERSTYLE\""))\n          { // check for is_new_format: has extended data for APPID \u201cACAD_MLEADERVER\u201d\n            Dwg_Object_Ref ref;\n            ref.obj = NULL;\n            ref.handleref = obj->eed[idx].handle;\n            ref.absolute_ref = 0L;\n            if (dwg_resolve_handleref(&ref, _obj))\n              {\n                Dwg_Object_APPID_CONTROL *appid = &dwg->appid_control;\n                // search absref in APPID_CONTROL apps[]\n                for (j=0; j < appid->num_entries; j++)\n                  {\n                    if ( appid->apps[j]->absolute_ref == ref.absolute_ref )\n                      {\n                        Dwg_Object_MLEADERSTYLE *this = obj->tio.MLEADERSTYLE;\n                        this->is_new_format = 1;\n                        LOG_TRACE(\""EED found ACAD_MLEADERVER %lu: new format\\n\"",\n                                  ref.absolute_ref);\n                      }\n                  }\n              }\n          }\n      }\n\n      sav_byte = dat->byte;\n      obj->eed[idx].raw = bit_read_TF(dat, size);\n      LOG_INSANE_TF(obj->eed[idx].raw, size);\n      dat->byte = sav_byte;\n\n      while (dat->byte < end)\n        {\n          int lenc;\n          BITCODE_RS lens;\n\n          obj->eed[idx].data = (Dwg_Eed_Data*)calloc(size + 8, 1);\n          obj->eed[idx].data->code = code = bit_read_RC(dat);\n          LOG_TRACE(\""EED[%u] code: %d\\n\"", idx, (int)code);\n          switch (code)\n            {\n            case 0:\n              PRE(R_2007) {\n                obj->eed[idx].data->u.eed_0.length = lenc = bit_read_RC(dat);\n                obj->eed[idx].data->u.eed_0.codepage = bit_read_RS_LE(dat);\n                if (lenc > size-4)\n                  {\n                    LOG_ERROR(\""Invalid EED string len %d, max %d\"", lenc, size-4);\n                    dat->byte = end;\n                    break;\n#if 0\n\n                    obj->num_eed = 0;\n                    if (obj->eed[idx].size)\n                      free(obj->eed[idx].raw);\n                    free(obj->eed[idx].data);\n                    free(obj->eed);\n                    dat->byte = end;\n                    return DWG_ERR_VALUEOUTOFBOUNDS; /* may not continue */\n#endif\n                  }\n                /* code:1 + len:1 + cp:2 */\n                bit_read_fixed(dat, obj->eed[idx].data->u.eed_0.string, lenc);\n                obj->eed[idx].data->u.eed_0.string[lenc] = '\\0';\n                LOG_TRACE(\""EED[%u] string: \\\""%s\\\"" len=%d cp=%d\\n\"", idx,\n                          obj->eed[idx].data->u.eed_0.string, (int)lenc,\n                          (int)obj->eed[idx].data->u.eed_0.codepage);\n              } LATER_VERSIONS {\n                obj->eed[idx].data->u.eed_0_r2007.length = lens = bit_read_RS(dat);\n                /* code:1 + len:2 NUL? */\n                for (j=0; j < MIN(lens,(size-3)/2); j++)\n                  obj->eed[idx].data->u.eed_0_r2007.string[j] = bit_read_RS_LE(dat);\n                //obj->eed[idx].data->u.eed_0_r2007.string[j] = 0; //already calloc'ed\n#ifdef _WIN32\n                LOG_TRACE(\""EED[%u] string: \\\""\"" FORMAT_TU \""\\\"" len=%d\\n\"", idx,\n                          obj->eed[idx].data->u.eed_0_r2007.string, (int)lens);\n#endif\n              }\n              break;\n            case 2:\n              obj->eed[idx].data->u.eed_2.byte = bit_read_RC(dat);\n              LOG_TRACE(\""EED[%u] byte: \"" FORMAT_RC \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_2.byte);\n""}, {""source"": ""value_info(file:decode.c, value:obj->eed)"", ""result"": {""value_trace"": [{""full_code"": ""obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed))"", ""line"": 2301, ""func_name"": ""dwg_decode_eed""}, {""full_code"": ""obj->eed = (Dwg_Eed*)calloc(1, sizeof(Dwg_Eed))"", ""line"": 2304, ""func_name"": ""dwg_decode_eed""}, {""full_code"": ""obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed))"", ""line"": 2460, ""func_name"": ""dwg_decode_eed""}], ""struct_var"": ""obj"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:decode.c, lines:2400-2469)"", ""result"": ""                        obj->eed[idx].data->u.eed_2.byte);\n              break;\n            case 3:\n            case 5:\n              obj->eed[idx].data->u.eed_3.layer = bit_read_RL(dat);\n              LOG_TRACE(\""EED[%u] layer/...: \"" FORMAT_RL \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_3.layer);\n              break;\n            case 4:\n              obj->eed[idx].data->u.eed_4.length = lenc = bit_read_RC(dat);\n              /* code:1 + len:1 */\n              for (j=0; j < MIN(lenc,size-2); j++)\n                obj->eed[idx].data->u.eed_4.data[j] = bit_read_RC(dat);\n              LOG_TRACE(\""EED[%u] raw: %s\\n\"", idx, obj->eed[idx].data->u.eed_4.data);\n              break;\n            case 10: case 11: case 12: case 13: /*case 14: case 15:*/\n              obj->eed[idx].data->u.eed_10.point.x = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.y = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.z = bit_read_RD(dat);\n              LOG_TRACE(\""EED[%u] 3dpoint: %f, %f, %f\\n\"", idx,\n                        obj->eed[idx].data->u.eed_10.point.x,\n                        obj->eed[idx].data->u.eed_10.point.y,\n                        obj->eed[idx].data->u.eed_10.point.z);\n              break;\n            case 40: case 41: case 42: /*case 43: case 44: case 45: case 46:\n            case 51: case 54:*/\n              obj->eed[idx].data->u.eed_40.real = bit_read_RD(dat);\n              LOG_TRACE(\""EED[%u] real: %f\\n\"", idx,\n                        obj->eed[idx].data->u.eed_40.real);\n              break;\n            case 70:\n              obj->eed[idx].data->u.eed_70.rs = bit_read_RS(dat);\n              LOG_TRACE(\""EED[%u] short: \"" FORMAT_RS \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_70.rs);\n              break;\n            case 71:\n              obj->eed[idx].data->u.eed_71.rl = bit_read_RL(dat);\n              LOG_TRACE(\""EED[%u] long: \"" FORMAT_RL \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_71.rl);\n              break;\n            default:\n              LOG_ERROR(\""Unknown EED code %d\"", code);\n              dat->byte = end;\n              return DWG_ERR_INVALIDTYPE; /* may continue */\n            }\n#ifdef DEBUG\n          // sanity checks\n          if (code == 0 || code == 4)\n            assert(obj->eed[idx].data->u.eed_0.length <= size-1);\n          if (code == 10) // 3 double\n            assert(size >= 1 + 3*8);\n#endif\n\n          idx++;\n          obj->num_eed++;\n          if (dat->byte < end-1)\n            {\n              size = (long)(end - dat->byte + 1);\n              LOG_INSANE(\""EED[%u] size remaining: %ld\\n\"", idx, (long)size);\n\n              obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n              obj->eed[idx].handle = obj->eed[idx-1].handle;\n              obj->eed[idx].size = 0;\n              obj->eed[idx].raw = NULL;\n            }\n        }\n      dat->byte = end;\n    }\n  return error;\n}\n""}, {""source"": ""func_info(file:decode.c, func:dwg_decode_eed)"", ""result"": [{""code"": ""static int\ndwg_decode_eed(Bit_Chain * dat, Dwg_Object_Object * obj)\n{\n  BITCODE_BS size;\n  unsigned int idx = 0;\n  int error = 0;\n  Dwg_Data *dwg = obj->dwg;\n\n  obj->num_eed = 0;\n  while ((size = bit_read_BS(dat)))\n    {\n      int i;\n      BITCODE_BS j;\n      BITCODE_RC code = 0;\n      long unsigned int end, offset;\n      long unsigned int sav_byte;\n      Dwg_Object *_obj = &dwg->object[obj->objid];\n\n      LOG_TRACE(\""EED[%u] size: \"" FORMAT_BS \""\\n\"", idx, size);\n      if (size > _obj->size)\n        {\n          LOG_ERROR(\""Invalid EED size \"" FORMAT_BS \"" > %u\"", size, _obj->size)\n          obj->num_eed = 0;\n          return DWG_ERR_INVALIDEED; /* may continue */\n        }\n\n      if (idx) {\n        obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n        memset(&obj->eed[idx], 0, sizeof(Dwg_Eed));\n      } else {\n        obj->eed = (Dwg_Eed*)calloc(1, sizeof(Dwg_Eed));\n      }\n      obj->eed[idx].size = size;\n      error = bit_read_H(dat, &obj->eed[idx].handle);\n      if (error) {\n        LOG_ERROR(\""No EED[%d].handle\"", idx);\n        obj->num_eed = 0;\n        free(obj->eed);\n        return error;\n      } else {\n        end = dat->byte + size;\n        LOG_TRACE(\""EED[%u] handle: %d.%d.%lX\\n\"", idx,\n                  obj->eed[idx].handle.code, obj->eed[idx].handle.size,\n                  obj->eed[idx].handle.value);\n        if (_obj->supertype == DWG_SUPERTYPE_OBJECT &&\n            _obj->dxfname &&\n            !strcmp(_obj->dxfname, \""MLEADERSTYLE\""))\n          { // check for is_new_format: has extended data for APPID \u201cACAD_MLEADERVER\u201d\n            Dwg_Object_Ref ref;\n            ref.obj = NULL;\n            ref.handleref = obj->eed[idx].handle;\n            ref.absolute_ref = 0L;\n            if (dwg_resolve_handleref(&ref, _obj))\n              {\n                Dwg_Object_APPID_CONTROL *appid = &dwg->appid_control;\n                // search absref in APPID_CONTROL apps[]\n                for (j=0; j < appid->num_entries; j++)\n                  {\n                    if ( appid->apps[j]->absolute_ref == ref.absolute_ref )\n                      {\n                        Dwg_Object_MLEADERSTYLE *this = obj->tio.MLEADERSTYLE;\n                        this->is_new_format = 1;\n                        LOG_TRACE(\""EED found ACAD_MLEADERVER %lu: new format\\n\"",\n                                  ref.absolute_ref);\n                      }\n                  }\n              }\n          }\n      }\n\n      sav_byte = dat->byte;\n      obj->eed[idx].raw = bit_read_TF(dat, size);\n      LOG_INSANE_TF(obj->eed[idx].raw, size);\n      dat->byte = sav_byte;\n\n      while (dat->byte < end)\n        {\n          int lenc;\n          BITCODE_RS lens;\n\n          obj->eed[idx].data = (Dwg_Eed_Data*)calloc(size + 8, 1);\n          obj->eed[idx].data->code = code = bit_read_RC(dat);\n          LOG_TRACE(\""EED[%u] code: %d\\n\"", idx, (int)code);\n          switch (code)\n            {\n            case 0:\n              PRE(R_2007) {\n                obj->eed[idx].data->u.eed_0.length = lenc = bit_read_RC(dat);\n                obj->eed[idx].data->u.eed_0.codepage = bit_read_RS_LE(dat);\n                if (lenc > size-4)\n                  {\n                    LOG_ERROR(\""Invalid EED string len %d, max %d\"", lenc, size-4);\n                    dat->byte = end;\n                    break;\n#if 0\n\n                    obj->num_eed = 0;\n                    if (obj->eed[idx].size)\n                      free(obj->eed[idx].raw);\n                    free(obj->eed[idx].data);\n                    free(obj->eed);\n                    dat->byte = end;\n                    return DWG_ERR_VALUEOUTOFBOUNDS; /* may not continue */\n#endif\n                  }\n                /* code:1 + len:1 + cp:2 */\n                bit_read_fixed(dat, obj->eed[idx].data->u.eed_0.string, lenc);\n                obj->eed[idx].data->u.eed_0.string[lenc] = '\\0';\n                LOG_TRACE(\""EED[%u] string: \\\""%s\\\"" len=%d cp=%d\\n\"", idx,\n                          obj->eed[idx].data->u.eed_0.string, (int)lenc,\n                          (int)obj->eed[idx].data->u.eed_0.codepage);\n              } LATER_VERSIONS {\n                obj->eed[idx].data->u.eed_0_r2007.length = lens = bit_read_RS(dat);\n                /* code:1 + len:2 NUL? */\n                for (j=0; j < MIN(lens,(size-3)/2); j++)\n                  obj->eed[idx].data->u.eed_0_r2007.string[j] = bit_read_RS_LE(dat);\n                //obj->eed[idx].data->u.eed_0_r2007.string[j] = 0; //already calloc'ed\n#ifdef _WIN32\n                LOG_TRACE(\""EED[%u] string: \\\""\"" FORMAT_TU \""\\\"" len=%d\\n\"", idx,\n                          obj->eed[idx].data->u.eed_0_r2007.string, (int)lens);\n#endif\n              }\n              break;\n            case 2:\n              obj->eed[idx].data->u.eed_2.byte = bit_read_RC(dat);\n              LOG_TRACE(\""EED[%u] byte: \"" FORMAT_RC \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_2.byte);\n              break;\n            case 3:\n            case 5:\n              obj->eed[idx].data->u.eed_3.layer = bit_read_RL(dat);\n              LOG_TRACE(\""EED[%u] layer/...: \"" FORMAT_RL \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_3.layer);\n              break;\n            case 4:\n              obj->eed[idx].data->u.eed_4.length = lenc = bit_read_RC(dat);\n              /* code:1 + len:1 */\n              for (j=0; j < MIN(lenc,size-2); j++)\n                obj->eed[idx].data->u.eed_4.data[j] = bit_read_RC(dat);\n              LOG_TRACE(\""EED[%u] raw: %s\\n\"", idx, obj->eed[idx].data->u.eed_4.data);\n              break;\n            case 10: case 11: case 12: case 13: /*case 14: case 15:*/\n              obj->eed[idx].data->u.eed_10.point.x = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.y = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.z = bit_read_RD(dat);\n              LOG_TRACE(\""EED[%u] 3dpoint: %f, %f, %f\\n\"", idx,\n                        obj->eed[idx].data->u.eed_10.point.x,\n                        obj->eed[idx].data->u.eed_10.point.y,\n                        obj->eed[idx].data->u.eed_10.point.z);\n              break;\n            case 40: case 41: case 42: /*case 43: case 44: case 45: case 46:\n            case 51: case 54:*/\n              obj->eed[idx].data->u.eed_40.real = bit_read_RD(dat);\n              LOG_TRACE(\""EED[%u] real: %f\\n\"", idx,\n                        obj->eed[idx].data->u.eed_40.real);\n              break;\n            case 70:\n              obj->eed[idx].data->u.eed_70.rs = bit_read_RS(dat);\n              LOG_TRACE(\""EED[%u] short: \"" FORMAT_RS \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_70.rs);\n              break;\n            case 71:\n              obj->eed[idx].data->u.eed_71.rl = bit_read_RL(dat);\n              LOG_TRACE(\""EED[%u] long: \"" FORMAT_RL \""\\n\"", idx,\n                        obj->eed[idx].data->u.eed_71.rl);\n              break;\n            default:\n              LOG_ERROR(\""Unknown EED code %d\"", code);\n              dat->byte = end;\n              return DWG_ERR_INVALIDTYPE; /* may continue */\n            }\n#ifdef DEBUG\n          // sanity checks\n          if (code == 0 || code == 4)\n            assert(obj->eed[idx].data->u.eed_0.length <= size-1);\n          if (code == 10) // 3 double\n            assert(size >= 1 + 3*8);\n#endif\n\n          idx++;\n          obj->num_eed++;\n          if (dat->byte < end-1)\n            {\n              size = (long)(end - dat->byte + 1);\n              LOG_INSANE(\""EED[%u] size remaining: %ld\\n\"", idx, (long)size);\n\n              obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n              obj->eed[idx].handle = obj->eed[idx-1].handle;\n              obj->eed[idx].size = 0;\n              obj->eed[idx].raw = NULL;\n            }\n        }\n      dat->byte = end;\n    }\n  return error;\n}\n"", ""start_line"": 2274, ""end_line"": 2469, ""full_name"": ""dwg_decode_eed"", ""file_path"": ""src/decode.c""}]}]","In `dwg_decode_eed` (decode.c:2310, 2373), `obj->eed` is freed during error handling but not set to NULL. When `dwg_free_eed` (free.c:268-277) later frees `obj->eed`, this causes a double-free. The patch sets `obj->eed = NULL` after `free()` in these paths. The full `dwg_decode_eed` function shows no other error paths freeing `obj->eed` without nullification, confirming the root cause is fully addressed by the patch.",0.95,./github/other_context/CVE-2018-14524
63,CVE-2018-15858,CWE-476,c_cpp,Unchecked NULL pointer usage when handling invalid aliases in CopyKeyAliasesToKeymap in xkbcomp/keycodes.c in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file.,https://github.com/xkbcommon/libxkbcommon/commit/badb428e63387140720f22486b3acbd3d738859f,"keycodes: don't try to copy zero key aliases\n\nMove the aliases copy to within the (num_key_aliases > 0) block.\n\nPassing info->aliases into this fuction with invalid aliases will\ncause log messages but num_key_aliases stays on 0. The key_aliases array\nis never allocated and remains NULL. We then loop through the aliases, causing\na null-pointer dereference.\n\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>",1,"[{""func_name"": ""CopyKeyAliasesToKeymap"", ""file_path"": ""src/xkbcomp/keycodes.c"", ""func_code"": ""static bool\nCopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \""Attempt to alias %s to non-existent key %s; Ignored\\n\"",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \""Attempt to create alias with the name of a real key; \""\n                    \""Alias \\\""%s = %s\\\"" ignored\\n\"",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}"", ""target"": 0}]","[{""func_name"": ""CopyKeyAliasesToKeymap"", ""file_path"": ""src/xkbcomp/keycodes.c"", ""func_code"": ""static bool\nCopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \""Attempt to alias %s to non-existent key %s; Ignored\\n\"",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \""Attempt to create alias with the name of a real key; \""\n                    \""Alias \\\""%s = %s\\\"" ignored\\n\"",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n\n        i = 0;\n        darray_foreach(alias, info->aliases) {\n            if (alias->real != XKB_ATOM_NONE) {\n                key_aliases[i].alias = alias->alias;\n                key_aliases[i].real = alias->real;\n                i++;\n            }\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}""}]","{""code"": 1, ""value"": 1}","[{""source"": ""code_info(file:keycodes.c, lines:580-597)"", ""result"": ""        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \""Attempt to create alias with the name of a real key; \""\n                    \""Alias \\\""%s = %s\\\"" ignored\\n\"",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n""}, {""source"": ""value_info(file:keycodes.c, value:num_key_aliases)"", ""result"": {""value_trace"": [{""full_code"": ""num_key_aliases = 0"", ""line"": 567, ""func_name"": ""CopyKeyAliasesToKeymap""}, {""full_code"": ""num_key_aliases++"", ""line"": 590, ""func_name"": ""CopyKeyAliasesToKeymap""}], ""struct_var"": ""num_key_aliases"", ""struct_type"": ""unsigned"", ""struct_definition"": ""unsigned""}}]","src/xkbcomp/keycodes.c: The loop over info->aliases in CopyKeyAliasesToKeymap (lines 597-597) was executed without checking if num_key_aliases > 0. When invalid aliases are provided (e.g., aliases pointing to real keys), alias->real is set to XKB_ATOM_NONE (line 580-597), and num_key_aliases remains zero. Since key_aliases is only allocated if num_key_aliases > 0 (line 597), the loop dereferences a NULL pointer. The patch moves the loop into the num_key_aliases > 0 block to prevent this.",0.95,./github/other_context/CVE-2018-15858
64,CVE-2018-15855,CWE-476,c_cpp,"Unchecked NULL pointer usage in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because the XkbFile for an xkb_geometry section was mishandled.",https://github.com/xkbcommon/libxkbcommon/commit/917636b1d0d70205a13f89062b95e3a0fc31d4ff,"xkbcomp: fix crash when parsing an xkb_geometry section\n\nxkb_geometry sections are ignored; previously the had done so by\nreturning NULL for the section's XkbFile, however some sections of the\ncode do not expect this. Instead, create an XkbFile for it, it will\nnever be processes and discarded later.\n\nCaught with the afl fuzzer.\n\nSigned-off-by: Ran Benita <ran234@gmail.com>",1,"[{""func_name"": ""CompileKeymap"", ""file_path"": ""src/xkbcomp/keymap.c"", ""func_code"": ""bool\nCompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \""Cannot define %s in a keymap file\\n\"",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \""More than one %s section in keymap file; \""\n                    \""All sections after the first ignored\\n\"",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \""Required section %s missing from keymap\\n\"",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \""Compiling %s \\\""%s\\\""\\n\"",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \""Failed to compile %s\\n\"",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}"", ""target"": 0}]","[{""func_name"": ""CompileKeymap"", ""file_path"": ""src/xkbcomp/keymap.c"", ""func_code"": ""bool\nCompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            if (file->file_type == FILE_TYPE_GEOMETRY) {\n                log_vrb(ctx, 1,\n                        \""Geometry sections are not supported; ignoring\\n\"");\n            } else {\n                log_err(ctx, \""Cannot define %s in a keymap file\\n\"",\n                        xkb_file_type_to_string(file->file_type));\n            }\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \""More than one %s section in keymap file; \""\n                    \""All sections after the first ignored\\n\"",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \""Required section %s missing from keymap\\n\"",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \""Compiling %s \\\""%s\\\""\\n\"",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \""Failed to compile %s\\n\"",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}""}]","{""code"": 2, ""function"": 1}","[{""source"": ""code_info(file:keymap.c, lines:242-272)"", ""result"": ""        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \""Cannot define %s in a keymap file\\n\"",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \""More than one %s section in keymap file; \""\n                    \""All sections after the first ignored\\n\"",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \""Required section %s missing from keymap\\n\"",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n""}, {""source"": ""func_info(file:keymap.c, func:CompileKeymap)"", ""result"": [{""code"": ""bool\nCompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb"", ""start_line"": 231, ""end_line"": 293, ""full_name"": ""CompileKeymap"", ""file_path"": ""src/xkbcomp/keymap.c""}]}, {""source"": ""code_info(file:keymap.c, lines:273-293)"", ""result"": ""    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \""Compiling %s \\\""%s\\\""\\n\"",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \""Failed to compile %s\\n\"",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}\n""}]","The vulnerability was caused by a NULL pointer dereference in src/xkbcomp/keymap.c:277. Before the patch, geometry sections returned NULL for XkbFile. The code in CompileKeymap (src/xkbcomp/keymap.c:273-293) iterated over files[type], accessing files[type]->name without checking for NULL. This led to a crash when files[type] was NULL (e.g., for geometry sections). The patch ensures files[type] is always non-NULL by creating a dummy XkbFile for geometry sections, preventing the dereference.",0.95,./github/other_context/CVE-2018-15855
65,CVE-2018-17293,CWE-476,c_cpp,"An issue was discovered in WAVM before 2018-09-16. The run function in Programs/wavm/wavm.cpp does not check whether there is Emscripten memory to store the command-line arguments passed by the input WebAssembly file's main function, which allows attackers to cause a denial of service (application crash by NULL pointer dereference) or possibly have unspecified other impact by crafting certain WebAssembly files.",https://github.com/WAVM/WAVM/commit/31d670b6489e6d708c3b04b911cdf14ac43d846d,Fix dereferencing null pointer when running wavm with WebAssembly main function that takes command-line arguments but no Emscripten memory to write them to,1,"[{""func_name"": ""run"", ""file_path"": ""Programs/wavm/wavm.cpp"", ""func_code"": ""static int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \""wavm.precompiled_object\"")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Input file did not contain 'wavm.precompiled_object' section\"");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""env\"", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""asm2wasm\"", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""global\"", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\""threadTest\"", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \""Failed to link module:\\n\"");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\""Missing import: module=\\\""%s\\\"" export=\\\""%s\\\"" type=\\\""%s\\\""\\n\"",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \""main\""));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \""_main\"")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Module does not export main function\\n\"");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Module does not export '%s'\\n\"", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tMemoryInstance* defaultMemory = Runtime::getDefaultMemory(moduleInstance);\n\t\t\tif(!defaultMemory)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\""Module does not declare a default memory object to put arguments in.\\n\"");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\n\t\t\tstd::vector<const char*> argStrings;\n\t\t\targStrings.push_back(options.filename);\n\t\t\tchar** args = options.args;\n\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\""WebAssembly function requires %\"" PRIu64\n\t\t\t\t\t\t\"" argument(s), but only 0 or 2 can be passed!\"",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\""Cannot parse command-line argument for %s function parameter\"",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\""Invoked function\"", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\""%s returned: %s\\n\"",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""run"", ""file_path"": ""Programs/wavm/wavm.cpp"", ""func_code"": ""static int run(const CommandLineOptions& options)\n{\n\tIR::Module irModule;\n\n\t// Load the module.\n\tif(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }\n\tif(options.onlyCheck) { return EXIT_SUCCESS; }\n\n\t// Compile the module.\n\tRuntime::Module* module = nullptr;\n\tif(!options.precompiled) { module = Runtime::compileModule(irModule); }\n\telse\n\t{\n\t\tconst UserSection* precompiledObjectSection = nullptr;\n\t\tfor(const UserSection& userSection : irModule.userSections)\n\t\t{\n\t\t\tif(userSection.name == \""wavm.precompiled_object\"")\n\t\t\t{\n\t\t\t\tprecompiledObjectSection = &userSection;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!precompiledObjectSection)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Input file did not contain 'wavm.precompiled_object' section\"");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodule = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);\n\t\t}\n\t}\n\n\t// Link the module with the intrinsic modules.\n\tCompartment* compartment = Runtime::createCompartment();\n\tContext* context = Runtime::createContext(compartment);\n\tRootResolver rootResolver(compartment);\n\n\tEmscripten::Instance* emscriptenInstance = nullptr;\n\tif(options.enableEmscripten)\n\t{\n\t\temscriptenInstance = Emscripten::instantiate(compartment, irModule);\n\t\tif(emscriptenInstance)\n\t\t{\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""env\"", emscriptenInstance->env);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""asm2wasm\"", emscriptenInstance->asm2wasm);\n\t\t\trootResolver.moduleNameToInstanceMap.set(\""global\"", emscriptenInstance->global);\n\t\t}\n\t}\n\n\tif(options.enableThreadTest)\n\t{\n\t\tModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);\n\t\trootResolver.moduleNameToInstanceMap.set(\""threadTest\"", threadTestInstance);\n\t}\n\n\tLinkResult linkResult = linkModule(irModule, rootResolver);\n\tif(!linkResult.success)\n\t{\n\t\tLog::printf(Log::error, \""Failed to link module:\\n\"");\n\t\tfor(auto& missingImport : linkResult.missingImports)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\""Missing import: module=\\\""%s\\\"" export=\\\""%s\\\"" type=\\\""%s\\\""\\n\"",\n\t\t\t\t\t\tmissingImport.moduleName.c_str(),\n\t\t\t\t\t\tmissingImport.exportName.c_str(),\n\t\t\t\t\t\tasString(missingImport.type).c_str());\n\t\t}\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// Instantiate the module.\n\tModuleInstance* moduleInstance = instantiateModule(\n\t\tcompartment, module, std::move(linkResult.resolvedImports), options.filename);\n\tif(!moduleInstance) { return EXIT_FAILURE; }\n\n\t// Call the module start function, if it has one.\n\tFunctionInstance* startFunction = getStartFunction(moduleInstance);\n\tif(startFunction) { invokeFunctionChecked(context, startFunction, {}); }\n\n\tif(options.enableEmscripten)\n\t{\n\t\t// Call the Emscripten global initalizers.\n\t\tEmscripten::initializeGlobals(context, irModule, moduleInstance);\n\t}\n\n\t// Look up the function export to call.\n\tFunctionInstance* functionInstance;\n\tif(!options.functionName)\n\t{\n\t\tfunctionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \""main\""));\n\t\tif(!functionInstance)\n\t\t{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \""_main\"")); }\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Module does not export main function\\n\"");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfunctionInstance\n\t\t\t= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));\n\t\tif(!functionInstance)\n\t\t{\n\t\t\tLog::printf(Log::error, \""Module does not export '%s'\\n\"", options.functionName);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tFunctionType functionType = getFunctionType(functionInstance);\n\n\t// Set up the arguments for the invoke.\n\tstd::vector<Value> invokeArgs;\n\tif(!options.functionName)\n\t{\n\t\tif(functionType.params().size() == 2)\n\t\t{\n\t\t\tif(!emscriptenInstance)\n\t\t\t{\n\t\t\t\tLog::printf(\n\t\t\t\t\tLog::error,\n\t\t\t\t\t\""Module does not declare a default memory object to put arguments in.\\n\"");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::vector<const char*> argStrings;\n\t\t\t\targStrings.push_back(options.filename);\n\t\t\t\tchar** args = options.args;\n\t\t\t\twhile(*args) { argStrings.push_back(*args++); };\n\n\t\t\t\twavmAssert(emscriptenInstance);\n\t\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n\t\t\t}\n\t\t}\n\t\telse if(functionType.params().size() > 0)\n\t\t{\n\t\t\tLog::printf(Log::error,\n\t\t\t\t\t\t\""WebAssembly function requires %\"" PRIu64\n\t\t\t\t\t\t\"" argument(s), but only 0 or 2 can be passed!\"",\n\t\t\t\t\t\tfunctionType.params().size());\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(U32 i = 0; options.args[i]; ++i)\n\t\t{\n\t\t\tValue value;\n\t\t\tswitch(functionType.params()[i])\n\t\t\t{\n\t\t\tcase ValueType::i32: value = (U32)atoi(options.args[i]); break;\n\t\t\tcase ValueType::i64: value = (U64)atol(options.args[i]); break;\n\t\t\tcase ValueType::f32: value = (F32)atof(options.args[i]); break;\n\t\t\tcase ValueType::f64: value = atof(options.args[i]); break;\n\t\t\tcase ValueType::v128:\n\t\t\tcase ValueType::anyref:\n\t\t\tcase ValueType::anyfunc:\n\t\t\t\tErrors::fatalf(\""Cannot parse command-line argument for %s function parameter\"",\n\t\t\t\t\t\t\t   asString(functionType.params()[i]));\n\t\t\tdefault: Errors::unreachable();\n\t\t\t}\n\t\t\tinvokeArgs.push_back(value);\n\t\t}\n\t}\n\n\t// Invoke the function.\n\tTiming::Timer executionTimer;\n\tIR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);\n\tTiming::logTimer(\""Invoked function\"", executionTimer);\n\n\tif(options.functionName)\n\t{\n\t\tLog::printf(Log::debug,\n\t\t\t\t\t\""%s returned: %s\\n\"",\n\t\t\t\t\toptions.functionName,\n\t\t\t\t\tasString(functionResults).c_str());\n\t\treturn EXIT_SUCCESS;\n\t}\n\telse if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)\n\t{\n\t\treturn functionResults[0].i32;\n\t}\n\telse\n\t{\n\t\treturn EXIT_SUCCESS;\n\t}\n}""}]","{""value"": 1, ""function"": 1}","[{""source"": ""value_info(file:wavm.cpp, value:emscriptenInstance)"", ""result"": {""value_trace"": [{""full_code"": ""* emscriptenInstance = nullptr"", ""line"": 174, ""func_name"": ""run:int(CommandLineOptions&)""}, {""full_code"": ""emscriptenInstance = Emscripten::instantiate(compartment, irModule)"", ""line"": 177, ""func_name"": ""run:int(CommandLineOptions&)""}], ""struct_var"": ""emscriptenInstance"", ""struct_type"": ""Emscripten.Instance*"", ""struct_definition"": null}}, {""source"": ""func_info(func:instantiate)"", ""result"": [{""code"": ""Emscripten::Instance* Emscripten::instantiate(Compartment* compartment, const IR::Module& module)\n{\n\tMemoryType memoryType(false, SizeConstraints{0, 0});\n\tif(module.memories.imports.size() && module.memories.imports[0].moduleName == \""env\""\n\t   && module.memories.imports[0].exportName == \""memory\"")\n\t{\n\t\tmemoryType = module.memories.imports[0].type;\n\t\tif(memoryType.size.max >= minStaticEmscriptenMemoryPages)\n\t\t{\n\t\t\tif(memoryType.size.min <= minStaticEmscriptenMemoryPages)\n\t\t\t{\n\t\t\t\t// Enlarge the initial memory to make space for the stack and mutable globals.\n\t\t\t\tmemoryType.size.min = minStaticEmscriptenMemoryPages;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLog::printf(Log::error, \""module's memory is too small for Emscripten emulation\"");\n\t\t\treturn nullptr;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn nullptr;\n\t}\n\n\tTableType tableType(ReferenceType::anyfunc, false, SizeConstraints{0, 0});\n\tif(module.tables.imports.size() && module.tables.imports[0].moduleName == \""env\""\n\t   && module.tables.imports[0].exportName == \""table\"")\n\t{ tableType = module.tables.imports[0].type; }\n\n\tMemoryInstance* memory = Runtime::createMemory(compartment, memoryType);\n\tTableInstance* table = Runtime::createTable(compartment, tableType);\n\n\tHashMap<std::string, Runtime::Object*> extraEnvExports = {\n\t\t{\""memory\"", Runtime::asObject(memory)},\n\t\t{\""table\"", Runtime::asObject(table)},\n\t};\n\n\tInstance* instance = new Instance;\n\tinstance->env = Intrinsics::instantiateModule(\n\t\tcompartment, INTRINSIC_MODULE_REF(env), \""env\"", extraEnvExports);\n\tinstance->asm2wasm\n\t\t= Intrinsics::instantiateModule(compartment, INTRINSIC_MODULE_REF(asm2wasm), \""asm2wasm\"");\n\tinstance->global\n\t\t= Intrinsics::instantiateModule(compartment, INTRINSIC_MODULE_REF(global), \""global\"");\n\n\tMutableGlobals& mutableGlobals = memoryRef<MutableGlobals>(memory, MutableGlobals::address);\n\n\tmutableGlobals.DYNAMICTOP_PTR = STACK_MAX.getValue().i32;\n\tmutableGlobals._stderr = (U32)ioStreamVMHandle::StdErr;\n\tmutableGlobals._stdin = (U32)ioStreamVMHandle::StdIn;\n\tmutableGlobals._stdout = (U32)ioStreamVMHandle::StdOut;\n\n\tinstance->emscriptenMemory = memory;\n\n\treturn instance;\n}\n"", ""start_line"": 627, ""end_line"": 684, ""full_name"": ""Emscripten.instantiate:Emscripten.Instance*(Runtime.Compartment*,IR.Module&)"", ""file_path"": ""Lib/Emscripten/Emscripten.cpp""}, {""code"": ""Runtime::FunctionInstance* Intrinsics::Function::instantiate(Runtime::Compartment* compartment)\n{\n\treturn new Runtime::FunctionInstance(nullptr, type, nativeFunction, callingConvention, name);\n}"", ""start_line"": 52, ""end_line"": 55, ""full_name"": ""Intrinsics.Function.instantiate:Runtime.FunctionInstance*(Runtime.Compartment*)"", ""file_path"": ""Lib/Runtime/Intrinsics.cpp""}, {""code"": ""Runtime::GlobalInstance* Intrinsics::Global::instantiate(Runtime::Compartment* compartment)\n{\n\treturn Runtime::createGlobal(compartment, IR::GlobalType(type, false), value);\n}"", ""start_line"": 70, ""end_line"": 73, ""full_name"": ""Intrinsics.Global.instantiate:Runtime.GlobalInstance*(Runtime.Compartment*)"", ""file_path"": ""Lib/Runtime/Intrinsics.cpp""}]}]","The root cause is the absence of proper validation in `Emscripten::instantiate(Lib/Emscripten/Emscripten.cpp:627-684)` for required memory imports. If a module does not declare an `env.memory` import with sufficient size, `Emscripten::instantiate()` returns `nullptr`, leaving `emscriptenInstance` unassigned in `wavm.cpp:177`. This null value is later dereferenced in `wavm.cpp:251-255` during `Emscripten::injectCommandArgs()` without sufficient checks, causing a NULL pointer dereference.",0.95,./github/other_context/CVE-2018-17293
66,CVE-2018-17825,CWE-415,c_cpp,"An issue was discovered in AdPlug 2.3.1. There are several double-free vulnerabilities in the CEmuopl class in emuopl.cpp because of a destructor's two OPLDestroy calls, each of which frees TL_TABLE, SIN_TABLE, AMS_TABLE, and VIB_TABLE.",https://github.com/adplug/adplug/commit/19ebb61bf92262dc1868de10ba5a211db249ce76,FMOPL: Avoid double-free by checking OPL pointer (fix #67)\n\nFixes CVE-2018-17825.,1,"[{""func_name"": ""OPLDestroy"", ""file_path"": ""src/fmopl.c"", ""func_code"": ""void OPLDestroy(FM_OPL *OPL)\n{\n#ifdef OPL_OUTPUT_LOG\n\tif(opl_dbg_fp)\n\t{\n\t\tfclose(opl_dbg_fp);\n\t\topl_dbg_fp = NULL;\n\t}\n#endif\n\tOPL_UnLockTable();\n\tfree(OPL);\n}"", ""target"": 0}]","[{""func_name"": ""OPLDestroy"", ""file_path"": ""src/fmopl.c"", ""func_code"": ""void OPLDestroy(FM_OPL *OPL)\n{\n\tif(!OPL)\n\t{\n\t\treturn;\n\t}\n#ifdef OPL_OUTPUT_LOG\n\tif(opl_dbg_fp)\n\t{\n\t\tfclose(opl_dbg_fp);\n\t\topl_dbg_fp = NULL;\n\t}\n#endif\n\tOPL_UnLockTable();\n\tfree(OPL);\n}""}]","{""code"": 2, ""value"": 4, ""function"": 4}","[{""source"": ""code_info(file:fmopl.c, lines:1271-1280)"", ""result"": ""{\n#ifdef OPL_OUTPUT_LOG\n\tif(opl_dbg_fp)\n\t{\n\t\tfclose(opl_dbg_fp);\n\t\topl_dbg_fp = NULL;\n\t}\n#endif\n\tOPL_UnLockTable();\n\tfree(OPL);\n""}, {""source"": ""value_info(file:fmopl.c, value:TL_TABLE)"", ""result"": {""value_trace"": [{""full_code"": ""TL_TABLE = malloc(TL_MAX*2*sizeof(INT32))"", ""line"": 628, ""func_name"": ""OPLOpenTable""}, {""full_code"": ""TL_TABLE[       t] =  (int)rate"", ""line"": 651, ""func_name"": ""OPLOpenTable""}, {""full_code"": ""TL_TABLE[TL_MAX+t] = -TL_TABLE[t]"", ""line"": 652, ""func_name"": ""OPLOpenTable""}, {""full_code"": ""TL_TABLE[t] = TL_TABLE[TL_MAX+t] = 0"", ""line"": 657, ""func_name"": ""OPLOpenTable""}], ""struct_var"": ""TL_TABLE"", ""struct_type"": ""INT32*"", ""struct_definition"": ""typedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;""}}, {""source"": ""value_info(file:fmopl.c, value:SIN_TABLE)"", ""result"": {""value_trace"": [{""full_code"": ""SIN_TABLE = malloc(SIN_ENT*4 *sizeof(INT32 *))"", ""line"": 630, ""func_name"": ""OPLOpenTable""}, {""full_code"": ""SIN_TABLE[0] = SIN_TABLE[SIN_ENT/2]         = &TL_TABLE[EG_ENT-1]"", ""line"": 662, ""func_name"": ""OPLOpenTable""}], ""struct_var"": ""SIN_TABLE"", ""struct_type"": ""INT32**"", ""struct_definition"": ""typedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;""}}, {""source"": ""value_info(file:fmopl.c, value:AMS_TABLE)"", ""result"": {""value_trace"": [{""full_code"": ""AMS_TABLE = malloc(AMS_ENT*2 *sizeof(INT32))"", ""line"": 635, ""func_name"": ""OPLOpenTable""}, {""full_code"": ""AMS_TABLE[i]         = (1.0/EG_STEP)*pom"", ""line"": 697, ""func_name"": ""OPLOpenTable""}, {""full_code"": ""AMS_TABLE[AMS_ENT+i] = (4.8/EG_STEP)*pom"", ""line"": 698, ""func_name"": ""OPLOpenTable""}], ""struct_var"": ""AMS_TABLE"", ""struct_type"": ""INT32*"", ""struct_definition"": ""typedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;""}}, {""source"": ""value_info(file:fmopl.c, value:VIB_TABLE)"", ""result"": {""value_trace"": [{""full_code"": ""VIB_TABLE = malloc(VIB_ENT*2 *sizeof(INT32))"", ""line"": 641, ""func_name"": ""OPLOpenTable""}, {""full_code"": ""VIB_TABLE[i]         = VIB_RATE + (pom*0.07)"", ""line"": 705, ""func_name"": ""OPLOpenTable""}, {""full_code"": ""VIB_TABLE[VIB_ENT+i] = VIB_RATE + (pom*0.14)"", ""line"": 706, ""func_name"": ""OPLOpenTable""}], ""struct_var"": ""VIB_TABLE"", ""struct_type"": ""INT32*"", ""struct_definition"": ""typedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;\n\ntypedef signed int\t\tINT32;""}}, {""source"": ""code_info(file:fmopl.c, lines:1260-1290)"", ""result"": ""\t\t\t(clock/0x100)&0xff,\n\t\t\t(clock/0x10000)&0xff,\n\t\t\t(clock/0x1000000)&0xff);\n\t\topl_dbg_maxchip++;\n\t}\n#endif\n\treturn OPL;\n}\n\n/* ----------  Destroy one of vietual YM3812 ----------       */\nvoid OPLDestroy(FM_OPL *OPL)\n{\n#ifdef OPL_OUTPUT_LOG\n\tif(opl_dbg_fp)\n\t{\n\t\tfclose(opl_dbg_fp);\n\t\topl_dbg_fp = NULL;\n\t}\n#endif\n\tOPL_UnLockTable();\n\tfree(OPL);\n}\n\n/* ----------  Option handlers ----------       */\n\nvoid OPLSetTimerHandler(FM_OPL *OPL,OPL_TIMERHANDLER TimerHandler,int channelOffset)\n{\n\tOPL->TimerHandler   = TimerHandler;\n\tOPL->TimerParam = channelOffset;\n}\nvoid OPLSetIRQHandler(FM_OPL *OPL,OPL_IRQHANDLER IRQHandler,int param)\n""}, {""source"": ""func_info(file:fmopl.c, func:OPL_UnLockTable)"", ""result"": [{""code"": ""static void OPL_UnLockTable(void)\n{\n\tif(num_lock) num_lock--;\n\tif(num_lock) return;\n\t/* last time */\n\tcur_chip = NULL;\n\tOPLCloseTable();\n}"", ""start_line"": 1033, ""end_line"": 1040, ""full_name"": ""OPL_UnLockTable"", ""file_path"": ""src/fmopl.c""}]}, {""source"": ""func_info(func:CEmuopl)"", ""result"": [{""code"": ""CEmuopl::CEmuopl(int rate, bool bit16, bool usestereo)\n  : use16bit(bit16), stereo(usestereo), mixbufSamples(0)\n{\n  opl[0] = OPLCreate(OPL_TYPE_YM3812, 3579545, rate);\n  opl[1] = OPLCreate(OPL_TYPE_YM3812, 3579545, rate);\n\n  currType = TYPE_DUAL_OPL2;\n\n  init();\n}"", ""start_line"": 24, ""end_line"": 33, ""full_name"": ""CEmuopl.CEmuopl:ANY(int,bool,bool)"", ""file_path"": ""src/emuopl.cpp""}]}, {""source"": ""func_info(file:fmopl.c, func:OPLCloseTable)"", ""result"": [{""code"": ""static void OPLCloseTable( void )\n{\n\tfree(TL_TABLE);\n\tfree(SIN_TABLE);\n\tfree(AMS_TABLE);\n\tfree(VIB_TABLE);\n}"", ""start_line"": 713, ""end_line"": 719, ""full_name"": ""OPLCloseTable"", ""file_path"": ""src/fmopl.c""}]}, {""source"": ""func_info(func:~CEmuopl)"", ""result"": [{""code"": ""CEmuopl::~CEmuopl()\n{\n  OPLDestroy(opl[0]); OPLDestroy(opl[1]);\n\n  if(mixbufSamples) {\n    delete [] mixbuf0;\n    delete [] mixbuf1;\n  }\n}"", ""start_line"": 35, ""end_line"": 43, ""full_name"": ""CEmuopl.~CEmuopl:ANY()"", ""file_path"": ""src/emuopl.cpp""}]}]","src/emuopl.cpp:35-43: CEmuopl destructor calls OPLDestroy(opl[0]) and OPLDestroy(opl[1]). src/fmopl.c:1271-1280: OPLDestroy calls OPL_UnLockTable() (src/fmopl.c:1033-1040) → OPLCloseTable() (src/fmopl.c:713-719), which frees TL_TABLE, SIN_TABLE, AMS_TABLE, VIB_TABLE. src/fmopl.c:713-719: OPLCloseTable() frees the tables without setting them to NULL. Subsequent OPLDestroy calls on the same FM_OPL instance (e.g., due to opl[0] and opl[1] pointing to the same struct) re-execute OPLCloseTable(), causing double-free. Patch (src/fmopl.c:1271-1275) prevents double-free of FM_OPL struct but not tables.",0.95,./github/other_context/CVE-2018-17825
67,CVE-2018-20360,"CWE-119, CWE-476",c_cpp,"An invalid memory address dereference was discovered in the sbr_process_channel function of libfaad/sbr_dec.c in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. The vulnerability causes a segmentation fault and application crash, which leads to denial of service.",https://github.com/knik0/faad2/commit/6823e6610c9af1b0080cb22b9da03efb208d7d57,"ps_dec: sanitize iid_index before mixing\n\nindex range is supposed to be withing -7 and 7 or -15 and 15 depending on\niid_mode (see Table 8.24, ISO/IEC 14496-3:2005).\n\nIndexes outside these boundaries are likely to be errors and should be\nsanitized to avoid memory corruption. Replace any index under\n-no_iid_steps (-7 or -15 depending on iid_mode) by -no_iid_steps. Replace\nany index above no_iid_steps by no_iid_steps. Try to process further.\n\nThis commit addresses CVE-2019-6956 (fixes #39).",2,"[{""func_name"": ""ps_mix_phase"", ""file_path"": ""libfaad/ps_dec.c"", ""func_code"": ""static void ps_mix_phase(ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64],\n                         qmf_t X_hybrid_left[32][32], qmf_t X_hybrid_right[32][32])\n{\n    uint8_t n;\n    uint8_t gr;\n    uint8_t bk = 0;\n    uint8_t sb, maxsb;\n    uint8_t env;\n    uint8_t nr_ipdopd_par;\n    complex_t h11, h12, h21, h22;\n    complex_t H11, H12, H21, H22;\n    complex_t deltaH11, deltaH12, deltaH21, deltaH22;\n    complex_t tempLeft;\n    complex_t tempRight;\n    complex_t phaseLeft;\n    complex_t phaseRight;\n    real_t L;\n    const real_t *sf_iid;\n    uint8_t no_iid_steps;\n\n    if (ps->iid_mode >= 3)\n    {\n        no_iid_steps = 15;\n        sf_iid = sf_iid_fine;\n    } else {\n        no_iid_steps = 7;\n        sf_iid = sf_iid_normal;\n    }\n\n    if (ps->ipd_mode == 0 || ps->ipd_mode == 3)\n    {\n        nr_ipdopd_par = 11; /* resolution */\n    } else {\n        nr_ipdopd_par = ps->nr_ipdopd_par;\n    }\n\n    for (gr = 0; gr < ps->num_groups; gr++)\n    {\n        bk = (~NEGATE_IPD_MASK) & ps->map_group2bk[gr];\n\n        /* use one channel per group in the subqmf domain */\n        maxsb = (gr < ps->num_hybrid_groups) ? ps->group_border[gr] + 1 : ps->group_border[gr + 1];\n\n        for (env = 0; env < ps->num_env; env++)\n        {\n            if (ps->icc_mode < 3)\n            {\n                /* type 'A' mixing as described in 8.6.4.6.2.1 */\n                real_t c_1, c_2;\n                real_t cosa, sina;\n                real_t cosb, sinb;\n                real_t ab1, ab2;\n                real_t ab3, ab4;\n\n                /*\n                c_1 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps + iid_index] / 10.0)));\n                c_2 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps - iid_index] / 10.0)));\n                alpha = 0.5 * acos(quant_rho[icc_index]);\n                beta = alpha * ( c_1 - c_2 ) / sqrt(2.0);\n                */\n\n                //printf(\""%d\\n\"", ps->iid_index[env][bk]);\n\n                /* calculate the scalefactors c_1 and c_2 from the intensity differences */\n                c_1 = sf_iid[no_iid_steps + ps->iid_index[env][bk]];\n                c_2 = sf_iid[no_iid_steps - ps->iid_index[env][bk]];\n\n                /* calculate alpha and beta using the ICC parameters */\n                cosa = cos_alphas[ps->icc_index[env][bk]];\n                sina = sin_alphas[ps->icc_index[env][bk]];\n\n                if (ps->iid_mode >= 3)\n                {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                } else {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                }\n\n                ab1 = MUL_C(cosb, cosa);\n                ab2 = MUL_C(sinb, sina);\n                ab3 = MUL_C(sinb, cosa);\n                ab4 = MUL_C(cosb, sina);\n\n                /* h_xy: COEF */\n                RE(h11) = MUL_C(c_2, (ab1 - ab2));\n                RE(h12) = MUL_C(c_1, (ab1 + ab2));\n                RE(h21) = MUL_C(c_2, (ab3 + ab4));\n                RE(h22) = MUL_C(c_1, (ab3 - ab4));\n            } else {\n                /* type 'B' mixing as described in 8.6.4.6.2.2 */\n                real_t sina, cosa;\n                real_t cosg, sing;\n\n                /*\n                real_t c, rho, mu, alpha, gamma;\n                uint8_t i;\n\n                i = ps->iid_index[env][bk];\n                c = (real_t)pow(10.0, ((i)?(((i>0)?1:-1)*quant_iid[((i>0)?i:-i)-1]):0.)/20.0);\n                rho = quant_rho[ps->icc_index[env][bk]];\n\n                if (rho == 0.0f && c == 1.)\n                {\n                    alpha = (real_t)M_PI/4.0f;\n                    rho = 0.05f;\n                } else {\n                    if (rho <= 0.05f)\n                    {\n                        rho = 0.05f;\n                    }\n                    alpha = 0.5f*(real_t)atan( (2.0f*c*rho) / (c*c-1.0f) );\n\n                    if (alpha < 0.)\n                    {\n                        alpha += (real_t)M_PI/2.0f;\n                    }\n                    if (rho < 0.)\n                    {\n                        alpha += (real_t)M_PI;\n                    }\n                }\n                mu = c+1.0f/c;\n                mu = 1+(4.0f*rho*rho-4.0f)/(mu*mu);\n                gamma = (real_t)atan(sqrt((1.0f-sqrt(mu))/(1.0f+sqrt(mu))));\n                */\n\n                if (ps->iid_mode >= 3)\n                {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_fine[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_fine[30 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                } else {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_normal[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_normal[14 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                }\n\n                RE(h11) = MUL_C(COEF_SQRT2, MUL_C(cosa, cosg));\n                RE(h12) = MUL_C(COEF_SQRT2, MUL_C(sina, cosg));\n                RE(h21) = MUL_C(COEF_SQRT2, MUL_C(-cosa, sing));\n                RE(h22) = MUL_C(COEF_SQRT2, MUL_C(sina, sing));\n            }\n\n            /* calculate phase rotation parameters H_xy */\n            /* note that the imaginary part of these parameters are only calculated when\n               IPD and OPD are enabled\n             */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                int8_t i;\n                real_t xy, pq, xypq;\n\n                /* ringbuffer index */\n                i = ps->phase_hist;\n\n                /* previous value */\n#ifdef FIXED_POINT\n                /* divide by 4, shift right 2 bits */\n                RE(tempLeft)  = RE(ps->ipd_prev[bk][i]) >> 2;\n                IM(tempLeft)  = IM(ps->ipd_prev[bk][i]) >> 2;\n                RE(tempRight) = RE(ps->opd_prev[bk][i]) >> 2;\n                IM(tempRight) = IM(ps->opd_prev[bk][i]) >> 2;\n#else\n                RE(tempLeft)  = MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempLeft)  = MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                RE(tempRight) = MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempRight) = MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n#endif\n\n                /* save current value */\n                RE(ps->ipd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->ipd_index[env][bk])];\n                IM(ps->ipd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->ipd_index[env][bk])];\n                RE(ps->opd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->opd_index[env][bk])];\n                IM(ps->opd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->opd_index[env][bk])];\n\n                /* add current value */\n                RE(tempLeft)  += RE(ps->ipd_prev[bk][i]);\n                IM(tempLeft)  += IM(ps->ipd_prev[bk][i]);\n                RE(tempRight) += RE(ps->opd_prev[bk][i]);\n                IM(tempRight) += IM(ps->opd_prev[bk][i]);\n\n                /* ringbuffer index */\n                if (i == 0)\n                {\n                    i = 2;\n                }\n                i--;\n\n                /* get value before previous */\n#ifdef FIXED_POINT\n                /* dividing by 2, shift right 1 bit */\n                RE(tempLeft)  += (RE(ps->ipd_prev[bk][i]) >> 1);\n                IM(tempLeft)  += (IM(ps->ipd_prev[bk][i]) >> 1);\n                RE(tempRight) += (RE(ps->opd_prev[bk][i]) >> 1);\n                IM(tempRight) += (IM(ps->opd_prev[bk][i]) >> 1);\n#else\n                RE(tempLeft)  += MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempLeft)  += MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                RE(tempRight) += MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempRight) += MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n#endif\n\n#if 0 /* original code */\n                ipd = (float)atan2(IM(tempLeft), RE(tempLeft));\n                opd = (float)atan2(IM(tempRight), RE(tempRight));\n\n                /* phase rotation */\n                RE(phaseLeft) = (float)cos(opd);\n                IM(phaseLeft) = (float)sin(opd);\n                opd -= ipd;\n                RE(phaseRight) = (float)cos(opd);\n                IM(phaseRight) = (float)sin(opd);\n#else\n\n                // x = IM(tempLeft)\n                // y = RE(tempLeft)\n                // p = IM(tempRight)\n                // q = RE(tempRight)\n                // cos(atan2(x,y)) = y/sqrt((x*x) + (y*y))\n                // sin(atan2(x,y)) = x/sqrt((x*x) + (y*y))\n                // cos(atan2(x,y)-atan2(p,q)) = (y*q + x*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n                // sin(atan2(x,y)-atan2(p,q)) = (x*q - y*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n\n                xy = magnitude_c(tempRight);\n                pq = magnitude_c(tempLeft);\n\n                if (xy != 0)\n                {\n                    RE(phaseLeft) = DIV_R(RE(tempRight), xy);\n                    IM(phaseLeft) = DIV_R(IM(tempRight), xy);\n                } else {\n                    RE(phaseLeft) = 0;\n                    IM(phaseLeft) = 0;\n                }\n\n                xypq = MUL_R(xy, pq);\n\n                if (xypq != 0)\n                {\n                    real_t tmp1 = MUL_R(RE(tempRight), RE(tempLeft)) + MUL_R(IM(tempRight), IM(tempLeft));\n                    real_t tmp2 = MUL_R(IM(tempRight), RE(tempLeft)) - MUL_R(RE(tempRight), IM(tempLeft));\n\n                    RE(phaseRight) = DIV_R(tmp1, xypq);\n                    IM(phaseRight) = DIV_R(tmp2, xypq);\n                } else {\n                    RE(phaseRight) = 0;\n                    IM(phaseRight) = 0;\n                }\n\n#endif\n\n                /* MUL_F(COEF, REAL) = COEF */\n                IM(h11) = MUL_R(RE(h11), IM(phaseLeft));\n                IM(h12) = MUL_R(RE(h12), IM(phaseRight));\n                IM(h21) = MUL_R(RE(h21), IM(phaseLeft));\n                IM(h22) = MUL_R(RE(h22), IM(phaseRight));\n\n                RE(h11) = MUL_R(RE(h11), RE(phaseLeft));\n                RE(h12) = MUL_R(RE(h12), RE(phaseRight));\n                RE(h21) = MUL_R(RE(h21), RE(phaseLeft));\n                RE(h22) = MUL_R(RE(h22), RE(phaseRight));\n            }\n\n            /* length of the envelope n_e+1 - n_e (in time samples) */\n            /* 0 < L <= 32: integer */\n            L = (real_t)(ps->border_position[env + 1] - ps->border_position[env]);\n\n            /* obtain final H_xy by means of linear interpolation */\n            RE(deltaH11) = (RE(h11) - RE(ps->h11_prev[gr])) / L;\n            RE(deltaH12) = (RE(h12) - RE(ps->h12_prev[gr])) / L;\n            RE(deltaH21) = (RE(h21) - RE(ps->h21_prev[gr])) / L;\n            RE(deltaH22) = (RE(h22) - RE(ps->h22_prev[gr])) / L;\n\n            RE(H11) = RE(ps->h11_prev[gr]);\n            RE(H12) = RE(ps->h12_prev[gr]);\n            RE(H21) = RE(ps->h21_prev[gr]);\n            RE(H22) = RE(ps->h22_prev[gr]);\n\n            RE(ps->h11_prev[gr]) = RE(h11);\n            RE(ps->h12_prev[gr]) = RE(h12);\n            RE(ps->h21_prev[gr]) = RE(h21);\n            RE(ps->h22_prev[gr]) = RE(h22);\n\n            /* only calculate imaginary part when needed */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                /* obtain final H_xy by means of linear interpolation */\n                IM(deltaH11) = (IM(h11) - IM(ps->h11_prev[gr])) / L;\n                IM(deltaH12) = (IM(h12) - IM(ps->h12_prev[gr])) / L;\n                IM(deltaH21) = (IM(h21) - IM(ps->h21_prev[gr])) / L;\n                IM(deltaH22) = (IM(h22) - IM(ps->h22_prev[gr])) / L;\n\n                IM(H11) = IM(ps->h11_prev[gr]);\n                IM(H12) = IM(ps->h12_prev[gr]);\n                IM(H21) = IM(ps->h21_prev[gr]);\n                IM(H22) = IM(ps->h22_prev[gr]);\n\n                if ((NEGATE_IPD_MASK & ps->map_group2bk[gr]) != 0)\n                {\n                    IM(deltaH11) = -IM(deltaH11);\n                    IM(deltaH12) = -IM(deltaH12);\n                    IM(deltaH21) = -IM(deltaH21);\n                    IM(deltaH22) = -IM(deltaH22);\n\n                    IM(H11) = -IM(H11);\n                    IM(H12) = -IM(H12);\n                    IM(H21) = -IM(H21);\n                    IM(H22) = -IM(H22);\n                }\n\n                IM(ps->h11_prev[gr]) = IM(h11);\n                IM(ps->h12_prev[gr]) = IM(h12);\n                IM(ps->h21_prev[gr]) = IM(h21);\n                IM(ps->h22_prev[gr]) = IM(h22);\n            }\n\n            /* apply H_xy to the current envelope band of the decorrelated subband */\n            for (n = ps->border_position[env]; n < ps->border_position[env + 1]; n++)\n            {\n                /* addition finalises the interpolation over every n */\n                RE(H11) += RE(deltaH11);\n                RE(H12) += RE(deltaH12);\n                RE(H21) += RE(deltaH21);\n                RE(H22) += RE(deltaH22);\n                if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                {\n                    IM(H11) += IM(deltaH11);\n                    IM(H12) += IM(deltaH12);\n                    IM(H21) += IM(deltaH21);\n                    IM(H22) += IM(deltaH22);\n                }\n\n                /* channel is an alias to the subband */\n                for (sb = ps->group_border[gr]; sb < maxsb; sb++)\n                {\n                    complex_t inLeft, inRight;\n\n                    /* load decorrelated samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(inLeft) =  RE(X_hybrid_left[n][sb]);\n                        IM(inLeft) =  IM(X_hybrid_left[n][sb]);\n                        RE(inRight) = RE(X_hybrid_right[n][sb]);\n                        IM(inRight) = IM(X_hybrid_right[n][sb]);\n                    } else {\n                        RE(inLeft) =  RE(X_left[n][sb]);\n                        IM(inLeft) =  IM(X_left[n][sb]);\n                        RE(inRight) = RE(X_right[n][sb]);\n                        IM(inRight) = IM(X_right[n][sb]);\n                    }\n\n                    /* apply mixing */\n                    RE(tempLeft) =  MUL_C(RE(H11), RE(inLeft)) + MUL_C(RE(H21), RE(inRight));\n                    IM(tempLeft) =  MUL_C(RE(H11), IM(inLeft)) + MUL_C(RE(H21), IM(inRight));\n                    RE(tempRight) = MUL_C(RE(H12), RE(inLeft)) + MUL_C(RE(H22), RE(inRight));\n                    IM(tempRight) = MUL_C(RE(H12), IM(inLeft)) + MUL_C(RE(H22), IM(inRight));\n\n                    /* only perform imaginary operations when needed */\n                    if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                    {\n                        /* apply rotation */\n                        RE(tempLeft)  -= MUL_C(IM(H11), IM(inLeft)) + MUL_C(IM(H21), IM(inRight));\n                        IM(tempLeft)  += MUL_C(IM(H11), RE(inLeft)) + MUL_C(IM(H21), RE(inRight));\n                        RE(tempRight) -= MUL_C(IM(H12), IM(inLeft)) + MUL_C(IM(H22), IM(inRight));\n                        IM(tempRight) += MUL_C(IM(H12), RE(inLeft)) + MUL_C(IM(H22), RE(inRight));\n                    }\n\n                    /* store final samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(X_hybrid_left[n][sb])  = RE(tempLeft);\n                        IM(X_hybrid_left[n][sb])  = IM(tempLeft);\n                        RE(X_hybrid_right[n][sb]) = RE(tempRight);\n                        IM(X_hybrid_right[n][sb]) = IM(tempRight);\n                    } else {\n                        RE(X_left[n][sb])  = RE(tempLeft);\n                        IM(X_left[n][sb])  = IM(tempLeft);\n                        RE(X_right[n][sb]) = RE(tempRight);\n                        IM(X_right[n][sb]) = IM(tempRight);\n                    }\n                }\n            }\n\n            /* shift phase smoother's circular buffer index */\n            ps->phase_hist++;\n            if (ps->phase_hist == 2)\n            {\n                ps->phase_hist = 0;\n            }\n        }\n    }\n}"", ""target"": 0}, {""func_name"": ""reconstruct_single_channel"", ""file_path"": ""libfaad/specrec.c"", ""func_code"": ""uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,\n                                   element *sce, int16_t *spec_data)\n{\n    uint8_t retval;\n    int output_channels;\n    ALIGN real_t spec_coef[1024];\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n\n    /* always allocate 2 channels, PS can always \""suddenly\"" turn up */\n#if ( (defined(DRM) && defined(DRM_PS)) )\n    output_channels = 2;\n#elif defined(PS_DEC)\n    if (hDecoder->ps_used[hDecoder->fr_ch_ele])\n        output_channels = 2;\n    else\n        output_channels = 1;\n#else\n    output_channels = 1;\n#endif\n\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {\n        /* element inconsistency */\n\n        /* this only happens if PS is actually found but not in the first frame\n         * this means that there is only 1 bitstream element!\n         */\n\n        /* reset the allocation */\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;\n\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n\n        //return 21;\n    }\n\n    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)\n    {\n        retval = allocate_single_channel(hDecoder, sce->channel, output_channels);\n        if (retval > 0)\n            return retval;\n\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;\n    }\n\n\n    /* dequantisation and scaling */\n    retval = quant_to_spec(hDecoder, ics, spec_data, spec_coef, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->requant_cycles += count;\n#endif\n\n\n    /* pns decoding */\n    pns_decode(ics, NULL, spec_coef, NULL, hDecoder->frameLength, 0, hDecoder->object_type,\n        &(hDecoder->__r1), &(hDecoder->__r2));\n\n#ifdef MAIN_DEC\n    /* MAIN object type prediction */\n    if (hDecoder->object_type == MAIN)\n    {\n\t\tif (!hDecoder->pred_stat[sce->channel])\n\t\t\treturn 33;\n\n        /* intra channel prediction */\n        ic_prediction(ics, spec_coef, hDecoder->pred_stat[sce->channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n\n        /* In addition, for scalefactor bands coded by perceptual\n           noise substitution the predictors belonging to the\n           corresponding spectral coefficients are reset.\n        */\n        pns_reset_pred_state(ics, hDecoder->pred_stat[sce->channel]);\n    }\n#endif\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n#ifdef LD_DEC\n        if (hDecoder->object_type == LD)\n        {\n            if (ics->ltp.data_present)\n            {\n                if (ics->ltp.lag_update)\n                    hDecoder->ltp_lag[sce->channel] = ics->ltp.lag;\n            }\n            ics->ltp.lag = hDecoder->ltp_lag[sce->channel];\n        }\n#endif\n\n        /* long term prediction */\n        lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[sce->channel], hDecoder->fb,\n            ics->window_shape, hDecoder->window_shape_prev[sce->channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n    }\n#endif\n\n    /* tns decoding */\n    tns_decode_frame(ics, &(ics->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef, hDecoder->frameLength);\n\n    /* drc decoding */\n    if (hDecoder->drc->present)\n    {\n        if (!hDecoder->drc->exclude_mask[sce->channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef);\n    }\n\n    /* filter bank */\n#ifdef SSR_DEC\n    if (hDecoder->object_type != SSR)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef,\n            hDecoder->time_out[sce->channel], hDecoder->fb_intermed[sce->channel],\n            hDecoder->object_type, hDecoder->frameLength);\n#ifdef SSR_DEC\n    } else {\n        ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef, hDecoder->time_out[sce->channel],\n            hDecoder->ssr_overlap[sce->channel], hDecoder->ipqf_buffer[sce->channel], hDecoder->prev_fmd[sce->channel],\n            hDecoder->frameLength);\n    }\n#endif\n\n    /* save window shape for next frame */\n    hDecoder->window_shape_prev[sce->channel] = ics->window_shape;\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        lt_update_state(hDecoder->lt_pred_stat[sce->channel], hDecoder->time_out[sce->channel],\n            hDecoder->fb_intermed[sce->channel], hDecoder->frameLength, hDecoder->object_type);\n    }\n#endif\n\n#ifdef SBR_DEC\n    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n\n        /* following case can happen when forceUpSampling == 1 */\n        if (hDecoder->sbr[ele] == NULL)\n        {\n            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,\n                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),\n                hDecoder->downSampledSBR\n#ifdef DRM\n                , 0\n#endif\n                );\n        }\n\n        if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n            hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n        else\n            hDecoder->sbr[ele]->maxAACLine = min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n\n        /* check if any of the PS tools is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->ps_used[ele] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        } else {\n            retval = sbrDecodeSingleFramePS(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->time_out[ch+1], hDecoder->postSeekResetFlag,\n                hDecoder->downSampledSBR);\n        }\n#endif\n        if (retval > 0)\n            return retval;\n    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* copy L to R when no PS is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n    if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&\n        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;\n        frame_size *= hDecoder->frameLength*sizeof(real_t);\n\n        memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);\n    }\n#endif\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""ps_mix_phase"", ""file_path"": ""libfaad/ps_dec.c"", ""func_code"": ""static void ps_mix_phase(ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64],\n                         qmf_t X_hybrid_left[32][32], qmf_t X_hybrid_right[32][32])\n{\n    uint8_t n;\n    uint8_t gr;\n    uint8_t bk = 0;\n    uint8_t sb, maxsb;\n    uint8_t env;\n    uint8_t nr_ipdopd_par;\n    complex_t h11, h12, h21, h22;\n    complex_t H11, H12, H21, H22;\n    complex_t deltaH11, deltaH12, deltaH21, deltaH22;\n    complex_t tempLeft;\n    complex_t tempRight;\n    complex_t phaseLeft;\n    complex_t phaseRight;\n    real_t L;\n    const real_t *sf_iid;\n    uint8_t no_iid_steps;\n\n    if (ps->iid_mode >= 3)\n    {\n        no_iid_steps = 15;\n        sf_iid = sf_iid_fine;\n    } else {\n        no_iid_steps = 7;\n        sf_iid = sf_iid_normal;\n    }\n\n    if (ps->ipd_mode == 0 || ps->ipd_mode == 3)\n    {\n        nr_ipdopd_par = 11; /* resolution */\n    } else {\n        nr_ipdopd_par = ps->nr_ipdopd_par;\n    }\n\n    for (gr = 0; gr < ps->num_groups; gr++)\n    {\n        bk = (~NEGATE_IPD_MASK) & ps->map_group2bk[gr];\n\n        /* use one channel per group in the subqmf domain */\n        maxsb = (gr < ps->num_hybrid_groups) ? ps->group_border[gr] + 1 : ps->group_border[gr + 1];\n\n        for (env = 0; env < ps->num_env; env++)\n        {\n            if (ps->icc_mode < 3)\n            {\n                /* type 'A' mixing as described in 8.6.4.6.2.1 */\n                real_t c_1, c_2;\n                real_t cosa, sina;\n                real_t cosb, sinb;\n                real_t ab1, ab2;\n                real_t ab3, ab4;\n\n                /*\n                c_1 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps + iid_index] / 10.0)));\n                c_2 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps - iid_index] / 10.0)));\n                alpha = 0.5 * acos(quant_rho[icc_index]);\n                beta = alpha * ( c_1 - c_2 ) / sqrt(2.0);\n                */\n\n                //printf(\""%d\\n\"", ps->iid_index[env][bk]);\n\n                /* index range is supposed to be -7...7 or -15...15 depending on iid_mode\n                   (Table 8.24, ISO/IEC 14496-3:2005).\n                   if it is outside these boundaries, this is most likely an error. sanitize\n                   it and try to process further. */\n                if (ps->iid_index[env][bk] < -no_iid_steps) {\n                    fprintf(stderr, \""Warning: invalid iid_index: %d < %d\\n\"", ps->iid_index[env][bk],\n                        -no_iid_steps);\n                    ps->iid_index[env][bk] = -no_iid_steps;\n                } else if (ps->iid_index[env][bk] > no_iid_steps) {\n                    fprintf(stderr, \""Warning: invalid iid_index: %d > %d\\n\"", ps->iid_index[env][bk],\n                        no_iid_steps);\n                    ps->iid_index[env][bk] = no_iid_steps;\n                }\n\n                /* calculate the scalefactors c_1 and c_2 from the intensity differences */\n                c_1 = sf_iid[no_iid_steps + ps->iid_index[env][bk]];\n                c_2 = sf_iid[no_iid_steps - ps->iid_index[env][bk]];\n\n                /* calculate alpha and beta using the ICC parameters */\n                cosa = cos_alphas[ps->icc_index[env][bk]];\n                sina = sin_alphas[ps->icc_index[env][bk]];\n\n                if (ps->iid_mode >= 3)\n                {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                } else {\n                    if (ps->iid_index[env][bk] < 0)\n                    {\n                        cosb =  cos_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = -sin_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    } else {\n                        cosb = cos_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                        sinb = sin_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    }\n                }\n\n                ab1 = MUL_C(cosb, cosa);\n                ab2 = MUL_C(sinb, sina);\n                ab3 = MUL_C(sinb, cosa);\n                ab4 = MUL_C(cosb, sina);\n\n                /* h_xy: COEF */\n                RE(h11) = MUL_C(c_2, (ab1 - ab2));\n                RE(h12) = MUL_C(c_1, (ab1 + ab2));\n                RE(h21) = MUL_C(c_2, (ab3 + ab4));\n                RE(h22) = MUL_C(c_1, (ab3 - ab4));\n            } else {\n                /* type 'B' mixing as described in 8.6.4.6.2.2 */\n                real_t sina, cosa;\n                real_t cosg, sing;\n\n                /*\n                real_t c, rho, mu, alpha, gamma;\n                uint8_t i;\n\n                i = ps->iid_index[env][bk];\n                c = (real_t)pow(10.0, ((i)?(((i>0)?1:-1)*quant_iid[((i>0)?i:-i)-1]):0.)/20.0);\n                rho = quant_rho[ps->icc_index[env][bk]];\n\n                if (rho == 0.0f && c == 1.)\n                {\n                    alpha = (real_t)M_PI/4.0f;\n                    rho = 0.05f;\n                } else {\n                    if (rho <= 0.05f)\n                    {\n                        rho = 0.05f;\n                    }\n                    alpha = 0.5f*(real_t)atan( (2.0f*c*rho) / (c*c-1.0f) );\n\n                    if (alpha < 0.)\n                    {\n                        alpha += (real_t)M_PI/2.0f;\n                    }\n                    if (rho < 0.)\n                    {\n                        alpha += (real_t)M_PI;\n                    }\n                }\n                mu = c+1.0f/c;\n                mu = 1+(4.0f*rho*rho-4.0f)/(mu*mu);\n                gamma = (real_t)atan(sqrt((1.0f-sqrt(mu))/(1.0f+sqrt(mu))));\n                */\n\n                if (ps->iid_mode >= 3)\n                {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_fine[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_fine[30 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_fine[abs_iid][ps->icc_index[env][bk]];\n                } else {\n                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);\n\n                    cosa = sincos_alphas_B_normal[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];\n                    sina = sincos_alphas_B_normal[14 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];\n                    cosg = cos_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                    sing = sin_gammas_normal[abs_iid][ps->icc_index[env][bk]];\n                }\n\n                RE(h11) = MUL_C(COEF_SQRT2, MUL_C(cosa, cosg));\n                RE(h12) = MUL_C(COEF_SQRT2, MUL_C(sina, cosg));\n                RE(h21) = MUL_C(COEF_SQRT2, MUL_C(-cosa, sing));\n                RE(h22) = MUL_C(COEF_SQRT2, MUL_C(sina, sing));\n            }\n\n            /* calculate phase rotation parameters H_xy */\n            /* note that the imaginary part of these parameters are only calculated when\n               IPD and OPD are enabled\n             */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                int8_t i;\n                real_t xy, pq, xypq;\n\n                /* ringbuffer index */\n                i = ps->phase_hist;\n\n                /* previous value */\n#ifdef FIXED_POINT\n                /* divide by 4, shift right 2 bits */\n                RE(tempLeft)  = RE(ps->ipd_prev[bk][i]) >> 2;\n                IM(tempLeft)  = IM(ps->ipd_prev[bk][i]) >> 2;\n                RE(tempRight) = RE(ps->opd_prev[bk][i]) >> 2;\n                IM(tempRight) = IM(ps->opd_prev[bk][i]) >> 2;\n#else\n                RE(tempLeft)  = MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempLeft)  = MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));\n                RE(tempRight) = MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n                IM(tempRight) = MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.25));\n#endif\n\n                /* save current value */\n                RE(ps->ipd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->ipd_index[env][bk])];\n                IM(ps->ipd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->ipd_index[env][bk])];\n                RE(ps->opd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->opd_index[env][bk])];\n                IM(ps->opd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->opd_index[env][bk])];\n\n                /* add current value */\n                RE(tempLeft)  += RE(ps->ipd_prev[bk][i]);\n                IM(tempLeft)  += IM(ps->ipd_prev[bk][i]);\n                RE(tempRight) += RE(ps->opd_prev[bk][i]);\n                IM(tempRight) += IM(ps->opd_prev[bk][i]);\n\n                /* ringbuffer index */\n                if (i == 0)\n                {\n                    i = 2;\n                }\n                i--;\n\n                /* get value before previous */\n#ifdef FIXED_POINT\n                /* dividing by 2, shift right 1 bit */\n                RE(tempLeft)  += (RE(ps->ipd_prev[bk][i]) >> 1);\n                IM(tempLeft)  += (IM(ps->ipd_prev[bk][i]) >> 1);\n                RE(tempRight) += (RE(ps->opd_prev[bk][i]) >> 1);\n                IM(tempRight) += (IM(ps->opd_prev[bk][i]) >> 1);\n#else\n                RE(tempLeft)  += MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempLeft)  += MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));\n                RE(tempRight) += MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n                IM(tempRight) += MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.5));\n#endif\n\n#if 0 /* original code */\n                ipd = (float)atan2(IM(tempLeft), RE(tempLeft));\n                opd = (float)atan2(IM(tempRight), RE(tempRight));\n\n                /* phase rotation */\n                RE(phaseLeft) = (float)cos(opd);\n                IM(phaseLeft) = (float)sin(opd);\n                opd -= ipd;\n                RE(phaseRight) = (float)cos(opd);\n                IM(phaseRight) = (float)sin(opd);\n#else\n\n                // x = IM(tempLeft)\n                // y = RE(tempLeft)\n                // p = IM(tempRight)\n                // q = RE(tempRight)\n                // cos(atan2(x,y)) = y/sqrt((x*x) + (y*y))\n                // sin(atan2(x,y)) = x/sqrt((x*x) + (y*y))\n                // cos(atan2(x,y)-atan2(p,q)) = (y*q + x*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n                // sin(atan2(x,y)-atan2(p,q)) = (x*q - y*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );\n\n                xy = magnitude_c(tempRight);\n                pq = magnitude_c(tempLeft);\n\n                if (xy != 0)\n                {\n                    RE(phaseLeft) = DIV_R(RE(tempRight), xy);\n                    IM(phaseLeft) = DIV_R(IM(tempRight), xy);\n                } else {\n                    RE(phaseLeft) = 0;\n                    IM(phaseLeft) = 0;\n                }\n\n                xypq = MUL_R(xy, pq);\n\n                if (xypq != 0)\n                {\n                    real_t tmp1 = MUL_R(RE(tempRight), RE(tempLeft)) + MUL_R(IM(tempRight), IM(tempLeft));\n                    real_t tmp2 = MUL_R(IM(tempRight), RE(tempLeft)) - MUL_R(RE(tempRight), IM(tempLeft));\n\n                    RE(phaseRight) = DIV_R(tmp1, xypq);\n                    IM(phaseRight) = DIV_R(tmp2, xypq);\n                } else {\n                    RE(phaseRight) = 0;\n                    IM(phaseRight) = 0;\n                }\n\n#endif\n\n                /* MUL_F(COEF, REAL) = COEF */\n                IM(h11) = MUL_R(RE(h11), IM(phaseLeft));\n                IM(h12) = MUL_R(RE(h12), IM(phaseRight));\n                IM(h21) = MUL_R(RE(h21), IM(phaseLeft));\n                IM(h22) = MUL_R(RE(h22), IM(phaseRight));\n\n                RE(h11) = MUL_R(RE(h11), RE(phaseLeft));\n                RE(h12) = MUL_R(RE(h12), RE(phaseRight));\n                RE(h21) = MUL_R(RE(h21), RE(phaseLeft));\n                RE(h22) = MUL_R(RE(h22), RE(phaseRight));\n            }\n\n            /* length of the envelope n_e+1 - n_e (in time samples) */\n            /* 0 < L <= 32: integer */\n            L = (real_t)(ps->border_position[env + 1] - ps->border_position[env]);\n\n            /* obtain final H_xy by means of linear interpolation */\n            RE(deltaH11) = (RE(h11) - RE(ps->h11_prev[gr])) / L;\n            RE(deltaH12) = (RE(h12) - RE(ps->h12_prev[gr])) / L;\n            RE(deltaH21) = (RE(h21) - RE(ps->h21_prev[gr])) / L;\n            RE(deltaH22) = (RE(h22) - RE(ps->h22_prev[gr])) / L;\n\n            RE(H11) = RE(ps->h11_prev[gr]);\n            RE(H12) = RE(ps->h12_prev[gr]);\n            RE(H21) = RE(ps->h21_prev[gr]);\n            RE(H22) = RE(ps->h22_prev[gr]);\n\n            RE(ps->h11_prev[gr]) = RE(h11);\n            RE(ps->h12_prev[gr]) = RE(h12);\n            RE(ps->h21_prev[gr]) = RE(h21);\n            RE(ps->h22_prev[gr]) = RE(h22);\n\n            /* only calculate imaginary part when needed */\n            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n            {\n                /* obtain final H_xy by means of linear interpolation */\n                IM(deltaH11) = (IM(h11) - IM(ps->h11_prev[gr])) / L;\n                IM(deltaH12) = (IM(h12) - IM(ps->h12_prev[gr])) / L;\n                IM(deltaH21) = (IM(h21) - IM(ps->h21_prev[gr])) / L;\n                IM(deltaH22) = (IM(h22) - IM(ps->h22_prev[gr])) / L;\n\n                IM(H11) = IM(ps->h11_prev[gr]);\n                IM(H12) = IM(ps->h12_prev[gr]);\n                IM(H21) = IM(ps->h21_prev[gr]);\n                IM(H22) = IM(ps->h22_prev[gr]);\n\n                if ((NEGATE_IPD_MASK & ps->map_group2bk[gr]) != 0)\n                {\n                    IM(deltaH11) = -IM(deltaH11);\n                    IM(deltaH12) = -IM(deltaH12);\n                    IM(deltaH21) = -IM(deltaH21);\n                    IM(deltaH22) = -IM(deltaH22);\n\n                    IM(H11) = -IM(H11);\n                    IM(H12) = -IM(H12);\n                    IM(H21) = -IM(H21);\n                    IM(H22) = -IM(H22);\n                }\n\n                IM(ps->h11_prev[gr]) = IM(h11);\n                IM(ps->h12_prev[gr]) = IM(h12);\n                IM(ps->h21_prev[gr]) = IM(h21);\n                IM(ps->h22_prev[gr]) = IM(h22);\n            }\n\n            /* apply H_xy to the current envelope band of the decorrelated subband */\n            for (n = ps->border_position[env]; n < ps->border_position[env + 1]; n++)\n            {\n                /* addition finalises the interpolation over every n */\n                RE(H11) += RE(deltaH11);\n                RE(H12) += RE(deltaH12);\n                RE(H21) += RE(deltaH21);\n                RE(H22) += RE(deltaH22);\n                if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                {\n                    IM(H11) += IM(deltaH11);\n                    IM(H12) += IM(deltaH12);\n                    IM(H21) += IM(deltaH21);\n                    IM(H22) += IM(deltaH22);\n                }\n\n                /* channel is an alias to the subband */\n                for (sb = ps->group_border[gr]; sb < maxsb; sb++)\n                {\n                    complex_t inLeft, inRight;\n\n                    /* load decorrelated samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(inLeft) =  RE(X_hybrid_left[n][sb]);\n                        IM(inLeft) =  IM(X_hybrid_left[n][sb]);\n                        RE(inRight) = RE(X_hybrid_right[n][sb]);\n                        IM(inRight) = IM(X_hybrid_right[n][sb]);\n                    } else {\n                        RE(inLeft) =  RE(X_left[n][sb]);\n                        IM(inLeft) =  IM(X_left[n][sb]);\n                        RE(inRight) = RE(X_right[n][sb]);\n                        IM(inRight) = IM(X_right[n][sb]);\n                    }\n\n                    /* apply mixing */\n                    RE(tempLeft) =  MUL_C(RE(H11), RE(inLeft)) + MUL_C(RE(H21), RE(inRight));\n                    IM(tempLeft) =  MUL_C(RE(H11), IM(inLeft)) + MUL_C(RE(H21), IM(inRight));\n                    RE(tempRight) = MUL_C(RE(H12), RE(inLeft)) + MUL_C(RE(H22), RE(inRight));\n                    IM(tempRight) = MUL_C(RE(H12), IM(inLeft)) + MUL_C(RE(H22), IM(inRight));\n\n                    /* only perform imaginary operations when needed */\n                    if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))\n                    {\n                        /* apply rotation */\n                        RE(tempLeft)  -= MUL_C(IM(H11), IM(inLeft)) + MUL_C(IM(H21), IM(inRight));\n                        IM(tempLeft)  += MUL_C(IM(H11), RE(inLeft)) + MUL_C(IM(H21), RE(inRight));\n                        RE(tempRight) -= MUL_C(IM(H12), IM(inLeft)) + MUL_C(IM(H22), IM(inRight));\n                        IM(tempRight) += MUL_C(IM(H12), RE(inLeft)) + MUL_C(IM(H22), RE(inRight));\n                    }\n\n                    /* store final samples */\n                    if (gr < ps->num_hybrid_groups)\n                    {\n                        RE(X_hybrid_left[n][sb])  = RE(tempLeft);\n                        IM(X_hybrid_left[n][sb])  = IM(tempLeft);\n                        RE(X_hybrid_right[n][sb]) = RE(tempRight);\n                        IM(X_hybrid_right[n][sb]) = IM(tempRight);\n                    } else {\n                        RE(X_left[n][sb])  = RE(tempLeft);\n                        IM(X_left[n][sb])  = IM(tempLeft);\n                        RE(X_right[n][sb]) = RE(tempRight);\n                        IM(X_right[n][sb]) = IM(tempRight);\n                    }\n                }\n            }\n\n            /* shift phase smoother's circular buffer index */\n            ps->phase_hist++;\n            if (ps->phase_hist == 2)\n            {\n                ps->phase_hist = 0;\n            }\n        }\n    }\n}""}, {""func_name"": ""reconstruct_single_channel"", ""file_path"": ""libfaad/specrec.c"", ""func_code"": ""uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,\n                                   element *sce, int16_t *spec_data)\n{\n    uint8_t retval;\n    int output_channels;\n    ALIGN real_t spec_coef[1024];\n\n#ifdef PROFILE\n    int64_t count = faad_get_ts();\n#endif\n\n\n    /* always allocate 2 channels, PS can always \""suddenly\"" turn up */\n#if ( (defined(DRM) && defined(DRM_PS)) )\n    output_channels = 2;\n#elif defined(PS_DEC)\n    if (hDecoder->ps_used[hDecoder->fr_ch_ele])\n        output_channels = 2;\n    else\n        output_channels = 1;\n#else\n    output_channels = 1;\n#endif\n\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {\n        /* element inconsistency\n         * this only happens if PS is actually found but not in the first frame\n         * this means that there is only 1 bitstream element!\n         */\n\n        if (hDecoder->fr_channels == 1) {\n            /* reset the allocation */\n            hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;\n            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;\n        } else {\n            return 21;\n        }\n    }\n\n    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)\n    {\n        retval = allocate_single_channel(hDecoder, sce->channel, output_channels);\n        if (retval > 0)\n            return retval;\n\n        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;\n    }\n\n\n    /* dequantisation and scaling */\n    retval = quant_to_spec(hDecoder, ics, spec_data, spec_coef, hDecoder->frameLength);\n    if (retval > 0)\n        return retval;\n\n#ifdef PROFILE\n    count = faad_get_ts() - count;\n    hDecoder->requant_cycles += count;\n#endif\n\n\n    /* pns decoding */\n    pns_decode(ics, NULL, spec_coef, NULL, hDecoder->frameLength, 0, hDecoder->object_type,\n        &(hDecoder->__r1), &(hDecoder->__r2));\n\n#ifdef MAIN_DEC\n    /* MAIN object type prediction */\n    if (hDecoder->object_type == MAIN)\n    {\n\t\tif (!hDecoder->pred_stat[sce->channel])\n\t\t\treturn 33;\n\n        /* intra channel prediction */\n        ic_prediction(ics, spec_coef, hDecoder->pred_stat[sce->channel], hDecoder->frameLength,\n            hDecoder->sf_index);\n\n        /* In addition, for scalefactor bands coded by perceptual\n           noise substitution the predictors belonging to the\n           corresponding spectral coefficients are reset.\n        */\n        pns_reset_pred_state(ics, hDecoder->pred_stat[sce->channel]);\n    }\n#endif\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n#ifdef LD_DEC\n        if (hDecoder->object_type == LD)\n        {\n            if (ics->ltp.data_present)\n            {\n                if (ics->ltp.lag_update)\n                    hDecoder->ltp_lag[sce->channel] = ics->ltp.lag;\n            }\n            ics->ltp.lag = hDecoder->ltp_lag[sce->channel];\n        }\n#endif\n\n        /* long term prediction */\n        lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[sce->channel], hDecoder->fb,\n            ics->window_shape, hDecoder->window_shape_prev[sce->channel],\n            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);\n    }\n#endif\n\n    /* tns decoding */\n    tns_decode_frame(ics, &(ics->tns), hDecoder->sf_index, hDecoder->object_type,\n        spec_coef, hDecoder->frameLength);\n\n    /* drc decoding */\n    if (hDecoder->drc->present)\n    {\n        if (!hDecoder->drc->exclude_mask[sce->channel] || !hDecoder->drc->excluded_chns_present)\n            drc_decode(hDecoder->drc, spec_coef);\n    }\n\n    /* filter bank */\n#ifdef SSR_DEC\n    if (hDecoder->object_type != SSR)\n    {\n#endif\n        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef,\n            hDecoder->time_out[sce->channel], hDecoder->fb_intermed[sce->channel],\n            hDecoder->object_type, hDecoder->frameLength);\n#ifdef SSR_DEC\n    } else {\n        ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,\n            hDecoder->window_shape_prev[sce->channel], spec_coef, hDecoder->time_out[sce->channel],\n            hDecoder->ssr_overlap[sce->channel], hDecoder->ipqf_buffer[sce->channel], hDecoder->prev_fmd[sce->channel],\n            hDecoder->frameLength);\n    }\n#endif\n\n    /* save window shape for next frame */\n    hDecoder->window_shape_prev[sce->channel] = ics->window_shape;\n\n#ifdef LTP_DEC\n    if (is_ltp_ot(hDecoder->object_type))\n    {\n        lt_update_state(hDecoder->lt_pred_stat[sce->channel], hDecoder->time_out[sce->channel],\n            hDecoder->fb_intermed[sce->channel], hDecoder->frameLength, hDecoder->object_type);\n    }\n#endif\n\n#ifdef SBR_DEC\n    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n\n        /* following case can happen when forceUpSampling == 1 */\n        if (hDecoder->sbr[ele] == NULL)\n        {\n            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,\n                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),\n                hDecoder->downSampledSBR\n#ifdef DRM\n                , 0\n#endif\n                );\n        }\n\n        if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)\n            hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n        else\n            hDecoder->sbr[ele]->maxAACLine = min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);\n\n        /* check if any of the PS tools is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n        if (hDecoder->ps_used[ele] == 0)\n        {\n#endif\n            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);\n#if (defined(PS_DEC) || defined(DRM_PS))\n        } else {\n            retval = sbrDecodeSingleFramePS(hDecoder->sbr[ele], hDecoder->time_out[ch],\n                hDecoder->time_out[ch+1], hDecoder->postSeekResetFlag,\n                hDecoder->downSampledSBR);\n        }\n#endif\n        if (retval > 0)\n            return retval;\n    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))\n        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])\n    {\n        return 23;\n    }\n#endif\n\n    /* copy L to R when no PS is used */\n#if (defined(PS_DEC) || defined(DRM_PS))\n    if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&\n        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))\n    {\n        int ele = hDecoder->fr_ch_ele;\n        int ch = sce->channel;\n        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;\n        frame_size *= hDecoder->frameLength*sizeof(real_t);\n\n        memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);\n    }\n#endif\n\n    return 0;\n}""}]","{""value"": 7, ""function"": 3, ""code"": 2}","[{""source"": ""value_info(file:ps_dec.c, value:ps->iid_index)"", ""result"": {""value_trace"": [{""full_code"": ""ps->iid_index[0][bin] = ps->iid_index_prev[bin]"", ""line"": 867, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[0][bin] = 0"", ""line"": 870, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index_prev[bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 900, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[ps->num_env][bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 926, ""func_name"": ""ps_data_decode""}], ""struct_var"": ""ps"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:ps_dec.c, value:no_iid_steps)"", ""result"": {""value_trace"": [{""full_code"": ""no_iid_steps = 15"", ""line"": 1470, ""func_name"": ""ps_mix_phase""}, {""full_code"": ""no_iid_steps = 7"", ""line"": 1473, ""func_name"": ""ps_mix_phase""}], ""struct_var"": ""no_iid_steps"", ""struct_type"": ""uint8_t"", ""struct_definition"": ""typedef unsigned char uint8_t;""}}, {""source"": ""value_info(file:ps_dec.c, value:ps->iid_index)"", ""result"": {""value_trace"": [{""full_code"": ""ps->iid_index[0][bin] = ps->iid_index_prev[bin]"", ""line"": 867, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[0][bin] = 0"", ""line"": 870, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index_prev[bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 900, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[ps->num_env][bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 926, ""func_name"": ""ps_data_decode""}], ""struct_var"": ""ps"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:ps_dec.c, value:iid_mode)"", ""result"": {""value_trace"": [{""full_code"": ""ps->iid_mode = (uint8_t)faad_getbits(ld, 3\n                DEBUGVAR(1,1002,\""ps_data(): iid_mode\""))"", ""line"": 351, ""func_name"": ""ps_data""}], ""struct_var"": ""iid_mode"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:ps_dec.c, value:no_iid_steps)"", ""result"": {""value_trace"": [{""full_code"": ""no_iid_steps = 15"", ""line"": 1470, ""func_name"": ""ps_mix_phase""}, {""full_code"": ""no_iid_steps = 7"", ""line"": 1473, ""func_name"": ""ps_mix_phase""}], ""struct_var"": ""no_iid_steps"", ""struct_type"": ""uint8_t"", ""struct_definition"": ""typedef unsigned char uint8_t;""}}, {""source"": ""func_info(file:ps_dec.c, func:ps_data_decode)"", ""result"": [{""code"": ""static void ps_data_decode(ps_info *ps)\n{\n    uint8_t env, bin;\n\n    /* ps data not available, use data from previous frame */\n    if (ps->ps_data_available == 0)\n    {\n        ps->num_env = 0;\n    }\n\n    for (env = 0; env < ps->num_env; env++)\n    {\n        int8_t *iid_index_prev;\n        int8_t *icc_index_prev;\n        int8_t *ipd_index_prev;\n        int8_t *opd_index_prev;\n\n        int8_t num_iid_steps = (ps->iid_mode < 3) ? 7 : 15 /*fine quant*/;\n\n        if (env == 0)\n        {\n            /* take last envelope from previous frame */\n            iid_index_prev = ps->iid_index_prev;\n            icc_index_prev = ps->icc_index_prev;\n            ipd_index_prev = ps->ipd_index_prev;\n            opd_index_prev = ps->opd_index_prev;\n        } else {\n            /* take index values from previous envelope */\n            iid_index_prev = ps->iid_index[env - 1];\n            icc_index_prev = ps->icc_index[env - 1];\n            ipd_index_prev = ps->ipd_index[env - 1];\n            opd_index_prev = ps->opd_index[env - 1];\n        }\n\n//        iid = 1;\n        /* delta decode iid parameters */\n        delta_decode(ps->enable_iid, ps->iid_index[env], iid_index_prev,\n            ps->iid_dt[env], ps->nr_iid_par,\n            (ps->iid_mode == 0 || ps->iid_mode == 3) ? 2 : 1,\n            -num_iid_steps, num_iid_steps);\n//        iid = 0;\n\n        /* delta decode icc parameters */\n        delta_decode(ps->enable_icc, ps->icc_index[env], icc_index_prev,\n            ps->icc_dt[env], ps->nr_icc_par,\n            (ps->icc_mode == 0 || ps->icc_mode == 3) ? 2 : 1,\n            0, 7);\n\n        /* delta modulo decode ipd parameters */\n        delta_modulo_decode(ps->enable_ipdopd, ps->ipd_index[env], ipd_index_prev,\n            ps->ipd_dt[env], ps->nr_ipdopd_par, 1, 7);\n\n        /* delta modulo decode opd parameters */\n        delta_modulo_decode(ps->enable_ipdopd, ps->opd_index[env], opd_index_prev,\n            ps->opd_dt[env], ps->nr_ipdopd_par, 1, 7);\n    }\n\n    /* handle error case */\n    if (ps->num_env == 0)\n    {\n        /* force to 1 */\n        ps->num_env = 1;\n\n        if (ps->enable_iid)\n        {\n            for (bin = 0; bin < 34; bin++)\n                ps->iid_index[0][bin] = ps->iid_index_prev[bin];\n        } else {\n            for (bin = 0; bin < 34; bin++)\n                ps->iid_index[0][bin] = 0;\n        }\n\n        if (ps->enable_icc)\n        {\n            for (bin = 0; bin < 34; bin++)\n                ps->icc_index[0][bin] = ps->icc_index_prev[bin];\n        } else {\n            for (bin = 0; bin < 34; bin++)\n                ps->icc_index[0][bin] = 0;\n        }\n\n        if (ps->enable_ipdopd)\n        {\n            for (bin = 0; bin < 17; bin++)\n            {\n                ps->ipd_index[0][bin] = ps->ipd_index_prev[bin];\n                ps->opd_index[0][bin] = ps->opd_index_prev[bin];\n            }\n        } else {\n            for (bin = 0; bin < 17; bin++)\n            {\n                ps->ipd_index[0][bin] = 0;\n                ps->opd_index[0][bin] = 0;\n            }\n        }\n    }\n\n    /* update previous indices */\n    for (bin = 0; bin < 34; bin++)\n        ps->iid_index_prev[bin] = ps->iid_index[ps->num_env-1][bin];\n    for (bin = 0; bin < 34; bin++)\n        ps->icc_index_prev[bin] = ps->icc_index[ps->num_env-1][bin];\n    for (bin = 0; bin < 17; bin++)\n    {\n        ps->ipd_index_prev[bin] = ps->ipd_index[ps->num_env-1][bin];\n        ps->opd_index_prev[bin] = ps->opd_index[ps->num_env-1][bin];\n    }\n\n    ps->ps_data_available = 0;\n\n    if (ps->frame_class == 0)\n    {\n        ps->border_position[0] = 0;\n        for (env = 1; env < ps->num_env; env++)\n        {\n            ps->border_position[env] = (env * ps->numTimeSlotsRate) / ps->num_env;\n        }\n        ps->border_position[ps->num_env] = ps->numTimeSlotsRate;\n    } else {\n        ps->border_position[0] = 0;\n\n        if (ps->border_position[ps->num_env] < ps->numTimeSlotsRate)\n        {\n            for (bin = 0; bin < 34; bin++)\n            {\n                ps->iid_index[ps->num_env][bin] = ps->iid_index[ps->num_env-1][bin];\n                ps->icc_index[ps->num_env][bin] = ps->icc_index[ps->num_env-1][bin];\n            }\n            for (bin = 0; bin < 17; bin++)\n            {\n                ps->ipd_index[ps->num_env][bin] = ps->ipd_index[ps->num_env-1][bin];\n                ps->opd_index[ps->num_env][bin] = ps->opd_index[ps->num_env-1][bin];\n            }\n            ps->num_env++;\n            ps->border_position[ps->num_env] = ps->numTimeSlotsRate;\n        }\n\n        for (env = 1; env < ps->num_env; env++)\n        {\n            int8_t thr = ps->numTimeSlotsRate - (ps->num_env - env);\n\n            if (ps->border_position[env] > thr)\n            {\n                ps->border_position[env] = thr;\n            } else {\n                thr = ps->border_position[env-1]+1;\n                if (ps->border_position[env] < thr)\n                {\n                    ps->border_position[env] = thr;\n                }\n            }\n        }\n    }\n\n    /* make sure that the indices of all parameters can be mapped\n     * to the same hybrid synthesis filterbank\n     */\n#ifdef PS_LOW_POWER\n    for (env = 0; env < ps->num_env; env++)\n    {\n        if (ps->iid_mode == 2 || ps->iid_mode == 5)\n            map34indexto20(ps->iid_index[env], 34);\n        if (ps->icc_mode == 2 || ps->icc_mode == 5)\n            map34indexto20(ps->icc_index[env], 34);\n\n        /* disable ipd/opd */\n        for (bin = 0; bin < 17; bin++)\n        {\n            ps->aaIpdIndex[env][bin] = 0;\n            ps->aaOpdIndex[env][bin] = 0;\n        }\n    }\n#else\n    if (ps->use34hybrid_bands)\n    {\n        for (env = 0; env < ps->num_env; env++)\n        {\n            if (ps->iid_mode != 2 && ps->iid_mode != 5)\n                map20indexto34(ps->iid_index[env], 34);\n            if (ps->icc_mode != 2 && ps->icc_mode != 5)\n                map20indexto34(ps->icc_index[env], 34);\n            if (ps->ipd_mode != 2 && ps->ipd_mode != 5)\n            {\n                map20indexto34(ps->ipd_index[env], 17);\n                map20indexto34(ps->opd_index[env], 17);\n            }\n        }\n    }\n#endif\n\n#if 0\n    for (env = 0; env < ps->num_env; env++)\n    {\n        printf(\""iid[env:%d]:\"", env);\n        for (bin = 0; bin < 34; bin++)\n        {\n            printf(\"" %d\"", ps->iid_index[env][bin]);\n        }\n        printf(\""\\n\"");\n    }\n    for (env = 0; env < ps->num_env; env++)\n    {\n        printf(\""icc[env:%d]:\"", env);\n        for (bin = 0; bin < 34; bin++)\n        {\n            printf(\"" %d\"", ps->icc_index[env][bin]);\n        }\n        printf(\""\\n\"");\n    }\n    for (env = 0; env < ps->num_env; env++)\n    {\n        printf(\""ipd[env:%d]:\"", env);\n        for (bin = 0; bin < 17; bin++)\n        {\n            printf(\"" %d\"", ps->ipd_index[env][bin]);\n        }\n        printf(\""\\n\"");\n    }\n    for (env = 0; env < ps->num_env; env++)\n    {\n        printf(\""opd[env:%d]:\"", env);\n        for (bin = 0; bin < 17; bin++)\n        {\n            printf(\"" %d\"", ps->opd_index[env][bin]);\n        }\n        printf(\""\\n\"");\n    }\n    printf(\""\\n\"");\n#endif\n}\n"", ""start_line"": 801, ""end_line"": 1030, ""full_name"": ""ps_data_decode"", ""file_path"": ""libfaad/ps_dec.c""}]}, {""source"": ""code_info(file:ps_dec.c, lines:867-870)"", ""result"": ""                ps->iid_index[0][bin] = ps->iid_index_prev[bin];\n        } else {\n            for (bin = 0; bin < 34; bin++)\n                ps->iid_index[0][bin] = 0;\n""}, {""source"": ""code_info(file:ps_dec.c, lines:900-926)"", ""result"": ""        ps->iid_index_prev[bin] = ps->iid_index[ps->num_env-1][bin];\n    for (bin = 0; bin < 34; bin++)\n        ps->icc_index_prev[bin] = ps->icc_index[ps->num_env-1][bin];\n    for (bin = 0; bin < 17; bin++)\n    {\n        ps->ipd_index_prev[bin] = ps->ipd_index[ps->num_env-1][bin];\n        ps->opd_index_prev[bin] = ps->opd_index[ps->num_env-1][bin];\n    }\n\n    ps->ps_data_available = 0;\n\n    if (ps->frame_class == 0)\n    {\n        ps->border_position[0] = 0;\n        for (env = 1; env < ps->num_env; env++)\n        {\n            ps->border_position[env] = (env * ps->numTimeSlotsRate) / ps->num_env;\n        }\n        ps->border_position[ps->num_env] = ps->numTimeSlotsRate;\n    } else {\n        ps->border_position[0] = 0;\n\n        if (ps->border_position[ps->num_env] < ps->numTimeSlotsRate)\n        {\n            for (bin = 0; bin < 34; bin++)\n            {\n                ps->iid_index[ps->num_env][bin] = ps->iid_index[ps->num_env-1][bin];\n""}, {""source"": ""value_info(file:ps_dec.c, value:ps->iid_index)"", ""result"": {""value_trace"": [{""full_code"": ""ps->iid_index[0][bin] = ps->iid_index_prev[bin]"", ""line"": 867, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[0][bin] = 0"", ""line"": 870, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index_prev[bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 900, ""func_name"": ""ps_data_decode""}, {""full_code"": ""ps->iid_index[ps->num_env][bin] = ps->iid_index[ps->num_env-1][bin]"", ""line"": 926, ""func_name"": ""ps_data_decode""}], ""struct_var"": ""ps"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:ps_dec.c, func:delta_decode)"", ""result"": [{""code"": ""static void delta_decode(uint8_t enable, int8_t *index, int8_t *index_prev,\n                         uint8_t dt_flag, uint8_t nr_par, uint8_t stride,\n                         int8_t min_index, int8_t max_index)\n{\n    int8_t i;\n\n    if (enable == 1)\n    {\n        if (dt_flag == 0)\n        {\n            /* delta coded in frequency direction */\n            index[0] = 0 + index[0];\n            index[0] = delta_clip(index[0], min_index, max_index);\n\n            for (i = 1; i < nr_par; i++)\n            {\n                index[i] = index[i-1] + index[i];\n                index[i] = delta_clip(index[i], min_index, max_index);\n            }\n        } else {\n            /* delta coded in time direction */\n            for (i = 0; i < nr_par; i++)\n            {\n                //int8_t tmp2;\n                //int8_t tmp = index[i];\n\n                //printf(\""%d %d\\n\"", index_prev[i*stride], index[i]);\n                //printf(\""%d\\n\"", index[i]);\n\n                index[i] = index_prev[i*stride] + index[i];\n                //tmp2 = index[i];\n                index[i] = delta_clip(index[i], min_index, max_index);\n\n                //if (iid)\n                //{\n                //    if (index[i] == 7)\n                //    {\n                //        printf(\""%d %d %d\\n\"", index_prev[i*stride], tmp, tmp2);\n                //    }\n                //}\n            }\n        }\n    } else {\n        /* set indices to zero */\n        for (i = 0; i < nr_par; i++)\n        {\n            index[i] = 0;\n        }\n    }\n\n    /* coarse */\n    if (stride == 2)\n    {\n        for (i = (nr_par<<1)-1; i > 0; i--)\n        {\n            index[i] = index[i>>1];\n        }\n    }\n}\n"", ""start_line"": 620, ""end_line"": 678, ""full_name"": ""delta_decode"", ""file_path"": ""libfaad/ps_dec.c""}]}, {""source"": ""value_info(file:ps_dec.c, value:ps->iid_mode)"", ""result"": {""value_trace"": [{""full_code"": ""ps->iid_mode = (uint8_t)faad_getbits(ld, 3\n                DEBUGVAR(1,1002,\""ps_data(): iid_mode\""))"", ""line"": 351, ""func_name"": ""ps_data""}], ""struct_var"": ""ps"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(file:ps_dec.c, func:delta_clip)"", ""result"": [{""code"": ""static int8_t delta_clip(int8_t i, int8_t min, int8_t max)\n{\n    if (i < min)\n        return min;\n    else if (i > max)\n        return max;\n    else\n        return i;\n}"", ""start_line"": 607, ""end_line"": 615, ""full_name"": ""delta_clip"", ""file_path"": ""libfaad/ps_dec.c""}]}]","libfaad/ps_dec.c:1521-1522: Out-of-bounds access in `sf_iid[no_iid_steps + ps->iid_index[]]` occurs when `ps->iid_index` contains values outside [-no_iid_steps, no_iid_steps]. The root cause is incorrect handling of `dt_flag == 0` in `delta_decode` (libfaad/ps_dec.c:620-678), which does not use `index_prev` for the first element, leading to potential unclamped values. `ps->iid_index` is populated in `ps_data_decode` (libfaad/ps_dec.c:867,870,900,926) via `delta_decode`, which relies on `delta_clip` (libfaad/ps_dec.c:607-615) to enforce bounds. The patch in `ps_mix_phase` clamps `iid_index` to prevent OOB access.",0.95,./github/other_context/CVE-2018-20360
68,CVE-2018-6197,CWE-476,c_cpp,w3m through 0.5.3 is prone to a NULL pointer dereference flaw in formUpdateBuffer in form.c.,https://github.com/tats/w3m/commit/7fdc83b0364005a0b5ed869230dd81752ba022e8,Prevent invalid columnPos() call in formUpdateBuffer()\n\nBug-Debian: https://github.com/tats/w3m/issues/89,1,"[{""func_name"": ""formUpdateBuffer"", ""file_path"": ""form.c"", ""func_code"": ""void\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}"", ""target"": 0}]","[{""func_name"": ""formUpdateBuffer"", ""file_path"": ""form.c"", ""func_code"": ""void\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n\t    break;\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (l == NULL)\n\t\tbreak;\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len ||\n\t\tspos < 0 || epos < 0 || COLPOS(l, epos) < col)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}""}]","{""code"": 2, ""value"": 2}","[{""source"": ""code_info(file:form.c, lines:450-490)"", ""result"": ""\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t{\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\t}\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n""}, {""source"": ""value_info(file:form.c, value:l)"", ""result"": {""value_trace"": [{""full_code"": ""l = New(struct form_list)"", ""line"": 69, ""func_name"": ""newFormList""}, {""full_code"": ""l = buf->currentLine"", ""line"": 470, ""func_name"": ""formUpdateBuffer""}, {""full_code"": ""l = l->prev"", ""line"": 476, ""func_name"": ""formUpdateBuffer""}, {""full_code"": ""l = l->prev"", ""line"": 478, ""func_name"": ""formUpdateBuffer""}, {""full_code"": ""l = l->next"", ""line"": 484, ""func_name"": ""formUpdateBuffer""}], ""struct_var"": ""l"", ""struct_type"": ""form_list*"", ""struct_definition"": ""typedef struct form_list {\n    struct form_item_list *item;\n    struct form_item_list *lastitem;\n    int method;\n    Str action;\n    char *target;\n    char *name;\n#ifdef USE_M17N\n    wc_ces charset;\n#endif\n    int enctype;\n    struct form_list *next;\n    int nitems;\n    char *body;\n    char *boundary;\n    unsigned long length;\n}\n\nstruct form_list\n\nstruct form_list\n\nextern struct form_list""}}, {""source"": ""code_info(file:form.c, lines:100-150)"", ""result"": ""    item = New(struct form_item_list);\n    item->type = FORM_UNKNOWN;\n    item->size = -1;\n    item->rows = 0;\n    item->checked = item->init_checked = 0;\n    item->accept = 0;\n    item->name = NULL;\n    item->value = item->init_value = NULL;\n    item->readonly = 0;\n    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\titem->type = formtype(p);\n\tif (item->size < 0 &&\n\t    (item->type == FORM_INPUT_TEXT ||\n\t     item->type == FORM_INPUT_FILE ||\n\t     item->type == FORM_INPUT_PASSWORD))\n\t    item->size = FORM_I_TEXT_DEFAULT_SIZE;\n    }\n    if (parsedtag_get_value(tag, ATTR_NAME, &p))\n\titem->name = Strnew_charp(p);\n    if (parsedtag_get_value(tag, ATTR_VALUE, &p))\n\titem->value = item->init_value = Strnew_charp(p);\n    item->checked = item->init_checked = parsedtag_exists(tag, ATTR_CHECKED);\n    item->accept = parsedtag_exists(tag, ATTR_ACCEPT);\n    parsedtag_get_value(tag, ATTR_SIZE, &item->size);\n    parsedtag_get_value(tag, ATTR_MAXLENGTH, &item->maxlength);\n    item->readonly = parsedtag_exists(tag, ATTR_READONLY);\n    if (parsedtag_get_value(tag, ATTR_TEXTAREANUMBER, &i)\n\t&& i >= 0 && i < max_textarea)\n\titem->value = item->init_value = textarea_str[i];\n#ifdef MENU_SELECT\n    if (parsedtag_get_value(tag, ATTR_SELECTNUMBER, &i)\n\t&& i >= 0 && i < max_select)\n\titem->select_option = select_option[i].first;\n#endif\t\t\t\t/* MENU_SELECT */\n    if (parsedtag_get_value(tag, ATTR_ROWS, &p))\n\titem->rows = atoi(p);\n    if (item->type == FORM_UNKNOWN) {\n\t/* type attribute is missing. Ignore the tag. */\n\treturn NULL;\n    }\n#ifdef MENU_SELECT\n    if (item->type == FORM_SELECT) {\n\tchooseSelectOption(item, item->select_option);\n\titem->init_selected = item->selected;\n\titem->init_value = item->value;\n\titem->init_label = item->label;\n    }\n#endif\t\t\t\t/* MENU_SELECT */\n    if (item->type == FORM_INPUT_FILE && item->value && item->value->length) {\n\t/* security hole ! */\n\treturn NULL;\n""}, {""source"": ""value_info(file:form.c, value:form->rows)"", ""result"": {""value_trace"": [{""full_code"": ""a_form->rows = 1 + top + bottom"", ""line"": 5908, ""func_name"": ""HTMLlineproc2body""}], ""struct_var"": ""form"", ""struct_type"": null, ""struct_definition"": null}}]","form.c:483-487: Loop iterates 'rows' times (from form->rows) with l = l->next without NULL check. If the line list (buf->currentLine) is shorter than rows, l becomes NULL. form.c:100-150 shows form->rows is initialized via parsedtag_get_value(ATTR_ROWS) → atoi(p) without validation, allowing attacker-controlled large values. This creates a NULL dereference in columnPos(l, col) when l is NULL.",0.95,./github/other_context/CVE-2018-6197
69,CVE-2019-11338,CWE-476,c_cpp,"libavcodec/hevcdec.c in FFmpeg 3.4 and 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",https://github.com/FFmpeg/FFmpeg/commit/9ccc633068c6fe76989f487c8932bd11886ad65b,avcodec/hevcdec: Avoid only partly skiping duplicate first slices\n\nFixes: NULL pointer dereference and out of array access\nFixes: 13871/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5746167087890432\nFixes: 13845/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5650370728034304\n\nThis also fixes the return code for explode mode\n\nFound-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg\nReviewed-by: James Almer <jamrial@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 54655623a82632e7624714d7b2a3e039dc5faa7e)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>,2,"[{""func_name"": ""decode_nal_unit"", ""file_path"": ""libavcodec/hevcdec.c"", ""func_code"": ""static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n    s->temporal_id   = nal->temporal_id;\n\n    switch (s->nal_unit_type) {\n    case HEVC_NAL_VPS:\n        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SPS:\n        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,\n                                     s->apply_defdispwin);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_PPS:\n        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SEI_PREFIX:\n    case HEVC_NAL_SEI_SUFFIX:\n        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->ref) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Two slices reporting being the first in the same frame.\\n\"");\n                goto fail;\n            }\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&\n                s->poc <= s->max_ra) {\n                s->is_decoded = 0;\n                break;\n            } else {\n                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)\n                    s->max_ra = INT_MIN;\n            }\n\n            ret = hevc_frame_start(s);\n            if (ret < 0)\n                return ret;\n        } else if (!s->ref) {\n            av_log(s->avctx, AV_LOG_ERROR, \""First slice in a frame missing.\\n\"");\n            goto fail;\n        }\n\n        if (s->nal_unit_type != s->first_nal_type) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \""Non-matching NAL types of the VCL NALUs: %d %d\\n\"",\n                   s->first_nal_type, s->nal_unit_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!s->sh.dependent_slice_segment_flag &&\n            s->sh.slice_type != HEVC_SLICE_I) {\n            ret = ff_hevc_slice_rpl(s);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \""Error constructing the reference lists for the current slice.\\n\"");\n                goto fail;\n            }\n        }\n\n        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);\n            if (ret < 0)\n                goto fail;\n        }\n\n        if (s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        } else {\n            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)\n                ctb_addr_ts = hls_slice_data_wpp(s, nal);\n            else\n                ctb_addr_ts = hls_slice_data(s);\n            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {\n                s->is_decoded = 1;\n            }\n\n            if (ctb_addr_ts < 0) {\n                ret = ctb_addr_ts;\n                goto fail;\n            }\n        }\n        break;\n    case HEVC_NAL_EOS_NUT:\n    case HEVC_NAL_EOB_NUT:\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        break;\n    case HEVC_NAL_AUD:\n    case HEVC_NAL_FD_NUT:\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_INFO,\n               \""Skipping NAL unit %d\\n\"", s->nal_unit_type);\n    }\n\n    return 0;\nfail:\n    if (s->avctx->err_recognition & AV_EF_EXPLODE)\n        return ret;\n    return 0;\n}"", ""target"": 0}, {""func_name"": ""hls_slice_header"", ""file_path"": ""libavcodec/hevcdec.c"", ""func_code"": ""static int hls_slice_header(HEVCContext *s)\n{\n    GetBitContext *gb = &s->HEVClc->gb;\n    SliceHeader *sh   = &s->sh;\n    int i, ret;\n\n    // Coded parameters\n    sh->first_slice_in_pic_flag = get_bits1(gb);\n    if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        if (IS_IDR(s))\n            ff_hevc_clear_refs(s);\n    }\n    sh->no_output_of_prior_pics_flag = 0;\n    if (IS_IRAP(s))\n        sh->no_output_of_prior_pics_flag = get_bits1(gb);\n\n    sh->pps_id = get_ue_golomb_long(gb);\n    if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS id out of range: %d\\n\"", sh->pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!sh->first_slice_in_pic_flag &&\n        s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS changed between slices.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n    s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;\n    if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)\n        sh->no_output_of_prior_pics_flag = 1;\n\n    if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {\n        const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;\n        const HEVCSPS *last_sps = s->ps.sps;\n        enum AVPixelFormat pix_fmt;\n\n        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {\n            if (sps->width != last_sps->width || sps->height != last_sps->height ||\n                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=\n                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)\n                sh->no_output_of_prior_pics_flag = 0;\n        }\n        ff_hevc_clear_refs(s);\n\n        pix_fmt = get_format(s, sps);\n        if (pix_fmt < 0)\n            return pix_fmt;\n\n        ret = set_sps(s, sps, pix_fmt);\n        if (ret < 0)\n            return ret;\n\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n    }\n\n    sh->dependent_slice_segment_flag = 0;\n    if (!sh->first_slice_in_pic_flag) {\n        int slice_address_length;\n\n        if (s->ps.pps->dependent_slice_segments_enabled_flag)\n            sh->dependent_slice_segment_flag = get_bits1(gb);\n\n        slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *\n                                            s->ps.sps->ctb_height);\n        sh->slice_segment_addr = get_bitsz(gb, slice_address_length);\n        if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \""Invalid slice segment address: %u.\\n\"",\n                   sh->slice_segment_addr);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!sh->dependent_slice_segment_flag) {\n            sh->slice_addr = sh->slice_segment_addr;\n            s->slice_idx++;\n        }\n    } else {\n        sh->slice_segment_addr = sh->slice_addr = 0;\n        s->slice_idx           = 0;\n        s->slice_initialized   = 0;\n    }\n\n    if (!sh->dependent_slice_segment_flag) {\n        s->slice_initialized = 0;\n\n        for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)\n            skip_bits(gb, 1);  // slice_reserved_undetermined_flag[]\n\n        sh->slice_type = get_ue_golomb_long(gb);\n        if (!(sh->slice_type == HEVC_SLICE_I ||\n              sh->slice_type == HEVC_SLICE_P ||\n              sh->slice_type == HEVC_SLICE_B)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Unknown slice type: %d.\\n\"",\n                   sh->slice_type);\n            return AVERROR_INVALIDDATA;\n        }\n        if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Inter slices in an IRAP frame.\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n\n        // when flag is not present, picture is inferred to be output\n        sh->pic_output_flag = 1;\n        if (s->ps.pps->output_flag_present_flag)\n            sh->pic_output_flag = get_bits1(gb);\n\n        if (s->ps.sps->separate_colour_plane_flag)\n            sh->colour_plane_id = get_bits(gb, 2);\n\n        if (!IS_IDR(s)) {\n            int poc, pos;\n\n            sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);\n            poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);\n            if (!sh->first_slice_in_pic_flag && poc != s->poc) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \""Ignoring POC change between slices: %d -> %d\\n\"", s->poc, poc);\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n                poc = s->poc;\n            }\n            s->poc = poc;\n\n            sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);\n            pos = get_bits_left(gb);\n            if (!sh->short_term_ref_pic_set_sps_flag) {\n                ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);\n                if (ret < 0)\n                    return ret;\n\n                sh->short_term_rps = &sh->slice_rps;\n            } else {\n                int numbits, rps_idx;\n\n                if (!s->ps.sps->nb_st_rps) {\n                    av_log(s->avctx, AV_LOG_ERROR, \""No ref lists in the SPS.\\n\"");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                numbits = av_ceil_log2(s->ps.sps->nb_st_rps);\n                rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;\n                sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];\n            }\n            sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            pos = get_bits_left(gb);\n            ret = decode_lt_rps(s, &sh->long_term_rps, gb);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING, \""Invalid long term RPS.\\n\"");\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n            }\n            sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            if (s->ps.sps->sps_temporal_mvp_enabled_flag)\n                sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);\n            else\n                sh->slice_temporal_mvp_enabled_flag = 0;\n        } else {\n            s->sh.short_term_rps = NULL;\n            s->poc               = 0;\n        }\n\n        /* 8.3.1 */\n        if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&\n            s->nal_unit_type != HEVC_NAL_TRAIL_N &&\n            s->nal_unit_type != HEVC_NAL_TSA_N   &&\n            s->nal_unit_type != HEVC_NAL_STSA_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_R  &&\n            s->nal_unit_type != HEVC_NAL_RASL_N  &&\n            s->nal_unit_type != HEVC_NAL_RASL_R)\n            s->pocTid0 = s->poc;\n\n        if (s->ps.sps->sao_enabled) {\n            sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);\n            if (s->ps.sps->chroma_format_idc) {\n                sh->slice_sample_adaptive_offset_flag[1] =\n                sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);\n            }\n        } else {\n            sh->slice_sample_adaptive_offset_flag[0] = 0;\n            sh->slice_sample_adaptive_offset_flag[1] = 0;\n            sh->slice_sample_adaptive_offset_flag[2] = 0;\n        }\n\n        sh->nb_refs[L0] = sh->nb_refs[L1] = 0;\n        if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {\n            int nb_refs;\n\n            sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;\n\n            if (get_bits1(gb)) { // num_ref_idx_active_override_flag\n                sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;\n            }\n            if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Too many refs: %d/%d.\\n\"",\n                       sh->nb_refs[L0], sh->nb_refs[L1]);\n                return AVERROR_INVALIDDATA;\n            }\n\n            sh->rpl_modification_flag[0] = 0;\n            sh->rpl_modification_flag[1] = 0;\n            nb_refs = ff_hevc_frame_nb_refs(s);\n            if (!nb_refs) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Zero refs for a frame with P or B slices.\\n\"");\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {\n                sh->rpl_modification_flag[0] = get_bits1(gb);\n                if (sh->rpl_modification_flag[0]) {\n                    for (i = 0; i < sh->nb_refs[L0]; i++)\n                        sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n\n                if (sh->slice_type == HEVC_SLICE_B) {\n                    sh->rpl_modification_flag[1] = get_bits1(gb);\n                    if (sh->rpl_modification_flag[1] == 1)\n                        for (i = 0; i < sh->nb_refs[L1]; i++)\n                            sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n            }\n\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->mvd_l1_zero_flag = get_bits1(gb);\n\n            if (s->ps.pps->cabac_init_present_flag)\n                sh->cabac_init_flag = get_bits1(gb);\n            else\n                sh->cabac_init_flag = 0;\n\n            sh->collocated_ref_idx = 0;\n            if (sh->slice_temporal_mvp_enabled_flag) {\n                sh->collocated_list = L0;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->collocated_list = !get_bits1(gb);\n\n                if (sh->nb_refs[sh->collocated_list] > 1) {\n                    sh->collocated_ref_idx = get_ue_golomb_long(gb);\n                    if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \""Invalid collocated_ref_idx: %d.\\n\"",\n                               sh->collocated_ref_idx);\n                        return AVERROR_INVALIDDATA;\n                    }\n                }\n            }\n\n            if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||\n                (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {\n                int ret = pred_weight_table(s, gb);\n                if (ret < 0)\n                    return ret;\n            }\n\n            sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);\n            if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \""Invalid number of merging MVP candidates: %d.\\n\"",\n                       sh->max_num_merge_cand);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        sh->slice_qp_delta = get_se_golomb(gb);\n\n        if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {\n            sh->slice_cb_qp_offset = get_se_golomb(gb);\n            sh->slice_cr_qp_offset = get_se_golomb(gb);\n        } else {\n            sh->slice_cb_qp_offset = 0;\n            sh->slice_cr_qp_offset = 0;\n        }\n\n        if (s->ps.pps->chroma_qp_offset_list_enabled_flag)\n            sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);\n        else\n            sh->cu_chroma_qp_offset_enabled_flag = 0;\n\n        if (s->ps.pps->deblocking_filter_control_present_flag) {\n            int deblocking_filter_override_flag = 0;\n\n            if (s->ps.pps->deblocking_filter_override_enabled_flag)\n                deblocking_filter_override_flag = get_bits1(gb);\n\n            if (deblocking_filter_override_flag) {\n                sh->disable_deblocking_filter_flag = get_bits1(gb);\n                if (!sh->disable_deblocking_filter_flag) {\n                    int beta_offset_div2 = get_se_golomb(gb);\n                    int tc_offset_div2   = get_se_golomb(gb) ;\n                    if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||\n                        tc_offset_div2   < -6 || tc_offset_div2   > 6) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                            \""Invalid deblock filter offsets: %d, %d\\n\"",\n                            beta_offset_div2, tc_offset_div2);\n                        return AVERROR_INVALIDDATA;\n                    }\n                    sh->beta_offset = beta_offset_div2 * 2;\n                    sh->tc_offset   =   tc_offset_div2 * 2;\n                }\n            } else {\n                sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;\n                sh->beta_offset                    = s->ps.pps->beta_offset;\n                sh->tc_offset                      = s->ps.pps->tc_offset;\n            }\n        } else {\n            sh->disable_deblocking_filter_flag = 0;\n            sh->beta_offset                    = 0;\n            sh->tc_offset                      = 0;\n        }\n\n        if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&\n            (sh->slice_sample_adaptive_offset_flag[0] ||\n             sh->slice_sample_adaptive_offset_flag[1] ||\n             !sh->disable_deblocking_filter_flag)) {\n            sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);\n        } else {\n            sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;\n        }\n    } else if (!s->slice_initialized) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Independent slice segment missing.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->num_entry_point_offsets = 0;\n    if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {\n        unsigned num_entry_point_offsets = get_ue_golomb_long(gb);\n        // It would be possible to bound this tighter but this here is simpler\n        if (num_entry_point_offsets > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""num_entry_point_offsets %d is invalid\\n\"", num_entry_point_offsets);\n            return AVERROR_INVALIDDATA;\n        }\n\n        sh->num_entry_point_offsets = num_entry_point_offsets;\n        if (sh->num_entry_point_offsets > 0) {\n            int offset_len = get_ue_golomb_long(gb) + 1;\n\n            if (offset_len < 1 || offset_len > 32) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""offset_len %d is invalid\\n\"", offset_len);\n                return AVERROR_INVALIDDATA;\n            }\n\n            av_freep(&sh->entry_point_offset);\n            av_freep(&sh->offset);\n            av_freep(&sh->size);\n            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));\n            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            if (!sh->entry_point_offset || !sh->offset || !sh->size) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""Failed to allocate memory\\n\"");\n                return AVERROR(ENOMEM);\n            }\n            for (i = 0; i < sh->num_entry_point_offsets; i++) {\n                unsigned val = get_bits_long(gb, offset_len);\n                sh->entry_point_offset[i] = val + 1; // +1; // +1 to get the size\n            }\n            if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {\n                s->enable_parallel_tiles = 0; // TODO: you can enable tiles in parallel here\n                s->threads_number = 1;\n            } else\n                s->enable_parallel_tiles = 0;\n        } else\n            s->enable_parallel_tiles = 0;\n    }\n\n    if (s->ps.pps->slice_header_extension_present_flag) {\n        unsigned int length = get_ue_golomb_long(gb);\n        if (length*8LL > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""too many slice_header_extension_data_bytes\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < length; i++)\n            skip_bits(gb, 8);  // slice_header_extension_data_byte\n    }\n\n    // Inferred parameters\n    sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;\n    if (sh->slice_qp > 51 ||\n        sh->slice_qp < -s->ps.sps->qp_bd_offset) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""The slice_qp %d is outside the valid range \""\n               \""[%d, 51].\\n\"",\n               sh->slice_qp,\n               -s->ps.sps->qp_bd_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->slice_ctb_addr_rs = sh->slice_segment_addr;\n\n    if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Impossible slice segment.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (get_bits_left(gb) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""Overread slice header by %d bits\\n\"", -get_bits_left(gb));\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;\n\n    if (!s->ps.pps->cu_qp_delta_enabled_flag)\n        s->HEVClc->qp_y = s->sh.slice_qp;\n\n    s->slice_initialized = 1;\n    s->HEVClc->tu.cu_qp_offset_cb = 0;\n    s->HEVClc->tu.cu_qp_offset_cr = 0;\n\n    return 0;\n}"", ""target"": 0}]","[{""func_name"": ""decode_nal_unit"", ""file_path"": ""libavcodec/hevcdec.c"", ""func_code"": ""static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n    s->temporal_id   = nal->temporal_id;\n\n    switch (s->nal_unit_type) {\n    case HEVC_NAL_VPS:\n        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SPS:\n        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,\n                                     s->apply_defdispwin);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_PPS:\n        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SEI_PREFIX:\n    case HEVC_NAL_SEI_SUFFIX:\n        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n        if (ret == 1) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&\n                s->poc <= s->max_ra) {\n                s->is_decoded = 0;\n                break;\n            } else {\n                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)\n                    s->max_ra = INT_MIN;\n            }\n\n            ret = hevc_frame_start(s);\n            if (ret < 0)\n                return ret;\n        } else if (!s->ref) {\n            av_log(s->avctx, AV_LOG_ERROR, \""First slice in a frame missing.\\n\"");\n            goto fail;\n        }\n\n        if (s->nal_unit_type != s->first_nal_type) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \""Non-matching NAL types of the VCL NALUs: %d %d\\n\"",\n                   s->first_nal_type, s->nal_unit_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!s->sh.dependent_slice_segment_flag &&\n            s->sh.slice_type != HEVC_SLICE_I) {\n            ret = ff_hevc_slice_rpl(s);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \""Error constructing the reference lists for the current slice.\\n\"");\n                goto fail;\n            }\n        }\n\n        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);\n            if (ret < 0)\n                goto fail;\n        }\n\n        if (s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        } else {\n            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)\n                ctb_addr_ts = hls_slice_data_wpp(s, nal);\n            else\n                ctb_addr_ts = hls_slice_data(s);\n            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {\n                s->is_decoded = 1;\n            }\n\n            if (ctb_addr_ts < 0) {\n                ret = ctb_addr_ts;\n                goto fail;\n            }\n        }\n        break;\n    case HEVC_NAL_EOS_NUT:\n    case HEVC_NAL_EOB_NUT:\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        break;\n    case HEVC_NAL_AUD:\n    case HEVC_NAL_FD_NUT:\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_INFO,\n               \""Skipping NAL unit %d\\n\"", s->nal_unit_type);\n    }\n\n    return 0;\nfail:\n    if (s->avctx->err_recognition & AV_EF_EXPLODE)\n        return ret;\n    return 0;\n}""}, {""func_name"": ""hls_slice_header"", ""file_path"": ""libavcodec/hevcdec.c"", ""func_code"": ""static int hls_slice_header(HEVCContext *s)\n{\n    GetBitContext *gb = &s->HEVClc->gb;\n    SliceHeader *sh   = &s->sh;\n    int i, ret;\n\n    // Coded parameters\n    sh->first_slice_in_pic_flag = get_bits1(gb);\n    if (s->ref && sh->first_slice_in_pic_flag) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Two slices reporting being the first in the same frame.\\n\"");\n        return 1; // This slice will be skiped later, do not corrupt state\n    }\n\n    if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        if (IS_IDR(s))\n            ff_hevc_clear_refs(s);\n    }\n    sh->no_output_of_prior_pics_flag = 0;\n    if (IS_IRAP(s))\n        sh->no_output_of_prior_pics_flag = get_bits1(gb);\n\n    sh->pps_id = get_ue_golomb_long(gb);\n    if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS id out of range: %d\\n\"", sh->pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!sh->first_slice_in_pic_flag &&\n        s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS changed between slices.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n    s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;\n    if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)\n        sh->no_output_of_prior_pics_flag = 1;\n\n    if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {\n        const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;\n        const HEVCSPS *last_sps = s->ps.sps;\n        enum AVPixelFormat pix_fmt;\n\n        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {\n            if (sps->width != last_sps->width || sps->height != last_sps->height ||\n                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=\n                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)\n                sh->no_output_of_prior_pics_flag = 0;\n        }\n        ff_hevc_clear_refs(s);\n\n        pix_fmt = get_format(s, sps);\n        if (pix_fmt < 0)\n            return pix_fmt;\n\n        ret = set_sps(s, sps, pix_fmt);\n        if (ret < 0)\n            return ret;\n\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n    }\n\n    sh->dependent_slice_segment_flag = 0;\n    if (!sh->first_slice_in_pic_flag) {\n        int slice_address_length;\n\n        if (s->ps.pps->dependent_slice_segments_enabled_flag)\n            sh->dependent_slice_segment_flag = get_bits1(gb);\n\n        slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *\n                                            s->ps.sps->ctb_height);\n        sh->slice_segment_addr = get_bitsz(gb, slice_address_length);\n        if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \""Invalid slice segment address: %u.\\n\"",\n                   sh->slice_segment_addr);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!sh->dependent_slice_segment_flag) {\n            sh->slice_addr = sh->slice_segment_addr;\n            s->slice_idx++;\n        }\n    } else {\n        sh->slice_segment_addr = sh->slice_addr = 0;\n        s->slice_idx           = 0;\n        s->slice_initialized   = 0;\n    }\n\n    if (!sh->dependent_slice_segment_flag) {\n        s->slice_initialized = 0;\n\n        for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)\n            skip_bits(gb, 1);  // slice_reserved_undetermined_flag[]\n\n        sh->slice_type = get_ue_golomb_long(gb);\n        if (!(sh->slice_type == HEVC_SLICE_I ||\n              sh->slice_type == HEVC_SLICE_P ||\n              sh->slice_type == HEVC_SLICE_B)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Unknown slice type: %d.\\n\"",\n                   sh->slice_type);\n            return AVERROR_INVALIDDATA;\n        }\n        if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Inter slices in an IRAP frame.\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n\n        // when flag is not present, picture is inferred to be output\n        sh->pic_output_flag = 1;\n        if (s->ps.pps->output_flag_present_flag)\n            sh->pic_output_flag = get_bits1(gb);\n\n        if (s->ps.sps->separate_colour_plane_flag)\n            sh->colour_plane_id = get_bits(gb, 2);\n\n        if (!IS_IDR(s)) {\n            int poc, pos;\n\n            sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);\n            poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);\n            if (!sh->first_slice_in_pic_flag && poc != s->poc) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \""Ignoring POC change between slices: %d -> %d\\n\"", s->poc, poc);\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n                poc = s->poc;\n            }\n            s->poc = poc;\n\n            sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);\n            pos = get_bits_left(gb);\n            if (!sh->short_term_ref_pic_set_sps_flag) {\n                ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);\n                if (ret < 0)\n                    return ret;\n\n                sh->short_term_rps = &sh->slice_rps;\n            } else {\n                int numbits, rps_idx;\n\n                if (!s->ps.sps->nb_st_rps) {\n                    av_log(s->avctx, AV_LOG_ERROR, \""No ref lists in the SPS.\\n\"");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                numbits = av_ceil_log2(s->ps.sps->nb_st_rps);\n                rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;\n                sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];\n            }\n            sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            pos = get_bits_left(gb);\n            ret = decode_lt_rps(s, &sh->long_term_rps, gb);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING, \""Invalid long term RPS.\\n\"");\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n            }\n            sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            if (s->ps.sps->sps_temporal_mvp_enabled_flag)\n                sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);\n            else\n                sh->slice_temporal_mvp_enabled_flag = 0;\n        } else {\n            s->sh.short_term_rps = NULL;\n            s->poc               = 0;\n        }\n\n        /* 8.3.1 */\n        if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&\n            s->nal_unit_type != HEVC_NAL_TRAIL_N &&\n            s->nal_unit_type != HEVC_NAL_TSA_N   &&\n            s->nal_unit_type != HEVC_NAL_STSA_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_R  &&\n            s->nal_unit_type != HEVC_NAL_RASL_N  &&\n            s->nal_unit_type != HEVC_NAL_RASL_R)\n            s->pocTid0 = s->poc;\n\n        if (s->ps.sps->sao_enabled) {\n            sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);\n            if (s->ps.sps->chroma_format_idc) {\n                sh->slice_sample_adaptive_offset_flag[1] =\n                sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);\n            }\n        } else {\n            sh->slice_sample_adaptive_offset_flag[0] = 0;\n            sh->slice_sample_adaptive_offset_flag[1] = 0;\n            sh->slice_sample_adaptive_offset_flag[2] = 0;\n        }\n\n        sh->nb_refs[L0] = sh->nb_refs[L1] = 0;\n        if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {\n            int nb_refs;\n\n            sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;\n\n            if (get_bits1(gb)) { // num_ref_idx_active_override_flag\n                sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;\n            }\n            if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Too many refs: %d/%d.\\n\"",\n                       sh->nb_refs[L0], sh->nb_refs[L1]);\n                return AVERROR_INVALIDDATA;\n            }\n\n            sh->rpl_modification_flag[0] = 0;\n            sh->rpl_modification_flag[1] = 0;\n            nb_refs = ff_hevc_frame_nb_refs(s);\n            if (!nb_refs) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Zero refs for a frame with P or B slices.\\n\"");\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {\n                sh->rpl_modification_flag[0] = get_bits1(gb);\n                if (sh->rpl_modification_flag[0]) {\n                    for (i = 0; i < sh->nb_refs[L0]; i++)\n                        sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n\n                if (sh->slice_type == HEVC_SLICE_B) {\n                    sh->rpl_modification_flag[1] = get_bits1(gb);\n                    if (sh->rpl_modification_flag[1] == 1)\n                        for (i = 0; i < sh->nb_refs[L1]; i++)\n                            sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n            }\n\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->mvd_l1_zero_flag = get_bits1(gb);\n\n            if (s->ps.pps->cabac_init_present_flag)\n                sh->cabac_init_flag = get_bits1(gb);\n            else\n                sh->cabac_init_flag = 0;\n\n            sh->collocated_ref_idx = 0;\n            if (sh->slice_temporal_mvp_enabled_flag) {\n                sh->collocated_list = L0;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->collocated_list = !get_bits1(gb);\n\n                if (sh->nb_refs[sh->collocated_list] > 1) {\n                    sh->collocated_ref_idx = get_ue_golomb_long(gb);\n                    if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \""Invalid collocated_ref_idx: %d.\\n\"",\n                               sh->collocated_ref_idx);\n                        return AVERROR_INVALIDDATA;\n                    }\n                }\n            }\n\n            if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||\n                (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {\n                int ret = pred_weight_table(s, gb);\n                if (ret < 0)\n                    return ret;\n            }\n\n            sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);\n            if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \""Invalid number of merging MVP candidates: %d.\\n\"",\n                       sh->max_num_merge_cand);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        sh->slice_qp_delta = get_se_golomb(gb);\n\n        if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {\n            sh->slice_cb_qp_offset = get_se_golomb(gb);\n            sh->slice_cr_qp_offset = get_se_golomb(gb);\n        } else {\n            sh->slice_cb_qp_offset = 0;\n            sh->slice_cr_qp_offset = 0;\n        }\n\n        if (s->ps.pps->chroma_qp_offset_list_enabled_flag)\n            sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);\n        else\n            sh->cu_chroma_qp_offset_enabled_flag = 0;\n\n        if (s->ps.pps->deblocking_filter_control_present_flag) {\n            int deblocking_filter_override_flag = 0;\n\n            if (s->ps.pps->deblocking_filter_override_enabled_flag)\n                deblocking_filter_override_flag = get_bits1(gb);\n\n            if (deblocking_filter_override_flag) {\n                sh->disable_deblocking_filter_flag = get_bits1(gb);\n                if (!sh->disable_deblocking_filter_flag) {\n                    int beta_offset_div2 = get_se_golomb(gb);\n                    int tc_offset_div2   = get_se_golomb(gb) ;\n                    if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||\n                        tc_offset_div2   < -6 || tc_offset_div2   > 6) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                            \""Invalid deblock filter offsets: %d, %d\\n\"",\n                            beta_offset_div2, tc_offset_div2);\n                        return AVERROR_INVALIDDATA;\n                    }\n                    sh->beta_offset = beta_offset_div2 * 2;\n                    sh->tc_offset   =   tc_offset_div2 * 2;\n                }\n            } else {\n                sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;\n                sh->beta_offset                    = s->ps.pps->beta_offset;\n                sh->tc_offset                      = s->ps.pps->tc_offset;\n            }\n        } else {\n            sh->disable_deblocking_filter_flag = 0;\n            sh->beta_offset                    = 0;\n            sh->tc_offset                      = 0;\n        }\n\n        if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&\n            (sh->slice_sample_adaptive_offset_flag[0] ||\n             sh->slice_sample_adaptive_offset_flag[1] ||\n             !sh->disable_deblocking_filter_flag)) {\n            sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);\n        } else {\n            sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;\n        }\n    } else if (!s->slice_initialized) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Independent slice segment missing.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->num_entry_point_offsets = 0;\n    if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {\n        unsigned num_entry_point_offsets = get_ue_golomb_long(gb);\n        // It would be possible to bound this tighter but this here is simpler\n        if (num_entry_point_offsets > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""num_entry_point_offsets %d is invalid\\n\"", num_entry_point_offsets);\n            return AVERROR_INVALIDDATA;\n        }\n\n        sh->num_entry_point_offsets = num_entry_point_offsets;\n        if (sh->num_entry_point_offsets > 0) {\n            int offset_len = get_ue_golomb_long(gb) + 1;\n\n            if (offset_len < 1 || offset_len > 32) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""offset_len %d is invalid\\n\"", offset_len);\n                return AVERROR_INVALIDDATA;\n            }\n\n            av_freep(&sh->entry_point_offset);\n            av_freep(&sh->offset);\n            av_freep(&sh->size);\n            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));\n            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            if (!sh->entry_point_offset || !sh->offset || !sh->size) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""Failed to allocate memory\\n\"");\n                return AVERROR(ENOMEM);\n            }\n            for (i = 0; i < sh->num_entry_point_offsets; i++) {\n                unsigned val = get_bits_long(gb, offset_len);\n                sh->entry_point_offset[i] = val + 1; // +1; // +1 to get the size\n            }\n            if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {\n                s->enable_parallel_tiles = 0; // TODO: you can enable tiles in parallel here\n                s->threads_number = 1;\n            } else\n                s->enable_parallel_tiles = 0;\n        } else\n            s->enable_parallel_tiles = 0;\n    }\n\n    if (s->ps.pps->slice_header_extension_present_flag) {\n        unsigned int length = get_ue_golomb_long(gb);\n        if (length*8LL > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""too many slice_header_extension_data_bytes\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < length; i++)\n            skip_bits(gb, 8);  // slice_header_extension_data_byte\n    }\n\n    // Inferred parameters\n    sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;\n    if (sh->slice_qp > 51 ||\n        sh->slice_qp < -s->ps.sps->qp_bd_offset) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""The slice_qp %d is outside the valid range \""\n               \""[%d, 51].\\n\"",\n               sh->slice_qp,\n               -s->ps.sps->qp_bd_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->slice_ctb_addr_rs = sh->slice_segment_addr;\n\n    if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Impossible slice segment.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (get_bits_left(gb) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""Overread slice header by %d bits\\n\"", -get_bits_left(gb));\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;\n\n    if (!s->ps.pps->cu_qp_delta_enabled_flag)\n        s->HEVClc->qp_y = s->sh.slice_qp;\n\n    s->slice_initialized = 1;\n    s->HEVClc->tu.cu_qp_offset_cb = 0;\n    s->HEVClc->tu.cu_qp_offset_cr = 0;\n\n    return 0;\n}""}]","{""value"": 4, ""code"": 4, ""function"": 5}","[{""source"": ""value_info(file:hevcdec.c, value:s->ref)"", ""result"": {""value_trace"": [{""full_code"": ""s->ref = NULL"", ""line"": 2809, ""func_name"": ""hevc_frame_start""}, {""full_code"": ""s->ref = NULL"", ""line"": 2964, ""func_name"": ""decode_nal_units<duplicate>0""}, {""full_code"": ""s->ref = NULL"", ""line"": 3128, ""func_name"": ""hevc_decode_frame""}], ""struct_var"": ""s"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:hevcdec.c, lines:2800-2820)"", ""result"": ""\n    if (!s->avctx->hwaccel)\n        ff_thread_finish_setup(s->avctx);\n\n    return 0;\n\nfail:\n    if (s->ref)\n        ff_hevc_unref_frame(s, s->ref, ~0);\n    s->ref = NULL;\n    return ret;\n}\n\nstatic int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n""}, {""source"": ""func_info(file:hevcdec.c, func:hevc_frame_start)"", ""result"": [{""code"": ""static int hevc_frame_start(HEVCContext *s)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    int pic_size_in_ctb  = ((s->ps.sps->width  >> s->ps.sps->log2_min_cb_size) + 1) *\n                           ((s->ps.sps->height >> s->ps.sps->log2_min_cb_size) + 1);\n    int ret;\n\n    memset(s->horizontal_bs, 0, s->bs_width * s->bs_height);\n    memset(s->vertical_bs,   0, s->bs_width * s->bs_height);\n    memset(s->cbf_luma,      0, s->ps.sps->min_tb_width * s->ps.sps->min_tb_height);\n    memset(s->is_pcm,        0, (s->ps.sps->min_pu_width + 1) * (s->ps.sps->min_pu_height + 1));\n    memset(s->tab_slice_address, -1, pic_size_in_ctb * sizeof(*s->tab_slice_address));\n\n    s->is_decoded        = 0;\n    s->first_nal_type    = s->nal_unit_type;\n\n    s->no_rasl_output_flag = IS_IDR(s) || IS_BLA(s) || (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos);\n\n    if (s->ps.pps->tiles_enabled_flag)\n        lc->end_of_tiles_x = s->ps.pps->column_width[0] << s->ps.sps->log2_ctb_size;\n\n    ret = ff_hevc_set_new_ref(s, &s->frame, s->poc);\n    if (ret < 0)\n        goto fail;\n\n    ret = ff_hevc_frame_rps(s);\n    if (ret < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Error constructing the frame RPS.\\n\"");\n        goto fail;\n    }\n\n    s->ref->frame->key_frame = IS_IRAP(s);\n\n    ret = set_side_data(s);\n    if (ret < 0)\n        goto fail;\n\n    s->frame->pict_type = 3 - s->sh.slice_type;\n\n    if (!IS_IRAP(s))\n        ff_hevc_bump_frame(s);\n\n    av_frame_unref(s->output_frame);\n    ret = ff_hevc_output_frame(s, s->output_frame, 0);\n    if (ret < 0)\n        goto fail;\n\n    if (!s->avctx->hwaccel)\n        ff_thread_finish_setup(s->avctx);\n\n    return 0;\n\nfail:\n    if (s->ref)\n        ff_hevc_unref_frame(s, s->ref, ~0);\n    s->ref = NULL;\n    return ret;\n}\n"", ""start_line"": 2754, ""end_line"": 2811, ""full_name"": ""hevc_frame_start"", ""file_path"": ""libavcodec/hevcdec.c""}]}, {""source"": ""func_info(file:hevcdec.c, func:hls_slice_header)"", ""result"": [{""code"": ""static int hls_slice_header(HEVCContext *s)\n{\n    GetBitContext *gb = &s->HEVClc->gb;\n    SliceHeader *sh   = &s->sh;\n    int i, ret;\n\n    // Coded parameters\n    sh->first_slice_in_pic_flag = get_bits1(gb);\n    if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        if (IS_IDR(s))\n            ff_hevc_clear_refs(s);\n    }\n    sh->no_output_of_prior_pics_flag = 0;\n    if (IS_IRAP(s))\n        sh->no_output_of_prior_pics_flag = get_bits1(gb);\n\n    sh->pps_id = get_ue_golomb_long(gb);\n    if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS id out of range: %d\\n\"", sh->pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!sh->first_slice_in_pic_flag &&\n        s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {\n        av_log(s->avctx, AV_LOG_ERROR, \""PPS changed between slices.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n    s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;\n    if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)\n        sh->no_output_of_prior_pics_flag = 1;\n\n    if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {\n        const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;\n        const HEVCSPS *last_sps = s->ps.sps;\n        enum AVPixelFormat pix_fmt;\n\n        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {\n            if (sps->width != last_sps->width || sps->height != last_sps->height ||\n                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=\n                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)\n                sh->no_output_of_prior_pics_flag = 0;\n        }\n        ff_hevc_clear_refs(s);\n\n        pix_fmt = get_format(s, sps);\n        if (pix_fmt < 0)\n            return pix_fmt;\n\n        ret = set_sps(s, sps, pix_fmt);\n        if (ret < 0)\n            return ret;\n\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n    }\n\n    sh->dependent_slice_segment_flag = 0;\n    if (!sh->first_slice_in_pic_flag) {\n        int slice_address_length;\n\n        if (s->ps.pps->dependent_slice_segments_enabled_flag)\n            sh->dependent_slice_segment_flag = get_bits1(gb);\n\n        slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *\n                                            s->ps.sps->ctb_height);\n        sh->slice_segment_addr = get_bitsz(gb, slice_address_length);\n        if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \""Invalid slice segment address: %u.\\n\"",\n                   sh->slice_segment_addr);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!sh->dependent_slice_segment_flag) {\n            sh->slice_addr = sh->slice_segment_addr;\n            s->slice_idx++;\n        }\n    } else {\n        sh->slice_segment_addr = sh->slice_addr = 0;\n        s->slice_idx           = 0;\n        s->slice_initialized   = 0;\n    }\n\n    if (!sh->dependent_slice_segment_flag) {\n        s->slice_initialized = 0;\n\n        for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)\n            skip_bits(gb, 1);  // slice_reserved_undetermined_flag[]\n\n        sh->slice_type = get_ue_golomb_long(gb);\n        if (!(sh->slice_type == HEVC_SLICE_I ||\n              sh->slice_type == HEVC_SLICE_P ||\n              sh->slice_type == HEVC_SLICE_B)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Unknown slice type: %d.\\n\"",\n                   sh->slice_type);\n            return AVERROR_INVALIDDATA;\n        }\n        if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Inter slices in an IRAP frame.\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n\n        // when flag is not present, picture is inferred to be output\n        sh->pic_output_flag = 1;\n        if (s->ps.pps->output_flag_present_flag)\n            sh->pic_output_flag = get_bits1(gb);\n\n        if (s->ps.sps->separate_colour_plane_flag)\n            sh->colour_plane_id = get_bits(gb, 2);\n\n        if (!IS_IDR(s)) {\n            int poc, pos;\n\n            sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);\n            poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);\n            if (!sh->first_slice_in_pic_flag && poc != s->poc) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \""Ignoring POC change between slices: %d -> %d\\n\"", s->poc, poc);\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n                poc = s->poc;\n            }\n            s->poc = poc;\n\n            sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);\n            pos = get_bits_left(gb);\n            if (!sh->short_term_ref_pic_set_sps_flag) {\n                ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);\n                if (ret < 0)\n                    return ret;\n\n                sh->short_term_rps = &sh->slice_rps;\n            } else {\n                int numbits, rps_idx;\n\n                if (!s->ps.sps->nb_st_rps) {\n                    av_log(s->avctx, AV_LOG_ERROR, \""No ref lists in the SPS.\\n\"");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                numbits = av_ceil_log2(s->ps.sps->nb_st_rps);\n                rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;\n                sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];\n            }\n            sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            pos = get_bits_left(gb);\n            ret = decode_lt_rps(s, &sh->long_term_rps, gb);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING, \""Invalid long term RPS.\\n\"");\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n            }\n            sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);\n\n            if (s->ps.sps->sps_temporal_mvp_enabled_flag)\n                sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);\n            else\n                sh->slice_temporal_mvp_enabled_flag = 0;\n        } else {\n            s->sh.short_term_rps = NULL;\n            s->poc               = 0;\n        }\n\n        /* 8.3.1 */\n        if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&\n            s->nal_unit_type != HEVC_NAL_TRAIL_N &&\n            s->nal_unit_type != HEVC_NAL_TSA_N   &&\n            s->nal_unit_type != HEVC_NAL_STSA_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_N  &&\n            s->nal_unit_type != HEVC_NAL_RADL_R  &&\n            s->nal_unit_type != HEVC_NAL_RASL_N  &&\n            s->nal_unit_type != HEVC_NAL_RASL_R)\n            s->pocTid0 = s->poc;\n\n        if (s->ps.sps->sao_enabled) {\n            sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);\n            if (s->ps.sps->chroma_format_idc) {\n                sh->slice_sample_adaptive_offset_flag[1] =\n                sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);\n            }\n        } else {\n            sh->slice_sample_adaptive_offset_flag[0] = 0;\n            sh->slice_sample_adaptive_offset_flag[1] = 0;\n            sh->slice_sample_adaptive_offset_flag[2] = 0;\n        }\n\n        sh->nb_refs[L0] = sh->nb_refs[L1] = 0;\n        if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {\n            int nb_refs;\n\n            sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;\n\n            if (get_bits1(gb)) { // num_ref_idx_active_override_flag\n                sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;\n            }\n            if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Too many refs: %d/%d.\\n\"",\n                       sh->nb_refs[L0], sh->nb_refs[L1]);\n                return AVERROR_INVALIDDATA;\n            }\n\n            sh->rpl_modification_flag[0] = 0;\n            sh->rpl_modification_flag[1] = 0;\n            nb_refs = ff_hevc_frame_nb_refs(s);\n            if (!nb_refs) {\n                av_log(s->avctx, AV_LOG_ERROR, \""Zero refs for a frame with P or B slices.\\n\"");\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {\n                sh->rpl_modification_flag[0] = get_bits1(gb);\n                if (sh->rpl_modification_flag[0]) {\n                    for (i = 0; i < sh->nb_refs[L0]; i++)\n                        sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n\n                if (sh->slice_type == HEVC_SLICE_B) {\n                    sh->rpl_modification_flag[1] = get_bits1(gb);\n                    if (sh->rpl_modification_flag[1] == 1)\n                        for (i = 0; i < sh->nb_refs[L1]; i++)\n                            sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));\n                }\n            }\n\n            if (sh->slice_type == HEVC_SLICE_B)\n                sh->mvd_l1_zero_flag = get_bits1(gb);\n\n            if (s->ps.pps->cabac_init_present_flag)\n                sh->cabac_init_flag = get_bits1(gb);\n            else\n                sh->cabac_init_flag = 0;\n\n            sh->collocated_ref_idx = 0;\n            if (sh->slice_temporal_mvp_enabled_flag) {\n                sh->collocated_list = L0;\n                if (sh->slice_type == HEVC_SLICE_B)\n                    sh->collocated_list = !get_bits1(gb);\n\n                if (sh->nb_refs[sh->collocated_list] > 1) {\n                    sh->collocated_ref_idx = get_ue_golomb_long(gb);\n                    if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                               \""Invalid collocated_ref_idx: %d.\\n\"",\n                               sh->collocated_ref_idx);\n                        return AVERROR_INVALIDDATA;\n                    }\n                }\n            }\n\n            if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||\n                (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {\n                int ret = pred_weight_table(s, gb);\n                if (ret < 0)\n                    return ret;\n            }\n\n            sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);\n            if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \""Invalid number of merging MVP candidates: %d.\\n\"",\n                       sh->max_num_merge_cand);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        sh->slice_qp_delta = get_se_golomb(gb);\n\n        if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {\n            sh->slice_cb_qp_offset = get_se_golomb(gb);\n            sh->slice_cr_qp_offset = get_se_golomb(gb);\n        } else {\n            sh->slice_cb_qp_offset = 0;\n            sh->slice_cr_qp_offset = 0;\n        }\n\n        if (s->ps.pps->chroma_qp_offset_list_enabled_flag)\n            sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);\n        else\n            sh->cu_chroma_qp_offset_enabled_flag = 0;\n\n        if (s->ps.pps->deblocking_filter_control_present_flag) {\n            int deblocking_filter_override_flag = 0;\n\n            if (s->ps.pps->deblocking_filter_override_enabled_flag)\n                deblocking_filter_override_flag = get_bits1(gb);\n\n            if (deblocking_filter_override_flag) {\n                sh->disable_deblocking_filter_flag = get_bits1(gb);\n                if (!sh->disable_deblocking_filter_flag) {\n                    int beta_offset_div2 = get_se_golomb(gb);\n                    int tc_offset_div2   = get_se_golomb(gb) ;\n                    if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||\n                        tc_offset_div2   < -6 || tc_offset_div2   > 6) {\n                        av_log(s->avctx, AV_LOG_ERROR,\n                            \""Invalid deblock filter offsets: %d, %d\\n\"",\n                            beta_offset_div2, tc_offset_div2);\n                        return AVERROR_INVALIDDATA;\n                    }\n                    sh->beta_offset = beta_offset_div2 * 2;\n                    sh->tc_offset   =   tc_offset_div2 * 2;\n                }\n            } else {\n                sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;\n                sh->beta_offset                    = s->ps.pps->beta_offset;\n                sh->tc_offset                      = s->ps.pps->tc_offset;\n            }\n        } else {\n            sh->disable_deblocking_filter_flag = 0;\n            sh->beta_offset                    = 0;\n            sh->tc_offset                      = 0;\n        }\n\n        if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&\n            (sh->slice_sample_adaptive_offset_flag[0] ||\n             sh->slice_sample_adaptive_offset_flag[1] ||\n             !sh->disable_deblocking_filter_flag)) {\n            sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);\n        } else {\n            sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;\n        }\n    } else if (!s->slice_initialized) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Independent slice segment missing.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->num_entry_point_offsets = 0;\n    if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {\n        unsigned num_entry_point_offsets = get_ue_golomb_long(gb);\n        // It would be possible to bound this tighter but this here is simpler\n        if (num_entry_point_offsets > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""num_entry_point_offsets %d is invalid\\n\"", num_entry_point_offsets);\n            return AVERROR_INVALIDDATA;\n        }\n\n        sh->num_entry_point_offsets = num_entry_point_offsets;\n        if (sh->num_entry_point_offsets > 0) {\n            int offset_len = get_ue_golomb_long(gb) + 1;\n\n            if (offset_len < 1 || offset_len > 32) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""offset_len %d is invalid\\n\"", offset_len);\n                return AVERROR_INVALIDDATA;\n            }\n\n            av_freep(&sh->entry_point_offset);\n            av_freep(&sh->offset);\n            av_freep(&sh->size);\n            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));\n            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));\n            if (!sh->entry_point_offset || !sh->offset || !sh->size) {\n                sh->num_entry_point_offsets = 0;\n                av_log(s->avctx, AV_LOG_ERROR, \""Failed to allocate memory\\n\"");\n                return AVERROR(ENOMEM);\n            }\n            for (i = 0; i < sh->num_entry_point_offsets; i++) {\n                unsigned val = get_bits_long(gb, offset_len);\n                sh->entry_point_offset[i] = val + 1; // +1; // +1 to get the size\n            }\n            if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {\n                s->enable_parallel_tiles = 0; // TODO: you can enable tiles in parallel here\n                s->threads_number = 1;\n            } else\n                s->enable_parallel_tiles = 0;\n        } else\n            s->enable_parallel_tiles = 0;\n    }\n\n    if (s->ps.pps->slice_header_extension_present_flag) {\n        unsigned int length = get_ue_golomb_long(gb);\n        if (length*8LL > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \""too many slice_header_extension_data_bytes\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < length; i++)\n            skip_bits(gb, 8);  // slice_header_extension_data_byte\n    }\n\n    // Inferred parameters\n    sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;\n    if (sh->slice_qp > 51 ||\n        sh->slice_qp < -s->ps.sps->qp_bd_offset) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""The slice_qp %d is outside the valid range \""\n               \""[%d, 51].\\n\"",\n               sh->slice_qp,\n               -s->ps.sps->qp_bd_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    sh->slice_ctb_addr_rs = sh->slice_segment_addr;\n\n    if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {\n        av_log(s->avctx, AV_LOG_ERROR, \""Impossible slice segment.\\n\"");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (get_bits_left(gb) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \""Overread slice header by %d bits\\n\"", -get_bits_left(gb));\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;\n\n    if (!s->ps.pps->cu_qp_delta_enabled_flag)\n        s->HEVClc->qp_y = s->sh.slice_qp;\n\n    s->slice_initialized = 1;\n    s->HEVClc->tu.cu_qp_offset_cb = 0;\n    s->HEVClc->tu.cu_qp_offset_cr = 0;\n\n    return 0;\n}\n"", ""start_line"": 467, ""end_line"": 886, ""full_name"": ""hls_slice_header"", ""file_path"": ""libavcodec/hevcdec.c""}]}, {""source"": ""func_info(func:ff_hevc_set_new_ref)"", ""result"": [{""code"": ""int ff_hevc_set_new_ref(HEVCContext *s, AVFrame **frame, int poc)\n{\n    HEVCFrame *ref;\n    int i;\n\n    /* check that this POC doesn't already exist */\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        HEVCFrame *frame = &s->DPB[i];\n\n        if (frame->frame->buf[0] && frame->sequence == s->seq_decode &&\n            frame->poc == poc) {\n            av_log(s->avctx, AV_LOG_ERROR, \""Duplicate POC in a sequence: %d.\\n\"",\n                   poc);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    ref = alloc_frame(s);\n    if (!ref)\n        return AVERROR(ENOMEM);\n\n    *frame = ref->frame;\n    s->ref = ref;\n\n    if (s->sh.pic_output_flag)\n        ref->flags = HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_SHORT_REF;\n    else\n        ref->flags = HEVC_FRAME_FLAG_SHORT_REF;\n\n    ref->poc      = poc;\n    ref->sequence = s->seq_decode;\n    ref->frame->crop_left   = s->ps.sps->output_window.left_offset;\n    ref->frame->crop_right  = s->ps.sps->output_window.right_offset;\n    ref->frame->crop_top    = s->ps.sps->output_window.top_offset;\n    ref->frame->crop_bottom = s->ps.sps->output_window.bottom_offset;\n\n    return 0;\n}\n"", ""start_line"": 135, ""end_line"": 172, ""full_name"": ""ff_hevc_set_new_ref"", ""file_path"": ""libavcodec/hevc_refs.c""}]}, {""source"": ""code_info(file:hevcdec.c, lines:2700-2750)"", ""result"": ""\n        av_log(s->avctx, AV_LOG_DEBUG, \""Mastering Display Metadata:\\n\"");\n        av_log(s->avctx, AV_LOG_DEBUG,\n               \""r(%5.4f,%5.4f) g(%5.4f,%5.4f) b(%5.4f %5.4f) wp(%5.4f, %5.4f)\\n\"",\n               av_q2d(metadata->display_primaries[0][0]),\n               av_q2d(metadata->display_primaries[0][1]),\n               av_q2d(metadata->display_primaries[1][0]),\n               av_q2d(metadata->display_primaries[1][1]),\n               av_q2d(metadata->display_primaries[2][0]),\n               av_q2d(metadata->display_primaries[2][1]),\n               av_q2d(metadata->white_point[0]), av_q2d(metadata->white_point[1]));\n        av_log(s->avctx, AV_LOG_DEBUG,\n               \""min_luminance=%f, max_luminance=%f\\n\"",\n               av_q2d(metadata->min_luminance), av_q2d(metadata->max_luminance));\n    }\n    // Decrement the mastering display flag when IRAP frame has no_rasl_output_flag=1\n    // so the side data persists for the entire coded video sequence.\n    if (s->sei.content_light.present > 0 &&\n        IS_IRAP(s) && s->no_rasl_output_flag) {\n        s->sei.content_light.present--;\n    }\n    if (s->sei.content_light.present) {\n        AVContentLightMetadata *metadata =\n            av_content_light_metadata_create_side_data(out);\n        if (!metadata)\n            return AVERROR(ENOMEM);\n        metadata->MaxCLL  = s->sei.content_light.max_content_light_level;\n        metadata->MaxFALL = s->sei.content_light.max_pic_average_light_level;\n\n        av_log(s->avctx, AV_LOG_DEBUG, \""Content Light Level Metadata:\\n\"");\n        av_log(s->avctx, AV_LOG_DEBUG, \""MaxCLL=%d, MaxFALL=%d\\n\"",\n               metadata->MaxCLL, metadata->MaxFALL);\n    }\n\n    if (s->sei.a53_caption.a53_caption) {\n        AVFrameSideData* sd = av_frame_new_side_data(out,\n                                                     AV_FRAME_DATA_A53_CC,\n                                                     s->sei.a53_caption.a53_caption_size);\n        if (sd)\n            memcpy(sd->data, s->sei.a53_caption.a53_caption, s->sei.a53_caption.a53_caption_size);\n        av_freep(&s->sei.a53_caption.a53_caption);\n        s->sei.a53_caption.a53_caption_size = 0;\n        s->avctx->properties |= FF_CODEC_PROPERTY_CLOSED_CAPTIONS;\n    }\n\n    if (s->sei.alternative_transfer.present &&\n        av_color_transfer_name(s->sei.alternative_transfer.preferred_transfer_characteristics) &&\n        s->sei.alternative_transfer.preferred_transfer_characteristics != AVCOL_TRC_UNSPECIFIED) {\n        s->avctx->color_trc = out->color_trc = s->sei.alternative_transfer.preferred_transfer_characteristics;\n    }\n\n""}, {""source"": ""value_info(file:hevcdec.c, value:s->ref)"", ""result"": {""value_trace"": [{""full_code"": ""s->ref = NULL"", ""line"": 2809, ""func_name"": ""hevc_frame_start""}, {""full_code"": ""s->ref = NULL"", ""line"": 2964, ""func_name"": ""decode_nal_units<duplicate>0""}, {""full_code"": ""s->ref = NULL"", ""line"": 3128, ""func_name"": ""hevc_decode_frame""}], ""struct_var"": ""s"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:ff_hevc_unref_frame)"", ""result"": [{""code"": ""void ff_hevc_unref_frame(HEVCContext *s, HEVCFrame *frame, int flags)\n{\n    /* frame->frame can be NULL if context init failed */\n    if (!frame->frame || !frame->frame->buf[0])\n        return;\n\n    frame->flags &= ~flags;\n    if (!frame->flags) {\n        ff_thread_release_buffer(s->avctx, &frame->tf);\n\n        av_buffer_unref(&frame->tab_mvf_buf);\n        frame->tab_mvf = NULL;\n\n        av_buffer_unref(&frame->rpl_buf);\n        av_buffer_unref(&frame->rpl_tab_buf);\n        frame->rpl_tab    = NULL;\n        frame->refPicList = NULL;\n\n        frame->collocated_ref = NULL;\n\n        av_buffer_unref(&frame->hwaccel_priv_buf);\n        frame->hwaccel_picture_private = NULL;\n    }\n}"", ""start_line"": 32, ""end_line"": 55, ""full_name"": ""ff_hevc_unref_frame"", ""file_path"": ""libavcodec/hevc_refs.c""}]}, {""source"": ""code_info(file:hevcdec.c, lines:3000-3100)"", ""result"": ""\nfail:\n    if (s->ref && s->threads_type == FF_THREAD_FRAME)\n        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);\n\n    return ret;\n}\n\nstatic void print_md5(void *log_ctx, int level, uint8_t md5[16])\n{\n    int i;\n    for (i = 0; i < 16; i++)\n        av_log(log_ctx, level, \""%02\""PRIx8, md5[i]);\n}\n\nstatic int verify_md5(HEVCContext *s, AVFrame *frame)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n    int pixel_shift;\n    int i, j;\n\n    if (!desc)\n        return AVERROR(EINVAL);\n\n    pixel_shift = desc->comp[0].depth > 8;\n\n    av_log(s->avctx, AV_LOG_DEBUG, \""Verifying checksum for frame with POC %d: \"",\n           s->poc);\n\n    /* the checksums are LE, so we have to byteswap for >8bpp formats\n     * on BE arches */\n#if HAVE_BIGENDIAN\n    if (pixel_shift && !s->checksum_buf) {\n        av_fast_malloc(&s->checksum_buf, &s->checksum_buf_size,\n                       FFMAX3(frame->linesize[0], frame->linesize[1],\n                              frame->linesize[2]));\n        if (!s->checksum_buf)\n            return AVERROR(ENOMEM);\n    }\n#endif\n\n    for (i = 0; frame->data[i]; i++) {\n        int width  = s->avctx->coded_width;\n        int height = s->avctx->coded_height;\n        int w = (i == 1 || i == 2) ? (width  >> desc->log2_chroma_w) : width;\n        int h = (i == 1 || i == 2) ? (height >> desc->log2_chroma_h) : height;\n        uint8_t md5[16];\n\n        av_md5_init(s->sei.picture_hash.md5_ctx);\n        for (j = 0; j < h; j++) {\n            const uint8_t *src = frame->data[i] + j * frame->linesize[i];\n#if HAVE_BIGENDIAN\n            if (pixel_shift) {\n                s->bdsp.bswap16_buf((uint16_t *) s->checksum_buf,\n                                    (const uint16_t *) src, w);\n                src = s->checksum_buf;\n            }\n#endif\n            av_md5_update(s->sei.picture_hash.md5_ctx, src, w << pixel_shift);\n        }\n        av_md5_final(s->sei.picture_hash.md5_ctx, md5);\n\n        if (!memcmp(md5, s->sei.picture_hash.md5[i], 16)) {\n            av_log   (s->avctx, AV_LOG_DEBUG, \""plane %d - correct \"", i);\n            print_md5(s->avctx, AV_LOG_DEBUG, md5);\n            av_log   (s->avctx, AV_LOG_DEBUG, \""; \"");\n        } else {\n            av_log   (s->avctx, AV_LOG_ERROR, \""mismatching checksum of plane %d - \"", i);\n            print_md5(s->avctx, AV_LOG_ERROR, md5);\n            av_log   (s->avctx, AV_LOG_ERROR, \"" != \"");\n            print_md5(s->avctx, AV_LOG_ERROR, s->sei.picture_hash.md5[i]);\n            av_log   (s->avctx, AV_LOG_ERROR, \""\\n\"");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    av_log(s->avctx, AV_LOG_DEBUG, \""\\n\"");\n\n    return 0;\n}\n\nstatic int hevc_decode_extradata(HEVCContext *s, uint8_t *buf, int length, int first)\n{\n    int ret, i;\n\n    ret = ff_hevc_decode_extradata(buf, length, &s->ps, &s->sei, &s->is_nalff,\n                                   &s->nal_length_size, s->avctx->err_recognition,\n                                   s->apply_defdispwin, s->avctx);\n    if (ret < 0)\n        return ret;\n\n    /* export stream parameters from the first SPS */\n    for (i = 0; i < FF_ARRAY_ELEMS(s->ps.sps_list); i++) {\n        if (first && s->ps.sps_list[i]) {\n            const HEVCSPS *sps = (const HEVCSPS*)s->ps.sps_list[i]->data;\n            export_stream_params(s->avctx, &s->ps, sps);\n            break;\n        }\n    }\n\n    return 0;\n""}, {""source"": ""value_info(file:hevcdec.c, value:s->ref)"", ""result"": {""value_trace"": [{""full_code"": ""s->ref = NULL"", ""line"": 2809, ""func_name"": ""hevc_frame_start""}, {""full_code"": ""s->ref = NULL"", ""line"": 2964, ""func_name"": ""decode_nal_units<duplicate>0""}, {""full_code"": ""s->ref = NULL"", ""line"": 3128, ""func_name"": ""hevc_decode_frame""}], ""struct_var"": ""s"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:hevcdec.c, value:s->ref)"", ""result"": {""value_trace"": [{""full_code"": ""s->ref = NULL"", ""line"": 2809, ""func_name"": ""hevc_frame_start""}, {""full_code"": ""s->ref = NULL"", ""line"": 2964, ""func_name"": ""decode_nal_units<duplicate>0""}, {""full_code"": ""s->ref = NULL"", ""line"": 3128, ""func_name"": ""hevc_decode_frame""}], ""struct_var"": ""s"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:hevc_refs.c, lines:10-30)"", ""result"": "" * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \""libavutil/avassert.h\""\n#include \""libavutil/pixdesc.h\""\n\n#include \""internal.h\""\n#include \""thread.h\""\n#include \""hevc.h\""\n#include \""hevcdec.h\""\n""}, {""source"": ""func_info(file:hevcdec.c, func:hevc_decode_frame)"", ""result"": [{""code"": ""static int hevc_decode_frame(AVCodecContext *avctx, void *data, int *got_output,\n                             AVPacket *avpkt)\n{\n    int ret;\n    int new_extradata_size;\n    uint8_t *new_extradata;\n    HEVCContext *s = avctx->priv_data;\n\n    if (!avpkt->size) {\n        ret = ff_hevc_output_frame(s, data, 1);\n        if (ret < 0)\n            return ret;\n\n        *got_output = ret;\n        return 0;\n    }\n\n    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,\n                                            &new_extradata_size);\n    if (new_extradata && new_extradata_size > 0) {\n        ret = hevc_decode_extradata(s, new_extradata, new_extradata_size, 0);\n        if (ret < 0)\n            return ret;\n    }\n\n    s->ref = NULL;\n    ret    = decode_nal_units(s, avpkt->data, avpkt->size);\n    if (ret < 0)\n        return ret;\n\n    if (avctx->hwaccel) {\n        if (s->ref && (ret = avctx->hwaccel->end_frame(avctx)) < 0) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \""hardware accelerator failed to decode picture\\n\"");\n            ff_hevc_unref_frame(s, s->ref, ~0);\n            return ret;\n        }\n    } else {\n        /* verify the SEI checksum */\n        if (avctx->err_recognition & AV_EF_CRCCHECK && s->is_decoded &&\n            s->sei.picture_hash.is_md5) {\n            ret = verify_md5(s, s->ref->frame);\n            if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE) {\n                ff_hevc_unref_frame(s, s->ref, ~0);\n                return ret;\n            }\n        }\n    }\n    s->sei.picture_hash.is_md5 = 0;\n\n    if (s->is_decoded) {\n        av_log(avctx, AV_LOG_DEBUG, \""Decoded frame with POC %d.\\n\"", s->poc);\n        s->is_decoded = 0;\n    }\n\n    if (s->output_frame->buf[0]) {\n        av_frame_move_ref(data, s->output_frame);\n        *got_output = 1;\n    }\n\n    return avpkt->size;\n}\n"", ""start_line"": 3103, ""end_line"": 3164, ""full_name"": ""hevc_decode_frame"", ""file_path"": ""libavcodec/hevcdec.c""}]}]","When processing a HEVC slice, `hls_slice_header` (libavcodec/hevcdec.c:473-477) checks if `s->ref` is already set to detect duplicate `first_slice_in_pic_flag`. If so, it returns 1, which `decode_nal_unit` (libavcodec/hevcdec.c:2863-2867) converts to an error. Before the patch, if `s->ref` was not reset (e.g., due to error paths or invalid state), subsequent code could dereference NULL or access invalid memory. `s->ref` is initialized to NULL in `hevc_frame_start` (libavcodec/hevcdec.c:2809) and assigned via `ff_hevc_set_new_ref` (libavcodec/hevc_refs.c:135-172).",0.95,./github/other_context/CVE-2019-11338
70,CVE-2019-12481,"CWE-787, CWE-476",c_cpp,"An issue was discovered in GPAC 0.7.1. There is a NULL pointer dereference in the function GetESD at isomedia/track.c in libgpac.a, as demonstrated by MP4Box.",https://github.com/gpac/gpac/commit/f40aaaf959d4d1f7fa0dcd04c0666592e615c8f1,fixed a few memory issues (#1249),6,"[{""func_name"": ""gf_isom_get_original_format_type"", ""file_path"": ""src/isomedia/drm_sample.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_isom_get_original_format_type(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tMedia_GetSampleDesc(trak->Media, sampleDescriptionIndex, &sea, NULL);\n\tif (!sea) return GF_BAD_PARAM;\n\n\tsinf = (GF_ProtectionSchemeInfoBox*)gf_list_get(sea->protections, 0);\n\tif (outOriginalFormat && sinf->original_format) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t}\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""gf_media_get_rfc_6381_codec_name"", ""file_path"": ""src/media_tools/dash_segmenter.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_media_get_rfc_6381_codec_name(GF_ISOFile *movie, u32 track, char *szCodec, Bool force_inband, Bool force_sbr)\n{\n\tGF_ESD *esd;\n\tGF_AVCConfig *avcc;\n#ifndef GPAC_DISABLE_HEVC\n\tGF_HEVCConfig *hvcc;\n#endif\n\n\tu32 subtype = gf_isom_get_media_subtype(movie, track, 1);\n\n\tif (subtype == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\tGF_Err e;\n\t\tu32 originalFormat=0;\n\t\tif (gf_isom_is_ismacryp_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_ismacryp_info(movie, track, 1, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if (gf_isom_is_omadrm_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_omadrm_info(movie, track, 1, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if(gf_isom_is_cenc_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_cenc_info(movie, track, 1, &originalFormat, NULL, NULL, NULL);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_AUTHOR, (\""[ISOM Tools] Unknown protection scheme type %s\\n\"", gf_4cc_to_str( gf_isom_is_media_encrypted(movie, track, 1)) ));\n\t\t\te = gf_isom_get_original_format_type(movie, track, 1, &originalFormat);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\""[ISOM Tools] Error fetching protection information\\n\""));\n\t\t\treturn e;\n\t\t}\n\n\t\tif (originalFormat) subtype = originalFormat;\n\t}\n\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\tesd = gf_isom_get_esd(movie, track, 1);\n\t\tif (esd) {\n\t\t\tswitch (esd->decoderConfig->streamType) {\n\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\t\t\tu8 audio_object_type;\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo->dataLength < 2) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[RFC6381-AAC] invalid DSI size %u < 2\\n\"", esd->decoderConfig->decoderSpecificInfo->dataLength));\n\t\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t}\n\t\t\t\t\t/*5 first bits of AAC config*/\n\t\t\t\t\taudio_object_type = (esd->decoderConfig->decoderSpecificInfo->data[0] & 0xF8) >> 3;\n\t\t\t\t\tif (audio_object_type == 31) { /*escape code*/\n\t\t\t\t\t\tconst u8 audio_object_type_ext = ((esd->decoderConfig->decoderSpecificInfo->data[0] & 0x07) << 3) + ((esd->decoderConfig->decoderSpecificInfo->data[1] & 0xE0) >> 5);\n\t\t\t\t\t\taudio_object_type = 32 + audio_object_type_ext;\n\t\t\t\t\t}\n\t#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (force_sbr && (audio_object_type==2) ) {\n\t\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\t\tGF_Err e = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\tif (a_cfg.sbr_sr)\n\t\t\t\t\t\t\t\taudio_object_type = a_cfg.sbr_object_type;\n\t\t\t\t\t\t\tif (a_cfg.has_ps)\n\t\t\t\t\t\t\t\taudio_object_type = 29;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t#endif\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4a.%02X.%01d\"", esd->decoderConfig->objectTypeIndication, audio_object_type);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4a.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_VISUAL:\n\t#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4v.%02X.%01x\"", esd->decoderConfig->objectTypeIndication, dsi.VideoPL);\n\t\t\t\t} else\n\t#endif\n\t\t\t\t{\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4v.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4s.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[RFC6381] Cannot find ESD. Aborting.\\n\""));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t//FIXME: in avc1 with multiple descriptor, we should take the right description index\n\t\tavcc = gf_isom_avc_config_get(movie, track, 1);\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC3_H264;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC4_H264;\n\t\t}\n\t\tif (avcc) {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02X%02X%02X\"", gf_4cc_to_str(subtype), avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Cannot find AVC configuration box\""));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tavcc = gf_isom_mvc_config_get(movie, track, 1);\n\t\tif (!avcc) avcc = gf_isom_svc_config_get(movie, track, 1);\n\t\tif (avcc) {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02X%02X%02X\"", gf_4cc_to_str(subtype), avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Cannot find AVC configuration box\""));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n#ifndef GPAC_DISABLE_HEVC\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_HVT1:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_HVC1) subtype = GF_ISOM_SUBTYPE_HEV1;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_HVC2) subtype = GF_ISOM_SUBTYPE_HEV2;\n\t\t}\n\t\thvcc = gf_isom_hevc_config_get(movie, track, 1);\n\t\tif (!hvcc) {\n\t\t\thvcc = gf_isom_lhvc_config_get(movie, track, 1);\n\t\t}\n\t\tif (subtype==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\tu32 refTrack;\n\t\t\tgf_isom_get_reference(movie, track, GF_ISOM_REF_TBAS, 1, &refTrack);\n\t\t\tif (hvcc) gf_odf_hevc_cfg_del(hvcc);\n\t\t\thvcc = gf_isom_hevc_config_get(movie, refTrack, 1);\n\t\t}\n\t\tif (hvcc) {\n\t\t\tu8 c;\n\t\t\tchar szTemp[RFC6381_CODEC_NAME_SIZE_MAX];\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.\"", gf_4cc_to_str(subtype));\n\t\t\tif (hvcc->profile_space==1) strcat(szCodec, \""A\"");\n\t\t\telse if (hvcc->profile_space==2) strcat(szCodec, \""B\"");\n\t\t\telse if (hvcc->profile_space==3) strcat(szCodec, \""C\"");\n\t\t\t//profile idc encoded as a decimal number\n\t\t\tsprintf(szTemp, \""%d\"", hvcc->profile_idc);\n\t\t\tstrcat(szCodec, szTemp);\n\t\t\t//general profile compatibility flags: hexa, bit-reversed\n\t\t\t{\n\t\t\t\tu32 val = hvcc->general_profile_compatibility_flags;\n\t\t\t\tu32 i, res = 0;\n\t\t\t\tfor (i=0; i<32; i++) {\n\t\t\t\t\tres |= val & 1;\n\t\t\t\t\tif (i==31) break;\n\t\t\t\t\tres <<= 1;\n\t\t\t\t\tval >>=1;\n\t\t\t\t}\n\t\t\t\tsprintf(szTemp, \"".%X\"", res);\n\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t}\n\n\t\t\tif (hvcc->tier_flag) strcat(szCodec, \"".H\"");\n\t\t\telse strcat(szCodec, \"".L\"");\n\t\t\tsprintf(szTemp, \""%d\"", hvcc->level_idc);\n\t\t\tstrcat(szCodec, szTemp);\n\n\t\t\tc = hvcc->progressive_source_flag << 7;\n\t\t\tc |= hvcc->interlaced_source_flag << 6;\n\t\t\tc |= hvcc->non_packed_constraint_flag << 5;\n\t\t\tc |= hvcc->frame_only_constraint_flag << 4;\n\t\t\tc |= (hvcc->constraint_indicator_flags >> 40);\n\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\tstrcat(szCodec, szTemp);\n\t\t\tif (hvcc->constraint_indicator_flags & 0xFFFFFFFF) {\n\t\t\t\tc = (hvcc->constraint_indicator_flags >> 32) & 0xFF;\n\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\tif (hvcc->constraint_indicator_flags & 0x00FFFFFF) {\n\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 24) & 0xFF;\n\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\tif (hvcc->constraint_indicator_flags & 0x0000FFFF) {\n\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 16) & 0xFF;\n\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\tif (hvcc->constraint_indicator_flags & 0x000000FF) {\n\t\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 8) & 0xFF;\n\t\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags ) & 0xFF;\n\t\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t} else {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s\"", gf_4cc_to_str(subtype));\n\t\t}\n\t\treturn GF_OK;\n#endif /*GPAC_DISABLE_HEVC*/\n\n#ifndef GPAC_DISABLE_AV1\n\tcase GF_ISOM_SUBTYPE_AV01: {\n\t\tGF_AV1Config *av1c = NULL;\n\t\tAV1State av1_state;\n\t\tGF_BitStream *bs = NULL;\n\t\tGF_Err e = GF_OK;\n\t\tu32 i = 0;\n\n\t\tmemset(&av1_state, 0, sizeof(AV1State));\n\t\tav1c = gf_isom_av1_config_get(movie, track, 1);\n\t\tif (!av1c) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] No config found for AV1 file (\\\""%s\\\"") when computing RFC6381.\\n\"", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tav1_state.config = av1c;\n\n\t\tfor (i = 0; i < gf_list_count(av1c->obu_array); ++i) {\n\t\t\tGF_AV1_OBUArrayEntry *a = gf_list_get(av1c->obu_array, i);\n\t\t\tbs = gf_bs_new(a->obu, a->obu_length, GF_BITSTREAM_READ);\n\t\t\tif (!av1_is_obu_header(a->obu_type))\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_AUTHOR, (\""[ISOM Tools] AV1: unexpected obu_type %d when computing RFC6381. PArsing anyway.\\n\"", a->obu_type, gf_4cc_to_str(subtype)));\n\n\t\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &av1_state);\n\t\t\tgf_bs_del(bs); bs = NULL;\n\t\t\tif (e) {\n\t\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%01u.%02u%c.%02u\"", gf_4cc_to_str(subtype),\n\t\t\tav1_state.config->seq_profile, av1_state.config->seq_level_idx_0, av1_state.config->seq_tier_0 ? 'H' : 'M',\n\t\t\tav1_state.bit_depth);\n\t\t\n\t\t/* \""All the other fields [...] are optional, mutually inclusive (all or none) fields.\"" https://aomediacodec.github.io/av1-isobmff/ */\n\t\tif (av1_state.color_description_present_flag) {\n\t\t\tchar tmp[RFC6381_CODEC_NAME_SIZE_MAX];\n\t\t\tsnprintf(tmp, RFC6381_CODEC_NAME_SIZE_MAX, \""%01u.%01u.%01u.%01u.%01u.%01u%01u%01u\"",\n\t\t\t\tav1_state.config->monochrome,\n\t\t\t\tav1_state.config->chroma_subsampling_x, av1_state.config->chroma_subsampling_y,\n\t\t\t\tav1_state.config->chroma_subsampling_x && av1_state.config->chroma_subsampling_y ? av1_state.config->chroma_sample_position : 0,\n\t\t\t\tav1_state.color_primaries, av1_state.transfer_characteristics, av1_state.matrix_coefficients, av1_state.color_range);\n\t\t\tstrcat(szCodec, tmp);\n\t\t}\n\n\t\tgf_odf_av1_cfg_del(av1c);\n\t\tav1_reset_frame_state(&av1_state.frame_state);\n\t\treturn GF_OK;\n\t}\n#endif /*GPAC_DISABLE_AV1*/\n\n\n\tcase GF_ISOM_SUBTYPE_VP08:\n\tcase GF_ISOM_SUBTYPE_VP09:\n\t{\n\t\tGF_VPConfig *vpcc = NULL;\n\n\t\tvpcc = gf_isom_vp_config_get(movie, track, 1);\n\t\tif (!vpcc) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] No config found for VP file (\\\""%s\\\"") when computing RFC6381.\\n\"", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02u.%02u.%02u.%02u.%02u.%02u.%02u.%02u\"", gf_4cc_to_str(subtype),\n\t\t\tvpcc->profile,\n\t\t\tvpcc->level,\n\t\t\tvpcc->bit_depth,\n\t\t\tvpcc->chroma_subsampling,\n\t\t\tvpcc->colour_primaries,\n\t\t\tvpcc->transfer_characteristics,\n\t\t\tvpcc->matrix_coefficients,\n\t\t\tvpcc->video_fullRange_flag);\n\n\n\t\tgf_odf_vp_cfg_del(vpcc);\n\n\t\treturn GF_OK;\n\t}\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] codec parameters not known - setting codecs string to default value \\\""%s\\\""\\n\"", gf_4cc_to_str(subtype) ));\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s\"", gf_4cc_to_str(subtype));\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""iSLT_Write"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err iSLT_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMACrypSaltBox *ptr = (GF_ISMACrypSaltBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\t\n\tgf_bs_write_u64(bs, ptr->salt);\n\treturn GF_OK;\n}"", ""target"": 1}, {""func_name"": ""senc_Parse"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tu32 i, j, count;\n\tu64 pos = gf_bs_get_position(bs);\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tcount = gf_bs_read_u32(bs);\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tu32 is_encrypted;\n\t\tu32 samp_count;\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));\n\t\tmemset(sai, 0, sizeof(GF_CENCSampleAuxInfo));\n\n\t\tsamp_count = i+1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (trak) samp_count += trak->sample_count_at_seg_start;\n#endif\n\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_ex(trak, traf, senc, samp_count, &is_encrypted, &sai->IV_size, NULL, NULL, NULL, NULL, NULL);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isobmf] could not get cenc info for sample %d: %s\\n\"", samp_count, gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size 16\\n\"" ));\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tsai->IV_size = 16;\n\t\t}\n\t\t//while this would technically be correct, senc mandates that sample_count = all samples in traf/track\n\t\t//regardless of their encryption state\n\t\t//if (is_encrypted)\n\t\t{\n\t\t\tif (sai->IV_size)\n\t\t\t\tgf_bs_read_data(bs, (char *)sai->IV, sai->IV_size);\n\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tsai->subsample_count = gf_bs_read_u16(bs);\n\t\t\t\tsai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));\n\t\t\t\tfor (j = 0; j < sai->subsample_count; j++) {\n\t\t\t\t\tsai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);\n\t\t\t\t\tsai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n}"", ""target"": 0}, {""func_name"": ""audio_sample_entry_Read"", ""file_path"": ""src/isomedia/box_code_base.c"", ""func_code"": ""GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC(data[i+4], data[i+5], data[i+6], data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}"", ""target"": 0}, {""func_name"": ""ReadGF_IPMPX_RemoveToolNotificationListener"", ""file_path"": ""src/odf/ipmpx_code.c"", ""func_code"": ""static GF_Err ReadGF_IPMPX_RemoveToolNotificationListener(GF_BitStream *bs, GF_IPMPX_Data *_p, u32 size)\n{\n\tu32 i;\n\tGF_IPMPX_RemoveToolNotificationListener*p = (GF_IPMPX_RemoveToolNotificationListener*)_p;\n\tp->eventTypeCount = gf_bs_read_int(bs, 8);\n\tfor (i=0; i<p->eventTypeCount; i++) p->eventType[i] = gf_bs_read_int(bs, 8);\n\treturn GF_OK;\n}"", ""target"": 0}]","[{""func_name"": ""gf_isom_get_original_format_type"", ""file_path"": ""src/isomedia/drm_sample.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_isom_get_original_format_type(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex, u32 *outOriginalFormat)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *sea;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tMedia_GetSampleDesc(trak->Media, sampleDescriptionIndex, &sea, NULL);\n\tif (!sea) return GF_BAD_PARAM;\n\n\tsinf = (GF_ProtectionSchemeInfoBox*)gf_list_get(sea->protections, 0);\n\tif (outOriginalFormat && sinf && sinf->original_format) {\n\t\t*outOriginalFormat = sinf->original_format->data_format;\n\t}\n\treturn GF_OK;\n}""}, {""func_name"": ""gf_media_get_rfc_6381_codec_name"", ""file_path"": ""src/media_tools/dash_segmenter.c"", ""func_code"": ""GF_EXPORT\nGF_Err gf_media_get_rfc_6381_codec_name(GF_ISOFile *movie, u32 track, char *szCodec, Bool force_inband, Bool force_sbr)\n{\n\tGF_ESD *esd;\n\tGF_AVCConfig *avcc;\n#ifndef GPAC_DISABLE_HEVC\n\tGF_HEVCConfig *hvcc;\n#endif\n\n\tu32 subtype = gf_isom_get_media_subtype(movie, track, 1);\n\n\tif (subtype == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\tGF_Err e;\n\t\tu32 originalFormat=0;\n\t\tif (gf_isom_is_ismacryp_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_ismacryp_info(movie, track, 1, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if (gf_isom_is_omadrm_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_omadrm_info(movie, track, 1, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\t\t} else if(gf_isom_is_cenc_media(movie, track, 1)) {\n\t\t\te = gf_isom_get_cenc_info(movie, track, 1, &originalFormat, NULL, NULL, NULL);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_AUTHOR, (\""[ISOM Tools] Unknown protection scheme type %s\\n\"", gf_4cc_to_str( gf_isom_is_media_encrypted(movie, track, 1)) ));\n\t\t\te = gf_isom_get_original_format_type(movie, track, 1, &originalFormat);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\""[ISOM Tools] Error fetching protection information\\n\""));\n\t\t\treturn e;\n\t\t}\n\n\t\tif (originalFormat) subtype = originalFormat;\n\t}\n\n\tswitch (subtype) {\n\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\tesd = gf_isom_get_esd(movie, track, 1);\n\t\tif (esd && esd->decoderConfig) {\n\t\t\tswitch (esd->decoderConfig->streamType) {\n\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\t\t\tu8 audio_object_type;\n\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo->dataLength < 2) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[RFC6381-AAC] invalid DSI size %u < 2\\n\"", esd->decoderConfig->decoderSpecificInfo->dataLength));\n\t\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t}\n\t\t\t\t\t/*5 first bits of AAC config*/\n\t\t\t\t\taudio_object_type = (esd->decoderConfig->decoderSpecificInfo->data[0] & 0xF8) >> 3;\n\t\t\t\t\tif (audio_object_type == 31) { /*escape code*/\n\t\t\t\t\t\tconst u8 audio_object_type_ext = ((esd->decoderConfig->decoderSpecificInfo->data[0] & 0x07) << 3) + ((esd->decoderConfig->decoderSpecificInfo->data[1] & 0xE0) >> 5);\n\t\t\t\t\t\taudio_object_type = 32 + audio_object_type_ext;\n\t\t\t\t\t}\n\t#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tif (force_sbr && (audio_object_type==2) ) {\n\t\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\t\tGF_Err e = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\tif (a_cfg.sbr_sr)\n\t\t\t\t\t\t\t\taudio_object_type = a_cfg.sbr_object_type;\n\t\t\t\t\t\t\tif (a_cfg.has_ps)\n\t\t\t\t\t\t\t\taudio_object_type = 29;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t#endif\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4a.%02X.%01d\"", esd->decoderConfig->objectTypeIndication, audio_object_type);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4a.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_VISUAL:\n\t#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4v.%02X.%01x\"", esd->decoderConfig->objectTypeIndication, dsi.VideoPL);\n\t\t\t\t} else\n\t#endif\n\t\t\t\t{\n\t\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4v.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""mp4s.%02X\"", esd->decoderConfig->objectTypeIndication);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[RFC6381] Cannot find ESD. Aborting.\\n\""));\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t//FIXME: in avc1 with multiple descriptor, we should take the right description index\n\t\tavcc = gf_isom_avc_config_get(movie, track, 1);\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_AVC_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC3_H264;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_AVC2_H264)\n\t\t\t\tsubtype = GF_ISOM_SUBTYPE_AVC4_H264;\n\t\t}\n\t\tif (avcc) {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02X%02X%02X\"", gf_4cc_to_str(subtype), avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Cannot find AVC configuration box\""));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tavcc = gf_isom_mvc_config_get(movie, track, 1);\n\t\tif (!avcc) avcc = gf_isom_svc_config_get(movie, track, 1);\n\t\tif (avcc) {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02X%02X%02X\"", gf_4cc_to_str(subtype), avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""Cannot find AVC configuration box\""));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n#ifndef GPAC_DISABLE_HEVC\n\tcase GF_ISOM_SUBTYPE_HVC1:\n\tcase GF_ISOM_SUBTYPE_HEV1:\n\tcase GF_ISOM_SUBTYPE_HVC2:\n\tcase GF_ISOM_SUBTYPE_HEV2:\n\tcase GF_ISOM_SUBTYPE_HVT1:\n\tcase GF_ISOM_SUBTYPE_LHV1:\n\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tif (force_inband) {\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_HVC1) subtype = GF_ISOM_SUBTYPE_HEV1;\n\t\t\telse if (subtype==GF_ISOM_SUBTYPE_HVC2) subtype = GF_ISOM_SUBTYPE_HEV2;\n\t\t}\n\t\thvcc = gf_isom_hevc_config_get(movie, track, 1);\n\t\tif (!hvcc) {\n\t\t\thvcc = gf_isom_lhvc_config_get(movie, track, 1);\n\t\t}\n\t\tif (subtype==GF_ISOM_SUBTYPE_HVT1) {\n\t\t\tu32 refTrack;\n\t\t\tgf_isom_get_reference(movie, track, GF_ISOM_REF_TBAS, 1, &refTrack);\n\t\t\tif (hvcc) gf_odf_hevc_cfg_del(hvcc);\n\t\t\thvcc = gf_isom_hevc_config_get(movie, refTrack, 1);\n\t\t}\n\t\tif (hvcc) {\n\t\t\tu8 c;\n\t\t\tchar szTemp[RFC6381_CODEC_NAME_SIZE_MAX];\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.\"", gf_4cc_to_str(subtype));\n\t\t\tif (hvcc->profile_space==1) strcat(szCodec, \""A\"");\n\t\t\telse if (hvcc->profile_space==2) strcat(szCodec, \""B\"");\n\t\t\telse if (hvcc->profile_space==3) strcat(szCodec, \""C\"");\n\t\t\t//profile idc encoded as a decimal number\n\t\t\tsprintf(szTemp, \""%d\"", hvcc->profile_idc);\n\t\t\tstrcat(szCodec, szTemp);\n\t\t\t//general profile compatibility flags: hexa, bit-reversed\n\t\t\t{\n\t\t\t\tu32 val = hvcc->general_profile_compatibility_flags;\n\t\t\t\tu32 i, res = 0;\n\t\t\t\tfor (i=0; i<32; i++) {\n\t\t\t\t\tres |= val & 1;\n\t\t\t\t\tif (i==31) break;\n\t\t\t\t\tres <<= 1;\n\t\t\t\t\tval >>=1;\n\t\t\t\t}\n\t\t\t\tsprintf(szTemp, \"".%X\"", res);\n\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t}\n\n\t\t\tif (hvcc->tier_flag) strcat(szCodec, \"".H\"");\n\t\t\telse strcat(szCodec, \"".L\"");\n\t\t\tsprintf(szTemp, \""%d\"", hvcc->level_idc);\n\t\t\tstrcat(szCodec, szTemp);\n\n\t\t\tc = hvcc->progressive_source_flag << 7;\n\t\t\tc |= hvcc->interlaced_source_flag << 6;\n\t\t\tc |= hvcc->non_packed_constraint_flag << 5;\n\t\t\tc |= hvcc->frame_only_constraint_flag << 4;\n\t\t\tc |= (hvcc->constraint_indicator_flags >> 40);\n\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\tstrcat(szCodec, szTemp);\n\t\t\tif (hvcc->constraint_indicator_flags & 0xFFFFFFFF) {\n\t\t\t\tc = (hvcc->constraint_indicator_flags >> 32) & 0xFF;\n\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\tif (hvcc->constraint_indicator_flags & 0x00FFFFFF) {\n\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 24) & 0xFF;\n\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\tif (hvcc->constraint_indicator_flags & 0x0000FFFF) {\n\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 16) & 0xFF;\n\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\tif (hvcc->constraint_indicator_flags & 0x000000FF) {\n\t\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags >> 8) & 0xFF;\n\t\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\t\tc = (hvcc->constraint_indicator_flags ) & 0xFF;\n\t\t\t\t\t\t\tsprintf(szTemp, \"".%X\"", c);\n\t\t\t\t\t\t\tstrcat(szCodec, szTemp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t} else {\n\t\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s\"", gf_4cc_to_str(subtype));\n\t\t}\n\t\treturn GF_OK;\n#endif /*GPAC_DISABLE_HEVC*/\n\n#ifndef GPAC_DISABLE_AV1\n\tcase GF_ISOM_SUBTYPE_AV01: {\n\t\tGF_AV1Config *av1c = NULL;\n\t\tAV1State av1_state;\n\t\tGF_BitStream *bs = NULL;\n\t\tGF_Err e = GF_OK;\n\t\tu32 i = 0;\n\n\t\tmemset(&av1_state, 0, sizeof(AV1State));\n\t\tav1c = gf_isom_av1_config_get(movie, track, 1);\n\t\tif (!av1c) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] No config found for AV1 file (\\\""%s\\\"") when computing RFC6381.\\n\"", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tav1_state.config = av1c;\n\n\t\tfor (i = 0; i < gf_list_count(av1c->obu_array); ++i) {\n\t\t\tGF_AV1_OBUArrayEntry *a = gf_list_get(av1c->obu_array, i);\n\t\t\tbs = gf_bs_new(a->obu, a->obu_length, GF_BITSTREAM_READ);\n\t\t\tif (!av1_is_obu_header(a->obu_type))\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_AUTHOR, (\""[ISOM Tools] AV1: unexpected obu_type %d when computing RFC6381. PArsing anyway.\\n\"", a->obu_type, gf_4cc_to_str(subtype)));\n\n\t\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &av1_state);\n\t\t\tgf_bs_del(bs); bs = NULL;\n\t\t\tif (e) {\n\t\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%01u.%02u%c.%02u\"", gf_4cc_to_str(subtype),\n\t\t\tav1_state.config->seq_profile, av1_state.config->seq_level_idx_0, av1_state.config->seq_tier_0 ? 'H' : 'M',\n\t\t\tav1_state.bit_depth);\n\n\t\t/* \""All the other fields [...] are optional, mutually inclusive (all or none) fields.\"" https://aomediacodec.github.io/av1-isobmff/ */\n\t\tif (av1_state.color_description_present_flag) {\n\t\t\tchar tmp[RFC6381_CODEC_NAME_SIZE_MAX];\n\t\t\tsnprintf(tmp, RFC6381_CODEC_NAME_SIZE_MAX, \""%01u.%01u.%01u.%01u.%01u.%01u%01u%01u\"",\n\t\t\t\tav1_state.config->monochrome,\n\t\t\t\tav1_state.config->chroma_subsampling_x, av1_state.config->chroma_subsampling_y,\n\t\t\t\tav1_state.config->chroma_subsampling_x && av1_state.config->chroma_subsampling_y ? av1_state.config->chroma_sample_position : 0,\n\t\t\t\tav1_state.color_primaries, av1_state.transfer_characteristics, av1_state.matrix_coefficients, av1_state.color_range);\n\t\t\tstrcat(szCodec, tmp);\n\t\t}\n\n\t\tgf_odf_av1_cfg_del(av1c);\n\t\tav1_reset_frame_state(&av1_state.frame_state);\n\t\treturn GF_OK;\n\t}\n#endif /*GPAC_DISABLE_AV1*/\n\n\n\tcase GF_ISOM_SUBTYPE_VP08:\n\tcase GF_ISOM_SUBTYPE_VP09:\n\t{\n\t\tGF_VPConfig *vpcc = NULL;\n\n\t\tvpcc = gf_isom_vp_config_get(movie, track, 1);\n\t\tif (!vpcc) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] No config found for VP file (\\\""%s\\\"") when computing RFC6381.\\n\"", gf_4cc_to_str(subtype)));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s.%02u.%02u.%02u.%02u.%02u.%02u.%02u.%02u\"", gf_4cc_to_str(subtype),\n\t\t\tvpcc->profile,\n\t\t\tvpcc->level,\n\t\t\tvpcc->bit_depth,\n\t\t\tvpcc->chroma_subsampling,\n\t\t\tvpcc->colour_primaries,\n\t\t\tvpcc->transfer_characteristics,\n\t\t\tvpcc->matrix_coefficients,\n\t\t\tvpcc->video_fullRange_flag);\n\n\n\t\tgf_odf_vp_cfg_del(vpcc);\n\n\t\treturn GF_OK;\n\t}\n\n\tdefault:\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (\""[ISOM Tools] codec parameters not known - setting codecs string to default value \\\""%s\\\""\\n\"", gf_4cc_to_str(subtype) ));\n\t\tsnprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, \""%s\"", gf_4cc_to_str(subtype));\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}""}, {""func_name"": ""iSLT_Write"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err iSLT_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMACrypSaltBox *ptr = (GF_ISMACrypSaltBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u64(bs, ptr->salt);\n\treturn GF_OK;\n}""}, {""func_name"": ""senc_Parse"", ""file_path"": ""src/isomedia/box_code_drm.c"", ""func_code"": ""GF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tu32 i, j, count;\n\tu64 pos = gf_bs_get_position(bs);\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tcount = gf_bs_read_u32(bs);\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tu32 is_encrypted;\n\t\tu32 samp_count;\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));\n\t\tmemset(sai, 0, sizeof(GF_CENCSampleAuxInfo));\n\n\t\tsamp_count = i+1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (trak) samp_count += trak->sample_count_at_seg_start;\n#endif\n\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_ex(trak, traf, senc, samp_count, &is_encrypted, &sai->IV_size, NULL, NULL, NULL, NULL, NULL);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[isobmf] could not get cenc info for sample %d: %s\\n\"", samp_count, gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size 16\\n\"" ));\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tsai->IV_size = 16;\n\t\t}\n\t\t//while this would technically be correct, senc mandates that sample_count = all samples in traf/track\n\t\t//regardless of their encryption state\n\t\t//if (is_encrypted)\n\t\t{\n\t\t\tif (sai->IV_size)\n\t\t\t\tgf_bs_read_data(bs, (char *)sai->IV, sai->IV_size);\n\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tsai->subsample_count = gf_bs_read_u16(bs);\n\t\t\t\tsai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));\n\t\t\t\tfor (j = 0; j < sai->subsample_count; j++) {\n\t\t\t\t\tif (gf_bs_get_size(bs) - gf_bs_get_position(bs) < 6) {\n\t\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tsai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);\n\t\t\t\t\tsai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n}""}, {""func_name"": ""audio_sample_entry_Read"", ""file_path"": ""src/isomedia/box_code_base.c"", ""func_code"": ""GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\t\t\tif (!e) gf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}""}, {""func_name"": ""ReadGF_IPMPX_RemoveToolNotificationListener"", ""file_path"": ""src/odf/ipmpx_code.c"", ""func_code"": ""static GF_Err ReadGF_IPMPX_RemoveToolNotificationListener(GF_BitStream *bs, GF_IPMPX_Data *_p, u32 size)\n{\n\tu32 i;\n\tu8 count;\n\tGF_IPMPX_RemoveToolNotificationListener*p = (GF_IPMPX_RemoveToolNotificationListener*)_p;\n\tp->eventTypeCount = 0;\n\tcount = gf_bs_read_int(bs, 8);\n\tif (count > ARRAY_LENGTH(p->eventType))\n\t\treturn GF_CORRUPTED_DATA;\n\n\tp->eventTypeCount = count;\n\tfor (i=0; i<p->eventTypeCount; i++) p->eventType[i] = gf_bs_read_int(bs, 8);\n\treturn GF_OK;\n}""}]","{""function"": 5, ""code"": 2}","[{""source"": ""func_info(func:gf_isom_get_esd)"", ""result"": [{""code"": ""GF_ESD *gf_isom_get_esd(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_ESD *esd;\n\tGF_Err e;\n\te = GetESD(movie->moov, gf_isom_get_track_id(movie, trackNumber), StreamDescriptionI"", ""start_line"": 1121, ""end_line"": 1132, ""full_name"": ""gf_isom_get_esd"", ""file_path"": ""src/isomedia/isom_read.c""}]}, {""source"": ""func_info(file:track.c, func:GetESD)"", ""result"": [{""code"": ""GF_Err GetESD(GF_MovieBox *moov, u32 trackID, u32 StreamDescIndex, GF_ESD **outESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu32 track_num = 0;\n\tu32 k;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak, *OCRTrack;\n\tGF_"", ""start_line"": 66, ""end_line"": 312, ""full_name"": ""GetESD"", ""file_path"": ""src/isomedia/track.c""}]}, {""source"": ""func_info(file:track.c, func:GetESD)"", ""result"": [{""code"": ""GF_Err GetESD(GF_MovieBox *moov, u32 trackID, u32 StreamDescIndex, GF_ESD **outESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu32 track_num = 0;\n\tu32 k;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak, *OCRTrack;\n\tGF_"", ""start_line"": 66, ""end_line"": 312, ""full_name"": ""GetESD"", ""file_path"": ""src/isomedia/track.c""}]}, {""source"": ""code_info(file:track.c, lines:66-312)"", ""result"": ""GF_Err GetESD(GF_MovieBox *moov, u32 trackID, u32 StreamDescIndex, GF_ESD **outESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu32 track_num = 0;\n\tu32 k;\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak, *OCRTrack;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_SLConfig *slc;\n\tGF_MPEGSampleEntryBox *entry;\n\n\tif (!moov) return GF_ISOM_INVALID_FILE;\n\n\ttrack_num = gf_isom_get_tracknum_from_id(moov, trackID);\n\tdpnd = NULL;\n\t*outESD = NULL;\n\n\ttrak = gf_isom_get_track(moov, track_num);\n\tif (!trak) return GF_ISOM_INVALID_FILE;\n\n\te = Media_GetESD(trak->Media, StreamDescIndex, &esd, 0);\n\tif (e) return e;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescIndex, (GF_SampleEntryBox **) &entry, NULL);\n\tif (e) return e;\n\t//set the ID\n\tesd->ESID = trackID;\n\n\t//find stream dependencies: dpnd, sbas and scal\n\tfor (k=0; k<3; k++) {\n\t\tu32 ref = GF_ISOM_BOX_TYPE_DPND;\n\t\tif (k==1) ref = GF_ISOM_REF_BASE;\n\t\telse if (k==2) ref = GF_ISOM_REF_SCAL;\n\n\t\te = Track_FindRef(trak, ref , &dpnd);\n\t\tif (e) return e;\n\t\tif (dpnd) {\n\t\t\t//ONLY ONE STREAM DEPENDENCY IS ALLOWED\n\t\t\tif (!k && (dpnd->trackIDCount != 1)) return GF_ISOM_INVALID_MEDIA;\n\t\t\t//fix the spec: where is the index located ??\n\t\t\tesd->dependsOnESID = dpnd->trackIDs[0];\n\t\t\tbreak;\n\t\t} else {\n\t\t\tesd->dependsOnESID = 0;\n\t\t}\n\t}\n\n\tif (trak->udta) {\n\t\tGF_UserDataMap *map;\n\t\tu32 i = 0;\n\t\twhile ((map = (GF_UserDataMap*)gf_list_enum(trak->udta->recordList, &i))) {\n\t\t\tif (map->boxType == GF_ISOM_BOX_TYPE_AUXV) {\n\t\t\t\tGF_Descriptor *d = gf_odf_desc_new(GF_ODF_AUX_VIDEO_DATA);\n\t\t\t\tgf_list_add(esd->extensionDescriptors, d);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//OK, get the OCR (in a REAL MP4File, OCR is 0 in ESD and is specified through track reference\n\tdpnd = NULL;\n\tOCRTrack = NULL;\n\t//find OCR dependencies\n\te = Track_FindRef(trak, GF_ISOM_BOX_TYPE_SYNC, &dpnd);\n\tif (e) return e;\n\tif (dpnd) {\n\t\tif (dpnd->trackIDCount != 1) return GF_ISOM_INVALID_MEDIA;\n\t\tesd->OCRESID = dpnd->trackIDs[0];\n\t\tOCRTrack = gf_isom_get_track_from_id(trak->moov, dpnd->trackIDs[0]);\n\n\t\twhile (OCRTrack) {\n\t\t\t/*if we have a dependency on a track that doesn't have OCR dep, remove that dependency*/\n\t\t\te = Track_FindRef(OCRTrack, GF_ISOM_BOX_TYPE_SYNC, &dpnd);\n\t\t\tif (e || !dpnd || !dpnd->trackIDCount) {\n\t\t\t\tOCRTrack = NULL;\n\t\t\t\tgoto default_sync;\n\t\t\t}\n\t\t\t/*this is explicit desync*/\n\t\t\tif (dpnd && ((dpnd->trackIDs[0]==0) || (dpnd->trackIDs[0]==OCRTrack->Header->trackID))) break;\n\t\t\t/*loop in OCRs, break it*/\n\t\t\tif (esd->ESID == OCRTrack->Header->trackID) {\n\t\t\t\tOCRTrack = NULL;\n\t\t\t\tgoto default_sync;\n\t\t\t}\n\t\t\t/*check next*/\n\t\t\tOCRTrack = gf_isom_get_track_from_id(trak->moov, dpnd->trackIDs[0]);\n\t\t}\n\t\tif (!OCRTrack) goto default_sync;\n\t} else {\ndefault_sync:\n\t\t/*all tracks are sync'ed by default*/\n\t\tif (trak->moov->mov->es_id_default_sync<0) {\n\t\t\tif (esd->OCRESID)\n\t\t\t\ttrak->moov->mov->es_id_default_sync = esd->OCRESID;\n\t\t\telse\n\t\t\t\ttrak->moov->mov->es_id_default_sync = esd->ESID;\n\t\t}\n\t\tif (trak->moov->mov->es_id_default_sync) esd->OCRESID = (u16) trak->moov->mov->es_id_default_sync;\n\t\t/*cf ESD writer*/\n\t\tif (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\t}\n\n\n\n\t//update the IPI stuff if needed\n\tif (esd->ipiPtr != NULL) {\n\t\tdpnd = NULL;\n\t\te = Track_FindRef(trak, GF_ISOM_BOX_TYPE_IPIR, &dpnd);\n\t\tif (e) return e;\n\t\tif (dpnd) {\n\t\t\tif (esd->ipiPtr->tag != GF_ODF_ISOM_IPI_PTR_TAG) return GF_ISOM_INVALID_FILE;\n\t\t\t//OK, retrieve the ID: the IPI_ES_Id is currently the ref track\n\t\t\tesd->ipiPtr->IPI_ES_Id = dpnd->trackIDs[esd->ipiPtr->IPI_ES_Id - 1];\n\t\t\t//and change the tag\n\t\t\tesd->ipiPtr->tag = GF_ODF_IPI_PTR_TAG;\n\t\t} else {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n\tif ((trak->Media->mediaHeader->packedLanguage[0] != 'u')\n\t        || (trak->Media->mediaHeader->packedLanguage[1] != 'n')\n\t        || (trak->Media->mediaHeader->packedLanguage[2] != 'd') ) {\n\t\tif (!esd->langDesc) esd->langDesc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);\n\n\t\tesd->langDesc->langCode = trak->Media->mediaHeader->packedLanguage[0];\n\t\tesd->langDesc->langCode <<= 8;\n\t\tesd->langDesc->langCode |= trak->Media->mediaHeader->packedLanguage[1];\n\t\tesd->langDesc->langCode <<= 8;\n\t\tesd->langDesc->langCode |= trak->Media->mediaHeader->packedLanguage[2];\n\t}\n\n\n\t{\n\t\tu16 rvc_predefined;\n\t\tchar *rvc_cfg_data;\n\t\tconst char *mime_type;\n\t\tu32 rvc_cfg_size;\n\t\te = gf_isom_get_rvc_config(moov->mov, track_num, 1, &rvc_predefined, &rvc_cfg_data, &rvc_cfg_size, &mime_type);\n\t\tif (e==GF_OK) {\n\t\t\tif (rvc_predefined) {\n\t\t\t\tesd->decoderConfig->predefined_rvc_config = rvc_predefined;\n\t\t\t} else {\n\t\t\t\tesd->decoderConfig->rvc_config = (GF_DefaultDescriptor *) gf_odf_desc_new(GF_ODF_DSI_TAG);\n\t\t\t\tif (mime_type && !strcmp(mime_type, \""application/rvc-config+xml+gz\"") ) {\n#if !defined(GPAC_DISABLE_CORE_TOOLS) && !defined(GPAC_DISABLE_ZLIB)\n\t\t\t\t\tgf_gz_decompress_payload(rvc_cfg_data, rvc_cfg_size, &esd->decoderConfig->rvc_config->data, &esd->decoderConfig->rvc_config->dataLength);\n\t\t\t\t\tgf_free(rvc_cfg_data);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tesd->decoderConfig->rvc_config->data = rvc_cfg_data;\n\t\t\t\t\tesd->decoderConfig->rvc_config->dataLength = rvc_cfg_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/*normally all files shall be stored with predefined=SLPredef_MP4, but of course some are broken (philips)\n\tso we just check the ESD_URL. If set, use the given cfg, otherwise always rewrite it*/\n\tif (esd->URLString != NULL) {\n\t\t*outESD = esd;\n\t\treturn GF_OK;\n\t}\n\n\t//if we are in publishing mode and we have an SLConfig specified, use it as is\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tslc = entry->slc;\n\t\tbreak;\n\tdefault:\n\t\tslc = NULL;\n\t\tbreak;\n\t}\n\tif (slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)esd->slConfig);\n\t\tgf_odf_desc_copy((GF_Descriptor *)slc, (GF_Descriptor **)&esd->slConfig);\n\t\t*outESD = esd;\n\t\treturn GF_OK;\n\t}\n\t//otherwise use the regular mapping\n\n\t//this is a desc for a media in the file, let's rewrite some param\n\tesd->slConfig->timestampLength = 32;\n\tesd->slConfig->timestampResolution = trak->Media->mediaHeader->timeScale;\n\t//NO OCR from MP4File streams (eg, constant OC Res one)\n\tesd->slConfig->OCRLength = 0;\n\tesd->slConfig->OCRResolution = 0;\n//\tif (OCRTrack) esd->slConfig->OCRResolution = OCRTrack->Media->mediaHeader->timeScale;\n\n\tstbl = trak->Media->information->sampleTable;\n\t// a little optimization here: if all our samples are sync,\n\t//set the RAPOnly to true... for external users...\n\tif (! stbl->SyncSample) {\n\t\tif (\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t    moov->mvex &&\n#endif\n\t\t    (esd->decoderConfig->streamType==GF_STREAM_VISUAL)) {\n\t\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 0;\n\t\t\tesd->slConfig->useRandomAccessPointFlag = 1;\n\t\t\tif (trak->moov->mov->openMode!=GF_ISOM_OPEN_READ)\n\t\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSS);\n\t\t} else {\n\t\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\tesd->slConfig->useRandomAccessPointFlag = 0;\n\t\t}\n\t} else {\n\t\tesd->slConfig->hasRandomAccessUnitsOnlyFlag = 0;\n\t\t//signal we are NOT using sync points if no info is present in the table\n\t\tesd->slConfig->useRandomAccessPointFlag = stbl->SyncSample->nb_entries ? 1 : 0;\n\t}\n\t//do we have DegradationPriority ?\n\tif (stbl->DegradationPriority) {\n\t\tesd->slConfig->degradationPriorityLength = 15;\n\t} else {\n\t\tesd->slConfig->degradationPriorityLength = 0;\n\t}\n\t//paddingBits\n\tif (stbl->PaddingBits) {\n\t\tesd->slConfig->usePaddingFlag = 1;\n\t}\n\t//change to support reflecting OD streams\n\tesd->slConfig->useAccessUnitEndFlag = 1;\n\tesd->slConfig->useAccessUnitStartFlag = 1;\n\n\t//signal we do have padding flag (since we only use logical SL packet\n\t//the user can decide whether to use the info or not\n\tesd->slConfig->usePaddingFlag = stbl->PaddingBits ? 1 : 0;\n\n\t//same with degradation priority\n\tesd->slConfig->degradationPriorityLength = stbl->DegradationPriority ? 32 : 0;\n\n\t//this new SL will be OUT OF THE FILE. Let's set its predefined to 0\n\tesd->slConfig->predefined = 0;\n\n\n\t*outESD = esd;\n\treturn GF_OK;\n}\n\n""}, {""source"": ""func_info(file:media.c, func:Media_GetESD)"", ""result"": [{""code"": ""GF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_SampleDescriptionBox *sts"", ""start_line"": 149, ""end_line"": 360, ""full_name"": ""Media_GetESD"", ""file_path"": ""src/isomedia/media.c""}]}, {""source"": ""func_info(file:media.c, func:Media_GetESD)"", ""result"": [{""code"": ""GF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_SampleDescriptionBox *sts"", ""start_line"": 149, ""end_line"": 360, ""full_name"": ""Media_GetESD"", ""file_path"": ""src/isomedia/media.c""}]}, {""source"": ""code_info(file:media.c, lines:149-360)"", ""result"": ""GF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;\n\n\t*out_esd = NULL;\n\tif (!stsd || !stsd->other_boxes || !sampleDescIndex || (sampleDescIndex > gf_list_count(stsd->other_boxes)) )\n\t\treturn GF_BAD_PARAM;\n\n\tesd = NULL;\n\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->other_boxes, sampleDescIndex - 1);\n\tif (! entry) return GF_ISOM_INVALID_MEDIA;\n\n\t*out_esd = NULL;\n\tESDa = NULL;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tESDa = ((GF_MPEGVisualSampleEntryBox*)entry)->esd;\n\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t/*avc1 encrypted*/\n\t\telse esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tAV1_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tVP9_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n        {\n            GF_MPEGAudioSampleEntryBox *ase = (GF_MPEGAudioSampleEntryBox*)entry;\n            ESDa = ase->esd;\n            if (ESDa) esd = (GF_ESD *) ESDa->desc;\n            else {\n                // Assuming that if no ESD is provided the stream is Basic MPEG-4 AAC LC\n                GF_M4ADecSpecInfo aacinfo;\n                memset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n                aacinfo.nb_chan = ase->channel_count;\n                aacinfo.base_object_type = GF_M4A_AAC_LC;\n                aacinfo.base_sr = ase->samplerate_hi;\n                *out_esd = gf_odf_desc_esd_new(0);\n                (*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n                (*out_esd)->decoderConfig->objectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;\n                gf_m4a_write_config(&aacinfo, &(*out_esd)->decoderConfig->decoderSpecificInfo->data, &(*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n            }\n        }\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\tESDa = entry->esd;\n\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\tbreak;\n#ifndef GPAC_DISABLE_TTXT\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tif (!true_desc_only && mdia->mediaTrack->moov->mov->convert_streaming_text) {\n\t\t\tGF_Err e = gf_isom_get_ttxt_esd(mdia, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n#endif\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t{\n\t\tGF_BitStream *bs;\n\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t*out_esd = esd;\n\t\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_SCENE_VTT_MP4;\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u32(bs, entry->type);\n\t\tgf_isom_box_write((GF_Box *)((GF_WebVTTSampleEntryBox*)entry)->config, bs);\n\t\tgf_bs_get_content(bs, & esd->decoderConfig->decoderSpecificInfo->data, & esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs);\n\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tbreak;\n#endif\n\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tif (!true_desc_only) {\n\t\t\tGF_Err e = gf_isom_get_3gpp_audio_esd(mdia->information->sampleTable, (GF_GenericAudioSampleEntryBox*)entry, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t} else return GF_ISOM_INVALID_MEDIA;\n\n\tcase GF_ISOM_SUBTYPE_OPUS: {\n\t\tGF_OpusSpecificBox *e = ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_opus;\n\t\tGF_BitStream *bs_out;\n\t\tif (!e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""ESD not found for Opus\\n)\""));\n\t\t\tbreak;\n\t\t}\n\n\t\t*out_esd = gf_odf_desc_esd_new(2);\n\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GPAC_OTI_MEDIA_OPUS;\n\n\t\t//serialize box with header - compatibility with ffmpeg\n\t\tbs_out = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_isom_box_size((GF_Box *) e);\n\t\tgf_isom_box_write((GF_Box *) e, bs_out);\n\t\tgf_bs_get_content(bs_out, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs_out);\n\t\tbreak;\n\t}\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_BitStream *bs;\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_MEDIA_GENERIC;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, entry->type);\n\t\t\tgf_bs_write_u16(bs, ((GF_MPEGVisualSampleEntryBox*)entry)->Width);\n\t\t\tgf_bs_write_u16(bs, ((GF_MPEGVisualSampleEntryBox*)entry)->Height);\n\t\t\tgf_bs_get_content(bs, & esd->decoderConfig->decoderSpecificInfo->data, & esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_MP3:\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_AUDIO_MPEG1;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_LSR1:\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_LASeRSampleEntryBox*ptr = (GF_LASeRSampleEntryBox*)entry;\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t\tesd->decoderConfig->objectTypeIndication = GPAC_OTI_SCENE_LASER;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = ptr->lsr_config->hdr_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, ptr->lsr_config->hdr, sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tbreak;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t\tbreak;\n\n\tdefault:\n\t\treturn GF_ISOM_INVALID_MEDIA;\n\t}\n\n\tif (true_desc_only) {\n\t\tif (!esd) return GF_ISOM_INVALID_MEDIA;\n\t\t*out_esd = esd;\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!esd && !*out_esd) return GF_ISOM_INVALID_MEDIA;\n\t\tif (*out_esd == NULL) gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)out_esd);\n\t}\n\treturn GF_OK;\n}\n\n""}]","The vulnerability chain is as follows: 1. `Media_GetESD` (media.c:149-360) returns an error if `sampleDescIndex` is invalid or the corresponding sample entry is missing. 2. `GetESD` (track.c:66-312) propagates this error, leading to a NULL `esd` in `gf_isom_get_esd` (isom_read.c:1121-1132). 3. The NULL `esd` is dereferenced in `gf_media_get_rfc_6381_codec_name` (dash_segmenter.c:478) without a check in the vulnerable version. Patches added checks for `esd && esd->decoderConfig` to prevent the dereference.",0.95,./github/other_context/CVE-2019-12481
71,CVE-2019-15151,CWE-415,c_cpp,AdPlug 2.3.1 has a double free in the Cu6mPlayer class in u6m.h.,https://github.com/adplug/adplug/commit/e8814f46ec2285a32eed47cbaea691030da67637,"Fix double free in Cu6mPlayer::~Cu6mPlayer() (issue #91)\n\nLeave deallocation of song_data to destructor when\ndecompression fails, just like on success.\n\nThis fixes CVE-2019-15151.\n\nEven though load() is apparently not supposed to be called\ntwice (and bad things happen in many players if you do),\nlet's also avoid leaking song_data's memory in that case.\n\nFixes: https://github.com/adplug/adplug/issues/91",1,"[{""func_name"": ""Cu6mPlayer::load"", ""file_path"": ""src/u6m.cpp"", ""func_code"": ""bool Cu6mPlayer::load(const std::string &filename, const CFileProvider &fp)\n{\n  // file validation section\n  // this section only checks a few *necessary* conditions\n  unsigned long filesize, decompressed_filesize;\n  binistream *f;\n\n  f = fp.open(filename); if(!f) return false;\n  filesize = fp.filesize(f);\n\n  if (filesize >= 6)\n    {\n      // check if the file has a valid pseudo-header\n      unsigned char pseudo_header[6];\n      f->readString((char *)pseudo_header, 6);\n      decompressed_filesize = pseudo_header[0] + (pseudo_header[1] << 8);\n\n      if (!( (pseudo_header[2]==0) && (pseudo_header[3]==0) &&\n\t     (pseudo_header[4] + ((pseudo_header[5] & 0x1)<<8) == 0x100) &&\n\t     (decompressed_filesize > (filesize-4)) ))\n        {\n\t  fp.close(f);\n\t  return(false);\n        }\n    }\n  else\n    {\n      fp.close(f);\n      return(false);\n    }\n\n  // load section\n  song_data = new unsigned char[decompressed_filesize];\n  unsigned char* compressed_song_data = new unsigned char[filesize-3];\n\n  f->seek(4);\n  f->readString((char *)compressed_song_data, filesize - 4);\n  fp.close(f);\n\n  // attempt to decompress the song data\n  // if unsuccessful, deallocate song_data[] on the spot, and return(false)\n  data_block source, destination;\n  source.size = filesize-4;\n  source.data = compressed_song_data;\n  destination.size = decompressed_filesize;\n  destination.data = song_data;\n\t\n  if (!lzw_decompress(source,destination))\n    {\n      delete[] compressed_song_data;\n      delete[] song_data;\n      return(false);\n    }\n\n  // deallocation section\n  delete[] compressed_song_data;\n\n  rewind(0);\n  return (true);\n}"", ""target"": 0}]","[{""func_name"": ""Cu6mPlayer::load"", ""file_path"": ""src/u6m.cpp"", ""func_code"": ""bool Cu6mPlayer::load(const std::string &filename, const CFileProvider &fp)\n{\n  // file validation section\n  // this section only checks a few *necessary* conditions\n  unsigned long filesize, decompressed_filesize;\n  binistream *f;\n\n  f = fp.open(filename); if(!f) return false;\n  filesize = fp.filesize(f);\n\n  if (filesize >= 6)\n    {\n      // check if the file has a valid pseudo-header\n      unsigned char pseudo_header[6];\n      f->readString((char *)pseudo_header, 6);\n      decompressed_filesize = pseudo_header[0] + (pseudo_header[1] << 8);\n\n      if (!( (pseudo_header[2]==0) && (pseudo_header[3]==0) &&\n\t     (pseudo_header[4] + ((pseudo_header[5] & 0x1)<<8) == 0x100) &&\n\t     (decompressed_filesize > (filesize-4)) ))\n        {\n\t  fp.close(f);\n\t  return(false);\n        }\n    }\n  else\n    {\n      fp.close(f);\n      return(false);\n    }\n\n  // load section\n  delete[] song_data;\n  song_data = new unsigned char[decompressed_filesize];\n  unsigned char* compressed_song_data = new unsigned char[filesize-3];\n\n  f->seek(4);\n  f->readString((char *)compressed_song_data, filesize - 4);\n  fp.close(f);\n\n  // attempt to decompress the song data\n  data_block source, destination;\n  source.size = filesize-4;\n  source.data = compressed_song_data;\n  destination.size = decompressed_filesize;\n  destination.data = song_data;\n\t\n  if (!lzw_decompress(source,destination))\n    {\n      delete[] compressed_song_data;\n      return(false);\n    }\n\n  // deallocation section\n  delete[] compressed_song_data;\n\n  rewind(0);\n  return (true);\n}""}]","{""function"": 1}","[{""source"": ""func_info(func:~Cu6mPlayer)"", ""result"": [{""code"": ""~Cu6mPlayer()\n    {\n      if(song_data) delete[] song_data;\n    }"", ""start_line"": 40, ""end_line"": 43, ""full_name"": ""Cu6mPlayer.~Cu6mPlayer:ANY()"", ""file_path"": ""src/u6m.h""}]}]","1. In Cu6mPlayer::load(), pre-patch code deleted song_data on decompression failure (src/u6m.cpp:110). 2. The destructor (~Cu6mPlayer in u6m.h:40-43) also deletes song_data. 3. If load() failed and the object was destroyed, song_data was freed twice. 4. The patch removes the error-path delete[] song_data and adds delete[] song_data before reallocation (src/u6m.cpp:92), ensuring single deallocation via the destructor.",0.95,./github/other_context/CVE-2019-15151
72,CVE-2019-19004,"CWE-415, CWE-190",c_cpp,A biWidth*biBitCnt integer overflow in input-bmp.c in autotrace 0.31.1 allows attackers to provide an unexpected input value to malloc via a malformed bitmap image.,https://github.com/autotrace/autotrace/commit/64c5833e55d7672d6136a3fbfeae24bd012d36a5,Check for overflow in row bytes\n\nFixes CVE-2019-19004,1,"[{""func_name"": ""input_bmp_reader"", ""file_path"": ""src/input-bmp.c"", ""func_code"": ""at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps, Grey;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n\n  fd = fopen(filename, \""rb\"");\n\n  if (!fd) {\n    LOG(\""Can't open \\\""%s\\\""\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: cannot open input file\"");\n    return image;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, buffer, 18) || (strncmp((const char *)buffer, \""BM\"", 2))) {\n    LOG(\""Not a valid BMP file %s\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: invalid input file\"");\n    goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x02]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x06]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x08]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x0a]);\n  Bitmap_File_Head.biSize = ToL(&buffer[0x0e]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 4;\n  } else if (Bitmap_File_Head.biSize >= 40 && Bitmap_File_Head.biSize <= 64) {  /* Probably OS/2 2.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 3;\n  } else {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    Bitmap_Head.biClrUsed = ColormapSize;\n\n  /* Sanity checks */\n\n  if ((Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n      || (Bitmap_Head.biPlanes != 1)\n      || (ColormapSize > 256 || Bitmap_Head.biClrUsed > 256)) {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\""\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\"", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n  /* Get the Colormap */\n  ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp);\n  if (at_exception_got_fatal(&exp))\n    goto cleanup;\n\n#ifdef DEBUG\n  printf(\""Colormap read\\n\"");\n#endif\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, Bitmap_Head.biWidth, Bitmap_Head.biHeight, ColorMap, Bitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes, Grey);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}"", ""target"": 0}]","[{""func_name"": ""input_bmp_reader"", ""file_path"": ""src/input-bmp.c"", ""func_code"": ""at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps, Grey;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n\n  fd = fopen(filename, \""rb\"");\n\n  if (!fd) {\n    LOG(\""Can't open \\\""%s\\\""\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: cannot open input file\"");\n    return image;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, buffer, 18) || (strncmp((const char *)buffer, \""BM\"", 2))) {\n    LOG(\""Not a valid BMP file %s\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: invalid input file\"");\n    goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x02]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x06]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x08]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x0a]);\n  Bitmap_File_Head.biSize = ToL(&buffer[0x0e]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 4;\n  } else if (Bitmap_File_Head.biSize >= 40 && Bitmap_File_Head.biSize <= 64) {  /* Probably OS/2 2.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 3;\n  } else {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    Bitmap_Head.biClrUsed = ColormapSize;\n\n  /* Sanity checks */\n\n  if ((Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n      || (Bitmap_Head.biPlanes != 1)\n      || (ColormapSize > 256 || Bitmap_Head.biClrUsed > 256)) {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n   \n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\""Error reading BMP file header. Width is too large\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header. Width is too large\"");\n    goto cleanup;\n  }\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\""\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\"", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n  /* Get the Colormap */\n  ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp);\n  if (at_exception_got_fatal(&exp))\n    goto cleanup;\n\n#ifdef DEBUG\n  printf(\""Colormap read\\n\"");\n#endif\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, Bitmap_Head.biWidth, Bitmap_Head.biHeight, ColorMap, Bitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes, Grey);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}""}]","{""code"": 1, ""value"": 2}","[{""source"": ""code_info(file:input-bmp.c, lines:1-182)"", ""result"": ""/* input-bmp.c:\treads any bitmap I could get for testing\n\n   Copyright (C) 1999, 2000, 2001 Martin Weber.\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public License\n   as published by the Free Software Foundation; either version 2.1 of\n   the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n   USA. */\n\n#ifdef HAVE_CONFIG_H\n#include \""config.h\""\n#endif /* Def: HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \""types.h\""\n#include \""bitmap.h\""\n#include \""logreport.h\""\n#include \""xstd.h\""\n#include \""input-bmp.h\""\n\n#define BitSet(byte, bit)  (((byte) & (bit)) == (bit))\n\n#define ReadOK(file,buffer,len)  (fread(buffer, len, 1, file) != 0)\n\nstruct Bitmap_File_Head_Struct {\n  char zzMagic[2];              /* 00 \""BM\"" */\n  unsigned long bfSize;         /* 02 */\n  unsigned short zzHotX;        /* 06 */\n  unsigned short zzHotY;        /* 08 */\n  unsigned long bfOffs;         /* 0A */\n  unsigned long biSize;         /* 0E */\n} Bitmap_File_Head;\n\nstruct Bitmap_Head_Struct {\n  unsigned long biWidth;        /* 12 */\n  unsigned long biHeight;       /* 16 */\n  unsigned short biPlanes;      /* 1A */\n  unsigned short biBitCnt;      /* 1C */\n  unsigned long biCompr;        /* 1E */\n  unsigned long biSizeIm;       /* 22 */\n  unsigned long biXPels;        /* 26 */\n  unsigned long biYPels;        /* 2A */\n  unsigned long biClrUsed;      /* 2E */\n  unsigned long biClrImp;       /* 32 */\n  /* 36 */\n} Bitmap_Head;\n\nstatic long ToL(unsigned char *);\nstatic short ToS(unsigned char *);\nstatic int ReadColorMap(FILE *, unsigned char[256][3], int, int, int *, at_exception_type *);\nstatic unsigned char *ReadImage(FILE *, int, int, unsigned char[256][3], int, int, int, int);\n\nat_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps, Grey;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n\n  fd = fopen(filename, \""rb\"");\n\n  if (!fd) {\n    LOG(\""Can't open \\\""%s\\\""\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: cannot open input file\"");\n    return image;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, buffer, 18) || (strncmp((const char *)buffer, \""BM\"", 2))) {\n    LOG(\""Not a valid BMP file %s\\n\"", filename);\n    at_exception_fatal(&exp, \""bmp: invalid input file\"");\n    goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x02]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x06]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x08]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x0a]);\n  Bitmap_File_Head.biSize = ToL(&buffer[0x0e]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 4;\n  } else if (Bitmap_File_Head.biSize >= 40 && Bitmap_File_Head.biSize <= 64) {  /* Probably OS/2 2.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\""Error reading BMP file header\\n\"");\n      at_exception_fatal(&exp, \""Error reading BMP file header\"");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 3;\n  } else {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    Bitmap_Head.biClrUsed = ColormapSize;\n\n  /* Sanity checks */\n\n  if ((Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n      || (Bitmap_Head.biPlanes != 1)\n      || (ColormapSize > 256 || Bitmap_Head.biClrUsed > 256)) {\n    LOG(\""Error reading BMP file header\\n\"");\n    at_exception_fatal(&exp, \""Error reading BMP file header\"");\n    goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n""}, {""source"": ""value_info(file:input-bmp.c, value:Bitmap_Head.biWidth)"", ""result"": {""value_trace"": [{""full_code"": ""Bitmap_Head.biWidth = ToS(&buffer[0x00])"", ""line"": 109, ""func_name"": ""input_bmp_reader""}, {""full_code"": ""Bitmap_Head.biWidth = ToL(&buffer[0x00])"", ""line"": 125, ""func_name"": ""input_bmp_reader""}, {""full_code"": ""Bitmap_Head.biWidth = ToL(&buffer[0x00])"", ""line"": 144, ""func_name"": ""input_bmp_reader""}], ""struct_var"": ""Bitmap_Head"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:input-bmp.c, value:Bitmap_Head.biBitCnt)"", ""result"": {""value_trace"": [{""full_code"": ""Bitmap_Head.biBitCnt = ToS(&buffer[0x06])"", ""line"": 112, ""func_name"": ""input_bmp_reader""}, {""full_code"": ""Bitmap_Head.biBitCnt = ToS(&buffer[0x0A])"", ""line"": 128, ""func_name"": ""input_bmp_reader""}, {""full_code"": ""Bitmap_Head.biBitCnt = ToS(&buffer[0x0A])"", ""line"": 147, ""func_name"": ""input_bmp_reader""}], ""struct_var"": ""Bitmap_Head"", ""struct_type"": null, ""struct_definition"": null}}]","The vulnerability arises from unchecked multiplication of user-controlled `biWidth` (src/input-bmp.c:109, 125, 144) and `biBitCnt` (src/input-bmp.c:112, 128, 147) read from a BMP file header via `fread`. These values are derived from `fopen(filename, ""rb"")` (src/input-bmp.c:43), making them attacker-controlled. The unchecked product is used in `rowbytes = ((biWidth * biBitCnt - 1) / 32) * 4 + 4` (src/input-bmp.c:183), leading to integer overflow and unsafe memory allocation. The patch (src/input-bmp.c:183) adds an overflow check via division validation.",0.95,./github/other_context/CVE-2019-19004
73,CVE-2020-16293,CWE-476,c_cpp,A null pointer dereference vulnerability in compose_group_nonknockout_nonblend_isolated_allmask_common() in base/gxblend.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.,https://github.com/ArtifexSoftware/ghostpdl/commit/7870f4951bcc6a153f317e3439e14d0e929fd231,Bug 701795: Segv due to image mask issue,2,"[{""func_name"": ""do_compose_group16"", ""file_path"": ""base/gxblend.c"", ""func_code"": ""static void\ndo_compose_group16(pdf14_buf *tos, pdf14_buf *nos, pdf14_buf *maskbuf,\n                   int x0, int x1, int y0, int y1, int n_chan, bool additive,\n                   const pdf14_nonseparable_blending_procs_t * pblend_procs,\n                   bool has_matte, bool overprint, gx_color_index drawn_comps,\n                   gs_memory_t *memory, gx_device *dev)\n{\n    int num_spots = tos->num_spots;\n    uint16_t alpha = tos->alpha;\n    uint16_t shape = tos->shape;\n    gs_blend_mode_t blend_mode = tos->blend_mode;\n    uint16_t *tos_ptr =\n        (uint16_t *)(void *)(tos->data + (x0 - tos->rect.p.x)*2 +\n                             (y0 - tos->rect.p.y) * tos->rowstride);\n    uint16_t *nos_ptr =\n        (uint16_t *)(void *)(nos->data + (x0 - nos->rect.p.x)*2 +\n                             (y0 - nos->rect.p.y) * nos->rowstride);\n    uint16_t *mask_row_ptr = NULL;\n    int tos_planestride = tos->planestride;\n    int nos_planestride = nos->planestride;\n    uint16_t mask_bg_alpha = 0; /* Quiet compiler. */\n    bool tos_isolated = tos->isolated;\n    bool nos_isolated = nos->isolated;\n    bool nos_knockout = nos->knockout;\n    uint16_t *nos_alpha_g_ptr;\n    int tos_shape_offset = n_chan * tos_planestride;\n    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);\n    bool tos_has_tag = tos->has_tags;\n    int tos_tag_offset = tos_planestride * (tos->n_planes - 1);\n    int nos_shape_offset = n_chan * nos_planestride;\n    int nos_alpha_g_offset = nos_shape_offset + (nos->has_shape ? nos_planestride : 0);\n    int nos_tag_offset = nos_planestride * (nos->n_planes - 1);\n    const uint16_t *mask_tr_fn = NULL; /* Quiet compiler. */\n    bool has_mask = false;\n    uint16_t *backdrop_ptr = NULL;\n    pdf14_device *pdev = (pdf14_device *)dev;\n#if RAW_DUMP\n    uint16_t *composed_ptr = NULL;\n    int width = x1 - x0;\n#endif\n    art_pdf_compose_group16_fn fn;\n\n    if ((tos->n_chan == 0) || (nos->n_chan == 0))\n        return;\n    rect_merge(nos->dirty, tos->dirty);\n    if (nos->has_tags)\n        if_debug7m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, tag = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, dev->graphics_type_tag & ~GS_DEVICE_ENCODES_TAGS, blend_mode);\n    else\n        if_debug6m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, blend_mode);\n    if (!nos->has_shape)\n        nos_shape_offset = 0;\n    if (!nos->has_tags)\n        nos_tag_offset = 0;\n    if (nos->has_alpha_g) {\n        nos_alpha_g_ptr = nos_ptr + (nos_alpha_g_offset>>1);\n    } else\n        nos_alpha_g_ptr = NULL;\n    if (nos->backdrop != NULL) {\n        backdrop_ptr =\n            (uint16_t *)(void *)(nos->backdrop + (x0 - nos->rect.p.x)*2 +\n                                 (y0 - nos->rect.p.y) * nos->rowstride);\n    }\n    if (blend_mode != BLEND_MODE_Compatible && blend_mode != BLEND_MODE_Normal)\n        overprint = false;\n\n    if (maskbuf != NULL) {\n        unsigned int tmp;\n        mask_tr_fn = (uint16_t *)maskbuf->transfer_fn;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr =\n                (uint16_t *)(void *)(maskbuf->data + (x0 - maskbuf->rect.p.x)*2 +\n                                     (y0 - maskbuf->rect.p.y) * maskbuf->rowstride);\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = interp16(mask_tr_fn, mask_bg_alpha);\n        tmp = alpha * mask_bg_alpha + 0x8000;\n        mask_bg_alpha = (tmp + (tmp >> 8)) >> 8;\n    }\n    n_chan--; /* Now the true number of colorants (i.e. not including alpha)*/\n#if RAW_DUMP\n    composed_ptr = nos_ptr;\n    dump_raw_buffer(memory, y1-y0, width, tos->n_planes, tos_planestride, tos->rowstride,\n                    \""bImageTOS\"", (byte *)tos_ptr, tos->deep);\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""cImageNOS\"", (byte *)nos_ptr, tos->deep);\n    if (maskbuf !=NULL && maskbuf->data != NULL) {\n        dump_raw_buffer(memory, maskbuf->rect.q.y - maskbuf->rect.p.y,\n                        maskbuf->rect.q.x - maskbuf->rect.p.x, maskbuf->n_planes,\n                        maskbuf->planestride, maskbuf->rowstride, \""dMask\"",\n                        maskbuf->data, maskbuf->deep);\n    }\n#endif\n\n    /* You might hope that has_mask iff maskbuf != NULL, but this is\n     * not the case. Certainly we can see cases where maskbuf != NULL\n     * and has_mask = 0. What's more, treating such cases as being\n     * has_mask = 0 causes diffs. */\n#ifdef TRACK_COMPOSE_GROUPS\n    {\n        int code = 0;\n\n        code += !!nos_knockout;\n        code += (!!nos_isolated)<<1;\n        code += (!!tos_isolated)<<2;\n        code += (!!tos->has_shape)<<3;\n        code += (!!tos_has_tag)<<4;\n        code += (!!additive)<<5;\n        code += (!!overprint)<<6;\n        code += (!!has_mask || maskbuf != NULL)<<7;\n        code += (!!has_matte)<<8;\n        code += (backdrop_ptr != NULL)<<9;\n        code += (num_spots != 0)<<10;\n        code += blend_mode<<11;\n\n        if (track_compose_groups == 0)\n        {\n            atexit(dump_track_compose_groups);\n            track_compose_groups = 1;\n        }\n        compose_groups[code]++;\n    }\n#endif\n\n    /* We have tested the files on the cluster to see what percentage of\n     * files/devices hit the different options. */\n    if (nos_knockout)\n        fn = &compose_group16_knockout; /* Small %ages, nothing more than 1.1% */\n    else if (blend_mode != 0)\n        fn = &compose_group16_nonknockout_blend; /* Small %ages, nothing more than 2% */\n    else if (tos->has_shape == 0 && tos_has_tag == 0 && nos_isolated == 0 && nos_alpha_g_ptr == NULL &&\n             nos_shape_offset == 0 && nos_tag_offset == 0 && backdrop_ptr == NULL && has_matte == 0 && num_spots == 0 &&\n             overprint == 0) {\n             /* Additive vs Subtractive makes no difference in normal blend mode with no spots */\n        if (tos_isolated) {\n            if (has_mask || maskbuf) {/* 7% */\n                /* AirPrint test case hits this */\n                if (maskbuf && maskbuf->rect.p.x <= x0 && maskbuf->rect.p.y <= y0 &&\n                    maskbuf->rect.q.x >= x1 && maskbuf->rect.q.y >= y1)\n                    fn = &compose_group16_nonknockout_nonblend_isolated_allmask_common;\n                else\n                    fn = &compose_group16_nonknockout_nonblend_isolated_mask_common;\n            } else /* 14% */\n                fn = &compose_group16_nonknockout_nonblend_isolated_nomask_common;\n        } else {\n            if (has_mask || maskbuf) /* 4% */\n                fn = &compose_group16_nonknockout_nonblend_nonisolated_mask_common;\n            else /* 15% */\n                fn = &compose_group16_nonknockout_nonblend_nonisolated_nomask_common;\n        }\n    } else\n        fn = compose_group16_nonknockout_noblend_general;\n\n    tos_planestride >>= 1;\n    tos_shape_offset >>= 1;\n    tos_alpha_g_offset >>= 1;\n    tos_tag_offset >>= 1;\n    nos_planestride >>= 1;\n    nos_shape_offset >>= 1;\n    nos_tag_offset >>= 1;\n    fn(tos_ptr, tos_isolated, tos_planestride, tos->rowstride>>1, alpha, shape, blend_mode, tos->has_shape,\n                  tos_shape_offset, tos_alpha_g_offset, tos_tag_offset, tos_has_tag,\n                  nos_ptr, nos_isolated, nos_planestride, nos->rowstride>>1, nos_alpha_g_ptr, nos_knockout,\n                  nos_shape_offset, nos_tag_offset,\n                  mask_row_ptr, has_mask, maskbuf, mask_bg_alpha, mask_tr_fn,\n                  backdrop_ptr,\n                  has_matte, n_chan, additive, num_spots, overprint, drawn_comps, x0, y0, x1, y1,\n                  pblend_procs, pdev);\n\n#if RAW_DUMP\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride<<1, nos->rowstride,\n                    \""eComposed\"", (byte *)composed_ptr, nos->deep);\n    global_index++;\n#endif\n}"", ""target"": 1}, {""func_name"": ""do_compose_group"", ""file_path"": ""base/gxblend.c"", ""func_code"": ""static void\ndo_compose_group(pdf14_buf *tos, pdf14_buf *nos, pdf14_buf *maskbuf,\n              int x0, int x1, int y0, int y1, int n_chan, bool additive,\n              const pdf14_nonseparable_blending_procs_t * pblend_procs,\n              bool has_matte, bool overprint, gx_color_index drawn_comps,\n              gs_memory_t *memory, gx_device *dev)\n{\n    int num_spots = tos->num_spots;\n    byte alpha = tos->alpha>>8;\n    byte shape = tos->shape>>8;\n    gs_blend_mode_t blend_mode = tos->blend_mode;\n    byte *tos_ptr = tos->data + x0 - tos->rect.p.x +\n        (y0 - tos->rect.p.y) * tos->rowstride;\n    byte *nos_ptr = nos->data + x0 - nos->rect.p.x +\n        (y0 - nos->rect.p.y) * nos->rowstride;\n    byte *mask_row_ptr = NULL;\n    int tos_planestride = tos->planestride;\n    int nos_planestride = nos->planestride;\n    byte mask_bg_alpha = 0; /* Quiet compiler. */\n    bool tos_isolated = tos->isolated;\n    bool nos_isolated = nos->isolated;\n    bool nos_knockout = nos->knockout;\n    byte *nos_alpha_g_ptr;\n    int tos_shape_offset = n_chan * tos_planestride;\n    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);\n    bool tos_has_tag = tos->has_tags;\n    int tos_tag_offset = tos_planestride * (tos->n_planes - 1);\n    int nos_shape_offset = n_chan * nos_planestride;\n    int nos_alpha_g_offset = nos_shape_offset + (nos->has_shape ? nos_planestride : 0);\n    int nos_tag_offset = nos_planestride * (nos->n_planes - 1);\n    byte *mask_tr_fn = NULL; /* Quiet compiler. */\n    bool is_ident = true;\n    bool has_mask = false;\n    byte *backdrop_ptr = NULL;\n    pdf14_device *pdev = (pdf14_device *)dev;\n\n\n#if RAW_DUMP\n    byte *composed_ptr = NULL;\n    int width = x1 - x0;\n#endif\n    art_pdf_compose_group_fn fn;\n\n    if ((tos->n_chan == 0) || (nos->n_chan == 0))\n        return;\n    rect_merge(nos->dirty, tos->dirty);\n    if (nos->has_tags)\n        if_debug7m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, tag = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, dev->graphics_type_tag & ~GS_DEVICE_ENCODES_TAGS, blend_mode);\n    else\n        if_debug6m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, blend_mode);\n    if (!nos->has_shape)\n        nos_shape_offset = 0;\n    if (!nos->has_tags)\n        nos_tag_offset = 0;\n    if (nos->has_alpha_g) {\n        nos_alpha_g_ptr = nos_ptr + nos_alpha_g_offset;\n    } else\n        nos_alpha_g_ptr = NULL;\n    if (nos->backdrop != NULL) {\n        backdrop_ptr = nos->backdrop + x0 - nos->rect.p.x +\n                       (y0 - nos->rect.p.y) * nos->rowstride;\n    }\n    if (blend_mode != BLEND_MODE_Compatible && blend_mode != BLEND_MODE_Normal)\n        overprint = false;\n\n    if (maskbuf != NULL) {\n        int tmp;\n\n        mask_tr_fn = maskbuf->transfer_fn;\n\n        is_ident = maskbuf->is_ident;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr = maskbuf->data + x0 - maskbuf->rect.p.x +\n                    (y0 - maskbuf->rect.p.y) * maskbuf->rowstride;\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha>>8;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = mask_tr_fn[mask_bg_alpha];\n        tmp = alpha * mask_bg_alpha + 0x80;\n        mask_bg_alpha = (tmp + (tmp >> 8)) >> 8;\n    }\n    n_chan--; /* Now the true number of colorants (i.e. not including alpha)*/\n#if RAW_DUMP\n    composed_ptr = nos_ptr;\n    dump_raw_buffer(memory, y1-y0, width, tos->n_planes, tos_planestride, tos->rowstride,\n                    \""bImageTOS\"", tos_ptr, tos->deep);\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""cImageNOS\"", nos_ptr, tos->deep);\n    if (maskbuf !=NULL && maskbuf->data != NULL) {\n        dump_raw_buffer(memory, maskbuf->rect.q.y - maskbuf->rect.p.y,\n                        maskbuf->rect.q.x - maskbuf->rect.p.x, maskbuf->n_planes,\n                        maskbuf->planestride, maskbuf->rowstride, \""dMask\"",\n                        maskbuf->data, maskbuf->deep);\n    }\n#endif\n\n    /* You might hope that has_mask iff maskbuf != NULL, but this is\n     * not the case. Certainly we can see cases where maskbuf != NULL\n     * and has_mask = 0. What's more, treating such cases as being\n     * has_mask = 0 causes diffs. */\n#ifdef TRACK_COMPOSE_GROUPS\n    {\n        int code = 0;\n\n        code += !!nos_knockout;\n        code += (!!nos_isolated)<<1;\n        code += (!!tos_isolated)<<2;\n        code += (!!tos->has_shape)<<3;\n        code += (!!tos_has_tag)<<4;\n        code += (!!additive)<<5;\n        code += (!!overprint)<<6;\n        code += (!!has_mask || maskbuf != NULL)<<7;\n        code += (!!has_matte)<<8;\n        code += (backdrop_ptr != NULL)<<9;\n        code += (num_spots != 0)<<10;\n        code += blend_mode<<11;\n\n        if (track_compose_groups == 0)\n        {\n            atexit(dump_track_compose_groups);\n            track_compose_groups = 1;\n        }\n        compose_groups[code]++;\n    }\n#endif\n\n    /* We have tested the files on the cluster to see what percentage of\n     * files/devices hit the different options. */\n    if (nos_knockout)\n        fn = &compose_group_knockout; /* Small %ages, nothing more than 1.1% */\n    else if (blend_mode != 0)\n        fn = &compose_group_nonknockout_blend; /* Small %ages, nothing more than 2% */\n    else if (tos->has_shape == 0 && tos_has_tag == 0 && nos_isolated == 0 && nos_alpha_g_ptr == NULL &&\n             nos_shape_offset == 0 && nos_tag_offset == 0 && backdrop_ptr == NULL && has_matte == 0 && num_spots == 0 &&\n             overprint == 0) {\n             /* Additive vs Subtractive makes no difference in normal blend mode with no spots */\n        if (tos_isolated) {\n            if (has_mask || maskbuf) {/* 7% */\n                /* AirPrint test case hits this */\n                if (maskbuf && maskbuf->rect.p.x <= x0 && maskbuf->rect.p.y <= y0 &&\n                    maskbuf->rect.q.x >= x1 && maskbuf->rect.q.y >= y1) {\n                    /* AVX and SSE accelerations only valid if maskbuf transfer\n                       function is identity and we have no matte color replacement */\n                    if (is_ident && !has_matte) {\n                        fn = compose_group_nonknockout_nonblend_isolated_allmask_common;\n#ifdef WITH_CAL\n\t\t\tfn = (art_pdf_compose_group_fn)cal_get_compose_group(\n\t\t\t\t\t memory->gs_lib_ctx->core->cal_ctx,\n\t\t\t\t\t (cal_composer_proc_t *)fn,\n\t\t\t\t\t tos->n_chan-1);\n#endif\n                    } else {\n                        fn = compose_group_nonknockout_nonblend_isolated_allmask_common;\n                    }\n                } else\n                    fn = &compose_group_nonknockout_nonblend_isolated_mask_common;\n            } else /* 14% */\n                fn = &compose_group_nonknockout_nonblend_isolated_nomask_common;\n        } else {\n            if (has_mask || maskbuf) /* 4% */\n                fn = &compose_group_nonknockout_nonblend_nonisolated_mask_common;\n            else /* 15% */\n                fn = &compose_group_nonknockout_nonblend_nonisolated_nomask_common;\n        }\n    } else\n        fn = compose_group_nonknockout_noblend_general;\n\n    fn(tos_ptr, tos_isolated, tos_planestride, tos->rowstride, alpha, shape,\n        blend_mode, tos->has_shape, tos_shape_offset, tos_alpha_g_offset,\n        tos_tag_offset, tos_has_tag, nos_ptr, nos_isolated, nos_planestride,\n        nos->rowstride, nos_alpha_g_ptr, nos_knockout, nos_shape_offset,\n        nos_tag_offset, mask_row_ptr, has_mask, maskbuf, mask_bg_alpha,\n        mask_tr_fn, backdrop_ptr, has_matte, n_chan, additive, num_spots,\n        overprint, drawn_comps, x0, y0, x1, y1, pblend_procs, pdev);\n\n#if RAW_DUMP\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""eComposed\"", composed_ptr, nos->deep);\n    global_index++;\n#endif\n}"", ""target"": 0}]","[{""func_name"": ""do_compose_group16"", ""file_path"": ""base/gxblend.c"", ""func_code"": ""static void\ndo_compose_group16(pdf14_buf *tos, pdf14_buf *nos, pdf14_buf *maskbuf,\n                   int x0, int x1, int y0, int y1, int n_chan, bool additive,\n                   const pdf14_nonseparable_blending_procs_t * pblend_procs,\n                   bool has_matte, bool overprint, gx_color_index drawn_comps,\n                   gs_memory_t *memory, gx_device *dev)\n{\n    int num_spots = tos->num_spots;\n    uint16_t alpha = tos->alpha;\n    uint16_t shape = tos->shape;\n    gs_blend_mode_t blend_mode = tos->blend_mode;\n    uint16_t *tos_ptr =\n        (uint16_t *)(void *)(tos->data + (x0 - tos->rect.p.x)*2 +\n                             (y0 - tos->rect.p.y) * tos->rowstride);\n    uint16_t *nos_ptr =\n        (uint16_t *)(void *)(nos->data + (x0 - nos->rect.p.x)*2 +\n                             (y0 - nos->rect.p.y) * nos->rowstride);\n    uint16_t *mask_row_ptr = NULL;\n    int tos_planestride = tos->planestride;\n    int nos_planestride = nos->planestride;\n    uint16_t mask_bg_alpha = 0; /* Quiet compiler. */\n    bool tos_isolated = tos->isolated;\n    bool nos_isolated = nos->isolated;\n    bool nos_knockout = nos->knockout;\n    uint16_t *nos_alpha_g_ptr;\n    int tos_shape_offset = n_chan * tos_planestride;\n    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);\n    bool tos_has_tag = tos->has_tags;\n    int tos_tag_offset = tos_planestride * (tos->n_planes - 1);\n    int nos_shape_offset = n_chan * nos_planestride;\n    int nos_alpha_g_offset = nos_shape_offset + (nos->has_shape ? nos_planestride : 0);\n    int nos_tag_offset = nos_planestride * (nos->n_planes - 1);\n    const uint16_t *mask_tr_fn = NULL; /* Quiet compiler. */\n    bool has_mask = false;\n    uint16_t *backdrop_ptr = NULL;\n    pdf14_device *pdev = (pdf14_device *)dev;\n#if RAW_DUMP\n    uint16_t *composed_ptr = NULL;\n    int width = x1 - x0;\n#endif\n    art_pdf_compose_group16_fn fn;\n\n    if ((tos->n_chan == 0) || (nos->n_chan == 0))\n        return;\n    rect_merge(nos->dirty, tos->dirty);\n    if (nos->has_tags)\n        if_debug7m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, tag = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, dev->graphics_type_tag & ~GS_DEVICE_ENCODES_TAGS, blend_mode);\n    else\n        if_debug6m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, blend_mode);\n    if (!nos->has_shape)\n        nos_shape_offset = 0;\n    if (!nos->has_tags)\n        nos_tag_offset = 0;\n    if (nos->has_alpha_g) {\n        nos_alpha_g_ptr = nos_ptr + (nos_alpha_g_offset>>1);\n    } else\n        nos_alpha_g_ptr = NULL;\n    if (nos->backdrop != NULL) {\n        backdrop_ptr =\n            (uint16_t *)(void *)(nos->backdrop + (x0 - nos->rect.p.x)*2 +\n                                 (y0 - nos->rect.p.y) * nos->rowstride);\n    }\n    if (blend_mode != BLEND_MODE_Compatible && blend_mode != BLEND_MODE_Normal)\n        overprint = false;\n\n    if (maskbuf != NULL) {\n        unsigned int tmp;\n        mask_tr_fn = (uint16_t *)maskbuf->transfer_fn;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr =\n                (uint16_t *)(void *)(maskbuf->data + (x0 - maskbuf->rect.p.x)*2 +\n                                     (y0 - maskbuf->rect.p.y) * maskbuf->rowstride);\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = interp16(mask_tr_fn, mask_bg_alpha);\n        tmp = alpha * mask_bg_alpha + 0x8000;\n        mask_bg_alpha = (tmp + (tmp >> 8)) >> 8;\n    }\n    n_chan--; /* Now the true number of colorants (i.e. not including alpha)*/\n#if RAW_DUMP\n    composed_ptr = nos_ptr;\n    dump_raw_buffer(memory, y1-y0, width, tos->n_planes, tos_planestride, tos->rowstride,\n                    \""bImageTOS\"", (byte *)tos_ptr, tos->deep);\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""cImageNOS\"", (byte *)nos_ptr, tos->deep);\n    if (maskbuf !=NULL && maskbuf->data != NULL) {\n        dump_raw_buffer(memory, maskbuf->rect.q.y - maskbuf->rect.p.y,\n                        maskbuf->rect.q.x - maskbuf->rect.p.x, maskbuf->n_planes,\n                        maskbuf->planestride, maskbuf->rowstride, \""dMask\"",\n                        maskbuf->data, maskbuf->deep);\n    }\n#endif\n\n    /* You might hope that has_mask iff maskbuf != NULL, but this is\n     * not the case. Certainly we can see cases where maskbuf != NULL\n     * and has_mask = 0. What's more, treating such cases as being\n     * has_mask = 0 causes diffs. */\n#ifdef TRACK_COMPOSE_GROUPS\n    {\n        int code = 0;\n\n        code += !!nos_knockout;\n        code += (!!nos_isolated)<<1;\n        code += (!!tos_isolated)<<2;\n        code += (!!tos->has_shape)<<3;\n        code += (!!tos_has_tag)<<4;\n        code += (!!additive)<<5;\n        code += (!!overprint)<<6;\n        code += (!!has_mask || maskbuf != NULL)<<7;\n        code += (!!has_matte)<<8;\n        code += (backdrop_ptr != NULL)<<9;\n        code += (num_spots != 0)<<10;\n        code += blend_mode<<11;\n\n        if (track_compose_groups == 0)\n        {\n            atexit(dump_track_compose_groups);\n            track_compose_groups = 1;\n        }\n        compose_groups[code]++;\n    }\n#endif\n\n    /* We have tested the files on the cluster to see what percentage of\n     * files/devices hit the different options. */\n    if (nos_knockout)\n        fn = &compose_group16_knockout; /* Small %ages, nothing more than 1.1% */\n    else if (blend_mode != 0)\n        fn = &compose_group16_nonknockout_blend; /* Small %ages, nothing more than 2% */\n    else if (tos->has_shape == 0 && tos_has_tag == 0 && nos_isolated == 0 && nos_alpha_g_ptr == NULL &&\n             nos_shape_offset == 0 && nos_tag_offset == 0 && backdrop_ptr == NULL && has_matte == 0 && num_spots == 0 &&\n             overprint == 0) {\n             /* Additive vs Subtractive makes no difference in normal blend mode with no spots */\n        if (tos_isolated) {\n            if (has_mask && maskbuf) {/* 7% */\n                /* AirPrint test case hits this */\n                if (maskbuf && maskbuf->rect.p.x <= x0 && maskbuf->rect.p.y <= y0 &&\n                    maskbuf->rect.q.x >= x1 && maskbuf->rect.q.y >= y1)\n                    fn = &compose_group16_nonknockout_nonblend_isolated_allmask_common;\n                else\n                    fn = &compose_group16_nonknockout_nonblend_isolated_mask_common;\n            } else /* 14% */\n                fn = &compose_group16_nonknockout_nonblend_isolated_nomask_common;\n        } else {\n            if (has_mask || maskbuf) /* 4% */\n                fn = &compose_group16_nonknockout_nonblend_nonisolated_mask_common;\n            else /* 15% */\n                fn = &compose_group16_nonknockout_nonblend_nonisolated_nomask_common;\n        }\n    } else\n        fn = compose_group16_nonknockout_noblend_general;\n\n    tos_planestride >>= 1;\n    tos_shape_offset >>= 1;\n    tos_alpha_g_offset >>= 1;\n    tos_tag_offset >>= 1;\n    nos_planestride >>= 1;\n    nos_shape_offset >>= 1;\n    nos_tag_offset >>= 1;\n    fn(tos_ptr, tos_isolated, tos_planestride, tos->rowstride>>1, alpha, shape, blend_mode, tos->has_shape,\n                  tos_shape_offset, tos_alpha_g_offset, tos_tag_offset, tos_has_tag,\n                  nos_ptr, nos_isolated, nos_planestride, nos->rowstride>>1, nos_alpha_g_ptr, nos_knockout,\n                  nos_shape_offset, nos_tag_offset,\n                  mask_row_ptr, has_mask, maskbuf, mask_bg_alpha, mask_tr_fn,\n                  backdrop_ptr,\n                  has_matte, n_chan, additive, num_spots, overprint, drawn_comps, x0, y0, x1, y1,\n                  pblend_procs, pdev);\n\n#if RAW_DUMP\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride<<1, nos->rowstride,\n                    \""eComposed\"", (byte *)composed_ptr, nos->deep);\n    global_index++;\n#endif\n}""}, {""func_name"": ""do_compose_group"", ""file_path"": ""base/gxblend.c"", ""func_code"": ""static void\ndo_compose_group(pdf14_buf *tos, pdf14_buf *nos, pdf14_buf *maskbuf,\n              int x0, int x1, int y0, int y1, int n_chan, bool additive,\n              const pdf14_nonseparable_blending_procs_t * pblend_procs,\n              bool has_matte, bool overprint, gx_color_index drawn_comps,\n              gs_memory_t *memory, gx_device *dev)\n{\n    int num_spots = tos->num_spots;\n    byte alpha = tos->alpha>>8;\n    byte shape = tos->shape>>8;\n    gs_blend_mode_t blend_mode = tos->blend_mode;\n    byte *tos_ptr = tos->data + x0 - tos->rect.p.x +\n        (y0 - tos->rect.p.y) * tos->rowstride;\n    byte *nos_ptr = nos->data + x0 - nos->rect.p.x +\n        (y0 - nos->rect.p.y) * nos->rowstride;\n    byte *mask_row_ptr = NULL;\n    int tos_planestride = tos->planestride;\n    int nos_planestride = nos->planestride;\n    byte mask_bg_alpha = 0; /* Quiet compiler. */\n    bool tos_isolated = tos->isolated;\n    bool nos_isolated = nos->isolated;\n    bool nos_knockout = nos->knockout;\n    byte *nos_alpha_g_ptr;\n    int tos_shape_offset = n_chan * tos_planestride;\n    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);\n    bool tos_has_tag = tos->has_tags;\n    int tos_tag_offset = tos_planestride * (tos->n_planes - 1);\n    int nos_shape_offset = n_chan * nos_planestride;\n    int nos_alpha_g_offset = nos_shape_offset + (nos->has_shape ? nos_planestride : 0);\n    int nos_tag_offset = nos_planestride * (nos->n_planes - 1);\n    byte *mask_tr_fn = NULL; /* Quiet compiler. */\n    bool is_ident = true;\n    bool has_mask = false;\n    byte *backdrop_ptr = NULL;\n    pdf14_device *pdev = (pdf14_device *)dev;\n\n\n#if RAW_DUMP\n    byte *composed_ptr = NULL;\n    int width = x1 - x0;\n#endif\n    art_pdf_compose_group_fn fn;\n\n    if ((tos->n_chan == 0) || (nos->n_chan == 0))\n        return;\n    rect_merge(nos->dirty, tos->dirty);\n    if (nos->has_tags)\n        if_debug7m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, tag = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, dev->graphics_type_tag & ~GS_DEVICE_ENCODES_TAGS, blend_mode);\n    else\n        if_debug6m('v', memory,\n                   \""pdf14_pop_transparency_group y0 = %d, y1 = %d, w = %d, alpha = %d, shape = %d, bm = %d\\n\"",\n                   y0, y1, x1 - x0, alpha, shape, blend_mode);\n    if (!nos->has_shape)\n        nos_shape_offset = 0;\n    if (!nos->has_tags)\n        nos_tag_offset = 0;\n    if (nos->has_alpha_g) {\n        nos_alpha_g_ptr = nos_ptr + nos_alpha_g_offset;\n    } else\n        nos_alpha_g_ptr = NULL;\n    if (nos->backdrop != NULL) {\n        backdrop_ptr = nos->backdrop + x0 - nos->rect.p.x +\n                       (y0 - nos->rect.p.y) * nos->rowstride;\n    }\n    if (blend_mode != BLEND_MODE_Compatible && blend_mode != BLEND_MODE_Normal)\n        overprint = false;\n\n    if (maskbuf != NULL) {\n        int tmp;\n\n        mask_tr_fn = maskbuf->transfer_fn;\n\n        is_ident = maskbuf->is_ident;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr = maskbuf->data + x0 - maskbuf->rect.p.x +\n                    (y0 - maskbuf->rect.p.y) * maskbuf->rowstride;\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha>>8;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = mask_tr_fn[mask_bg_alpha];\n        tmp = alpha * mask_bg_alpha + 0x80;\n        mask_bg_alpha = (tmp + (tmp >> 8)) >> 8;\n    }\n    n_chan--; /* Now the true number of colorants (i.e. not including alpha)*/\n#if RAW_DUMP\n    composed_ptr = nos_ptr;\n    dump_raw_buffer(memory, y1-y0, width, tos->n_planes, tos_planestride, tos->rowstride,\n                    \""bImageTOS\"", tos_ptr, tos->deep);\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""cImageNOS\"", nos_ptr, tos->deep);\n    if (maskbuf !=NULL && maskbuf->data != NULL) {\n        dump_raw_buffer(memory, maskbuf->rect.q.y - maskbuf->rect.p.y,\n                        maskbuf->rect.q.x - maskbuf->rect.p.x, maskbuf->n_planes,\n                        maskbuf->planestride, maskbuf->rowstride, \""dMask\"",\n                        maskbuf->data, maskbuf->deep);\n    }\n#endif\n\n    /* You might hope that has_mask iff maskbuf != NULL, but this is\n     * not the case. Certainly we can see cases where maskbuf != NULL\n     * and has_mask = 0. What's more, treating such cases as being\n     * has_mask = 0 causes diffs. */\n#ifdef TRACK_COMPOSE_GROUPS\n    {\n        int code = 0;\n\n        code += !!nos_knockout;\n        code += (!!nos_isolated)<<1;\n        code += (!!tos_isolated)<<2;\n        code += (!!tos->has_shape)<<3;\n        code += (!!tos_has_tag)<<4;\n        code += (!!additive)<<5;\n        code += (!!overprint)<<6;\n        code += (!!has_mask || maskbuf != NULL)<<7;\n        code += (!!has_matte)<<8;\n        code += (backdrop_ptr != NULL)<<9;\n        code += (num_spots != 0)<<10;\n        code += blend_mode<<11;\n\n        if (track_compose_groups == 0)\n        {\n            atexit(dump_track_compose_groups);\n            track_compose_groups = 1;\n        }\n        compose_groups[code]++;\n    }\n#endif\n\n    /* We have tested the files on the cluster to see what percentage of\n     * files/devices hit the different options. */\n    if (nos_knockout)\n        fn = &compose_group_knockout; /* Small %ages, nothing more than 1.1% */\n    else if (blend_mode != 0)\n        fn = &compose_group_nonknockout_blend; /* Small %ages, nothing more than 2% */\n    else if (tos->has_shape == 0 && tos_has_tag == 0 && nos_isolated == 0 && nos_alpha_g_ptr == NULL &&\n             nos_shape_offset == 0 && nos_tag_offset == 0 && backdrop_ptr == NULL && has_matte == 0 && num_spots == 0 &&\n             overprint == 0) {\n             /* Additive vs Subtractive makes no difference in normal blend mode with no spots */\n        if (tos_isolated) {\n            if (has_mask && maskbuf) {/* 7% */\n                /* AirPrint test case hits this */\n                if (maskbuf && maskbuf->rect.p.x <= x0 && maskbuf->rect.p.y <= y0 &&\n                    maskbuf->rect.q.x >= x1 && maskbuf->rect.q.y >= y1) {\n                    /* AVX and SSE accelerations only valid if maskbuf transfer\n                       function is identity and we have no matte color replacement */\n                    if (is_ident && !has_matte) {\n                        fn = compose_group_nonknockout_nonblend_isolated_allmask_common;\n#ifdef WITH_CAL\n\t\t\tfn = (art_pdf_compose_group_fn)cal_get_compose_group(\n\t\t\t\t\t memory->gs_lib_ctx->core->cal_ctx,\n\t\t\t\t\t (cal_composer_proc_t *)fn,\n\t\t\t\t\t tos->n_chan-1);\n#endif\n                    } else {\n                        fn = compose_group_nonknockout_nonblend_isolated_allmask_common;\n                    }\n                } else\n                    fn = &compose_group_nonknockout_nonblend_isolated_mask_common;\n            } else /* 14% */\n                fn = &compose_group_nonknockout_nonblend_isolated_nomask_common;\n        } else {\n            if (has_mask || maskbuf) /* 4% */\n                fn = &compose_group_nonknockout_nonblend_nonisolated_mask_common;\n            else /* 15% */\n                fn = &compose_group_nonknockout_nonblend_nonisolated_nomask_common;\n        }\n    } else\n        fn = compose_group_nonknockout_noblend_general;\n\n    fn(tos_ptr, tos_isolated, tos_planestride, tos->rowstride, alpha, shape,\n        blend_mode, tos->has_shape, tos_shape_offset, tos_alpha_g_offset,\n        tos_tag_offset, tos_has_tag, nos_ptr, nos_isolated, nos_planestride,\n        nos->rowstride, nos_alpha_g_ptr, nos_knockout, nos_shape_offset,\n        nos_tag_offset, mask_row_ptr, has_mask, maskbuf, mask_bg_alpha,\n        mask_tr_fn, backdrop_ptr, has_matte, n_chan, additive, num_spots,\n        overprint, drawn_comps, x0, y0, x1, y1, pblend_procs, pdev);\n\n#if RAW_DUMP\n    dump_raw_buffer(memory, y1-y0, width, nos->n_planes, nos_planestride, nos->rowstride,\n                    \""eComposed\"", composed_ptr, nos->deep);\n    global_index++;\n#endif\n}""}]","{""value"": 2, ""code"": 3}","[{""source"": ""value_info(file:gxblend.c, value:has_mask)"", ""result"": {""value_trace"": [{""full_code"": ""has_mask = false"", ""line"": 3363, ""func_name"": ""do_compose_group""}, {""full_code"": ""has_mask = true"", ""line"": 3410, ""func_name"": ""do_compose_group""}, {""full_code"": ""has_mask = false"", ""line"": 4136, ""func_name"": ""do_compose_group16""}, {""full_code"": ""has_mask = true"", ""line"": 4180, ""func_name"": ""do_compose_group16""}, {""full_code"": ""has_mask = false"", ""line"": 4341, ""func_name"": ""do_compose_alphaless_group""}], ""struct_var"": ""has_mask"", ""struct_type"": ""bool"", ""struct_definition"": ""typedef int bool;\n\ntypedef int bool;\n\ntypedef unsigned char bool;\n\ntypedef int bool;\n\ntypedef int bool;""}}, {""source"": ""value_info(file:gxblend.c, value:maskbuf)"", ""result"": {""value_trace"": [{""full_code"": ""maskbuf = mask_stack->rc_mask->mask_buf"", ""line"": 974, ""func_name"": ""template_transform_color_buffer""}, {""full_code"": ""maskbuf = NULL"", ""line"": 1506, ""func_name"": ""pdf14_pop_transparency_group""}, {""full_code"": ""maskbuf = mask_stack->rc_mask->mask_buf"", ""line"": 1508, ""func_name"": ""pdf14_pop_transparency_group""}], ""struct_var"": ""maskbuf"", ""struct_type"": ""pdf14_buf*"", ""struct_definition"": ""typedef struct pdf14_buf_s pdf14_buf;""}}, {""source"": ""code_info(file:gxblend.c, lines:3400-3420)"", ""result"": ""    if (maskbuf != NULL) {\n        int tmp;\n\n        mask_tr_fn = maskbuf->transfer_fn;\n\n        is_ident = maskbuf->is_ident;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr = maskbuf->data + x0 - maskbuf->rect.p.x +\n                    (y0 - maskbuf->rect.p.y) * maskbuf->rowstride;\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha>>8;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = mask_tr_fn[mask_bg_alpha];\n        tmp = alpha * mask_bg_alpha + 0x80;\n""}, {""source"": ""code_info(file:gxblend.c, lines:4170-4190)"", ""result"": ""        overprint = false;\n\n    if (maskbuf != NULL) {\n        unsigned int tmp;\n        mask_tr_fn = (uint16_t *)maskbuf->transfer_fn;\n        /* Make sure we are in the mask buffer */\n        if (maskbuf->data != NULL) {\n            mask_row_ptr =\n                (uint16_t *)(void *)(maskbuf->data + (x0 - maskbuf->rect.p.x)*2 +\n                                     (y0 - maskbuf->rect.p.y) * maskbuf->rowstride);\n            has_mask = true;\n        }\n        /* We may have a case, where we are outside the maskbuf rect. */\n        /* We would have avoided creating the maskbuf->data */\n        /* In that case, we should use the background alpha value */\n        /* See discussion on the BC entry in the PDF spec.   */\n        mask_bg_alpha = maskbuf->alpha;\n        /* Adjust alpha by the mask background alpha.   This is only used\n           if we are outside the soft mask rect during the filling operation */\n        mask_bg_alpha = interp16(mask_tr_fn, mask_bg_alpha);\n        tmp = alpha * mask_bg_alpha + 0x8000;\n""}, {""source"": ""code_info(file:gxblend.c, lines:4330-4350)"", ""result"": ""    bool nos_isolated = nos->isolated;\n    bool nos_knockout = nos->knockout;\n    byte *nos_alpha_g_ptr;\n    int tos_shape_offset = n_chan * tos_planestride;\n    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);\n    bool tos_has_tag = tos->has_tags;\n    int tos_tag_offset = tos_planestride * (tos->n_planes - 1);\n    int nos_shape_offset = n_chan * nos_planestride;\n    int nos_alpha_g_offset = nos_shape_offset + (nos->has_shape ? nos_planestride : 0);\n    int nos_tag_offset = nos_planestride * (nos->n_planes - 1);\n    const byte *mask_tr_fn = NULL; /* Quiet compiler. */\n    bool has_mask = false;\n    byte *backdrop_ptr = NULL;\n#if RAW_DUMP\n    byte *composed_ptr = NULL;\n    int width = x1 - x0;\n#endif\n    art_pdf_compose_group_fn fn;\n\n    if ((tos->n_chan == 0) || (nos->n_chan == 0))\n        return;\n""}]","In `gxblend.c:3477`, the original condition `has_mask || maskbuf` allowed execution if either was true. `has_mask` is set to true in `do_compose_group` (line 3410) and `do_compose_group16` (line 4180) *only if* `maskbuf` is non-null and valid (i.e., `maskbuf != NULL && maskbuf->data != NULL`). However, `maskbuf` can later be set to NULL (e.g., via `pdf14_pop_transparency_group` lines 1506/1508), leaving `has_mask` still true. The code at line 3477 then proceeds to dereference the NULL `maskbuf`, causing a segv. The patch fixes this by requiring both `has_mask && maskbuf`, ensuring `maskbuf` is valid at use time.",0.95,./github/other_context/CVE-2020-16293
74,CVE-2020-8448,CWE-476,c_cpp,"In OSSEC-HIDS 2.7 through 3.5.0, the server component responsible for log analysis (ossec-analysisd) is vulnerable to a denial of service (NULL pointer dereference) via crafted messages written directly to the analysisd UNIX domain socket by a local user.",https://github.com/ossec/ossec-hids/commit/9b8b14c88188cdc66ab25f92a26918d0cb8a7760,"analysisd: fix possible null ptr deref in OS_CleanMSG.\n\nIf the `msg` provided to `OS_CleanMSG` has a `(` after the ID, but\ndoesn't not contain a `->` or `:` it should be rejected with\na `FORMAT_ERROR`.\n\nPrev. to this commit nesting `strstr` for `->` as the first argument to\n`strchr` for `:` results in a null ptr deref when the message is\nmalformed.",1,"[{""func_name"": ""OS_CleanMSG"", ""file_path"": ""src/analysisd/cleanevent.c"", ""func_code"": ""int OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n        merror(FORMAT_ERROR, ARGV0);\n        return (-1);\n    }\n\n    /* Is this from an agent? */\n    if ( *msg == '(' )\n    {   /* look past '->' for the first ':' */\n        pieces = strchr(strstr(msg, \""->\""), ':');\n        if(!pieces)\n        {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n    }\n\n    *pieces = '\\0';\n    pieces++;\n\n    os_strdup(msg, lf->location);\n\n    /* Get the log length */\n    loglen = strlen(pieces) + 1;\n\n    /* Assign the values in the structure (lf->full_log) */\n    os_malloc((2 * loglen) + 1, lf->full_log);\n\n    /* Set the whole message at full_log */\n    strncpy(lf->full_log, pieces, loglen);\n\n    /* Log is the one used for parsing in the decoders and rules */\n    lf->log = lf->full_log + loglen;\n    strncpy(lf->log, pieces, loglen);\n\n    /* check if month contains an umlaut and repair\n     * umlauts are non-ASCII and use 2 slots in the char array\n     * repair to only one slot so we can detect the correct date format in the next step\n     * ex: M\u00e4r 02 17:30:52\n     */\n    if (pieces[1] == (char) 195) {\n        if (pieces[2] == (char) 164) {\n            pieces[0] = '\\0';\n            pieces[1] = 'M';\n            pieces[2] = 'a';\n            pieces++;\n        }\n    }\n\n    /* Check for the syslog date format\n     * ( ex: Dec 29 10:00:01\n     *   or  2015-04-16 21:51:02,805 for proftpd 1.3.5\n     *   or  2007-06-14T15:48:55-04:00 for syslog-ng isodate\n     *   or  2007-06-14T15:48:55.3352-04:00 for syslog-ng isodate with up to 6 optional fraction of a second\n     *   or  2009-05-22T09:36:46.214994-07:00 for rsyslog\n     *   or  2015 Dec 29 10:00:01 )\n     */\n    if (\n        (   /* ex: Dec 29 10:00:01 */\n            (loglen > 17) &&\n            (pieces[3] == ' ') &&\n            (pieces[6] == ' ') &&\n            (pieces[9] == ':') &&\n            (pieces[12] == ':') &&\n            (pieces[15] == ' ') && (lf->log += 16)\n        )\n        ||\n        (   /* ex: 2015-04-16 21:51:02,805 */\n            (loglen > 24) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == ' ') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (pieces[19] == ',') &&\n            (lf->log += 23)\n        )\n        ||\n        (\n            (loglen > 33) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == 'T') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (   /* ex: 2007-06-14T15:48:55-04:00 */\n                (\n                    (pieces[22] == ':') &&\n                    (pieces[25] == ' ') && (lf->log += 26)\n                )\n                ||\n                /* ex: 2007-06-14T15:48:55.3-04:00 or 2009-05-22T09:36:46,214994-07:00 */\n                (\n                    (\n                        (pieces[19] == '.') || (pieces[19] == ',')\n                    )\n                    &&\n                    (\n                        ( (pieces[24] == ':') && (lf->log += 27) ) ||\n                        ( (pieces[25] == ':') && (lf->log += 28) ) ||\n                        ( (pieces[26] == ':') && (lf->log += 29) ) ||\n                        ( (pieces[27] == ':') && (lf->log += 30) ) ||\n                        ( (pieces[28] == ':') && (lf->log += 31) ) ||\n                        ( (pieces[29] == ':') && (lf->log += 32) )\n                    )\n                )\n            )\n        )\n        ||\n        (   /* ex: 2015 Dec 29 10:00:01 */\n            (loglen > 21) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ' ') &&\n            (pieces[8] == ' ') &&\n            (pieces[11] == ' ') &&\n            (pieces[14] == ':') &&\n            (pieces[17] == ':') &&\n            (pieces[20] == ' ') && (lf->log += 21)\n        )\n        ||\n        (\n            /* ex: 2019:11:06-00:08:03 */\n            (loglen > 20) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ':') &&\n            (pieces[7] == ':') &&\n            (pieces[10] == '-') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') && (lf->log += 20)\n        )\n    ) {\n        /* Check for an extra space in here */\n        if (*lf->log == ' ') {\n            lf->log++;\n        }\n\n\n        /* Hostname */\n        pieces = lf->hostname = lf->log;\n\n\n        /* Check for a valid hostname */\n        while (isValidChar(*pieces) == 1) {\n            pieces++;\n        }\n\n        /* Check if it is a syslog without hostname (common on Solaris) */\n        if (*pieces == ':' && pieces[1] == ' ') {\n            /* Getting solaris 8/9 messages without hostname.\n             * In these cases, the process_name should be there.\n             * http://www.ossec.net/wiki/index.php/Log_Samples_Solaris\n             */\n            lf->program_name = lf->hostname;\n            lf->hostname = NULL;\n\n            /* End the program name string */\n            *pieces = '\\0';\n\n            pieces += 2;\n            lf->log = pieces;\n        }\n\n        /* Extract the hostname */\n        else if (*pieces != ' ') {\n            /* Invalid hostname */\n            lf->hostname = NULL;\n            pieces = NULL;\n        } else {\n            /* End the hostname string */\n            *pieces = '\\0';\n\n            /* Move pieces to the beginning of the log message */\n            pieces++;\n            lf->log = pieces;\n\n            /* Get program_name */\n            lf->program_name = pieces;\n\n            /* Extract program_name */\n            /* Valid names:\n             * p_name:\n             * p_name[pid]:\n             * p_name[pid]: [ID xx facility.severity]\n             * auth|security:info p_name:\n             */\n            while (isValidChar(*pieces) == 1) {\n                pieces++;\n            }\n\n            /* Check for the first format: p_name: */\n            if ((*pieces == ':') && (pieces[1] == ' ')) {\n                *pieces = '\\0';\n                pieces += 2;\n            }\n\n            /* Check for the second format: p_name[pid]: */\n            else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                *pieces = '\\0';\n                pieces += 2;\n                while (isdigit((int)*pieces)) {\n                    pieces++;\n                }\n\n                if ((*pieces == ']') && (pieces[1] == ':') && (pieces[2] == ' ')) {\n                    pieces += 3;\n                }\n                /* Some systems are not terminating the program name with\n                 * a ':'. Working around this in here...\n                 */\n                else if ((*pieces == ']') && (pieces[1] == ' ')) {\n                    pieces += 2;\n                } else {\n                    /* Fix for some weird log formats */\n                    pieces--;\n                    while (isdigit((int)*pieces)) {\n                        pieces--;\n                    }\n\n                    if (*pieces == '\\0') {\n                        *pieces = '[';\n                    }\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            }\n            /* AIX syslog */\n            else if ((*pieces == '|') && islower((int)pieces[1])) {\n                pieces += 2;\n\n                /* Remove facility */\n                while (isalnum((int)*pieces)) {\n                    pieces++;\n                }\n\n                if (*pieces == ':') {\n                    /* Remove severity */\n                    pieces++;\n                    while (isalnum((int)*pieces)) {\n                        pieces++;\n                    }\n\n                    if (*pieces == ' ') {\n                        pieces++;\n                        lf->program_name = pieces;\n\n\n                        /* Get program name again */\n                        while (isValidChar(*pieces) == 1) {\n                            pieces++;\n                        }\n\n                        /* Check for the first format: p_name: */\n                        if ((*pieces == ':') && (pieces[1] == ' ')) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                        }\n\n                        /* Check for the second format: p_name[pid]: */\n                        else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                            while (isdigit((int)*pieces)) {\n                                pieces++;\n                            }\n\n                            if ((*pieces == ']') && (pieces[1] == ':') &&\n                                    (pieces[2] == ' ')) {\n                                pieces += 3;\n                            } else {\n                                pieces = NULL;\n                            }\n                        }\n                    } else {\n                        pieces = NULL;\n                        lf->program_name = NULL;\n                    }\n                }\n                /* Invalid AIX */\n                else {\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            } else {\n                pieces = NULL;\n                lf->program_name = NULL;\n            }\n        }\n\n        /* Remove [ID xx facility.severity] */\n        if (pieces) {\n            /* Set log after program name */\n            lf->log = pieces;\n\n            if ((pieces[0] == '[') &&\n                    (pieces[1] == 'I') &&\n                    (pieces[2] == 'D') &&\n                    (pieces[3] == ' ')) {\n                pieces += 4;\n\n                /* Going after the ] */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    pieces += 2;\n                    lf->log = pieces;\n                }\n            }\n        }\n\n        /* Get program name size */\n        if (lf->program_name) {\n            lf->p_name_size = strlen(lf->program_name);\n        }\n    }\n\n    /* xferlog date format\n     * Mon Apr 17 18:27:14 2006 1 64.160.42.130\n     */\n    else if ((loglen > 28) &&\n             (pieces[3] == ' ') &&\n             (pieces[7] == ' ') &&\n             (pieces[10] == ' ') &&\n             (pieces[13] == ':') &&\n             (pieces[16] == ':') &&\n             (pieces[19] == ' ') &&\n             (pieces[24] == ' ') &&\n             (pieces[26] == ' ')) {\n        /* Move log to the beginning of the message */\n        lf->log += 24;\n    }\n\n    /* Check for snort date format\n     * ex: 01/28-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 24) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '-') &&\n              (pieces[8] == ':') &&\n              (pieces[11] == ':') &&\n              (pieces[14] == '.') &&\n              (pieces[21] == ' ') ) {\n        lf->log += 23;\n    }\n\n    /* Check for suricata (new) date format\n     * ex: 01/28/1979-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 26) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '/') &&\n              (pieces[10] == '-') &&\n              (pieces[13] == ':') &&\n              (pieces[16] == ':') &&\n              (pieces[19] == '.') &&\n              (pieces[26] == ' ') ) {\n        lf->log += 28;\n    }\n\n\n    /* Check for apache log format */\n    /* [Fri Feb 11 18:06:35 2004] [warn] */\n    else if ( (loglen > 27) &&\n              (pieces[0] == '[') &&\n              (pieces[4] == ' ') &&\n              (pieces[8] == ' ') &&\n              (pieces[11] == ' ') &&\n              (pieces[14] == ':') &&\n              (pieces[17] == ':') &&\n              (pieces[20] == ' ') &&\n              (pieces[25] == ']') ) {\n        lf->log += 27;\n    }\n\n    /* Check for the osx asl log format.\n     * Examples:\n     * [Time 2006.12.28 15:53:55 UTC] [Facility auth] [Sender sshd] [PID 483] [Message error: PAM: Authentication failure for username from 192.168.0.2] [Level 3] [UID -2] [GID -2] [Host Hostname]\n     * [Time 2006.11.02 14:02:11 UTC] [Facility auth] [Sender sshd] [PID 856]\n     [Message refused connect from 59.124.44.34] [Level 4] [UID -2] [GID -2]\n     [Host robert-wyatts-emac]\n     */\n    else if ((loglen > 26) &&\n             (pieces[0] == '[')  &&\n             (pieces[1] == 'T')  &&\n             (pieces[5] == ' ')  &&\n             (pieces[10] == '.') &&\n             (pieces[13] == '.') &&\n             (pieces[16] == ' ') &&\n             (pieces[19] == ':')) {\n        /* Do not read more than 1 message entry -> log tampering */\n        short unsigned int done_message = 0;\n\n        /* Remove the date */\n        lf->log += 25;\n\n        /* Get the desired values */\n        pieces = strchr(lf->log, '[');\n        while (pieces) {\n            pieces++;\n\n            /* Get the sender (set to program name) */\n            if ((strncmp(pieces, \""Sender \"", 7) == 0) &&\n                    (lf->program_name == NULL)) {\n                pieces += 7;\n                lf->program_name = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n\n                    /* Set program_name size */\n                    lf->p_name_size = strlen(lf->program_name);\n\n                    pieces++;\n                }\n                /* Invalid program name */\n                else {\n                    lf->program_name = NULL;\n                    break;\n                }\n            }\n\n            /* Get message */\n            else if ((strncmp(pieces, \""Message \"", 8) == 0) &&\n                     (done_message == 0)) {\n                pieces += 8;\n                done_message = 1;\n\n                lf->log = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n                /* Invalid log closure */\n                else {\n                    break;\n                }\n            }\n\n            /* Get hostname */\n            else if (strncmp(pieces, \""Host \"", 5) == 0) {\n                pieces += 5;\n                lf->hostname = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n\n                /* Invalid hostname */\n                else {\n                    lf->hostname = NULL;\n                }\n                break;\n            }\n\n            /* Get next entry */\n            pieces = strchr(pieces, '[');\n        }\n    }\n\n    /* Check for squid date format\n     * 1140804070.368  11623\n     * seconds from 00:00:00 1970-01-01 UTC\n     */\n    else if ((loglen > 32) &&\n             (pieces[0] == '1') &&\n             (isdigit((int)pieces[1])) &&\n             (isdigit((int)pieces[2])) &&\n             (isdigit((int)pieces[3])) &&\n             (pieces[10] == '.') &&\n             (isdigit((int)pieces[13])) &&\n             (pieces[14] == ' ') &&\n             ((pieces[21] == ' ') || (pieces[22] == ' '))) {\n        lf->log += 14;\n\n        /* We need to start at the size of the event */\n        while (*lf->log == ' ') {\n            lf->log++;\n        }\n    }\n\n    /* Every message must be in the format\n     * hostname->location or\n     * (agent) ip->location.\n     */\n\n    /* Set hostname for local messages */\n    if (lf->location[0] == '(') {\n        /* Messages from an agent */\n        lf->hostname = lf->location;\n    } else if (lf->hostname == NULL) {\n        lf->hostname = __shost;\n    }\n\n    /* Set up the event data */\n    lf->time = c_time;\n    p = localtime(&c_time);\n\n    /* Assign hour, day, year and month values */\n    lf->day = p->tm_mday;\n    lf->year = p->tm_year + 1900;\n    strncpy(lf->mon, month[p->tm_mon], 3);\n    snprintf(lf->hour, 9, \""%02d:%02d:%02d\"",\n             p->tm_hour,\n             p->tm_min,\n             p->tm_sec);\n\n    /* Set the global hour/weekday */\n    __crt_hour = p->tm_hour;\n    __crt_wday = p->tm_wday;\n\n#ifdef TESTRULE\n    if (!alert_only) {\n        print_out(\""**Phase 1: Completed pre-decoding.\"");\n        print_out(\""       full event: '%s'\"", lf->full_log);\n        print_out(\""       hostname: '%s'\"", lf->hostname);\n        print_out(\""       program_name: '%s'\"", lf->program_name);\n        print_out(\""       log: '%s'\"", lf->log);\n    }\n#endif\n    return (0);\n}"", ""target"": 0}]","[{""func_name"": ""OS_CleanMSG"", ""file_path"": ""src/analysisd/cleanevent.c"", ""func_code"": ""int OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n        merror(FORMAT_ERROR, ARGV0);\n        return (-1);\n    }\n\n    /* Is this from an agent? */\n    if ( *msg == '(' )\n    {   /* look past '->' for the first ':' */\n        pieces = strstr(msg, \""->\"");\n        if(!pieces) {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n        pieces = strchr(pieces, ':');\n        if(!pieces)\n        {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n    }\n\n    *pieces = '\\0';\n    pieces++;\n\n    os_strdup(msg, lf->location);\n\n    /* Get the log length */\n    loglen = strlen(pieces) + 1;\n\n    /* Assign the values in the structure (lf->full_log) */\n    os_malloc((2 * loglen) + 1, lf->full_log);\n\n    /* Set the whole message at full_log */\n    strncpy(lf->full_log, pieces, loglen);\n\n    /* Log is the one used for parsing in the decoders and rules */\n    lf->log = lf->full_log + loglen;\n    strncpy(lf->log, pieces, loglen);\n\n    /* check if month contains an umlaut and repair\n     * umlauts are non-ASCII and use 2 slots in the char array\n     * repair to only one slot so we can detect the correct date format in the next step\n     * ex: M\u00e4r 02 17:30:52\n     */\n    if (pieces[1] == (char) 195) {\n        if (pieces[2] == (char) 164) {\n            pieces[0] = '\\0';\n            pieces[1] = 'M';\n            pieces[2] = 'a';\n            pieces++;\n        }\n    }\n\n    /* Check for the syslog date format\n     * ( ex: Dec 29 10:00:01\n     *   or  2015-04-16 21:51:02,805 for proftpd 1.3.5\n     *   or  2007-06-14T15:48:55-04:00 for syslog-ng isodate\n     *   or  2007-06-14T15:48:55.3352-04:00 for syslog-ng isodate with up to 6 optional fraction of a second\n     *   or  2009-05-22T09:36:46.214994-07:00 for rsyslog\n     *   or  2015 Dec 29 10:00:01 )\n     */\n    if (\n        (   /* ex: Dec 29 10:00:01 */\n            (loglen > 17) &&\n            (pieces[3] == ' ') &&\n            (pieces[6] == ' ') &&\n            (pieces[9] == ':') &&\n            (pieces[12] == ':') &&\n            (pieces[15] == ' ') && (lf->log += 16)\n        )\n        ||\n        (   /* ex: 2015-04-16 21:51:02,805 */\n            (loglen > 24) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == ' ') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (pieces[19] == ',') &&\n            (lf->log += 23)\n        )\n        ||\n        (\n            (loglen > 33) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == 'T') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (   /* ex: 2007-06-14T15:48:55-04:00 */\n                (\n                    (pieces[22] == ':') &&\n                    (pieces[25] == ' ') && (lf->log += 26)\n                )\n                ||\n                /* ex: 2007-06-14T15:48:55.3-04:00 or 2009-05-22T09:36:46,214994-07:00 */\n                (\n                    (\n                        (pieces[19] == '.') || (pieces[19] == ',')\n                    )\n                    &&\n                    (\n                        ( (pieces[24] == ':') && (lf->log += 27) ) ||\n                        ( (pieces[25] == ':') && (lf->log += 28) ) ||\n                        ( (pieces[26] == ':') && (lf->log += 29) ) ||\n                        ( (pieces[27] == ':') && (lf->log += 30) ) ||\n                        ( (pieces[28] == ':') && (lf->log += 31) ) ||\n                        ( (pieces[29] == ':') && (lf->log += 32) )\n                    )\n                )\n            )\n        )\n        ||\n        (   /* ex: 2015 Dec 29 10:00:01 */\n            (loglen > 21) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ' ') &&\n            (pieces[8] == ' ') &&\n            (pieces[11] == ' ') &&\n            (pieces[14] == ':') &&\n            (pieces[17] == ':') &&\n            (pieces[20] == ' ') && (lf->log += 21)\n        )\n        ||\n        (\n            /* ex: 2019:11:06-00:08:03 */\n            (loglen > 20) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ':') &&\n            (pieces[7] == ':') &&\n            (pieces[10] == '-') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') && (lf->log += 20)\n        )\n    ) {\n        /* Check for an extra space in here */\n        if (*lf->log == ' ') {\n            lf->log++;\n        }\n\n\n        /* Hostname */\n        pieces = lf->hostname = lf->log;\n\n\n        /* Check for a valid hostname */\n        while (isValidChar(*pieces) == 1) {\n            pieces++;\n        }\n\n        /* Check if it is a syslog without hostname (common on Solaris) */\n        if (*pieces == ':' && pieces[1] == ' ') {\n            /* Getting solaris 8/9 messages without hostname.\n             * In these cases, the process_name should be there.\n             * http://www.ossec.net/wiki/index.php/Log_Samples_Solaris\n             */\n            lf->program_name = lf->hostname;\n            lf->hostname = NULL;\n\n            /* End the program name string */\n            *pieces = '\\0';\n\n            pieces += 2;\n            lf->log = pieces;\n        }\n\n        /* Extract the hostname */\n        else if (*pieces != ' ') {\n            /* Invalid hostname */\n            lf->hostname = NULL;\n            pieces = NULL;\n        } else {\n            /* End the hostname string */\n            *pieces = '\\0';\n\n            /* Move pieces to the beginning of the log message */\n            pieces++;\n            lf->log = pieces;\n\n            /* Get program_name */\n            lf->program_name = pieces;\n\n            /* Extract program_name */\n            /* Valid names:\n             * p_name:\n             * p_name[pid]:\n             * p_name[pid]: [ID xx facility.severity]\n             * auth|security:info p_name:\n             */\n            while (isValidChar(*pieces) == 1) {\n                pieces++;\n            }\n\n            /* Check for the first format: p_name: */\n            if ((*pieces == ':') && (pieces[1] == ' ')) {\n                *pieces = '\\0';\n                pieces += 2;\n            }\n\n            /* Check for the second format: p_name[pid]: */\n            else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                *pieces = '\\0';\n                pieces += 2;\n                while (isdigit((int)*pieces)) {\n                    pieces++;\n                }\n\n                if ((*pieces == ']') && (pieces[1] == ':') && (pieces[2] == ' ')) {\n                    pieces += 3;\n                }\n                /* Some systems are not terminating the program name with\n                 * a ':'. Working around this in here...\n                 */\n                else if ((*pieces == ']') && (pieces[1] == ' ')) {\n                    pieces += 2;\n                } else {\n                    /* Fix for some weird log formats */\n                    pieces--;\n                    while (isdigit((int)*pieces)) {\n                        pieces--;\n                    }\n\n                    if (*pieces == '\\0') {\n                        *pieces = '[';\n                    }\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            }\n            /* AIX syslog */\n            else if ((*pieces == '|') && islower((int)pieces[1])) {\n                pieces += 2;\n\n                /* Remove facility */\n                while (isalnum((int)*pieces)) {\n                    pieces++;\n                }\n\n                if (*pieces == ':') {\n                    /* Remove severity */\n                    pieces++;\n                    while (isalnum((int)*pieces)) {\n                        pieces++;\n                    }\n\n                    if (*pieces == ' ') {\n                        pieces++;\n                        lf->program_name = pieces;\n\n\n                        /* Get program name again */\n                        while (isValidChar(*pieces) == 1) {\n                            pieces++;\n                        }\n\n                        /* Check for the first format: p_name: */\n                        if ((*pieces == ':') && (pieces[1] == ' ')) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                        }\n\n                        /* Check for the second format: p_name[pid]: */\n                        else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                            while (isdigit((int)*pieces)) {\n                                pieces++;\n                            }\n\n                            if ((*pieces == ']') && (pieces[1] == ':') &&\n                                    (pieces[2] == ' ')) {\n                                pieces += 3;\n                            } else {\n                                pieces = NULL;\n                            }\n                        }\n                    } else {\n                        pieces = NULL;\n                        lf->program_name = NULL;\n                    }\n                }\n                /* Invalid AIX */\n                else {\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            } else {\n                pieces = NULL;\n                lf->program_name = NULL;\n            }\n        }\n\n        /* Remove [ID xx facility.severity] */\n        if (pieces) {\n            /* Set log after program name */\n            lf->log = pieces;\n\n            if ((pieces[0] == '[') &&\n                    (pieces[1] == 'I') &&\n                    (pieces[2] == 'D') &&\n                    (pieces[3] == ' ')) {\n                pieces += 4;\n\n                /* Going after the ] */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    pieces += 2;\n                    lf->log = pieces;\n                }\n            }\n        }\n\n        /* Get program name size */\n        if (lf->program_name) {\n            lf->p_name_size = strlen(lf->program_name);\n        }\n    }\n\n    /* xferlog date format\n     * Mon Apr 17 18:27:14 2006 1 64.160.42.130\n     */\n    else if ((loglen > 28) &&\n             (pieces[3] == ' ') &&\n             (pieces[7] == ' ') &&\n             (pieces[10] == ' ') &&\n             (pieces[13] == ':') &&\n             (pieces[16] == ':') &&\n             (pieces[19] == ' ') &&\n             (pieces[24] == ' ') &&\n             (pieces[26] == ' ')) {\n        /* Move log to the beginning of the message */\n        lf->log += 24;\n    }\n\n    /* Check for snort date format\n     * ex: 01/28-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 24) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '-') &&\n              (pieces[8] == ':') &&\n              (pieces[11] == ':') &&\n              (pieces[14] == '.') &&\n              (pieces[21] == ' ') ) {\n        lf->log += 23;\n    }\n\n    /* Check for suricata (new) date format\n     * ex: 01/28/1979-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 26) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '/') &&\n              (pieces[10] == '-') &&\n              (pieces[13] == ':') &&\n              (pieces[16] == ':') &&\n              (pieces[19] == '.') &&\n              (pieces[26] == ' ') ) {\n        lf->log += 28;\n    }\n\n\n    /* Check for apache log format */\n    /* [Fri Feb 11 18:06:35 2004] [warn] */\n    else if ( (loglen > 27) &&\n              (pieces[0] == '[') &&\n              (pieces[4] == ' ') &&\n              (pieces[8] == ' ') &&\n              (pieces[11] == ' ') &&\n              (pieces[14] == ':') &&\n              (pieces[17] == ':') &&\n              (pieces[20] == ' ') &&\n              (pieces[25] == ']') ) {\n        lf->log += 27;\n    }\n\n    /* Check for the osx asl log format.\n     * Examples:\n     * [Time 2006.12.28 15:53:55 UTC] [Facility auth] [Sender sshd] [PID 483] [Message error: PAM: Authentication failure for username from 192.168.0.2] [Level 3] [UID -2] [GID -2] [Host Hostname]\n     * [Time 2006.11.02 14:02:11 UTC] [Facility auth] [Sender sshd] [PID 856]\n     [Message refused connect from 59.124.44.34] [Level 4] [UID -2] [GID -2]\n     [Host robert-wyatts-emac]\n     */\n    else if ((loglen > 26) &&\n             (pieces[0] == '[')  &&\n             (pieces[1] == 'T')  &&\n             (pieces[5] == ' ')  &&\n             (pieces[10] == '.') &&\n             (pieces[13] == '.') &&\n             (pieces[16] == ' ') &&\n             (pieces[19] == ':')) {\n        /* Do not read more than 1 message entry -> log tampering */\n        short unsigned int done_message = 0;\n\n        /* Remove the date */\n        lf->log += 25;\n\n        /* Get the desired values */\n        pieces = strchr(lf->log, '[');\n        while (pieces) {\n            pieces++;\n\n            /* Get the sender (set to program name) */\n            if ((strncmp(pieces, \""Sender \"", 7) == 0) &&\n                    (lf->program_name == NULL)) {\n                pieces += 7;\n                lf->program_name = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n\n                    /* Set program_name size */\n                    lf->p_name_size = strlen(lf->program_name);\n\n                    pieces++;\n                }\n                /* Invalid program name */\n                else {\n                    lf->program_name = NULL;\n                    break;\n                }\n            }\n\n            /* Get message */\n            else if ((strncmp(pieces, \""Message \"", 8) == 0) &&\n                     (done_message == 0)) {\n                pieces += 8;\n                done_message = 1;\n\n                lf->log = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n                /* Invalid log closure */\n                else {\n                    break;\n                }\n            }\n\n            /* Get hostname */\n            else if (strncmp(pieces, \""Host \"", 5) == 0) {\n                pieces += 5;\n                lf->hostname = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n\n                /* Invalid hostname */\n                else {\n                    lf->hostname = NULL;\n                }\n                break;\n            }\n\n            /* Get next entry */\n            pieces = strchr(pieces, '[');\n        }\n    }\n\n    /* Check for squid date format\n     * 1140804070.368  11623\n     * seconds from 00:00:00 1970-01-01 UTC\n     */\n    else if ((loglen > 32) &&\n             (pieces[0] == '1') &&\n             (isdigit((int)pieces[1])) &&\n             (isdigit((int)pieces[2])) &&\n             (isdigit((int)pieces[3])) &&\n             (pieces[10] == '.') &&\n             (isdigit((int)pieces[13])) &&\n             (pieces[14] == ' ') &&\n             ((pieces[21] == ' ') || (pieces[22] == ' '))) {\n        lf->log += 14;\n\n        /* We need to start at the size of the event */\n        while (*lf->log == ' ') {\n            lf->log++;\n        }\n    }\n\n    /* Every message must be in the format\n     * hostname->location or\n     * (agent) ip->location.\n     */\n\n    /* Set hostname for local messages */\n    if (lf->location[0] == '(') {\n        /* Messages from an agent */\n        lf->hostname = lf->location;\n    } else if (lf->hostname == NULL) {\n        lf->hostname = __shost;\n    }\n\n    /* Set up the event data */\n    lf->time = c_time;\n    p = localtime(&c_time);\n\n    /* Assign hour, day, year and month values */\n    lf->day = p->tm_mday;\n    lf->year = p->tm_year + 1900;\n    strncpy(lf->mon, month[p->tm_mon], 3);\n    snprintf(lf->hour, 9, \""%02d:%02d:%02d\"",\n             p->tm_hour,\n             p->tm_min,\n             p->tm_sec);\n\n    /* Set the global hour/weekday */\n    __crt_hour = p->tm_hour;\n    __crt_wday = p->tm_wday;\n\n#ifdef TESTRULE\n    if (!alert_only) {\n        print_out(\""**Phase 1: Completed pre-decoding.\"");\n        print_out(\""       full event: '%s'\"", lf->full_log);\n        print_out(\""       hostname: '%s'\"", lf->hostname);\n        print_out(\""       program_name: '%s'\"", lf->program_name);\n        print_out(\""       log: '%s'\"", lf->log);\n    }\n#endif\n    return (0);\n}""}]","{""caller"": 1, ""code"": 4, ""value"": 3, ""function"": 2}","[{""source"": ""caller_info(file:cleanevent.c, func:OS_CleanMSG)"", ""result"": [{""call_line"": 713, ""call_code"": ""OS_CleanMSG(msg, lf)"", ""caller_code"": ""void OS_ReadMSG(int m_queue)\n#else\n__attribute__((noreturn))\nvoid OS_ReadMSG_analysisd(int m_queue)\n#endif\n{\n    int i;\n    char msg[OS_MAXSTR + 1];\n    Eventinfo *lf;\n\n    RuleInfo *stats_rule = NULL;\n\n    /* Null to global currently pointers */\n    currently_rule = NULL;\n\n    /* Initialize the logs */\n    OS_InitLog();\n\n    /* Initialize the integrity database */\n    SyscheckInit();\n\n    /* Initialize Rootcheck */\n    RootcheckInit();\n\n    /* Initialize host info */\n    HostinfoInit();\n\n    /* Create the event list */\n    OS_CreateEventList(Config.memorysize);\n\n    /* Initiate the FTS list */\n    if (!FTS_Init()) {\n        ErrorExit(FTS_LIST_ERROR, ARGV0);\n    }\n\n    /* Initialize the Accumulator */\n    if (!Accumulate_Init()) {\n        merror(\""accumulator: ERROR: Initialization failed\"");\n        exit(1);\n    }\n\n    /* Start the active response queues */\n    if (Config.ar) {\n        /* Waiting the ARQ to settle */\n        sleep(3);\n\n#ifndef LOCAL\n        if (Config.ar & REMOTE_AR)..."", ""caller_start"": 528, ""file_path"": ""src/analysisd/analysisd.c""}, {""call_line"": 432, ""call_code"": ""OS_CleanMSG(msg, lf)"", ""caller_code"": ""void OS_ReadMSG(char *ut_str)\n{\n    char msg[OS_MAXSTR + 1];\n    int exit_code = 0;\n    char *ut_alertlevel = NULL;\n    char *ut_rulelevel = NULL;\n    char *ut_decoder_name = NULL;\n\n    if (ut_str) {\n        /* XXX Break apart string */\n        ut_rulelevel = ut_str;\n        ut_alertlevel =  strchr(ut_rulelevel, ':');\n        if (!ut_alertlevel) {\n            ErrorExit(\""%s: -U requires the matching format to be \""\n                      \""\\\""<rule_id>:<alert_level>:<decoder_name>\\\""\"", ARGV0);\n        } else {\n            *ut_alertlevel = '\\0';\n            ut_alertlevel++;\n        }\n        ut_decoder_name = strchr(ut_alertlevel, ':');\n        if (!ut_decoder_name) {\n            ErrorExit(\""%s: -U requires the matching format to be \""\n                      \""\\\""<rule_id>:<alert_level>:<decoder_name>\\\""\"", ARGV0);\n        } else {\n            *ut_decoder_name = '\\0';\n            ut_decoder_name++;\n        }\n    }\n\n    RuleInfoDetail *last_info_detail;\n    Eventinfo *lf;\n\n    /* Null global point..."", ""caller_start"": 332, ""file_path"": ""src/analysisd/testrule.c""}]}, {""source"": ""code_info(file:cleanevent.c, lines:1-60)"", ""result"": ""/* Copyright (C) 2009 Trend Micro Inc.\n * All rights reserved.\n *\n * This program is a free software; you can redistribute it\n * and/or modify it under the terms of the GNU General Public\n * License (version 2) as published by the FSF - Free Software\n * Foundation.\n */\n\n#include \""cleanevent.h\""\n\n#include \""shared.h\""\n#include \""os_regex/os_regex.h\""\n#include \""analysisd.h\""\n#include \""fts.h\""\n#include \""config.h\""\n\n/* To translate between month (int) to month (char) */\nstatic const char *(month[]) = {\""Jan\"", \""Feb\"", \""Mar\"", \""Apr\"", \""May\"", \""Jun\"",\n                   \""Jul\"", \""Aug\"", \""Sep\"", \""Oct\"", \""Nov\"", \""Dec\""\n                  };\n\n\n/* Format a received message in the Eventinfo structure */\nint OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n        merror(FORMAT_ERROR, ARGV0);\n        return (-1);\n    }\n\n    /* Is this from an agent? */\n    if ( *msg == '(' )\n    {   /* look past '->' for the first ':' */\n        pieces = strchr(strstr(msg, \""->\""), ':');\n        if(!pieces)\n        {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n    }\n\n    *pieces = '\\0';\n    pieces++;\n\n    os_strdup(msg, lf->location);\n\n    /* Get the log length */\n""}, {""source"": ""value_info(file:cleanevent.c, value:msg)"", ""result"": {""value_trace"": [{""full_code"": ""msg += 2"", ""line"": 36, ""func_name"": ""OS_CleanMSG""}], ""struct_var"": ""msg"", ""struct_type"": ""char[OS_MAXSTR+1]"", ""struct_definition"": null}}, {""source"": ""code_info(file:analysisd.c, lines:528-713)"", ""result"": ""void OS_ReadMSG(int m_queue)\n#else\n__attribute__((noreturn))\nvoid OS_ReadMSG_analysisd(int m_queue)\n#endif\n{\n    int i;\n    char msg[OS_MAXSTR + 1];\n    Eventinfo *lf;\n\n    RuleInfo *stats_rule = NULL;\n\n    /* Null to global currently pointers */\n    currently_rule = NULL;\n\n    /* Initialize the logs */\n    OS_InitLog();\n\n    /* Initialize the integrity database */\n    SyscheckInit();\n\n    /* Initialize Rootcheck */\n    RootcheckInit();\n\n    /* Initialize host info */\n    HostinfoInit();\n\n    /* Create the event list */\n    OS_CreateEventList(Config.memorysize);\n\n    /* Initiate the FTS list */\n    if (!FTS_Init()) {\n        ErrorExit(FTS_LIST_ERROR, ARGV0);\n    }\n\n    /* Initialize the Accumulator */\n    if (!Accumulate_Init()) {\n        merror(\""accumulator: ERROR: Initialization failed\"");\n        exit(1);\n    }\n\n    /* Start the active response queues */\n    if (Config.ar) {\n        /* Waiting the ARQ to settle */\n        sleep(3);\n\n#ifndef LOCAL\n        if (Config.ar & REMOTE_AR) {\n            if ((arq = StartMQ(ARQUEUE, WRITE)) < 0) {\n                merror(ARQ_ERROR, ARGV0);\n\n                /* If LOCAL_AR is set, keep it there */\n                if (Config.ar & LOCAL_AR) {\n                    Config.ar = 0;\n                    Config.ar |= LOCAL_AR;\n                } else {\n                    Config.ar = 0;\n                }\n            } else {\n                verbose(CONN_TO, ARGV0, ARQUEUE, \""active-response\"");\n            }\n        }\n#else\n        /* Only for LOCAL_ONLY installs */\n        if (Config.ar & REMOTE_AR) {\n            if (Config.ar & LOCAL_AR) {\n                Config.ar = 0;\n                Config.ar |= LOCAL_AR;\n            } else {\n                Config.ar = 0;\n            }\n        }\n#endif\n\n        if (Config.ar & LOCAL_AR) {\n            if ((execdq = StartMQ(EXECQUEUE, WRITE)) < 0) {\n                merror(ARQ_ERROR, ARGV0);\n\n                /* If REMOTE_AR is set, keep it there */\n                if (Config.ar & REMOTE_AR) {\n                    Config.ar = 0;\n                    Config.ar |= REMOTE_AR;\n                } else {\n                    Config.ar = 0;\n                }\n            } else {\n                verbose(CONN_TO, ARGV0, EXECQUEUE, \""exec\"");\n            }\n        }\n    }\n    debug1(\""%s: DEBUG: Active response Init completed.\"", ARGV0);\n\n    /* Get current time before starting */\n    c_time = time(NULL);\n\n    /* Start the hourly/weekly stats */\n    if (Start_Hour() < 0) {\n        Config.stats = 0;\n    } else {\n        /* Initialize stats rules */\n        stats_rule = zerorulemember(\n                         STATS_MODULE,\n                         Config.stats,\n                         0, 0, 0, 0, 0, 0);\n\n        if (!stats_rule) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n        stats_rule->group = \""stats,\"";\n        stats_rule->comment = \""Excessive number of events (above normal).\"";\n    }\n\n    /* Do some cleanup */\n    memset(msg, '\\0', OS_MAXSTR + 1);\n\n    /* Initialize the logs */\n    {\n        lf = (Eventinfo *)calloc(1, sizeof(Eventinfo));\n        if (!lf) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n        os_calloc(Config.decoder_order_size, sizeof(char*), lf->fields);\n        lf->year = prev_year;\n        strncpy(lf->mon, prev_month, 3);\n        lf->day = today;\n\n        if (OS_GetLogLocation(lf) < 0) {\n            ErrorExit(\""%s: Error allocating log files\"", ARGV0);\n        }\n\n        Free_Eventinfo(lf);\n    }\n\n#ifdef SQLITE_ENABLED\n    /* Open the sqlite db */\n    extern sqlite3 *conn;\n    int s_error = 0;\n    if (Config.md5_allowlist) {\n        debug2(\""Opening md5_allowlist: %s\"", Config.md5_allowlist);\n        if((s_error = sqlite3_open(Config.md5_allowlist, &conn))) {\n            merror(INVALID_IGNORE_MD5DB, ARGV0, Config.md5_allowlist);\n        }\n\n    }\n#endif\n\n    debug1(\""%s: DEBUG: Startup completed. Waiting for new messages..\"", ARGV0);\n\n    if (Config.custom_alert_output) {\n        debug1(\""%s: INFO: Custom output found.!\"", ARGV0);\n    }\n\n    /* Daemon loop */\n    while (1) {\n        lf = (Eventinfo *)calloc(1, sizeof(Eventinfo));\n        os_calloc(Config.decoder_order_size, sizeof(char*), lf->fields);\n\n        /* This shouldn't happen */\n        if (lf == NULL) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n\n        DEBUG_MSG(\""%s: DEBUG: Waiting for msgs - %d \"", ARGV0, (int)time(0));\n\n        /* Receive message from queue */\n        if ((i = OS_RecvUnix(m_queue, OS_MAXSTR, msg))) {\n            RuleNode *rulenode_pt;\n\n            /* Get the time we received the event */\n            c_time = time(NULL);\n\n            /* Default values for the log info */\n            Zero_Eventinfo(lf);\n\n            /* Check for a valid message */\n            if (i < 4) {\n                merror(IMSG_ERROR, ARGV0, msg);\n                Free_Eventinfo(lf);\n                continue;\n            }\n\n            /* Message before extracting header */\n            DEBUG_MSG(\""%s: DEBUG: Received msg: %s \"", ARGV0, msg);\n\n            /* Clean the msg appropriately */\n            if (OS_CleanMSG(msg, lf) < 0) {\n                merror(IMSG_ERROR, ARGV0, msg);\n""}, {""source"": ""code_info(file:testrule.c, lines:332-432)"", ""result"": ""void OS_ReadMSG(char *ut_str)\n{\n    char msg[OS_MAXSTR + 1];\n    int exit_code = 0;\n    char *ut_alertlevel = NULL;\n    char *ut_rulelevel = NULL;\n    char *ut_decoder_name = NULL;\n\n    if (ut_str) {\n        /* XXX Break apart string */\n        ut_rulelevel = ut_str;\n        ut_alertlevel =  strchr(ut_rulelevel, ':');\n        if (!ut_alertlevel) {\n            ErrorExit(\""%s: -U requires the matching format to be \""\n                      \""\\\""<rule_id>:<alert_level>:<decoder_name>\\\""\"", ARGV0);\n        } else {\n            *ut_alertlevel = '\\0';\n            ut_alertlevel++;\n        }\n        ut_decoder_name = strchr(ut_alertlevel, ':');\n        if (!ut_decoder_name) {\n            ErrorExit(\""%s: -U requires the matching format to be \""\n                      \""\\\""<rule_id>:<alert_level>:<decoder_name>\\\""\"", ARGV0);\n        } else {\n            *ut_decoder_name = '\\0';\n            ut_decoder_name++;\n        }\n    }\n\n    RuleInfoDetail *last_info_detail;\n    Eventinfo *lf;\n\n    /* Null global pointer to current rule */\n    currently_rule = NULL;\n\n    /* Create the event list */\n    OS_CreateEventList(Config.memorysize);\n\n    /* Initiate the FTS list */\n    if (!FTS_Init()) {\n        ErrorExit(FTS_LIST_ERROR, ARGV0);\n    }\n\n    /* Initialize the Accumulator */\n    if (!Accumulate_Init()) {\n        merror(\""accumulator: ERROR: Initialization failed\"");\n        exit(1);\n    }\n\n    __crt_ftell = 1;\n\n    /* Get current time before starting */\n    c_time = time(NULL);\n\n    /* Do some cleanup */\n    memset(msg, '\\0', OS_MAXSTR + 1);\n\n    if (!alert_only) {\n        print_out(\""%s: Type one log per line.\\n\"", ARGV0);\n    }\n\n    /* Daemon loop */\n    while (1) {\n        lf = (Eventinfo *)calloc(1, sizeof(Eventinfo));\n        os_calloc(Config.decoder_order_size, sizeof(char*), lf->fields);\n\n\n        /* This shouldn't happen */\n        if (lf == NULL) {\n            ErrorExit(MEM_ERROR, ARGV0, errno, strerror(errno));\n        }\n\n        /* Fix the msg */\n        snprintf(msg, 15, \""1:stdin:\"");\n\n        /* Receive message from queue */\n        if (fgets(msg + 8, OS_MAXSTR - 8, stdin)) {\n            RuleNode *rulenode_pt;\n\n            /* Get the time we received the event */\n            c_time = time(NULL);\n\n            /* Remov newline */\n            if (msg[strlen(msg) - 1] == '\\n') {\n                msg[strlen(msg) - 1] = '\\0';\n            }\n\n            /* Make sure we ignore blank lines */\n            if (strlen(msg) < 10) {\n                continue;\n            }\n\n            if (!alert_only) {\n                print_out(\""\\n\"");\n            }\n\n            /* Default values for the log info */\n            Zero_Eventinfo(lf);\n\n            /* Clean the msg appropriately */\n            if (OS_CleanMSG(msg, lf) < 0) {\n                merror(IMSG_ERROR, ARGV0, msg);\n""}, {""source"": ""value_info(file:analysisd.c, value:msg)"", ""result"": {""value_trace"": [{""full_code"": ""msg[OS_MAXSTR + 1]"", ""line"": 535, ""func_name"": ""OS_ReadMSG""}], ""struct_var"": ""msg"", ""struct_type"": ""char[OS_MAXSTR+1]"", ""struct_definition"": null}}, {""source"": ""value_info(file:testrule.c, value:ut_str)"", ""result"": {""value_trace"": [{""full_code"": ""*ut_str = NULL"", ""line"": 64, ""func_name"": ""main<duplicate>3""}, {""full_code"": ""ut_str = optarg"", ""line"": 107, ""func_name"": ""main<duplicate>3""}], ""struct_var"": ""ut_str"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}, {""source"": ""code_info(file:analysisd.c, lines:713-720)"", ""result"": ""            if (OS_CleanMSG(msg, lf) < 0) {\n                merror(IMSG_ERROR, ARGV0, msg);\n                Free_Eventinfo(lf);\n                continue;\n            }\n\n            /* Msg cleaned */\n            DEBUG_MSG(\""%s: DEBUG: Msg cleanup: %s \"", ARGV0, lf->log);\n\n""}, {""source"": ""func_info(func:OS_RecvUnix)"", ""result"": [{""code"": ""int OS_RecvUnix(int socket, int sizet, char *ret)\n{\n    ssize_t recvd;\n    if ((recvd = recvfrom(socket, ret, sizet - 1, 0,\n                          (struct sockaddr *)&n_us, &us_l)) < 0) {\n        r"", ""start_line"": 579, ""end_line"": 589, ""full_name"": ""OS_RecvUnix"", ""file_path"": ""src/os_net/os_net.c""}]}, {""source"": ""func_info(func:StartMQ)"", ""result"": [{""code"": ""int StartMQ(const char *path, short int type)\n{\n    if (type == READ) {\n        return (OS_BindUnixDomain(path, 0660, OS_MAXSTR + 512));\n    }\n\n    /* We give up to 21 seconds for the other end to sta"", ""start_line"": 17, ""end_line"": 58, ""full_name"": ""StartMQ"", ""file_path"": ""src/shared/mq_op.c""}, {""code"": ""int StartMQ(const char *path, short int type)\n{\n    /* Connect to the server */\n    connect_server(0);\n\n    if ((path == NULL) && (type == 0)) {\n        return (0);\n    }\n\n    return (0);\n}"", ""start_line"": 449, ""end_line"": 459, ""full_name"": ""StartMQ<duplicate>0"", ""file_path"": ""src/win32/win_agent.c""}]}]","The vulnerability arises when `msg` starts with '(' but lacks '->' or ':' in OS_CleanMSG (src/analysisd/cleanevent.c line 46). The original code `strchr(strstr(msg, ""->""), "":"")` dereferences a NULL pointer if `strstr` returns NULL. The patch (lines 47-49) adds a null check. The trigger chain begins with `msg` populated via `OS_RecvUnix(m_queue, OS_MAXSTR, msg)` in OS_ReadMSG (src/analysisd/analysisd.c line 713), which receives data from a UNIX socket initialized by `StartMQ` (src/shared/mq_op.c). No further context is needed as the core path is fully evidenced.",0.95,./github/other_context/CVE-2020-8448
75,CVE-2021-28855,CWE-476,c_cpp,"In Deark before 1.5.8, a specially crafted input file can cause a NULL pointer dereference in the dbuf_write function (src/deark-dbuf.c).",https://github.com/jsummers/deark/commit/287f5ac31dfdc074669182f51ece637706070eeb,pict: Fixed a bug with ICC profile extraction\n\nCould cause a NULL pointer dereference.\n\nFound by F. Çelik.,1,"[{""func_name"": ""do_iccprofile_item"", ""file_path"": ""modules/pict.c"", ""func_code"": ""static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \""ICC profile segment, selector=%d, data len=%d\"", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \""icc\"", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n\t\t// Beginning and Continuation segments normally have profile data.\n\t\t// End segments (selector==2) are not allowed to include data.\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}"", ""target"": 0}]","[{""func_name"": ""do_iccprofile_item"", ""file_path"": ""modules/pict.c"", ""func_code"": ""static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \""ICC profile segment, selector=%d, data len=%d\"", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \""icc\"", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n\t\t// Beginning and Continuation segments normally have profile data.\n\t\t// End segments (selector==2) are not allowed to include data.\n\n\t\tif(!d->iccprofile_file) {\n\t\t\tde_warn(c, \""Bad ICC profile segment\"");\n\t\t\treturn;\n\t\t}\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}""}]","{""value"": 1, ""caller"": 1, ""code"": 2}","[{""source"": ""value_info(file:pict.c, value:d->iccprofile_file)"", ""result"": {""value_trace"": [{""full_code"": ""d->iccprofile_file = NULL"", ""line"": 653, ""func_name"": ""do_iccprofile_item""}, {""full_code"": ""d->iccprofile_file = dbuf_create_output_file(c, \""icc\"", NULL, DE_CREATEFLAG_IS_AUX)"", ""line"": 657, ""func_name"": ""do_iccprofile_item""}], ""struct_var"": ""d"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""caller_info(file:pict.c, func:do_iccprofile_item)"", ""result"": [{""call_line"": 696, ""call_code"": ""do_iccprofile_item(c, d, data_pos+4, len)"", ""caller_code"": ""static int handler_a1(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 kind;\n\ti64 len;\n\n\tkind = de_getu16be(data_pos);\n\tlen = de_getu16be(data_pos+2);\n\tde_dbg(c, \""comment kind: %d, size: %d\"", (int)kind, (int)len);\n\t*bytes_used = 4+len;\n\n\tif(kind==100 && len>=4) {\n\t\tstruct de_fourcc sig4cc;\n\n\t\tdbuf_read_fourcc(c->infile, data_pos+4, &sig4cc, 4, 0x0);\n\t\tde_dbg(c, \""application comment, signature=0x%08x '%s'\"",\n\t\t\t(unsigned int)sig4cc.id, sig4cc.id_dbgstr);\n\t\tde_dbg_hexdump(c, c->infile, data_pos+8, len-4, 256, NULL, 0x1);\n\t}\n\telse if(kind==224) {\n\t\tdo_iccprofile_item(c, d, data_pos+4, len);\n\t}\n\telse {\n\t\tde_dbg_hexdump(c, c->infile, data_pos+4, len, 256, NULL, 0x1);\n\t}\n\n\treturn 1;\n}"", ""caller_start"": 677, ""file_path"": ""modules/pict.c""}]}, {""source"": ""code_info(file:pict.c, lines:653-660)"", ""result"": ""\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \""icc\"", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n""}, {""source"": ""code_info(file:pict.c, lines:640-660)"", ""result"": ""{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \""ICC profile segment, selector=%d, data len=%d\"", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \""icc\"", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n""}]",modules/pict.c:653 (d->iccprofile_file = NULL) → modules/pict.c:657 (conditional assignment if selector==0) → modules/pict.c:664-666 (dbuf_copy uses d->iccprofile_file without validation when selector==1) → modules/pict.c:644 (selector derived from input via de_getu32be).,0.95,./github/other_context/CVE-2021-28855
76,CVE-2021-30015,CWE-476,c_cpp,"There is a Null Pointer Dereference in function filter_core/filter_pck.c:gf_filter_pck_new_alloc_internal in GPAC 1.0.1. The pid comes from function av1dmx_parse_flush_sample, the ctx.opid maybe NULL. The result is a crash in gf_filter_pck_new_alloc_internal.",https://github.com/gpac/gpac/commit/13dad7d5ef74ca2e6fe4010f5b03eb12e9bbe0ec,fixed #1719,1,"[{""func_name"": ""av1dmx_parse_flush_sample"", ""file_path"": ""src/filters/reframe_av1.c"", ""func_code"": ""static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\""[AV1Dmx] no frame OBU, skipping OBU\\n\""));\n\t\treturn GF_OK;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \t//flags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\n\treturn GF_OK;\n\n}"", ""target"": 0}]","[{""func_name"": ""av1dmx_parse_flush_sample"", ""file_path"": ""src/filters/reframe_av1.c"", ""func_code"": ""static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\""[AV1Dmx] no frame OBU, skipping OBU\\n\""));\n\t\treturn GF_OK;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \t//flags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\n\treturn GF_OK;\n\n}""}]","{""function"": 1, ""query"": 1}","[{""source"": ""func_info(func:gf_filter_pck_new_alloc_internal)"", ""result"": [{""code"": ""static GF_FilterPacket *gf_filter_pck_new_alloc_internal(GF_FilterPid *pid, u32 data_size, u8 **data, Bool no_block_check)\n{\n\tGF_FilterPacket *pck=NULL;\n\tGF_FilterPacket *closest=NULL;\n\tu32 count, max_reservoir_size;\n\n\tif (PID_IS_INPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\""Attempt to allocate a packet on an input PID in filter %s\\n\"", pid->filter->name));\n\t\treturn NULL;\n\t}\n\tif (!no_block_check && gf_filter_pid_would_block(pid))\n\t\treturn NULL;\n\n\tcount = gf_fq_count(pid->filter->pcks_alloc_reservoir);\n\tif (count) {\n\t\tGF_PckQueueEnum pck_enum_state;\n\t\tmemset(&pck_enum_state, 0, sizeof(GF_PckQueueEnum));\n\t\tpck_enum_state.data_size = data_size;\n\t\tgf_fq_enum(pid->filter->pcks_alloc_reservoir, pck_queue_enum, &pck_enum_state);\n\t\tpck = pck_enum_state.pck;\n\t\tclosest = pck_enum_state.closest;\n\t}\n\n\t//stop allocating after a while - TODO we for sur can design a better algo...\n\tmax_reservoir_size = pid->num_destinations ? 10 : 1;\n\t//if pid is file, force 1 max\n\tif (!pck && (pid->stream_type==GF_STREAM_FILE))\n\t\tmax_reservoir_size = 1;\n\n\tif (!pck && (count>=max_reservoir_size)) {\n\t\tassert(closest);\n\t\tclosest->alloc_size = data_size;\n\t\tclosest->data = gf_realloc(closest->data, closest->alloc_size);\n\t\tpck = closest;\n#ifdef GPAC_MEMORY_TRACKING\n\t\tpid->filter->session->nb_realloc_pck++;\n#endif\n\t}\n\n\tif (!pck) {\n\t\tGF_SAFEALLOC(pck, GF_FilterPacket);\n\t\tif (!pck)\n\t\t\treturn NULL;\n\t\tpck->data = gf_malloc(sizeof(char)*data_size);\n\t\tpck->alloc_size = data_size;\n#ifdef GPAC_MEMORY_TRACKING\n\t\tpid->filter->session->nb_alloc_pck+=2;\n#endif\n\t} else {\n\t\t//pop first item and swap pointers. We can safely do this since this filter\n\t\t//is the only one accessing the queue in pop mode, all others are just pushing to it\n\t\t//this may however imply that we don't get the best matching block size if new packets\n\t\t//were added to the list\n\n\t\tGF_FilterPacket *head_pck = gf_fq_pop(pid->filter->pcks_alloc_reservoir);\n\t\tchar *pck_data = pck->data;\n\t\tu32 alloc_size = pck->alloc_size;\n\t\tpck->data = head_pck->data;\n\t\tpck->alloc_size = head_pck->alloc_size;\n\t\thead_pck->data = pck_data;\n\t\thead_pck->alloc_size = alloc_size;\n\t\tpck = head_pck;\n\t}\n\n\tpck->pck = pck;\n\tpck->data_length = data_size;\n\tif (data) *data = pck->data;\n\tpck->filter_owns_mem = 0;\n\n\tgf_filter_pck_reset_props(pck, pid);\n\treturn pck;\n}\n"", ""start_line"": 98, ""end_line"": 169, ""full_name"": ""gf_filter_pck_new_alloc_internal"", ""file_path"": ""src/filter_core/filter_pck.c""}]}, {""source"": ""query_info(query:cpg.method.name(\""gf_filter_pck_new_alloc_internal\""...)"", ""result"": [{""name"": ""PID_IS_INPUT"", ""signature"": """", ""code"": ""PID_IS_INPUT(pid)"", ""typeFullName"": ""ANY"", ""lineNumber"": 104, ""methodFullName"": ""src/filter_core/filter_session.h:41:41:PID_IS_INPUT:1"", ""dispatchType"": ""INLINED"", ""columnNumber"": 6, ""argumentIndex"": -1}, {""name"": ""<operator>.conditional"", ""signature"": """", ""code"": ""(pid->pid == pid) ? GF_FALSE : GF_TRUE"", ""typeFullName"": ""ANY"", ""lineNumber"": 104, ""methodFullName"": ""<operator>.conditional"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.equals"", ""signature"": """", ""code"": ""pid->pid == pid"", ""typeFullName"": ""ANY"", ""lineNumber"": 104, ""methodFullName"": ""<operator>.equals"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->pid"", ""typeFullName"": ""ANY"", ""lineNumber"": 104, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": 1}, {""name"": ""GF_LOG"", ""signature"": """", ""code"": ""GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\""Attempt to allocate a packet on an input PID in filter %s\\n\"", pid->filter->name))"", ""typeFullName"": ""ANY"", ""lineNumber"": 105, ""methodFullName"": ""GF_LOG"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 3, ""argumentIndex"": -1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter->name"", ""typeFullName"": ""ANY"", ""lineNumber"": 105, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 103, ""argumentIndex"": 2}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter"", ""typeFullName"": ""ANY"", ""lineNumber"": 105, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 103, ""argumentIndex"": 1}, {""name"": ""<operator>.logicalAnd"", ""signature"": """", ""code"": ""!no_block_check && gf_filter_pid_would_block(pid)"", ""typeFullName"": ""ANY"", ""lineNumber"": 108, ""methodFullName"": ""<operator>.logicalAnd"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": -1}, {""name"": ""gf_filter_pid_would_block"", ""signature"": """", ""code"": ""gf_filter_pid_would_block(pid)"", ""typeFullName"": ""ANY"", ""lineNumber"": 108, ""methodFullName"": ""gf_filter_pid_would_block"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 25, ""argumentIndex"": 2}, {""name"": ""<operator>.assignment"", ""signature"": """", ""code"": ""count = gf_fq_count(pid->filter->pcks_alloc_reservoir)"", ""typeFullName"": ""ANY"", ""lineNumber"": 111, ""methodFullName"": ""<operator>.assignment"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""gf_fq_count"", ""signature"": """", ""code"": ""gf_fq_count(pid->filter->pcks_alloc_reservoir)"", ""typeFullName"": ""ANY"", ""lineNumber"": 111, ""methodFullName"": ""gf_fq_count"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 10, ""argumentIndex"": 2}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter->pcks_alloc_reservoir"", ""typeFullName"": ""ANY"", ""lineNumber"": 111, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 22, ""argumentIndex"": 1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter"", ""typeFullName"": ""ANY"", ""lineNumber"": 111, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 22, ""argumentIndex"": 1}, {""name"": ""gf_fq_enum"", ""signature"": """", ""code"": ""gf_fq_enum(pid->filter->pcks_alloc_reservoir, pck_queue_enum, &pck_enum_state)"", ""typeFullName"": ""void"", ""lineNumber"": 116, ""methodFullName"": ""gf_fq_enum"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 3, ""argumentIndex"": -1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter->pcks_alloc_reservoir"", ""typeFullName"": ""ANY"", ""lineNumber"": 116, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 14, ""argumentIndex"": 1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter"", ""typeFullName"": ""ANY"", ""lineNumber"": 116, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 14, ""argumentIndex"": 1}, {""name"": ""<operator>.assignment"", ""signature"": """", ""code"": ""max_reservoir_size = pid->num_destinations ? 10 : 1"", ""typeFullName"": ""ANY"", ""lineNumber"": 122, ""methodFullName"": ""<operator>.assignment"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}, {""name"": ""<operator>.conditional"", ""signature"": """", ""code"": ""pid->num_destinations ? 10 : 1"", ""typeFullName"": ""ANY"", ""lineNumber"": 122, ""methodFullName"": ""<operator>.conditional"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 23, ""argumentIndex"": 2}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->num_destinations"", ""typeFullName"": ""ANY"", ""lineNumber"": 122, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 23, ""argumentIndex"": 1}, {""name"": ""<operator>.logicalAnd"", ""signature"": """", ""code"": ""!pck && (pid->stream_type==GF_STREAM_FILE)"", ""typeFullName"": ""ANY"", ""lineNumber"": 124, ""methodFullName"": ""<operator>.logicalAnd"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 6, ""argumentIndex"": -1}, {""name"": ""<operator>.equals"", ""signature"": """", ""code"": ""pid->stream_type==GF_STREAM_FILE"", ""typeFullName"": ""ANY"", ""lineNumber"": 124, ""methodFullName"": ""<operator>.equals"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 15, ""argumentIndex"": 2}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->stream_type"", ""typeFullName"": ""ANY"", ""lineNumber"": 124, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 15, ""argumentIndex"": 1}, {""name"": ""<operator>.assignment"", ""signature"": """", ""code"": ""*head_pck = gf_fq_pop(pid->filter->pcks_alloc_reservoir)"", ""typeFullName"": ""GF_FilterPacket*"", ""lineNumber"": 152, ""methodFullName"": ""<operator>.assignment"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 19, ""argumentIndex"": 2}, {""name"": ""gf_fq_pop"", ""signature"": """", ""code"": ""gf_fq_pop(pid->filter->pcks_alloc_reservoir)"", ""typeFullName"": ""void*"", ""lineNumber"": 152, ""methodFullName"": ""gf_fq_pop"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 31, ""argumentIndex"": 2}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter->pcks_alloc_reservoir"", ""typeFullName"": ""ANY"", ""lineNumber"": 152, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 41, ""argumentIndex"": 1}, {""name"": ""<operator>.indirectFieldAccess"", ""signature"": """", ""code"": ""pid->filter"", ""typeFullName"": ""ANY"", ""lineNumber"": 152, ""methodFullName"": ""<operator>.indirectFieldAccess"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 41, ""argumentIndex"": 1}, {""name"": ""gf_filter_pck_reset_props"", ""signature"": """", ""code"": ""gf_filter_pck_reset_props(pck, pid)"", ""typeFullName"": ""void"", ""lineNumber"": 167, ""methodFullName"": ""gf_filter_pck_reset_props"", ""dispatchType"": ""STATIC_DISPATCH"", ""columnNumber"": 2, ""argumentIndex"": -1}]}]","av1dmx_parse_flush_sample() in src/filters/reframe_av1.c:740-743 (patched) passes 'ctx->opid' to gf_filter_pck_new_alloc_internal() without validation. gf_filter_pck_new_alloc_internal() in src/filter_core/filter_pck.c:104-105 (via PID_IS_INPUT(pid)) dereferences 'pid->pid' and 'pid->filter->name', causing a NULL pointer dereference if 'pid' is NULL.",0.95,./github/other_context/CVE-2021-30015
77,CVE-2021-32276,CWE-476,c_cpp,An issue was discovered in faad2 through 2.10.0. A NULL pointer dereference exists in the function get_sample() located in output.c. It allows an attacker to cause Denial of Service.,https://github.com/knik0/faad2/commit/b58840121d1827b4b6c7617e2431589af1776ddc,Check for error after each channel decode.\n\nhInfo->error is reset within the decode_* functions. This caused the decoder\nto ignore errors for some channels in the error resilience (ER) code path.\n\nFixes #58.,2,"[{""func_name"": ""raw_data_block"", ""file_path"": ""libfaad/syntax.c"", ""func_code"": ""void raw_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                    bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t id_syn_ele;\n    uint8_t ele_this_frame = 0;\n\n    hDecoder->fr_channels = 0;\n    hDecoder->fr_ch_ele = 0;\n    hDecoder->first_syn_ele = 25;\n    hDecoder->has_lfe = 0;\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->object_type < ER_OBJECT_START)\n    {\n#endif\n        /* Table 4.4.3: raw_data_block() */\n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\""NeAACDecDecode(): id_syn_ele\""))) != ID_END)\n        {\n            switch (id_syn_ele) {\n            case ID_SCE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CPE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_cpe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_LFE:\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n                hDecoder->has_lfe++;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CCE: /* not implemented yet, but skip the bits */\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n#ifdef COUPLING_DEC\n                hInfo->error = coupling_channel_element(hDecoder, ld);\n#else\n                hInfo->error = 6;\n#endif\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_DSE:\n                ele_this_frame++;\n                data_stream_element(hDecoder, ld);\n                break;\n            case ID_PCE:\n                if (ele_this_frame != 0)\n                {\n                    hInfo->error = 31;\n                    return;\n                }\n                ele_this_frame++;\n                /* 14496-4: 5.6.4.1.2.1.3: */\n                /* program_configuration_element()'s in access units shall be ignored */\n                program_config_element(pce, ld);\n                //if ((hInfo->error = program_config_element(pce, ld)) > 0)\n                //    return;\n                //hDecoder->pce_set = 1;\n                break;\n            case ID_FIL:\n                ele_this_frame++;\n                /* one sbr_info describes a channel_element not a channel! */\n                /* if we encounter SBR data here: error */\n                /* SBR data will be read directly in the SCE/LFE/CPE element */\n                if ((hInfo->error = fill_element(hDecoder, ld, drc\n#ifdef SBR_DEC\n                    , INVALID_SBR_ELEMENT\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n        }\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* Table 262: er_raw_data_block() */\n        switch (hDecoder->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 7: /* 8 channels */\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        default:\n            hInfo->error = 7;\n            return;\n        }\n#if 0\n        cnt = bits_to_decode() / 8;\n        while (cnt >= 1)\n        {\n            cnt -= extension_payload(cnt);\n        }\n#endif\n    }\n#endif\n\n    /* new in corrigendum 14496-3:2002 */\n#ifdef DRM\n    if (hDecoder->object_type != DRM_ER_LC\n#if 0\n        && !hDecoder->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(ld);\n    }\n\n    return;\n}"", ""target"": 0}, {""func_name"": ""decodeAACfile"", ""file_path"": ""frontend/main.c"", ""func_code"": ""static int decodeAACfile(char *aacfile, char *sndfile, char *adts_fn, int to_stdout,\n                  int def_srate, int object_type, int outputFormat, int fileType,\n                  int downMatrix, int infoOnly, int adts_out, int old_format,\n                  float *song_length)\n{\n    int tagsize;\n    unsigned long samplerate;\n    unsigned char channels;\n    void *sample_buffer;\n\n    audio_file *aufile = NULL;\n\n    FILE *adtsFile = NULL;\n    unsigned char *adtsData;\n    int adtsDataSize;\n\n    NeAACDecHandle hDecoder;\n    NeAACDecFrameInfo frameInfo;\n    NeAACDecConfigurationPtr config;\n\n    char percents[MAX_PERCENTS];\n    int percent, old_percent = -1;\n    int bread, fileread;\n    int header_type = 0;\n    int bitrate = 0;\n    float length = 0;\n\n    int first_time = 1;\n    int retval;\n    int streaminput = 0;\n\n    aac_buffer b;\n\n    memset(&b, 0, sizeof(aac_buffer));\n\n    if (adts_out)\n    {\n        adtsFile = faad_fopen(adts_fn, \""wb\"");\n        if (adtsFile == NULL)\n        {\n            faad_fprintf(stderr, \""Error opening file: %s\\n\"", adts_fn);\n            return 1;\n        }\n    }\n\n    if (0 == strcmp(aacfile, \""-\""))\n    {\n        b.infile = stdin;\n#ifdef _WIN32\n        _setmode(_fileno(stdin), O_BINARY);\n#endif\n\n    }\n    else\n    {\n        b.infile = faad_fopen(aacfile, \""rb\"");\n        if (b.infile == NULL)\n        {\n            /* unable to open file */\n            faad_fprintf(stderr, \""Error opening file: %s\\n\"", aacfile);\n            return 1;\n        }\n    }\n\n    retval = fseek(b.infile, 0, SEEK_END);\n#ifdef _WIN32\n    if (0 == strcmp(aacfile, \""-\"")) {\n        retval = -1;\n    }\n#endif\n    if (retval )\n    {\n        faad_fprintf(stderr, \""Input not seekable %s\\n\"", aacfile);\n        fileread = -1;\n        streaminput = 1;\n    } else {\n        fileread = ftell(b.infile);\n        fseek(b.infile, 0, SEEK_SET);\n    };\n\n    if (!(b.buffer = (unsigned char*)malloc(FAAD_MIN_STREAMSIZE*MAX_CHANNELS)))\n    {\n        faad_fprintf(stderr, \""Memory allocation error\\n\"");\n        return 0;\n    }\n    memset(b.buffer, 0, FAAD_MIN_STREAMSIZE*MAX_CHANNELS);\n\n    bread = fread(b.buffer, 1, FAAD_MIN_STREAMSIZE*MAX_CHANNELS, b.infile);\n    b.bytes_into_buffer = bread;\n    b.bytes_consumed = 0;\n    b.file_offset = 0;\n\n    if (bread != FAAD_MIN_STREAMSIZE*MAX_CHANNELS)\n        b.at_eof = 1;\n\n    tagsize = 0;\n    if (!memcmp(b.buffer, \""ID3\"", 3))\n    {\n        /* high bit is not used */\n        tagsize = (b.buffer[6] << 21) | (b.buffer[7] << 14) |\n            (b.buffer[8] <<  7) | (b.buffer[9] <<  0);\n\n        tagsize += 10;\n        advance_buffer(&b, tagsize);\n        fill_buffer(&b);\n    }\n\n    hDecoder = NeAACDecOpen();\n\n    /* Set the default object type and samplerate */\n    /* This is useful for RAW AAC files */\n    config = NeAACDecGetCurrentConfiguration(hDecoder);\n    if (def_srate)\n        config->defSampleRate = def_srate;\n    config->defObjectType = object_type;\n    config->outputFormat = outputFormat;\n    config->downMatrix = downMatrix;\n    config->useOldADTSFormat = old_format;\n    //config->dontUpSampleImplicitSBR = 1;\n    NeAACDecSetConfiguration(hDecoder, config);\n\n    /* get AAC infos for printing */\n    header_type = 0;\n    if (streaminput == 1)\n        lookforheader(&b);\n\n    if ((b.buffer[0] == 0xFF) && ((b.buffer[1] & 0xF6) == 0xF0))\n    {\n        if (streaminput == 1)\n        {\n            int /*frames,*/ frame_length;\n            int samplerate;\n            float frames_per_sec, bytes_per_frame;\n            channels = 2;\n            samplerate = adts_sample_rates[(b.buffer[2]&0x3c)>>2];\n            frame_length = ((((unsigned int)b.buffer[3] & 0x3)) << 11)\n                | (((unsigned int)b.buffer[4]) << 3) | (b.buffer[5] >> 5);\n            frames_per_sec = (float)samplerate/1024.0f;\n            bytes_per_frame = (float)frame_length/(float)(1000);\n            bitrate = (int)(8. * bytes_per_frame * frames_per_sec + 0.5);\n            length = 1;\n            faad_fprintf(stderr, \""Streamed input format  samplerate %d channels %d.\\n\"", samplerate, channels);\n        } else {\n            adts_parse(&b, &bitrate, &length);\n            fseek(b.infile, tagsize, SEEK_SET);\n\n            bread = fread(b.buffer, 1, FAAD_MIN_STREAMSIZE*MAX_CHANNELS, b.infile);\n            if (bread != FAAD_MIN_STREAMSIZE*MAX_CHANNELS)\n                b.at_eof = 1;\n            else\n                b.at_eof = 0;\n            b.bytes_into_buffer = bread;\n            b.bytes_consumed = 0;\n            b.file_offset = tagsize;\n        }\n\n        header_type = 1;\n    }\n    else if (memcmp(b.buffer, \""ADIF\"", 4) == 0)\n    {\n        int skip_size = (b.buffer[4] & 0x80) ? 9 : 0;\n        bitrate = ((unsigned int)(b.buffer[4 + skip_size] & 0x0F)<<19) |\n            ((unsigned int)b.buffer[5 + skip_size]<<11) |\n            ((unsigned int)b.buffer[6 + skip_size]<<3) |\n            ((unsigned int)b.buffer[7 + skip_size] & 0xE0);\n\n        length = (float)fileread;\n        if (length != 0)\n        {\n            length = ((float)length*8.f)/((float)bitrate) + 0.5f;\n        }\n\n        bitrate = (int)((float)bitrate/1000.0f + 0.5f);\n\n        header_type = 2;\n    }\n\n    *song_length = length;\n\n    fill_buffer(&b);\n    if ((bread = NeAACDecInit(hDecoder, b.buffer,\n        b.bytes_into_buffer, &samplerate, &channels)) < 0)\n    {\n        /* If some error initializing occured, skip the file */\n        faad_fprintf(stderr, \""Error initializing decoder library.\\n\"");\n        if (b.buffer)\n            free(b.buffer);\n        NeAACDecClose(hDecoder);\n        if (b.infile != stdin)\n            fclose(b.infile);\n        return 1;\n    }\n    advance_buffer(&b, bread);\n    fill_buffer(&b);\n\n    /* print AAC file info */\n    faad_fprintf(stderr, \""%s file info:\\n\"", aacfile);\n    switch (header_type)\n    {\n    case 0:\n        faad_fprintf(stderr, \""RAW\\n\\n\"");\n        break;\n    case 1:\n        faad_fprintf(stderr, \""ADTS, %.3f sec, %d kbps, %d Hz\\n\\n\"",\n            length, bitrate, samplerate);\n        break;\n    case 2:\n        faad_fprintf(stderr, \""ADIF, %.3f sec, %d kbps, %d Hz\\n\\n\"",\n            length, bitrate, samplerate);\n        break;\n    }\n\n    if (infoOnly)\n    {\n        NeAACDecClose(hDecoder);\n        if (b.infile != stdin)\n            fclose(b.infile);\n        if (b.buffer)\n            free(b.buffer);\n        return 0;\n    }\n\n    do\n    {\n        sample_buffer = NeAACDecDecode(hDecoder, &frameInfo,\n            b.buffer, b.bytes_into_buffer);\n\n        if (adts_out == 1)\n        {\n            int skip = (old_format) ? 8 : 7;\n            adtsData = MakeAdtsHeader(&adtsDataSize, &frameInfo, old_format);\n\n            /* write the adts header */\n            fwrite(adtsData, 1, adtsDataSize, adtsFile);\n\n            /* write the frame data */\n            if (frameInfo.header_type == ADTS)\n                fwrite(b.buffer + skip, 1, frameInfo.bytesconsumed - skip, adtsFile);\n            else\n                fwrite(b.buffer, 1, frameInfo.bytesconsumed, adtsFile);\n        }\n\n        /* update buffer indices */\n        advance_buffer(&b, frameInfo.bytesconsumed);\n\n        if (frameInfo.error > 0)\n        {\n            faad_fprintf(stderr, \""Error: %s\\n\"",\n                NeAACDecGetErrorMessage(frameInfo.error));\n        }\n\n        /* open the sound file now that the number of channels are known */\n        if (first_time && !frameInfo.error)\n        {\n            /* print some channel info */\n            print_channel_info(&frameInfo);\n\n            if (!adts_out)\n            {\n                /* open output file */\n                if (!to_stdout)\n                {\n                    aufile = open_audio_file(sndfile, frameInfo.samplerate, frameInfo.channels,\n                        outputFormat, fileType, aacChannelConfig2wavexChannelMask(&frameInfo));\n                } else {\n                    aufile = open_audio_file(\""-\"", frameInfo.samplerate, frameInfo.channels,\n                        outputFormat, fileType, aacChannelConfig2wavexChannelMask(&frameInfo));\n                }\n                if (aufile == NULL)\n                {\n                    if (b.buffer)\n                        free(b.buffer);\n                    NeAACDecClose(hDecoder);\n                    if (b.infile != stdin)\n                        fclose(b.infile);\n                    return 0;\n                }\n            } else {\n                faad_fprintf(stderr, \""Writing output MPEG-4 AAC ADTS file.\\n\\n\"");\n            }\n            first_time = 0;\n        }\n\n        percent = min((int)(b.file_offset*100)/fileread, 100);\n        if (percent > old_percent)\n        {\n            old_percent = percent;\n            snprintf(percents, MAX_PERCENTS, \""%d%% decoding %s.\"", percent, aacfile);\n            faad_fprintf(stderr, \""%s\\r\"", percents);\n#ifdef _WIN32\n            SetConsoleTitle(percents);\n#endif\n        }\n\n        if ((frameInfo.error == 0) && (frameInfo.samples > 0) && (!adts_out))\n        {\n            if (write_audio_file(aufile, sample_buffer, frameInfo.samples, 0) == 0)\n                break;\n        }\n\n        /* fill buffer */\n        fill_buffer(&b);\n\n        if (b.bytes_into_buffer == 0)\n            sample_buffer = NULL; /* to make sure it stops now */\n\n    } while (sample_buffer != NULL);\n\n    NeAACDecClose(hDecoder);\n\n    if (adts_out == 1)\n    {\n        fclose(adtsFile);\n    }\n\n    if (b.infile != stdin)\n        fclose(b.infile);\n\n    if (!first_time && !adts_out)\n        close_audio_file(aufile);\n\n    if (b.buffer)\n        free(b.buffer);\n\n    return frameInfo.error;\n}"", ""target"": 1}]","[{""func_name"": ""raw_data_block"", ""file_path"": ""libfaad/syntax.c"", ""func_code"": ""void raw_data_block(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo,\n                    bitfile *ld, program_config *pce, drc_info *drc)\n{\n    uint8_t id_syn_ele;\n    uint8_t ele_this_frame = 0;\n\n    hDecoder->fr_channels = 0;\n    hDecoder->fr_ch_ele = 0;\n    hDecoder->first_syn_ele = 25;\n    hDecoder->has_lfe = 0;\n\n#ifdef ERROR_RESILIENCE\n    if (hDecoder->object_type < ER_OBJECT_START)\n    {\n#endif\n        /* Table 4.4.3: raw_data_block() */\n        while ((id_syn_ele = (uint8_t)faad_getbits(ld, LEN_SE_ID\n            DEBUGVAR(1,4,\""NeAACDecDecode(): id_syn_ele\""))) != ID_END)\n        {\n            switch (id_syn_ele) {\n            case ID_SCE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CPE:\n                ele_this_frame++;\n                if (hDecoder->first_syn_ele == 25) hDecoder->first_syn_ele = id_syn_ele;\n                decode_cpe(hDecoder, hInfo, ld, id_syn_ele);\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_LFE:\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n                hDecoder->has_lfe++;\n                decode_sce_lfe(hDecoder, hInfo, ld, id_syn_ele);\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_CCE: /* not implemented yet, but skip the bits */\n#ifdef DRM\n                hInfo->error = 32;\n#else\n                ele_this_frame++;\n#ifdef COUPLING_DEC\n                hInfo->error = coupling_channel_element(hDecoder, ld);\n#else\n                hInfo->error = 6;\n#endif\n#endif\n                if (hInfo->error > 0)\n                    return;\n                break;\n            case ID_DSE:\n                ele_this_frame++;\n                data_stream_element(hDecoder, ld);\n                break;\n            case ID_PCE:\n                if (ele_this_frame != 0)\n                {\n                    hInfo->error = 31;\n                    return;\n                }\n                ele_this_frame++;\n                /* 14496-4: 5.6.4.1.2.1.3: */\n                /* program_configuration_element()'s in access units shall be ignored */\n                program_config_element(pce, ld);\n                //if ((hInfo->error = program_config_element(pce, ld)) > 0)\n                //    return;\n                //hDecoder->pce_set = 1;\n                break;\n            case ID_FIL:\n                ele_this_frame++;\n                /* one sbr_info describes a channel_element not a channel! */\n                /* if we encounter SBR data here: error */\n                /* SBR data will be read directly in the SCE/LFE/CPE element */\n                if ((hInfo->error = fill_element(hDecoder, ld, drc\n#ifdef SBR_DEC\n                    , INVALID_SBR_ELEMENT\n#endif\n                    )) > 0)\n                    return;\n                break;\n            }\n        }\n#ifdef ERROR_RESILIENCE\n    } else {\n        /* Table 262: er_raw_data_block() */\n        switch (hDecoder->channelConfiguration)\n        {\n        case 1:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 2:\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 3:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 4:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 5:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 6:\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        case 7: /* 8 channels */\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_SCE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_cpe(hDecoder, hInfo, ld, ID_CPE);\n            if (hInfo->error > 0)\n                return;\n            decode_sce_lfe(hDecoder, hInfo, ld, ID_LFE);\n            if (hInfo->error > 0)\n                return;\n            break;\n        default:\n            hInfo->error = 7;\n            return;\n        }\n#if 0\n        cnt = bits_to_decode() / 8;\n        while (cnt >= 1)\n        {\n            cnt -= extension_payload(cnt);\n        }\n#endif\n    }\n#endif\n\n    /* new in corrigendum 14496-3:2002 */\n#ifdef DRM\n    if (hDecoder->object_type != DRM_ER_LC\n#if 0\n        && !hDecoder->latm_header_present\n#endif\n        )\n#endif\n    {\n        faad_byte_align(ld);\n    }\n\n    return;\n}""}, {""func_name"": ""decodeAACfile"", ""file_path"": ""frontend/main.c"", ""func_code"": ""static int decodeAACfile(char *aacfile, char *sndfile, char *adts_fn, int to_stdout,\n                  int def_srate, int object_type, int outputFormat, int fileType,\n                  int downMatrix, int infoOnly, int adts_out, int old_format,\n                  float *song_length)\n{\n    int tagsize;\n    unsigned long samplerate;\n    unsigned char channels;\n    void *sample_buffer;\n\n    audio_file *aufile = NULL;\n\n    FILE *adtsFile = NULL;\n    unsigned char *adtsData;\n    int adtsDataSize;\n\n    NeAACDecHandle hDecoder;\n    NeAACDecFrameInfo frameInfo;\n    NeAACDecConfigurationPtr config;\n\n    char percents[MAX_PERCENTS];\n    int percent, old_percent = -1;\n    int bread, fileread;\n    int header_type = 0;\n    int bitrate = 0;\n    float length = 0;\n\n    int first_time = 1;\n    int retval;\n    int streaminput = 0;\n\n    aac_buffer b;\n\n    memset(&b, 0, sizeof(aac_buffer));\n\n    if (adts_out)\n    {\n        adtsFile = faad_fopen(adts_fn, \""wb\"");\n        if (adtsFile == NULL)\n        {\n            faad_fprintf(stderr, \""Error opening file: %s\\n\"", adts_fn);\n            return 1;\n        }\n    }\n\n    if (0 == strcmp(aacfile, \""-\""))\n    {\n        b.infile = stdin;\n#ifdef _WIN32\n        _setmode(_fileno(stdin), O_BINARY);\n#endif\n\n    }\n    else\n    {\n        b.infile = faad_fopen(aacfile, \""rb\"");\n        if (b.infile == NULL)\n        {\n            /* unable to open file */\n            faad_fprintf(stderr, \""Error opening file: %s\\n\"", aacfile);\n            return 1;\n        }\n    }\n\n    retval = fseek(b.infile, 0, SEEK_END);\n#ifdef _WIN32\n    if (0 == strcmp(aacfile, \""-\"")) {\n        retval = -1;\n    }\n#endif\n    if (retval )\n    {\n        faad_fprintf(stderr, \""Input not seekable %s\\n\"", aacfile);\n        fileread = -1;\n        streaminput = 1;\n    } else {\n        fileread = ftell(b.infile);\n        fseek(b.infile, 0, SEEK_SET);\n    };\n\n    if (!(b.buffer = (unsigned char*)malloc(FAAD_MIN_STREAMSIZE*MAX_CHANNELS)))\n    {\n        faad_fprintf(stderr, \""Memory allocation error\\n\"");\n        return 0;\n    }\n    memset(b.buffer, 0, FAAD_MIN_STREAMSIZE*MAX_CHANNELS);\n\n    bread = fread(b.buffer, 1, FAAD_MIN_STREAMSIZE*MAX_CHANNELS, b.infile);\n    b.bytes_into_buffer = bread;\n    b.bytes_consumed = 0;\n    b.file_offset = 0;\n\n    if (bread != FAAD_MIN_STREAMSIZE*MAX_CHANNELS)\n        b.at_eof = 1;\n\n    tagsize = 0;\n    if (!memcmp(b.buffer, \""ID3\"", 3))\n    {\n        /* high bit is not used */\n        tagsize = (b.buffer[6] << 21) | (b.buffer[7] << 14) |\n            (b.buffer[8] <<  7) | (b.buffer[9] <<  0);\n\n        tagsize += 10;\n        advance_buffer(&b, tagsize);\n        fill_buffer(&b);\n    }\n\n    hDecoder = NeAACDecOpen();\n\n    /* Set the default object type and samplerate */\n    /* This is useful for RAW AAC files */\n    config = NeAACDecGetCurrentConfiguration(hDecoder);\n    if (def_srate)\n        config->defSampleRate = def_srate;\n    config->defObjectType = object_type;\n    config->outputFormat = outputFormat;\n    config->downMatrix = downMatrix;\n    config->useOldADTSFormat = old_format;\n    //config->dontUpSampleImplicitSBR = 1;\n    NeAACDecSetConfiguration(hDecoder, config);\n\n    /* get AAC infos for printing */\n    header_type = 0;\n    if (streaminput == 1)\n        lookforheader(&b);\n\n    if ((b.buffer[0] == 0xFF) && ((b.buffer[1] & 0xF6) == 0xF0))\n    {\n        if (streaminput == 1)\n        {\n            int /*frames,*/ frame_length;\n            int samplerate;\n            float frames_per_sec, bytes_per_frame;\n            channels = 2;\n            samplerate = adts_sample_rates[(b.buffer[2]&0x3c)>>2];\n            frame_length = ((((unsigned int)b.buffer[3] & 0x3)) << 11)\n                | (((unsigned int)b.buffer[4]) << 3) | (b.buffer[5] >> 5);\n            frames_per_sec = (float)samplerate/1024.0f;\n            bytes_per_frame = (float)frame_length/(float)(1000);\n            bitrate = (int)(8. * bytes_per_frame * frames_per_sec + 0.5);\n            length = 1;\n            faad_fprintf(stderr, \""Streamed input format  samplerate %d channels %d.\\n\"", samplerate, channels);\n        } else {\n            adts_parse(&b, &bitrate, &length);\n            fseek(b.infile, tagsize, SEEK_SET);\n\n            bread = fread(b.buffer, 1, FAAD_MIN_STREAMSIZE*MAX_CHANNELS, b.infile);\n            if (bread != FAAD_MIN_STREAMSIZE*MAX_CHANNELS)\n                b.at_eof = 1;\n            else\n                b.at_eof = 0;\n            b.bytes_into_buffer = bread;\n            b.bytes_consumed = 0;\n            b.file_offset = tagsize;\n        }\n\n        header_type = 1;\n    }\n    else if (memcmp(b.buffer, \""ADIF\"", 4) == 0)\n    {\n        int skip_size = (b.buffer[4] & 0x80) ? 9 : 0;\n        bitrate = ((unsigned int)(b.buffer[4 + skip_size] & 0x0F)<<19) |\n            ((unsigned int)b.buffer[5 + skip_size]<<11) |\n            ((unsigned int)b.buffer[6 + skip_size]<<3) |\n            ((unsigned int)b.buffer[7 + skip_size] & 0xE0);\n\n        length = (float)fileread;\n        if (length != 0)\n        {\n            length = ((float)length*8.f)/((float)bitrate) + 0.5f;\n        }\n\n        bitrate = (int)((float)bitrate/1000.0f + 0.5f);\n\n        header_type = 2;\n    }\n\n    *song_length = length;\n\n    fill_buffer(&b);\n    if ((bread = NeAACDecInit(hDecoder, b.buffer,\n        b.bytes_into_buffer, &samplerate, &channels)) < 0)\n    {\n        /* If some error initializing occured, skip the file */\n        faad_fprintf(stderr, \""Error initializing decoder library.\\n\"");\n        if (b.buffer)\n            free(b.buffer);\n        NeAACDecClose(hDecoder);\n        if (b.infile != stdin)\n            fclose(b.infile);\n        return 1;\n    }\n    advance_buffer(&b, bread);\n    fill_buffer(&b);\n\n    /* print AAC file info */\n    faad_fprintf(stderr, \""%s file info:\\n\"", aacfile);\n    switch (header_type)\n    {\n    case 0:\n        faad_fprintf(stderr, \""RAW\\n\\n\"");\n        break;\n    case 1:\n        faad_fprintf(stderr, \""ADTS, %.3f sec, %d kbps, %d Hz\\n\\n\"",\n            length, bitrate, samplerate);\n        break;\n    case 2:\n        faad_fprintf(stderr, \""ADIF, %.3f sec, %d kbps, %d Hz\\n\\n\"",\n            length, bitrate, samplerate);\n        break;\n    }\n\n    if (infoOnly)\n    {\n        NeAACDecClose(hDecoder);\n        if (b.infile != stdin)\n            fclose(b.infile);\n        if (b.buffer)\n            free(b.buffer);\n        return 0;\n    }\n\n    do\n    {\n        sample_buffer = NeAACDecDecode(hDecoder, &frameInfo,\n            b.buffer, b.bytes_into_buffer);\n\n        if (adts_out == 1)\n        {\n            int skip = (old_format) ? 8 : 7;\n            adtsData = MakeAdtsHeader(&adtsDataSize, &frameInfo, old_format);\n\n            /* write the adts header */\n            fwrite(adtsData, 1, adtsDataSize, adtsFile);\n\n            /* write the frame data */\n            if (frameInfo.header_type == ADTS)\n                fwrite(b.buffer + skip, 1, frameInfo.bytesconsumed - skip, adtsFile);\n            else\n                fwrite(b.buffer, 1, frameInfo.bytesconsumed, adtsFile);\n        }\n\n        /* update buffer indices */\n        advance_buffer(&b, frameInfo.bytesconsumed);\n\n        /* check if the inconsistent number of channels */\n        if (aufile != NULL && frameInfo.channels != aufile->channels)\n            frameInfo.error = 12;\n\n        if (frameInfo.error > 0)\n        {\n            faad_fprintf(stderr, \""Error: %s\\n\"",\n                NeAACDecGetErrorMessage(frameInfo.error));\n        }\n\n        /* open the sound file now that the number of channels are known */\n        if (first_time && !frameInfo.error)\n        {\n            /* print some channel info */\n            print_channel_info(&frameInfo);\n\n            if (!adts_out)\n            {\n                /* open output file */\n                if (!to_stdout)\n                {\n                    aufile = open_audio_file(sndfile, frameInfo.samplerate, frameInfo.channels,\n                        outputFormat, fileType, aacChannelConfig2wavexChannelMask(&frameInfo));\n                } else {\n                    aufile = open_audio_file(\""-\"", frameInfo.samplerate, frameInfo.channels,\n                        outputFormat, fileType, aacChannelConfig2wavexChannelMask(&frameInfo));\n                }\n                if (aufile == NULL)\n                {\n                    if (b.buffer)\n                        free(b.buffer);\n                    NeAACDecClose(hDecoder);\n                    if (b.infile != stdin)\n                        fclose(b.infile);\n                    return 0;\n                }\n            } else {\n                faad_fprintf(stderr, \""Writing output MPEG-4 AAC ADTS file.\\n\\n\"");\n            }\n            first_time = 0;\n        }\n\n        percent = min((int)(b.file_offset*100)/fileread, 100);\n        if (percent > old_percent)\n        {\n            old_percent = percent;\n            snprintf(percents, MAX_PERCENTS, \""%d%% decoding %s.\"", percent, aacfile);\n            faad_fprintf(stderr, \""%s\\r\"", percents);\n#ifdef _WIN32\n            SetConsoleTitle(percents);\n#endif\n        }\n\n        if ((frameInfo.error == 0) && (frameInfo.samples > 0) && (!adts_out))\n        {\n            if (write_audio_file(aufile, sample_buffer, frameInfo.samples, 0) == 0)\n                break;\n        }\n\n        /* fill buffer */\n        fill_buffer(&b);\n\n        if (b.bytes_into_buffer == 0)\n            sample_buffer = NULL; /* to make sure it stops now */\n\n    } while (sample_buffer != NULL);\n\n    NeAACDecClose(hDecoder);\n\n    if (adts_out == 1)\n    {\n        fclose(adtsFile);\n    }\n\n    if (b.infile != stdin)\n        fclose(b.infile);\n\n    if (!first_time && !adts_out)\n        close_audio_file(aufile);\n\n    if (b.buffer)\n        free(b.buffer);\n\n    return frameInfo.error;\n}""}]","{""function"": 1, ""value"": 4, ""code"": 3}","[{""source"": ""func_info(func:get_sample)"", ""result"": [{""code"": ""static INLINE real_t get_sample(real_t **input, uint8_t channel, uint16_t sample,\n                                uint8_t down_matrix, uint8_t *internal_channel)\n{\n    if (!down_matrix)\n        return input[internal_channel[channel]][sample];\n\n    if (channel == 0)\n    {\n        return DM_MUL * (input[internal_channel[1]][sample] +\n            input[internal_channel[0]][sample] * RSQRT2 +\n            input[internal_channel[3]][sample] * RSQRT2);\n    } else {\n        return DM_MUL * (input[internal_channel[2]][sample] +\n            input[internal_channel[0]][sample] * RSQRT2 +\n            input[internal_channel[4]][sample] * RSQRT2);\n    }\n}"", ""start_line"": 45, ""end_line"": 61, ""full_name"": ""get_sample"", ""file_path"": ""libfaad/output.c""}, {""code"": ""static INLINE real_t get_sample(real_t **input, uint8_t channel, uint16_t sample,\n                                uint8_t down_matrix, uint8_t up_matrix,\n                                uint8_t *internal_channel)\n{\n    if (up_matrix == 1)\n        return input[internal_channel[0]][sample];\n\n    if (!down_matrix)\n        return input[internal_channel[channel]][sample];\n\n    if (channel == 0)\n    {\n        real_t C   = MUL_F(input[internal_channel[0]][sample], RSQRT2);\n        real_t L_S = MUL_F(input[internal_channel[3]][sample], RSQRT2);\n        real_t cum = input[internal_channel[1]][sample] + C + L_S;\n        return MUL_F(cum, DM_MUL);\n    } else {\n        real_t C   = MUL_F(input[internal_channel[0]][sample], RSQRT2);\n        real_t R_S = MUL_F(input[internal_channel[4]][sample], RSQRT2);\n        real_t cum = input[internal_channel[2]][sample] + C + R_S;\n        return MUL_F(cum, DM_MUL);\n    }\n}"", ""start_line"": 444, ""end_line"": 466, ""full_name"": ""get_sample<duplicate>0"", ""file_path"": ""libfaad/output.c""}]}, {""source"": ""value_info(file:syntax.c, value:hInfo->error)"", ""result"": {""value_trace"": [{""full_code"": ""hInfo->error = 12"", ""line"": 334, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hInfo->error = 13"", ""line"": 339, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hInfo->error = 21"", ""line"": 351, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hInfo->error = single_lfe_channel_element(hDecoder, ld, channels, &tag)"", ""line"": 359, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hInfo->error = 12"", ""line"": 386, ""func_name"": ""decode_cpe""}], ""struct_var"": ""hInfo"", ""struct_type"": ""NeAACDecFrameInfo*"", ""struct_definition"": ""typedef struct NeAACDecFrameInfo\n{\n    unsigned long bytesconsumed;\n    unsigned long samples;\n    unsigned char channels;\n    unsigned char error;\n    unsigned long samplerate;\n\n    /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */\n    unsigned char sbr;\n\n    /* MPEG-4 ObjectType */\n    unsigned char object_type;\n\n    /* AAC header type; MP4 will be signalled as RAW also */\n    unsigned char header_type;\n\n    /* multichannel configuration */\n    unsigned char num_front_channels;\n    unsigned char num_side_channels;\n    unsigned char num_back_channels;\n    unsigned char num_lfe_channels;\n    unsigned char channel_position[64];\n\n    /* PS: 0: off, 1: on */\n    unsigned char ps;\n}\n\ntypedef struct NeAACDecFrameInfo\n{\n    unsigned long bytesconsumed;\n    unsigned long samples;\n    unsigned char channels;\n    unsigned char error;\n    unsigned long samplerate;\n\n    /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */\n    unsigned char sbr;\n\n    /* MPEG-4 ObjectType */\n    unsigned char object_type;\n\n    /* AAC header type; MP4 will be signalled as RAW also */\n    unsigned char header_type;\n\n    /* multichannel configuration */\n    unsigned char num_front_channels;\n    unsigned char num_side_channels;\n    unsigned char num_back_channels;\n    unsigned char num_lfe_channels;\n    unsigned char channel_position[64];\n\n    /* PS: 0: off, 1: on */\n    unsigned char ps;\n} NeAACDecFrameInfo;\n\ntypedef struct NeAACDecFrameInfo\n{\n    unsigned long bytesconsumed;\n    unsigned long samples;\n    unsigned char channels;\n    unsigned char error;\n    unsigned long samplerate;\n\n    /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */\n    unsigned char sbr;\n\n    /* MPEG-4 ObjectType */\n    unsigned char object_type;\n\n    /* AAC header type; MP4 will be signalled as RAW also */\n    unsigned char header_type;\n\n    /* multichannel configuration */\n    unsigned char num_front_channels;\n    unsigned char num_side_channels;\n    unsigned char num_back_channels;\n    unsigned char num_lfe_channels;\n    unsigned char channel_position[64];\n\n    /* PS: 0: off, 1: on */\n    unsigned char ps;\n}\n\ntypedef struct NeAACDecFrameInfo\n{\n    unsigned long bytesconsumed;\n    unsigned long samples;\n    unsigned char channels;\n    unsigned char error;\n    unsigned long samplerate;\n\n    /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */\n    unsigned char sbr;\n\n    /* MPEG-4 ObjectType */\n    unsigned char object_type;\n\n    /* AAC header type; MP4 will be signalled as RAW also */\n    unsigned char header_type;\n\n    /* multichannel configuration */\n    unsigned char num_front_channels;\n    unsigned char num_side_channels;\n    unsigned char num_back_channels;\n    unsigned char num_lfe_channels;\n    unsigned char channel_position[64];\n\n    /* PS: 0: off, 1: on */\n    unsigned char ps;\n} NeAACDecFrameInfo;""}}, {""source"": ""code_info(file:output.c, lines:100-200)"", ""result"": ""        for(i = 0; i < frame_len; i++)\n        {\n            real_t inp = input[hDecoder->internal_channel[0]][i];\n\n            CLIP(inp, 32767.0f, -32768.0f);\n\n            (*sample_buffer)[i] = (int16_t)lrintf(inp);\n        }\n        break;\n    case CONV(2,0):\n        if (hDecoder->upMatrix)\n        {\n            ch  = hDecoder->internal_channel[0];\n            for(i = 0; i < frame_len; i++)\n            {\n                real_t inp0 = input[ch][i];\n\n                CLIP(inp0, 32767.0f, -32768.0f);\n\n                (*sample_buffer)[(i*2)+0] = (int16_t)lrintf(inp0);\n                (*sample_buffer)[(i*2)+1] = (int16_t)lrintf(inp0);\n            }\n        } else {\n            ch  = hDecoder->internal_channel[0];\n            ch1 = hDecoder->internal_channel[1];\n            for(i = 0; i < frame_len; i++)\n            {\n                real_t inp0 = input[ch ][i];\n                real_t inp1 = input[ch1][i];\n\n                CLIP(inp0, 32767.0f, -32768.0f);\n                CLIP(inp1, 32767.0f, -32768.0f);\n\n                (*sample_buffer)[(i*2)+0] = (int16_t)lrintf(inp0);\n                (*sample_buffer)[(i*2)+1] = (int16_t)lrintf(inp1);\n            }\n        }\n        break;\n    default:\n        for (ch = 0; ch < channels; ch++)\n        {\n            for(i = 0; i < frame_len; i++)\n            {\n                real_t inp = get_sample(input, ch, i, hDecoder->downMatrix, hDecoder->internal_channel);\n\n                CLIP(inp, 32767.0f, -32768.0f);\n\n                (*sample_buffer)[(i*channels)+ch] = (int16_t)lrintf(inp);\n            }\n        }\n        break;\n    }\n}\n\nstatic void to_PCM_24bit(NeAACDecStruct *hDecoder, real_t **input,\n                         uint8_t channels, uint16_t frame_len,\n                         int32_t **sample_buffer)\n{\n    uint8_t ch, ch1;\n    uint16_t i;\n\n    switch (CONV(channels,hDecoder->downMatrix))\n    {\n    case CONV(1,0):\n    case CONV(1,1):\n        for(i = 0; i < frame_len; i++)\n        {\n            real_t inp = input[hDecoder->internal_channel[0]][i];\n\n            inp *= 256.0f;\n            CLIP(inp, 8388607.0f, -8388608.0f);\n\n            (*sample_buffer)[i] = (int32_t)lrintf(inp);\n        }\n        break;\n    case CONV(2,0):\n        if (hDecoder->upMatrix)\n        {\n            ch = hDecoder->internal_channel[0];\n            for(i = 0; i < frame_len; i++)\n            {\n                real_t inp0 = input[ch][i];\n\n                inp0 *= 256.0f;\n                CLIP(inp0, 8388607.0f, -8388608.0f);\n\n                (*sample_buffer)[(i*2)+0] = (int32_t)lrintf(inp0);\n                (*sample_buffer)[(i*2)+1] = (int32_t)lrintf(inp0);\n            }\n        } else {\n            ch  = hDecoder->internal_channel[0];\n            ch1 = hDecoder->internal_channel[1];\n            for(i = 0; i < frame_len; i++)\n            {\n                real_t inp0 = input[ch ][i];\n                real_t inp1 = input[ch1][i];\n\n                inp0 *= 256.0f;\n                inp1 *= 256.0f;\n                CLIP(inp0, 8388607.0f, -8388608.0f);\n                CLIP(inp1, 8388607.0f, -8388608.0f);\n""}, {""source"": ""value_info(file:output.c, value:internal_channel)"", ""result"": {""value_trace"": [{""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 365, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels+1] = channels+1"", ""line"": 366, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels"", ""line"": 369, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 371, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels"", ""line"": 423, ""func_name"": ""decode_cpe""}], ""struct_var"": ""internal_channel"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:syntax.c, lines:300-400)"", ""result"": ""    {\n        pce->cc_element_is_ind_sw[i] = faad_get1bit(ld\n            DEBUGVAR(1,34,\""program_config_element(): cc_element_is_ind_sw\""));\n        pce->valid_cc_element_tag_select[i] = (uint8_t)faad_getbits(ld, 4\n            DEBUGVAR(1,35,\""program_config_element(): valid_cc_element_tag_select\""));\n    }\n\n    faad_byte_align(ld);\n\n    pce->comment_field_bytes = (uint8_t)faad_getbits(ld, 8\n        DEBUGVAR(1,36,\""program_config_element(): comment_field_bytes\""));\n\n    for (i = 0; i < pce->comment_field_bytes; i++)\n    {\n        pce->comment_field_data[i] = (uint8_t)faad_getbits(ld, 8\n            DEBUGVAR(1,37,\""program_config_element(): comment_field_data\""));\n    }\n    pce->comment_field_data[i] = 0;\n\n    if (pce->channels > MAX_CHANNELS)\n        return 22;\n\n    return 0;\n}\n\nstatic void decode_sce_lfe(NeAACDecStruct *hDecoder,\n                           NeAACDecFrameInfo *hInfo, bitfile *ld,\n                           uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+1 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for SCE hDecoder->element_output_channels[] is not set here because this\n       can become 2 when some form of Parametric Stereo coding is used\n    */\n\n    if (hDecoder->element_id[hDecoder->fr_ch_ele] != INVALID_ELEMENT_ID &&\n        hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele)\n    {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = single_lfe_channel_element(hDecoder, ld, channels, &tag);\n\n    /* map output channels position to internal data channels */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)\n    {\n        /* this might be faulty when pce_set is true */\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    } else {\n        if (hDecoder->pce_set)\n            hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels;\n        else\n            hDecoder->internal_channel[channels] = channels;\n    }\n\n    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];\n    hDecoder->fr_ch_ele++;\n}\n\nstatic void decode_cpe(NeAACDecStruct *hDecoder, NeAACDecFrameInfo *hInfo, bitfile *ld,\n                       uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+2 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for CPE the number of output channels is always 2 */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)\n    {\n        /* element_output_channels not set yet */\n        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = 2;\n    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != 2) {\n""}, {""source"": ""value_info(file:syntax.c, value:hDecoder->internal_channel)"", ""result"": {""value_trace"": [{""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 365, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels+1] = channels+1"", ""line"": 366, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels"", ""line"": 369, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 371, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels"", ""line"": 423, ""func_name"": ""decode_cpe""}], ""struct_var"": ""hDecoder"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:syntax.c, lines:100-200)"", ""result"": ""static uint8_t side_info(NeAACDecStruct *hDecoder, element *ele,\n                         bitfile *ld, ic_stream *ics, uint8_t scal_flag);\n#ifdef DRM\nstatic int8_t DRM_aac_scalable_main_header(NeAACDecStruct *hDecoder, ic_stream *ics1, ic_stream *ics2,\n                                           bitfile *ld, uint8_t this_layer_stereo);\n#endif\n\n\n/* Table 4.4.1 */\nint8_t GASpecificConfig(bitfile *ld, mp4AudioSpecificConfig *mp4ASC,\n                        program_config *pce_out)\n{\n    program_config pce;\n\n    /* 1024 or 960 */\n    mp4ASC->frameLengthFlag = faad_get1bit(ld\n        DEBUGVAR(1,138,\""GASpecificConfig(): FrameLengthFlag\""));\n#ifndef ALLOW_SMALL_FRAMELENGTH\n    if (mp4ASC->frameLengthFlag == 1)\n        return -3;\n#endif\n\n    mp4ASC->dependsOnCoreCoder = faad_get1bit(ld\n        DEBUGVAR(1,139,\""GASpecificConfig(): DependsOnCoreCoder\""));\n    if (mp4ASC->dependsOnCoreCoder == 1)\n    {\n        mp4ASC->coreCoderDelay = (uint16_t)faad_getbits(ld, 14\n            DEBUGVAR(1,140,\""GASpecificConfig(): CoreCoderDelay\""));\n    }\n\n    mp4ASC->extensionFlag = faad_get1bit(ld DEBUGVAR(1,141,\""GASpecificConfig(): ExtensionFlag\""));\n    if (mp4ASC->channelsConfiguration == 0)\n    {\n        if (program_config_element(&pce, ld))\n            return -3;\n        //mp4ASC->channelsConfiguration = pce.channels;\n\n        if (pce_out != NULL)\n            memcpy(pce_out, &pce, sizeof(program_config));\n\n        /*\n        if (pce.num_valid_cc_elements)\n            return -3;\n        */\n    }\n\n#ifdef ERROR_RESILIENCE\n    if (mp4ASC->extensionFlag == 1)\n    {\n        /* Error resilience not supported yet */\n        if (mp4ASC->objectTypeIndex >= ER_OBJECT_START)\n        {\n            mp4ASC->aacSectionDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,144,\""GASpecificConfig(): aacSectionDataResilienceFlag\""));\n            mp4ASC->aacScalefactorDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,145,\""GASpecificConfig(): aacScalefactorDataResilienceFlag\""));\n            mp4ASC->aacSpectralDataResilienceFlag = faad_get1bit(ld\n                DEBUGVAR(1,146,\""GASpecificConfig(): aacSpectralDataResilienceFlag\""));\n        }\n        /* 1 bit: extensionFlag3 */\n        faad_getbits(ld, 1);\n\t}\n#endif\n\n    return 0;\n}\n\n/* Table 4.4.2 */\n/* An MPEG-4 Audio decoder is only required to follow the Program\n   Configuration Element in GASpecificConfig(). The decoder shall ignore\n   any Program Configuration Elements that may occur in raw data blocks.\n   PCEs transmitted in raw data blocks cannot be used to convey decoder\n   configuration information.\n*/\nstatic uint8_t program_config_element(program_config *pce, bitfile *ld)\n{\n    uint8_t i;\n\n    memset(pce, 0, sizeof(program_config));\n\n    pce->channels = 0;\n\n    pce->element_instance_tag = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,10,\""program_config_element(): element_instance_tag\""));\n\n    pce->object_type = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,11,\""program_config_element(): object_type\""));\n    pce->sf_index = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,12,\""program_config_element(): sf_index\""));\n    pce->num_front_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,13,\""program_config_element(): num_front_channel_elements\""));\n    pce->num_side_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,14,\""program_config_element(): num_side_channel_elements\""));\n    pce->num_back_channel_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,15,\""program_config_element(): num_back_channel_elements\""));\n    pce->num_lfe_channel_elements = (uint8_t)faad_getbits(ld, 2\n        DEBUGVAR(1,16,\""program_config_element(): num_lfe_channel_elements\""));\n    pce->num_assoc_data_elements = (uint8_t)faad_getbits(ld, 3\n        DEBUGVAR(1,17,\""program_config_element(): num_assoc_data_elements\""));\n    pce->num_valid_cc_elements = (uint8_t)faad_getbits(ld, 4\n        DEBUGVAR(1,18,\""program_config_element(): num_valid_cc_elements\""));\n""}, {""source"": ""value_info(file:syntax.c, value:hDecoder->internal_channel)"", ""result"": {""value_trace"": [{""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 365, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels+1] = channels+1"", ""line"": 366, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels"", ""line"": 369, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[channels] = channels"", ""line"": 371, ""func_name"": ""decode_sce_lfe""}, {""full_code"": ""hDecoder->internal_channel[hDecoder->pce.cpe_channel[tag]] = channels"", ""line"": 423, ""func_name"": ""decode_cpe""}], ""struct_var"": ""hDecoder"", ""struct_type"": null, ""struct_definition"": null}}]","libfaad/syntax.c:540-575: Missing error checks after decode_* calls allowed processing to continue despite hInfo->error being set. This caused hDecoder->internal_channel assignments in decode_sce_lfe (syntax.c:365-366, 369, 371) and decode_cpe (syntax.c:423) to be skipped during error conditions. When get_sample() (output.c:45-61, 444-466) later accessed hDecoder->internal_channel[channel], it dereferenced uninitialized/invalid indices. The error resilience code path failed to reset the decoder state, propagating corrupted indices.",0.95,./github/other_context/CVE-2021-32276
78,CVE-2021-33304,CWE-415,c_cpp,"Double Free vulnerability in virtualsquare picoTCP v1.7.0 and picoTCP-NG v2.1 in modules/pico_fragments.c in function pico_fragments_reassemble, allows attackers to execute arbitrary code.",https://github.com/virtualsquare/picotcp/commit/7c195747d88a37b4059f5ad9df4bfbb6f1179e08,Fix double free in pico_fragments_reassemble(),1,"[{""func_name"": ""pico_fragments_reassemble"", ""file_path"": ""modules/pico_fragments.c"", ""func_code"": ""static int pico_fragments_reassemble(struct pico_tree *tree, unsigned int len, uint8_t proto, uint8_t net)\n{\n    struct pico_tree_node *index, *tmp;\n    struct pico_frame *f;\n    uint16_t header_length = 0;\n    unsigned int bookmark = 0;\n    struct pico_frame *full = NULL;\n    struct pico_frame *first = NULL;\n\n    if (!tree)\n    {\n        frag_dbg(\""Cannot reassemble packet, no tree supplied!\\n\"");\n        return -1;\n    }\n\n    first = pico_tree_first(tree);\n\n    if (!first)\n    {\n        frag_dbg(\""Cannot reassemble packet, empty tree supplied!\\n\"");\n        return -2;\n    }\n\n    header_length = pico_fragments_get_header_length(net);\n\n    if (!header_length)\n    {\n        return -3;\n    }\n\n    full = pico_frame_alloc((uint16_t)(header_length + len));\n    if (full) {\n        full->net_hdr = full->buffer;\n        full->net_len = header_length;\n        memcpy(full->net_hdr, first->net_hdr, full->net_len);\n        full->transport_hdr = full->net_hdr + full->net_len;\n        full->transport_len = (uint16_t)len;\n        full->dev = first->dev;\n        pico_tree_foreach_safe(index, tree, tmp) {\n            f = index->keyValue;\n            memcpy(full->transport_hdr + bookmark, f->transport_hdr, f->transport_len);\n            bookmark += f->transport_len;\n            pico_tree_delete(tree, f);\n            pico_frame_discard(f);\n        }\n        if (pico_transport_receive(full, proto) == -1)\n        {\n            pico_frame_discard(full);\n        }\n        return 0;\n    }\n\n    return 1;\n}"", ""target"": 0}]","[{""func_name"": ""pico_fragments_reassemble"", ""file_path"": ""modules/pico_fragments.c"", ""func_code"": ""static int pico_fragments_reassemble(struct pico_tree *tree, unsigned int len, uint8_t proto, uint8_t net)\n{\n    struct pico_tree_node *index, *tmp;\n    struct pico_frame *f;\n    uint16_t header_length = 0;\n    unsigned int bookmark = 0;\n    struct pico_frame *full = NULL;\n    struct pico_frame *first = NULL;\n\n    if (!tree)\n    {\n        frag_dbg(\""Cannot reassemble packet, no tree supplied!\\n\"");\n        return -1;\n    }\n\n    first = pico_tree_first(tree);\n\n    if (!first)\n    {\n        frag_dbg(\""Cannot reassemble packet, empty tree supplied!\\n\"");\n        return -2;\n    }\n\n    header_length = pico_fragments_get_header_length(net);\n\n    if (!header_length)\n    {\n        return -3;\n    }\n\n    full = pico_frame_alloc((uint16_t)(header_length + len));\n    if (full) {\n        full->net_hdr = full->buffer;\n        full->net_len = header_length;\n        memcpy(full->net_hdr, first->net_hdr, full->net_len);\n        full->transport_hdr = full->net_hdr + full->net_len;\n        full->transport_len = (uint16_t)len;\n        full->dev = first->dev;\n        pico_tree_foreach_safe(index, tree, tmp) {\n            f = index->keyValue;\n            memcpy(full->transport_hdr + bookmark, f->transport_hdr, f->transport_len);\n            bookmark += f->transport_len;\n            pico_tree_delete(tree, f);\n            pico_frame_discard(f);\n        }\n        pico_transport_receive(full, proto);\n        return 0;\n    }\n    return 1;\n}""}]","{""function"": 2}","[{""source"": ""func_info(func:pico_transport_receive)"", ""result"": [{""code"": ""MOCKABLE int32_t pico_transport_receive(struct pico_frame *f, uint8_t proto)\n{\n    int32_t ret = -1;\n    switch (proto) {\n\n#ifdef PICO_SUPPORT_ICMP4\n    case PICO_PROTO_ICMP4:\n        ret = pico_enqueue(pico_proto_icmp4.q_in, f);\n        break;\n#endif\n\n#ifdef PICO_SUPPORT_ICMP6\n    case PICO_PROTO_ICMP6:\n        ret = pico_enqueue(pico_proto_icmp6.q_in, f);\n        break;\n#endif\n\n\n#if defined(PICO_SUPPORT_IGMP) && defined(PICO_SUPPORT_MCAST)\n    case PICO_PROTO_IGMP:\n        ret = pico_enqueue(pico_proto_igmp.q_in, f);\n        break;\n#endif\n\n#ifdef PICO_SUPPORT_UDP\n    case PICO_PROTO_UDP:\n        ret = pico_enqueue(pico_proto_udp.q_in, f);\n        break;\n#endif\n\n#ifdef PICO_SUPPORT_TCP\n    case PICO_PROTO_TCP:\n        ret = pico_enqueue(pico_proto_tcp.q_in, f);\n        break;\n#endif\n\n    default:\n        /* Protocol not available */\n        dbg(\""pkt: no such protocol (%d)\\n\"", proto);\n        pico_notify_proto_unreachable(f->dev->stack, f);\n        pico_frame_discard(f);\n        ret = -1;\n    }\n    return ret;\n}\n"", ""start_line"": 199, ""end_line"": 243, ""full_name"": ""pico_transport_receive"", ""file_path"": ""stack/pico_stack.c""}]}, {""source"": ""func_info(func:pico_frame_discard)"", ""result"": [{""code"": ""void pico_frame_discard(struct pico_frame *f)\n{\n    if (!f)\n        return;\n\n    (*f->usage_count)--;\n    if (*f->usage_count == 0) {\n        if (f->flags & PICO_FRAME_FLAG_EXT_USAGE_COUNTER)\n            PICO_FREE(f->usage_count);\n\n#ifdef PICO_SUPPORT_DEBUG_MEMORY\n        dbg(\""Discarded buffer @%p, caller: %p\\n\"", f->buffer, __builtin_return_address(3));\n        dbg(\""DEBUG MEMORY: %d frames in use.\\n\"", --n_frames_allocated);\n#endif\n        if (!(f->flags & PICO_FRAME_FLAG_EXT_BUFFER))\n            PICO_FREE(f->buffer);\n        else if (f->notify_free)\n            f->notify_free(f->buffer);\n\n        if (f->info)\n            PICO_FREE(f->info);\n    }\n\n#ifdef PICO_SUPPORT_DEBUG_MEMORY\n    else {\n        dbg(\""Removed frame @%p(copy), usage count now: %d\\n\"", f, *f->usage_count);\n    }\n#endif\n    PICO_FREE(f);\n}"", ""start_line"": 40, ""end_line"": 69, ""full_name"": ""pico_frame_discard"", ""file_path"": ""stack/pico_frame.c""}]}]","In modules/pico_fragments.c:360-363, the original code called pico_frame_discard(full) if pico_transport_receive returned -1. However, in stack/pico_stack.c:243, pico_transport_receive() itself calls pico_frame_discard(f) in the default protocol case (when no protocol matches). This caused 'full' to be freed twice: once by pico_transport_receive and again by pico_frame_discard in pico_fragments_reassemble. The patch removes the redundant discard, resolving the double free.",0.95,./github/other_context/CVE-2021-33304
79,CVE-2021-36146,CWE-476,c_cpp,ACRN before 2.5 has a devicemodel/hw/pci/xhci.c NULL Pointer Dereference for a trb pointer.,https://github.com/projectacrn/acrn-hypervisor/commit/330359921e2e4c2f3f3a10b5bab86942d63c4428,"DM: xHCI: Check trb pointer before use it\n\nThe trb pointer may be NULL when get the address from user space, add\nthe pointer check before use the trb.\n\nTracked-On: #6172\nSigned-off-by: Liu Long <long.liu@intel.com>\nReviewed-by: Shuo A Liu <shuo.a.liu@intel.com>\nAcked-by: Yu Wang <yu1.wang@intel.com>",1,"[{""func_name"": ""pci_xhci_complete_commands"", ""file_path"": ""devicemodel/hw/pci/xhci.c"", ""func_code"": ""static int\npci_xhci_complete_commands(struct pci_xhci_vdev *xdev)\n{\n\tstruct xhci_trb\tevtrb;\n\tstruct xhci_trb\t*trb;\n\tuint64_t\tcrcr;\n\tuint32_t\tccs;\t\t/* cycle state (XHCI 4.9.2) */\n\tuint32_t\ttype;\n\tuint32_t\tslot;\n\tuint32_t\tcmderr;\n\n\txdev->opregs.crcr |= XHCI_CRCR_LO_CRR;\n\n\ttrb = xdev->opregs.cr_p;\n\tccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS;\n\tcrcr = xdev->opregs.crcr & ~0xF;\n\n\twhile (1) {\n\t\txdev->opregs.cr_p = trb;\n\n\t\ttype = XHCI_TRB_3_TYPE_GET(trb->dwTrb3);\n\n\t\tif ((trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT) !=\n\t\t    (ccs & XHCI_TRB_3_CYCLE_BIT))\n\t\t\tbreak;\n\n\t\tUPRINTF(LDBG, \""cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x\""\n\t\t\t\"" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\\r\\n\"",\n\t\t\ttype, trb->qwTrb0, trb->dwTrb2, trb->dwTrb3,\n\t\t\ttrb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT, ccs);\n\n\t\tcmderr = XHCI_TRB_ERROR_SUCCESS;\n\t\tevtrb.dwTrb2 = 0;\n\t\tevtrb.dwTrb3 = (ccs & XHCI_TRB_3_CYCLE_BIT) |\n\t\t      XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_CMD_COMPLETE);\n\t\tslot = 0;\n\n\t\tswitch (type) {\n\t\tcase XHCI_TRB_TYPE_LINK:\t\t\t/* 0x06 */\n\t\t\tif (trb->dwTrb3 & XHCI_TRB_3_TC_BIT)\n\t\t\t\tccs ^= XHCI_CRCR_LO_RCS;\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ENABLE_SLOT:\t\t\t/* 0x09 */\n\t\t\t/*\n\t\t\t *From xHCI spec 4.5.3.2, the only command that\n\t\t\t *software is allowed to issue for the slot in\n\t\t\t *disabled state is the Enable Slot Command.\n\t\t\t * */\n\t\t\tcmderr = pci_xhci_cmd_enable_slot(xdev, &slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_DISABLE_SLOT:\t\t/* 0x0A */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_disable_slot(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ADDRESS_DEVICE:\t\t/* 0x0B */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_address_device(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_CONFIGURE_EP:\t\t/* 0x0C */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_config_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_EVALUATE_CTX:\t\t/* 0x0D */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_eval_ctx(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_EP:\t\t\t/* 0x0E */\n\t\t\tUPRINTF(LDBG, \""Reset Endpoint on slot %d\\r\\n\"", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_STOP_EP:\t\t\t/* 0x0F */\n\t\t\tUPRINTF(LDBG, \""Stop Endpoint on slot %d\\r\\n\"", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_TR_DEQUEUE:\t\t/* 0x10 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_set_tr(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_DEVICE:\t\t/* 0x11 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_device(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_EVENT:\t\t\t/* 0x12 */\n\t\t\t/* TODO: */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NEGOTIATE_BW:\t\t/* 0x13 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_LATENCY_TOL:\t\t/* 0x14 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_GET_PORT_BW:\t\t\t/* 0x15 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_HEADER:\t\t/* 0x16 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NOOP_CMD:\t\t\t/* 0x17 */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tUPRINTF(LDBG, \""unsupported cmd %x\\r\\n\"", type);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (type != XHCI_TRB_TYPE_LINK) {\n\t\t\t/*\n\t\t\t * insert command completion event and assert intr\n\t\t\t */\n\t\t\tevtrb.qwTrb0 = crcr;\n\t\t\tevtrb.dwTrb2 |= XHCI_TRB_2_ERROR_SET(cmderr);\n\t\t\tevtrb.dwTrb3 |= XHCI_TRB_3_SLOT_SET(slot);\n\t\t\tUPRINTF(LDBG, \""command 0x%x result: 0x%x\\r\\n\"",\n\t\t\t\ttype, cmderr);\n\t\t\tif (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) {\n\t\t\t\tUPRINTF(LFTL, \""Failed to inject command completion event!\\r\\n\"");\n\t\t\t\treturn -ENAVAIL;\n\t\t\t}\n\t\t}\n\n\t\ttrb = pci_xhci_trb_next(xdev, trb, &crcr);\n\t\tif (!trb) {\n\t\t\tUPRINTF(LDBG, \""Get the invalid trb in %s!\\r\\n\"", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\txdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs;\n\txdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR;\n\treturn 0;\n}"", ""target"": 0}]","[{""func_name"": ""pci_xhci_complete_commands"", ""file_path"": ""devicemodel/hw/pci/xhci.c"", ""func_code"": ""static int\npci_xhci_complete_commands(struct pci_xhci_vdev *xdev)\n{\n\tstruct xhci_trb\tevtrb;\n\tstruct xhci_trb\t*trb;\n\tuint64_t\tcrcr;\n\tuint32_t\tccs;\t\t/* cycle state (XHCI 4.9.2) */\n\tuint32_t\ttype;\n\tuint32_t\tslot;\n\tuint32_t\tcmderr;\n\n\txdev->opregs.crcr |= XHCI_CRCR_LO_CRR;\n\n\ttrb = xdev->opregs.cr_p;\n\tccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS;\n\tcrcr = xdev->opregs.crcr & ~0xF;\n\tif (!trb) {\n\t\tUPRINTF(LDBG, \""Get the invalid guest address!\\r\\n\"");\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\txdev->opregs.cr_p = trb;\n\n\t\ttype = XHCI_TRB_3_TYPE_GET(trb->dwTrb3);\n\n\t\tif ((trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT) !=\n\t\t    (ccs & XHCI_TRB_3_CYCLE_BIT))\n\t\t\tbreak;\n\n\t\tUPRINTF(LDBG, \""cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x\""\n\t\t\t\"" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\\r\\n\"",\n\t\t\ttype, trb->qwTrb0, trb->dwTrb2, trb->dwTrb3,\n\t\t\ttrb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT, ccs);\n\n\t\tcmderr = XHCI_TRB_ERROR_SUCCESS;\n\t\tevtrb.dwTrb2 = 0;\n\t\tevtrb.dwTrb3 = (ccs & XHCI_TRB_3_CYCLE_BIT) |\n\t\t      XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_CMD_COMPLETE);\n\t\tslot = 0;\n\n\t\tswitch (type) {\n\t\tcase XHCI_TRB_TYPE_LINK:\t\t\t/* 0x06 */\n\t\t\tif (trb->dwTrb3 & XHCI_TRB_3_TC_BIT)\n\t\t\t\tccs ^= XHCI_CRCR_LO_RCS;\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ENABLE_SLOT:\t\t\t/* 0x09 */\n\t\t\t/*\n\t\t\t *From xHCI spec 4.5.3.2, the only command that\n\t\t\t *software is allowed to issue for the slot in\n\t\t\t *disabled state is the Enable Slot Command.\n\t\t\t * */\n\t\t\tcmderr = pci_xhci_cmd_enable_slot(xdev, &slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_DISABLE_SLOT:\t\t/* 0x0A */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_disable_slot(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ADDRESS_DEVICE:\t\t/* 0x0B */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_address_device(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_CONFIGURE_EP:\t\t/* 0x0C */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_config_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_EVALUATE_CTX:\t\t/* 0x0D */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_eval_ctx(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_EP:\t\t\t/* 0x0E */\n\t\t\tUPRINTF(LDBG, \""Reset Endpoint on slot %d\\r\\n\"", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_STOP_EP:\t\t\t/* 0x0F */\n\t\t\tUPRINTF(LDBG, \""Stop Endpoint on slot %d\\r\\n\"", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_TR_DEQUEUE:\t\t/* 0x10 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_set_tr(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_DEVICE:\t\t/* 0x11 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_device(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_EVENT:\t\t\t/* 0x12 */\n\t\t\t/* TODO: */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NEGOTIATE_BW:\t\t/* 0x13 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_LATENCY_TOL:\t\t/* 0x14 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_GET_PORT_BW:\t\t\t/* 0x15 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_HEADER:\t\t/* 0x16 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NOOP_CMD:\t\t\t/* 0x17 */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tUPRINTF(LDBG, \""unsupported cmd %x\\r\\n\"", type);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (type != XHCI_TRB_TYPE_LINK) {\n\t\t\t/*\n\t\t\t * insert command completion event and assert intr\n\t\t\t */\n\t\t\tevtrb.qwTrb0 = crcr;\n\t\t\tevtrb.dwTrb2 |= XHCI_TRB_2_ERROR_SET(cmderr);\n\t\t\tevtrb.dwTrb3 |= XHCI_TRB_3_SLOT_SET(slot);\n\t\t\tUPRINTF(LDBG, \""command 0x%x result: 0x%x\\r\\n\"",\n\t\t\t\ttype, cmderr);\n\t\t\tif (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) {\n\t\t\t\tUPRINTF(LFTL, \""Failed to inject command completion event!\\r\\n\"");\n\t\t\t\treturn -ENAVAIL;\n\t\t\t}\n\t\t}\n\n\t\ttrb = pci_xhci_trb_next(xdev, trb, &crcr);\n\t\tif (!trb) {\n\t\t\tUPRINTF(LDBG, \""Get the invalid trb in %s!\\r\\n\"", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\txdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs;\n\txdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR;\n\treturn 0;\n}""}]","{""value"": 1}","[{""source"": ""value_info(file:xhci.c, value:xdev->opregs.cr_p)"", ""result"": {""value_trace"": [{""full_code"": ""xdev->opregs.cr_p = trb"", ""line"": 2632, ""func_name"": ""pci_xhci_complete_commands""}, {""full_code"": ""xdev->opregs.cr_p = XHCI_GADDR(xdev,\n\t\t\t\t\t  xdev->opregs.crcr & ~0xF)"", ""line"": 3572, ""func_name"": ""pci_xhci_hostop_write""}], ""struct_var"": ""xdev"", ""struct_type"": ""pci_xhci_opregs"", ""struct_definition"": ""struct pci_xhci_opregs {\n\tuint32_t\tusbcmd;\t\t/* usb command */\n\tuint32_t\tusbsts;\t\t/* usb status */\n\tuint32_t\tpgsz;\t\t/* page size */\n\tuint32_t\tdnctrl;\t\t/* device notification control */\n\tuint64_t\tcrcr;\t\t/* command ring control */\n\tuint64_t\tdcbaap;\t\t/* device ctx base addr array ptr */\n\tuint32_t\tconfig;\t\t/* configure */\n\n\t/* guest mapped addresses: */\n\tstruct xhci_trb\t*cr_p;\t\t/* crcr dequeue */\n\tstruct xhci_dcbaa *dcbaa_p;\t/* dev ctx array ptr */\n}\n\nstruct pci_xhci_opregs""}}]","devicemodel/hw/pci/xhci.c:2628: 'trb' is assigned from 'xdev->opregs.cr_p' (unvalidated guest input). devicemodel/hw/pci/xhci.c:3572: 'xdev->opregs.cr_p' is set via 'XHCI_GADDR' from 'xdev->opregs.crcr', which is populated by guest writes to the CRCR register. Guest can set CRCR to 0, causing 'trb' to be NULL and triggering a dereference in 'pci_xhci_complete_commands' before the patch.",0.95,./github/other_context/CVE-2021-36146
80,CVE-2021-41687,"CWE-415, CWE-401",c_cpp,"DCMTK through 3.6.6 does not handle memory free properly. The program malloc a heap memory for parsing data, but does not free it when error in parsing. Sending specific requests to the dcmqrdb program incur the memory leak. An attacker can use it to launch a DoS attack.",https://github.com/DCMTK/dcmtk/commit/a9697dfeb672b0b9412c00c7d36d801e27ec85cb,Fixed poss. NULL pointer dereference/double free.\n\nThanks to Jinsheng Ba <bajinsheng@u.nus.edu> for the report and some patches.,4,"[{""func_name"": ""parsePresentationContext"", ""file_path"": ""dcmnet/libsrc/dulparse.cc"", ""func_code"": ""static OFCondition\nparsePresentationContext(unsigned char type,\n                  PRV_PRESENTATIONCONTEXTITEM * context, unsigned char *buf,\n                         unsigned long *itemLength, unsigned long availData)\n{\n    unsigned long\n        length;\n    unsigned long\n        presentationLength;\n    OFCondition cond = EC_Normal;\n    DUL_SUBITEM\n        * subItem;\n\n    // We need at least 8 bytes, anything smaller would be reading past the end\n    if (availData < 8)\n        return makeLengthError(\""presentation context\"", availData, 8);\n\n    if ((context->transferSyntaxList = LST_Create()) == NULL) return EC_MemoryExhausted;\n\n    *itemLength = 0;\n    context->type = *buf++;\n    context->rsv1 = *buf++;\n    EXTRACT_SHORT_BIG(buf, context->length);\n    buf += 2;\n    context->contextID = *buf++;\n    context->rsv2 = *buf++;\n    context->result = *buf++;\n    context->rsv3 = *buf++;\n\n    length = context->length;\n    *itemLength = 2 + 2 + length;\n\n    // Does the length field claim to be larger than the containing PDU?\n    if (availData - 4 < length || length < 4)\n        return makeLengthError(\""presentation context\"", availData, 4, length);\n\n    DCMNET_TRACE(\""Parsing Presentation Context: (\""\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->type\n            << STD_NAMESPACE dec << \""), Length: \"" << (unsigned long)context->length << OFendl\n            << \""Presentation Context ID: \""\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->contextID\n            << STD_NAMESPACE dec);\n    presentationLength = length - 4;\n    if (!((type == DUL_TYPEPRESENTATIONCONTEXTAC) &&\n          (context->result != DUL_PRESENTATION_ACCEPT))) {\n        while (presentationLength > 0) {\n            DCMNET_TRACE(\""Parsing remaining \"" << presentationLength << \"" bytes of Presentation Context\"" << OFendl\n                    << \""Next item type: \""\n                    << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n            switch (*buf) {\n            case DUL_TYPEABSTRACTSYNTAX:\n                cond = parseSubItem(&context->abstractSyntax, buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\""Abstract Syntax\"", presentationLength, length);\n                DCMNET_TRACE(\""Successfully parsed Abstract Syntax\"");\n                break;\n            case DUL_TYPETRANSFERSYNTAX:\n                subItem = (DUL_SUBITEM*)malloc(sizeof(DUL_SUBITEM));\n                if (subItem == NULL) return EC_MemoryExhausted;\n                cond = parseSubItem(subItem, buf, &length, presentationLength);\n                if (cond.bad()) return cond;\n                LST_Enqueue(&context->transferSyntaxList, (LST_NODE*)subItem);\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\""Transfer Syntax\"", presentationLength, length);\n                DCMNET_TRACE(\""Successfully parsed Transfer Syntax\"");\n                break;\n            default:\n                cond = parseDummy(buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\""unknown presentation context type\"", presentationLength, length);\n                break;\n            }\n        }\n    }\n    return EC_Normal;\n}"", ""target"": 0}, {""func_name"": ""parseUserInfo"", ""file_path"": ""dcmnet/libsrc/dulparse.cc"", ""func_code"": ""static OFCondition\nparseUserInfo(DUL_USERINFO * userInfo,\n              unsigned char *buf,\n              unsigned long *itemLength,\n              unsigned char typeRQorAC,\n              unsigned long availData /* bytes left for in this PDU */)\n{\n    unsigned short userLength;\n    unsigned long length;\n    OFCondition cond = EC_Normal;\n    PRV_SCUSCPROLE *role;\n    SOPClassExtendedNegotiationSubItem *extNeg = NULL;\n    UserIdentityNegotiationSubItem *usrIdent = NULL;\n\n    // minimum allowed size is 4 byte (case where the length of the user data is 0),\n    // else we read past the buffer end\n    if (availData < 4)\n        return makeLengthError(\""user info\"", availData, 4);\n\n    // skip item type (50H) field\n    userInfo->type = *buf++;\n    // skip unused (\""reserved\"") field\n    userInfo->rsv1 = *buf++;\n    // get and remember announced length of user data\n    EXTRACT_SHORT_BIG(buf, userInfo->length);\n    // .. and skip over the two length field bytes\n    buf += 2;\n\n    // userLength contains announced length of full user item structure,\n    // will be used here to count down the available data later\n    userLength = userInfo->length;\n    // itemLength contains full length of the user item including the 4 bytes extra header (type, reserved + 2 for length)\n    *itemLength = userLength + 4;\n\n    // does this item claim to be larger than the available data?\n    if (availData < *itemLength)\n        return makeLengthError(\""user info\"", availData, 0, userLength);\n\n    DCMNET_TRACE(\""Parsing user info field (\""\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)userInfo->type\n            << STD_NAMESPACE dec << \""), Length: \"" << (unsigned long)userInfo->length);\n    // parse through different types of user items as long as we have data\n    while (userLength > 0) {\n        DCMNET_TRACE(\""Parsing remaining \"" << (long)userLength << \"" bytes of User Information\"" << OFendl\n                << \""Next item type: \""\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n        switch (*buf) {\n        case DUL_TYPEMAXLENGTH:\n            cond = parseMaxPDU(&userInfo->maxLength, buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""maximum length sub-item\"", userLength, length);\n            DCMNET_TRACE(\""Successfully parsed Maximum PDU Length\"");\n            break;\n        case DUL_TYPEIMPLEMENTATIONCLASSUID:\n            cond = parseSubItem(&userInfo->implementationClassUID,\n                                buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""Implementation Class UID sub-item\"", userLength, length);\n            break;\n\n        case DUL_TYPEASYNCOPERATIONS:\n            cond = parseDummy(buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""asynchronous operation user item type\"", userLength, length);\n            break;\n        case DUL_TYPESCUSCPROLE:\n            role = (PRV_SCUSCPROLE*)malloc(sizeof(PRV_SCUSCPROLE));\n            if (role == NULL) return EC_MemoryExhausted;\n            cond = parseSCUSCPRole(role, buf, &length, userLength);\n            if (cond.bad()) return cond;\n            LST_Enqueue(&userInfo->SCUSCPRoleList, (LST_NODE*)role);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""SCP/SCU Role Selection sub-item\"", userLength, length);\n            break;\n        case DUL_TYPEIMPLEMENTATIONVERSIONNAME:\n            cond = parseSubItem(&userInfo->implementationVersionName,\n                                buf, &length, userLength);\n            if (cond.bad()) return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""Implementation Version Name structure\"", userLength, length);\n            break;\n\n        case DUL_TYPESOPCLASSEXTENDEDNEGOTIATION:\n            /* parse an extended negotiation sub-item */\n            extNeg = new SOPClassExtendedNegotiationSubItem;\n            if (extNeg == NULL)  return EC_MemoryExhausted;\n            cond = parseExtNeg(extNeg, buf, &length, userLength);\n            if (cond.bad()) return cond;\n            if (userInfo->extNegList == NULL)\n            {\n                userInfo->extNegList = new SOPClassExtendedNegotiationSubItemList;\n                if (userInfo->extNegList == NULL)  return EC_MemoryExhausted;\n            }\n            userInfo->extNegList->push_back(extNeg);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""SOP Class Extended Negotiation sub-item\"", userLength, length);\n            break;\n\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_REQ:\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_ACK:\n          if (typeRQorAC == DUL_TYPEASSOCIATERQ)\n            usrIdent = new UserIdentityNegotiationSubItemRQ();\n          else // assume DUL_TYPEASSOCIATEAC\n            usrIdent = new UserIdentityNegotiationSubItemAC();\n          if (usrIdent == NULL) return EC_MemoryExhausted;\n          cond = usrIdent->parseFromBuffer(buf, length /*return value*/, userLength);\n          if (cond.bad())\n          {\n            delete usrIdent;\n            return cond;\n          }\n          userInfo->usrIdent = usrIdent;\n          buf += length;\n          if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n            return makeLengthError(\""User Identity sub-item\"", userLength, length);\n          break;\n        default:\n            // we hit an unknown user item that is not defined in the standard\n            // or still unknown to DCMTK\n            cond = parseDummy(buf, &length /* returns bytes \""handled\"" by parseDummy */, userLength /* data available in bytes for user item */);\n            if (cond.bad())\n              return cond;\n            // skip the bytes read\n            buf += length;\n            // subtract bytes of parsed data from available data bytes\n            if (OFstatic_cast(unsigned short, length) != length\n                || !OFStandard::safeSubtract(userLength, OFstatic_cast(unsigned short, length), userLength))\n              return makeUnderflowError(\""unknown user item\"", userLength, length);\n            break;\n        }\n    }\n\n    return EC_Normal;\n}"", ""target"": 0}, {""func_name"": ""parseAssociate"", ""file_path"": ""dcmnet/libsrc/dulparse.cc"", ""func_code"": ""OFCondition\nparseAssociate(unsigned char *buf, unsigned long pduLength,\n               PRV_ASSOCIATEPDU * assoc)\n{\n    OFCondition cond = EC_Normal;\n    unsigned char\n        type;\n    unsigned long\n        itemLength;\n    PRV_PRESENTATIONCONTEXTITEM\n        * context;\n\n    (void) memset(assoc, 0, sizeof(*assoc));\n    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n\n    // Check if the PDU actually is long enough for the fields we read\n    if (pduLength < 2 + 2 + 16 + 16 + 32)\n        return makeLengthError(\""associate PDU\"", pduLength, 2 + 2 + 16 + 16 + 32);\n\n    assoc->type = *buf++;\n    assoc->rsv1 = *buf++;\n    EXTRACT_LONG_BIG(buf, assoc->length);\n    buf += 4;\n\n    EXTRACT_SHORT_BIG(buf, assoc->protocol);\n    buf += 2;\n    pduLength -= 2;\n    if ((assoc->protocol & DUL_PROTOCOL) == 0)\n    {\n        char buffer[256];\n        sprintf(buffer, \""DUL Unsupported peer protocol %04x; expected %04x in %s\"", assoc->protocol, DUL_PROTOCOL, \""parseAssociate\"");\n        return makeDcmnetCondition(DULC_UNSUPPORTEDPEERPROTOCOL, OF_error, buffer);\n    }\n    assoc->rsv2[0] = *buf++;\n    pduLength--;\n    assoc->rsv2[1] = *buf++;\n    pduLength--;\n    (void) strncpy(assoc->calledAPTitle, (char *) buf, 16);\n    assoc->calledAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->calledAPTitle);\n\n    buf += 16;\n    pduLength -= 16;\n    (void) strncpy(assoc->callingAPTitle, (char *) buf, 16);\n    assoc->callingAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->callingAPTitle);\n    buf += 16;\n    pduLength -= 16;\n    (void) memcpy(assoc->rsv3, buf, 32);\n    buf += 32;\n    pduLength -= 32;\n\n    if (DCM_dcmnetLogger.isEnabledFor(OFLogger::DEBUG_LOG_LEVEL)) {\n        const char *s;\n        DCMNET_DEBUG(\""Parsing an A-ASSOCIATE PDU\"");\n        if (assoc->type == DUL_TYPEASSOCIATERQ)\n            s = \""A-ASSOCIATE RQ\"";\n        else if (assoc->type == DUL_TYPEASSOCIATEAC)\n            s = \""A-ASSOCIATE AC\"";\n        else\n            s = \""Unknown: Programming bug in parseAssociate\"";\n\n/*      If we hit the \""Unknown type\"", there is a programming bug somewhere.\n**      This function is only supposed to parse A-ASSOCIATE PDUs and\n**      expects its input to have been properly screened.\n*/\n        DCMNET_TRACE(\""PDU type: \""\n            << STD_NAMESPACE hex << ((unsigned int)assoc->type)\n            << STD_NAMESPACE dec << \"" (\"" << s << \""), PDU Length: \"" << assoc->length << OFendl\n            << \""DICOM Protocol: \""\n            << STD_NAMESPACE hex << assoc->protocol\n            << STD_NAMESPACE dec << OFendl\n            << \""Called AP Title:  \"" << assoc->calledAPTitle << OFendl\n            << \""Calling AP Title: \"" << assoc->callingAPTitle);\n    }\n    while ((cond.good()) && (pduLength > 0))\n    {\n        type = *buf;\n        DCMNET_TRACE(\""Parsing remaining \"" << pduLength << \"" bytes of A-ASSOCIATE PDU\"" << OFendl\n                << \""Next item type: \""\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << ((unsigned int)type));\n        switch (type) {\n        case DUL_TYPEAPPLICATIONCONTEXT:\n            cond = parseSubItem(&assoc->applicationContext,\n                                buf, &itemLength, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                  return makeUnderflowError(\""Application Context item\"", pduLength, itemLength);\n                DCMNET_TRACE(\""Successfully parsed Application Context\"");\n            }\n            break;\n        case DUL_TYPEPRESENTATIONCONTEXTRQ:\n        case DUL_TYPEPRESENTATIONCONTEXTAC:\n            context = (PRV_PRESENTATIONCONTEXTITEM*)malloc(sizeof(PRV_PRESENTATIONCONTEXTITEM));\n            if (context == NULL) return EC_MemoryExhausted;\n            (void) memset(context, 0, sizeof(*context));\n            cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);\n            if (cond.bad()) return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\""Presentation Context item\"", pduLength, itemLength);\n            LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);\n            DCMNET_TRACE(\""Successfully parsed Presentation Context\"");\n            break;\n        case DUL_TYPEUSERINFO:\n            // parse user info, which can contain several sub-items like User\n            // Identity Negotiation or SOP Class Extended Negotiation\n            cond = parseUserInfo(&assoc->userInfo, buf, &itemLength, assoc->type, pduLength);\n            if (cond.bad())\n                return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\""User Information item\"", pduLength, itemLength);\n            DCMNET_TRACE(\""Successfully parsed User Information\"");\n            break;\n        default:\n            cond = parseDummy(buf, &itemLength, pduLength);\n            if (cond.bad())\n                return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\""unknown item type\"", pduLength, itemLength);\n            break;\n        }\n    }\n    return cond;\n}"", ""target"": 0}, {""func_name"": ""ASC_destroyAssociation"", ""file_path"": ""dcmnet/libsrc/assoc.cc"", ""func_code"": ""OFCondition\nASC_destroyAssociation(T_ASC_Association ** association)\n{\n    OFCondition cond = EC_Normal;\n\n    /* don't worry if already destroyed */\n    if (association == NULL) return EC_Normal;\n    if (*association == NULL) return EC_Normal;\n\n    if ((*association)->DULassociation != NULL) {\n        ASC_dropAssociation(*association);\n    }\n\n    if ((*association)->params != NULL) {\n        cond = ASC_destroyAssociationParameters(&(*association)->params);\n        if (cond.bad()) return cond;\n    }\n\n    if ((*association)->sendPDVBuffer != NULL)\n        free((*association)->sendPDVBuffer);\n\n    free(*association);\n    *association = NULL;\n\n    return EC_Normal;\n}"", ""target"": 0}]","[{""func_name"": ""parsePresentationContext"", ""file_path"": ""dcmnet/libsrc/dulparse.cc"", ""func_code"": ""static OFCondition\nparsePresentationContext(unsigned char type,\n                  PRV_PRESENTATIONCONTEXTITEM * context, unsigned char *buf,\n                         unsigned long *itemLength, unsigned long availData)\n{\n    unsigned long\n        length;\n    unsigned long\n        presentationLength;\n    OFCondition cond = EC_Normal;\n    DUL_SUBITEM\n        * subItem;\n\n    // We need at least 8 bytes, anything smaller would be reading past the end\n    if (availData < 8)\n        return makeLengthError(\""presentation context\"", availData, 8);\n\n    if ((context->transferSyntaxList = LST_Create()) == NULL) return EC_MemoryExhausted;\n\n    *itemLength = 0;\n    context->type = *buf++;\n    context->rsv1 = *buf++;\n    EXTRACT_SHORT_BIG(buf, context->length);\n    buf += 2;\n    context->contextID = *buf++;\n    context->rsv2 = *buf++;\n    context->result = *buf++;\n    context->rsv3 = *buf++;\n\n    length = context->length;\n    *itemLength = 2 + 2 + length;\n\n    // Does the length field claim to be larger than the containing PDU?\n    if (availData - 4 < length || length < 4)\n        return makeLengthError(\""presentation context\"", availData, 4, length);\n\n    DCMNET_TRACE(\""Parsing Presentation Context: (\""\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->type\n            << STD_NAMESPACE dec << \""), Length: \"" << (unsigned long)context->length << OFendl\n            << \""Presentation Context ID: \""\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->contextID\n            << STD_NAMESPACE dec);\n    presentationLength = length - 4;\n    if (!((type == DUL_TYPEPRESENTATIONCONTEXTAC) &&\n          (context->result != DUL_PRESENTATION_ACCEPT))) {\n        while (presentationLength > 0) {\n            DCMNET_TRACE(\""Parsing remaining \"" << presentationLength << \"" bytes of Presentation Context\"" << OFendl\n                    << \""Next item type: \""\n                    << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n            switch (*buf) {\n            case DUL_TYPEABSTRACTSYNTAX:\n                cond = parseSubItem(&context->abstractSyntax, buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\""Abstract Syntax\"", presentationLength, length);\n                DCMNET_TRACE(\""Successfully parsed Abstract Syntax\"");\n                break;\n            case DUL_TYPETRANSFERSYNTAX:\n                subItem = (DUL_SUBITEM*)malloc(sizeof(DUL_SUBITEM));\n                if (subItem == NULL) return EC_MemoryExhausted;\n                cond = parseSubItem(subItem, buf, &length, presentationLength);\n                if (cond.bad())\n                {\n                    free(subItem);\n                    return cond;\n                }\n                LST_Enqueue(&context->transferSyntaxList, (LST_NODE*)subItem);\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\""Transfer Syntax\"", presentationLength, length);\n                DCMNET_TRACE(\""Successfully parsed Transfer Syntax\"");\n                break;\n            default:\n                cond = parseDummy(buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\""unknown presentation context type\"", presentationLength, length);\n                break;\n            }\n        }\n    }\n    return EC_Normal;\n}""}, {""func_name"": ""parseUserInfo"", ""file_path"": ""dcmnet/libsrc/dulparse.cc"", ""func_code"": ""static OFCondition\nparseUserInfo(DUL_USERINFO * userInfo,\n              unsigned char *buf,\n              unsigned long *itemLength,\n              unsigned char typeRQorAC,\n              unsigned long availData /* bytes left for in this PDU */)\n{\n    unsigned short userLength;\n    unsigned long length;\n    OFCondition cond = EC_Normal;\n    PRV_SCUSCPROLE *role;\n    SOPClassExtendedNegotiationSubItem *extNeg = NULL;\n    UserIdentityNegotiationSubItem *usrIdent = NULL;\n\n    // minimum allowed size is 4 byte (case where the length of the user data is 0),\n    // else we read past the buffer end\n    if (availData < 4)\n        return makeLengthError(\""user info\"", availData, 4);\n\n    // skip item type (50H) field\n    userInfo->type = *buf++;\n    // skip unused (\""reserved\"") field\n    userInfo->rsv1 = *buf++;\n    // get and remember announced length of user data\n    EXTRACT_SHORT_BIG(buf, userInfo->length);\n    // .. and skip over the two length field bytes\n    buf += 2;\n\n    // userLength contains announced length of full user item structure,\n    // will be used here to count down the available data later\n    userLength = userInfo->length;\n    // itemLength contains full length of the user item including the 4 bytes extra header (type, reserved + 2 for length)\n    *itemLength = userLength + 4;\n\n    // does this item claim to be larger than the available data?\n    if (availData < *itemLength)\n        return makeLengthError(\""user info\"", availData, 0, userLength);\n\n    DCMNET_TRACE(\""Parsing user info field (\""\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)userInfo->type\n            << STD_NAMESPACE dec << \""), Length: \"" << (unsigned long)userInfo->length);\n    // parse through different types of user items as long as we have data\n    while (userLength > 0) {\n        DCMNET_TRACE(\""Parsing remaining \"" << (long)userLength << \"" bytes of User Information\"" << OFendl\n                << \""Next item type: \""\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n        switch (*buf) {\n        case DUL_TYPEMAXLENGTH:\n            cond = parseMaxPDU(&userInfo->maxLength, buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""maximum length sub-item\"", userLength, length);\n            DCMNET_TRACE(\""Successfully parsed Maximum PDU Length\"");\n            break;\n        case DUL_TYPEIMPLEMENTATIONCLASSUID:\n            cond = parseSubItem(&userInfo->implementationClassUID,\n                                buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""Implementation Class UID sub-item\"", userLength, length);\n            break;\n\n        case DUL_TYPEASYNCOPERATIONS:\n            cond = parseDummy(buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""asynchronous operation user item type\"", userLength, length);\n            break;\n        case DUL_TYPESCUSCPROLE:\n            role = (PRV_SCUSCPROLE*)malloc(sizeof(PRV_SCUSCPROLE));\n            if (role == NULL) return EC_MemoryExhausted;\n            cond = parseSCUSCPRole(role, buf, &length, userLength);\n            if (cond.bad())\n            {\n                free(role);\n                return cond;\n            }\n            LST_Enqueue(&userInfo->SCUSCPRoleList, (LST_NODE*)role);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""SCP/SCU Role Selection sub-item\"", userLength, length);\n            break;\n        case DUL_TYPEIMPLEMENTATIONVERSIONNAME:\n            cond = parseSubItem(&userInfo->implementationVersionName,\n                                buf, &length, userLength);\n            if (cond.bad()) return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""Implementation Version Name structure\"", userLength, length);\n            break;\n\n        case DUL_TYPESOPCLASSEXTENDEDNEGOTIATION:\n            /* parse an extended negotiation sub-item */\n            extNeg = new SOPClassExtendedNegotiationSubItem;\n            if (extNeg == NULL)  return EC_MemoryExhausted;\n            cond = parseExtNeg(extNeg, buf, &length, userLength);\n            if (cond.bad()) return cond;\n            if (userInfo->extNegList == NULL)\n            {\n                userInfo->extNegList = new SOPClassExtendedNegotiationSubItemList;\n                if (userInfo->extNegList == NULL)  return EC_MemoryExhausted;\n            }\n            userInfo->extNegList->push_back(extNeg);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\""SOP Class Extended Negotiation sub-item\"", userLength, length);\n            break;\n\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_REQ:\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_ACK:\n          if (typeRQorAC == DUL_TYPEASSOCIATERQ)\n            usrIdent = new UserIdentityNegotiationSubItemRQ();\n          else // assume DUL_TYPEASSOCIATEAC\n            usrIdent = new UserIdentityNegotiationSubItemAC();\n          if (usrIdent == NULL) return EC_MemoryExhausted;\n          cond = usrIdent->parseFromBuffer(buf, length /*return value*/, userLength);\n          if (cond.bad())\n          {\n            delete usrIdent;\n            return cond;\n          }\n          userInfo->usrIdent = usrIdent;\n          buf += length;\n          if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n            return makeLengthError(\""User Identity sub-item\"", userLength, length);\n          break;\n        default:\n            // we hit an unknown user item that is not defined in the standard\n            // or still unknown to DCMTK\n            cond = parseDummy(buf, &length /* returns bytes \""handled\"" by parseDummy */, userLength /* data available in bytes for user item */);\n            if (cond.bad())\n              return cond;\n            // skip the bytes read\n            buf += length;\n            // subtract bytes of parsed data from available data bytes\n            if (OFstatic_cast(unsigned short, length) != length\n                || !OFStandard::safeSubtract(userLength, OFstatic_cast(unsigned short, length), userLength))\n              return makeUnderflowError(\""unknown user item\"", userLength, length);\n            break;\n        }\n    }\n\n    return EC_Normal;\n}""}, {""func_name"": ""parseAssociate"", ""file_path"": ""dcmnet/libsrc/dulparse.cc"", ""func_code"": ""OFCondition\nparseAssociate(unsigned char *buf, unsigned long pduLength,\n               PRV_ASSOCIATEPDU * assoc)\n{\n    OFCondition cond = EC_Normal;\n    unsigned char\n        type;\n    unsigned long\n        itemLength;\n    PRV_PRESENTATIONCONTEXTITEM\n        * context;\n\n    (void) memset(assoc, 0, sizeof(*assoc));\n    // Check if the PDU actually is long enough for the fields we read\n    if (pduLength < 2 + 2 + 16 + 16 + 32)\n        return makeLengthError(\""associate PDU\"", pduLength, 2 + 2 + 16 + 16 + 32);\n\n    assoc->type = *buf++;\n    assoc->rsv1 = *buf++;\n    EXTRACT_LONG_BIG(buf, assoc->length);\n    buf += 4;\n\n    EXTRACT_SHORT_BIG(buf, assoc->protocol);\n    buf += 2;\n    pduLength -= 2;\n    if ((assoc->protocol & DUL_PROTOCOL) == 0)\n    {\n        char buffer[256];\n        sprintf(buffer, \""DUL Unsupported peer protocol %04x; expected %04x in %s\"", assoc->protocol, DUL_PROTOCOL, \""parseAssociate\"");\n        return makeDcmnetCondition(DULC_UNSUPPORTEDPEERPROTOCOL, OF_error, buffer);\n    }\n    assoc->rsv2[0] = *buf++;\n    pduLength--;\n    assoc->rsv2[1] = *buf++;\n    pduLength--;\n    (void) strncpy(assoc->calledAPTitle, (char *) buf, 16);\n    assoc->calledAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->calledAPTitle);\n\n    buf += 16;\n    pduLength -= 16;\n    (void) strncpy(assoc->callingAPTitle, (char *) buf, 16);\n    assoc->callingAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->callingAPTitle);\n    buf += 16;\n    pduLength -= 16;\n    (void) memcpy(assoc->rsv3, buf, 32);\n    buf += 32;\n    pduLength -= 32;\n\n    if (DCM_dcmnetLogger.isEnabledFor(OFLogger::DEBUG_LOG_LEVEL)) {\n        const char *s;\n        DCMNET_DEBUG(\""Parsing an A-ASSOCIATE PDU\"");\n        if (assoc->type == DUL_TYPEASSOCIATERQ)\n            s = \""A-ASSOCIATE RQ\"";\n        else if (assoc->type == DUL_TYPEASSOCIATEAC)\n            s = \""A-ASSOCIATE AC\"";\n        else\n            s = \""Unknown: Programming bug in parseAssociate\"";\n\n/*      If we hit the \""Unknown type\"", there is a programming bug somewhere.\n**      This function is only supposed to parse A-ASSOCIATE PDUs and\n**      expects its input to have been properly screened.\n*/\n        DCMNET_TRACE(\""PDU type: \""\n            << STD_NAMESPACE hex << ((unsigned int)assoc->type)\n            << STD_NAMESPACE dec << \"" (\"" << s << \""), PDU Length: \"" << assoc->length << OFendl\n            << \""DICOM Protocol: \""\n            << STD_NAMESPACE hex << assoc->protocol\n            << STD_NAMESPACE dec << OFendl\n            << \""Called AP Title:  \"" << assoc->calledAPTitle << OFendl\n            << \""Calling AP Title: \"" << assoc->callingAPTitle);\n    }\n    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n    while ((cond.good()) && (pduLength > 0))\n    {\n        type = *buf;\n        DCMNET_TRACE(\""Parsing remaining \"" << pduLength << \"" bytes of A-ASSOCIATE PDU\"" << OFendl\n                << \""Next item type: \""\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << ((unsigned int)type));\n        switch (type) {\n        case DUL_TYPEAPPLICATIONCONTEXT:\n            cond = parseSubItem(&assoc->applicationContext,\n                                buf, &itemLength, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                {\n                    cond = makeUnderflowError(\""Application Context item\"", pduLength, itemLength);\n                }\n                else\n                {\n                    DCMNET_TRACE(\""Successfully parsed Application Context\"");\n                }\n            }\n            break;\n        case DUL_TYPEPRESENTATIONCONTEXTRQ:\n        case DUL_TYPEPRESENTATIONCONTEXTAC:\n            context = (PRV_PRESENTATIONCONTEXTITEM*)malloc(sizeof(PRV_PRESENTATIONCONTEXTITEM));\n            if (context != NULL)\n            {\n                (void) memset(context, 0, sizeof(*context));\n                cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);\n                if (cond.bad())\n                {\n                    free(context);\n                }\n                else\n                {\n                    buf += itemLength;\n                    if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                    {\n                        cond =  makeUnderflowError(\""Presentation Context item\"", pduLength, itemLength);\n                    }\n                    else\n                    {\n                        LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);\n                        DCMNET_TRACE(\""Successfully parsed Presentation Context\"");\n                    }\n                }\n            }\n            else\n            {\n                cond = EC_MemoryExhausted;\n            }\n            break;\n        case DUL_TYPEUSERINFO:\n            // parse user info, which can contain several sub-items like User\n            // Identity Negotiation or SOP Class Extended Negotiation\n            cond = parseUserInfo(&assoc->userInfo, buf, &itemLength, assoc->type, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                {\n                    cond = makeUnderflowError(\""User Information item\"", pduLength, itemLength);\n                }\n                else\n                {\n                    DCMNET_TRACE(\""Successfully parsed User Information\"");\n                }\n            }\n            break;\n        default:\n            cond = parseDummy(buf, &itemLength, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                {\n                    cond = makeUnderflowError(\""unknown item type\"", pduLength, itemLength);\n                }\n            }\n            break;\n        }\n    }\n    if (cond.bad())\n    {\n      destroyPresentationContextList(&assoc->presentationContextList);\n      destroyUserInformationLists(&assoc->userInfo);\n    }\n    return cond;\n}""}, {""func_name"": ""ASC_destroyAssociation"", ""file_path"": ""dcmnet/libsrc/assoc.cc"", ""func_code"": ""OFCondition\nASC_destroyAssociation(T_ASC_Association ** association)\n{\n    OFCondition cond = EC_Normal;\n\n    /* don't worry if already destroyed */\n    if (association == NULL) return EC_Normal;\n    if (*association == NULL) return EC_Normal;\n\n    if ((*association)->DULassociation != NULL) {\n        ASC_dropAssociation(*association);\n    }\n\n    if ((*association)->params != NULL) {\n        ASC_destroyAssociationParameters(&(*association)->params);\n    }\n\n    if ((*association)->sendPDVBuffer != NULL)\n        free((*association)->sendPDVBuffer);\n\n    free(*association);\n    *association = NULL;\n\n    return EC_Normal;\n}""}]","{""function"": 2, ""code"": 1}","[{""source"": ""func_info(func:destroyPresentationContextList)"", ""result"": [{""code"": ""static void\ndestroyPresentationContextList(LST_HEAD ** lst)\n{\n    DUL_PRESENTATIONCONTEXT *pc;\n    DUL_TRANSFERSYNTAX *ts;\n\n    if ((lst == NULL) || (*lst == NULL))\n        return;\n    while ((pc = (DUL_PRESENTATIONCONTEXT*) LST_Dequeue(lst)) != NULL) {\n        if (pc->proposedTransferSyntax != NULL) {\n            while ((ts = (DUL_TRANSFERSYNTAX*) LST_Dequeue(&pc->proposedTransferSyntax)) != NULL) {\n                free(ts);\n            }\n            LST_Destroy(&pc->proposedTransferSyntax);\n        }\n        free(pc);\n    }\n    LST_Destroy(lst);\n}"", ""start_line"": 339, ""end_line"": 357, ""full_name"": ""destroyPresentationContextList:void(LST_HEAD**)"", ""file_path"": ""dcmnet/libsrc/assoc.cc""}, {""code"": ""void\ndestroyPresentationContextList(LST_HEAD ** l)\n{\n    PRV_PRESENTATIONCONTEXTITEM\n    * prvCtx;\n    DUL_SUBITEM\n        * subItem;\n\n    if (*l == NULL)\n        return;\n\n    prvCtx = (PRV_PRESENTATIONCONTEXTITEM*)LST_Dequeue(l);\n    while (prvCtx != NULL) {\n        subItem = (DUL_SUBITEM*)LST_Dequeue(&prvCtx->transferSyntaxList);\n        while (subItem != NULL) {\n            free(subItem);\n            subItem = (DUL_SUBITEM*)LST_Dequeue(&prvCtx->transferSyntaxList);\n        }\n        LST_Destroy(&prvCtx->transferSyntaxList);\n        free(prvCtx);\n        prvCtx = (PRV_PRESENTATIONCONTEXTITEM*)LST_Dequeue(l);\n    }\n    LST_Destroy(l);\n}"", ""start_line"": 3982, ""end_line"": 4005, ""full_name"": ""destroyPresentationContextList<duplicate>0:void(LST_HEAD**)"", ""file_path"": ""dcmnet/libsrc/dulfsm.cc""}]}, {""source"": ""func_info(func:destroyUserInformationLists)"", ""result"": [{""code"": ""void\ndestroyUserInformationLists(DUL_USERINFO * userInfo)\n{\n    PRV_SCUSCPROLE\n    * role;\n\n    role = (PRV_SCUSCPROLE*)LST_Dequeue(&userInfo->SCUSCPRoleList);\n    while (role != NULL) {\n        free(role);\n        role = (PRV_SCUSCPROLE*)LST_Dequeue(&userInfo->SCUSCPRoleList);\n    }\n    LST_Destroy(&userInfo->SCUSCPRoleList);\n\n    /* extended negotiation */\n    delete userInfo->extNegList; userInfo->extNegList = NULL;\n\n    /* user identity negotiation */\n    delete userInfo->usrIdent; userInfo->usrIdent = NULL;\n}"", ""start_line"": 4007, ""end_line"": 4025, ""full_name"": ""destroyUserInformationLists:void(DUL_USERINFO*)"", ""file_path"": ""dcmnet/libsrc/dulfsm.cc""}]}, {""source"": ""code_info(file:dulparse.cc, lines:143-160)"", ""result"": ""\n    (void) memset(assoc, 0, sizeof(*assoc));\n    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n\n    // Check if the PDU actually is long enough for the fields we read\n    if (pduLength < 2 + 2 + 16 + 16 + 32)\n        return makeLengthError(\""associate PDU\"", pduLength, 2 + 2 + 16 + 16 + 32);\n\n    assoc->type = *buf++;\n    assoc->rsv1 = *buf++;\n    EXTRACT_LONG_BIG(buf, assoc->length);\n    buf += 4;\n\n    EXTRACT_SHORT_BIG(buf, assoc->protocol);\n    buf += 2;\n    pduLength -= 2;\n    if ((assoc->protocol & DUL_PROTOCOL) == 0)\n""}]","In DCMTK's DUL parsing code, dynamically allocated memory (e.g., subItem in parsePresentationContext (dulparse.cc:405), role in parseUserInfo (dulparse.cc:526)) was not freed when error conditions occurred (e.g., cond.bad()). This caused memory leaks during association parsing in parseAssociate (dulparse.cc:206-220). The patches add explicit free() calls on error paths and a final cleanup block invoking destroyPresentationContextList (assoc.cc:339-357, dulfsm.cc:3982-4005) and destroyUserInformationLists (dulfsm.cc:4007-4025) to ensure full resource release.",0.95,./github/other_context/CVE-2021-41687
81,CVE-2022-0699,CWE-415,c_cpp,A double-free condition exists in contrib/shpsort.c of shapelib 1.5.0 and older releases. This issue may allow an attacker to cause a denial of service or have other unspecified impact via control over malloc.,https://github.com/OSGeo/shapelib/commit/c75b9281a5b9452d92e1682bdfe6019a13ed819f,"Remove double free() in contrib/shpsrt, issue #39\n\nThis fixes issue #39",1,"[{""func_name"": ""split"", ""file_path"": ""contrib/shpsort.c"", ""func_code"": ""static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n\n  free(copy);\n\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n\n  return result;\n}"", ""target"": 0}]","[{""func_name"": ""split"", ""file_path"": ""contrib/shpsort.c"", ""func_code"": ""static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n\n  free(copy);\n\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n\n  return result;\n}""}]","{""code"": 1, ""value"": 1}","[{""source"": ""code_info(file:shpsort.c, lines:100-130)"", ""result"": ""      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n\n  free(copy);\n\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n\n  return result;\n}\n\n\nstatic void copy_related (const char *inName, const char *outName,\n\t\t\t  const char *old_ext, const char *new_ext)\n{\n  size_t name_len = strlen(inName);\n""}, {""source"": ""value_info(file:shpsort.c, value:copy)"", ""result"": {""value_trace"": [{""full_code"": ""*copy = dupstr(arg)"", ""line"": 89, ""func_name"": ""split""}], ""struct_var"": ""copy"", ""struct_type"": ""char*"", ""struct_definition"": ""char""}}]","1. 'copy' is allocated via 'dupstr(arg)' at contrib/shpsort.c:89.\n2. 'copy' is first freed at contrib/shpsort.c:100 (before realloc check).\n3. In the error path (realloc failure), 'copy' is freed again at contrib/shpsort.c:114, causing a double-free.\n4. The patch removes line 114's 'free(copy)' to eliminate redundancy.",0.95,./github/other_context/CVE-2022-0699
82,CVE-2022-1341,CWE-476,c_cpp,An issue was discovered in in bwm-ng v0.6.2. An arbitrary null write exists in get_cmdln_options() function in src/options.c.,https://github.com/vgropp/bwm-ng/commit/9774f23bf78a6e6d3ae4cfe3d73bad34f2fdcd17,Fix https://github.com/vgropp/bwm-ng/issues/26,1,"[{""func_name"": ""get_cmdln_options"", ""file_path"": ""src/options.c"", ""func_code"": ""void get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\""timeout\"", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\""procfile\"",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\""diskstatsfile\"",1,0,1000},\n\t\t\t{\""partitionsfile\"",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\""netstat\"",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\""longdisknames\"",0,0,1002},\n#endif\n        {\""input\"",1,0,'i'},\n        {\""dynamic\"",1,0,'d'},\n        {\""help\"", 0, 0, 'h'},\n        {\""version\"",0,0,'V'},\n        {\""allif\"",1,0,'a'},\n        {\""unit\"",1,0,'u'},\n\t\t  {\""ansiout\"",0,0,'N'},\n#if EXTENDED_STATS        \n        {\""type\"",1,0,'T'},\n        {\""avglength\"",1,0,'A'},\n#endif        \n        {\""interfaces\"",1,0,'I'},\n        {\""sumhidden\"",1,0,'S'},\n        {\""output\"",1,0,'o'},\n#ifdef CSV\n        {\""csvchar\"",1,0,'C'},\n        {\""csvfile\"",1,0,'F'},\n#endif\n        {\""count\"",1,0,'c'},\n        {\""daemon\"",1,0,'D'},\n#ifdef HTML\n        {\""htmlrefresh\"",1,0,'R'},\n        {\""htmlheader\"",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\""/etc/bwm-ng.conf\"");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\""%s/.bwm-ng.conf\"",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\""unknown option: %s\\n\"",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\""-a\"") || !strcasecmp(argv[optind-1],\""--allif\"")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\""-d\"") || !strcasecmp(argv[optind-1],\""--dynamic\""))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\""-D\"") || !strcasecmp(argv[optind-1],\""--daemon\""))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\""-H\"") || !strcasecmp(argv[optind-1],\""--htmlheader\""))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\""-S\"") || !strcasecmp(argv[optind-1],\""--sumhidden\""))\n                            sumhidden=1;    \n                          else {\n                              printf(\""%s requires an argument!\\n\"",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\""a\""); \n                    if (!out_file) deinit(1, \""failed to open outfile\\n\"");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \""avglength needs to be a least twice the value of timeout\\n\"");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}"", ""target"": 0}]","[{""func_name"": ""get_cmdln_options"", ""file_path"": ""src/options.c"", ""func_code"": ""void get_cmdln_options(int argc, char *argv[]) {\n\tint o;\n#if CONFIG_FILE && HAVE_GETPWUID\n    static struct passwd *pwd_entry;\n    char *str;\n#endif\n#ifdef LONG_OPTIONS\n    int option_index = 0;\n    static struct option long_options[] = {\n        {\""timeout\"", 1, 0, 't'},\n#ifdef PROC_NET_DEV\n        {\""procfile\"",1,0,'f'},\n#endif\n#ifdef PROC_DISKSTATS\n\t\t\t{\""diskstatsfile\"",1,0,1000},\n\t\t\t{\""partitionsfile\"",1,0,1001},\n#endif\t\t  \n#if NETSTAT && ALLOW_NETSTATPATH\n        {\""netstat\"",1,0,'n'},\n#endif\n#if IOSERVICE_IN\n\t\t  {\""longdisknames\"",0,0,1002},\n#endif\n        {\""input\"",1,0,'i'},\n        {\""dynamic\"",1,0,'d'},\n        {\""help\"", 0, 0, 'h'},\n        {\""version\"",0,0,'V'},\n        {\""allif\"",1,0,'a'},\n        {\""unit\"",1,0,'u'},\n\t\t  {\""ansiout\"",0,0,'N'},\n#if EXTENDED_STATS        \n        {\""type\"",1,0,'T'},\n        {\""avglength\"",1,0,'A'},\n#endif        \n        {\""interfaces\"",1,0,'I'},\n        {\""sumhidden\"",1,0,'S'},\n        {\""output\"",1,0,'o'},\n#ifdef CSV\n        {\""csvchar\"",1,0,'C'},\n        {\""csvfile\"",1,0,'F'},\n#endif\n        {\""count\"",1,0,'c'},\n        {\""daemon\"",1,0,'D'},\n#ifdef HTML\n        {\""htmlrefresh\"",1,0,'R'},\n        {\""htmlheader\"",1,0,'H'},\n#endif\n        {0,0,0,0}\n    };\n#endif\n#ifdef CONFIG_FILE\n    /* loop till first non option argument */\n    opterr=0;\n    while (1) {\n#ifdef LONG_OPTIONS\n        o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n        o=getopt (argc,argv,SHORT_OPTIONS);\n#endif\n        if (o==-1) break;\n    }\n    opterr=1;\n    if (optind < argc) {\n        read_config(argv[optind]);\n    } else {\n        read_config(\""/etc/bwm-ng.conf\"");\n#ifdef HAVE_GETPWUID    \n        pwd_entry=getpwuid(getuid());\n        if (pwd_entry!=NULL) {\n            str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n            if(!str) {\n              printf(\""Fatal: failed to allocate %zu bytes.\\n\"", strlen(pwd_entry->pw_dir)+14);\n              exit(EXIT_FAILURE);\n            }\n            snprintf(str,strlen(pwd_entry->pw_dir)+14,\""%s/.bwm-ng.conf\"",pwd_entry->pw_dir);\n            read_config(str);\n            free(str);\n        }\n#endif    \n    }\n    /* reset getopt again  */\n    optind=1;\n#endif\n    /* get command line arguments, kinda ugly, wanna rewrite it? */\n    while (1) {\n#ifdef LONG_OPTIONS\n\t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n#else\n\t\to=getopt (argc,argv,SHORT_OPTIONS);\n#endif\t\t\n        if (o==-1) break;\n        switch (o) {\n            case '?': printf(\""unknown option: %s\\n\"",argv[optind-1]);\n                      exit(EXIT_FAILURE);\n                      break;\n            /* ugly workaround to handle optional arguments for all platforms */                      \n            case ':': if (!strcmp(argv[optind-1],\""-a\"") || !strcasecmp(argv[optind-1],\""--allif\"")) \n                            show_all_if=1;\n                      else if (!strcmp(argv[optind-1],\""-d\"") || !strcasecmp(argv[optind-1],\""--dynamic\""))\n                            dynamic=1;\n                      else if (!strcmp(argv[optind-1],\""-D\"") || !strcasecmp(argv[optind-1],\""--daemon\""))\n                            daemonize=1;\n#ifdef HTML                      \n                      else if (!strcmp(argv[optind-1],\""-H\"") || !strcasecmp(argv[optind-1],\""--htmlheader\""))\n                            html_header=1;\n#endif                      \n                      else if (!strcmp(argv[optind-1],\""-S\"") || !strcasecmp(argv[optind-1],\""--sumhidden\""))\n                            sumhidden=1;    \n                          else {\n                              printf(\""%s requires an argument!\\n\"",argv[optind-1]);\n                              exit(EXIT_FAILURE);\n                          }\n                      break;\n#ifdef PROC_DISKSTATS\n\t\t\tcase 1000:\n\t\t\t\tif (strlen(optarg)<PATH_MAX) \n\t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n\t\t\t\tbreak;\n         case 1001:\n            if (strlen(optarg)<PATH_MAX)\n               strcpy(PROC_PARTITIONS_FILE,optarg);\n\t\t\t\tbreak;\n#endif\t\t\t\t\n#if IOSERVICE_IN\n\t\t\tcase 1002:\n\t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'D':\n\t\t\t\tif (optarg) daemonize=atoi(optarg);\n\t\t\t\tbreak;\n#ifdef HTML\n\t\t\tcase 'R':\n\t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tif (optarg) html_header=atoi(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'c':\n\t\t\t\tif (optarg) output_count=atol(optarg);\n\t\t\t\tbreak;\n#if CSV || HTML\n            case 'F':\n                if (optarg) { \n                    if (out_file) fclose(out_file);\n                    out_file=fopen(optarg,\""a\""); \n                    if (!out_file) deinit(1, \""failed to open outfile\\n\"");\n                    if (out_file_path) free(out_file_path);\n                    out_file_path=(char *)strdup(optarg);\n                }\n                break;\n#endif\n#ifdef CSV\n\t\t\tcase 'C':\n\t\t\t\tif (optarg) csv_char=optarg[0];\n\t\t\t\tbreak;\n#endif\n            case 'h':\n                cmdln_printhelp();\n                break;\n#ifdef PROC_NET_DEV\n\t\t\tcase 'f':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                break;\n#endif\t\t\t\n\t\t\tcase 'i':\n                if (optarg) {\n                    input_method=str2in_method(optarg);\n                }\n\t\t\t\tbreak;\t\t\t\t\n            case 'I':\n                if (optarg) iface_list=(char *)strdup(optarg);\n                break;\n            case 'S':\n                if (optarg) sumhidden=atoi(optarg);\n                break;\n            case 'o':\n                if (optarg) {\n                    output_method=str2out_method(optarg);\n                }\n                break;\n\t\t\t\tcase 'N':\n\t\t\t\t\t ansi_output=!ansi_output;\n            case 'a':\n                if (optarg) show_all_if=atoi(optarg);\n                break;\n            case 't':\n                if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                break;\n#if EXTENDED_STATS                \n            case 'T':\n                output_type=str2output_type(optarg);\n                break;\n            case 'A':\n                if (optarg) avg_length=atoi(optarg)*1000;\n                break;\n#endif                \n            case 'd':\n                if (optarg) dynamic=atoi(optarg);\n                break;\n            case 'u':\n                output_unit=str2output_unit(optarg);\n                break;\n#if NETSTAT && ALLOW_NETSTATPATH\n            case 'n':\n                if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                break;\n#endif                \n            case 'V':\n                print_version;\n                exit(EXIT_SUCCESS);\n                break;\n        }\n    }\n    if (iface_list==NULL && show_all_if==1) show_all_if=2;\n#if EXTENDED_STATS    \n    /* default init of avg_length */\n    if (avg_length==0) {\n        if (delay<AVG_LENGTH/2) \n            avg_length=AVG_LENGTH; \n        else  \n            avg_length=(delay*2)+1;\n    } else /* avg_length was set via cmdline or config file, better check it */\n        if (delay*2>=avg_length) deinit(1, \""avglength needs to be a least twice the value of timeout\\n\"");\n#endif    \n\t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) || \n\t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN)) \n\t\toutput_unit=BYTES_OUT;\n    return;\n}""}]",{},[],"Original code flow: `str=(char*)malloc(...)` at `src/options.c:336` allocates memory without checking for failure. If `malloc` returns NULL, `snprintf(str, ...)` at the same file:line would attempt to write to a NULL pointer, causing an arbitrary null write. The patch introduces a NULL check for `str` and exits on failure, directly addressing this unsafe usage.",0.95,./github/other_context/CVE-2022-1341
