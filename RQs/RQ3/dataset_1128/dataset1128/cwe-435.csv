id,cve_id,cwe_id,language,description,commit_url,commit_msg,patch_nums,func_before,func_after,context_nums,context_data,root_cause,confidence_score,other_context_path
1,CVE-2019-18792,CWE-436,c_cpp,An issue was discovered in Suricata 5.0.0. It is possible to bypass/evade any tcp based signature by overlapping a TCP segment with a fake FIN packet. The fake FIN packet is injected just before the PUSH ACK packet we want to bypass. The PUSH ACK packet (containing the data) will be ignored by Suricata because it overlaps the FIN packet (the sequence and ack number are identical in the two packets). The client will ignore the fake FIN packet because the ACK flag is not set. Both linux and windows clients are ignoring the injected packet.,https://github.com/OISF/suricata/commit/fa692df37a796c3330c81988d15ef1a219afc006,"stream: reject broken ACK packets\n\nFix evasion posibility by rejecting packets with a broken ACK field.\nThese packets have a non-0 ACK field, but do not have a ACK flag set.\n\nBug #3324.\n\nReported-by: Nicolas Adba",2,"[{""func_name"": ""StreamTcpPacket"", ""file_path"": ""src/stream-tcp.c"", ""func_code"": ""int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\n                     PacketQueue *pq)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(p->flow);\n\n    SCLogDebug(\""p->pcap_cnt %\""PRIu64, p->pcap_cnt);\n\n    HandleThreadId(tv, p, stt);\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    /* track TCP flags */\n    if (ssn != NULL) {\n        ssn->tcp_packet_flags |= p->tcph->th_flags;\n        if (PKT_IS_TOSERVER(p))\n            ssn->client.tcp_flags |= p->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(p))\n            ssn->server.tcp_flags |= p->tcph->th_flags;\n\n        /* check if we need to unset the ASYNC flag */\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC &&\n            ssn->client.tcp_flags != 0 &&\n            ssn->server.tcp_flags != 0)\n        {\n            SCLogDebug(\""ssn %p: removing ASYNC flag as we have packets on both sides\"", ssn);\n            ssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n        }\n    }\n\n    /* update counters */\n    if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        StatsIncr(tv, stt->counter_tcp_synack);\n    } else if (p->tcph->th_flags & (TH_SYN)) {\n        StatsIncr(tv, stt->counter_tcp_syn);\n    }\n    if (p->tcph->th_flags & (TH_RST)) {\n        StatsIncr(tv, stt->counter_tcp_rst);\n    }\n\n    /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */\n    if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\n        StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n    }\n\n    /* If we are on IPS mode, and got a drop action triggered from\n     * the IP only module, or from a reassembled msg and/or from an\n     * applayer detection, then drop the rest of the packets of the\n     * same stream and avoid inspecting it any further */\n    if (StreamTcpCheckFlowDrops(p) == 1) {\n        SCLogDebug(\""This flow/stream triggered a drop rule\"");\n        FlowSetNoPacketInspectionFlag(p->flow);\n        DecodeSetNoPacketInspectionFlag(p);\n        StreamTcpDisableAppLayer(p->flow);\n        PACKET_DROP(p);\n        /* return the segments to the pool */\n        StreamTcpSessionPktFree(p);\n        SCReturnInt(0);\n    }\n\n    if (ssn == NULL || ssn->state == TCP_NONE) {\n        if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (ssn != NULL)\n            SCLogDebug(\""ssn->alproto %\""PRIu16\""\"", p->flow->alproto);\n    } else {\n        /* special case for PKT_PSEUDO_STREAM_END packets:\n         * bypass the state handling and various packet checks,\n         * we care about reassembly here. */\n        if (p->flags & PKT_PSEUDO_STREAM_END) {\n            if (PKT_IS_TOCLIENT(p)) {\n                ssn->client.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->server, p, pq);\n            } else {\n                ssn->server.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->client, p, pq);\n            }\n            /* straight to 'skip' as we already handled reassembly */\n            goto skip;\n        }\n\n        if (p->flow->flags & FLOW_WRONG_THREAD ||\n            ssn->client.flags & STREAMTCP_STREAM_FLAG_GAP ||\n            ssn->server.flags & STREAMTCP_STREAM_FLAG_GAP)\n        {\n            /* Stream and/or session in known bad condition. Block events\n             * from being set. */\n            p->flags |= PKT_STREAM_NO_EVENTS;\n        }\n\n        if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\n            StreamTcpClearKeepAliveFlag(ssn, p);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(ssn, p);\n\n        /* if packet is not a valid window update, check if it is perhaps\n         * a bad window update that we should ignore (and alert on) */\n        if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)\n            if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                    goto skip;\n\n        /* handle the per 'state' logic */\n        if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->state) < 0)\n            goto error;\n\n    skip:\n        StreamTcpPacketCheckPostRst(ssn, p);\n\n        if (ssn->state >= TCP_ESTABLISHED) {\n            p->flags |= PKT_STREAM_EST;\n        }\n    }\n\n    /* deal with a pseudo packet that is created upon receiving a RST\n     * segment. To be sure we process both sides of the connection, we\n     * inject a fake packet into the system, forcing reassembly of the\n     * opposing direction.\n     * There should be only one, but to be sure we do a while loop. */\n    if (ssn != NULL) {\n        while (stt->pseudo_queue.len > 0) {\n            SCLogDebug(\""processing pseudo packet / stream end\"");\n            Packet *np = PacketDequeue(&stt->pseudo_queue);\n            if (np != NULL) {\n                /* process the opposing direction of the original packet */\n                if (PKT_IS_TOSERVER(np)) {\n                    SCLogDebug(\""pseudo packet is to server\"");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->client, np, NULL);\n                } else {\n                    SCLogDebug(\""pseudo packet is to client\"");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->server, np, NULL);\n                }\n\n                /* enqueue this packet so we inspect it in detect etc */\n                PacketEnqueue(pq, np);\n            }\n            SCLogDebug(\""processing pseudo packet / stream end done\"");\n        }\n\n        /* recalc the csum on the packet if it was modified */\n        if (p->flags & PKT_STREAM_MODIFIED) {\n            ReCalculateChecksum(p);\n        }\n        /* check for conditions that may make us not want to log this packet */\n\n        /* streams that hit depth */\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n        }\n\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        /* encrypted packets */\n        if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n            (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_BYPASS) {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n\n        /* if stream is dead and we have no detect engine at all, bypass. */\n        } else if (g_detect_disabled &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\""bypass as stream is dead and we have no rules\"");\n            PacketBypassCallback(p);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* make sure we don't leave packets in our pseudo queue */\n    while (stt->pseudo_queue.len > 0) {\n        Packet *np = PacketDequeue(&stt->pseudo_queue);\n        if (np != NULL) {\n            PacketEnqueue(pq, np);\n        }\n    }\n\n    /* recalc the csum on the packet if it was modified */\n    if (p->flags & PKT_STREAM_MODIFIED) {\n        ReCalculateChecksum(p);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* disable payload inspection as we're dropping this packet\n         * anyway. Doesn't disable all detection, so we can still\n         * match on the stream event that was set. */\n        DecodeSetNoPayloadInspectionFlag(p);\n        PACKET_DROP(p);\n    }\n    SCReturnInt(-1);\n}"", ""target"": 0}, {""func_name"": ""StreamTcpTest10"", ""file_path"": ""src/stream-tcp.c"", ""func_code"": ""static int StreamTcpTest10 (void)\n{\n    Packet *p = SCMalloc(SIZE_OF_PACKET);\n    FAIL_IF(unlikely(p == NULL));\n    Flow f;\n    ThreadVars tv;\n    StreamTcpThread stt;\n    TCPHdr tcph;\n    uint8_t payload[4];\n    memset(p, 0, SIZE_OF_PACKET);\n    PacketQueue pq;\n    memset(&pq,0,sizeof(PacketQueue));\n    memset (&f, 0, sizeof(Flow));\n    memset(&tv, 0, sizeof (ThreadVars));\n    memset(&stt, 0, sizeof (StreamTcpThread));\n    memset(&tcph, 0, sizeof (TCPHdr));\n    FLOW_INITIALIZE(&f);\n    p->flow = &f;\n\n    StreamTcpUTInit(&stt.ra_ctx);\n    stream_config.async_oneside = TRUE;\n\n    tcph.th_win = htons(5480);\n    tcph.th_seq = htonl(10);\n    tcph.th_ack = htonl(11);\n    tcph.th_flags = TH_SYN;\n    p->tcph = &tcph;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    p->tcph->th_seq = htonl(11);\n    p->tcph->th_ack = htonl(11);\n    p->tcph->th_flags = TH_ACK;\n    p->flowflags = FLOW_PKT_TOSERVER;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    p->tcph->th_seq = htonl(11);\n    p->tcph->th_ack = htonl(11);\n    p->tcph->th_flags = TH_ACK|TH_PUSH;\n    p->flowflags = FLOW_PKT_TOSERVER;\n\n    StreamTcpCreateTestPacket(payload, 0x42, 3, 4); /*BBB*/\n    p->payload = payload;\n    p->payload_len = 3;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    p->tcph->th_seq = htonl(6);\n    p->tcph->th_ack = htonl(11);\n    p->tcph->th_flags = TH_ACK|TH_PUSH;\n    p->flowflags = FLOW_PKT_TOSERVER;\n\n    StreamTcpCreateTestPacket(payload, 0x42, 3, 4); /*BBB*/\n    p->payload = payload;\n    p->payload_len = 3;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    FAIL_IF(((TcpSession *)(p->flow->protoctx))->state != TCP_ESTABLISHED);\n\n    FAIL_IF(! (((TcpSession *)(p->flow->protoctx))->flags & STREAMTCP_FLAG_ASYNC));\n\n    FAIL_IF(((TcpSession *)(p->flow->protoctx))->client.last_ack != 6 &&\n            ((TcpSession *)(p->flow->protoctx))->server.next_seq != 11);\n\n    StreamTcpSessionClear(p->flow->protoctx);\n\n    SCFree(p);\n    FLOW_DESTROY(&f);\n    StreamTcpUTDeinit(stt.ra_ctx);\n    PASS;\n}"", ""target"": 0}]","[{""func_name"": ""StreamTcpPacket"", ""file_path"": ""src/stream-tcp.c"", ""func_code"": ""int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\n                     PacketQueue *pq)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(p->flow);\n\n    SCLogDebug(\""p->pcap_cnt %\""PRIu64, p->pcap_cnt);\n\n    HandleThreadId(tv, p, stt);\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    /* track TCP flags */\n    if (ssn != NULL) {\n        ssn->tcp_packet_flags |= p->tcph->th_flags;\n        if (PKT_IS_TOSERVER(p))\n            ssn->client.tcp_flags |= p->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(p))\n            ssn->server.tcp_flags |= p->tcph->th_flags;\n\n        /* check if we need to unset the ASYNC flag */\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC &&\n            ssn->client.tcp_flags != 0 &&\n            ssn->server.tcp_flags != 0)\n        {\n            SCLogDebug(\""ssn %p: removing ASYNC flag as we have packets on both sides\"", ssn);\n            ssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n        }\n    }\n\n    /* update counters */\n    if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        StatsIncr(tv, stt->counter_tcp_synack);\n    } else if (p->tcph->th_flags & (TH_SYN)) {\n        StatsIncr(tv, stt->counter_tcp_syn);\n    }\n    if (p->tcph->th_flags & (TH_RST)) {\n        StatsIncr(tv, stt->counter_tcp_rst);\n    }\n\n    /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */\n    if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\n        StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n        goto error;\n    }\n\n    /* If we are on IPS mode, and got a drop action triggered from\n     * the IP only module, or from a reassembled msg and/or from an\n     * applayer detection, then drop the rest of the packets of the\n     * same stream and avoid inspecting it any further */\n    if (StreamTcpCheckFlowDrops(p) == 1) {\n        SCLogDebug(\""This flow/stream triggered a drop rule\"");\n        FlowSetNoPacketInspectionFlag(p->flow);\n        DecodeSetNoPacketInspectionFlag(p);\n        StreamTcpDisableAppLayer(p->flow);\n        PACKET_DROP(p);\n        /* return the segments to the pool */\n        StreamTcpSessionPktFree(p);\n        SCReturnInt(0);\n    }\n\n    if (ssn == NULL || ssn->state == TCP_NONE) {\n        if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (ssn != NULL)\n            SCLogDebug(\""ssn->alproto %\""PRIu16\""\"", p->flow->alproto);\n    } else {\n        /* special case for PKT_PSEUDO_STREAM_END packets:\n         * bypass the state handling and various packet checks,\n         * we care about reassembly here. */\n        if (p->flags & PKT_PSEUDO_STREAM_END) {\n            if (PKT_IS_TOCLIENT(p)) {\n                ssn->client.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->server, p, pq);\n            } else {\n                ssn->server.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->client, p, pq);\n            }\n            /* straight to 'skip' as we already handled reassembly */\n            goto skip;\n        }\n\n        if (p->flow->flags & FLOW_WRONG_THREAD ||\n            ssn->client.flags & STREAMTCP_STREAM_FLAG_GAP ||\n            ssn->server.flags & STREAMTCP_STREAM_FLAG_GAP)\n        {\n            /* Stream and/or session in known bad condition. Block events\n             * from being set. */\n            p->flags |= PKT_STREAM_NO_EVENTS;\n        }\n\n        if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\n            StreamTcpClearKeepAliveFlag(ssn, p);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(ssn, p);\n\n        /* if packet is not a valid window update, check if it is perhaps\n         * a bad window update that we should ignore (and alert on) */\n        if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)\n            if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                    goto skip;\n\n        /* handle the per 'state' logic */\n        if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->state) < 0)\n            goto error;\n\n    skip:\n        StreamTcpPacketCheckPostRst(ssn, p);\n\n        if (ssn->state >= TCP_ESTABLISHED) {\n            p->flags |= PKT_STREAM_EST;\n        }\n    }\n\n    /* deal with a pseudo packet that is created upon receiving a RST\n     * segment. To be sure we process both sides of the connection, we\n     * inject a fake packet into the system, forcing reassembly of the\n     * opposing direction.\n     * There should be only one, but to be sure we do a while loop. */\n    if (ssn != NULL) {\n        while (stt->pseudo_queue.len > 0) {\n            SCLogDebug(\""processing pseudo packet / stream end\"");\n            Packet *np = PacketDequeue(&stt->pseudo_queue);\n            if (np != NULL) {\n                /* process the opposing direction of the original packet */\n                if (PKT_IS_TOSERVER(np)) {\n                    SCLogDebug(\""pseudo packet is to server\"");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->client, np, NULL);\n                } else {\n                    SCLogDebug(\""pseudo packet is to client\"");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->server, np, NULL);\n                }\n\n                /* enqueue this packet so we inspect it in detect etc */\n                PacketEnqueue(pq, np);\n            }\n            SCLogDebug(\""processing pseudo packet / stream end done\"");\n        }\n\n        /* recalc the csum on the packet if it was modified */\n        if (p->flags & PKT_STREAM_MODIFIED) {\n            ReCalculateChecksum(p);\n        }\n        /* check for conditions that may make us not want to log this packet */\n\n        /* streams that hit depth */\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n        }\n\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        /* encrypted packets */\n        if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n            (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_BYPASS) {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n\n        /* if stream is dead and we have no detect engine at all, bypass. */\n        } else if (g_detect_disabled &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\""bypass as stream is dead and we have no rules\"");\n            PacketBypassCallback(p);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* make sure we don't leave packets in our pseudo queue */\n    while (stt->pseudo_queue.len > 0) {\n        Packet *np = PacketDequeue(&stt->pseudo_queue);\n        if (np != NULL) {\n            PacketEnqueue(pq, np);\n        }\n    }\n\n    /* recalc the csum on the packet if it was modified */\n    if (p->flags & PKT_STREAM_MODIFIED) {\n        ReCalculateChecksum(p);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* disable payload inspection as we're dropping this packet\n         * anyway. Doesn't disable all detection, so we can still\n         * match on the stream event that was set. */\n        DecodeSetNoPayloadInspectionFlag(p);\n        PACKET_DROP(p);\n    }\n    SCReturnInt(-1);\n}""}, {""func_name"": ""StreamTcpTest10"", ""file_path"": ""src/stream-tcp.c"", ""func_code"": ""static int StreamTcpTest10 (void)\n{\n    Packet *p = SCMalloc(SIZE_OF_PACKET);\n    FAIL_IF(unlikely(p == NULL));\n    Flow f;\n    ThreadVars tv;\n    StreamTcpThread stt;\n    TCPHdr tcph;\n    uint8_t payload[4];\n    memset(p, 0, SIZE_OF_PACKET);\n    PacketQueue pq;\n    memset(&pq,0,sizeof(PacketQueue));\n    memset (&f, 0, sizeof(Flow));\n    memset(&tv, 0, sizeof (ThreadVars));\n    memset(&stt, 0, sizeof (StreamTcpThread));\n    memset(&tcph, 0, sizeof (TCPHdr));\n    FLOW_INITIALIZE(&f);\n    p->flow = &f;\n\n    StreamTcpUTInit(&stt.ra_ctx);\n    stream_config.async_oneside = TRUE;\n\n    tcph.th_win = htons(5480);\n    tcph.th_seq = htonl(10);\n    tcph.th_ack = 0;\n    tcph.th_flags = TH_SYN;\n    p->tcph = &tcph;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    p->tcph->th_seq = htonl(11);\n    p->tcph->th_ack = htonl(11);\n    p->tcph->th_flags = TH_ACK;\n    p->flowflags = FLOW_PKT_TOSERVER;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    p->tcph->th_seq = htonl(11);\n    p->tcph->th_ack = htonl(11);\n    p->tcph->th_flags = TH_ACK|TH_PUSH;\n    p->flowflags = FLOW_PKT_TOSERVER;\n\n    StreamTcpCreateTestPacket(payload, 0x42, 3, 4); /*BBB*/\n    p->payload = payload;\n    p->payload_len = 3;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    p->tcph->th_seq = htonl(6);\n    p->tcph->th_ack = htonl(11);\n    p->tcph->th_flags = TH_ACK|TH_PUSH;\n    p->flowflags = FLOW_PKT_TOSERVER;\n\n    StreamTcpCreateTestPacket(payload, 0x42, 3, 4); /*BBB*/\n    p->payload = payload;\n    p->payload_len = 3;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    FAIL_IF(((TcpSession *)(p->flow->protoctx))->state != TCP_ESTABLISHED);\n\n    FAIL_IF(! (((TcpSession *)(p->flow->protoctx))->flags & STREAMTCP_FLAG_ASYNC));\n\n    FAIL_IF(((TcpSession *)(p->flow->protoctx))->client.last_ack != 6 &&\n            ((TcpSession *)(p->flow->protoctx))->server.next_seq != 11);\n\n    StreamTcpSessionClear(p->flow->protoctx);\n\n    SCFree(p);\n    FLOW_DESTROY(&f);\n    StreamTcpUTDeinit(stt.ra_ctx);\n    PASS;\n}""}]","{""caller"": 1, ""code"": 3, ""function"": 4}","[{""source"": ""caller_info(file:stream-tcp.c, func:StreamTcpPacket)"", ""result"": [{""call_line"": 5210, ""call_code"": ""StreamTcpPacket(tv, p, stt, pq)"", ""caller_code"": ""TmEcode StreamTcp (ThreadVars *tv, Packet *p, void *data, PacketQueue *pq, PacketQueue *postpq)\n{\n    StreamTcpThread *stt = (StreamTcpThread *)data;\n\n    SCLogDebug(\""p->pcap_cnt %\""PRIu64, p->pcap_cnt);\n\n    if (!(PKT_IS_TCP(p))) {\n        return TM_ECODE_OK;\n    }\n\n    if (p->flow == NULL) {\n        StatsIncr(tv, stt->counter_tcp_no_flow);\n        return TM_ECODE_OK;\n    }\n\n    /* only TCP packets with a flow from here */\n\n    if (!(p->flags & PKT_PSEUDO_STREAM_END)) {\n        if (stream_config.flags & STREAMTCP_INIT_FLAG_CHECKSUM_VALIDATION) {\n            if (StreamTcpValidateChecksum(p) == 0) {\n                StatsIncr(tv, stt->counter_tcp_invalid_checksum);\n                return TM_ECODE_OK;\n            }\n        } else {\n            p->flags |= PKT_IGNORE_CHECKSUM;\n        }\n    } else {\n        p->flags |= PKT_IGNORE_CHECKSUM; //TODO check that this is set at creation\n    }\n    AppLayerProfilingReset(stt->ra_ctx->app_tctx);\n\n    (void)StreamTcpPacket(tv, p, stt, pq);\n\n    return TM_ECODE_OK;\n}\n"", ""caller_start"": 5179, ""file_path"": ""src/stream-tcp.c""}]}, {""source"": ""code_info(file:stream-tcp.c, lines:4790-4820)"", ""result"": ""        }\n    }\n\n    /* update counters */\n    if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        StatsIncr(tv, stt->counter_tcp_synack);\n    } else if (p->tcph->th_flags & (TH_SYN)) {\n        StatsIncr(tv, stt->counter_tcp_syn);\n    }\n    if (p->tcph->th_flags & (TH_RST)) {\n        StatsIncr(tv, stt->counter_tcp_rst);\n    }\n\n    /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */\n    if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\n        StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n    }\n\n    /* If we are on IPS mode, and got a drop action triggered from\n     * the IP only module, or from a reassembled msg and/or from an\n     * applayer detection, then drop the rest of the packets of the\n     * same stream and avoid inspecting it any further */\n    if (StreamTcpCheckFlowDrops(p) == 1) {\n        SCLogDebug(\""This flow/stream triggered a drop rule\"");\n        FlowSetNoPacketInspectionFlag(p->flow);\n        DecodeSetNoPacketInspectionFlag(p);\n        StreamTcpDisableAppLayer(p->flow);\n        PACKET_DROP(p);\n        /* return the segments to the pool */\n        StreamTcpSessionPktFree(p);\n        SCReturnInt(0);\n    }\n""}, {""source"": ""code_info(file:stream-tcp.c, lines:4820-5000)"", ""result"": ""        SCReturnInt(0);\n    }\n\n    if (ssn == NULL || ssn->state == TCP_NONE) {\n        if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (ssn != NULL)\n            SCLogDebug(\""ssn->alproto %\""PRIu16\""\"", p->flow->alproto);\n    } else {\n        /* special case for PKT_PSEUDO_STREAM_END packets:\n         * bypass the state handling and various packet checks,\n         * we care about reassembly here. */\n        if (p->flags & PKT_PSEUDO_STREAM_END) {\n            if (PKT_IS_TOCLIENT(p)) {\n                ssn->client.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->server, p, pq);\n            } else {\n                ssn->server.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->client, p, pq);\n            }\n            /* straight to 'skip' as we already handled reassembly */\n            goto skip;\n        }\n\n        if (p->flow->flags & FLOW_WRONG_THREAD ||\n            ssn->client.flags & STREAMTCP_STREAM_FLAG_GAP ||\n            ssn->server.flags & STREAMTCP_STREAM_FLAG_GAP)\n        {\n            /* Stream and/or session in known bad condition. Block events\n             * from being set. */\n            p->flags |= PKT_STREAM_NO_EVENTS;\n        }\n\n        if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\n            StreamTcpClearKeepAliveFlag(ssn, p);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(ssn, p);\n\n        /* if packet is not a valid window update, check if it is perhaps\n         * a bad window update that we should ignore (and alert on) */\n        if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)\n            if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                    goto skip;\n\n        /* handle the per 'state' logic */\n        if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->state) < 0)\n            goto error;\n\n    skip:\n        StreamTcpPacketCheckPostRst(ssn, p);\n\n        if (ssn->state >= TCP_ESTABLISHED) {\n            p->flags |= PKT_STREAM_EST;\n        }\n    }\n\n    /* deal with a pseudo packet that is created upon receiving a RST\n     * segment. To be sure we process both sides of the connection, we\n     * inject a fake packet into the system, forcing reassembly of the\n     * opposing direction.\n     * There should be only one, but to be sure we do a while loop. */\n    if (ssn != NULL) {\n        while (stt->pseudo_queue.len > 0) {\n            SCLogDebug(\""processing pseudo packet / stream end\"");\n            Packet *np = PacketDequeue(&stt->pseudo_queue);\n            if (np != NULL) {\n                /* process the opposing direction of the original packet */\n                if (PKT_IS_TOSERVER(np)) {\n                    SCLogDebug(\""pseudo packet is to server\"");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->client, np, NULL);\n                } else {\n                    SCLogDebug(\""pseudo packet is to client\"");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->server, np, NULL);\n                }\n\n                /* enqueue this packet so we inspect it in detect etc */\n                PacketEnqueue(pq, np);\n            }\n            SCLogDebug(\""processing pseudo packet / stream end done\"");\n        }\n\n        /* recalc the csum on the packet if it was modified */\n        if (p->flags & PKT_STREAM_MODIFIED) {\n            ReCalculateChecksum(p);\n        }\n        /* check for conditions that may make us not want to log this packet */\n\n        /* streams that hit depth */\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n        }\n\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        /* encrypted packets */\n        if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n            (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_BYPASS) {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n\n        /* if stream is dead and we have no detect engine at all, bypass. */\n        } else if (g_detect_disabled &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\""bypass as stream is dead and we have no rules\"");\n            PacketBypassCallback(p);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* make sure we don't leave packets in our pseudo queue */\n    while (stt->pseudo_queue.len > 0) {\n        Packet *np = PacketDequeue(&stt->pseudo_queue);\n        if (np != NULL) {\n            PacketEnqueue(pq, np);\n        }\n    }\n\n    /* recalc the csum on the packet if it was modified */\n    if (p->flags & PKT_STREAM_MODIFIED) {\n        ReCalculateChecksum(p);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* disable payload inspection as we're dropping this packet\n         * anyway. Doesn't disable all detection, so we can still\n         * match on the stream event that was set. */\n        DecodeSetNoPayloadInspectionFlag(p);\n        PACKET_DROP(p);\n    }\n    SCReturnInt(-1);\n}\n\n/**\n *  \\brief  Function to validate the checksum of the received packet. If the\n *          checksum is invalid, packet will be dropped, as the end system will\n *          also drop the packet.\n *\n *  \\param  p       Packet of which checksum has to be validated\n *  \\retval  1 if the checksum is valid, otherwise 0\n */\nstatic inline int StreamTcpValidateChecksum(Packet *p)\n{\n    int ret = 1;\n\n    if (p->flags & PKT_IGNORE_CHECKSUM)\n        return ret;\n\n    if (p->level4_comp_csum == -1) {\n        if (PKT_IS_IPV4(p)) {\n            p->level4_comp_csum = TCPChecksum(p->ip4h->s_ip_addrs,\n""}, {""source"": ""func_info(func:StreamTcpReassembleHandleSegment)"", ""result"": [{""code"": ""int StreamTcpReassembleHandleSegment(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx,\n                                     TcpSession *ssn, TcpStream *stream,\n                                     Packet *p, PacketQueue *pq)\n{\n    SCEnter();\n\n    DEBUG_VALIDATE_BUG_ON(p->tcph == NULL);\n\n    SCLogDebug(\""ssn %p, stream %p, p %p, p->payload_len %\""PRIu16\""\"",\n                ssn, stream, p, p->payload_len);\n\n    /* we need to update the opposing stream in\n     * StreamTcpReassembleHandleSegmentUpdateACK */\n    TcpStream *opposing_stream = NULL;\n    if (stream == &ssn->client) {\n        opposing_stream = &ssn->server;\n    } else {\n        opposing_stream = &ssn->client;\n    }\n\n    /* default IDS: update opposing side (triggered by ACK) */\n    enum StreamUpdateDir dir = UPDATE_DIR_OPPOSING;\n    /* inline and stream end and flow timeout packets trigger same dir handling */\n    if (StreamTcpInlineMode()) {\n        dir = UPDATE_DIR_PACKET;\n    } else if (p->flags & PKT_PSEUDO_STREAM_END) {\n        dir = UPDATE_DIR_PACKET;\n    } else if (p->tcph->th_flags & TH_RST) { // accepted rst\n        dir = UPDATE_DIR_PACKET;\n    } else if ((p->tcph->th_flags & TH_FIN) && ssn->state > TCP_TIME_WAIT) {\n        dir = UPDATE_DIR_PACKET;\n    } else if (ssn->state == TCP_CLOSED) {\n        dir = UPDATE_DIR_BOTH;\n    }\n\n    /* handle ack received */\n    if ((dir == UPDATE_DIR_OPPOSING || dir == UPDATE_DIR_BOTH) &&\n        StreamTcpReassembleHandleSegmentUpdateACK(tv, ra_ctx, ssn, opposing_stream, p) != 0)\n    {\n        SCLogDebug(\""StreamTcpReassembleHandleSegmentUpdateACK error\"");\n        SCReturnInt(-1);\n    }\n\n    /* if this segment contains data, insert it */\n    if (p->payload_len > 0 && !(stream->flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) {\n        SCLogDebug(\""calling StreamTcpReassembleHandleSegmentHandleData\"");\n\n        if (StreamTcpReassembleHandleSegmentHandleData(tv, ra_ctx, ssn, stream, p) != 0) {\n            SCLogDebug(\""StreamTcpReassembleHandleSegmentHandleData error\"");\n            SCReturnInt(-1);\n        }\n\n        SCLogDebug(\""packet %\""PRIu64\"" set PKT_STREAM_ADD\"", p->pcap_cnt);\n        p->flags |= PKT_STREAM_ADD;\n    } else {\n        SCLogDebug(\""ssn %p / stream %p: not calling StreamTcpReassembleHandleSegmentHandleData:\""\n                \"" p->payload_len %u, STREAMTCP_STREAM_FLAG_NOREASSEMBLY %s\"",\n                ssn, stream, p->payload_len,\n                (stream->flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) ? \""true\"" : \""false\"");\n\n    }\n\n    /* if the STREAMTCP_STREAM_FLAG_DEPTH_REACHED is set, but not the\n     * STREAMTCP_STREAM_FLAG_NOREASSEMBLY flag, it means the DEPTH flag\n     * was *just* set. In this case we trigger the AppLayer Truncate\n     * logic, to inform the applayer no more data in this direction is\n     * to be expected. */\n    if ((stream->flags &\n                (STREAMTCP_STREAM_FLAG_DEPTH_REACHED|STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ==\n            STREAMTCP_STREAM_FLAG_DEPTH_REACHED)\n    {\n        SCLogDebug(\""STREAMTCP_STREAM_FLAG_DEPTH_REACHED, truncate applayer\"");\n        if (dir != UPDATE_DIR_PACKET) {\n            SCLogDebug(\""override: direction now UPDATE_DIR_PACKET so we \""\n                    \""can trigger Truncate\"");\n            dir = UPDATE_DIR_PACKET;\n        }\n    }\n\n    /* in stream inline mode even if we have no data we call the reassembly\n     * functions to handle EOF */\n    if (dir == UPDATE_DIR_PACKET || dir == UPDATE_DIR_BOTH) {\n        SCLogDebug(\""inline (%s) or PKT_PSEUDO_STREAM_END (%s)\"",\n                StreamTcpInlineMode()?\""true\"":\""false\"",\n                (p->flags & PKT_PSEUDO_STREAM_END) ?\""true\"":\""false\"");\n        if (StreamTcpReassembleAppLayer(tv, ra_ctx, ssn, stream, p, dir) < 0) {\n            SCReturnInt(-1);\n        }\n    }\n\n    SCReturnInt(0);\n}\n"", ""start_line"": 1706, ""end_line"": 1797, ""full_name"": ""StreamTcpReassembleHandleSegment"", ""file_path"": ""src/stream-tcp-reassemble.c""}]}, {""source"": ""code_info(file:stream-tcp-reassemble.c, lines:1800-1900)"", ""result"": "" *  \\brief get a segment from the pool\n *\n *  \\retval seg Segment from the pool or NULL\n */\nTcpSegment *StreamTcpGetSegment(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx)\n{\n    TcpSegment *seg = (TcpSegment *) PoolThreadGetById(segment_thread_pool, ra_ctx->segment_thread_pool_id);\n    SCLogDebug(\""seg we return is %p\"", seg);\n    if (seg == NULL) {\n        /* Increment the counter to show that we are not able to serve the\n           segment request due to memcap limit */\n        StatsIncr(tv, ra_ctx->counter_tcp_segment_memcap);\n    } else {\n        memset(&seg->sbseg, 0, sizeof(seg->sbseg));\n    }\n\n    return seg;\n}\n\n/**\n *  \\brief Trigger RAW stream reassembly\n *\n *  Used by AppLayerTriggerRawStreamReassembly to trigger RAW stream\n *  reassembly from the applayer, for example upon completion of a\n *  HTTP request.\n *\n *  It sets a flag in the stream so that the next Raw call will return\n *  the data.\n *\n *  \\param ssn TcpSession\n */\nvoid StreamTcpReassembleTriggerRawReassembly(TcpSession *ssn, int direction)\n{\n#ifdef DEBUG\n    BUG_ON(ssn == NULL);\n#endif\n\n    if (ssn != NULL) {\n        if (direction == STREAM_TOSERVER) {\n            ssn->client.flags |= STREAMTCP_STREAM_FLAG_TRIGGER_RAW;\n        } else {\n            ssn->server.flags |= STREAMTCP_STREAM_FLAG_TRIGGER_RAW;\n        }\n\n        SCLogDebug(\""flagged ssn %p for immediate raw reassembly\"", ssn);\n    }\n}\n\nvoid StreamTcpReassemblySetMinInspectDepth(TcpSession *ssn, int direction, uint32_t depth)\n{\n#ifdef DEBUG\n    BUG_ON(ssn == NULL);\n#endif\n\n    if (ssn != NULL) {\n        if (direction == STREAM_TOSERVER) {\n            ssn->client.min_inspect_depth = depth;\n            SCLogDebug(\""ssn %p: set client.min_inspect_depth to %u\"", ssn, depth);\n        } else {\n            ssn->server.min_inspect_depth = depth;\n            SCLogDebug(\""ssn %p: set server.min_inspect_depth to %u\"", ssn, depth);\n        }\n    }\n}\n\n#ifdef UNITTESTS\n/** unit tests and it's support functions below */\n\n#define SET_ISN(stream, setseq)             \\\n    (stream)->isn = (setseq);               \\\n    (stream)->base_seq = (setseq) + 1\n\n/** \\brief  The Function to create the packet with given payload, which is used\n *          to test the reassembly of the engine.\n *\n *  \\param  payload     The variable used to store the payload contents of the\n *                      current packet.\n *  \\param  value       The value which current payload will have for this packet\n *  \\param  payload_len The length of the filed payload for current packet.\n *  \\param  len         Length of the payload array\n */\n\nvoid StreamTcpCreateTestPacket(uint8_t *payload, uint8_t value,\n                               uint8_t payload_len, uint8_t len)\n{\n    uint8_t i;\n    for (i = 0; i < payload_len; i++)\n        payload[i] = value;\n    for (; i < len; i++)\n        payload = NULL;\n}\n\n/** \\brief  The Function Checks the reassembled stream contents against predefined\n *          stream contents according to OS policy used.\n *\n *  \\param  stream_policy   Predefined value of stream for different OS policies\n *  \\param  stream          Reassembled stream returned from the reassembly functions\n */\n\nint StreamTcpCheckStreamContents(uint8_t *stream_policy, uint16_t sp_size, TcpStream *stream)\n{\n    if (StreamingBufferCompareRawData(&stream->sb, stream_policy,(uint32_t)sp_size) == 0)\n""}, {""source"": ""func_info(file:stream-tcp-reassemble.c, func:StreamTcpReassembleHandleSegmentHandleData)"", ""result"": [{""code"": ""int StreamTcpReassembleHandleSegmentHandleData(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx,\n                                TcpSession *ssn, TcpStream *stream, Packet *p)\n{\n    SCEnter();\n\n    if (ssn->data_first_seen_dir == 0) {\n        if (PKT_IS_TOSERVER(p)) {\n            ssn->data_first_seen_dir = STREAM_TOSERVER;\n        } else {\n            ssn->data_first_seen_dir = STREAM_TOCLIENT;\n        }\n    }\n\n    /* If the OS policy is not set then set the OS policy for this stream */\n    if (stream->os_policy == 0) {\n        StreamTcpSetOSPolicy(stream, p);\n    }\n\n    if ((ssn->flags & STREAMTCP_FLAG_APP_LAYER_DISABLED) &&\n        (stream->flags & STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED)) {\n        SCLogDebug(\""ssn %p: both app and raw reassembly disabled, not reassembling\"", ssn);\n        SCReturnInt(0);\n    }\n\n    /* If we have reached the defined depth for either of the stream, then stop\n       reassembling the TCP session */\n    uint32_t size = StreamTcpReassembleCheckDepth(ssn, stream, TCP_GET_SEQ(p), p->payload_len);\n    SCLogDebug(\""ssn %p: check depth returned %\""PRIu32, ssn, size);\n\n    if (stream->flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) {\n        /* increment stream depth counter */\n        StatsIncr(tv, ra_ctx->counter_tcp_stream_depth);\n    }\n    if (size == 0) {\n        SCLogDebug(\""ssn %p: depth reached, not reassembling\"", ssn);\n        SCReturnInt(0);\n    }\n\n    DEBUG_VALIDATE_BUG_ON(size > p->payload_len);\n    if (size > p->payload_len)\n        size = p->payload_len;\n\n    TcpSegment *seg = StreamTcpGetSegment(tv, ra_ctx);\n    if (seg == NULL) {\n        SCLogDebug(\""segment_pool is empty\"");\n        StreamTcpSetEvent(p, STREAM_REASSEMBLY_NO_SEGMENT);\n        SCReturnInt(-1);\n    }\n\n    TCP_SEG_LEN(seg) = size;\n    seg->seq = TCP_GET_SEQ(p);\n\n    /* proto detection skipped, but now we do get data. Set event. */\n    if (RB_EMPTY(&stream->seg_tree) &&\n        stream->flags & STREAMTCP_STREAM_FLAG_APPPROTO_DETECTION_SKIPPED) {\n\n        AppLayerDecoderEventsSetEventRaw(&p->app_layer_events,\n                APPLAYER_PROTO_DETECTION_SKIPPED);\n    }\n\n    if (StreamTcpReassembleInsertSegment(tv, ra_ctx, stream, seg, p, TCP_GET_SEQ(p), p->payload, p->payload_len) != 0) {\n        SCLogDebug(\""StreamTcpReassembleInsertSegment failed\"");\n        SCReturnInt(-1);\n    }\n    SCReturnInt(0);\n}\n"", ""start_line"": 593, ""end_line"": 658, ""full_name"": ""StreamTcpReassembleHandleSegmentHandleData"", ""file_path"": ""src/stream-tcp-reassemble.c""}]}, {""source"": ""func_info(func:StreamTcpReassembleInsertSegment)"", ""result"": [{""code"": ""int StreamTcpReassembleInsertSegment(ThreadVars *tv, TcpReassemblyThreadCtx *ra_ctx,\n        TcpStream *stream, TcpSegment *seg, Packet *p,\n        uint32_t pkt_seq, uint8_t *pkt_data, uint16_t pkt_datalen)\n{\n    SCEnter();\n\n    TcpSegment *dup_seg = NULL;\n\n    /* insert segment into list. Note: doesn't handle the data */\n    int r = DoInsertSegment (stream, seg, &dup_seg, p);\n    SCLogDebug(\""DoInsertSegment returned %d\"", r);\n    if (r < 0) {\n        StatsIncr(tv, ra_ctx->counter_tcp_reass_list_fail);\n        StreamTcpSegmentReturntoPool(seg);\n        SCReturnInt(-1);\n    }\n\n    if (likely(r == 0)) {\n        /* no overlap, straight data insert */\n        int res = InsertSegmentDataCustom(stream, seg, pkt_data, pkt_datalen);\n        if (res < 0) {\n            StatsIncr(tv, ra_ctx->counter_tcp_reass_data_normal_fail);\n            StreamTcpRemoveSegmentFromStream(stream, seg);\n            StreamTcpSegmentReturntoPool(seg);\n            SCReturnInt(-1);\n        }\n\n    } else if (r == 1 || r == 2) {\n        SCLogDebug(\""overlap (%s%s)\"", r == 1 ? \""normal\"" : \""\"", r == 2 ? \""duplicate\"" : \""\"");\n\n        if (r == 2) {\n            SCLogDebug(\""dup_seg %p\"", dup_seg);\n        }\n\n        /* XXX should we exclude 'retransmissions' here? */\n        StatsIncr(tv, ra_ctx->counter_tcp_reass_overlap);\n\n        /* now let's consider the data in the overlap case */\n        int res = DoHandleData(tv, ra_ctx, stream, seg, dup_seg, p);\n        if (res < 0) {\n            StatsIncr(tv, ra_ctx->counter_tcp_reass_data_overlap_fail);\n\n            if (r == 1) // r == 2 mean seg wasn't added to stream\n                StreamTcpRemoveSegmentFromStream(stream, seg);\n\n            StreamTcpSegmentReturntoPool(seg);\n            SCReturnInt(-1);\n        }\n        if (r == 2) {\n            SCLogDebug(\""duplicate segment %u/%u, discard it\"",\n                    seg->seq, seg->payload_len);\n\n            StreamTcpSegmentReturntoPool(seg);\n#ifdef DEBUG\n            if (SCLogDebugEnabled()) {\n                TcpSegment *s = NULL, *safe = NULL;\n                RB_FOREACH_SAFE(s, TCPSEG, &stream->seg_tree, safe)\n                {\n                    SCLogDebug(\""tree: seg %p, SEQ %\""PRIu32\"", LEN %\""PRIu16\"", SUM %\""PRIu32\""%s%s%s\"",\n                            s, s->seq, TCP_SEG_LEN(s),\n                            (uint32_t)(s->seq + TCP_SEG_LEN(s)),\n                            s->seq == seg->seq ? \"" DUPLICATE\"" : \""\"",\n                            TCPSEG_RB_PREV(s) == NULL ? \"" HEAD\"" : \""\"",\n                            TCPSEG_RB_NEXT(s) == NULL ? \"" TAIL\"" : \""\"");\n                }\n            }\n#endif\n        }\n    }\n\n    SCReturnInt(0);\n}\n"", ""start_line"": 557, ""end_line"": 628, ""full_name"": ""StreamTcpReassembleInsertSegment"", ""file_path"": ""src/stream-tcp-list.c""}]}, {""source"": ""func_info(file:stream-tcp-list.c, func:DoInsertSegment)"", ""result"": [{""code"": ""static int DoInsertSegment (TcpStream *stream, TcpSegment *seg, TcpSegment **dup_seg, Packet *p)\n{\n    /* before our base_seq we don't insert it in our list */\n    if (SEQ_LEQ(SEG_SEQ_RIGHT_EDGE(seg), stream->base_seq))\n    {\n        SCLogDebug(\""not inserting: SEQ+payload %\""PRIu32\"", last_ack %\""PRIu32\"", \""\n                \""base_seq %\""PRIu32, (seg->seq + TCP_SEG_LEN(seg)),\n                stream->last_ack, stream->base_seq);\n        StreamTcpSetEvent(p, STREAM_REASSEMBLY_SEGMENT_BEFORE_BASE_SEQ);\n        return -1;\n    }\n\n    /* fast track */\n    if (RB_EMPTY(&stream->seg_tree)) {\n        SCLogDebug(\""empty tree, inserting seg %p seq %\"" PRIu32 \"", \""\n                   \""len %\"" PRIu32 \""\"", seg, seg->seq, TCP_SEG_LEN(seg));\n        TCPSEG_RB_INSERT(&stream->seg_tree, seg);\n        stream->segs_right_edge = SEG_SEQ_RIGHT_EDGE(seg);\n        return 0;\n    }\n\n    /* insert and then check if there was any overlap with other segments */\n    TcpSegment *res = TCPSEG_RB_INSERT(&stream->seg_tree, seg);\n    if (res) {\n        SCLogDebug(\""seg has a duplicate in the tree seq %u/%u\"",\n                res->seq, res->payload_len);\n        /* exact duplicate SEQ + payload_len */\n        *dup_seg = res;\n        return 2; // duplicate has overlap by definition.\n    } else {\n        if (SEQ_GT(SEG_SEQ_RIGHT_EDGE(seg), stream->segs_right_edge))\n            stream->segs_right_edge = SEG_SEQ_RIGHT_EDGE(seg);\n\n        /* insert succeeded, now check if we overlap with someone */\n        if (CheckOverlap(&stream->seg_tree, seg) == true) {\n            SCLogDebug(\""seg %u has overlap in the tree\"", seg->seq);\n            return 1;\n        }\n    }\n    SCLogDebug(\""seg %u: no overlap\"", seg->seq);\n    return 0;\n}\n"", ""start_line"": 161, ""end_line"": 202, ""full_name"": ""DoInsertSegment"", ""file_path"": ""src/stream-tcp-list.c""}]}]","src/stream-tcp.c:4804-4807 rejects packets with non-0 ACK fields but no ACK flag. These packets were previously processed in StreamTcpReassembleInsertSegment (src/stream-tcp-list.c:557-628), which handles segment insertion and overlap resolution. The 'goto error' in StreamTcpPacket (src/stream-tcp.c:4804-4807) skips reassembly logic (src/stream-tcp.c:4820-5000), preventing fake FIN packets from being inserted into the stream. DoInsertSegment (src/stream-tcp-list.c:161-202) checks for overlaps, but invalid packets are terminated before reaching this function.",0.95,./github/other_context/CVE-2019-18792
2,CVE-2019-20372,CWE-444,c_cpp,"NGINX before 1.17.7, with certain error_page configurations, allows HTTP request smuggling, as demonstrated by the ability of an attacker to read unauthorized web pages in environments where NGINX is being fronted by a load balancer.",https://github.com/nginx/nginx/commit/c1be55f97211d38b69ac0c2027e6812ab8b1b94e,Discard request body when redirecting to a URL via error_page.\n\nReported by Bert JW Regeer and Francisco Oca Gonzalez.,1,"[{""func_name"": ""ngx_http_send_error_page"", ""file_path"": ""src/http/ngx_http_special_response.c"", ""func_code"": ""static ngx_int_t\nngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)\n{\n    ngx_int_t                  overwrite;\n    ngx_str_t                  uri, args;\n    ngx_table_elt_t           *location;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    overwrite = err_page->overwrite;\n\n    if (overwrite && overwrite != NGX_HTTP_OK) {\n        r->expect_tested = 1;\n    }\n\n    if (overwrite >= 0) {\n        r->err_status = overwrite;\n    }\n\n    if (ngx_http_complex_value(r, &err_page->value, &uri) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    if (uri.len && uri.data[0] == '/') {\n\n        if (err_page->value.lengths) {\n            ngx_http_split_args(r, &uri, &args);\n\n        } else {\n            args = err_page->args;\n        }\n\n        if (r->method != NGX_HTTP_HEAD) {\n            r->method = NGX_HTTP_GET;\n            r->method_name = ngx_http_core_get_method;\n        }\n\n        return ngx_http_internal_redirect(r, &uri, &args);\n    }\n\n    if (uri.len && uri.data[0] == '@') {\n        return ngx_http_named_location(r, &uri);\n    }\n\n    location = ngx_list_push(&r->headers_out.headers);\n\n    if (location == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (overwrite != NGX_HTTP_MOVED_PERMANENTLY\n        && overwrite != NGX_HTTP_MOVED_TEMPORARILY\n        && overwrite != NGX_HTTP_SEE_OTHER\n        && overwrite != NGX_HTTP_TEMPORARY_REDIRECT\n        && overwrite != NGX_HTTP_PERMANENT_REDIRECT)\n    {\n        r->err_status = NGX_HTTP_MOVED_TEMPORARILY;\n    }\n\n    location->hash = 1;\n    ngx_str_set(&location->key, \""Location\"");\n    location->value = uri;\n\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = location;\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf->msie_refresh && r->headers_in.msie) {\n        return ngx_http_send_refresh(r);\n    }\n\n    return ngx_http_send_special_response(r, clcf, r->err_status\n                                                   - NGX_HTTP_MOVED_PERMANENTLY\n                                                   + NGX_HTTP_OFF_3XX);\n}"", ""target"": 0}]","[{""func_name"": ""ngx_http_send_error_page"", ""file_path"": ""src/http/ngx_http_special_response.c"", ""func_code"": ""static ngx_int_t\nngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)\n{\n    ngx_int_t                  overwrite;\n    ngx_str_t                  uri, args;\n    ngx_table_elt_t           *location;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    overwrite = err_page->overwrite;\n\n    if (overwrite && overwrite != NGX_HTTP_OK) {\n        r->expect_tested = 1;\n    }\n\n    if (overwrite >= 0) {\n        r->err_status = overwrite;\n    }\n\n    if (ngx_http_complex_value(r, &err_page->value, &uri) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    if (uri.len && uri.data[0] == '/') {\n\n        if (err_page->value.lengths) {\n            ngx_http_split_args(r, &uri, &args);\n\n        } else {\n            args = err_page->args;\n        }\n\n        if (r->method != NGX_HTTP_HEAD) {\n            r->method = NGX_HTTP_GET;\n            r->method_name = ngx_http_core_get_method;\n        }\n\n        return ngx_http_internal_redirect(r, &uri, &args);\n    }\n\n    if (uri.len && uri.data[0] == '@') {\n        return ngx_http_named_location(r, &uri);\n    }\n\n    r->expect_tested = 1;\n\n    if (ngx_http_discard_request_body(r) != NGX_OK) {\n        r->keepalive = 0;\n    }\n\n    location = ngx_list_push(&r->headers_out.headers);\n\n    if (location == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (overwrite != NGX_HTTP_MOVED_PERMANENTLY\n        && overwrite != NGX_HTTP_MOVED_TEMPORARILY\n        && overwrite != NGX_HTTP_SEE_OTHER\n        && overwrite != NGX_HTTP_TEMPORARY_REDIRECT\n        && overwrite != NGX_HTTP_PERMANENT_REDIRECT)\n    {\n        r->err_status = NGX_HTTP_MOVED_TEMPORARILY;\n    }\n\n    location->hash = 1;\n    ngx_str_set(&location->key, \""Location\"");\n    location->value = uri;\n\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = location;\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf->msie_refresh && r->headers_in.msie) {\n        return ngx_http_send_refresh(r);\n    }\n\n    return ngx_http_send_special_response(r, clcf, r->err_status\n                                                   - NGX_HTTP_MOVED_PERMANENTLY\n                                                   + NGX_HTTP_OFF_3XX);\n}""}]","{""function"": 1, ""caller"": 1}","[{""source"": ""func_info(func:ngx_http_discard_request_body)"", ""result"": [{""code"": ""ngx_int_t\nngx_http_discard_request_body(ngx_http_request_t *r)\n{\n    ssize_t       size;\n    ngx_int_t     rc;\n    ngx_event_t  *rev;\n\n    if (r != r->main || r->discard_body || r->request_body) {\n   "", ""start_line"": 510, ""end_line"": 581, ""full_name"": ""ngx_http_discard_request_body"", ""file_path"": ""src/http/ngx_http_request_body.c""}]}, {""source"": ""caller_info(file:ngx_http_special_response.c, func:ngx_http_discard_request_body)"", ""result"": [{""call_line"": 473, ""call_code"": ""ngx_http_discard_request_body(r)"", ""caller_code"": ""ngx_int_t\nngx_http_special_response_handler(ngx_http_request_t *r, ngx_int_t error)\n{\n    ngx_uint_t                 i, err;\n    ngx_http_err_page_t       *err_page;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \""http special response: %i, \\\""%V?%V\\\""\"",\n                   error, &r->uri, &r->args);\n\n    r->err_status = error;\n\n    if (r->keepalive) {\n        switch (error) {\n            case NGX_HTTP_BAD_REQUEST:\n            case NGX_HTTP_REQUEST_ENTITY_TOO_LARGE:\n            case NGX_HTTP_REQUEST_URI_TOO_LARGE:\n            case NGX_HTTP_TO_HTTPS:\n            case NGX_HTTPS_CERT_ERROR:\n            case NGX_HTTPS_NO_CERT:\n            case NGX_HTTP_INTERNAL_SERVER_ERROR:\n            case NGX_HTTP_NOT_IMPLEMENTED:\n                r->keepalive = 0;\n        }\n    }\n\n    if (r->lingering_close) {\n        switch (error) {\n            case NGX_HTTP_BAD_REQUEST:\n            case NGX_HTTP_TO_HTTPS:\n            case NGX_HTT..."", ""caller_start"": 415, ""file_path"": ""src/http/ngx_http_special_response.c""}, {""call_line"": 183, ""call_code"": ""ngx_http_discard_request_body(r)"", ""caller_code"": ""static ngx_int_t\nngx_http_autoindex_handler(ngx_http_request_t *r)\n{\n    u_char                         *last, *filename;\n    size_t                          len, allocated, root;\n    ngx_err_t                       err;\n    ngx_buf_t                      *b;\n    ngx_int_t                       rc;\n    ngx_str_t                       path, callback;\n    ngx_dir_t                       dir;\n    ngx_uint_t                      level, format;\n    ngx_pool_t                     *pool;\n    ngx_chain_t                     out;\n    ngx_array_t                     entries;\n    ngx_http_autoindex_entry_t     *entry;\n    ngx_http_autoindex_loc_conf_t  *alcf;\n\n    if (r->uri.data[r->uri.len - 1] != '/') {\n        return NGX_DECLINED;\n    }\n\n    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n        return NGX_DECLINED;\n    }\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_autoindex_module);\n\n    if (!alcf->enable) {\n        return NGX_DECLINED;\n    }\n\n    rc = ngx_http_discard_request..."", ""caller_start"": 152, ""file_path"": ""src/http/modules/ngx_http_autoindex_module.c""}, {""call_line"": 84, ""call_code"": ""ngx_http_discard_request_body(r)"", ""caller_code"": ""static ngx_int_t\nngx_http_flv_handler(ngx_http_request_t *r)\n{\n    u_char                    *last;\n    off_t                      start, len;\n    size_t                     root;\n    ngx_int_t                  rc;\n    ngx_uint_t                 level, i;\n    ngx_str_t                  path, value;\n    ngx_log_t                 *log;\n    ngx_buf_t                 *b;\n    ngx_chain_t                out[2];\n    ngx_open_file_info_t       of;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n        return NGX_HTTP_NOT_ALLOWED;\n    }\n\n    if (r->uri.data[r->uri.len - 1] == '/') {\n        return NGX_DECLINED;\n    }\n\n    rc = ngx_http_discard_request_body(r);\n\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    last = ngx_http_map_uri_to_path(r, &path, &root, 0);\n    if (last == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    log = r->connection->log;\n\n    path.len = last - path.data;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, l..."", ""caller_start"": 61, ""file_path"": ""src/http/modules/ngx_http_flv_module.c""}]}]","The vulnerability arises from unprocessed request bodies retained during error_page redirects. The patch in `ngx_http_send_error_page` (src/http/ngx_http_special_response.c:624-629) introduces `ngx_http_discard_request_body(r)` to discard residual bodies. This function (src/http/ngx_http_request_body.c:510-581) ensures bodies are read and discarded, preventing smuggling. The error_page handler `ngx_http_special_response_handler` (src/http/ngx_http_special_response.c:415) triggers this logic when an error occurs. The chain is complete with the provided code evidence.",0.95,./github/other_context/CVE-2019-20372
3,CVE-2020-11724,CWE-444,c_cpp,"An issue was discovered in OpenResty before 1.15.8.4. ngx_http_lua_subrequest.c allows HTTP request smuggling, as demonstrated by the ngx.location.capture API.",https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa,bugfix: prevented request smuggling in the ngx.location.capture API.\n\nSigned-off-by: Yichun Zhang (agentzh) <yichun@openresty.com>,2,"[{""func_name"": ""ngx_http_lua_copy_request_headers"", ""file_path"": ""src/ngx_http_lua_subrequest.c"", ""func_code"": ""static ngx_int_t\nngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    dd(\""before: parent req headers count: %d\"",\n       (int) r->headers_in.headers.part.nelts);\n\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        dd(\""setting request header %.*s: %.*s\"", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\""after: parent req headers count: %d\"",\n       (int) r->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}"", ""target"": 0}, {""func_name"": ""ngx_http_lua_adjust_subrequest"", ""file_path"": ""src/ngx_http_lua_subrequest.c"", ""func_code"": ""static ngx_int_t\nngx_http_lua_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method,\n    int always_forward_body, ngx_http_request_body_t *body,\n    unsigned vars_action, ngx_array_t *extra_vars)\n{\n    ngx_http_request_t          *r;\n    ngx_int_t                    rc;\n    ngx_http_core_main_conf_t   *cmcf;\n    size_t                       size;\n\n    r = sr->parent;\n\n    sr->header_in = r->header_in;\n\n    if (body) {\n        sr->request_body = body;\n\n        rc = ngx_http_lua_set_content_length_header(sr,\n                                                    body->buf\n                                                    ? ngx_buf_size(body->buf)\n                                                    : 0);\n\n        if (rc != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n    } else if (!always_forward_body\n               && method != NGX_HTTP_PUT\n               && method != NGX_HTTP_POST\n               && r->headers_in.content_length_n > 0)\n    {\n        rc = ngx_http_lua_set_content_length_header(sr, 0);\n        if (rc != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n#if 1\n        sr->request_body = NULL;\n#endif\n\n    } else {\n        if (ngx_http_lua_copy_request_headers(sr, r) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        if (sr->request_body) {\n\n            /* deep-copy the request body */\n\n            if (sr->request_body->temp_file) {\n                if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n            }\n        }\n    }\n\n    sr->method = method;\n\n    switch (method) {\n        case NGX_HTTP_GET:\n            sr->method_name = ngx_http_lua_get_method;\n            break;\n\n        case NGX_HTTP_POST:\n            sr->method_name = ngx_http_lua_post_method;\n            break;\n\n        case NGX_HTTP_PUT:\n            sr->method_name = ngx_http_lua_put_method;\n            break;\n\n        case NGX_HTTP_HEAD:\n            sr->method_name = ngx_http_lua_head_method;\n            break;\n\n        case NGX_HTTP_DELETE:\n            sr->method_name = ngx_http_lua_delete_method;\n            break;\n\n        case NGX_HTTP_OPTIONS:\n            sr->method_name = ngx_http_lua_options_method;\n            break;\n\n        case NGX_HTTP_MKCOL:\n            sr->method_name = ngx_http_lua_mkcol_method;\n            break;\n\n        case NGX_HTTP_COPY:\n            sr->method_name = ngx_http_lua_copy_method;\n            break;\n\n        case NGX_HTTP_MOVE:\n            sr->method_name = ngx_http_lua_move_method;\n            break;\n\n        case NGX_HTTP_PROPFIND:\n            sr->method_name = ngx_http_lua_propfind_method;\n            break;\n\n        case NGX_HTTP_PROPPATCH:\n            sr->method_name = ngx_http_lua_proppatch_method;\n            break;\n\n        case NGX_HTTP_LOCK:\n            sr->method_name = ngx_http_lua_lock_method;\n            break;\n\n        case NGX_HTTP_UNLOCK:\n            sr->method_name = ngx_http_lua_unlock_method;\n            break;\n\n        case NGX_HTTP_PATCH:\n            sr->method_name = ngx_http_lua_patch_method;\n            break;\n\n        case NGX_HTTP_TRACE:\n            sr->method_name = ngx_http_lua_trace_method;\n            break;\n\n        default:\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \""unsupported HTTP method: %u\"", (unsigned) method);\n\n            return NGX_ERROR;\n    }\n\n    if (!(vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS)) {\n        /* we do not inherit the parent request's variables */\n        cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n        size = cmcf->variables.nelts * sizeof(ngx_http_variable_value_t);\n\n        if (vars_action & NGX_HTTP_LUA_COPY_ALL_VARS) {\n\n            sr->variables = ngx_palloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(sr->variables, r->variables, size);\n\n        } else {\n\n            /* we do not inherit the parent request's variables */\n\n            sr->variables = ngx_pcalloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(sr, extra_vars);\n}"", ""target"": 0}]","[{""func_name"": ""ngx_http_lua_copy_request_headers"", ""file_path"": ""src/ngx_http_lua_subrequest.c"", ""func_code"": ""static ngx_int_t\nngx_http_lua_copy_request_headers(ngx_http_request_t *sr,\n    ngx_http_request_t *pr, int pr_not_chunked)\n{\n    ngx_table_elt_t                 *clh, *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n    u_char                          *p;\n    off_t                            len;\n\n    dd(\""before: parent req headers count: %d\"",\n       (int) pr->headers_in.headers.part.nelts);\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (sr->request_body && !pr_not_chunked) {\n\n        /* craft our own Content-Length */\n\n        len = sr->request_body->buf ? ngx_buf_size(sr->request_body->buf) : 0;\n\n        clh = ngx_list_push(&sr->headers_in.headers);\n        if (clh == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->hash = ngx_http_lua_content_length_hash;\n        clh->key = ngx_http_lua_content_length_header_key;\n        clh->lowcase_key = ngx_pnalloc(sr->pool, clh->key.len);\n        if (clh->lowcase_key == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_strlow(clh->lowcase_key, clh->key.data, clh->key.len);\n\n        p = ngx_palloc(sr->pool, NGX_OFF_T_LEN);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->value.data = p;\n        clh->value.len = ngx_sprintf(clh->value.data, \""%O\"", len)\n                         - clh->value.data;\n\n        sr->headers_in.content_length = clh;\n        sr->headers_in.content_length_n = len;\n\n        dd(\""sr crafted content-length: %.*s\"",\n           (int) sr->headers_in.content_length->value.len,\n           sr->headers_in.content_length->value.data);\n    }\n\n    /* copy the parent request's headers */\n\n    part = &pr->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (!pr_not_chunked && header[i].key.len == sizeof(\""Content-Length\"") - 1\n            && ngx_strncasecmp(header[i].key.data, (u_char *) \""Content-Length\"",\n                               sizeof(\""Content-Length\"") - 1) == 0)\n        {\n            continue;\n        }\n\n        dd(\""sr copied req header %.*s: %.*s\"", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\""after: parent req headers count: %d\"",\n       (int) pr->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}""}, {""func_name"": ""ngx_http_lua_adjust_subrequest"", ""file_path"": ""src/ngx_http_lua_subrequest.c"", ""func_code"": ""static ngx_int_t\nngx_http_lua_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method,\n    int always_forward_body, ngx_http_request_body_t *body,\n    unsigned vars_action, ngx_array_t *extra_vars)\n{\n    ngx_http_request_t          *r;\n    ngx_http_core_main_conf_t   *cmcf;\n    int                          pr_not_chunked = 0;\n    size_t                       size;\n\n    r = sr->parent;\n\n    sr->header_in = r->header_in;\n\n    if (body) {\n        sr->request_body = body;\n\n    } else if (!always_forward_body\n               && method != NGX_HTTP_PUT\n               && method != NGX_HTTP_POST\n               && r->headers_in.content_length_n > 0)\n    {\n        sr->request_body = NULL;\n\n    } else {\n        if (!r->headers_in.chunked) {\n            pr_not_chunked = 1;\n        }\n\n        if (sr->request_body && sr->request_body->temp_file) {\n\n            /* deep-copy the request body */\n\n            if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    if (ngx_http_lua_copy_request_headers(sr, r, pr_not_chunked) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    sr->method = method;\n\n    switch (method) {\n        case NGX_HTTP_GET:\n            sr->method_name = ngx_http_lua_get_method;\n            break;\n\n        case NGX_HTTP_POST:\n            sr->method_name = ngx_http_lua_post_method;\n            break;\n\n        case NGX_HTTP_PUT:\n            sr->method_name = ngx_http_lua_put_method;\n            break;\n\n        case NGX_HTTP_HEAD:\n            sr->method_name = ngx_http_lua_head_method;\n            break;\n\n        case NGX_HTTP_DELETE:\n            sr->method_name = ngx_http_lua_delete_method;\n            break;\n\n        case NGX_HTTP_OPTIONS:\n            sr->method_name = ngx_http_lua_options_method;\n            break;\n\n        case NGX_HTTP_MKCOL:\n            sr->method_name = ngx_http_lua_mkcol_method;\n            break;\n\n        case NGX_HTTP_COPY:\n            sr->method_name = ngx_http_lua_copy_method;\n            break;\n\n        case NGX_HTTP_MOVE:\n            sr->method_name = ngx_http_lua_move_method;\n            break;\n\n        case NGX_HTTP_PROPFIND:\n            sr->method_name = ngx_http_lua_propfind_method;\n            break;\n\n        case NGX_HTTP_PROPPATCH:\n            sr->method_name = ngx_http_lua_proppatch_method;\n            break;\n\n        case NGX_HTTP_LOCK:\n            sr->method_name = ngx_http_lua_lock_method;\n            break;\n\n        case NGX_HTTP_UNLOCK:\n            sr->method_name = ngx_http_lua_unlock_method;\n            break;\n\n        case NGX_HTTP_PATCH:\n            sr->method_name = ngx_http_lua_patch_method;\n            break;\n\n        case NGX_HTTP_TRACE:\n            sr->method_name = ngx_http_lua_trace_method;\n            break;\n\n        default:\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \""unsupported HTTP method: %u\"", (unsigned) method);\n\n            return NGX_ERROR;\n    }\n\n    if (!(vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS)) {\n        /* we do not inherit the parent request's variables */\n        cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n        size = cmcf->variables.nelts * sizeof(ngx_http_variable_value_t);\n\n        if (vars_action & NGX_HTTP_LUA_COPY_ALL_VARS) {\n\n            sr->variables = ngx_palloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(sr->variables, r->variables, size);\n\n        } else {\n\n            /* we do not inherit the parent request's variables */\n\n            sr->variables = ngx_pcalloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(sr, extra_vars);\n}""}]","{""function"": 1, ""value"": 1}","[{""source"": ""func_info(func:ngx_http_lua_copy_request_headers)"", ""result"": [{""code"": ""static ngx_int_t\nngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    dd(\""before: parent req headers count: %d\"",\n       (int) r->headers_in.headers.part.nelts);\n\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        dd(\""setting request header %.*s: %.*s\"", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\""after: parent req headers count: %d\"",\n       (int) r->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}\n"", ""start_line"": 1744, ""end_line"": 1790, ""full_name"": ""ngx_http_lua_copy_request_headers"", ""file_path"": ""src/ngx_http_lua_subrequest.c""}]}, {""source"": ""value_info(value:sr->parent)"", ""result"": {""value_trace"": [{""full_code"": ""sr->parent = r"", ""line"": 1564, ""func_name"": ""ngx_http_lua_subrequest""}], ""struct_var"": ""sr"", ""struct_type"": null, ""struct_definition"": null}}]","The root cause is the inheritance of the parent's Content-Length header by subrequests in `ngx_http_lua_copy_request_headers` (src/ngx_http_lua_subrequest.c:1745-1834) without validation. When the parent and subrequest headers conflict (e.g., differing Content-Length values), attackers can exploit this inconsistency for HTTP request smuggling. The patch resolves this by generating a subrequest-specific Content-Length header and excluding the parent's Content-Length when `pr_not_chunked` is true, which is derived from the parent's `chunked` status in `ngx_http_lua_adjust_subrequest` (src/ngx_http_lua_subrequest.c:635-646).",0.95,./github/other_context/CVE-2020-11724
