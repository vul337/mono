id,cve_id,cwe_id,language,description,commit_url,commit_msg,patch_nums,func_before,func_after,context_nums,context_data,root_cause,confidence_score,other_context_path
1,CVE-2014-125071,CWE-346,java,A vulnerability was found in lukehutch Gribbit. It has been classified as problematic. Affected is the function messageReceived of the file src/gribbit/request/HttpRequestHandler.java. The manipulation leads to missing origin validation in websockets. The name of the patch is 620418df247aebda3dd4be1dda10fe229ea505dd. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217716.,https://github.com/lukehutch/gribbit/commit/620418df247aebda3dd4be1dda10fe229ea505dd,Protect against CSWSH: (Cross-Site WebSocket Hijacking),3,"[{""func_name"": ""messageReceived"", ""file_path"": ""src/gribbit/request/HttpRequestHandler.java"", ""func_code"": ""@Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\""REQUEST: \"" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\""100-continue\"")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\""UTF-8\"") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                                }\n                            } else {\n                                Log.warning(\""Got unknown data chunk type: \"" + httpDataType);\n                            }\n                        }\n                    }\n                } catch (EndOfDataDecoderException e) {\n                    // Apparently decoder.hasNext() doesn't actually work\n                }\n\n                if (chunk instanceof LastHttpContent) {\n                    requestComplete = true;\n                }\n            }\n\n            if (!requestComplete) {\n                // Wait for more chunks.\n                // (Since requestComplete is false, calling return here will not call destroyDecoder()\n                // in the finally block, so it will still exist when the next chunk is received.)\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Figure out how to handle HTTP request\n            // ------------------------------------------------------------------------------\n\n            // All POST chunks have been received (or there are no chunks); ready to start handling the request\n\n            String origReqURI = request.getURI();\n\n            // If this is a hash URI, look up original URI whose served resource was hashed to give this hash URI.\n            // We only need to serve the resource at a hash URI once per resource per client, since resources served\n            // from hash URIs are indefinitely cached in the browser.\n            String hashKey = CacheExtension.getHashKey(origReqURI);\n            boolean isHashURI = hashKey != null;\n            String reqURI = isHashURI ? CacheExtension.getOrigURI(origReqURI) : origReqURI;\n\n            InetSocketAddress requestor = (InetSocketAddress) ctx.channel().remoteAddress();\n            if (requestor != null) {\n                InetAddress address = requestor.getAddress();\n                if (address != null) {\n                    request.setRequestor(address.getHostAddress());\n                }\n            }\n\n            boolean isHEAD = request.getMethod() == HttpMethod.HEAD;\n\n            // Run the GET method if HEAD is requested, just don't return a body.\n            HttpMethod origReqMethod = request.getMethod();\n            if (isHEAD) {\n                request.setMethod(HttpMethod.GET);\n            }\n\n            // ------------------------------------------------------------------------------\n            // Authenticate user\n            // ------------------------------------------------------------------------------\n\n            // The response object generated by a RestHandler\n            Response response = null;\n\n            // Call route handlers until one is able to handle the route,\n            // or until we run out of handlers\n            User user = null;\n            RouteInfo authorizedRoute = null;\n            ArrayList<RouteInfo> allRoutes = GribbitServer.siteResources.getAllRoutes();\n            for (int i = 0, n = allRoutes.size(); i < n; i++) {\n                RouteInfo route = allRoutes.get(i);\n                // If the request URI matches this route path\n                if (route.matches(reqURI)) {\n                    Class<? extends RouteHandler> handler = route.getHandler();\n\n                    if (!(request.getMethod() == HttpMethod.GET || request.getMethod() == HttpMethod.POST)) {\n\n                        // We only support GET and POST at this point\n                        Log.error(\""Unsupported HTTP method \"" + request.getMethod().name() + \"" for path \"" + reqURI);\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \""HTTP method not allowed\"");\n\n                    } else if ((request.getMethod() == HttpMethod.GET && !route.hasGetMethod())\n                            || (request.getMethod() == HttpMethod.POST && !route.hasPostMethod())) {\n\n                        // Tried to call an HTTP method that is not defined for this route\n                        Log.error(\""HTTP method \"" + request.getMethod().name() + \"" not implemented in handler \""\n                                + handler.getName());\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \""HTTP method not allowed\"");\n\n                    } else if (RouteHandlerAuthRequired.class.isAssignableFrom(handler)) {\n\n                        // This handler requires authentication -- check if user is logged in\n                        user = User.getLoggedInUser(request);\n                        if (user == null) {\n\n                            // User is not logged in: handle request with OnUnauthorized handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(GribbitServer.siteResources.getUnauthorizedRoute(),\n                                            request, user)\n                                    // Redirect the user back to the page they were trying to get to once they\n                                    // do manage to log in successfully\n                                            .setCookie(\n                                                    new Cookie(Cookie.REDIRECT_AFTER_LOGIN_COOKIE_NAME, \""/\"", reqURI,\n                                                            300));\n\n                        } else if (RouteHandlerAuthAndValidatedEmailRequired.class.isAssignableFrom(handler)\n                                && !user.emailIsValidated()) {\n\n                            // User is logged in, but their email address has not been validated:\n                            // handle request with EmailNotValidated handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(\n                                            GribbitServer.siteResources.getEmailNotValidatedRoute(), request, user);\n\n                        } else {\n\n                            // Authorization required and user logged in: OK to handle request\n                            // with this route\n                            authorizedRoute = route;\n                        }\n                    } else {\n\n                        // Authorization not required -- OK to handle request with this route\n                        authorizedRoute = route;\n                    }\n\n                    // URI matches, so don't need to search further URIs\n                    break;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Complete websocket handshake if requested\n            // ------------------------------------------------------------------------------\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations\n                    && reqURI.endsWith(\""/websocket\"")) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Record which user was authenticated (if any) when websocket upgrade request was made.\n                // TODO: Reject WS upgrade request for websockets that require authentication.\n                // TODO: Also provide a means for revoking WS login.\n                wsAuthenticatedUser = User.getLoggedInUser(request);\n\n                WebSocketServerHandshakerFactory wsFactory =\n                        new WebSocketServerHandshakerFactory(GribbitServer.wsUri.toString(), null, true);\n                handshaker = wsFactory.newHandshaker(httpReq);\n                if (handshaker == null) {\n                    WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());\n                } else {\n                    // Attempt websocket handshake, and if it succeeds, upgrade connection to websocket\n                    // TODO: filed bug report, handshaker.handshake should take HttpRequest, not FullHttpRequest\n                    DefaultFullHttpRequest fullReq =\n                            new DefaultFullHttpRequest(httpReq.protocolVersion(), httpReq.method(), httpReq.uri());\n                    fullReq.headers().add(httpReq.headers());\n                    handshaker.handshake(ctx.channel(), (FullHttpRequest) fullReq);\n                }\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle static file requests\n            // ------------------------------------------------------------------------------\n\n            // If no error has occurred so far, and no route handler matched the request URI, and this is a\n            // GET request, then see if the URI points to a static file resource, and if so, serve the file.\n            if (response == null && authorizedRoute == null) {\n                // Static file requests can only use GET method\n                if (request.getMethod() != HttpMethod.GET) {\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n\n                File staticResourceFile = GribbitServer.siteResources.getStaticResource(reqURI);\n                if (staticResourceFile == null) {\n\n                    // Neither a route handler nor a static resource matched the request URI.\n                    // Return 404 Not Found.\n                    response =\n                            getResponseForErrorHandlerRoute(GribbitServer.siteResources.getNotFoundRoute(), request,\n                                    user);\n\n                } else {\n\n                    // A static resource matched the request URI, check last-modified timestamp\n                    // against the If-Modified-Since header timestamp in the request.\n                    long lastModifiedEpochSeconds = staticResourceFile.lastModified() / 1000;\n                    if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                        // File has not been modified since it was last cached -- return Not Modified\n                        response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                    } else {\n                        // If file is newer than what is in the browser cache, or is not in cache, serve the file\n                        serveStaticFile(reqURI, hashKey, staticResourceFile, lastModifiedEpochSeconds, ctx);\n\n                        Log.fine(request.getRequestor() + \""\\t\"" + origReqMethod + \""\\t\"" + reqURI + \""\\tfile://\""\n                                + staticResourceFile.getPath() + \""\\t\"" + HttpResponseStatus.OK + \""\\t\""\n                                + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \"" msec\"");\n\n                        // Finished request\n                        return;\n                    }\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle GET or POST requests\n            // ------------------------------------------------------------------------------\n\n            ZonedDateTime timeNow = null;\n\n            // If an error response hasn't yet been generated and this is a (non-static-file) GET or POST request,\n            // then call the get() or post() method for the route handler bound to the request URI to obtain the\n            // response object.\n            boolean hashTheResponse = false;\n            long hashKeyRemainingAgeSeconds = 0;\n            if (response == null && authorizedRoute != null) {\n\n                // ----------------------------------\n                // See if response should be hashed\n                // ----------------------------------\n\n                // For hashed *non-file* URIs, the actual last modified timestamp of dynamically-served\n                // content can't be read directly, so read the last modified timestamp stored for the\n                // previously hashed version in the CacheExtension class, as long as the max age of the\n                // cached version hasn't been exceeded, and see if the last modified timestamp is more\n                // recent than the version cached in the browser.\n                //\n                // The important ramification of this is that when the resource identified by the non-file\n                // URI changes, the CacheExtension class must be notified of that change (including in cases\n                // where the database is modified by another database client) if the modified version should\n                // start being served at a new hash URI immediately, otherwise the web client connected to\n                // this web server will continue to serve old resources until the max age of the cached\n                // content is exceeded.\n                if (isHashURI) {\n                    HashInfo hashInfo = CacheExtension.getHashInfo(reqURI);\n                    if (hashInfo != null) {\n                        long lastModifiedEpochSeconds = hashInfo.getLastModifiedEpochSeconds();\n                        timeNow = ZonedDateTime.now();\n                        long timeNowEpochSeconds = timeNow.toEpochSecond();\n\n                        long maxAgeSeconds = authorizedRoute.getMaxAgeSeconds();\n                        hashKeyRemainingAgeSeconds = lastModifiedEpochSeconds + maxAgeSeconds - timeNowEpochSeconds;\n\n                        if (maxAgeSeconds == 0) {\n                            // Content is not hash-cached\n                            hashKeyRemainingAgeSeconds = 0;\n                        }\n\n                        if (maxAgeSeconds > 0 && hashKeyRemainingAgeSeconds <= 0) {\n                            // Resource has expired -- call the route handler to generate a new response rather\n                            // than serving a Not Modified response, and schedule the response to be hashed or\n                            // re-hashed once the response has been generated.\n                            hashTheResponse = true;\n\n                            // Reset the expiry time at the requested number of seconds in the future\n                            hashKeyRemainingAgeSeconds = maxAgeSeconds;\n\n                        } else if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // However, resource has not been modified since it was last hashed --\n                            // return Not Modified.\n                            response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                        } else {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // Resource *has* been modified since it was last hashed -- serve it the\n                            // normal way using the route handler, but don't hash the response, since\n                            // it has not expired yet.\n                        }\n                    } else {\n                        // There is no original URI matching this hash URI, so the hash key was stale\n                        // (i.e. a URI whose hashcode has been spoofed, or a very old hashcode from\n                        // the previous time the server was run), but we still got a valid request URI\n                        // by stripping away the hash code, so that is served below in the normal way.\n                    }\n                }\n\n                // If the response wasn't just set to \""Not Modified\"" above, serve the request\n                if (response == null) {\n\n                    // -----------------------------------------------------------------\n                    // Call the route handler for this request, generating the response\n                    // -----------------------------------------------------------------\n\n                    response = getResponseForRoute(authorizedRoute, request, user);\n\n                    if (response == null) {\n                        // Should not happen\n                        throw new RuntimeException(\""Didn't generate a response\"");\n                    }\n\n                }\n\n            }\n            if (response == null) {\n                // Should not happen\n                throw new RuntimeException(\""Didn't generate a response\"");\n            }\n\n            // ------------------------------------------------------------------------------------\n            // Serve an HTTP result (except in the case of static files, they were served already)\n            // ------------------------------------------------------------------------------------\n\n            // Turn the Response object into an HttpResponse object and serve it to the user over Netty.\n            if (timeNow == null) {\n                timeNow = ZonedDateTime.now();\n            }\n\n            // Serve the response to the client \n            serveHttpResponse(reqURI, response, isHEAD, request.acceptEncodingGzip(),//\n                    timeNow, hashTheResponse, hashKeyRemainingAgeSeconds, hashKey, ctx);\n\n            // Log the request and response\n            HttpResponseStatus status = response.getStatus();\n            String logMsg =\n                    request.getRequestor() + \""\\t\"" + origReqMethod + \""\\t\"" + reqURI\n                            + (request.getMethod() == origReqMethod ? \""\"" : \""\\t\"" + request.getMethod()) + \""\\t\"" + status\n                            + \""\\t\"" + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \"" msec\"";\n            if (status == HttpResponseStatus.OK //\n                    || status == HttpResponseStatus.NOT_MODIFIED //\n                    || status == HttpResponseStatus.FOUND //\n                    || (status == HttpResponseStatus.NOT_FOUND //\n                    && (reqURI.equals(\""favicon.ico\"") || reqURI.endsWith(\""/favicon.ico\"")))) {\n                // Log at level \""fine\"" for non-errors, or 404 for favicon\n                Log.fine(logMsg);\n            } else {\n                // Log at level \""warning\"" for errors, or 404 for non-favicon\n                Log.warningWithoutCallerRef(logMsg);\n            }\n\n        } finally {\n            if (requestComplete) {\n                // Finished request -- destroy the multipart decoder and remove temporary files\n                destroyDecoder();\n            }\n        }\n    }"", ""target"": 0}, {""func_name"": ""toNettyCookie"", ""file_path"": ""src/gribbit/auth/Cookie.java"", ""func_code"": ""public io.netty.handler.codec.http.Cookie toNettyCookie() {\n        io.netty.handler.codec.http.Cookie nettyCookie = new DefaultCookie(name, WebUtils.escapeCookieValue(value));\n        if (path != null && !path.isEmpty()) {\n            nettyCookie.setPath(path);\n        }\n        nettyCookie.setMaxAge(maxAgeSeconds);\n        nettyCookie.setDiscard(discardAtEndOfBrowserSession);\n        nettyCookie.setHttpOnly(true);  // TODO\n        if (GribbitProperties.SSL) {\n            nettyCookie.setSecure(true);  // TODO\n        }\n        return nettyCookie;\n    }"", ""target"": 0}, {""func_name"": ""logIn"", ""file_path"": ""src/gribbit/auth/User.java"", ""func_code"": ""public void logIn(Response response) throws UnauthorizedException {\n        // Check user against login whitelist, if it exists\n        if (GribbitServer.loginWhitelistChecker == null || GribbitServer.loginWhitelistChecker.allowUserToLogin(id)) {\n\n            // Create new session token\n            sessionTok = new Token(TokenType.SESSION, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS);\n            csrfTok = CSRF.generateRandomCSRFToken();\n            save();\n            if (sessionTokHasExpired()) {\n                // Shouldn't happen, since we just created session tok, but just in case\n                clearSessionTok();\n                throw new UnauthorizedException(\""Couldn't create auth session\"");\n            }\n\n            // Save login cookies in result\n            response.setCookie(new Cookie(Cookie.SESSION_COOKIE_NAME, \""/\"", sessionTok.token,\n                    Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n            response.setCookie(new Cookie(Cookie.EMAIL_COOKIE_NAME, \""/\"", id, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n\n        } else {\n            // User is not authorized\n            throw new UnauthorizedException(\""User is not whitelisted for login: \"" + id);\n        }\n    }"", ""target"": 0}]","[{""func_name"": ""messageReceived"", ""file_path"": ""src/gribbit/request/HttpRequestHandler.java"", ""func_code"": ""@Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\""REQUEST: \"" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\""100-continue\"")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\""UTF-8\"") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                                }\n                            } else {\n                                Log.warning(\""Got unknown data chunk type: \"" + httpDataType);\n                            }\n                        }\n                    }\n                } catch (EndOfDataDecoderException e) {\n                    // Apparently decoder.hasNext() doesn't actually work\n                }\n\n                if (chunk instanceof LastHttpContent) {\n                    requestComplete = true;\n                }\n            }\n\n            if (!requestComplete) {\n                // Wait for more chunks.\n                // (Since requestComplete is false, calling return here will not call destroyDecoder()\n                // in the finally block, so it will still exist when the next chunk is received.)\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Figure out how to handle HTTP request\n            // ------------------------------------------------------------------------------\n\n            // All POST chunks have been received (or there are no chunks); ready to start handling the request\n\n            String origReqURI = request.getURI();\n\n            // If this is a hash URI, look up original URI whose served resource was hashed to give this hash URI.\n            // We only need to serve the resource at a hash URI once per resource per client, since resources served\n            // from hash URIs are indefinitely cached in the browser.\n            String hashKey = CacheExtension.getHashKey(origReqURI);\n            boolean isHashURI = hashKey != null;\n            String reqURI = isHashURI ? CacheExtension.getOrigURI(origReqURI) : origReqURI;\n\n            InetSocketAddress requestor = (InetSocketAddress) ctx.channel().remoteAddress();\n            if (requestor != null) {\n                InetAddress address = requestor.getAddress();\n                if (address != null) {\n                    request.setRequestor(address.getHostAddress());\n                }\n            }\n\n            boolean isHEAD = request.getMethod() == HttpMethod.HEAD;\n\n            // Run the GET method if HEAD is requested, just don't return a body.\n            HttpMethod origReqMethod = request.getMethod();\n            if (isHEAD) {\n                request.setMethod(HttpMethod.GET);\n            }\n\n            // ------------------------------------------------------------------------------\n            // Authenticate user\n            // ------------------------------------------------------------------------------\n\n            // The response object generated by a RestHandler\n            Response response = null;\n\n            // Call route handlers until one is able to handle the route,\n            // or until we run out of handlers\n            User user = null;\n            RouteInfo authorizedRoute = null;\n            ArrayList<RouteInfo> allRoutes = GribbitServer.siteResources.getAllRoutes();\n            for (int i = 0, n = allRoutes.size(); i < n; i++) {\n                RouteInfo route = allRoutes.get(i);\n                // If the request URI matches this route path\n                if (route.matches(reqURI)) {\n                    Class<? extends RouteHandler> handler = route.getHandler();\n\n                    if (!(request.getMethod() == HttpMethod.GET || request.getMethod() == HttpMethod.POST)) {\n\n                        // We only support GET and POST at this point\n                        Log.error(\""Unsupported HTTP method \"" + request.getMethod().name() + \"" for path \"" + reqURI);\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \""HTTP method not allowed\"");\n\n                    } else if ((request.getMethod() == HttpMethod.GET && !route.hasGetMethod())\n                            || (request.getMethod() == HttpMethod.POST && !route.hasPostMethod())) {\n\n                        // Tried to call an HTTP method that is not defined for this route\n                        Log.error(\""HTTP method \"" + request.getMethod().name() + \"" not implemented in handler \""\n                                + handler.getName());\n                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, \""HTTP method not allowed\"");\n\n                    } else if (RouteHandlerAuthRequired.class.isAssignableFrom(handler)) {\n\n                        // This handler requires authentication -- check if user is logged in\n                        user = User.getLoggedInUser(request);\n                        if (user == null) {\n\n                            // User is not logged in: handle request with OnUnauthorized handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(GribbitServer.siteResources.getUnauthorizedRoute(),\n                                            request, user)\n                                    // Redirect the user back to the page they were trying to get to once they\n                                    // do manage to log in successfully\n                                            .setCookie(\n                                                    new Cookie(Cookie.REDIRECT_AFTER_LOGIN_COOKIE_NAME, \""/\"", reqURI,\n                                                            300));\n\n                        } else if (RouteHandlerAuthAndValidatedEmailRequired.class.isAssignableFrom(handler)\n                                && !user.emailIsValidated()) {\n\n                            // User is logged in, but their email address has not been validated:\n                            // handle request with EmailNotValidated handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(\n                                            GribbitServer.siteResources.getEmailNotValidatedRoute(), request, user);\n\n                        } else {\n\n                            // Authorization required and user logged in: OK to handle request\n                            // with this route\n                            authorizedRoute = route;\n                        }\n                    } else {\n\n                        // Authorization not required -- OK to handle request with this route\n                        authorizedRoute = route;\n                    }\n\n                    // URI matches, so don't need to search further URIs\n                    break;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Complete websocket handshake if requested\n            // ------------------------------------------------------------------------------\n\n            // FIXME: Make these into class annotations\n            String websocketPath = \""/websocket\"";\n            boolean isAuthenticatedWebsocket = true;\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations, rather than using hardcoded \""/websocket\""\n                    && reqURI.endsWith(websocketPath)) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Protect against CSWSH: (Cross-Site WebSocket Hijacking)\n                // http://www.christian-schneider.net/CrossSiteWebSocketHijacking.html\n                // http://tools.ietf.org/html/rfc6455#page-7\n                CharSequence origin = request.getOrigin();\n                URI originUri = null;\n                if (origin != null && origin.length() > 0) {\n                    try {\n                        // Try parsing origin URI\n                        originUri = new URI(origin.toString());\n                    } catch (Exception e) {\n                    }\n                }\n                // If port number is set but it is the default for the URI scheme, revert the port number\n                // back to -1 (which means unspecified), so that it matches the server port number, \n                // which is unspecified when serving http on port 80 and https on port 443\n                int originPort = originUri == null ? -1 //\n                        : originUri.getPort() == 80 && \""http\"".equals(originUri.getScheme()) ? -1 //\n                                : originUri.getPort() == 443 && \""https\"".equals(originUri.getScheme()) ? -1 //\n                                        : originUri.getPort();\n                // Scheme, host and port all must match to forbid cross-origin requests\n                if (originUri == null //\n                        || !GribbitServer.uri.getScheme().equals(originUri.getScheme()) //\n                        || !GribbitServer.uri.getHost().equals(originUri.getHost()) //\n                        || GribbitServer.uri.getPort() != originPort) { //\n                    // Reject scripted requests to open this websocket from a different domain\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n                // Log.info(\""Origin: \"" + origin.toString());\n\n                if (isAuthenticatedWebsocket) {\n                    // For authenticated websockets, check if the user is logged in\n                    User loggedInUser = User.getLoggedInUser(request);\n                    if (loggedInUser == null) {\n                        // Not logged in, so can't connect to this websocket\n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;\n                    }\n\n                    // To further mitigate CSWSH attacks: check for the CSRF token in the URL parameter \""_csrf\"";\n                    // the passed token must match the user's CSRF token. This means the websocket URL has to\n                    // be dynamically generated and inserted into the webpage that opened the websocket.\n                    // TODO: generate this URL an insert into the page somehow\n                    String csrfTok = loggedInUser.csrfTok;\n                    if (csrfTok == null || csrfTok.isEmpty() || csrfTok.equals(CSRF.CSRF_TOKEN_UNKNOWN)\n                            || csrfTok.equals(CSRF.CSRF_TOKEN_PLACEHOLDER)) {\n                        // No valid CSRF token in User object\n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;\n                    }\n                    String csrfParam = request.getQueryParam(\""_csrf\"");\n                    if (csrfParam == null || csrfParam.isEmpty() || !csrfParam.equals(csrfTok)) {\n                        // The CSRF URL query parameter is missing, or doesn't match the user's token \n                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.FORBIDDEN));\n                        return;                        \n                    }\n\n                    // Record which user was authenticated when the websocket upgrade request was made.\n                    // TODO: Also provide a means for revoking user's session while WS is still open,\n                    // e.g. poll the user table every few seconds to see if user's session token has\n                    // changed in the database? (Although this would mean that logging in on a new\n                    // device would log you out of all other sessions...)\n                    wsAuthenticatedUser = loggedInUser;\n                }\n\n                WebSocketServerHandshakerFactory wsFactory =\n                        new WebSocketServerHandshakerFactory(GribbitServer.wsUri.toString(), null, true);\n                handshaker = wsFactory.newHandshaker(httpReq);\n                if (handshaker == null) {\n                    WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());\n                } else {\n                    // Attempt websocket handshake, and if it succeeds, upgrade connection to websocket\n                    // TODO: filed bug report, handshaker.handshake should take HttpRequest, not FullHttpRequest\n                    DefaultFullHttpRequest fullReq =\n                            new DefaultFullHttpRequest(httpReq.protocolVersion(), httpReq.method(), httpReq.uri());\n                    fullReq.headers().add(httpReq.headers());\n                    handshaker.handshake(ctx.channel(), (FullHttpRequest) fullReq);\n                }\n                return;\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle static file requests\n            // ------------------------------------------------------------------------------\n\n            // If no error has occurred so far, and no route handler matched the request URI, and this is a\n            // GET request, then see if the URI points to a static file resource, and if so, serve the file.\n            if (response == null && authorizedRoute == null) {\n                // Static file requests can only use GET method\n                if (request.getMethod() != HttpMethod.GET) {\n                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.FORBIDDEN));\n                    return;\n                }\n\n                File staticResourceFile = GribbitServer.siteResources.getStaticResource(reqURI);\n                if (staticResourceFile == null) {\n\n                    // Neither a route handler nor a static resource matched the request URI.\n                    // Return 404 Not Found.\n                    response =\n                            getResponseForErrorHandlerRoute(GribbitServer.siteResources.getNotFoundRoute(), request,\n                                    user);\n\n                } else {\n\n                    // A static resource matched the request URI, check last-modified timestamp\n                    // against the If-Modified-Since header timestamp in the request.\n                    long lastModifiedEpochSeconds = staticResourceFile.lastModified() / 1000;\n                    if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                        // File has not been modified since it was last cached -- return Not Modified\n                        response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                    } else {\n                        // If file is newer than what is in the browser cache, or is not in cache, serve the file\n                        serveStaticFile(reqURI, hashKey, staticResourceFile, lastModifiedEpochSeconds, ctx);\n\n                        Log.fine(request.getRequestor() + \""\\t\"" + origReqMethod + \""\\t\"" + reqURI + \""\\tfile://\""\n                                + staticResourceFile.getPath() + \""\\t\"" + HttpResponseStatus.OK + \""\\t\""\n                                + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \"" msec\"");\n\n                        // Finished request\n                        return;\n                    }\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Handle GET or POST requests\n            // ------------------------------------------------------------------------------\n\n            ZonedDateTime timeNow = null;\n\n            // If an error response hasn't yet been generated and this is a (non-static-file) GET or POST request,\n            // then call the get() or post() method for the route handler bound to the request URI to obtain the\n            // response object.\n            boolean hashTheResponse = false;\n            long hashKeyRemainingAgeSeconds = 0;\n            if (response == null && authorizedRoute != null) {\n\n                // ----------------------------------\n                // See if response should be hashed\n                // ----------------------------------\n\n                // For hashed *non-file* URIs, the actual last modified timestamp of dynamically-served\n                // content can't be read directly, so read the last modified timestamp stored for the\n                // previously hashed version in the CacheExtension class, as long as the max age of the\n                // cached version hasn't been exceeded, and see if the last modified timestamp is more\n                // recent than the version cached in the browser.\n                //\n                // The important ramification of this is that when the resource identified by the non-file\n                // URI changes, the CacheExtension class must be notified of that change (including in cases\n                // where the database is modified by another database client) if the modified version should\n                // start being served at a new hash URI immediately, otherwise the web client connected to\n                // this web server will continue to serve old resources until the max age of the cached\n                // content is exceeded.\n                if (isHashURI) {\n                    HashInfo hashInfo = CacheExtension.getHashInfo(reqURI);\n                    if (hashInfo != null) {\n                        long lastModifiedEpochSeconds = hashInfo.getLastModifiedEpochSeconds();\n                        timeNow = ZonedDateTime.now();\n                        long timeNowEpochSeconds = timeNow.toEpochSecond();\n\n                        long maxAgeSeconds = authorizedRoute.getMaxAgeSeconds();\n                        hashKeyRemainingAgeSeconds = lastModifiedEpochSeconds + maxAgeSeconds - timeNowEpochSeconds;\n\n                        if (maxAgeSeconds == 0) {\n                            // Content is not hash-cached\n                            hashKeyRemainingAgeSeconds = 0;\n                        }\n\n                        if (maxAgeSeconds > 0 && hashKeyRemainingAgeSeconds <= 0) {\n                            // Resource has expired -- call the route handler to generate a new response rather\n                            // than serving a Not Modified response, and schedule the response to be hashed or\n                            // re-hashed once the response has been generated.\n                            hashTheResponse = true;\n\n                            // Reset the expiry time at the requested number of seconds in the future\n                            hashKeyRemainingAgeSeconds = maxAgeSeconds;\n\n                        } else if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // However, resource has not been modified since it was last hashed --\n                            // return Not Modified.\n                            response = new NotModifiedResponse(lastModifiedEpochSeconds);\n\n                        } else {\n                            // Resource has not expired in cache, but client has requested it anyway.\n                            // Resource *has* been modified since it was last hashed -- serve it the\n                            // normal way using the route handler, but don't hash the response, since\n                            // it has not expired yet.\n                        }\n                    } else {\n                        // There is no original URI matching this hash URI, so the hash key was stale\n                        // (i.e. a URI whose hashcode has been spoofed, or a very old hashcode from\n                        // the previous time the server was run), but we still got a valid request URI\n                        // by stripping away the hash code, so that is served below in the normal way.\n                    }\n                }\n\n                // If the response wasn't just set to \""Not Modified\"" above, serve the request\n                if (response == null) {\n\n                    // -----------------------------------------------------------------\n                    // Call the route handler for this request, generating the response\n                    // -----------------------------------------------------------------\n\n                    response = getResponseForRoute(authorizedRoute, request, user);\n\n                    if (response == null) {\n                        // Should not happen\n                        throw new RuntimeException(\""Didn't generate a response\"");\n                    }\n\n                }\n\n            }\n            if (response == null) {\n                // Should not happen\n                throw new RuntimeException(\""Didn't generate a response\"");\n            }\n\n            // ------------------------------------------------------------------------------------\n            // Serve an HTTP result (except in the case of static files, they were served already)\n            // ------------------------------------------------------------------------------------\n\n            // Turn the Response object into an HttpResponse object and serve it to the user over Netty.\n            if (timeNow == null) {\n                timeNow = ZonedDateTime.now();\n            }\n\n            // Serve the response to the client \n            serveHttpResponse(reqURI, response, isHEAD, request.acceptEncodingGzip(),//\n                    timeNow, hashTheResponse, hashKeyRemainingAgeSeconds, hashKey, ctx);\n\n            // Log the request and response\n            HttpResponseStatus status = response.getStatus();\n            String logMsg =\n                    request.getRequestor() + \""\\t\"" + origReqMethod + \""\\t\"" + reqURI\n                            + (request.getMethod() == origReqMethod ? \""\"" : \""\\t\"" + request.getMethod()) + \""\\t\"" + status\n                            + \""\\t\"" + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + \"" msec\"";\n            if (status == HttpResponseStatus.OK //\n                    || status == HttpResponseStatus.NOT_MODIFIED //\n                    || status == HttpResponseStatus.FOUND //\n                    || (status == HttpResponseStatus.NOT_FOUND //\n                    && (reqURI.equals(\""favicon.ico\"") || reqURI.endsWith(\""/favicon.ico\"")))) {\n                // Log at level \""fine\"" for non-errors, or 404 for favicon\n                Log.fine(logMsg);\n            } else {\n                // Log at level \""warning\"" for errors, or 404 for non-favicon\n                Log.warningWithoutCallerRef(logMsg);\n            }\n\n        } finally {\n            if (requestComplete) {\n                // Finished request -- destroy the multipart decoder and remove temporary files\n                destroyDecoder();\n            }\n        }\n    }""}, {""func_name"": ""toNettyCookie"", ""file_path"": ""src/gribbit/auth/Cookie.java"", ""func_code"": ""public io.netty.handler.codec.http.Cookie toNettyCookie() {\n        io.netty.handler.codec.http.Cookie nettyCookie = new DefaultCookie(name, WebUtils.escapeCookieValue(value));\n        if (path != null && !path.isEmpty()) {\n            nettyCookie.setPath(path);\n        }\n        nettyCookie.setMaxAge(maxAgeSeconds);\n        nettyCookie.setDiscard(discardAtEndOfBrowserSession);\n        nettyCookie.setHttpOnly(true);  // TODO\n        if (GribbitProperties.SSL) {\n            // If SSL is enabled, force cookies to only be delivered over SSL, to prevent cookie hijacking\n            // on public wifi networks\n            nettyCookie.setSecure(true);\n        }\n        return nettyCookie;\n    }""}, {""func_name"": ""logIn"", ""file_path"": ""src/gribbit/auth/User.java"", ""func_code"": ""public void logIn(Response response) throws UnauthorizedException {\n        // Check user against login whitelist, if it exists\n        if (GribbitServer.loginWhitelistChecker == null || GribbitServer.loginWhitelistChecker.allowUserToLogin(id)) {\n\n            // Create new session token\n            sessionTok = new Token(TokenType.SESSION, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS);\n            \n            // Create new random CSRF token every time user logs in\n            csrfTok = CSRF.generateRandomCSRFToken();\n            \n            if (sessionTokHasExpired()) {\n                // Shouldn't happen, since we just created session tok, but just in case\n                clearSessionTok();\n                throw new UnauthorizedException(\""Couldn't create auth session\"");\n            }\n\n            // Save tokens in database\n            save();\n\n            // Save login cookies in result\n            response.setCookie(new Cookie(Cookie.SESSION_COOKIE_NAME, \""/\"", sessionTok.token,\n                    Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n            response.setCookie(new Cookie(Cookie.EMAIL_COOKIE_NAME, \""/\"", id, Cookie.SESSION_COOKIE_MAX_AGE_SECONDS));\n\n        } else {\n            // User is not authorized\n            throw new UnauthorizedException(\""User is not whitelisted for login: \"" + id);\n        }\n    }""}]","{""function"": 2, ""code"": 3}","[{""source"": ""func_info(file:HttpRequestHandler.java, func:messageReceived)"", ""result"": [{""code"": ""    @Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\""REQUEST: \"" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\""100-continue\"")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\""UTF-8\"") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                            "", ""start_line"": 600, ""end_line"": 1033, ""full_name"": ""gribbit.request.HttpRequestHandler.messageReceived:void(io.netty.channel.ChannelHandlerContext,java.lang.Object)"", ""file_path"": ""src/gribbit/request/HttpRequestHandler.java""}]}, {""source"": ""code_info(file:HttpRequestHandler.java, lines:800-826)"", ""result"": ""                                && !user.emailIsValidated()) {\n\n                            // User is logged in, but their email address has not been validated:\n                            // handle request with EmailNotValidated handler instead\n                            response =\n                                    getResponseForErrorHandlerRoute(\n                                            GribbitServer.siteResources.getEmailNotValidatedRoute(), request, user);\n\n                        } else {\n\n                            // Authorization required and user logged in: OK to handle request\n                            // with this route\n                            authorizedRoute = route;\n                        }\n                    } else {\n\n                        // Authorization not required -- OK to handle request with this route\n                        authorizedRoute = route;\n                    }\n\n                    // URI matches, so don't need to search further URIs\n                    break;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Complete websocket handshake if requested\n            // ------------------------------------------------------------------------------\n""}, {""source"": ""func_info(file:HttpRequestHandler.java, func:messageReceived)"", ""result"": [{""code"": ""    @Override\n    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {\n\n        // ------------------------------------------------------------------------------\n        // Handle WebSocket frames\n        // ------------------------------------------------------------------------------\n\n        if (msg instanceof WebSocketFrame) {\n            handleWebsocketFrame(ctx, (WebSocketFrame) msg);\n            return;\n        }\n\n        // ------------------------------------------------------------------------------\n        // Decode HTTP headers\n        // ------------------------------------------------------------------------------\n\n        boolean requestComplete = false;\n        try {\n            if (msg instanceof HttpRequest) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // System.out.println(\""REQUEST: \"" + httpReq.getUri());\n\n                // Start a new request\n                request = new Request(httpReq);\n\n                // Handle expect-100-continue\n                boolean expect100Continue = false;\n                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);\n                for (int i = 0; i < allExpectHeaders.size(); i++) {\n                    String h = allExpectHeaders.get(i).toString();\n                    if (h.equalsIgnoreCase(\""100-continue\"")) {\n                        expect100Continue = true;\n                        break;\n                    }\n                }\n                if (expect100Continue) {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,\n                            Unpooled.EMPTY_BUFFER));\n                    requestComplete = true;\n                    return;\n                }\n\n                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);\n                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);\n\n                if (httpReq.method() == HttpMethod.POST) {\n                    // Start decoding HttpContent chunks\n                    destroyDecoder();\n                    decoder = new HttpPostRequestDecoder(factory, httpReq);\n\n                } else {\n                    // Non-POST (probably GET) -- start handling the request\n                    requestComplete = true;\n                }\n\n                // TODO: will this return failure before all POST chunks have been received?\n                if (!httpReq.decoderResult().isSuccess()) {\n                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.BAD_REQUEST));\n                    requestComplete = true;\n                    return;\n                }\n            }\n\n            // ------------------------------------------------------------------------------\n            // Decode HTTP POST body\n            // ------------------------------------------------------------------------------\n\n            if (msg instanceof HttpContent && decoder != null) {\n                HttpContent chunk = (HttpContent) msg;\n                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to\n                // be separately released). Decoder is released after message has been handled.\n                decoder.offer(chunk);\n\n                try {\n                    while (decoder.hasNext()) {\n                        InterfaceHttpData data = decoder.next();\n                        if (data != null) {\n                            HttpDataType httpDataType = data.getHttpDataType();\n                            if (httpDataType == HttpDataType.Attribute) {\n                                try {\n                                    Attribute attribute = (Attribute) data;\n                                    request.setPostParam(attribute.getName(), attribute.getString(attribute\n                                            .getCharset() == null ? Charset.forName(\""UTF-8\"") : attribute.getCharset()));\n                                } finally {\n                                    // Decrease refcount, freeing data\n                                    data.release();\n                                }\n\n                            } else if (httpDataType == HttpDataType.FileUpload) {\n                                FileUpload fileUpload = (FileUpload) data;\n                                // TODO consider imposing size limit and returning 413 (Request Entity Too\n                                // Large) once the amount of data that has been sent hits the limit\n                                if (fileUpload.isCompleted()) {\n                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).\n                                    // Need to release this resource later.\n                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);\n                            "", ""start_line"": 600, ""end_line"": 1033, ""full_name"": ""gribbit.request.HttpRequestHandler.messageReceived:void(io.netty.channel.ChannelHandlerContext,java.lang.Object)"", ""file_path"": ""src/gribbit/request/HttpRequestHandler.java""}]}, {""source"": ""code_info(file:HttpRequestHandler.java, lines:827-834)"", ""result"": ""            // ------------------------------------------------------------------------------\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations\n                    && reqURI.endsWith(\""/websocket\"")) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Record which user was authenticated (if any) when websocket upgrade request was made.\n                // TODO: Reject WS upgrade request for websockets that require authentication.\n""}, {""source"": ""code_info(file:HttpRequestHandler.java, lines:827-834)"", ""result"": ""            // ------------------------------------------------------------------------------\n\n            if (response == null && authorizedRoute == null && msg instanceof HttpRequest\n            // TODO: Read WS routes from class annotations\n                    && reqURI.endsWith(\""/websocket\"")) {\n                HttpRequest httpReq = (HttpRequest) msg;\n\n                // Record which user was authenticated (if any) when websocket upgrade request was made.\n                // TODO: Reject WS upgrade request for websockets that require authentication.\n""}]","src/gribbit/request/HttpRequestHandler.java:827-834 (original code allowed WebSocket upgrades without origin validation). The original code checked `reqURI.endsWith(""/websocket"")` but lacked origin validation logic. The patch added origin and CSRF checks to prevent CSWSH.",0.95,./github/other_context/CVE-2014-125071
2,CVE-2017-5592,"CWE-20, CWE-346",c_cpp,"An incorrect implementation of ""XEP-0280: Message Carbons"" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for profanity (0.4.7 - 0.5.0).",https://github.com/profanity-im/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b,Add carbons from check,1,"[{""func_name"": ""_handle_carbons"", ""file_path"": ""src/xmpp/message.c"", ""func_code"": ""static gboolean\n_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error(\""Unable to retrieve stanza name for Carbon\"");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, \""private\"") == 0) {\n        log_info(\""Carbon received with private element.\"");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, \""received\"") != 0) && (g_strcmp0(name, \""sent\"") != 0)) {\n        log_warning(\""Carbon received with unrecognised stanza name: %s\"", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning(\""Carbon received with no forwarded element\"");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\""Carbon received with no message element\"");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\""Carbon received with no message.\"");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n    Jid *my_jid = jid_create(connection_get_fulljid());\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}"", ""target"": 0}]","[{""func_name"": ""_handle_carbons"", ""file_path"": ""src/xmpp/message.c"", ""func_code"": ""static gboolean\n_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error(\""Unable to retrieve stanza name for Carbon\"");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, \""private\"") == 0) {\n        log_info(\""Carbon received with private element.\"");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, \""received\"") != 0) && (g_strcmp0(name, \""sent\"") != 0)) {\n        log_warning(\""Carbon received with unrecognised stanza name: %s\"", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning(\""Carbon received with no forwarded element\"");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\""Carbon received with no message element\"");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\""Carbon received with no message.\"");\n        return TRUE;\n    }\n\n    Jid *my_jid = jid_create(connection_get_fulljid());\n    const char *const stanza_from = xmpp_stanza_get_from(stanza);\n    Jid *msg_jid = jid_create(stanza_from);\n    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {\n        log_warning(\""Invalid carbon received, from: %s\"", stanza_from);\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}""}]","{""caller"": 2, ""code"": 2, ""value"": 2}","[{""source"": ""caller_info(file:message.c, func:_handle_carbons)"", ""result"": [{""call_line"": 764, ""call_code"": ""_handle_carbons(stanza)"", ""caller_code"": ""static void\n_handle_chat(xmpp_stanza_t *const stanza)\n{\n    // ignore if type not chat or absent\n    const char *type = xmpp_stanza_get_type(stanza);\n    if (!(g_strcmp0(type, \""chat\"") == 0 || type == NULL)) {\n        return;\n    }\n\n    // check if carbon message\n    gboolean res = _handle_carbons(stanza);\n    if (res) {\n        return;\n    }\n\n    // ignore handled namespaces\n    xmpp_stanza_t *conf = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CAPTCHA);\n    if (conf || captcha) {\n        return;\n    }\n\n    // some clients send the mucuser namespace with private messages\n    // if the namespace exists, and the stanza contains a body element, assume its a private message\n    // otherwise exit the handler\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    xmpp_stanza_t *body = xmpp_stanza_get_child_by_name(stanza, STANZA_NAME_BODY);\n    if (mucuser && body ==..."", ""caller_start"": 754, ""file_path"": ""src/xmpp/message.c""}]}, {""source"": ""code_info(file:message.c, lines:700-720)"", ""result"": ""    if (!forwarded) {\n        log_warning(\""Carbon received with no forwarded element\"");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\""Carbon received with no message element\"");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\""Carbon received with no message.\"");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n""}, {""source"": ""value_info(file:message.c, value:stanza)"", ""result"": {""value_trace"": [{""full_code"": ""stanza = stanza_create_invite(ctx, roomjid, contact, reason, password)"", ""line"": 316, ""func_name"": ""message_send_invite""}, {""full_code"": ""stanza = stanza_create_mediated_invite(ctx, roomjid, contact, reason)"", ""line"": 319, ""func_name"": ""message_send_invite""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_COMPOSING)"", ""line"": 331, ""func_name"": ""message_send_composing""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_PAUSED)"", ""line"": 341, ""func_name"": ""message_send_paused""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_INACTIVE)"", ""line"": 350, ""func_name"": ""message_send_inactive""}], ""struct_var"": ""stanza"", ""struct_type"": ""xmpp_stanza_t*"", ""struct_definition"": ""xmpp_stanza_t""}}, {""source"": ""caller_info(file:message.c, func:_handle_chat)"", ""result"": [{""call_line"": 121, ""call_code"": ""_handle_chat(stanza)"", ""caller_code"": ""static int\n_message_handler(xmpp_conn_t *const conn, xmpp_stanza_t *const stanza, void *const userdata)\n{\n    log_debug(\""Message stanza handler fired\"");\n\n    char *text;\n    size_t text_size;\n    xmpp_stanza_to_text(stanza, &text, &text_size);\n    gboolean cont = plugins_on_message_stanza_receive(text);\n    xmpp_free(connection_get_ctx(), text);\n    if (!cont) {\n        return 1;\n    }\n\n    const char *type = xmpp_stanza_get_type(stanza);\n\n    if (g_strcmp0(type, STANZA_TYPE_ERROR) == 0) {\n        _handle_error(stanza);\n    }\n\n    if (g_strcmp0(type, STANZA_TYPE_GROUPCHAT) == 0) {\n        _handle_groupchat(stanza);\n    }\n\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    if (mucuser) {\n        _handel_muc_user(stanza);\n    }\n\n    xmpp_stanza_t *conference = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    if (conference) {\n        _handle_conference(stanza);\n    }\n\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, ..."", ""caller_start"": 77, ""file_path"": ""src/xmpp/message.c""}]}, {""source"": ""value_info(file:message.c, value:stanza)"", ""result"": {""value_trace"": [{""full_code"": ""stanza = stanza_create_invite(ctx, roomjid, contact, reason, password)"", ""line"": 316, ""func_name"": ""message_send_invite""}, {""full_code"": ""stanza = stanza_create_mediated_invite(ctx, roomjid, contact, reason)"", ""line"": 319, ""func_name"": ""message_send_invite""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_COMPOSING)"", ""line"": 331, ""func_name"": ""message_send_composing""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_PAUSED)"", ""line"": 341, ""func_name"": ""message_send_paused""}, {""full_code"": ""*stanza = stanza_create_chat_state(ctx, jid, STANZA_NAME_INACTIVE)"", ""line"": 350, ""func_name"": ""message_send_inactive""}], ""struct_var"": ""stanza"", ""struct_type"": ""xmpp_stanza_t*"", ""struct_definition"": ""xmpp_stanza_t""}}, {""source"": ""code_info(file:message.c, lines:100-140)"", ""result"": ""\n    xmpp_stanza_t *mucuser = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_MUC_USER);\n    if (mucuser) {\n        _handel_muc_user(stanza);\n    }\n\n    xmpp_stanza_t *conference = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n    if (conference) {\n        _handle_conference(stanza);\n    }\n\n    xmpp_stanza_t *captcha = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CAPTCHA);\n    if (captcha) {\n        _handle_captcha(stanza);\n    }\n\n    xmpp_stanza_t *receipts = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_RECEIPTS);\n    if (receipts) {\n        _handle_receipt_received(stanza);\n    }\n\n    _handle_chat(stanza);\n\n    return 1;\n}\n\nvoid\nmessage_handlers_init(void)\n{\n    xmpp_conn_t * const conn = connection_get_conn();\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n    xmpp_handler_add(conn, _message_handler, NULL, STANZA_NAME_MESSAGE, NULL, ctx);\n}\n\nchar*\nmessage_send_chat(const char *const barejid, const char *const msg, const char *const oob_url,\n    gboolean request_receipt)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *state = chat_session_get_state(barejid);\n    char *jid = chat_session_get_jid(barejid);\n""}]","The vulnerability originates in missing validation of the 'from' JID in XMPP carbons (src/xmpp/message.c:716-720). `_handle_carbons` is called by `_handle_chat` (src/xmpp/message.c:764), which is triggered by `_message_handler` (src/xmpp/message.c:121) to process incoming XMPP stanzas. `_message_handler` is registered as an XMPP stanza handler via `xmpp_handler_add` in `message_handlers_init` (src/xmpp/message.c:140), establishing the network input path for the `stanza` parameter. The attack vector is confirmed as an external attacker can send a malicious carbon stanza over XMPP, which is processed by `_message_handler` and passed to `_handle_carbons` without proper validation.",1.0,./github/other_context/CVE-2017-5592
3,CVE-2018-15836,CWE-347,c_cpp,"In verify_signed_hash() in lib/liboswkeys/signatures.c in Openswan before 2.6.50.1, the RSA implementation does not verify the value of padding string during PKCS#1 v1.5 signature verification. Consequently, a remote attacker can forge signatures when small public exponents are being used. IKEv2 signature verification is affected when RAW RSA keys are used.",https://github.com/xelerance/Openswan/commit/9eaa6c2a823c1d2b58913506a15f9474bf857a3d,wo#7449 . verify padding contents for IKEv2 RSA sig check\n\nSpecial thanks to Sze Yiu Chau of Purdue University (schau@purdue.edu)\nwho reported the issue.,1,"[{""func_name"": ""verify_signed_hash"", ""file_path"": ""lib/liboswkeys/signatures.c"", ""func_code"": ""err_t verify_signed_hash(const struct RSA_public_key *k\n                         , u_char *s, unsigned int s_max_octets\n                         , u_char **psig\n                         , size_t hash_len\n                         , const u_char *sig_val, size_t sig_len)\n{\n    unsigned int padlen;\n\n    /* actual exponentiation; see PKCS#1 v2.0 5.1 */\n    {\n\tchunk_t temp_s;\n\tMP_INT c;\n\n\tn_to_mpz(&c, sig_val, sig_len);\n\toswcrypto.mod_exp(&c, &c, &k->e, &k->n);\n\n\ttemp_s = mpz_to_n(&c, sig_len);\t/* back to octets */\n        if(s_max_octets < sig_len) {\n            return \""2\""\""exponentiation failed; too many octets\"";\n        }\n\tmemcpy(s, temp_s.ptr, sig_len);\n\tpfree(temp_s.ptr);\n\tmpz_clear(&c);\n    }\n\n    /* check signature contents */\n    /* verify padding (not including any DER digest info! */\n    padlen = sig_len - 3 - hash_len;\n    /* now check padding */\n\n    DBG(DBG_CRYPT,\n\tDBG_dump(\""verify_sh decrypted SIG1:\"", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\""pad_len calculated: %d hash_len: %d\"", padlen, (int)hash_len));\n\n    /* skip padding */\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \""3\""\""SIG padding does not check out\"";\n    }\n\n    s += padlen + 3;\n    (*psig) = s;\n\n    /* return SUCCESS */\n    return NULL;\n}"", ""target"": 0}]","[{""func_name"": ""verify_signed_hash"", ""file_path"": ""lib/liboswkeys/signatures.c"", ""func_code"": ""err_t verify_signed_hash(const struct RSA_public_key *k\n                         , u_char *s, unsigned int s_max_octets\n                         , u_char **psig\n                         , size_t hash_len\n                         , const u_char *sig_val, size_t sig_len)\n{\n    unsigned int padlen;\n\n    /* actual exponentiation; see PKCS#1 v2.0 5.1 */\n    {\n\tchunk_t temp_s;\n\tMP_INT c;\n\n\tn_to_mpz(&c, sig_val, sig_len);\n\toswcrypto.mod_exp(&c, &c, &k->e, &k->n);\n\n\ttemp_s = mpz_to_n(&c, sig_len);\t/* back to octets */\n        if(s_max_octets < sig_len) {\n            return \""2\""\""exponentiation failed; too many octets\"";\n        }\n\tmemcpy(s, temp_s.ptr, sig_len);\n\tpfree(temp_s.ptr);\n\tmpz_clear(&c);\n    }\n\n    /* check signature contents */\n    /* verify padding (not including any DER digest info! */\n    padlen = sig_len - 3 - hash_len;\n    /* now check padding */\n\n    DBG(DBG_CRYPT,\n\tDBG_dump(\""verify_sh decrypted SIG1:\"", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\""pad_len calculated: %d hash_len: %d\"", padlen, (int)hash_len));\n\n    /* skip padding */\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \""3\""\""SIG padding does not check out\"";\n    }\n\n    /* signature starts after ASN wrapped padding [00,01,FF..FF,00] */\n    (*psig) = s + padlen + 3;\n\n    /* verify padding contents */\n    {\n        const u_char *p;\n        size_t cnt_ffs = 0;\n\n        for (p = s+2; p < s+padlen+2; p++)\n            if (*p == 0xFF)\n                cnt_ffs ++;\n\n        if (cnt_ffs != padlen)\n            return \""4\"" \""invalid Padding String\"";\n    }\n\n    /* return SUCCESS */\n    return NULL;\n}""}]","{""code"": 1, ""value"": 1}","[{""source"": ""code_info(file:signatures.c, lines:145-155)"", ""result"": ""    /* verify padding (not including any DER digest info! */\n    padlen = sig_len - 3 - hash_len;\n    /* now check padding */\n\n    DBG(DBG_CRYPT,\n\tDBG_dump(\""verify_sh decrypted SIG1:\"", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\""pad_len calculated: %d hash_len: %d\"", padlen, (int)hash_len));\n\n    /* skip padding */\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n""}, {""source"": ""value_info(file:signatures.c, value:padlen)"", ""result"": {""value_trace"": [{""full_code"": ""padlen = sig_len - 3 - hash_len"", ""line"": 87, ""func_name"": ""sign_hash""}, {""full_code"": ""padlen = sig_len - 3 - hash_len"", ""line"": 146, ""func_name"": ""verify_signed_hash""}], ""struct_var"": ""padlen"", ""struct_type"": ""size_t"", ""struct_definition"": ""size_t""}}]","In verify_signed_hash() (lib/liboswkeys/signatures.c:158-159), the code skipped padding validation without checking its contents. The padding length (padlen) was calculated as sig_len - 3 - hash_len (line 146). The original code used this value to advance the pointer past padding (s += padlen + 3) but did not verify the padding string itself. The patch (lines 164-174) adds a loop to check all bytes in the padding region (s+2 to s+padlen+2) are 0xFF. This lack of validation allowed forged signatures when small public exponents are used, as attackers could craft signatures with invalid padding strings that were not checked.",0.95,./github/other_context/CVE-2018-15836
4,CVE-2018-20595,CWE-352,java,A CSRF issue was discovered in web/authorization/oauth2/controller/OAuth2ClientController.java in hsweb 3.0.4 because the state parameter in the request is not compared with the state parameter in the session after user authentication is successful.,https://github.com/hs-web/hsweb-framework/commit/40929e9b0d336a26281a5ed2e0e721d54dd8d2f2,fix #107 csrf,1,"[{""func_name"": ""callback"", ""file_path"": ""hsweb-system/hsweb-system-oauth2-client/hsweb-system-oauth2-client-web/src/main/java/org/hswebframework/web/authorization/oauth2/controller/OAuth2ClientController.java"", ""func_code"": ""@GetMapping(\""/callback/{serverId}\"")\n    @ApiOperation(value = \""OAuth2.0\u6388\u6743\u5b8c\u6210\u540e\u56de\u8c03\"", hidden = true)\n    public RedirectView callback(@RequestParam(defaultValue = \""/\"") String redirect,\n                                 @PathVariable String serverId,\n                                 @RequestParam String code,\n                                 @RequestParam String state,\n                                 HttpServletRequest request,\n                                 HttpSession session) throws UnsupportedEncodingException {\n        try {\n            String cachedState = (String) session.getAttribute(STATE_SESSION_KEY);\n            //  if (!state.equals(cachedState)) throw new BusinessException(\""state error\"");\n            oAuth2RequestService.doEvent(serverId, new OAuth2CodeAuthBeforeEvent(code, state, request::getParameter));\n            return new RedirectView(URLDecoder.decode(redirect, \""UTF-8\""));\n        } finally {\n            session.removeAttribute(STATE_SESSION_KEY);\n        }\n    }"", ""target"": 0}]","[{""func_name"": ""callback"", ""file_path"": ""hsweb-system/hsweb-system-oauth2-client/hsweb-system-oauth2-client-web/src/main/java/org/hswebframework/web/authorization/oauth2/controller/OAuth2ClientController.java"", ""func_code"": ""@GetMapping(\""/callback/{serverId}\"")\n    @ApiOperation(value = \""OAuth2.0\u6388\u6743\u5b8c\u6210\u540e\u56de\u8c03\"", hidden = true)\n    public RedirectView callback(@RequestParam(defaultValue = \""/\"") String redirect,\n                                 @PathVariable String serverId,\n                                 @RequestParam String code,\n                                 @RequestParam String state,\n                                 HttpServletRequest request,\n                                 HttpSession session) throws UnsupportedEncodingException {\n        try {\n            String cachedState = (String) session.getAttribute(STATE_SESSION_KEY);\n            if (!state.equals(cachedState)) {\n                throw new BusinessException(ErrorType.STATE_ERROR.name());\n            }\n            oAuth2RequestService.doEvent(serverId, new OAuth2CodeAuthBeforeEvent(code, state, request::getParameter));\n            return new RedirectView(URLDecoder.decode(redirect, \""UTF-8\""));\n        } finally {\n            session.removeAttribute(STATE_SESSION_KEY);\n        }\n    }""}]","{""code"": 2, ""value"": 2, ""function"": 1}","[{""source"": ""code_info(file:OAuth2ClientController.java, lines:100-110)"", ""result"": ""                                 @PathVariable String serverId,\n                                 @RequestParam String code,\n                                 @RequestParam String state,\n                                 HttpServletRequest request,\n                                 HttpSession session) throws UnsupportedEncodingException {\n        try {\n            String cachedState = (String) session.getAttribute(STATE_SESSION_KEY);\n            //  if (!state.equals(cachedState)) throw new BusinessException(\""state error\"");\n            oAuth2RequestService.doEvent(serverId, new OAuth2CodeAuthBeforeEvent(code, state, request::getParameter));\n            return new RedirectView(URLDecoder.decode(redirect, \""UTF-8\""));\n        } finally {\n            session.removeAttribute(STATE_SESSION_KEY);\n""}, {""source"": ""value_info(file:OAuth2ClientController.java, value:STATE_SESSION_KEY)"", ""result"": {""value_trace"": [{""full_code"": ""String OAuth2ClientController.STATE_SESSION_KEY = \""OAUTH2_STATE\"""", ""line"": 64, ""func_name"": ""org.hswebframework.web.authorization.oauth2.controller.OAuth2ClientController.<clinit>:void()""}], ""struct_var"": ""STATE_SESSION_KEY"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""func_info(func:doEvent)"", ""result"": [{""code"": ""    void doEvent(String serverId, OAuth2Event event);\n"", ""start_line"": 55, ""end_line"": 55, ""full_name"": ""org.hswebframework.web.authorization.oauth2.client.OAuth2RequestService.doEvent:void(java.lang.String,org.hswebframework.web.authorization.oauth2.client.listener.OAuth2Event)"", ""file_path"": ""hsweb-authorization/hsweb-authorization-oauth2/hsweb-authorization-oauth2-client/src/main/java/org/hswebframework/web/authorization/oauth2/client/OAuth2RequestService.java""}, {""code"": ""    void doEvent(String serverId, OAuth2Event event, Class<? extends OAuth2Event> eventType);\n"", ""start_line"": 63, ""end_line"": 63, ""full_name"": ""org.hswebframework.web.authorization.oauth2.client.OAuth2RequestService.doEvent:void(java.lang.String,org.hswebframework.web.authorization.oauth2.client.listener.OAuth2Event,java.lang.Class)"", ""file_path"": ""hsweb-authorization/hsweb-authorization-oauth2/hsweb-authorization-oauth2-client/src/main/java/org/hswebframework/web/authorization/oauth2/client/OAuth2RequestService.java""}, {""code"": ""    @Override\n    public void doEvent(String serverId, OAuth2Event event) {\n        doEvent(serverId, event, event.getClass());\n    }\n"", ""start_line"": 83, ""end_line"": 86, ""full_name"": ""org.hswebframework.web.authorization.oauth2.client.simple.SimpleOAuth2RequestService.doEvent:void(java.lang.String,org.hswebframework.web.authorization.oauth2.client.listener.OAuth2Event)"", ""file_path"": ""hsweb-authorization/hsweb-authorization-oauth2/hsweb-authorization-oauth2-client/src/main/java/org/hswebframework/web/authorization/oauth2/client/simple/SimpleOAuth2RequestService.java""}]}, {""source"": ""code_info(file:OAuth2ClientController.java, lines:1-99)"", ""result"": ""/*\n *  Copyright 2016 http://www.hswebframework.org\n *\n *  Licensed under the Apache License, Version 2.0 (the \""License\"");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \""AS IS\"" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *\n */\n\npackage org.hswebframework.web.authorization.oauth2.controller;\n\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport org.hswebframework.web.WebUtil;\nimport org.hswebframework.web.authorization.oauth2.client.OAuth2RequestService;\nimport org.hswebframework.web.authorization.oauth2.client.listener.OAuth2CodeAuthBeforeEvent;\nimport org.hswebframework.web.controller.message.ResponseMessage;\nimport org.hswebframework.web.entity.oauth2.client.OAuth2ServerConfigEntity;\nimport org.hswebframework.web.id.IDGenerator;\nimport org.hswebframework.web.oauth2.core.OAuth2Constants;\nimport org.hswebframework.web.service.oauth2.client.OAuth2ServerConfigService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.servlet.view.RedirectView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\n\n/**\n * @author zhouhao\n */\n@Controller\n@RequestMapping(\""${hsweb.web.mappings.oauth2-client-callback:oauth2}\"")\n@Api(tags = \""OAuth2.0-\u5ba2\u6237\u7aef-\u8bf7\u6c42\u670d\u52a1\"", value = \""OAuth2.0\u5ba2\u6237\u7aef\u8bf7\u6c42\u670d\u52a1\"")\npublic class OAuth2ClientController {\n\n    private OAuth2RequestService oAuth2RequestService;\n\n    private OAuth2ServerConfigService oAuth2ServerConfigService;\n\n    @Autowired\n    public void setoAuth2ServerConfigService(OAuth2ServerConfigService oAuth2ServerConfigService) {\n        this.oAuth2ServerConfigService = oAuth2ServerConfigService;\n    }\n\n    @Autowired\n    public void setoAuth2RequestService(OAuth2RequestService oAuth2RequestService) {\n        this.oAuth2RequestService = oAuth2RequestService;\n    }\n\n    private static final String STATE_SESSION_KEY = \""OAUTH2_STATE\"";\n\n    @GetMapping(\""/state\"")\n    @ResponseBody\n    @ApiOperation(\""\u7533\u8bf7\u4e00\u4e2astate\"")\n    public ResponseMessage<String> requestState(HttpSession session) {\n        String state = IDGenerator.RANDOM.generate();\n        session.setAttribute(STATE_SESSION_KEY, state);\n        return ResponseMessage.ok(state);\n    }\n\n    @GetMapping(\""/boot/{serverId}\"")\n    @ApiOperation(\""\u8df3\u8f6c\u81f3OAuth2.0\u670d\u52a1\u6388\u6743\u9875\u9762\"")\n    public RedirectView boot(@PathVariable String serverId,\n                             @RequestParam(defaultValue = \""/\"") String redirect,\n                             HttpServletRequest request,\n                             HttpSession session) throws UnsupportedEncodingException {\n        OAuth2ServerConfigEntity entity = oAuth2ServerConfigService.selectByPk(serverId);\n        if (entity == null) {\n            return new RedirectView(\""/401.html\"");\n        }\n        String callback = WebUtil.getBasePath(request)\n                .concat(\""oauth2/callback/\"")\n                .concat(serverId).concat(\""/?redirect=\"")\n                .concat(URLEncoder.encode(redirect, \""UTF-8\""));\n        RedirectView view = new RedirectView(entity.getRealUrl(entity.getAuthUrl()));\n        view.addStaticAttribute(OAuth2Constants.response_type, \""code\"");\n        view.addStaticAttribute(OAuth2Constants.state, requestState(session).getResult());\n        view.addStaticAttribute(OAuth2Constants.client_id, entity.getClientId());\n        view.addStaticAttribute(OAuth2Constants.redirect_uri, callback);\n        return view;\n    }\n\n    @GetMapping(\""/callback/{serverId}\"")\n    @ApiOperation(value = \""OAuth2.0\u6388\u6743\u5b8c\u6210\u540e\u56de\u8c03\"", hidden = true)\n    public RedirectView callback(@RequestParam(defaultValue = \""/\"") String redirect,\n                                 @PathVariable String serverId,\n""}, {""source"": ""value_info(file:OAuth2ClientController.java, value:cachedState)"", ""result"": {""value_trace"": [{""full_code"": ""String cachedState = (String) session.getAttribute(STATE_SESSION_KEY)"", ""line"": 106, ""func_name"": ""org.hswebframework.web.authorization.oauth2.controller.OAuth2ClientController.callback:org.springframework.web.servlet.view.RedirectView(java.lang.String,java.lang.String,java.lang.String,java.lang.String,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpSession)""}], ""struct_var"": ""cachedState"", ""struct_type"": ""java.lang.String"", ""struct_definition"": null}}]","OAuth2ClientController.java:105-107: Missing comparison of request `state` with session `cachedState` (originally commented out). The state is stored in the session via `requestState` (OAuth2ClientController.java:58-60), which generates a random value and sets it using `session.setAttribute(STATE_SESSION_KEY, state)`. The absence of the check allowed attackers to bypass state validation, enabling CSRF attacks.",0.95,./github/other_context/CVE-2018-20595
5,CVE-2019-15162,CWE-345,c_cpp,"rpcapd/daemon.c in libpcap before 1.9.1 on non-Windows platforms provides details about why authentication failed, which might make it easier for attackers to enumerate valid usernames.",https://github.com/the-tcpdump-group/libpcap/commit/484d60cbf7ca4ec758c3cbb8a82d68b244a78d58,"On UN*X, don't tell the client why authentication failed.\n\n""no such user"" tells the client that the user ID isn't valid and,\ntherefore, that it needn't bother trying to do password cracking for\nthat user ID; just saying that the authentication failed dosn't give\nthem that hint.\n\nThis resolves the third problem in Include Security issue F11: [libpcap]\nRemote Packet Capture Daemon Multiple Authentication Improvements.\n\nThe Windows LogonUser() API returns ERROR_LOGON_FAILURE for both cases,\nso the Windows code doesn't have this issue.  Just return the same\n""Authentication failed"" message on Windows to the user.\n\nFor various authentication failures *other* than ""no such user"" and\n""password not valid"", log a message, as there's a problem that may need\ndebugging.  We don't need to tell the end user what the problem is, as\nthey may not bother reporting it and, even if they do, they may not give\nthe full error message.",1,"[{""func_name"": ""daemon_AuthUserPwd"", ""file_path"": ""rpcapd/daemon.c"", ""func_code"": ""static int\ndaemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\t/*\n\t * Warning: the user which launches the process must have the\n\t * SE_TCB_NAME right.\n\t * This corresponds to have the \""Act as part of the Operating System\""\n\t * turned on (administrative tools, local security settings, local\n\t * policies, user right assignment)\n\t * However, it seems to me that if you run it as a service, this\n\t * right should be provided by default.\n\t *\n\t * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,\n\t * which merely indicates that the user name or password is\n\t * incorrect, not whether it's the user name or the password\n\t * that's incorrect, so a client that's trying to brute-force\n\t * accounts doesn't know whether it's the user name or the\n\t * password that's incorrect, so it doesn't know whether to\n\t * stop trying to log in with a given user name and move on\n\t * to another user name.\n\t */\n\tHANDLE Token;\n\tif (LogonUser(username, \"".\"", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \""LogonUser() failed\"");\n\t\treturn -1;\n\t}\n\n\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \""ImpersonateLoggedOnUser() failed\"");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n\t * at all with getpwnam() or will only do so if you're root.\n\t *\n\t * XXX - perhaps what we *should* be using is PAM, if we have\n\t * it.  That might hide all the details of username/password\n\t * authentication, whether it's done with a visible-to-root-\n\t * only password database or some other authentication mechanism,\n\t * behind its API.\n\t */\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tchar *crypt_password;\n\n\t// This call is needed to get the uid\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed: user name or password incorrect\"");\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_GETSPNAM\n\t// This call is needed to get the password; otherwise 'x' is returned\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed: user name or password incorrect\"");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\t/*\n\t * XXX - what about other platforms?\n\t * The unixpapa.com page claims this Just Works on *BSD if you're\n\t * running as root - it's from 2000, so it doesn't indicate whether\n\t * macOS (which didn't come out until 2001, under the name Mac OS\n\t * X) behaves like the *BSDs or not, and might also work on AIX.\n\t * HP-UX does something else.\n\t *\n\t * Again, hopefully PAM hides all that.\n\t */\n\tuser_password = user->pw_passwd;\n#endif\n\n\tcrypt_password = crypt(password, user_password);\n\tif (crypt_password == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed\"");\n\t\treturn -1;\n\t}\n\tif (strcmp(user_password, crypt_password) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed: user name or password incorrect\"");\n\t\treturn -1;\n\t}\n\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \""setuid\"");\n\t\treturn -1;\n\t}\n\n/*\tif (setgid(user->pw_gid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \""setgid\"");\n\t\treturn -1;\n\t}\n*/\n\treturn 0;\n\n#endif\n\n}"", ""target"": 0}]","[{""func_name"": ""daemon_AuthUserPwd"", ""file_path"": ""rpcapd/daemon.c"", ""func_code"": ""static int\ndaemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\t/*\n\t * Warning: the user which launches the process must have the\n\t * SE_TCB_NAME right.\n\t * This corresponds to have the \""Act as part of the Operating System\""\n\t * turned on (administrative tools, local security settings, local\n\t * policies, user right assignment)\n\t * However, it seems to me that if you run it as a service, this\n\t * right should be provided by default.\n\t *\n\t * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,\n\t * which merely indicates that the user name or password is\n\t * incorrect, not whether it's the user name or the password\n\t * that's incorrect, so a client that's trying to brute-force\n\t * accounts doesn't know whether it's the user name or the\n\t * password that's incorrect, so it doesn't know whether to\n\t * stop trying to log in with a given user name and move on\n\t * to another user name.\n\t */\n\tDWORD error;\n\tHANDLE Token;\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to log\n\n\tif (LogonUser(username, \"".\"", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed\"");\n\t\terror = GetLastError();\n\t\tif (error != ERROR_LOGON_FAILURE)\n\t\t{\n\t\t\t// Some error other than an authentication error;\n\t\t\t// log it.\n\t\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, error, \""LogonUser() failed\"");\n\t\t\trpcapd_log(LOGPRIO_ERROR, \""%s\"", errmsgbuf);\n\t\t}\t\t\t    \n\t\treturn -1;\n\t}\n\n\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed\"");\n\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \""ImpersonateLoggedOnUser() failed\"");\n\t\trpcapd_log(LOGPRIO_ERROR, \""%s\"", errmsgbuf);\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n\t * at all with getpwnam() or will only do so if you're root.\n\t *\n\t * XXX - perhaps what we *should* be using is PAM, if we have\n\t * it.  That might hide all the details of username/password\n\t * authentication, whether it's done with a visible-to-root-\n\t * only password database or some other authentication mechanism,\n\t * behind its API.\n\t */\n\tint error;\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tchar *crypt_password;\n\n\t// This call is needed to get the uid\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed\"");\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_GETSPNAM\n\t// This call is needed to get the password; otherwise 'x' is returned\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed\"");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\t/*\n\t * XXX - what about other platforms?\n\t * The unixpapa.com page claims this Just Works on *BSD if you're\n\t * running as root - it's from 2000, so it doesn't indicate whether\n\t * macOS (which didn't come out until 2001, under the name Mac OS\n\t * X) behaves like the *BSDs or not, and might also work on AIX.\n\t * HP-UX does something else.\n\t *\n\t * Again, hopefully PAM hides all that.\n\t */\n\tuser_password = user->pw_passwd;\n#endif\n\n\t//\n\t// The Single UNIX Specification says that if crypt() fails it\n\t// sets errno, but some implementatons that haven't been run\n\t// through the SUS test suite might not do so.\n\t//\n\terrno = 0;\n\tcrypt_password = crypt(password, user_password);\n\tif (crypt_password == NULL)\n\t{\n\t\terror = errno;\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed\"");\n\t\tif (error == 0)\n\t\t{\n\t\t\t// It didn't set errno.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \""crypt() failed\"");\n\t\t}\n\t\telse\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \""crypt() failed: %s\"",\n\t\t\t    strerror(error));\n\t\t}\n\t\treturn -1;\n\t}\n\tif (strcmp(user_password, crypt_password) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \""Authentication failed\"");\n\t\treturn -1;\n\t}\n\n\tif (setuid(user->pw_uid))\n\t{\n\t\terror = errno;\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    error, \""setuid\"");\n\t\trpcapd_log(LOGPRIO_ERROR, \""setuid() failed: %s\"",\n\t\t    strerror(error));\n\t\treturn -1;\n\t}\n\n/*\tif (setgid(user->pw_gid))\n\t{\n\t\terror = errno;\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \""setgid\"");\n\t\trpcapd_log(LOGPRIO_ERROR, \""setgid() failed: %s\"",\n\t\t    strerror(error));\n\t\treturn -1;\n\t}\n*/\n\treturn 0;\n\n#endif\n\n}""}]","{""code"": 2, ""function"": 1}","[{""source"": ""code_info(file:daemon.c, lines:1200-1210)"", ""result"": ""#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n""}, {""source"": ""func_info(func:rpcapd_log)"", ""result"": [{""code"": ""void rpcapd_log(log_priority priority, const char *message, ...)\n{\n\tva_list ap;\n\n\tif (priority != LOGPRIO_DEBUG || log_debug_messages) {\n\t\tva_start(ap, message);\n\t\tif (log_to_systemlog)\n\t\t{\n\t\t\trpcapd_vlog_systemlog(priority, message, ap);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trpcapd_vlog_stderr(priority, message, ap);\n\t\t}\n\t\tva_end(ap);\n\t}\n}"", ""start_line"": 244, ""end_line"": 260, ""full_name"": ""rpcapd_log"", ""file_path"": ""rpcapd/log.c""}]}, {""source"": ""code_info(file:daemon.c, lines:1180-1210)"", ""result"": ""\tif (LogonUser(username, \"".\"", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \""LogonUser() failed\"");\n\t\treturn -1;\n\t}\n\n\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \""ImpersonateLoggedOnUser() failed\"");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n""}]","Original code (rpcapd/daemon.c:1228-1242, 1254-1268) returned specific error messages for `getpwnam`, `getspnam`, and `crypt()` failures. For example, `getpwnam(username)` (line 1228) would trigger `pcap_snprintf(errbuf, ... ""Authentication failed: user name or password incorrect"")` on failure, leaking username validity. The patch replaces this with `pcap_snprintf(errbuf, ... ""Authentication failed"")`, preventing enumeration. Windows code (LogonUser/ImpersonateLoggedOnUser) inherently uses generic messages via `ERROR_LOGON_FAILURE`. The commented-out `setgid()` logic (lines 1180-1210) is inactive and does not contribute to the vulnerability.",0.95,./github/other_context/CVE-2019-15162
6,CVE-2019-10182,"CWE-345, CWE-94, CWE-22",java,It was found that icedtea-web though 1.7.2 and 1.8.2 did not properly sanitize paths from <jar/> elements in JNLP files. An attacker could trick a victim into running a specially crafted application and use this flaw to upload arbitrary files to arbitrary locations in the context of the user.,https://github.com/AdoptOpenJDK/IcedTea-Web/commit/2ab070cdac087bd208f64fa8138bb709f8d7680c,Fixed bug when relative path (..) could leak up (even out of cache) - CVE-2019-10182\n\n* netx/net/sourceforge/jnlp/cache/CacheUtil.java: if path or query contains .. is saved to cache via its hash\n* netx/net/sourceforge/jnlp/util/FileUtils.java: added warning about different behavior on win/linux\n* tests/netx/unit/net/sourceforge/jnlp/cache/CacheUtilTest.java: added tests for hashing\n* tests/netx/unit/net/sourceforge/jnlp/runtime/JNLPClassLoaderTest.java:  added test for .. in path. Added test that verifies encoded .. (%2E%2E) do not leak from cahce\n* tests/netx/unit/net/sourceforge/jnlp/runtime/up.jnlp: example jnlp with .. full url\n* tests/netx/unit/net/sourceforge/jnlp/runtime/up.jnlp: example jnlp with encoded ..,5,"[{""func_name"": ""createParentDir"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/util/FileUtils.java"", ""func_code"": ""public static void createParentDir(File f, String eMsg) throws IOException {\n        File parent = f.getParentFile();\n        if (!parent.isDirectory() && !parent.mkdirs()) {\n            throw new IOException(\""Cant create directory \"" + (eMsg == null ? parent : eMsg));\n        }\n    }"", ""target"": 0}, {""func_name"": ""urlToPath"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java"", ""func_code"": ""public static File urlToPath(URL location, String subdir) {\n        if (subdir == null) {\n            throw new NullPointerException();\n        }\n\n        StringBuilder path = new StringBuilder();\n\n        path.append(subdir);\n        path.append(File.separatorChar);\n\n        path.append(location.getProtocol());\n        path.append(File.separatorChar);\n        path.append(location.getHost());\n        path.append(File.separatorChar);\n        /**\n         * This is a bit of imprecise. The usage of default port would be\n         * better, but it would cause terrible backward incompatibility.\n         */\n        if (location.getPort() > 0) {\n            path.append(location.getPort());\n            path.append(File.separatorChar);\n        }\n        path.append(location.getPath().replace('/', File.separatorChar));\n        if (location.getQuery() != null && !location.getQuery().trim().isEmpty()) {\n            path.append(\"".\"").append(location.getQuery());\n        }\n\n        File candidate = new File(FileUtils.sanitizePath(path.toString()));\n        if (candidate.getName().length() > 255) {\n            /**\n             * When filename is longer then 255 chars, then then various\n             * filesystems have issues to save it. By saving the file by its\n             * sum, we are trying to prevent collision of two files differs in\n             * suffixes (general suffix of name, not only 'filetype suffix')\n             * only. It is also preventing bug when truncate (files with 1000\n             * chars hash in query) cuts to much.\n             */\n            try {\n                MessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n                byte[] sum = md.digest(candidate.getName().getBytes(UTF_8));\n                //convert the byte to hex format method 2\n                StringBuilder hexString = new StringBuilder();\n                for (int i = 0; i < sum.length; i++) {\n                    hexString.append(Integer.toHexString(0xFF & sum[i]));\n                }\n                String extension = \""\"";\n                int i = candidate.getName().lastIndexOf('.');\n                if (i > 0) {\n                    extension = candidate.getName().substring(i);//contains dot\n                }\n                if (extension.length() < 10 && extension.length() > 1) {\n                    hexString.append(extension);\n                }\n                candidate = new File(candidate.getParentFile(), hexString.toString());\n            } catch (NoSuchAlgorithmException ex) {\n                // should not occur, cite from javadoc:\n                // every java implementation should support\n                // MD5 SHA-1 SHA-256\n                throw new RuntimeException(ex);\n            }\n        }\n        return candidate;\n    }"", ""target"": 0}, {""func_name"": ""isMetaInfFile"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/tools/JarCertVerifier.java"", ""func_code"": ""static boolean isMetaInfFile(String name) {\n        String ucName = name.toUpperCase();\n        return ucName.startsWith(META_INF);\n    }"", ""target"": 0}, {""func_name"": ""activateJars"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/runtime/JNLPClassLoader.java"", ""func_code"": ""protected void activateJars(final List<JARDesc> jars) {\n        PrivilegedAction<Void> activate = new PrivilegedAction<Void>() {\n\n            @SuppressWarnings(\""deprecation\"")\n            @Override\n            public Void run() {\n                // transfer the Jars\n                waitForJars(jars);\n\n                for (JARDesc jar : jars) {\n                    available.remove(jar);\n\n                    // add jar\n                    File localFile = tracker.getCacheFile(jar.getLocation());\n                    try {\n                        URL location = jar.getLocation(); // non-cacheable, use source location\n                        if (localFile != null) {\n                            // TODO: Should be toURI().toURL()\n                            location = localFile.toURL(); // cached file\n                            // This is really not the best way.. but we need some way for\n                            // PluginAppletViewer::getCachedImageRef() to check if the image\n                            // is available locally, and it cannot use getResources() because\n                            // that prefetches the resource, which confuses MediaTracker.waitForAll()\n                            // which does a wait(), waiting for notification (presumably\n                            // thrown after a resource is fetched). This bug manifests itself\n                            // particularly when using The FileManager applet from Webmin.\n                            try (JarFile jarFile = new JarFile(localFile)) {\n                                for (JarEntry je : Collections.list(jarFile.entries())) {\n\n                                    // another jar in my jar? it is more likely than you think\n                                    if (je.getName().endsWith(\"".jar\"")) {\n                                        // We need to extract that jar so that it can be loaded\n                                        // (inline loading with \""jar:..!/...\"" path will not work\n                                        // with standard classloader methods)\n\n                                        String extractedJarLocation = localFile + \"".nested/\"" + je.getName();\n                                        File parentDir = new File(extractedJarLocation).getParentFile();\n                                        if (!parentDir.isDirectory() && !parentDir.mkdirs()) {\n                                            throw new RuntimeException(\""Unable to extract nested jar.\"");\n                                        }\n                                        FileOutputStream extractedJar = new FileOutputStream(extractedJarLocation);\n                                        InputStream is = jarFile.getInputStream(je);\n\n                                        byte[] bytes = new byte[1024];\n                                        int read = is.read(bytes);\n                                        int fileSize = read;\n                                        while (read > 0) {\n                                            extractedJar.write(bytes, 0, read);\n                                            read = is.read(bytes);\n                                            fileSize += read;\n                                        }\n\n                                        is.close();\n                                        extractedJar.close();\n\n                                        // 0 byte file? skip\n                                        if (fileSize <= 0) {\n                                            continue;\n                                        }\n\n                                        tracker.addResource(new File(extractedJarLocation).toURL(), null, null, null);\n\n                                        URL codebase = file.getCodeBase();\n                                        if (codebase == null) {\n                                            //FIXME: codebase should be the codebase of the Main Jar not\n                                            //the location. Although, it still works in the current state.\n                                            codebase = file.getResources().getMainJAR().getLocation();\n                                        }\n\n                                        final SecurityDesc jarSecurity = securityDelegate.getJarPermissions(codebase);\n\n                                        try {\n                                            URL fileURL = new URL(\""file://\"" + extractedJarLocation);\n                                            // there is no remote URL for this, so lets fake one\n                                            URL fakeRemote = new URL(jar.getLocation().toString() + \""!\"" + je.getName());\n                                            CachedJarFileCallback.getInstance().addMapping(fakeRemote, fileURL);\n                                            addURL(fakeRemote);\n\n                                            jarLocationSecurityMap.put(fakeRemote, jarSecurity);\n\n                                        } catch (MalformedURLException mfue) {\n                                            LOG.error(\""Unable to add extracted nested jar to classpath\"", mfue);\n                                        }\n                                    }\n\n                                    jarEntries.add(je.getName());\n                                }\n                            }\n                        }\n\n                        addURL(jar.getLocation());\n\n                        // there is currently no mechanism to cache files per\n                        // instance.. so only index cached files\n                        if (localFile != null) {\n                            CachedJarFileCallback.getInstance().addMapping(jar.getLocation(), localFile.toURI().toURL());\n\n                            try (JarFile jarFile = new JarFile(localFile.getAbsolutePath())) {\n                                Manifest mf = jarFile.getManifest();\n\n                                // Only check classpath if this is the plugin and there is no jnlp_href usage.\n                                // Note that this is different from proprietary plugin behaviour.\n                                // If jnlp_href is used, the app should be treated similarly to when\n                                // it is run from javaws as a webstart.\n                                if (file instanceof PluginBridge && !((PluginBridge) file).useJNLPHref()) {\n                                    classpaths.addAll(ManifestAttributesReader.getClassPaths(mf, jar.getLocation()));\n                                }\n\n                                JarIndexAccess index = JarIndexAccess.getJarIndex(jarFile);\n                                if (index != null) {\n                                    jarIndexes.add(index);\n                                }\n                            }\n                        } else {\n                            CachedJarFileCallback.getInstance().addMapping(jar.getLocation(), jar.getLocation());\n                        }\n\n                        LOG.debug(\""Activate jar: {}\"", location);\n                    } catch (Exception ex) {\n                        LOG.error(IcedTeaWebConstants.DEFAULT_ERROR_MESSAGE, ex);\n                    }\n\n                    // some programs place a native library in any jar\n                    nativeLibraryStorage.addSearchJar(jar.getLocation());\n                }\n\n                return null;\n            }\n        };\n\n        AccessController.doPrivileged(activate, acc);\n    }"", ""target"": 0}, {""func_name"": ""hex"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java"", ""func_code"": ""private static String hex(String origName, String candidate) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n        byte[] sum = md.digest(candidate.getBytes(UTF_8));\n        //convert the byte to hex format method 2\n        StringBuilder hexString = new StringBuilder();\n        for (int i = 0; i < sum.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & sum[i]));\n        }\n        String extension = \""\"";\n        int i = origName.lastIndexOf('.');\n        if (i > 0) {\n            extension = origName.substring(i);//contains dot\n        }\n        if (extension.length() < 10 && extension.length() > 1) {\n            hexString.append(extension);\n        }\n        return hexString.toString();\n    }"", ""target"": 0}]","[{""func_name"": ""createParentDir"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/util/FileUtils.java"", ""func_code"": ""public static void createParentDir(File f, String eMsg) throws IOException {\n        File parent = f.getParentFile();\n        // warning, linux and windows behave differently. Below snippet will pass on win(security hole), fail on linux\n        // warning  mkdir is canonicaling, but exists/isDirectory is not. So  where mkdirs return true, and really creates dir, isDirectory can still return false\n        // can be seen on this example\n        // mkdirs /a/b/../c\n        // where b do not exists will lead creation of /a/c\n        // but exists on /a/b/../c is false on linux  even afterwards\n        // without hexing of .. paths,\n        if (!parent.isDirectory() && !parent.mkdirs()) {\n            throw new IOException(\""Cant create directory \"" + (eMsg == null ? parent : eMsg));\n        }\n    }""}, {""func_name"": ""urlToPath"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java"", ""func_code"": ""public static File urlToPath(URL location, String subdir) {\n        if (subdir == null) {\n            throw new NullPointerException();\n        }\n\n        StringBuilder path = new StringBuilder();\n\n        path.append(subdir);\n        path.append(File.separatorChar);\n\n        path.append(location.getProtocol());\n        path.append(File.separatorChar);\n        path.append(location.getHost());\n        path.append(File.separatorChar);\n        /**\n         * This is a bit of imprecise. The usage of default port would be\n         * better, but it would cause terrible backward incompatibility.\n         */\n        if (location.getPort() > 0) {\n            path.append(location.getPort());\n            path.append(File.separatorChar);\n        }\n        String locationPath = location.getPath().replace('/', File.separatorChar);\n        String query = \""\"";\n        if (location.getQuery() != null) {\n            query = location.getQuery();\n        }\n        if (locationPath.contains(\""..\"") || query.contains(\""..\"")){\n            try {\n                /**\n                 * if path contains .. then it can harm lcoal system\n                 * So without mercy, hash it\n                 */\n                String hexed = hex(new File(locationPath).getName(), locationPath);\n                return new File(path.toString(), hexed.toString());\n            } catch (NoSuchAlgorithmException ex) {\n                // should not occur, cite from javadoc:\n                // every java implementation should support\n                // MD5 SHA-1 SHA-256\n                throw new RuntimeException(ex);\n            }\n        } else {\n            path.append(locationPath);\n            if (location.getQuery() != null && !location.getQuery().trim().isEmpty()) {\n                path.append(\"".\"").append(location.getQuery());\n            }\n\n            File candidate = new File(FileUtils.sanitizePath(path.toString()));\n            try {\n                if (candidate.getName().length() > 255) {\n                    /**\n                     * When filename is longer then 255 chars, then then various\n                     * filesystems have issues to save it. By saving the file by its\n                     * sum, we are trying to prevent collision of two files differs in\n                     * suffixes (general suffix of name, not only 'filetype suffix')\n                     * only. It is also preventing bug when truncate (files with 1000\n                     * chars hash in query) cuts to much.\n                     */\n                    String hexed = hex(candidate.getName(), candidate.getName());\n                    candidate = new File(candidate.getParentFile(), hexed.toString());\n                }\n            } catch (NoSuchAlgorithmException ex) {\n                // should not occur, cite from javadoc:\n                // every java implementation should support\n                // MD5 SHA-1 SHA-256\n                throw new RuntimeException(ex);\n            }\n            return candidate;\n        }\n    }""}, {""func_name"": ""isMetaInfFile"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/tools/JarCertVerifier.java"", ""func_code"": ""static boolean isMetaInfFile(String name) {\n        if (name.endsWith(\""class\"")) {\n            return false;\n        }\n        return name.startsWith(META_INF) && (\n                name.endsWith(\"".MF\"") ||\n                name.endsWith(\"".SF\"") ||\n                name.endsWith(\"".DSA\"") ||\n                name.endsWith(\"".RSA\"") ||\n                SIG.matcher(name).matches()\n        );\n    }""}, {""func_name"": ""activateJars"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/runtime/JNLPClassLoader.java"", ""func_code"": ""protected void activateJars(final List<JARDesc> jars) {\n        PrivilegedAction<Void> activate = new PrivilegedAction<Void>() {\n\n            @SuppressWarnings(\""deprecation\"")\n            @Override\n            public Void run() {\n                // transfer the Jars\n                waitForJars(jars);\n\n                for (JARDesc jar : jars) {\n                    available.remove(jar);\n\n                    // add jar\n                    File localFile = tracker.getCacheFile(jar.getLocation());\n                    try {\n                        URL location = jar.getLocation(); // non-cacheable, use source location\n                        if (localFile != null) {\n                            // TODO: Should be toURI().toURL()\n                            location = localFile.toURL(); // cached file\n                            // This is really not the best way.. but we need some way for\n                            // PluginAppletViewer::getCachedImageRef() to check if the image\n                            // is available locally, and it cannot use getResources() because\n                            // that prefetches the resource, which confuses MediaTracker.waitForAll()\n                            // which does a wait(), waiting for notification (presumably\n                            // thrown after a resource is fetched). This bug manifests itself\n                            // particularly when using The FileManager applet from Webmin.\n                            try (JarFile jarFile = new JarFile(localFile)) {\n                                for (JarEntry je : Collections.list(jarFile.entries())) {\n\n                                    // another jar in my jar? it is more likely than you think\n                                    if (je.getName().endsWith(\"".jar\"")) {\n                                        // We need to extract that jar so that it can be loaded\n                                        // (inline loading with \""jar:..!/...\"" path will not work\n                                        // with standard classloader methods)\n\n                                        String name = je.getName();\n                                        if (name.contains(\""..\"")){\n                                            name=CacheUtil.hex(name, name);\n                                        }\n                                        String extractedJarLocation = localFile + \"".nested/\"" + name;\n                                        File parentDir = new File(extractedJarLocation).getParentFile();\n                                        if (!parentDir.isDirectory() && !parentDir.mkdirs()) {\n                                            throw new RuntimeException(\""Unable to extract nested jar.\"");\n                                        }\n                                        FileOutputStream extractedJar = new FileOutputStream(extractedJarLocation);\n                                        InputStream is = jarFile.getInputStream(je);\n\n                                        byte[] bytes = new byte[1024];\n                                        int read = is.read(bytes);\n                                        int fileSize = read;\n                                        while (read > 0) {\n                                            extractedJar.write(bytes, 0, read);\n                                            read = is.read(bytes);\n                                            fileSize += read;\n                                        }\n\n                                        is.close();\n                                        extractedJar.close();\n\n                                        // 0 byte file? skip\n                                        if (fileSize <= 0) {\n                                            continue;\n                                        }\n\n                                        tracker.addResource(new File(extractedJarLocation).toURL(), null, null, null);\n\n                                        URL codebase = file.getCodeBase();\n                                        if (codebase == null) {\n                                            //FIXME: codebase should be the codebase of the Main Jar not\n                                            //the location. Although, it still works in the current state.\n                                            codebase = file.getResources().getMainJAR().getLocation();\n                                        }\n\n                                        final SecurityDesc jarSecurity = securityDelegate.getJarPermissions(codebase);\n\n                                        try {\n                                            URL fileURL = new URL(\""file://\"" + extractedJarLocation);\n                                            // there is no remote URL for this, so lets fake one\n                                            URL fakeRemote = new URL(jar.getLocation().toString() + \""!\"" + je.getName());\n                                            CachedJarFileCallback.getInstance().addMapping(fakeRemote, fileURL);\n                                            addURL(fakeRemote);\n\n                                            jarLocationSecurityMap.put(fakeRemote, jarSecurity);\n\n                                        } catch (MalformedURLException mfue) {\n                                            LOG.error(\""Unable to add extracted nested jar to classpath\"", mfue);\n                                        }\n                                    }\n\n                                    jarEntries.add(je.getName());\n                                }\n                            }\n                        }\n\n                        addURL(jar.getLocation());\n\n                        // there is currently no mechanism to cache files per\n                        // instance.. so only index cached files\n                        if (localFile != null) {\n                            CachedJarFileCallback.getInstance().addMapping(jar.getLocation(), localFile.toURI().toURL());\n\n                            try (JarFile jarFile = new JarFile(localFile.getAbsolutePath())) {\n                                Manifest mf = jarFile.getManifest();\n\n                                // Only check classpath if this is the plugin and there is no jnlp_href usage.\n                                // Note that this is different from proprietary plugin behaviour.\n                                // If jnlp_href is used, the app should be treated similarly to when\n                                // it is run from javaws as a webstart.\n                                if (file instanceof PluginBridge && !((PluginBridge) file).useJNLPHref()) {\n                                    classpaths.addAll(ManifestAttributesReader.getClassPaths(mf, jar.getLocation()));\n                                }\n\n                                JarIndexAccess index = JarIndexAccess.getJarIndex(jarFile);\n                                if (index != null) {\n                                    jarIndexes.add(index);\n                                }\n                            }\n                        } else {\n                            CachedJarFileCallback.getInstance().addMapping(jar.getLocation(), jar.getLocation());\n                        }\n\n                        LOG.debug(\""Activate jar: {}\"", location);\n                    } catch (Exception ex) {\n                        LOG.error(IcedTeaWebConstants.DEFAULT_ERROR_MESSAGE, ex);\n                    }\n\n                    // some programs place a native library in any jar\n                    nativeLibraryStorage.addSearchJar(jar.getLocation());\n                }\n\n                return null;\n            }\n        };\n\n        AccessController.doPrivileged(activate, acc);\n    }""}, {""func_name"": ""hex"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java"", ""func_code"": ""public static String hex(String origName, String candidate) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\n        byte[] sum = md.digest(candidate.getBytes(UTF_8));\n        //convert the byte to hex format method 2\n        StringBuilder hexString = new StringBuilder();\n        for (int i = 0; i < sum.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & sum[i]));\n        }\n        String extension = \""\"";\n        int i = origName.lastIndexOf('.');\n        if (i > 0) {\n            extension = origName.substring(i);//contains dot\n        }\n        if (extension.length() < 10 && extension.length() > 1) {\n            hexString.append(extension);\n        }\n        return hexString.toString();\n    }""}]","{""caller"": 1, ""function"": 1}","[{""source"": ""caller_info(file:CacheUtil.java, func:urlToPath)"", ""result"": [{""call_line"": 511, ""call_code"": ""urlToPath(source, \""\"")"", ""caller_code"": ""    public static File getCacheFile(final URL source, final VersionString version) {\n        if (!isCacheable(source))\n            throw new IllegalArgumentException(source + \"" is not a cacheable resource\"");\n\n        File cacheFile = null;\n        final CacheLRUWrapper lruHandler = CacheLRUWrapper.getInstance();\n        synchronized (lruHandler) {\n            try {\n                lruHandler.lock();\n\n                // We need to reload the cacheOrder file each time\n                // since another plugin/javaws instance may have updated it.\n                lruHandler.load();\n                cacheFile = getCacheFileIfExist(urlToPath(source, \""\""));\n                if (cacheFile == null) { // We did not find a copy of it.\n                    cacheFile = makeNewCacheFile(source, version);\n                } else\n                    lruHandler.store();\n            } finally {\n                lruHandler.unlock();\n            }\n        }\n        return cacheFile;\n    }\n"", ""caller_start"": 498, ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java""}, {""call_line"": 602, ""call_code"": ""urlToPath(source, path)"", ""caller_code"": ""    public static File makeNewCacheFile(final URL source, final VersionString version) {\n        final CacheLRUWrapper lruHandler = CacheLRUWrapper.getInstance();\n        synchronized (lruHandler) {\n            File cacheFile = null;\n            try {\n                lruHandler.lock();\n                lruHandler.load();\n                for (long i = 0; i < Long.MAX_VALUE; i++) {\n                    String path = lruHandler.getCacheDir().getFullPath() + File.separator + i;\n                    File cDir = new File(path);\n                    if (!cDir.exists()) {\n                        // We can use this directory.\n                        try {\n                            cacheFile = urlToPath(source, path);\n                            FileUtils.createParentDir(cacheFile);\n                            File pf = new File(cacheFile.getPath() + CacheDirectory.INFO_SUFFIX);\n                            FileUtils.createRestrictedFile(pf, true); // Create the info file for marking later.\n                            lruHandler.addEntry(lruHandler.generateKey(cacheFile.getPath()), cacheFile.getPath());\n                        } catch (IOException ioe) {\n                            LOG.error(IcedTeaWebConstants.DEFAULT_ERROR_MESSAGE, ioe);\n                        }\n\n                        break;\n                    }\n                }\n\n                lruHandler.store();\n            } finally {\n                lruHandler.unlock();\n            }\n            return cacheFile;\n        }\n    }\n"", ""caller_start"": 589, ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java""}, {""call_line"": 96, ""call_code"": ""CacheUtil.urlToPath(location, pcache)"", ""caller_code"": ""    private File toCacheFile(URL location) {\n        String pcache = PathsAndFiles.PCACHE_DIR.getFullPath();\n        return CacheUtil.urlToPath(location, pcache);\n    }\n"", ""caller_start"": 94, ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/services/XPersistenceService.java""}]}, {""source"": ""func_info(func:sanitizePath)"", ""result"": [{""code"": ""    public static String sanitizePath(String path) {\n        return sanitizePath(path, SANITIZED_CHAR);\n    }\n"", ""start_line"": 105, ""end_line"": 107, ""full_name"": ""net.sourceforge.jnlp.util.FileUtils.sanitizePath:java.lang.String(java.lang.String)"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/util/FileUtils.java""}, {""code"": ""    public static String sanitizePath(String path, char substitute) {\n        //on windows, we can receive both c:/path/ and c:\\path\\\n        path = path.replace(\""\\\\\"", \""/\"");\n        if (OsUtil.isWindows() && path.matches(\""^[a-zA-Z]\\\\:.*\"")) {\n            path = path.replaceFirst(\"":\"", WIN_DRIVE_LETTER_COLON_WILDCHAR);\n        }\n        for (int i = 0; i < INVALID_PATH.size(); i++) {\n            if (-1 != path.indexOf(INVALID_PATH.get(i))) {\n                path = path.replace(INVALID_PATH.get(i), substitute);\n            }\n        }\n        if (OsUtil.isWindows()) {\n            path = path.replaceFirst(WIN_DRIVE_LETTER_COLON_WILDCHAR, \"":\"");\n        }\n        return path;\n    }\n"", ""start_line"": 109, ""end_line"": 124, ""full_name"": ""net.sourceforge.jnlp.util.FileUtils.sanitizePath:java.lang.String(java.lang.String,char)"", ""file_path"": ""core/src/main/java/net/sourceforge/jnlp/util/FileUtils.java""}]}]","Paths containing '..' in JNLP <jar/> elements were not sanitized before being used to generate cache file paths. The `urlToPath` function (core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java:699-743) failed to block traversal sequences, allowing attackers to craft URLs like `http://example.com/../../malicious.jar`. The `sanitizePath` function (core/src/main/java/net/sourceforge/jnlp/util/FileUtils.java:109-124) replaced invalid characters but did not address '..' traversal. When `getCacheFile` (core/src/main/java/net/sourceforge/jnlp/cache/CacheUtil.java:498-511) called `urlToPath`, traversal paths were resolved to filesystem locations, enabling arbitrary file writes. The patch adds '..' checks and hashing to prevent this.",0.95,./github/other_context/CVE-2019-10182
7,CVE-2019-25052,CWE-327,c_cpp,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,"cryp: prevent direct calls to update and final functions\n\nWith inconsistent or malformed data it has been possible to call\n""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]\nwe have seen that this results in asserts, i.e., a crash that\npotentially could leak sensitive information.\n\nBy setting the state (initialized) in the crypto context (i.e., the\ntee_cryp_state) at the end of all syscall_*_init functions and then add\na check of the state at the beginning of all update and final functions,\n  we prevent direct entrance to the ""update"" and ""final"" functions.\n\n[1] https://github.com/MartijnB/optee_fuzzer\n\nFixes: OP-TEE-2019-0021\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Martijn Bogaard <bogaard@riscure.com>\nAcked-by: Jerome Forissier <jerome.forissier@linaro.org>\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",12,"[{""func_name"": ""syscall_authenc_update_aad"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_authenc_update_aad(unsigned long state,\n\t\t\tconst void *aad_data, size_t aad_data_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) aad_data,\n\t\t\t\t\t  aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = crypto_authenc_update_aad(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\taad_data, aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn TEE_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""syscall_authenc_dec_final"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_authenc_dec_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, const void *tag, size_t tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_DECRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_dec_final(cs->ctx, cs->algo, src_data, src_len,\n\t\t\t\t       dst_data, &dlen, tag, tag_len);\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}"", ""target"": 0}, {""func_name"": ""syscall_authenc_update_payload"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_authenc_update_payload(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t    src_data, src_len, dst_data,\n\t\t\t\t\t    &dlen);\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}"", ""target"": 0}, {""func_name"": ""syscall_cryp_state_copy"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\treturn TEE_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""syscall_cipher_init"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key1;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey1 = o->attr;\n\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_cipher_final;\n\treturn TEE_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""syscall_hash_update"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Zero length hash is valid, but nothing we need to do. */\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""syscall_hash_final"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_hash_final(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size, void *hash, uint64_t *hash_len)\n{\n\tTEE_Result res, res2;\n\tsize_t hash_size;\n\tsize_t hlen = 0;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&hlen, hash_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)hash, hlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = tee_hash_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\t chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tcase TEE_OPERATION_MAC:\n\t\tres = tee_mac_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\tchunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\nout:\n\tres2 = put_user_u64(hash_len, hash_size);\n\tif (res2 != TEE_SUCCESS)\n\t\treturn res2;\n\treturn res;\n}"", ""target"": 0}, {""func_name"": ""tee_svc_cipher_update_helper"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""static TEE_Result tee_svc_cipher_update_helper(unsigned long state,\n\t\t\tbool last_block, const void *src, size_t src_len,\n\t\t\tvoid *dst, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tif (src_len > 0) {\n\t\t/* Permit src_len == 0 to finalize the operation */\n\t\tres = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t   last_block, src, src_len, dst);\n\t}\n\n\tif (last_block && cs->ctx_finalize != NULL) {\n\t\tcs->ctx_finalize(cs->ctx, cs->algo);\n\t\tcs->ctx_finalize = NULL;\n\t}\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2;\n\n\t\tres2 = put_user_u64(dst_len, src_len);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}"", ""target"": 0}, {""func_name"": ""syscall_authenc_init"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t  (uint8_t *)(key + 1), key->key_size,\n\t\t\t\t  nonce, nonce_len, tag_len, aad_len,\n\t\t\t\t  payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n\treturn TEE_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""syscall_hash_init"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}"", ""target"": 0}, {""func_name"": ""syscall_authenc_enc_final"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_authenc_enc_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, void *tag, uint64_t *tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\tsize_t tlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = get_user_u64_as_size_t(&tlen, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_enc_final(cs->ctx, cs->algo, src_data,\n\t\t\t\t       src_len, dst_data, &dlen, tag, &tlen);\n\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tif (dst_len != NULL) {\n\t\t\tres2 = put_user_u64(dst_len, dlen);\n\t\t\tif (res2 != TEE_SUCCESS)\n\t\t\t\treturn res2;\n\t\t}\n\n\t\tres2 = put_user_u64(tag_len, tlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}"", ""target"": 0}, {""func_name"": ""syscall_cryp_state_alloc"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_EXTENSION:\n#ifdef CFG_CRYPTO_RSASSA_NA1\n\t\tif (algo == TEE_ALG_RSASSA_PKCS1_V1_5)\n\t\t\tgoto rsassa_na1;\n#endif\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||\n\t\t    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\nrsassa_na1: __maybe_unused\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}"", ""target"": 0}]","[{""func_name"": ""syscall_authenc_update_aad"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_authenc_update_aad(unsigned long state,\n\t\t\tconst void *aad_data, size_t aad_data_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) aad_data,\n\t\t\t\t\t  aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = crypto_authenc_update_aad(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\taad_data, aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn TEE_SUCCESS;\n}""}, {""func_name"": ""syscall_authenc_dec_final"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_authenc_dec_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, const void *tag, size_t tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (cs->mode != TEE_MODE_DECRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_dec_final(cs->ctx, cs->algo, src_data, src_len,\n\t\t\t\t       dst_data, &dlen, tag, tag_len);\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}""}, {""func_name"": ""syscall_authenc_update_payload"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_authenc_update_payload(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t    src_data, src_len, dst_data,\n\t\t\t\t\t    &dlen);\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}""}, {""func_name"": ""syscall_cryp_state_copy"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\tcs_dst->state = cs_src->state;\n\n\treturn TEE_SUCCESS;\n}""}, {""func_name"": ""syscall_cipher_init"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key1;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey1 = o->attr;\n\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_cipher_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}""}, {""func_name"": ""syscall_hash_update"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Zero length hash is valid, but nothing we need to do. */\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}""}, {""func_name"": ""syscall_hash_final"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_hash_final(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size, void *hash, uint64_t *hash_len)\n{\n\tTEE_Result res, res2;\n\tsize_t hash_size;\n\tsize_t hlen = 0;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&hlen, hash_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)hash, hlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = tee_hash_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\t chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tcase TEE_OPERATION_MAC:\n\t\tres = tee_mac_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\tchunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\nout:\n\tres2 = put_user_u64(hash_len, hash_size);\n\tif (res2 != TEE_SUCCESS)\n\t\treturn res2;\n\treturn res;\n}""}, {""func_name"": ""tee_svc_cipher_update_helper"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""static TEE_Result tee_svc_cipher_update_helper(unsigned long state,\n\t\t\tbool last_block, const void *src, size_t src_len,\n\t\t\tvoid *dst, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tif (src_len > 0) {\n\t\t/* Permit src_len == 0 to finalize the operation */\n\t\tres = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t   last_block, src, src_len, dst);\n\t}\n\n\tif (last_block && cs->ctx_finalize != NULL) {\n\t\tcs->ctx_finalize(cs->ctx, cs->algo);\n\t\tcs->ctx_finalize = NULL;\n\t}\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2;\n\n\t\tres2 = put_user_u64(dst_len, src_len);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}""}, {""func_name"": ""syscall_authenc_init"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t  (uint8_t *)(key + 1), key->key_size,\n\t\t\t\t  nonce, nonce_len, tag_len, aad_len,\n\t\t\t\t  payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}""}, {""func_name"": ""syscall_hash_init"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}""}, {""func_name"": ""syscall_authenc_enc_final"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_authenc_enc_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, void *tag, uint64_t *tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\tsize_t tlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (cs->mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = get_user_u64_as_size_t(&tlen, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_enc_final(cs->ctx, cs->algo, src_data,\n\t\t\t\t       src_len, dst_data, &dlen, tag, &tlen);\n\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tif (dst_len != NULL) {\n\t\t\tres2 = put_user_u64(dst_len, dlen);\n\t\t\tif (res2 != TEE_SUCCESS)\n\t\t\t\treturn res2;\n\t\t}\n\n\t\tres2 = put_user_u64(tag_len, tlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}""}, {""func_name"": ""syscall_cryp_state_alloc"", ""file_path"": ""core/tee/tee_svc_cryp.c"", ""func_code"": ""TEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\tcs->state = CRYP_STATE_UNINITIALIZED;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_EXTENSION:\n#ifdef CFG_CRYPTO_RSASSA_NA1\n\t\tif (algo == TEE_ALG_RSASSA_PKCS1_V1_5)\n\t\t\tgoto rsassa_na1;\n#endif\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||\n\t\t    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\nrsassa_na1: __maybe_unused\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}""}]","{""function"": 2, ""code"": 1, ""caller"": 1}","[{""source"": ""func_info(file:tee_svc_cryp.c, func:tee_svc_cryp_get_state)"", ""result"": [{""code"": ""static TEE_Result tee_svc_cryp_get_state(struct tee_ta_session *sess,\n\t\t\t\t\t uint32_t state_id,\n\t\t\t\t\t struct tee_cryp_state **state)\n{\n\tstruct tee_cryp_state *s;\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\n\tTAILQ_FOREACH(s, &utc->cryp_states, link) {\n\t\tif (state_id == (vaddr_t)s) {\n\t\t\t*state = s;\n\t\t\treturn TEE_SUCCESS;\n\t\t}\n\t}\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}"", ""start_line"": 1886, ""end_line"": 1900, ""full_name"": ""tee_svc_cryp_get_state"", ""file_path"": ""core/tee/tee_svc_cryp.c""}]}, {""source"": ""code_info(file:tee_svc_cryp.c, lines:1-200)"", ""result"": ""// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014, STMicroelectronics International N.V.\n */\n\n#include <assert.h>\n#include <compiler.h>\n#include <crypto/crypto.h>\n#include <kernel/tee_ta_manager.h>\n#include <mm/tee_mmu.h>\n#include <stdlib_ext.h>\n#include <string_ext.h>\n#include <string.h>\n#include <sys/queue.h>\n#include <tee_api_types.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee/tee_obj.h>\n#include <tee/tee_svc_cryp.h>\n#include <tee/tee_svc.h>\n#include <trace.h>\n#include <utee_defines.h>\n#include <util.h>\n#include <tee_api_defines_extensions.h>\n#if defined(CFG_CRYPTO_HKDF)\n#include <tee/tee_cryp_hkdf.h>\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n#include <tee/tee_cryp_concat_kdf.h>\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n#include <tee/tee_cryp_pbkdf2.h>\n#endif\n\ntypedef void (*tee_cryp_ctx_finalize_func_t) (void *ctx, uint32_t algo);\nstruct tee_cryp_state {\n\tTAILQ_ENTRY(tee_cryp_state) link;\n\tuint32_t algo;\n\tuint32_t mode;\n\tvaddr_t key1;\n\tvaddr_t key2;\n\tvoid *ctx;\n\ttee_cryp_ctx_finalize_func_t ctx_finalize;\n};\n\nstruct tee_cryp_obj_secret {\n\tuint32_t key_size;\n\tuint32_t alloc_size;\n\n\t/*\n\t * Pseudo code visualize layout of structure\n\t * Next follows data, such as:\n\t *\tuint8_t data[alloc_size]\n\t * key_size must never exceed alloc_size\n\t */\n};\n\n#define TEE_TYPE_ATTR_OPTIONAL       0x0\n#define TEE_TYPE_ATTR_REQUIRED       0x1\n#define TEE_TYPE_ATTR_OPTIONAL_GROUP 0x2\n#define TEE_TYPE_ATTR_SIZE_INDICATOR 0x4\n#define TEE_TYPE_ATTR_GEN_KEY_OPT    0x8\n#define TEE_TYPE_ATTR_GEN_KEY_REQ    0x10\n\n    /* Handle storing of generic secret keys of varying lengths */\n#define ATTR_OPS_INDEX_SECRET     0\n    /* Convert to/from big-endian byte array and provider-specific bignum */\n#define ATTR_OPS_INDEX_BIGNUM     1\n    /* Convert to/from value attribute depending on direction */\n#define ATTR_OPS_INDEX_VALUE      2\n\nstruct tee_cryp_obj_type_attrs {\n\tuint32_t attr_id;\n\tuint16_t flags;\n\tuint16_t ops_index;\n\tuint16_t raw_offs;\n\tuint16_t raw_size;\n};\n\n#define RAW_DATA(_x, _y)\t\\\n\t.raw_offs = offsetof(_x, _y), .raw_size = MEMBER_SIZE(_x, _y)\n\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_secret_value_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_SECRET_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_rsa_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_RSA_MODULUS,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_public_key, n)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PUBLIC_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_public_key, e)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_rsa_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_RSA_MODULUS,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, n)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PUBLIC_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, e)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIVATE_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, d)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIME1,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIME2,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_EXPONENT1,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, dp)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_EXPONENT2,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, dq)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_COEFFICIENT,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, qp)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dsa_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, y)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dsa_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n""}, {""source"": ""func_info(func:crypto_cipher_final)"", ""result"": [{""code"": ""void crypto_cipher_final(void *ctx, uint32_t algo);"", ""start_line"": 48, ""end_line"": 48, ""full_name"": ""crypto_cipher_final"", ""file_path"": ""core/include/crypto/crypto.h""}]}, {""source"": ""caller_info(file:tee_svc_cryp.c, func:tee_svc_cryp_get_state)"", ""result"": [{""call_line"": 2153, ""call_code"": ""tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst)"", ""caller_code"": ""TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n"", ""caller_start"": 2142, ""file_path"": ""core/tee/tee_svc_cryp.c""}, {""call_line"": 2157, ""call_code"": ""tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src)"", ""caller_code"": ""TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n"", ""caller_start"": 2142, ""file_path"": ""core/tee/tee_svc_cryp.c""}, {""call_line"": 2203, ""call_code"": ""tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs)"", ""caller_code"": ""TEE_Result syscall_cryp_state_free(unsigned long state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcryp_state_free(to_user_ta_ctx(sess->ctx), cs);\n\treturn TEE_SUCCESS;\n}"", ""caller_start"": 2193, ""file_path"": ""core/tee/tee_svc_cryp.c""}, {""call_line"": 2285, ""call_code"": ""tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs)"", ""caller_code"": ""TEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Zero length hash is valid, but nothing we need to do. */\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n"", ""caller_start"": 2259, ""file_path"": ""core/tee/tee_svc_cryp.c""}]}]","Attackers could allocate a `struct tee_cryp_state` via `syscall_cryp_state_alloc` (core/tee/tee_svc_cryp.c:2057+) which initializes `cs->state = CRYP_STATE_UNINITIALIZED`. Without calling an init function (e.g., `syscall_hash_init` at core/tee/tee_svc_cryp.c:84+ which sets `cs->state = CRYP_STATE_INITIALIZED`), the attacker directly invokes update/final functions (e.g., `syscall_hash_update` at core/tee/tee_svc_cryp.c:2287+). The patch adds checks like `if (cs->state != CRYP_STATE_INITIALIZED)` to block this. The `tee_svc_cryp_get_state()` function (core/tee/tee_svc_cryp.c:1886-1900) retrieves the state but does not validate initialization, allowing malformed `state_id`s to bypass checks before the patch.",0.95,./github/other_context/CVE-2019-25052
8,CVE-2021-29451,CWE-347,java,Portofino is an open source web development framework. Portofino before version 5.2.1 did not properly verify the signature of JSON Web Tokens. This allows forging a valid JWT. The issue will be patched in the upcoming 5.2.1 release.,https://github.com/ManyDesigns/Portofino/commit/8c754a0ad234555e813dcbf9e57d637f9f23d8fb,Fix security vulnerability,4,"[{""func_name"": ""loadAuthenticationInfo"", ""file_path"": ""portofino-core/src/main/java/com/manydesigns/portofino/shiro/AbstractPortofinoRealm.java"", ""func_code"": ""public AuthenticationInfo loadAuthenticationInfo(JSONWebToken token) {\n        Key key = getJWTKey();\n        Jwt jwt;\n        try {\n            jwt = Jwts.parser().setSigningKey(key).parse(token.getPrincipal());\n        } catch (JwtException e) {\n            throw new AuthenticationException(e);\n        }\n        String credentials = legacyHashing ? token.getCredentials() : encryptPassword(token.getCredentials());\n        Object principal = extractPrincipalFromWebToken(jwt);\n        return new SimpleAuthenticationInfo(principal, credentials, getName());\n    }"", ""target"": 0}, {""func_name"": ""extractPrincipalFromWebToken"", ""file_path"": ""portofino-core/src/main/java/com/manydesigns/portofino/shiro/AbstractPortofinoRealm.java"", ""func_code"": ""protected Object extractPrincipalFromWebToken(Jwt jwt) {\n        Map body = (Map) jwt.getBody();\n        String base64Principal = (String) body.get(\""serialized-principal\"");\n        byte[] serializedPrincipal = Base64.decode(base64Principal);\n        Object principal;\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader(codeBase.asClassLoader()); //In case the serialized principal is a POJO entity\n            ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(serializedPrincipal)) {\n                @Override\n                protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n                    return codeBase.loadClass(desc.getName());\n                }\n            };\n            principal = objectInputStream.readObject();\n            objectInputStream.close();\n        } catch (Exception e) {\n            throw new AuthenticationException(e);\n        } finally {\n            Thread.currentThread().setContextClassLoader(loader);\n        }\n        return principal;\n    }"", ""target"": 1}, {""func_name"": ""getPrincipal"", ""file_path"": ""dispatcher/src/main/java/com/manydesigns/portofino/dispatcher/security/jwt/JWTRealm.java"", ""func_code"": ""protected Map<String, Serializable> getPrincipal(Jwt jwt) {\n        Map<String, Serializable> principal = new HashMap<>();\n        principal.put(\""jwt\"", (Serializable) jwt.getBody());\n        return principal;\n    }"", ""target"": 0}, {""func_name"": ""doGetAuthenticationInfo"", ""file_path"": ""dispatcher/src/main/java/com/manydesigns/portofino/dispatcher/security/jwt/JWTRealm.java"", ""func_code"": ""@Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        String secret = getSecret();\n        Key key = new SecretKeySpec(Decoders.BASE64.decode(secret), getSignatureAlgorithm().getJcaName());\n        \n        Jwt jwt = Jwts.parser().\n                setSigningKey(key).\n                parse((String) token.getPrincipal());\n        Map<String, Serializable> principal = getPrincipal(jwt);\n        return new SimpleAuthenticationInfo(principal, ((String) token.getCredentials()).toCharArray(), getName());\n    }"", ""target"": 0}]","[{""func_name"": ""loadAuthenticationInfo"", ""file_path"": ""portofino-core/src/main/java/com/manydesigns/portofino/shiro/AbstractPortofinoRealm.java"", ""func_code"": ""public AuthenticationInfo loadAuthenticationInfo(JSONWebToken token) {\n        Key key = getJWTKey();\n        Jws<Claims> jwt;\n        try {\n            jwt = Jwts.parser().setSigningKey(key).parseClaimsJws(token.getPrincipal());\n        } catch (JwtException e) {\n            throw new AuthenticationException(e);\n        }\n        String credentials = legacyHashing ? token.getCredentials() : encryptPassword(token.getCredentials());\n        Object principal = extractPrincipalFromWebToken(jwt);\n        return new SimpleAuthenticationInfo(principal, credentials, getName());\n    }""}, {""func_name"": ""extractPrincipalFromWebToken"", ""file_path"": ""portofino-core/src/main/java/com/manydesigns/portofino/shiro/AbstractPortofinoRealm.java"", ""func_code"": ""protected Object extractPrincipalFromWebToken(Jws<Claims> jwt) {\n        Map<String, Object> body = jwt.getBody();\n        String base64Principal = (String) body.get(\""serialized-principal\"");\n        byte[] serializedPrincipal = Base64.decode(base64Principal);\n        Object principal;\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader(codeBase.asClassLoader()); //In case the serialized principal is a POJO entity\n            ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(serializedPrincipal)) {\n                @Override\n                protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n                    return codeBase.loadClass(desc.getName());\n                }\n            };\n            principal = objectInputStream.readObject();\n            objectInputStream.close();\n        } catch (Exception e) {\n            throw new AuthenticationException(e);\n        } finally {\n            Thread.currentThread().setContextClassLoader(loader);\n        }\n        return principal;\n    }""}, {""func_name"": ""getPrincipal"", ""file_path"": ""dispatcher/src/main/java/com/manydesigns/portofino/dispatcher/security/jwt/JWTRealm.java"", ""func_code"": ""protected Map<String, Serializable> getPrincipal(Jws<Claims> jwt) {\n        Map<String, Serializable> principal = new HashMap<>();\n        principal.put(\""jwt\"", (Serializable) jwt.getBody());\n        return principal;\n    }""}, {""func_name"": ""doGetAuthenticationInfo"", ""file_path"": ""dispatcher/src/main/java/com/manydesigns/portofino/dispatcher/security/jwt/JWTRealm.java"", ""func_code"": ""@Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        String secret = getSecret();\n        Key key = new SecretKeySpec(Decoders.BASE64.decode(secret), getSignatureAlgorithm().getJcaName());\n        \n        Jws<Claims> jwt = Jwts.parser().\n                setSigningKey(key).\n                parseClaimsJws((String) token.getPrincipal());\n        Map<String, Serializable> principal = getPrincipal(jwt);\n        return new SimpleAuthenticationInfo(principal, ((String) token.getCredentials()).toCharArray(), getName());\n    }""}]",{},[],"The original code used `Jwts.parser().parse()` (which does not verify signatures) instead of `parseClaimsJws()` (which does). This allowed forged JWTs to be accepted as valid. The patch replaces these calls in `loadAuthenticationInfo` (AbstractPortofinoRealm.java:17-18) and `doGetAuthenticationInfo` (JWTRealm.java:62-64), and updates parameter types to enforce proper handling of signed claims (JWTRealm.java:17).",0.95,./github/other_context/CVE-2021-29451
9,CVE-2023-45132,CWE-693,c_cpp,"NAXSI is an open-source maintenance web application firewall (WAF) for NGINX. An issue present starting in version 1.3 and prior to version 1.6 allows someone to bypass the WAF when a malicious `X-Forwarded-For` IP matches `IgnoreIP` `IgnoreCIDR` rules. This old code was arranged to allow older NGINX versions to also support `IgnoreIP` `IgnoreCIDR` when multiple reverse proxies were present. The issue is patched in version 1.6. As a workaround, do not set any `IgnoreIP` `IgnoreCIDR` for older versions.",https://github.com/wargio/naxsi/commit/1b712526ed3314dd6be7e8b0259eabda63c19537,Remove X-Forwarded-For header special processing (#103)\n\n* Change tests IgnoreCIDR/IgnoreIP with/without real_ip support\r\n* Remove X-Forwarding-For header special processing\r\n* Change tests IgnoreCIDR/IgnoreIP set_real_ip_from 127.0.0.1 for IPv6 (for IPv4 machine only)\r\n* Change tests IgnoreCIDR/IgnoreIP set_real_ip_from 127.0.0.1 and ::1/128 for IPv6,1,"[{""func_name"": ""ngx_http_naxsi_update_current_ctx_status"", ""file_path"": ""naxsi_src/naxsi_runtime.c"", ""func_code"": ""void\nngx_http_naxsi_update_current_ctx_status(ngx_http_request_ctx_t*    ctx,\n                                         ngx_http_naxsi_loc_conf_t* cf,\n                                         ngx_http_request_t*        r)\n{\n  unsigned int              i, z;\n  unsigned int              matched;\n  ngx_http_check_rule_t*    cr;\n  ngx_http_special_score_t* sc;\n\n  NX_DEBUG(_debug_custom_score, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \""XX-custom check rules\"");\n\n  if (!ctx->ignore && (cf->ignore_ips || cf->ignore_cidrs)) {\n#if (NGX_HTTP_X_FORWARDED_FOR)\n#if (nginx_version < 1023000)\n    ngx_table_elt_t** h;\n    if (r->headers_in.x_forwarded_for.nelts >= 1) {\n      h = r->headers_in.x_forwarded_for.elts;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \""XX- lookup ignore X-Forwarded-For: %V\"",\n               h[0]->value);\n      ngx_str_t* ip = &h[0]->value;\n      ctx->ignore   = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n    } else\n#else\n    ngx_table_elt_t* xff;\n    if (r->headers_in.x_forwarded_for != NULL) {\n      xff = r->headers_in.x_forwarded_for;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \""XX- lookup ignore X-Forwarded-For: %V\"",\n               xff->value);\n      ngx_str_t* ip = &xff->value;\n      ctx->ignore   = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n    } else\n#endif\n#endif\n    {\n      ngx_str_t* ip = &r->connection->addr_text;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \""XX- lookup ignore client ip: %V\"",\n               ip);\n      ctx->ignore = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n    }\n  }\n\n  if (cf->check_rules && ctx->special_scores) {\n    NX_DEBUG(_debug_custom_score,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \""XX-we have custom check rules and CTX got special score :)\"");\n\n    cr = cf->check_rules->elts;\n    sc = ctx->special_scores->elts;\n    for (z = 0; z < ctx->special_scores->nelts; z++)\n      for (i = 0; i < cf->check_rules->nelts; i++) {\n        NX_DEBUG(_debug_custom_score,\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \""XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\"",\n                 cr[i].sc_tag.data,\n                 cr[i].sc_score,\n                 sc[z].sc_tag->data,\n                 sc[z].sc_score,\n                 cr[i].cmp);\n\n        if (!ngx_strcmp(sc[z].sc_tag->data, cr[i].sc_tag.data)) {\n          NX_DEBUG(_debug_custom_score,\n                   NGX_LOG_DEBUG_HTTP,\n                   r->connection->log,\n                   0,\n                   \""XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\"",\n                   cr[i].sc_tag.data,\n                   cr[i].sc_score,\n                   sc[z].sc_tag->data,\n                   sc[z].sc_score,\n                   cr[i].cmp);\n\n          matched = 0;\n          // huglier than your mom :)\n          switch (cr[i].cmp) {\n            case SUP:\n              matched = sc[z].sc_score > cr[i].sc_score ? 1 : 0;\n              break;\n            case SUP_OR_EQUAL:\n              matched = sc[z].sc_score >= cr[i].sc_score ? 1 : 0;\n              break;\n            case INF:\n              matched = sc[z].sc_score < cr[i].sc_score ? 1 : 0;\n              break;\n            case INF_OR_EQUAL:\n              matched = sc[z].sc_score <= cr[i].sc_score ? 1 : 0;\n              break;\n          }\n          if (matched) {\n            NX_DEBUG(_debug_custom_score,\n                     NGX_LOG_DEBUG_HTTP,\n                     r->connection->log,\n                     0,\n                     \""XX- custom score rule triggered ..\"");\n            if (cr[i].block) {\n              ctx->block = 1;\n            }\n            if (cr[i].drop) {\n              ctx->drop = 1;\n            }\n            if (cr[i].allow) {\n              ctx->allow = 1;\n            }\n            if (cr[i].log) {\n              ctx->log = 1;\n            }\n          }\n        }\n      }\n  }\n  if (ctx->ignore) {\n    ctx->block = 0;\n    ctx->drop  = 0;\n  }\n}"", ""target"": 0}]","[{""func_name"": ""ngx_http_naxsi_update_current_ctx_status"", ""file_path"": ""naxsi_src/naxsi_runtime.c"", ""func_code"": ""void\nngx_http_naxsi_update_current_ctx_status(ngx_http_request_ctx_t*    ctx,\n                                         ngx_http_naxsi_loc_conf_t* cf,\n                                         ngx_http_request_t*        r)\n{\n  unsigned int              i, z;\n  unsigned int              matched;\n  ngx_http_check_rule_t*    cr;\n  ngx_http_special_score_t* sc;\n\n  NX_DEBUG(_debug_custom_score, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \""XX-custom check rules\"");\n\n  if (!ctx->ignore && (cf->ignore_ips || cf->ignore_cidrs)) {\n      ngx_str_t* ip = &r->connection->addr_text;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \""XX- lookup ignore client ip: %V\"",\n               ip);\n      ctx->ignore = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n  }\n\n  if (cf->check_rules && ctx->special_scores) {\n    NX_DEBUG(_debug_custom_score,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \""XX-we have custom check rules and CTX got special score :)\"");\n\n    cr = cf->check_rules->elts;\n    sc = ctx->special_scores->elts;\n    for (z = 0; z < ctx->special_scores->nelts; z++)\n      for (i = 0; i < cf->check_rules->nelts; i++) {\n        NX_DEBUG(_debug_custom_score,\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \""XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\"",\n                 cr[i].sc_tag.data,\n                 cr[i].sc_score,\n                 sc[z].sc_tag->data,\n                 sc[z].sc_score,\n                 cr[i].cmp);\n\n        if (!ngx_strcmp(sc[z].sc_tag->data, cr[i].sc_tag.data)) {\n          NX_DEBUG(_debug_custom_score,\n                   NGX_LOG_DEBUG_HTTP,\n                   r->connection->log,\n                   0,\n                   \""XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\"",\n                   cr[i].sc_tag.data,\n                   cr[i].sc_score,\n                   sc[z].sc_tag->data,\n                   sc[z].sc_score,\n                   cr[i].cmp);\n\n          matched = 0;\n          // huglier than your mom :)\n          switch (cr[i].cmp) {\n            case SUP:\n              matched = sc[z].sc_score > cr[i].sc_score ? 1 : 0;\n              break;\n            case SUP_OR_EQUAL:\n              matched = sc[z].sc_score >= cr[i].sc_score ? 1 : 0;\n              break;\n            case INF:\n              matched = sc[z].sc_score < cr[i].sc_score ? 1 : 0;\n              break;\n            case INF_OR_EQUAL:\n              matched = sc[z].sc_score <= cr[i].sc_score ? 1 : 0;\n              break;\n          }\n          if (matched) {\n            NX_DEBUG(_debug_custom_score,\n                     NGX_LOG_DEBUG_HTTP,\n                     r->connection->log,\n                     0,\n                     \""XX- custom score rule triggered ..\"");\n            if (cr[i].block) {\n              ctx->block = 1;\n            }\n            if (cr[i].drop) {\n              ctx->drop = 1;\n            }\n            if (cr[i].allow) {\n              ctx->allow = 1;\n            }\n            if (cr[i].log) {\n              ctx->log = 1;\n            }\n          }\n        }\n      }\n  }\n  if (ctx->ignore) {\n    ctx->block = 0;\n    ctx->drop  = 0;\n  }\n}""}]","{""function"": 2, ""value"": 2}","[{""source"": ""func_info(func:naxsi_can_ignore_ip)"", ""result"": [{""code"": ""int\nnaxsi_can_ignore_ip(const ngx_str_t* ipstr, ngx_http_naxsi_loc_conf_t* cf)\n{\n  if (!cf->ignore_ips || cf->ignore_ips_ha.keys.nelts < 1) {\n    return 0;\n  }\n  char ip_str[INET6_ADDRSTRLEN + 1] = { 0 };\n  if (!naxsi_parse_ip(ipstr, NULL, ip_str)) {\n    return 0;\n  }\n\n  ngx_str_t  scratch = { .data = (unsigned char*)ip_str, .len = strlen(ip_str) };\n  ngx_uint_t k       = ngx_hash_key(scratch.data, scratch.len);\n  return ngx_hash_find(cf->ignore_ips, k, (u_char*)scratch.data, scratch.len) != NULL ? 1 : 0;\n}"", ""start_line"": 447, ""end_line"": 461, ""full_name"": ""naxsi_can_ignore_ip"", ""file_path"": ""naxsi_src/naxsi_runtime.c""}]}, {""source"": ""func_info(func:naxsi_can_ignore_cidr)"", ""result"": [{""code"": ""int\nnaxsi_can_ignore_cidr(const ngx_str_t* ipstr, ngx_http_naxsi_loc_conf_t* cf)\n{\n  if (!cf->ignore_cidrs) {\n    return 0;\n  }\n  ngx_uint_t i;\n  ip_t       ip = ip_zero;\n  if (!naxsi_parse_ip(ipstr, &ip, NULL)) {\n    return 0;\n  }\n\n  for (i = 0; i < cf->ignore_cidrs->nelts; i++) {\n    cidr_t* cidr = &((cidr_t*)cf->ignore_cidrs->elts)[i];\n    if (naxsi_is_in_subnet(cidr, &ip)) {\n      return 1;\n    }\n  }\n\n  return 0;\n}"", ""start_line"": 463, ""end_line"": 483, ""full_name"": ""naxsi_can_ignore_cidr"", ""file_path"": ""naxsi_src/naxsi_runtime.c""}]}, {""source"": ""value_info(file:naxsi_runtime.c, value:cf->ignore_ips)"", ""result"": {""value_trace"": [{""full_code"": ""cf->ignore_ips"", ""line"": 450, ""func_name"": ""naxsi_can_ignore_ip""}, {""full_code"": ""cf->ignore_ips"", ""line"": 460, ""func_name"": ""naxsi_can_ignore_ip""}, {""full_code"": ""cf->ignore_ips"", ""line"": 2914, ""func_name"": ""ngx_http_naxsi_update_current_ctx_status""}], ""struct_var"": ""cf"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""value_info(file:naxsi_runtime.c, value:cf->ignore_cidrs)"", ""result"": {""value_trace"": [{""full_code"": ""alcf->ignore_cidrs = ngx_array_create(cf->pool, 1, sizeof(cidr_t))"", ""line"": 1097, ""func_name"": ""ngx_http_naxsi_ic_loc_conf""}], ""struct_var"": ""cf"", ""struct_type"": null, ""struct_definition"": null}}]","naxsi_src/naxsi_runtime.c:2913-2951 (original code) processed X-Forwarded-For headers via NGX_HTTP_X_FORWARDED_FOR blocks. If present, XFF IPs were parsed and checked against `cf->ignore_ips` (naxsi_src/naxsi_runtime.c:450) and `cf->ignore_cidrs` (naxsi_src/naxsi_runtime.c:463) using:\n1. `naxsi_can_ignore_ip()` (naxsi_src/naxsi_runtime.c:447-461): Checked if XFF IP exists in `ignore_ips` hash\n2. `naxsi_can_ignore_cidr()` (naxsi_src/naxsi_runtime.c:463-483): Checked if XFF IP falls within `ignore_cidrs` CIDR ranges\nThis allowed spoofed XFF headers to bypass WAF rules when matching ignore criteria.",0.95,./github/other_context/CVE-2023-45132
10,CVE-2017-6519,CWE-346,c_cpp,"avahi-daemon in Avahi through 0.6.32 and 0.7 inadvertently responds to IPv6 unicast queries with source addresses that are not on-link, which allows remote attackers to cause a denial of service (traffic amplification) and may cause information leakage by obtaining potentially sensitive  information from the responding device via port-5353 UDP packets.  NOTE: this may overlap CVE-2015-2809.",https://github.com/avahi/avahi/commit/e111def44a7df4624a4aa3f85fe98054bffb6b4f,"Drop legacy unicast queries from address not on local link\n\nWhen handling legacy unicast queries, ensure that the source IP is\ninside a subnet on the local link, otherwise drop the packet.\n\nFixes #145\nFixes #203\nCVE-2017-6519\nCVE-2018-100084",1,"[{""func_name"": ""dispatch_packet"", ""file_path"": ""avahi-core/server.c"", ""func_code"": ""static void dispatch_packet(AvahiServer *s, AvahiDnsPacket *p, const AvahiAddress *src_address, uint16_t port, const AvahiAddress *dst_address, AvahiIfIndex iface, int ttl) {\n    AvahiInterface *i;\n    int from_local_iface = 0;\n\n    assert(s);\n    assert(p);\n    assert(src_address);\n    assert(dst_address);\n    assert(iface > 0);\n    assert(src_address->proto == dst_address->proto);\n\n    if (!(i = avahi_interface_monitor_get_interface(s->monitor, iface, src_address->proto)) ||\n        !i->announcing) {\n        avahi_log_debug(\""Received packet from invalid interface.\"");\n        return;\n    }\n\n    if (port <= 0) {\n        /* This fixes RHBZ #475394 */\n        avahi_log_debug(\""Received packet from invalid source port %u.\"", (unsigned) port);\n        return;\n    }\n\n    if (avahi_address_is_ipv4_in_ipv6(src_address))\n        /* This is an IPv4 address encapsulated in IPv6, so let's ignore it. */\n        return;\n\n    if (originates_from_local_legacy_unicast_socket(s, src_address, port))\n        /* This originates from our local reflector, so let's ignore it */\n        return;\n\n    /* We don't want to reflect local traffic, so we check if this packet is generated locally. */\n    if (s->config.enable_reflector)\n        from_local_iface = originates_from_local_iface(s, iface, src_address, port);\n\n    if (avahi_dns_packet_check_valid_multicast(p) < 0) {\n        avahi_log_debug(\""Received invalid packet.\"");\n        return;\n    }\n\n    if (avahi_dns_packet_is_query(p)) {\n        int legacy_unicast = 0;\n\n        /* For queries EDNS0 might allow ARCOUNT != 0. We ignore the\n         * AR section completely here, so far. Until the day we add\n         * EDNS0 support. */\n\n        if (port != AVAHI_MDNS_PORT) {\n            /* Legacy Unicast */\n\n            if ((avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) != 0 ||\n                 avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0)) {\n                avahi_log_debug(\""Invalid legacy unicast query packet.\"");\n                return;\n            }\n\n            legacy_unicast = 1;\n        }\n\n        if (legacy_unicast)\n            reflect_legacy_unicast_query_packet(s, p, i, src_address, port);\n\n        handle_query_packet(s, p, i, src_address, port, legacy_unicast, from_local_iface);\n\n    } else {\n        char t[AVAHI_ADDRESS_STR_MAX];\n\n        if (port != AVAHI_MDNS_PORT) {\n            avahi_log_debug(\""Received response from host %s with invalid source port %u on interface '%s.%i'\"", avahi_address_snprint(t, sizeof(t), src_address), port, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (ttl != 255 && s->config.check_response_ttl) {\n            avahi_log_debug(\""Received response from host %s with invalid TTL %u on interface '%s.%i'.\"", avahi_address_snprint(t, sizeof(t), src_address), ttl, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (!is_mdns_mcast_address(dst_address) &&\n            !avahi_interface_address_on_link(i, src_address)) {\n\n            avahi_log_debug(\""Received non-local response from host %s on interface '%s.%i'.\"", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_QDCOUNT) != 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) == 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0) {\n\n            avahi_log_debug(\""Invalid response packet from host %s.\"", avahi_address_snprint(t, sizeof(t), src_address));\n            return;\n        }\n\n        handle_response_packet(s, p, i, src_address, from_local_iface);\n    }\n}"", ""target"": 0}]","[{""func_name"": ""dispatch_packet"", ""file_path"": ""avahi-core/server.c"", ""func_code"": ""static void dispatch_packet(AvahiServer *s, AvahiDnsPacket *p, const AvahiAddress *src_address, uint16_t port, const AvahiAddress *dst_address, AvahiIfIndex iface, int ttl) {\n    AvahiInterface *i;\n    int from_local_iface = 0;\n\n    assert(s);\n    assert(p);\n    assert(src_address);\n    assert(dst_address);\n    assert(iface > 0);\n    assert(src_address->proto == dst_address->proto);\n\n    if (!(i = avahi_interface_monitor_get_interface(s->monitor, iface, src_address->proto)) ||\n        !i->announcing) {\n        avahi_log_debug(\""Received packet from invalid interface.\"");\n        return;\n    }\n\n    if (port <= 0) {\n        /* This fixes RHBZ #475394 */\n        avahi_log_debug(\""Received packet from invalid source port %u.\"", (unsigned) port);\n        return;\n    }\n\n    if (avahi_address_is_ipv4_in_ipv6(src_address))\n        /* This is an IPv4 address encapsulated in IPv6, so let's ignore it. */\n        return;\n\n    if (originates_from_local_legacy_unicast_socket(s, src_address, port))\n        /* This originates from our local reflector, so let's ignore it */\n        return;\n\n    /* We don't want to reflect local traffic, so we check if this packet is generated locally. */\n    if (s->config.enable_reflector)\n        from_local_iface = originates_from_local_iface(s, iface, src_address, port);\n\n    if (avahi_dns_packet_check_valid_multicast(p) < 0) {\n        avahi_log_debug(\""Received invalid packet.\"");\n        return;\n    }\n\n    if (avahi_dns_packet_is_query(p)) {\n        int legacy_unicast = 0;\n        char t[AVAHI_ADDRESS_STR_MAX];\n\n        /* For queries EDNS0 might allow ARCOUNT != 0. We ignore the\n         * AR section completely here, so far. Until the day we add\n         * EDNS0 support. */\n\n        if (port != AVAHI_MDNS_PORT) {\n            /* Legacy Unicast */\n\n            if ((avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) != 0 ||\n                 avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0)) {\n                avahi_log_debug(\""Invalid legacy unicast query packet.\"");\n                return;\n            }\n\n            legacy_unicast = 1;\n        }\n\n        if (!is_mdns_mcast_address(dst_address) &&\n            !avahi_interface_address_on_link(i, src_address)) {\n\n            avahi_log_debug(\""Received non-local unicast query from host %s on interface '%s.%i'.\"", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (legacy_unicast)\n            reflect_legacy_unicast_query_packet(s, p, i, src_address, port);\n\n        handle_query_packet(s, p, i, src_address, port, legacy_unicast, from_local_iface);\n\n    } else {\n        char t[AVAHI_ADDRESS_STR_MAX];\n\n        if (port != AVAHI_MDNS_PORT) {\n            avahi_log_debug(\""Received response from host %s with invalid source port %u on interface '%s.%i'\"", avahi_address_snprint(t, sizeof(t), src_address), port, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (ttl != 255 && s->config.check_response_ttl) {\n            avahi_log_debug(\""Received response from host %s with invalid TTL %u on interface '%s.%i'.\"", avahi_address_snprint(t, sizeof(t), src_address), ttl, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (!is_mdns_mcast_address(dst_address) &&\n            !avahi_interface_address_on_link(i, src_address)) {\n\n            avahi_log_debug(\""Received non-local response from host %s on interface '%s.%i'.\"", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_QDCOUNT) != 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) == 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0) {\n\n            avahi_log_debug(\""Invalid response packet from host %s.\"", avahi_address_snprint(t, sizeof(t), src_address));\n            return;\n        }\n\n        handle_response_packet(s, p, i, src_address, from_local_iface);\n    }\n}""}]","{""function"": 2}","[{""source"": ""func_info(func:is_mdns_mcast_address)"", ""result"": [{""code"": ""static int is_mdns_mcast_address(const AvahiAddress *a) {\n    AvahiAddress b;\n    assert(a);\n\n    avahi_address_parse(a->proto == AVAHI_PROTO_INET ? AVAHI_IPV4_MCAST_GROUP : AVAHI_IPV6_MCAST_GROUP, a->proto, &b);\n    return avahi_address_cmp(a, &b) == 0;\n}"", ""start_line"": 871, ""end_line"": 877, ""full_name"": ""is_mdns_mcast_address"", ""file_path"": ""avahi-core/server.c""}]}, {""source"": ""func_info(func:avahi_interface_address_on_link)"", ""result"": [{""code"": ""int avahi_interface_address_on_link(AvahiInterface *i, const AvahiAddress *a) {\n    AvahiInterfaceAddress *ia;\n\n    assert(i);\n    assert(a);\n\n    if (a->proto != i->protocol)\n        return 0;\n\n    for (ia = i->addresses; ia; ia = ia->address_next) {\n\n        if (a->proto == AVAHI_PROTO_INET) {\n            uint32_t m;\n\n            m = ~(((uint32_t) -1) >> ia->prefix_len);\n\n            if ((ntohl(a->data.ipv4.address) & m) == (ntohl(ia->address.data.ipv4.address) & m))\n                return 1;\n        } else {\n            unsigned j;\n            unsigned char pl;\n            assert(a->proto == AVAHI_PROTO_INET6);\n\n            pl = ia->prefix_len;\n\n            for (j = 0; j < 16; j++) {\n                uint8_t m;\n\n                if (pl == 0)\n                    return 1;\n\n                if (pl >= 8) {\n                    m = 0xFF;\n                    pl -= 8;\n                } else {\n                    m = ~(0xFF >> pl);\n                    pl = 0;\n                }\n\n                if ((a->data.ipv6.address[j] & m) != (ia->address.data.ipv6.address[j] & m))\n                    break;\n            }\n        }\n    }\n\n    return 0;\n}\n"", ""start_line"": 777, ""end_line"": 823, ""full_name"": ""avahi_interface_address_on_link"", ""file_path"": ""avahi-core/iface.c""}]}]","Legacy unicast queries were processed without verifying the source IP's on-link status in `server.c:dispatch_packet()` (CVE-2017-6519/CVE-2018-100084). The patch adds checks at `server.c:947-953` to drop packets where `dst_address` is not a multicast address (`is_mdns_mcast_address()` in `server.c:871-877`) and `src_address` is not on the local interface's subnet (`avahi_interface_address_on_link()` in `iface.c:777-823`). The vulnerability arose because packets with remote source IPs were processed, enabling traffic amplification and information leakage.",0.95,./github/other_context/CVE-2017-6519
11,CVE-2020-27670,CWE-345,c_cpp,"An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",https://github.com/xen-project/xen/commit/0514a3a25fb9ebff5d75cc8f00a9229385300858,"AMD/IOMMU: ensure suitable ordering of DTE modifications\n\nDMA and interrupt translation should be enabled only after other\napplicable DTE fields have been written. Similarly when disabling\ntranslation or when moving a device between domains, translation should\nfirst be disabled, before other entry fields get modified. Note however\nthat the ""moving"" aspect doesn't apply to the interrupt remapping side,\nas domain specifics are maintained in the IRTEs here, not the DTE. We\nalso never disable interrupt remapping once it got enabled for a device\n(the respective argument passed is always the immutable iommu_intremap).\n\nThis is part of XSA-347.\n\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: Paul Durrant <paul@xen.org>",11,"[{""func_name"": ""amd_iommu_setup_domain_device"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static void amd_iommu_setup_domain_device(\n    struct domain *domain, struct amd_iommu *iommu,\n    uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id, valid = 1;\n    u8 bus = pdev->bus;\n    const struct domain_iommu *hd = dom_iommu(domain);\n\n    BUG_ON( !hd->arch.amd.root_table ||\n            !hd->arch.amd.paging_mode ||\n            !iommu->dev_table.buffer );\n\n    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )\n        valid = 0;\n\n    /* get device-table entry */\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n\n    if ( !dte->v || !dte->tv )\n    {\n        const struct ivrs_mappings *ivrs_dev;\n\n        /* bind DTE to domain page-tables */\n        amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.amd.root_table),\n            domain->domain_id, hd->arch.amd.paging_mode, valid);\n\n        /* Undo what amd_iommu_disable_domain_device() may have done. */\n        ivrs_dev = &get_ivrs_mappings(iommu->seg)[req_id];\n        if ( dte->it_root )\n            dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_TRANSLATED;\n        dte->iv = iommu_intremap;\n        dte->ex = ivrs_dev->dte_allow_exclusion;\n        dte->sys_mgt = MASK_EXTR(ivrs_dev->device_flags, ACPI_IVHD_SYSTEM_MGMT);\n\n        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )\n            dte->i = ats_enabled;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\""Setup I/O page table: device id = %#x, type = %#x, \""\n                        \""root table = %#\""PRIx64\"", \""\n                        \""domain = %d, paging mode = %d\\n\"",\n                        req_id, pdev->type,\n                        page_to_maddr(hd->arch.amd.root_table),\n                        domain->domain_id, hd->arch.amd.paging_mode);\n    }\n\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )\n    {\n        if ( devfn == pdev->devfn )\n            enable_ats_device(pdev, &iommu->ats_devices);\n\n        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);\n    }\n}"", ""target"": 0}, {""func_name"": ""amd_iommu_set_root_page_table"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""void amd_iommu_set_root_page_table(struct amd_iommu_dte *dte,\n                                   uint64_t root_ptr, uint16_t domain_id,\n                                   uint8_t paging_mode, bool valid)\n{\n    dte->domain_id = domain_id;\n    dte->pt_root = paddr_to_pfn(root_ptr);\n    dte->iw = true;\n    dte->ir = true;\n    dte->paging_mode = paging_mode;\n    dte->tv = true;\n    dte->v = valid;\n}"", ""target"": 0}, {""func_name"": ""amd_iommu_set_intremap_table"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""void amd_iommu_set_intremap_table(\n    struct amd_iommu_dte *dte, const void *ptr,\n    const struct amd_iommu *iommu, bool valid)\n{\n    if ( ptr )\n    {\n        dte->it_root = virt_to_maddr(ptr) >> 6;\n        dte->int_tab_len = amd_iommu_intremap_table_order(ptr, iommu);\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_TRANSLATED;\n    }\n    else\n    {\n        dte->it_root = 0;\n        dte->int_tab_len = 0;\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_ABORTED;\n    }\n\n    dte->ig = false; /* unmapped interrupts result in i/o page faults */\n    dte->iv = valid;\n}"", ""target"": 0}, {""func_name"": ""clear_iommu_pte_present"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static unsigned int clear_iommu_pte_present(unsigned long l1_mfn,\n                                            unsigned long dfn)\n{\n    union amd_iommu_pte *table, *pte;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(l1_mfn));\n    pte = &table[pfn_to_pde_idx(dfn, 1)];\n\n    flush_flags = pte->pr ? IOMMU_FLUSHF_modified : 0;\n    memset(pte, 0, sizeof(*pte));\n\n    unmap_domain_page(table);\n\n    return flush_flags;\n}"", ""target"": 0}, {""func_name"": ""set_iommu_pde_present"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static unsigned int set_iommu_pde_present(union amd_iommu_pte *pte,\n                                          unsigned long next_mfn,\n                                          unsigned int next_level, bool iw,\n                                          bool ir)\n{\n    unsigned int flush_flags = IOMMU_FLUSHF_added;\n\n    if ( pte->pr &&\n         (pte->mfn != next_mfn ||\n          pte->iw != iw ||\n          pte->ir != ir ||\n          pte->next_level != next_level) )\n            flush_flags |= IOMMU_FLUSHF_modified;\n\n    /*\n     * FC bit should be enabled in PTE, this helps to solve potential\n     * issues with ATS devices\n     */\n    pte->fc = !next_level;\n\n    pte->mfn = next_mfn;\n    pte->iw = iw;\n    pte->ir = ir;\n    pte->next_level = next_level;\n    pte->pr = 1;\n\n    return flush_flags;\n}"", ""target"": 0}, {""func_name"": ""amd_dump_p2m_table_level"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static void amd_dump_p2m_table_level(struct page_info* pg, int level, \n                                     paddr_t gpa, int indent)\n{\n    paddr_t address;\n    struct amd_iommu_pte *table_vaddr;\n    int index;\n\n    if ( level < 1 )\n        return;\n\n    table_vaddr = __map_domain_page(pg);\n    if ( table_vaddr == NULL )\n    {\n        printk(\""Failed to map IOMMU domain page %\""PRIpaddr\""\\n\"", \n                page_to_maddr(pg));\n        return;\n    }\n\n    for ( index = 0; index < PTE_PER_TABLE_SIZE; index++ )\n    {\n        struct amd_iommu_pte *pde = &table_vaddr[index];\n\n        if ( !(index % 2) )\n            process_pending_softirqs();\n\n        if ( !pde->pr )\n            continue;\n\n        if ( pde->next_level && (pde->next_level != (level - 1)) )\n        {\n            printk(\""IOMMU p2m table error. next_level = %d, expected %d\\n\"",\n                   pde->next_level, level - 1);\n\n            continue;\n        }\n\n        address = gpa + amd_offset_level_address(index, level);\n        if ( pde->next_level >= 1 )\n            amd_dump_p2m_table_level(\n                mfn_to_page(_mfn(pde->mfn)), pde->next_level,\n                address, indent + 1);\n        else\n            printk(\""%*sdfn: %08lx  mfn: %08lx\\n\"",\n                   indent, \""\"",\n                   (unsigned long)PFN_DOWN(address),\n                   (unsigned long)PFN_DOWN(pfn_to_paddr(pde->mfn)));\n    }\n\n    unmap_domain_page(table_vaddr);\n}"", ""target"": 0}, {""func_name"": ""iommu_pde_from_dfn"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static int iommu_pde_from_dfn(struct domain *d, unsigned long dfn,\n                              unsigned long pt_mfn[], bool map)\n{\n    struct amd_iommu_pte *pde, *next_table_vaddr;\n    unsigned long  next_table_mfn;\n    unsigned int level;\n    struct page_info *table;\n    const struct domain_iommu *hd = dom_iommu(d);\n\n    table = hd->arch.amd.root_table;\n    level = hd->arch.amd.paging_mode;\n\n    BUG_ON( table == NULL || level < 1 || level > 6 );\n\n    /*\n     * A frame number past what the current page tables can represent can't\n     * possibly have a mapping.\n     */\n    if ( dfn >> (PTE_PER_TABLE_SHIFT * level) )\n        return 0;\n\n    next_table_mfn = mfn_x(page_to_mfn(table));\n\n    while ( level > 1 )\n    {\n        unsigned int next_level = level - 1;\n        pt_mfn[level] = next_table_mfn;\n\n        next_table_vaddr = map_domain_page(_mfn(next_table_mfn));\n        pde = &next_table_vaddr[pfn_to_pde_idx(dfn, level)];\n\n        /* Here might be a super page frame */\n        next_table_mfn = pde->mfn;\n\n        /* Split super page frame into smaller pieces.*/\n        if ( pde->pr && !pde->next_level && next_table_mfn )\n        {\n            int i;\n            unsigned long mfn, pfn;\n            unsigned int page_sz;\n\n            page_sz = 1 << (PTE_PER_TABLE_SHIFT * (next_level - 1));\n            pfn =  dfn & ~((1 << (PTE_PER_TABLE_SHIFT * next_level)) - 1);\n            mfn = next_table_mfn;\n\n            /* allocate lower level page table */\n            table = iommu_alloc_pgtable(d);\n            if ( table == NULL )\n            {\n                AMD_IOMMU_DEBUG(\""Cannot allocate I/O page table\\n\"");\n                unmap_domain_page(next_table_vaddr);\n                return 1;\n            }\n\n            next_table_mfn = mfn_x(page_to_mfn(table));\n            set_iommu_pde_present(pde, next_table_mfn, next_level, true,\n                                  true);\n\n            for ( i = 0; i < PTE_PER_TABLE_SIZE; i++ )\n            {\n                set_iommu_pte_present(next_table_mfn, pfn, mfn, next_level,\n                                      true, true);\n                mfn += page_sz;\n                pfn += page_sz;\n             }\n\n            amd_iommu_flush_all_pages(d);\n        }\n\n        /* Install lower level page table for non-present entries */\n        else if ( !pde->pr )\n        {\n            if ( !map )\n                return 0;\n\n            if ( next_table_mfn == 0 )\n            {\n                table = iommu_alloc_pgtable(d);\n                if ( table == NULL )\n                {\n                    AMD_IOMMU_DEBUG(\""Cannot allocate I/O page table\\n\"");\n                    unmap_domain_page(next_table_vaddr);\n                    return 1;\n                }\n                next_table_mfn = mfn_x(page_to_mfn(table));\n                set_iommu_pde_present(pde, next_table_mfn, next_level, true,\n                                      true);\n            }\n            else /* should never reach here */\n            {\n                unmap_domain_page(next_table_vaddr);\n                return 1;\n            }\n        }\n\n        unmap_domain_page(next_table_vaddr);\n        level--;\n    }\n\n    /* mfn of level 1 page table */\n    pt_mfn[level] = next_table_mfn;\n    return 0;\n}"", ""target"": 1}, {""func_name"": ""amd_iommu_quarantine_init"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""int __init amd_iommu_quarantine_init(struct domain *d)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    unsigned long end_gfn =\n        1ul << (DEFAULT_DOMAIN_ADDRESS_WIDTH - PAGE_SHIFT);\n    unsigned int level = amd_iommu_get_paging_mode(end_gfn);\n    struct amd_iommu_pte *table;\n\n    if ( hd->arch.amd.root_table )\n    {\n        ASSERT_UNREACHABLE();\n        return 0;\n    }\n\n    spin_lock(&hd->arch.mapping_lock);\n\n    hd->arch.amd.root_table = iommu_alloc_pgtable(d);\n    if ( !hd->arch.amd.root_table )\n        goto out;\n\n    table = __map_domain_page(hd->arch.amd.root_table);\n    while ( level )\n    {\n        struct page_info *pg;\n        unsigned int i;\n\n        /*\n         * The pgtable allocator is fine for the leaf page, as well as\n         * page table pages, and the resulting allocations are always\n         * zeroed.\n         */\n        pg = iommu_alloc_pgtable(d);\n        if ( !pg )\n            break;\n\n        for ( i = 0; i < PTE_PER_TABLE_SIZE; i++ )\n        {\n            struct amd_iommu_pte *pde = &table[i];\n\n            /*\n             * PDEs are essentially a subset of PTEs, so this function\n             * is fine to use even at the leaf.\n             */\n            set_iommu_pde_present(pde, mfn_x(page_to_mfn(pg)), level - 1,\n                                  false, true);\n        }\n\n        unmap_domain_page(table);\n        table = __map_domain_page(pg);\n        level--;\n    }\n    unmap_domain_page(table);\n\n out:\n    spin_unlock(&hd->arch.mapping_lock);\n\n    amd_iommu_flush_all_pages(d);\n\n    /* Pages leaked in failure case */\n    return level ? -ENOMEM : 0;\n}"", ""target"": 2}, {""func_name"": ""set_iommu_pte_present"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static unsigned int set_iommu_pte_present(unsigned long pt_mfn,\n                                          unsigned long dfn,\n                                          unsigned long next_mfn,\n                                          int pde_level,\n                                          bool iw, bool ir)\n{\n    struct amd_iommu_pte *table, *pde;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(pt_mfn));\n    pde = &table[pfn_to_pde_idx(dfn, pde_level)];\n\n    flush_flags = set_iommu_pde_present(pde, next_mfn, 0, iw, ir);\n    unmap_domain_page(table);\n\n    return flush_flags;\n}"", ""target"": 2}, {""func_name"": ""clear_iommu_pte_present"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static unsigned int clear_iommu_pte_present(unsigned long l1_mfn,\n                                            unsigned long dfn)\n{\n    struct amd_iommu_pte *table, *pte;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(l1_mfn));\n    pte = &table[pfn_to_pde_idx(dfn, 1)];\n\n    flush_flags = pte->pr ? IOMMU_FLUSHF_modified : 0;\n    memset(pte, 0, sizeof(*pte));\n\n    unmap_domain_page(table);\n\n    return flush_flags;\n}"", ""target"": 0}, {""func_name"": ""set_iommu_pde_present"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static unsigned int set_iommu_pde_present(struct amd_iommu_pte *pte,\n                                          unsigned long next_mfn,\n                                          unsigned int next_level, bool iw,\n                                          bool ir)\n{\n    unsigned int flush_flags = IOMMU_FLUSHF_added;\n\n    if ( pte->pr &&\n         (pte->mfn != next_mfn ||\n          pte->iw != iw ||\n          pte->ir != ir ||\n          pte->next_level != next_level) )\n            flush_flags |= IOMMU_FLUSHF_modified;\n\n    /*\n     * FC bit should be enabled in PTE, this helps to solve potential\n     * issues with ATS devices\n     */\n    pte->fc = !next_level;\n\n    pte->mfn = next_mfn;\n    pte->iw = iw;\n    pte->ir = ir;\n    pte->next_level = next_level;\n    pte->pr = 1;\n\n    return flush_flags;\n}"", ""target"": 0}]","[{""func_name"": ""amd_iommu_setup_domain_device"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static void amd_iommu_setup_domain_device(\n    struct domain *domain, struct amd_iommu *iommu,\n    uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id, valid = 1;\n    u8 bus = pdev->bus;\n    const struct domain_iommu *hd = dom_iommu(domain);\n\n    BUG_ON( !hd->arch.amd.root_table ||\n            !hd->arch.amd.paging_mode ||\n            !iommu->dev_table.buffer );\n\n    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )\n        valid = 0;\n\n    /* get device-table entry */\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n\n    if ( !dte->v || !dte->tv )\n    {\n        const struct ivrs_mappings *ivrs_dev;\n\n        /* bind DTE to domain page-tables */\n        amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.amd.root_table),\n            domain->domain_id, hd->arch.amd.paging_mode, valid);\n\n        /* Undo what amd_iommu_disable_domain_device() may have done. */\n        ivrs_dev = &get_ivrs_mappings(iommu->seg)[req_id];\n        if ( dte->it_root )\n        {\n            dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_TRANSLATED;\n            smp_wmb();\n        }\n        dte->iv = iommu_intremap;\n        dte->ex = ivrs_dev->dte_allow_exclusion;\n        dte->sys_mgt = MASK_EXTR(ivrs_dev->device_flags, ACPI_IVHD_SYSTEM_MGMT);\n\n        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )\n            dte->i = ats_enabled;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\""Setup I/O page table: device id = %#x, type = %#x, \""\n                        \""root table = %#\""PRIx64\"", \""\n                        \""domain = %d, paging mode = %d\\n\"",\n                        req_id, pdev->type,\n                        page_to_maddr(hd->arch.amd.root_table),\n                        domain->domain_id, hd->arch.amd.paging_mode);\n    }\n\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )\n    {\n        if ( devfn == pdev->devfn )\n            enable_ats_device(pdev, &iommu->ats_devices);\n\n        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);\n    }\n}""}, {""func_name"": ""amd_iommu_set_root_page_table"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""void amd_iommu_set_root_page_table(struct amd_iommu_dte *dte,\n                                   uint64_t root_ptr, uint16_t domain_id,\n                                   uint8_t paging_mode, bool valid)\n{\n    if ( valid || dte->v )\n    {\n        dte->tv = false;\n        dte->v = true;\n        smp_wmb();\n    }\n    dte->domain_id = domain_id;\n    dte->pt_root = paddr_to_pfn(root_ptr);\n    dte->iw = true;\n    dte->ir = true;\n    dte->paging_mode = paging_mode;\n    smp_wmb();\n    dte->tv = true;\n    dte->v = valid;\n}""}, {""func_name"": ""amd_iommu_set_intremap_table"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""void amd_iommu_set_intremap_table(\n    struct amd_iommu_dte *dte, const void *ptr,\n    const struct amd_iommu *iommu, bool valid)\n{\n    if ( ptr )\n    {\n        dte->it_root = virt_to_maddr(ptr) >> 6;\n        dte->int_tab_len = amd_iommu_intremap_table_order(ptr, iommu);\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_TRANSLATED;\n    }\n    else\n    {\n        dte->it_root = 0;\n        dte->int_tab_len = 0;\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_ABORTED;\n    }\n\n    dte->ig = false; /* unmapped interrupts result in i/o page faults */\n    smp_wmb();\n    dte->iv = valid;\n}""}, {""func_name"": ""clear_iommu_pte_present"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static unsigned int clear_iommu_pte_present(unsigned long l1_mfn,\n                                            unsigned long dfn)\n{\n    union amd_iommu_pte *table, *pte;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(l1_mfn));\n    pte = &table[pfn_to_pde_idx(dfn, 1)];\n\n    flush_flags = pte->pr ? IOMMU_FLUSHF_modified : 0;\n    write_atomic(&pte->raw, 0);\n\n    unmap_domain_page(table);\n\n    return flush_flags;\n}""}, {""func_name"": ""set_iommu_pde_present"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static unsigned int set_iommu_pde_present(union amd_iommu_pte *pte,\n                                          unsigned long next_mfn,\n                                          unsigned int next_level, bool iw,\n                                          bool ir)\n{\n    union amd_iommu_pte new = {}, old;\n    unsigned int flush_flags = IOMMU_FLUSHF_added;\n\n    /*\n     * FC bit should be enabled in PTE, this helps to solve potential\n     * issues with ATS devices\n     */\n    new.fc = !next_level;\n\n    new.mfn = next_mfn;\n    new.iw = iw;\n    new.ir = ir;\n    new.next_level = next_level;\n    new.pr = true;\n\n    old.raw = read_atomic(&pte->raw);\n    old.ign0 = 0;\n    old.ign1 = 0;\n    old.ign2 = 0;\n\n    if ( old.pr && old.raw != new.raw )\n        flush_flags |= IOMMU_FLUSHF_modified;\n\n    write_atomic(&pte->raw, new.raw);\n\n    return flush_flags;\n}""}, {""func_name"": ""amd_dump_p2m_table_level"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c"", ""func_code"": ""static void amd_dump_p2m_table_level(struct page_info* pg, int level, \n                                     paddr_t gpa, int indent)\n{\n    paddr_t address;\n    const union amd_iommu_pte *table_vaddr;\n    int index;\n\n    if ( level < 1 )\n        return;\n\n    table_vaddr = __map_domain_page(pg);\n    if ( table_vaddr == NULL )\n    {\n        printk(\""Failed to map IOMMU domain page %\""PRIpaddr\""\\n\"", \n                page_to_maddr(pg));\n        return;\n    }\n\n    for ( index = 0; index < PTE_PER_TABLE_SIZE; index++ )\n    {\n        const union amd_iommu_pte *pde = &table_vaddr[index];\n\n        if ( !(index % 2) )\n            process_pending_softirqs();\n\n        if ( !pde->pr )\n            continue;\n\n        if ( pde->next_level && (pde->next_level != (level - 1)) )\n        {\n            printk(\""IOMMU p2m table error. next_level = %d, expected %d\\n\"",\n                   pde->next_level, level - 1);\n\n            continue;\n        }\n\n        address = gpa + amd_offset_level_address(index, level);\n        if ( pde->next_level >= 1 )\n            amd_dump_p2m_table_level(\n                mfn_to_page(_mfn(pde->mfn)), pde->next_level,\n                address, indent + 1);\n        else\n            printk(\""%*sdfn: %08lx  mfn: %08lx\\n\"",\n                   indent, \""\"",\n                   (unsigned long)PFN_DOWN(address),\n                   (unsigned long)PFN_DOWN(pfn_to_paddr(pde->mfn)));\n    }\n\n    unmap_domain_page(table_vaddr);\n}""}, {""func_name"": ""iommu_pde_from_dfn"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static int iommu_pde_from_dfn(struct domain *d, unsigned long dfn,\n                              unsigned long pt_mfn[], bool map)\n{\n    union amd_iommu_pte *pde, *next_table_vaddr;\n    unsigned long  next_table_mfn;\n    unsigned int level;\n    struct page_info *table;\n    const struct domain_iommu *hd = dom_iommu(d);\n\n    table = hd->arch.amd.root_table;\n    level = hd->arch.amd.paging_mode;\n\n    BUG_ON( table == NULL || level < 1 || level > 6 );\n\n    /*\n     * A frame number past what the current page tables can represent can't\n     * possibly have a mapping.\n     */\n    if ( dfn >> (PTE_PER_TABLE_SHIFT * level) )\n        return 0;\n\n    next_table_mfn = mfn_x(page_to_mfn(table));\n\n    while ( level > 1 )\n    {\n        unsigned int next_level = level - 1;\n        pt_mfn[level] = next_table_mfn;\n\n        next_table_vaddr = map_domain_page(_mfn(next_table_mfn));\n        pde = &next_table_vaddr[pfn_to_pde_idx(dfn, level)];\n\n        /* Here might be a super page frame */\n        next_table_mfn = pde->mfn;\n\n        /* Split super page frame into smaller pieces.*/\n        if ( pde->pr && !pde->next_level && next_table_mfn )\n        {\n            int i;\n            unsigned long mfn, pfn;\n            unsigned int page_sz;\n\n            page_sz = 1 << (PTE_PER_TABLE_SHIFT * (next_level - 1));\n            pfn =  dfn & ~((1 << (PTE_PER_TABLE_SHIFT * next_level)) - 1);\n            mfn = next_table_mfn;\n\n            /* allocate lower level page table */\n            table = iommu_alloc_pgtable(d);\n            if ( table == NULL )\n            {\n                AMD_IOMMU_DEBUG(\""Cannot allocate I/O page table\\n\"");\n                unmap_domain_page(next_table_vaddr);\n                return 1;\n            }\n\n            next_table_mfn = mfn_x(page_to_mfn(table));\n            set_iommu_pde_present(pde, next_table_mfn, next_level, true,\n                                  true);\n\n            for ( i = 0; i < PTE_PER_TABLE_SIZE; i++ )\n            {\n                set_iommu_pte_present(next_table_mfn, pfn, mfn, next_level,\n                                      true, true);\n                mfn += page_sz;\n                pfn += page_sz;\n             }\n\n            amd_iommu_flush_all_pages(d);\n        }\n\n        /* Install lower level page table for non-present entries */\n        else if ( !pde->pr )\n        {\n            if ( !map )\n                return 0;\n\n            if ( next_table_mfn == 0 )\n            {\n                table = iommu_alloc_pgtable(d);\n                if ( table == NULL )\n                {\n                    AMD_IOMMU_DEBUG(\""Cannot allocate I/O page table\\n\"");\n                    unmap_domain_page(next_table_vaddr);\n                    return 1;\n                }\n                next_table_mfn = mfn_x(page_to_mfn(table));\n                set_iommu_pde_present(pde, next_table_mfn, next_level, true,\n                                      true);\n            }\n            else /* should never reach here */\n            {\n                unmap_domain_page(next_table_vaddr);\n                return 1;\n            }\n        }\n\n        unmap_domain_page(next_table_vaddr);\n        level--;\n    }\n\n    /* mfn of level 1 page table */\n    pt_mfn[level] = next_table_mfn;\n    return 0;\n}""}, {""func_name"": ""amd_iommu_quarantine_init"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""int __init amd_iommu_quarantine_init(struct domain *d)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    unsigned long end_gfn =\n        1ul << (DEFAULT_DOMAIN_ADDRESS_WIDTH - PAGE_SHIFT);\n    unsigned int level = amd_iommu_get_paging_mode(end_gfn);\n    union amd_iommu_pte *table;\n\n    if ( hd->arch.amd.root_table )\n    {\n        ASSERT_UNREACHABLE();\n        return 0;\n    }\n\n    spin_lock(&hd->arch.mapping_lock);\n\n    hd->arch.amd.root_table = iommu_alloc_pgtable(d);\n    if ( !hd->arch.amd.root_table )\n        goto out;\n\n    table = __map_domain_page(hd->arch.amd.root_table);\n    while ( level )\n    {\n        struct page_info *pg;\n        unsigned int i;\n\n        /*\n         * The pgtable allocator is fine for the leaf page, as well as\n         * page table pages, and the resulting allocations are always\n         * zeroed.\n         */\n        pg = iommu_alloc_pgtable(d);\n        if ( !pg )\n            break;\n\n        for ( i = 0; i < PTE_PER_TABLE_SIZE; i++ )\n        {\n            union amd_iommu_pte *pde = &table[i];\n\n            /*\n             * PDEs are essentially a subset of PTEs, so this function\n             * is fine to use even at the leaf.\n             */\n            set_iommu_pde_present(pde, mfn_x(page_to_mfn(pg)), level - 1,\n                                  false, true);\n        }\n\n        unmap_domain_page(table);\n        table = __map_domain_page(pg);\n        level--;\n    }\n    unmap_domain_page(table);\n\n out:\n    spin_unlock(&hd->arch.mapping_lock);\n\n    amd_iommu_flush_all_pages(d);\n\n    /* Pages leaked in failure case */\n    return level ? -ENOMEM : 0;\n}""}, {""func_name"": ""set_iommu_pte_present"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static unsigned int set_iommu_pte_present(unsigned long pt_mfn,\n                                          unsigned long dfn,\n                                          unsigned long next_mfn,\n                                          int pde_level,\n                                          bool iw, bool ir)\n{\n    union amd_iommu_pte *table, *pde;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(pt_mfn));\n    pde = &table[pfn_to_pde_idx(dfn, pde_level)];\n\n    flush_flags = set_iommu_pde_present(pde, next_mfn, 0, iw, ir);\n    unmap_domain_page(table);\n\n    return flush_flags;\n}""}, {""func_name"": ""clear_iommu_pte_present"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static unsigned int clear_iommu_pte_present(unsigned long l1_mfn,\n                                            unsigned long dfn)\n{\n    union amd_iommu_pte *table, *pte;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(l1_mfn));\n    pte = &table[pfn_to_pde_idx(dfn, 1)];\n\n    flush_flags = pte->pr ? IOMMU_FLUSHF_modified : 0;\n    memset(pte, 0, sizeof(*pte));\n\n    unmap_domain_page(table);\n\n    return flush_flags;\n}""}, {""func_name"": ""set_iommu_pde_present"", ""file_path"": ""xen/drivers/passthrough/amd/iommu_map.c"", ""func_code"": ""static unsigned int set_iommu_pde_present(union amd_iommu_pte *pte,\n                                          unsigned long next_mfn,\n                                          unsigned int next_level, bool iw,\n                                          bool ir)\n{\n    unsigned int flush_flags = IOMMU_FLUSHF_added;\n\n    if ( pte->pr &&\n         (pte->mfn != next_mfn ||\n          pte->iw != iw ||\n          pte->ir != ir ||\n          pte->next_level != next_level) )\n            flush_flags |= IOMMU_FLUSHF_modified;\n\n    /*\n     * FC bit should be enabled in PTE, this helps to solve potential\n     * issues with ATS devices\n     */\n    pte->fc = !next_level;\n\n    pte->mfn = next_mfn;\n    pte->iw = iw;\n    pte->ir = ir;\n    pte->next_level = next_level;\n    pte->pr = 1;\n\n    return flush_flags;\n}""}]","{""caller"": 5, ""value"": 1, ""function"": 1}","[{""source"": ""caller_info(file:pci_amd_iommu.c, func:amd_iommu_setup_domain_device)"", ""result"": [{""call_line"": 353, ""call_code"": ""amd_iommu_setup_domain_device(target, iommu, devfn, pdev)"", ""caller_code"": ""static int reassign_device(struct domain *source, struct domain *target,\n                           u8 devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu *iommu;\n    int bdf, rc;\n\n    bdf = PCI_BDF2(pdev->bus, pdev->devfn);\n    iommu = find_iommu_for_device(pdev->seg, bdf);\n    if ( !iommu )\n    {\n        AMD_IOMMU_DEBUG(\""Fail to find iommu.\""\n                        \"" %04x:%02x:%x02.%x cannot be assigned to dom%d\\n\"",\n                        pdev->seg, pdev->bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                        target->domain_id);\n        return -ENODEV;\n    }\n\n    amd_iommu_disable_domain_device(source, iommu, devfn, pdev);\n\n    if ( devfn == pdev->devfn )\n    {\n        list_move(&pdev->domain_list, &target->pdev_list);\n        pdev->domain = target;\n    }\n\n    rc = allocate_domain_resources(target);\n    if ( rc )\n        return rc;\n\n    amd_iommu_setup_domain_device(target, iommu, devfn, pdev);\n    AMD_IOMMU_DEBUG(\""Re-assign %pp from dom%d to dom%d\\n\"",\n                    &pdev->sbdf, source->domain_id, target->domain_id);\n\n    return 0;\n}\n"", ""caller_start"": 324, ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c""}, {""call_line"": 451, ""call_code"": ""amd_iommu_setup_domain_device(pdev->domain, iommu, devfn, pdev)"", ""caller_code"": ""static int amd_iommu_add_device(u8 devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu *iommu;\n    u16 bdf;\n    struct ivrs_mappings *ivrs_mappings;\n\n    if ( !pdev->domain )\n        return -EINVAL;\n\n    bdf = PCI_BDF2(pdev->bus, pdev->devfn);\n\n    for_each_amd_iommu(iommu)\n        if ( pdev->seg == iommu->seg && bdf == iommu->bdf )\n            return is_hardware_domain(pdev->domain) ? 0 : -ENODEV;\n\n    iommu = find_iommu_for_device(pdev->seg, bdf);\n    if ( unlikely(!iommu) )\n    {\n        /* Filter bridge devices. */\n        if ( pdev->type == DEV_TYPE_PCI_HOST_BRIDGE &&\n             is_hardware_domain(pdev->domain) )\n        {\n            AMD_IOMMU_DEBUG(\""Skipping host bridge %pp\\n\"", &pdev->sbdf);\n            return 0;\n        }\n\n        AMD_IOMMU_DEBUG(\""No iommu for %pp; cannot be handed to d%d\\n\"",\n                        &pdev->sbdf, pdev->domain->domain_id);\n        return -ENODEV;\n    }\n\n    ivrs_mappings = get_ivrs_mappings(pdev->seg);\n    bdf = PCI_BDF2(pdev->bus, devfn);\n    if ( !ivrs_mappings ||\n         !ivrs_mappings[ivrs_mappings[bdf].dte_requestor_id].valid )\n        return -EPERM;\n\n    if ( iommu_intremap &&\n         ivrs_mappings[bdf].dte_requestor_id == bdf &&\n         !ivrs_mappings[bdf].intremap_table )\n    {\n        unsigned long flags;\n\n        if ( pdev->msix || pdev->msi_maxvec )\n        {\n            ivrs_mappings[bdf].intremap_table =\n                amd_iommu_alloc_intremap_table(\n                    iommu, &ivrs_mappings[bdf].intremap_inuse,\n                    pdev->msix ? pdev->msix->nr_entries\n                               : pdev->msi_maxvec);\n            if ( !ivrs_mappings[bdf].intremap_table )\n                return -ENOMEM;\n        }\n\n        spin_lock_irqsave(&iommu->lock, flags);\n\n        amd_iommu_set_intremap_table(\n            iommu->dev_table.buffer + (bdf * IOMMU_DEV_TABLE_ENTRY_SIZE),\n            ivrs_mappings[bdf].intremap_table, iommu, iommu_intremap);\n\n        amd_iommu_flush_device(iommu, bdf);\n\n        spin_unlock_irqrestore(&iommu->lock, flags);\n    }\n\n    amd_iommu_setup_domain_device(pdev->domain, iommu, devfn, pdev);\n    return 0;\n}\n"", ""caller_start"": 386, ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c""}]}, {""source"": ""caller_info(file:pci_amd_iommu.c, func:amd_iommu_set_root_page_table)"", ""result"": [{""call_line"": 113, ""call_code"": ""amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.amd.root_table),\n            domain->domain_id, hd->arch.amd.paging_mode, valid)"", ""caller_code"": ""static void amd_iommu_setup_domain_device(\n    struct domain *domain, struct amd_iommu *iommu,\n    uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id, valid = 1;\n    u8 bus = pdev->bus;\n    const struct domain_iommu *hd = dom_iommu(domain);\n\n    BUG_ON( !hd->arch.amd.root_table ||\n            !hd->arch.amd.paging_mode ||\n            !iommu->dev_table.buffer );\n\n    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )\n        valid = 0;\n\n    /* get device-table entry */\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n\n    if ( !dte->v || !dte->tv )\n    {\n        const struct ivrs_mappings *ivrs_dev;\n\n        /* bind DTE to domain page-tables */\n        amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.amd.root_table),\n            domain->domain_id, hd->arch.amd.paging_mode, valid);\n\n        /* Undo what amd_iommu_disable_domain_device() may have done. */\n        ivrs_dev = &get_ivrs_mappings(iommu->seg)[req_id];\n        if ( dte->it_root )\n            dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_TRANSLATED;\n        dte->iv = iommu_intremap;\n        dte->ex = ivrs_dev->dte_allow_exclusion;\n        dte->sys_mgt = MASK_EXTR(ivrs_dev->device_flags, ACPI_IVHD_SYSTEM_MGMT);\n\n        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )\n            dte->i = ats_enabled;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\""Setup I/O page table: device id = %#x, type = %#x, \""\n                        \""root table = %#\""PRIx64\"", \""\n                        \""domain = %d, paging mode = %d\\n\"",\n                        req_id, pdev->type,\n                        page_to_maddr(hd->arch.amd.root_table),\n                        domain->domain_id, hd->arch.amd.paging_mode);\n    }\n\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )\n    {\n        if ( devfn == pdev->devfn )\n            enable_ats_device(pdev, &iommu->ats_devices);\n\n        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);\n    }\n}\n"", ""caller_start"": 84, ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c""}]}, {""source"": ""caller_info(file:iommu_map.c, func:amd_iommu_setup_domain_device)"", ""result"": [{""call_line"": 353, ""call_code"": ""amd_iommu_setup_domain_device(target, iommu, devfn, pdev)"", ""caller_code"": ""static int reassign_device(struct domain *source, struct domain *target,\n                           u8 devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu *iommu;\n    int bdf, rc;\n\n    bdf = PCI_BDF2(pdev->bus, pdev->devfn);\n    iommu = find_iommu_for_device(pdev->seg, bdf);\n    if ( !iommu )\n    {\n        AMD_IOMMU_DEBUG(\""Fail to find iommu.\""\n                        \"" %04x:%02x:%x02.%x cannot be assigned to dom%d\\n\"",\n                        pdev->seg, pdev->bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                        target->domain_id);\n        return -ENODEV;\n    }\n\n    amd_iommu_disable_domain_device(source, iommu, devfn, pdev);\n\n    if ( devfn == pdev->devfn )\n    {\n        list_move(&pdev->domain_list, &target->pdev_list);\n        pdev->domain = target;\n    }\n\n    rc = allocate_domain_resources(target);\n    if ( rc )\n        return rc;\n\n    amd_iommu_setup_domain_device(target, iommu, devfn, pdev);\n    AMD_IOMMU_DEBUG(\""Re-assign %pp from dom%d to dom%d\\n\"",\n                    &pdev->sbdf, source->domain_id, target->domain_id);\n\n    return 0;\n}\n"", ""caller_start"": 324, ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c""}, {""call_line"": 451, ""call_code"": ""amd_iommu_setup_domain_device(pdev->domain, iommu, devfn, pdev)"", ""caller_code"": ""static int amd_iommu_add_device(u8 devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu *iommu;\n    u16 bdf;\n    struct ivrs_mappings *ivrs_mappings;\n\n    if ( !pdev->domain )\n        return -EINVAL;\n\n    bdf = PCI_BDF2(pdev->bus, pdev->devfn);\n\n    for_each_amd_iommu(iommu)\n        if ( pdev->seg == iommu->seg && bdf == iommu->bdf )\n            return is_hardware_domain(pdev->domain) ? 0 : -ENODEV;\n\n    iommu = find_iommu_for_device(pdev->seg, bdf);\n    if ( unlikely(!iommu) )\n    {\n        /* Filter bridge devices. */\n        if ( pdev->type == DEV_TYPE_PCI_HOST_BRIDGE &&\n             is_hardware_domain(pdev->domain) )\n        {\n            AMD_IOMMU_DEBUG(\""Skipping host bridge %pp\\n\"", &pdev->sbdf);\n            return 0;\n        }\n\n        AMD_IOMMU_DEBUG(\""No iommu for %pp; cannot be handed to d%d\\n\"",\n                        &pdev->sbdf, pdev->domain->domain_id);\n        return -ENODEV;\n    }\n\n    ivrs_mappings = get_ivrs_mappings(pdev->seg);\n    bdf = PCI_BDF2(pdev->bus, devfn);\n    if ( !ivrs_mappings ||\n         !ivrs_mappings[ivrs_mappings[bdf].dte_requestor_id].valid )\n        return -EPERM;\n\n    if ( iommu_intremap &&\n         ivrs_mappings[bdf].dte_requestor_id == bdf &&\n         !ivrs_mappings[bdf].intremap_table )\n    {\n        unsigned long flags;\n\n        if ( pdev->msix || pdev->msi_maxvec )\n        {\n            ivrs_mappings[bdf].intremap_table =\n                amd_iommu_alloc_intremap_table(\n                    iommu, &ivrs_mappings[bdf].intremap_inuse,\n                    pdev->msix ? pdev->msix->nr_entries\n                               : pdev->msi_maxvec);\n            if ( !ivrs_mappings[bdf].intremap_table )\n                return -ENOMEM;\n        }\n\n        spin_lock_irqsave(&iommu->lock, flags);\n\n        amd_iommu_set_intremap_table(\n            iommu->dev_table.buffer + (bdf * IOMMU_DEV_TABLE_ENTRY_SIZE),\n            ivrs_mappings[bdf].intremap_table, iommu, iommu_intremap);\n\n        amd_iommu_flush_device(iommu, bdf);\n\n        spin_unlock_irqrestore(&iommu->lock, flags);\n    }\n\n    amd_iommu_setup_domain_device(pdev->domain, iommu, devfn, pdev);\n    return 0;\n}\n"", ""caller_start"": 386, ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c""}]}, {""source"": ""caller_info(file:iommu_map.c, func:amd_iommu_set_root_page_table)"", ""result"": [{""call_line"": 113, ""call_code"": ""amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.amd.root_table),\n            domain->domain_id, hd->arch.amd.paging_mode, valid)"", ""caller_code"": ""static void amd_iommu_setup_domain_device(\n    struct domain *domain, struct amd_iommu *iommu,\n    uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id, valid = 1;\n    u8 bus = pdev->bus;\n    const struct domain_iommu *hd = dom_iommu(domain);\n\n    BUG_ON( !hd->arch.amd.root_table ||\n            !hd->arch.amd.paging_mode ||\n            !iommu->dev_table.buffer );\n\n    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )\n        valid = 0;\n\n    /* get device-table entry */\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n\n    if ( !dte->v || !dte->tv )\n    {\n        const struct ivrs_mappings *ivrs_dev;\n\n        /* bind DTE to domain page-tables */\n        amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.amd.root_table),\n            domain->domain_id, hd->arch.amd.paging_mode, valid);\n\n        /* Undo what amd_iommu_disable_domain_device() may have done. */\n        ivrs_dev = &get_ivrs_mappings(iommu->seg)[req_id];\n        if ( dte->it_root )\n            dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_TRANSLATED;\n        dte->iv = iommu_intremap;\n        dte->ex = ivrs_dev->dte_allow_exclusion;\n        dte->sys_mgt = MASK_EXTR(ivrs_dev->device_flags, ACPI_IVHD_SYSTEM_MGMT);\n\n        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )\n            dte->i = ats_enabled;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\""Setup I/O page table: device id = %#x, type = %#x, \""\n                        \""root table = %#\""PRIx64\"", \""\n                        \""domain = %d, paging mode = %d\\n\"",\n                        req_id, pdev->type,\n                        page_to_maddr(hd->arch.amd.root_table),\n                        domain->domain_id, hd->arch.amd.paging_mode);\n    }\n\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )\n    {\n        if ( devfn == pdev->devfn )\n            enable_ats_device(pdev, &iommu->ats_devices);\n\n        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);\n    }\n}\n"", ""caller_start"": 84, ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c""}]}, {""source"": ""value_info(file:amd-iommu.h, value:amd_iommu_dte)"", ""result"": {""value_trace"": [{""full_code"": ""struct amd_iommu_dte"", ""line"": 377, ""func_name"": null}], ""struct_var"": ""amd_iommu_dte"", ""struct_type"": ""amd_iommu_dte"", ""struct_definition"": ""struct amd_iommu_dte {\n    /* 0 - 63 */\n    bool v:1;\n    bool tv:1;\n    unsigned int :5;\n    unsigned int had:2;\n    unsigned int paging_mode:3;\n    uint64_t pt_root:40;\n    bool ppr:1;\n    bool gprp:1;\n    bool giov:1;\n    bool gv:1;\n    unsigned int glx:2;\n    unsigned int gcr3_trp_14_12:3;\n    bool ir:1;\n    bool iw:1;\n    unsigned int :1;\n\n    /* 64 - 127 */\n    unsigned int domain_id:16;\n    unsigned int gcr3_trp_30_15:16;\n    bool i:1;\n    bool se:1;\n    bool sa:1;\n    unsigned int ioctl:2;\n    bool cache:1;\n    bool sd:1;\n    bool ex:1;\n    unsigned int sys_mgt:2;\n    unsigned int :1;\n    unsigned int gcr3_trp_51_31:21;\n\n    /* 128 - 191 */\n    bool iv:1;\n    unsigned int int_tab_len:4;\n    bool ig:1;\n    uint64_t it_root:46;\n    unsigned int :4;\n    bool init_pass:1;\n    bool ext_int_pass:1;\n    bool nmi_pass:1;\n    unsigned int :1;\n    unsigned int int_ctl:2;\n    bool lint0_pass:1;\n    bool lint1_pass:1;\n\n    /* 192 - 255 */\n    uint64_t :54;\n    bool attr_v:1;\n    bool mo...""}}, {""source"": ""caller_info(file:pci_amd_iommu.c, func:amd_iommu_disable_domain_device)"", ""result"": [{""call_line"": 341, ""call_code"": ""amd_iommu_disable_domain_device(source, iommu, devfn, pdev)"", ""caller_code"": ""static int reassign_device(struct domain *source, struct domain *target,\n                           u8 devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu *iommu;\n    int bdf, rc;\n\n    bdf = PCI_BDF2(pdev->bus, pdev->devfn);\n    iommu = find_iommu_for_device(pdev->seg, bdf);\n    if ( !iommu )\n    {\n        AMD_IOMMU_DEBUG(\""Fail to find iommu.\""\n                        \"" %04x:%02x:%x02.%x cannot be assigned to dom%d\\n\"",\n                        pdev->seg, pdev->bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                        target->domain_id);\n        return -ENODEV;\n    }\n\n    amd_iommu_disable_domain_device(source, iommu, devfn, pdev);\n\n    if ( devfn == pdev->devfn )\n    {\n        list_move(&pdev->domain_list, &target->pdev_list);\n        pdev->domain = target;\n    }\n\n    rc = allocate_domain_resources(target);\n    if ( rc )\n        return rc;\n\n    amd_iommu_setup_domain_device(target, iommu, devfn, pdev);\n    AMD_IOMMU_DEBUG(\""Re-assign %pp from dom%d to dom%d\\n\"",\n                    &pdev->sbdf, source->domain_id, target->domain_id);\n\n    return 0;\n}\n"", ""caller_start"": 324, ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c""}, {""call_line"": 473, ""call_code"": ""amd_iommu_disable_domain_device(pdev->domain, iommu, devfn, pdev)"", ""caller_code"": ""static int amd_iommu_remove_device(u8 devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu *iommu;\n    u16 bdf;\n    struct ivrs_mappings *ivrs_mappings;\n\n    if ( !pdev->domain )\n        return -EINVAL;\n\n    bdf = PCI_BDF2(pdev->bus, pdev->devfn);\n    iommu = find_iommu_for_device(pdev->seg, bdf);\n    if ( !iommu )\n    {\n        AMD_IOMMU_DEBUG(\""Fail to find iommu. %pp cannot be removed from %pd\\n\"",\n                        &pdev->sbdf, pdev->domain);\n        return -ENODEV;\n    }\n\n    amd_iommu_disable_domain_device(pdev->domain, iommu, devfn, pdev);\n\n    ivrs_mappings = get_ivrs_mappings(pdev->seg);\n    bdf = PCI_BDF2(pdev->bus, devfn);\n    if ( amd_iommu_perdev_intremap &&\n         ivrs_mappings[bdf].dte_requestor_id == bdf &&\n         ivrs_mappings[bdf].intremap_table )\n        amd_iommu_free_intremap_table(iommu, &ivrs_mappings[bdf], bdf);\n\n    return 0;\n}"", ""caller_start"": 455, ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c""}]}, {""source"": ""func_info(func:amd_iommu_disable_domain_device)"", ""result"": [{""code"": ""static void amd_iommu_disable_domain_device(const struct domain *domain,\n                                            struct amd_iommu *iommu,\n                                            uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id;\n    u8 bus = pdev->bus;\n\n    BUG_ON ( iommu->dev_table.buffer == NULL );\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n    if ( dte->tv || dte->v )\n    {\n        /* See the comment in amd_iommu_setup_device_table(). */\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_ABORTED;\n        smp_wmb();\n        dte->iv = true;\n        dte->tv = false;\n        dte->gv = false;\n        dte->i = false;\n        dte->ex = false;\n        dte->sa = false;\n        dte->se = false;\n        dte->sd = false;\n        dte->sys_mgt = IOMMU_DEV_TABLE_SYS_MGT_DMA_ABORTED;\n        dte->ioctl = IOMMU_DEV_TABLE_IO_CONTROL_ABORTED;\n        smp_wmb();\n        dte->v = true;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\""Disable: device id = %#x, \""\n                        \""domain = %d, paging mode = %d\\n\"",\n                        req_id,  domain->domain_id,\n                        dom_iommu(domain)->arch.amd.paging_mode);\n    }\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( devfn == pdev->devfn &&\n         pci_ats_device(iommu->seg, bus, devfn) &&\n         pci_ats_enabled(iommu->seg, bus, devfn) )\n        disable_ats_device(pdev);\n}\n"", ""start_line"": 274, ""end_line"": 322, ""full_name"": ""amd_iommu_disable_domain_device"", ""file_path"": ""xen/drivers/passthrough/amd/pci_amd_iommu.c""}]}]","Half-updated AMD IOMMU DTE entries occurred due to missing memory barriers and non-atomic writes in DTE/PT modifications. Evidence includes:\n1. `amd_iommu_setup_domain_device` (xen/drivers/passthrough/amd/pci_amd_iommu.c:118) now uses `smp_wmb()` after critical DTE updates.\n2. `set_iommu_pde_present` (xen/drivers/passthrough/amd/iommu_map.c:54) uses `write_atomic()` for atomic PTE updates.\n3. `amd_iommu_disable_domain_device` (xen/drivers/passthrough/amd/pci_amd_iommu.c:274) includes `smp_wmb()` when disabling translation, ensuring fields are updated in order.\nTrigger chain: During device reassignment (`reassign_device`), `amd_iommu_disable_domain_device` disables translation with memory barriers, followed by `amd_iommu_setup_domain_device` enabling it with ordered updates. This prevents half-updated DTEs.",0.95,./github/other_context/CVE-2020-27670
12,CVE-2021-25924,CWE-352,java,"In GoCD, versions 19.6.0 to 21.1.0 are vulnerable to Cross-Site Request Forgery due to missing CSRF protection at the `/go/api/config/backup` endpoint. An attacker can trick a victim to click on a malicious link which could change backup configurations or execute system commands in the post_backup_script field.",https://github.com/gocd/gocd/commit/7d0baab0d361c377af84994f95ba76c280048548,#000 - Add missing Content-Type check,1,"[{""func_name"": ""setupRoutes"", ""file_path"": ""api/api-backup-config-v1/src/main/java/com/thoughtworks/go/apiv1/backupconfig/BackupConfigControllerV1.java"", ""func_code"": ""@Override\n    public void setupRoutes() {\n        path(controllerBasePath(), () -> {\n            before(\""\"", mimeType, this::setContentType);\n\n\n            // change the line below to enable appropriate security\n            before(\""\"", mimeType, this.apiAuthenticationHelper::checkAdminUserAnd403);\n\n            get(\""\"", mimeType, this::show);\n\n            post(\""\"", mimeType, this::createOrUpdate);\n            put(\""\"", mimeType, this::createOrUpdate);\n\n            delete(\""\"", mimeType, this::deleteBackupConfig);\n        });\n    }"", ""target"": 0}]","[{""func_name"": ""setupRoutes"", ""file_path"": ""api/api-backup-config-v1/src/main/java/com/thoughtworks/go/apiv1/backupconfig/BackupConfigControllerV1.java"", ""func_code"": ""@Override\n    public void setupRoutes() {\n        path(controllerBasePath(), () -> {\n            before(\""\"", mimeType, this::setContentType);\n            before(\""/*\"", mimeType, this::setContentType);\n            before(\""\"", mimeType, this::verifyContentType);\n            before(\""/*\"", mimeType, this::verifyContentType);\n\n            // change the line below to enable appropriate security\n            before(\""\"", mimeType, this.apiAuthenticationHelper::checkAdminUserAnd403);\n\n            get(\""\"", mimeType, this::show);\n\n            post(\""\"", mimeType, this::createOrUpdate);\n            put(\""\"", mimeType, this::createOrUpdate);\n\n            delete(\""\"", mimeType, this::deleteBackupConfig);\n        });\n    }""}]","{""function"": 1, ""value"": 1}","[{""source"": ""func_info(func:verifyContentType)"", ""result"": [{""code"": ""    protected void verifyContentType(Request request, Response response) throws IOException {\n        if (!UPDATE_HTTP_METHODS.contains(request.requestMethod().toUpperCase())) {\n            return;\n        }\n\n        boolean requestHasBody = request.contentLength() >= 1 || request.raw().getInputStream().available() >= 1 || \""chunked\"".equalsIgnoreCase(request.headers(\""Transfer-Encoding\""));\n\n        if (requestHasBody) {\n            if (!isJsonContentType(request)) {\n                throw haltBecauseJsonContentTypeExpected();\n            }\n        } else if (request.headers().stream().noneMatch(headerName -> headerName.toLowerCase().equals(\""x-gocd-confirm\""))) {\n            throw haltBecauseConfirmHeaderMissing();\n        }\n    }\n"", ""start_line"": 82, ""end_line"": 96, ""full_name"": ""com.thoughtworks.go.api.ApiController.verifyContentType:void(spark.Request,spark.Response)"", ""file_path"": ""api/api-base/src/main/java/com/thoughtworks/go/api/ApiController.java""}]}, {""source"": ""value_info(file:BackupConfigControllerV1.java, value:mimeType)"", ""result"": {""value_trace"": [{""full_code"": ""MimeType mimeType = MimeType.valueOf(mime)"", ""line"": 108, ""func_name"": ""com.thoughtworks.go.api.ApiController.isJsonContentType:boolean(spark.Request)""}, {""full_code"": ""String mimeType = this.getServletContext().getMimeType(filename)"", ""line"": 100, ""func_name"": ""com.thoughtworks.go.server.web.FileView.getMimeType:java.lang.String(java.lang.String,boolean)""}, {""full_code"": ""mimeType = \""application/octet-stream\"""", ""line"": 102, ""func_name"": ""com.thoughtworks.go.server.web.FileView.getMimeType:java.lang.String(java.lang.String,boolean)""}, {""full_code"": ""mimeType = (String) field.get(controller)"", ""line"": 101, ""func_name"": ""com.thoughtworks.go.spark.RoutesHelper.addDeprecationHeaders:void(com.thoughtworks.go.spark.spring.SparkSpringController)""}], ""struct_var"": ""mimeType"", ""struct_type"": ""org.springframework.util.MimeType"", ""struct_definition"": null}}]","Root cause: Missing CSRF protection in the original `setupRoutes` method (BackupConfigControllerV1.java:58) for the `/go/api/config/backup` endpoint. The `verifyContentType` method (ApiController.java:82-96) enforces Content-Type checks (via `isJsonContentType`) and the `X-GoCD-Confirm` header for state-changing requests. Before the patch, these checks were not applied, allowing forged requests to bypass CSRF protections. The patch adds `before` filters to enforce these checks on all relevant routes.",0.95,./github/other_context/CVE-2021-25924
13,CVE-2021-29481,CWE-312,java,"Ratpack is a toolkit for creating web applications. In versions prior to 1.9.0, the default configuration of client side sessions results in unencrypted, but signed, data being set as cookie values. This means that if something sensitive goes into the session, it could be read by something with access to the cookies. For this to be a vulnerability, some kind of sensitive data would need to be stored in the session and the session cookie would have to leak. For example, the cookies are not configured with httpOnly and an adjacent XSS vulnerability within the site allowed capture of the cookies. As of version 1.9.0, a securely randomly generated signing key is used. As a workaround, one may supply an encryption key, as per the documentation recommendation.",https://github.com/ratpack/ratpack/commit/d7d240c06536a8b89a917e4ac842c337f7ea31f0,Encrypt client side session cookies by default,8,"[{""func_name"": ""randomString"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""private static String randomString(int byteLength) {\n    byte[] bytes = new byte[byteLength];\n    try {\n      SecureRandom.getInstanceStrong().nextBytes(bytes);\n    } catch (NoSuchAlgorithmException e) {\n      throw new UncheckedException(e);\n    }\n    return new String(bytes, StandardCharsets.ISO_8859_1);\n  }"", ""target"": 1}, {""func_name"": ""setSecretKey"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""public void setSecretKey(String secretKey) {\n    this.secretKey = secretKey;\n  }"", ""target"": 2}, {""func_name"": ""crypto"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionModule.java"", ""func_code"": ""@Provides\n  @Singleton\n  Crypto crypto(ClientSideSessionConfig config) {\n    if (config.getSecretKey() == null || config.getCipherAlgorithm() == null) {\n      return NoCrypto.INSTANCE;\n    } else {\n      return new DefaultCrypto(config.getSecretKey().getBytes(CharsetUtil.UTF_8), config.getCipherAlgorithm());\n    }\n  }"", ""target"": 0}, {""func_name"": ""signer"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionModule.java"", ""func_code"": ""@Provides\n  @Singleton\n  Signer signer(ClientSideSessionConfig config) {\n    byte[] token = config.getSecretToken().getBytes(CharsetUtil.UTF_8);\n    return new DefaultSigner(new SecretKeySpec(token, config.getMacAlgorithm()));\n  }"", ""target"": 0}, {""func_name"": ""setCipherAlgorithm"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""public void setCipherAlgorithm(String cipherAlgorithm) {\n    this.cipherAlgorithm = cipherAlgorithm;\n  }"", ""target"": 2}, {""func_name"": ""getCipherAlgorithm"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""public String getCipherAlgorithm() {\n    return cipherAlgorithm;\n  }"", ""target"": 2}, {""func_name"": ""getSecretKey"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""public String getSecretKey() {\n    return secretKey;\n  }"", ""target"": 2}, {""func_name"": ""setSecretKey"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""@Nullable\n  public void setSecretKey(String secretKey) {\n    this.secretKey = secretKey;\n  }"", ""target"": 2}]","[{""func_name"": ""randomString"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""private static String randomString(int byteLength) {\n    byte[] bytes = new byte[byteLength];\n    SECURE_RANDOM.nextBytes(bytes);\n    return new String(bytes, StandardCharsets.ISO_8859_1);\n  }""}, {""func_name"": ""setSecretKey"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""@Nullable\n  public void setSecretKey(String secretKey) {\n    this.secretKey = secretKey;\n  }""}, {""func_name"": ""crypto"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionModule.java"", ""func_code"": ""@Provides\n  @Singleton\n  Crypto crypto(ClientSideSessionConfig config) {\n    if (config.getSecretKey() == null || config.getCipherAlgorithm() == null) {\n      return NoCrypto.INSTANCE;\n    } else {\n      return new DefaultCrypto(config.getSecretKey().getBytes(CharsetUtil.ISO_8859_1), config.getCipherAlgorithm());\n    }\n  }""}, {""func_name"": ""signer"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionModule.java"", ""func_code"": ""@Provides\n  @Singleton\n  Signer signer(ClientSideSessionConfig config) {\n    byte[] token = config.getSecretToken().getBytes(CharsetUtil.ISO_8859_1);\n    return new DefaultSigner(new SecretKeySpec(token, config.getMacAlgorithm()));\n  }""}, {""func_name"": ""setCipherAlgorithm"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""public void setCipherAlgorithm(@Nullable String cipherAlgorithm) {\n    this.cipherAlgorithm = cipherAlgorithm;\n  }""}, {""func_name"": ""getCipherAlgorithm"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""@Nullable\n  public String getCipherAlgorithm() {\n    return cipherAlgorithm;\n  }""}, {""func_name"": ""getSecretKey"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""@Nullable\n  public String getSecretKey() {\n    return secretKey;\n  }""}, {""func_name"": ""setSecretKey"", ""file_path"": ""ratpack-session/src/main/java/ratpack/session/clientside/ClientSideSessionConfig.java"", ""func_code"": ""public void setSecretKey(@Nullable String secretKey) {\n    this.secretKey = secretKey;\n  }""}]","{""code"": 4}","[{""source"": ""code_info(file:ClientSideSessionModule.java, lines:140-160)"", ""result"": ""      return new DefaultCrypto(config.getSecretKey().getBytes(CharsetUtil.ISO_8859_1), config.getCipherAlgorithm());\n    }\n  }\n\n}\n""}, {""source"": ""code_info(file:ClientSideSessionModule.java, lines:100-130)"", ""result"": "" *\n * <h3>Notes</h3>\n * <p>\n * The max cookie size for a client is 4k so it's important to keep\n * this in mind when using the {@link ClientSideSessionModule}\n * <p>\n * By default your session will be signed but not encrypted. This is because the <strong>secretKey</strong>\n * is not set by default. That is, your users will not be able to tamper with the\n * cookie but they can still read the key value pairs that you have set. If you want to render\n * the entire cookie unreadable make sure you set a <strong>secretKey</strong>\n * <p>\n * When setting your own <strong>secretKey</strong> and <strong>cipherAlgorithm</strong>\n * make sure that the key length is acceptable according to the algorithm you have chosen.\n * <p>\n * When working in multi instances environment the\n * {@code secretToken} has to be the same for every ratpack instance configuration.\n * <p>\n * If your application does not require a unique {@link SessionId} for other reasons,\n * consider replacing the default implementation with {@link SessionId#empty()} to avoid setting the session ID header.\n */\npublic class ClientSideSessionModule extends ConfigurableModule<ClientSideSessionConfig> {\n\n  @Override\n  protected void configure() {\n    bind(SessionStore.class).to(ClientSideSessionStore.class).in(Scopes.SINGLETON);\n  }\n\n  @Provides\n  @Singleton\n  Signer signer(ClientSideSessionConfig config) {\n    byte[] token = config.getSecretToken().getBytes(CharsetUtil.ISO_8859_1);\n""}, {""source"": ""code_info(file:ClientSideSessionModule.java, lines:50-99)"", ""result"": "" *   public static void main(String... args) throws Exception {\n *     EmbeddedApp.of(s -> s\n *       .registry(Guice.registry(b -> b\n *         .module(SessionModule.class, config -> {\n *           //config.path(\""/\"").domain(\""www.example.com\"");\n *         })\n *         .module(ClientSideSessionModule.class, config -> {\n *           config.setSessionCookieName(\""session_name\"");\n *           config.setSecretToken(\""your token for signing\"");\n *           //config.setSecretKey(\""key for cipher\"");\n *           //config.setMacAlgorithm(\""MAC algorithm for signing\"");\n *           //config.setCipherAlgorithm(\""Cipher Algorithm\"");\n *           //config.setMaxSessionCookieSize(1024);\n *           //config.setMaxInactivityInterval(Duration.ofSeconds(60));\n *         })\n *       ))\n *       .handlers(chain -> chain\n *         .get(ctx -> {\n *           ctx.get(Session.class).getData()\n *             .map(d -> d.get(SessionKey.ofType(\""value\"", \""value\"")).orElse(\""not set\""))\n *             .then(ctx::render);\n *         })\n *         .get(\""set/:value\"", ctx -> {\n *           ctx.get(Session.class).getData().then(d -> {\n *             d.set(\""value\"", ctx.getPathTokens().get(\""value\""));\n *             ctx.render(d.get(SessionKey.ofType(\""value\"", \""value\"")).orElse(\""not set\""));\n *           });\n *         })\n *       )\n *     )\n *     .test(client -> {\n *       ReceivedResponse response = client.get();\n *       assertEquals(\""not set\"", response.getBody().getText());\n *       assertFalse(\""No cookies should be set\"", response.getHeaders().getAll(\""Set-Cookie\"").contains(\""session_name\""));\n *\n *       response = client.get(\""set/foo\"");\n *       assertEquals(\""foo\"", response.getBody().getText());\n *       assertTrue(\""We set a value and our session name\"", response.getHeaders().getAll(\""Set-Cookie\"")\n *          .stream()\n *          .anyMatch(c -> c.startsWith(\""session_name\"")));\n *\n *       response = client.get();\n *       assertEquals(\""foo\"", response.getBody().getText());\n *       assertFalse(\""We did not update session\"", response.getHeaders().getAll(\""Set-Cookie\"")\n *          .stream()\n *          .anyMatch(c -> c.startsWith(\""session_name\"")));\n *     });\n *   }\n * }\n * }</pre>\n""}, {""source"": ""code_info(file:ClientSideSessionConfig.java, lines:1-50)"", ""result"": ""  private static String randomString(int byteLength) {\n    byte[] bytes = new byte[byteLength];\n    try {\n      SecureRandom.getInstanceStrong().nextBytes(bytes);\n    } catch (NoSuchAlgorithmException e) {\n      throw new UncheckedException(e);\n    }\n    return new String(bytes, StandardCharsets.ISO_8859_1);\n  }\n\n  private String sessionCookieName = \""ratpack_session\"";\n  private String secretToken = randomString(64);\n  private String macAlgorithm = \""HmacSHA1\"";\n  private String secretKey = randomString(16);\n  private String cipherAlgorithm = \""AES/CBC/PKCS5Padding\"";\n  private int maxSessionCookieSize = 1932;\n  private Duration maxInactivityInterval = Duration.ofHours(24);\n\n  /**\n   * The name of the {@code cookie} used to store serialized and encrypted session data.\n   * <p>\n   * If length of the serialized session is greater than {@link #getMaxSessionCookieSize()} it is partioned into more\n   * cookies. Every session cookie has a postfix {@code _index}, where {@code index} is the partition number.\n   * <p>\n   * <b>Defaults to: </b> {@code ratpack_session}\n   *\n   * @return the name of the {@code cookie} used to store session data.\n   */\n  public String getSessionCookieName() {\n    return sessionCookieName;\n  }\n\n  /**\n   * Set the {@code cookie} name used to store session data.\n   *\n   * @param sessionCookieName a {@code cookie} name used to store session data\n   */\n  public void setSessionCookieName(String sessionCookieName) {\n    this.sessionCookieName = sessionCookieName;\n  }\n\n  /**\n   * The name of the {@code cookie} used to store session's last access time.\n   * <p>\n   * Last access time is updated on every session load or store\n   *\n   * @return the name of the {@code cookie} with session's last access time\n   */\n  public String getLastAccessTimeCookieName() {\n    return LAST_ACCESS_TIME_TOKEN;\n""}]","1. Insecure key derivation via UTF-8 encoding in `ClientSideSessionModule.java:128` (signer) and `ClientSideSessionModule.java:138` (crypto) allowed ambiguous byte representations of secret keys.\n2. Sessions were signed but not encrypted by default (`ClientSideSessionModule.java:100-130`), requiring manual `secretKey` configuration.\n3. Version 1.9.0 switched to ISO-8859-1 for deterministic key bytes and introduced a default `secretKey` generated via `ClientSideSessionConfig.java:secretKey = randomString(16)`, which uses `SecureRandom.getInstanceStrong()` to create a cryptographically secure 16-byte key.\n4. This enabled encryption by default, addressing the vulnerability where unencrypted session data could be exposed if cookies leaked (e.g., via XSS).",0.95,./github/other_context/CVE-2021-29481
14,CVE-2021-25931,CWE-352,java,"In OpenNMS Horizon, versions opennms-1-0-stable through opennms-27.1.0-1; OpenNMS Meridian, versions meridian-foundation-2015.1.0-1 through meridian-foundation-2019.1.18-1; meridian-foundation-2020.1.0-1 through meridian-foundation-2020.1.6-1 are vulnerable to CSRF, due to no CSRF protection at `/opennms/admin/userGroupView/users/updateUser`. This flaw allows assigning `ROLE_ADMIN` security role to a normal user. Using this flaw, an attacker can trick the admin user to assign administrator privileges to a normal user by enticing him to click upon an attacker-controlled website.",https://github.com/OpenNMS/opennms/commit/607151ea8f90212a3fb37c977fa57c7d58d26a84,NMS-13124: Fixed user deletion by renaming bug and CSRF privilege escalation issue,1,"[{""func_name"": ""renameUser"", ""file_path"": ""opennms-config/src/main/java/org/opennms/netmgt/config/UserManager.java"", ""func_code"": ""public void renameUser(final String oldName, final String newName) throws Exception {\n        update();\n\n        m_writeLock.lock();\n        \n        try {\n            // Get the old data\n            if (m_users.containsKey(oldName)) {\n                final User data = m_users.get(oldName);\n                if (data == null) {\n                    m_users.remove(oldName);\n                    throw new Exception(\""UserFactory:rename the data contained for old user \"" + oldName + \"" is null\"");\n                } else {\n                    // Rename the user in the user map.\n                    m_users.remove(oldName);\n                    data.setUserId(newName);\n                    m_users.put(newName, data);\n        \n                    // Refresh the groups config first\n                    m_groupManager.update();\n                    \n                    // Rename the user in the group.\n                    m_groupManager.renameUser(oldName, newName);\n        \n                    // Rename the user in the view.\n                    // viewFactory.renameUser(oldName, newName);\n                }\n            } else {\n                throw new Exception(\""UserFactory:rename the old user name \"" + oldName + \"" is not found\"");\n            }\n        \n            _saveCurrent();\n        } finally {\n            m_writeLock.unlock();\n        }\n    }"", ""target"": 0}]","[{""func_name"": ""renameUser"", ""file_path"": ""opennms-config/src/main/java/org/opennms/netmgt/config/UserManager.java"", ""func_code"": ""public void renameUser(final String oldName, final String newName) throws Exception {\n        update();\n\n        m_writeLock.lock();\n        \n        try {\n            // Get the old data\n            if (m_users.containsKey(oldName)) {\n                final User data = m_users.get(oldName);\n                if (data == null) {\n                    m_users.remove(oldName);\n                    throw new Exception(\""UserFactory:rename the data contained for old user \"" + oldName + \"" is null\"");\n                } else {\n                    if (m_users.containsKey(newName)) {\n                        throw new Exception(\""UserFactory: cannot rename user \"" + oldName + \"". An user with the given name \"" + newName + \"" already exists\"");\n                    }\n\n                    // Rename the user in the user map.\n                    m_users.remove(oldName);\n                    data.setUserId(newName);\n                    m_users.put(newName, data);\n        \n                    // Refresh the groups config first\n                    m_groupManager.update();\n                    \n                    // Rename the user in the group.\n                    m_groupManager.renameUser(oldName, newName);\n        \n                    // Rename the user in the view.\n                    // viewFactory.renameUser(oldName, newName);\n                }\n            } else {\n                throw new Exception(\""UserFactory:rename the old user name \"" + oldName + \"" is not found\"");\n            }\n        \n            _saveCurrent();\n        } finally {\n            m_writeLock.unlock();\n        }\n    }""}]","{""function"": 3, ""code"": 7, ""value"": 2}","[{""source"": ""func_info(func:updateUser)"", ""result"": [{""code"": ""    @PUT\n    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n    @Path(\""{userCriteria}\"")\n    public Response updateUser(@Context final SecurityContext securityContext, @PathParam(\""userCriteria\"") final String userCriteria, final MultivaluedMapImpl params) {\n        writeLock();\n        try {\n            if (!hasEditRights(securityContext)) {\n                throw getException(Status.BAD_REQUEST, \""User {} does not have write access to users!\"", securityContext.getUserPrincipal().getName());\n            }\n            final OnmsUser user = getOnmsUser(userCriteria);\n            LOG.debug(\""updateUser: updating user {}\"", user);\n            boolean modified = false;\n            boolean passwordModified = false;\n            boolean hashPassword = false;\n            final BeanWrapper wrapper = PropertyAccessorFactory.forBeanPropertyAccess(user);\n            for(final String key : params.keySet()) {\n                if (wrapper.isWritableProperty(key)) {\n                    final String stringValue = params.getFirst(key);\n                    final Object value = wrapper.convertIfNecessary(stringValue, wrapper.getPropertyType(key));\n                    wrapper.setPropertyValue(key, value);\n                    modified = true;\n                }\n                if (key.equals(\""password\"")) {\n                    passwordModified = true;\n                } else if (key.equals(\""hashPassword\"")) {\n                    hashPassword = Boolean.valueOf(params.getFirst(\""hashPassword\""));\n                }\n            }\n            if (modified) {\n                LOG.debug(\""updateUser: user {} updated\"", user);\n                try {\n                    if (passwordModified && hashPassword) hashPassword(user);\n                    m_userManager.save(user);\n                } catch (final Throwable t) {\n                    throw getException(Status.INTERNAL_SERVER_ERROR, t);\n                }\n                return Response.noContent().build();\n            }\n            return Response.notModified().build();\n        } finally {\n            writeUnlock();\n        }\n    }\n"", ""start_line"": 137, ""end_line"": 179, ""full_name"": ""org.opennms.web.rest.v1.UserRestService.updateUser:javax.ws.rs.core.Response(javax.ws.rs.core.SecurityContext,java.lang.String,org.opennms.web.rest.support.MultivaluedMapImpl)"", ""file_path"": ""opennms-webapp-rest/src/main/java/org/opennms/web/rest/v1/UserRestService.java""}]}, {""source"": ""code_info(file:UserController.java, lines:1-50)"", ""result"": ""error code""}, {""source"": ""value_info(file:UserManager.java, value:ROLE_ADMIN)"", ""result"": {""value_trace"": [{""full_code"": ""String Authentication.ROLE_ADMIN = \""ROLE_ADMIN\"""", ""line"": 72, ""func_name"": ""org.opennms.web.api.Authentication.<clinit>:void()""}], ""struct_var"": ""ROLE_ADMIN"", ""struct_type"": null, ""struct_definition"": null}}, {""source"": ""code_info(file:UserRestService.java, lines:180-200)"", ""result"": ""\n    @PUT\n    @Path(\""{userCriteria}/roles/{roleName}\"")\n    public Response addRole(@Context final SecurityContext securityContext, @PathParam(\""userCriteria\"") final String userCriteria, @PathParam(\""roleName\"") final String roleName) {\n        writeLock();\n        try {\n            if (!hasEditRights(securityContext)) {\n                throw getException(Status.BAD_REQUEST, \""User {} does not have write access to users!\"", securityContext.getUserPrincipal().getName());\n            }\n            if (! Authentication.isValidRole(roleName)) {\n                throw getException(Status.BAD_REQUEST, \""Invalid role {}!\"", roleName);\n            }\n            final OnmsUser user = getOnmsUser(userCriteria);\n            LOG.debug(\""addRole: updating user {}\"", user);\n            boolean modified = false;\n            if (!user.getRoles().contains(roleName)) {\n                user.getRoles().add(roleName);\n                modified = true;\n            }\n            if (modified) {\n                LOG.debug(\""addRole: user {} updated\"", user);\n""}, {""source"": ""func_info(file:UserRestService.java, func:hasEditRights)"", ""result"": [{""code"": ""    private static boolean hasEditRights(SecurityContext securityContext) {\n        if (securityContext.isUserInRole(Authentication.ROLE_ADMIN) || securityContext.isUserInRole(Authentication.ROLE_REST)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n"", ""start_line"": 285, ""end_line"": 291, ""full_name"": ""org.opennms.web.rest.v1.UserRestService.hasEditRights:boolean(javax.ws.rs.core.SecurityContext)"", ""file_path"": ""opennms-webapp-rest/src/main/java/org/opennms/web/rest/v1/UserRestService.java""}]}, {""source"": ""value_info(file:UserManager.java, value:roles)"", ""result"": {""value_trace"": [{""full_code"": ""Map roles = new HashMap<String, List<GrantedAuthority>>()"", ""line"": 99, ""func_name"": ""org.opennms.web.springframework.security.SpringSecurityUserDaoImpl.parseUsers:void()""}, {""full_code"": ""Collection roles = m_roles.get(username)"", ""line"": 149, ""func_name"": ""org.opennms.web.springframework.security.SpringSecurityUserDaoImpl.getAuthoritiesByUsername:java.util.Collection(java.lang.String)""}, {""full_code"": ""List roles = Arrays.asList(new GrantedAuthority[] { ROLE_USER })"", ""line"": 155, ""func_name"": ""org.opennms.web.springframework.security.SpringSecurityUserDaoImpl.getAuthoritiesByUsername:java.util.Collection(java.lang.String)""}, {""full_code"": ""List roles = new ArrayList<>()"", ""line"": 266, ""func_name"": ""org.opennms.netmgt.config.GroupManager.saveGroups:void()""}, {""full_code"": ""Collection roles = m_groupManager.getRoles()"", ""line"": 336, ""func_name"": ""org.opennms.netmgt.config.WebRoleManagerImpl.getRoles:java.util.Collection()""}], ""struct_var"": ""roles"", ""struct_type"": ""java.util.Map"", ""struct_definition"": null}}, {""source"": ""code_info(file:UserRestService.java, lines:1-50)"", ""result"": ""    public OnmsUserList getUsers(@Context final SecurityContext securityContext) {\n        try {\n            return filterUserPasswords(securityContext, m_userManager.getOnmsUserList());\n        } catch (final Throwable t) {\n            throw getException(Status.INTERNAL_SERVER_ERROR, t);\n        }\n    }\n\n    @GET\n    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON, MediaType.APPLICATION_ATOM_XML})\n    @Path(\""whoami\"")\n    public OnmsUser whoami(@Context final SecurityContext securityContext) {\n        final String userName = securityContext.getUserPrincipal().getName();\n        final OnmsUser user = getOnmsUser(userName);\n        // Don't expose the user's password\n        if (user != null) {\n            user.setPassword(null);\n            user.setPasswordSalted(null);\n        }\n        return user;\n    }\n\n    @GET\n    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON, MediaType.APPLICATION_ATOM_XML})\n    @Path(\""{username}\"")\n    public OnmsUser getUser(@Context final SecurityContext securityContext, @PathParam(\""username\"") final String username) {\n        final OnmsUser user = getOnmsUser(username);\n        return filterUserPassword(securityContext, user);\n    }\n\n    @POST\n    @Consumes(MediaType.APPLICATION_XML)\n    public Response addUser(@Context final SecurityContext securityContext, @Context final UriInfo uriInfo, final OnmsUser user, @QueryParam(\""hashPassword\"") final boolean hashPassword) {\n        writeLock();\n        try {\n            if (!hasEditRights(securityContext)) {\n                throw getException(Status.BAD_REQUEST, \""User {} does not have write access to users!\"", securityContext.getUserPrincipal().getName());\n            }\n            LOG.debug(\""addUser: Adding user {}\"", user);\n            try {\n                if (hashPassword) hashPassword(user);\n                m_userManager.save(user);\n            } catch (final Throwable t) {\n                throw getException(Status.INTERNAL_SERVER_ERROR, t);\n            }\n            return Response.created(getRedirectUri(uriInfo, user.getUsername())).build();\n        } finally {\n            writeUnlock();\n        }\n    }\n""}, {""source"": ""func_info(func:isValidRole)"", ""result"": [{""code"": ""    public static boolean isValidRole(String role) {\n        loadRoles();\n        return s_availableRoles.contains(role);\n    }\n"", ""start_line"": 117, ""end_line"": 120, ""full_name"": ""org.opennms.web.api.Authentication.isValidRole:boolean(java.lang.String)"", ""file_path"": ""opennms-web-api/src/main/java/org/opennms/web/api/Authentication.java""}]}, {""source"": ""code_info(file:*, lines:1-200)"", ""result"": ""error code""}, {""source"": ""code_info(file:*, lines:1-200)"", ""result"": ""error code""}, {""source"": ""code_info(file:*, lines:1-200)"", ""result"": ""error code""}, {""source"": ""code_info(file:*, lines:1-200)"", ""result"": ""error code""}]","opennms-webapp-rest/src/main/java/org/opennms/web/rest/v1/UserRestService.java:137-179: updateUser endpoint lacks CSRF protection and allows arbitrary role updates. The BeanWrapper in updateUser processes parameters (including 'roles') without CSRF tokens. Authentication.java:72 defines ROLE_ADMIN, but isValidRole (Authentication.java:117-120) only validates role names, not assigners. hasEditRights (UserRestService.java:285-291) checks for admin privileges but does not prevent CSRF. GAP: No CSRF protection mechanisms (e.g., filters, tokens) are implemented.",0.95,./github/other_context/CVE-2021-25931
